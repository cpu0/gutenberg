Best 

Available 

Copy 





AD-A286 140 


(D 


NAVAL POSTGRADUATE SCHOOL 
Monterey, California 



A HYPERTEXT-BASED INTELLIGENT LEARNING 
ENVIRONMENT FOR THE X WINDOW SYSTEM 

by 

James Michael Delani Jr. 

September 1994 

Thesis Advisor: Yuh-jeng Lee 

Approved for public release; distribution is unlimited. 



94 11 10 


j 








REPORT DOCUMENTATION PAGE 

Form Approved 

OMB No. 0704-0188 

Public reporting burdon tor this collection ot information a estimated to average 1 hour per response, mckidmg the time reviewing instructions, searching exetmg data sources 
gat her ng and maintaining the data needed, and completing and reviewing the collection ot information Send comments regarding tho burden estimate or any other aspect ot this 
collection ol information, including suggestions for reducing this burden to Washington Headquarters Services. Directorate lor Information Operations and Reports. 1215 Jefferson 

Davis Highway, Suite 1204, Arlington. VA 22202-4302, and to the Office of Management and Budget, Paperwork Reducten Project (0704-0168). Washington. DC 20503 

rewd:wiiwj.\ , i¥mrv; , nrRni^MHiird-j«T.Yi;y57^— 


4. TITLE AND SUBTITLE 

A HYPERTEXT-BASED INTELLIGENT LEARNING 
ENVIRONMENT FOR THE X WINDOW SYSTEM (U) 

S. FUNDING NUMBERS 

6. AUTHOR(S) 

Delani, James Michael Jr. 

7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

Naval Postgraduate School 

Monterey, CA 93943-5000 

8. PERFORMING ORGANIZATION 

REPORT NUMBER 

9. SPONSORING/ MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

10. SPONSORING/ MONITORING 

AGENCY REPORT NUMBER 

11. SUPPLEMENTARY NOTES 

The views expressed in this thesis are those of the author and do not reflect the official policy or position 
of the Department of Defense or the United States Government. 

12a. DISTRIBUTION, AVAILABILITY STATEMENT 

Approved for public release; distribution is unlimited. 

12b. DISTRIBUTION CODE 

A 

13. ABSTRACT ( Maximum 200 words) 

Intelligent tutoring systems have failed to achieve practical benefits commensurate with their potential for time 
savings, increased efficiency, and improved effectiveness. The problem consists of three inter-related factors. First, the 
complexity and computational requirements of these systems often causes user interface design to be relegated to an ancillary 
role in the development cycle. Second, creating an effective and usable interface is an inherently difficult task that often 
requires as much time and effort as the logical components. Finally, the lack of an intuitive and navigable interface interferes 
with the student's primary task of learning new material, precluding the success of these systems. 

Our approach is to provide an alternative framework for tutorial developers which assumes the burden of interface 
design. This framework consists of a hypertext-based instructional format that authors can easily convert their lessons into, 
facilitating rapid prototype development. By creating an Intelligent Learning Environment (ILE) designed to dynamically 
integrate hypertext-based tutors and reference materials, we can also provide users with a consistent, familiar, and highly 
navigable interface which will simplify the learning process. 

Using this approach we have successfully implemented an integrated environment for the X Window System. We 
have created a course of instruction for the Ada programming language, including the Ada 9X Language Reference Manual in 
hypertext format. The ILE may be dynamically extended through the modification of a text-based configuration file. This 
enables additional hypertext-based tutorials, reference manuals, and help systems to be incorporated into the learning 
environment without requiring recompilation. This also allows developers to dynamically extend the functionality of individual 
tutor systems through the incorporation of student evaluation modules, software testing tools, or syntax directed editors. 

14. SUBJECT TERMS 

Intelligent Tutoring Systems, Intelligent Computer Aided Instruction, 
Computer Based Training, X Window Applications 

15. NUMBER OF PAGES 

128 

16. PRICE CODE 

17. SECURITY CLASSIFICATION 18. SECURITY CLASSIFICATION 

OF REPORT OF THIS PAGE 

Unclassified Unclassified 

19. SECURITY CLASSIFICATION 

OF ABSTRACT 

Unclassified 

20. LIMITATION OF ABSTRACT 

UL 


NSN 7540-01-280-5500 Standard Form 298 (Rev. 2-89) 


Prescribed by ANSI Std. 239-18 






















II 






Approved for public release; distribution is unlimited 


A HYPERTEXT-BASED INTELLIGENT LEARNING ENVIRONMENT 
FOR THE X WINDOW SYSTEM 


James Michael Delani Jr. 
Captain, United States Marine Corps 
B.S.E.E., Boston University, 1988 


Submitted in partial fulfillment of the 
requirements for the degree of 


MASTER OF SCIENCE IN COMPUTER SCIENCE 


from the 

NAVAL POSTGRADUATE SCHOOL 
September 1994 


Ac O: 

i ; on For 

J 

NT iS 
DTIC 

CRA&I 

TAB 

T1 

U.nan 

Justil 

nounced 

■Ciit/on 

i i 

! 

By. 


i 

Distrit 

— 

jution / 

. j 


AvoiliUiiity Cocos 


Dist 


to 


Av :■! a ; i or 

C-'p’-Cci! 


Author: 


Approved By: 






James Michael Delani Jr. 



Yuh-jeng Lee, Thesis Advisor 



Mantak Shing, Second Reader 



Ted Lewis, Chairman, 
Department of Computer Science 


iii 












ABSTRACT 


Intelligent tutoring systems have failed to achieve practical benefits commensurate 
with their potential for time savings, increased efficiency, and improved effectiveness. The 
problem consists of three inter-related factors. First, the complexity and computational 
requirements of these systems often causes user interface design to be relegated to an 
ancillary role in the development cycle. Second, creating an effective and usable interface 
is an inherently difficult task that often requires as much time and effort as the logical 
components. Finally, the lack of an intuitive and navigable interface interferes with the 
student's primary task of learning new material, precluding the success of these systems. 

Our approach is to provide an alternative framework for tutorial developers which 
assumes the burden of interface design. This framework consists of a hypertext-based 
instructional format that authors can easily convert their lessons into, facilitating rapid 
prototype development. By creating an Intelligent Learning Environment (ILE) designed 
to dynamically integrate hypertext-based tutors and reference materials, we can also 
provide users with a consistent, familiar, and highly navigable interface which will simplify 
the learning process. 

Using this approach we have successfully implemented an integrated environment 
for the X Window System. We have created a course of instruction for the Ada 
programming language, including the Ada 9X Language Reference Manual in hypertext 
format. The ILE may be dynamically extended through the modification of a text-based 
configuration file. This enables additional hypertext-based tutorials, reference manuals, 
and help systems to be incorporated into the learning environment without requiring 
recompilation. This also allows developers to dynamically extend the functionality of 
individual tutor systems through the incorporation of student evaluation modules, software 
testing tools, or syntax directed editors. 









TABLE OF CONTENTS 


I. INTRODUCTION. 

A. BACKGROUND. 

B. GOALS AND OBJECTIVES. 

C. SCOPE. 

D. ORGANIZATION. 

II. INTELLIGENT SYSTEMS. 

A. INTRODUCTION. 

B. CURRENT TUTORING PARADIGMS. 

1. Mixed Initiative Tutors. 

2. Diagnostic Tutors. 

3. Microworlds. 

4. Articulate Expert Systems. 

5. Coaches. 

C. EVALUATING INTELLIGENT TUTORING SYSTEMS 

D. A CRITICAL VIEW. 

III. DESIGN CONSIDERATIONS. 

A. INTEGRATED SYSTEM DESIGN. 

B. SYSTEM SPECIFICATIONS. 

C. USER INTERFACE. 

1. Graphical User Interface. 

2. Selecting an Interface Development Platform. 

3. Providing Hypertext Capabilities. 

D. PORTABILITY. 

E. EXTENSIBILITY. 

IV. IMPLEMENTATION DETAILS. 

A. SYSTEM OVERVIEW. 


vii 


.. 1 
. 1 
.. 3 
.. 3 
.4 
.. 5 
. 5 
. 6 
. 6 
.7 
. 7 
.. X 
. X 
. X 
. 9 
13 

13 

14 

15 

15 

16 
IX 
20 
22 
25 


25 


































B. INITIAL SETUP REQUIREMENTS.25 

C. CONTROL CENTER.27 

D. SUBSYSTEM OPERATION.28 

1. Reference Mode.29 

2. Tutor Mode.30 

E. ADDITIONAL FUNCTIONALITY.31 

F. EXTENDING THE LEARNING ENVIRONMENT.33 

G. CROSS PLATFORM CAPABILITY.34 

V. CREATING AN ADA TUTOR.35 

A. DEVELOPING A PROTOTYPE TUTORIAL.35 

B. ADDING CODE EVALUATION MECHANISM.38 

1. Evaluator Interface.38 

2. Expert System Code Evaluator.41 

VI. A DETAILED EXAMPLE.43 

A. SAMPLE USER SESSION.43 

1. Selecting the Ada Tutorial.44 

2. Activating Special Links.51 

B. EXTENDING THE APPLICATION.52 

C. EXTENDING THE APPLICATION BY THE USER.53 

D. ADDING SOFTWARE ENGINEERING TOOLS.54 

VII. CONCLUSIONS.57 

A. ACCOMPLISHMENTS.57 

B. FUTURE WORK.58 

APPENDIX A. SYSTEM ADMINISTRATION.59 

APPENDIX B. SOURCE CODE.67 

REFERENCES. 111 

BIBLIOGRAPHY. 113 

INITIAL DISTRIBUTION LIST. 117 


































LIST OF FIGURES 


1. X Window System Hierarchy .17 

2. ILE Setup File .26 

3. Sample Configuration File.27 

4. System Menu .28 

5. Quiz Formatting Codes.32 

6. Quiz Solution Format.33 

7. Sample Lesson in Ascii Format.36 

8. Sample Lesson in HTML Format .36 

9. User’s View of Sample Lesson.37 

10. Initial Screen of Evaluator Interface .39 

11. Analysis of User’s Solution .40 

12. Opening Screen.43 

13. Subsystem Menus .44 

14. Starting the Ada Tutorial .45 

15. Results of Hypertext Jump.46 

16. Selecting a Specific Topic .47 

17. Selecting the Back Button.48 

18. Jumping to Related Topic .49 

19. Quiz and Program Options.50 

20. Activating the Default Quiz.51 

21. Activating the Code Evaluator.52 

22. Sample User Configuration.54 


ix 


J 




























I. INTRODUCTION 


A. BACKGROUND 

The primary advantage of individualized instruction is that it provides the student 
with an environment specifically tailored to his or her learning needs and goals. The 
promise of achieving the effectiveness of personalized instruction without incurring the 
high cost of personal tutors has been one of the driving factors in the research and 
development efforts in the field of computer-aided instruction (CAI). Early efforts were 
less than successful due to the prohibitive cost and limited capability of existing hardware 
and software. Despite revolutionary advances in both the hardware and software industry, 
CAI applications have still failed to deliver on their promise for time savings, higher 
efficiency, and improved effectiveness. 

Kearsley [Kear87] attributes the field’s inability to achieve practical benefits to 
three critical factors: the computational requirements of these systems; the lack of an 
adequate research basis to properly understand learning strategies; and the lack of 
researchers and scientists involved in CAI. Although these factors have certainly had 
substantial limiting influences, the field has still experienced tremendous advances in the 
quality and sophistication of these systems. An even greater factor in the success of these 
systems that is often overlooked is the quality of the user interface. 

One of the major problems with traditional programmed instruction is that it 
confines the student to a prescribed and immutable sequence of screen presentations, which 
expedites the inevitable loss of interest. Recent efforts have shifted the focus of 
development on creating student models designed to completely represent current levels of 
understanding, comprehension, and ability to apply problem solving skills. The problem 
with these systems is that the tools needed to develop these elaborate models have 
interfered with the student’s primary task of exploring and learning new information. 

The problem is further exacerbated by the conflicting goals of the principle 
communities involved with the development of these systems. The primary goals of the 


1 





research community center around the advancement of their respective fields. Often the 
knowledge and insight gained in the development process is of equal or greater importance 
than the finished product. There is little reason to divert their efforts to include 
development of an effective and usable interface when this is not part of their objectives. 
On the other hand, developers who are members of the business community have goals that 
are related to their financial success. They are understandably more concerned with 
creating a polished and usable product, but are much less concerned with advancing the 
research basis of any of the fields involved. 

Our approach is to provide an intelligent learning environment as an alternative 
framework for the development of these systems. By providing a means for tutorial 
developers to intelligently organize and present their instructional material, we can greatly 
facilitate their efforts. This enables them to continue to focus on the computational aspects 
of their systems, since we will be providing the interface mechanisms for them. The 
concept of a learning environment offers substantial advantages to users as well. They are 
provided with a consistent, familiar, and highly navigable user interface that will facilitate 
the learning process. This allows them to focus on their primary task of exploring and 
learning new information. Our objective is to facilitate the learning process, not over¬ 
complicate it. 

We believe that this objective can be accomplished through the simplification of 
two critical areas of existing system models. The first and most dramatic change involves 
abandoning efforts to have the system explicitly model a human tutor in order to replace 
the human element altogether. Tutorials in our system will act as intelligent assistants, 
designed to supplement human teachers or instructional material. We are more interested 
in what the interaction between man and machine can accomplish than in what machines 
can accomplish by themselves. The second change involves strictly enforcing the 
separation of the presentation of instructional material from the student evaluation process. 
This enables our system to facilitate the interaction with its users, providing them with 
complete access and control of the information. Users will still be expected to view the 







instructional material in the order the authors intended, but there will be no control 
mechanisms in place to enforce this. 

B. GOALS AND OBJECTIVES 

The Intelligent Learning Environment (ILE) has been developed to fill a perceived 
void that exists in the area of programming language tutorials. The principle problem area 
is the usability and effectiveness of the tutor system itself. One of the fundamental goals 
of the ILE is to develop an intelligent and useful user interface that can provide a program 
development environment suitable for both novice and advanced programmers. To 
accomplish :his, the environment should be able to integrate the following hypertext based 
materials: instructional tutorials, on-line reference manuals, programming language help 
files, and system help files. In addition, specific mechanisms for extending the capabilities 
of the environment through incorporation of additional software tools must be provided to 
tutorial developers. 

C. SCOPE 

As the underlying goal of this endeavor has been to provide a learning environment 
that is useful to potential students, the main focus of effort has been in providing a usable 
interface which integrates diverse tutoring subsystems and on-line reference materials, not 
in the implementation of a particular language tutorial. Although we have used this tool to 
implement a tutorial in Ada, we could just as easily have provided a tutorial in any 
programming language. Our main concern has been to create an integrated environment 
that is functional, extendible, and most importantly, usable. We have provided 
mechanisms for dynamically extending the environment through the incorporation of 
additional tutoring systems or reference material, and have provided mechanisms for 
dynamically extending the power and functionality of individual tutoring systems through 
the incorporation of additional student evaluation modules, software testing tools, or syntax 
directed editors. 


3 







D. ORGANIZATION 

Chapter II of this thesis provides an overview of intelligent tutoring systems as well 
as an introduction to the evaluation criteria that currently exists for these systems. Chapter 
III discusses the conceptual design of the intelligent learning environment that we have 
developed. In Chapter IV we describe the implementation in greater detail, discussing 
specific design considerations and trade-offs. Chapter V contains a summary of the 
development of an Ada tutorial which has been integrated as a subsystem of the learning 
environment. This exemplifies the ease with which tutorial authors can develop rapid 
prototypes. In Chapter VI we provide a detailed example to demonstrate how the system 
works from the users’s perspective. We also illustrate how easily the system can be 
extended by either tutorial developers, system administrators, or users themselves. Finally, 
in Chapter VII we present our conclusions and ideas for future work. 


4 





II. INTELLIGENT SYSTEMS 

A. INTRODUCTION 

Traditional computer applications can be characterized as time-saving tools that 
have automated many of the manual tasks associated with office work, desktop publishing, 
and scientific research and development. They are typically implemented using well 
defined algorithms, and do not attempt to perform creative tasks such as problem solving, 
diagnosis, or planning. Intelligent systems, in contrast, are designed to emulate the human 
thinking process, and have a strong basis in artificial intelligence. Typical applications for 
intelligent systems include natural language processing, speech recognition, robotics, 
computer vision, diagnosis, and tutors. [BiLe91] 

The use of intelligent systems for the development of tutoring applications is the 
focus of this thesis. Although these systems have seen tremendous advances in the past 
decade, the enormous potential for computer-assisted instruction (CAI) has been 
recognized throughout the history of modern computers. Some of the earliest users of CAI 
were members of the computer industry, who, in the late 1950’s, used CAI programs to 
train their personnel [Skin86]. Unfortunately, the cost of the hardware and the complexity 
of the programming languages of that era effectively precluded the use of CAI in 
educational settings. Despite this shortcoming, the possibilities attracted researchers from 
such diverse fields as cognitive psychology, education and training, and of course, 
computer science. 

These prohibitive factors have become virtually inconsequential with the 
technological revolutions that have taken place in the computer hardware and software 
industries. Extensive research and development has also transformed the structure of CAI 
as well. Traditional applications in computer based instruction have primarily consisted of 
sequences of screen presentations that students were required to view in some 
predetermined order. Small sections of the instructional material, often called frames, are 
successively displayed on the screen according to a predefined set of responses from a 


5 






student. This method was prevalent in the 1970s, and is often referred to as frame-oriented 
CA1 [Weng87]. 

Developments in the fields of cognitive studies and artificial intelligence have 
generated significant changes to this model. The traditional methods of programmed 
instruction evolved into intelligent computer-assisted instruction (1CAI), which have 
become more commonly referred to as intelligent tutoring systems (ITS). These systems 
are programs that incorporate three major disciplines: computer science, cognitive 
psychology, and education and training. The field that encompasses these three disciplines 
is often referred to as cognitive science [Kear87]. Within computer science, the fields 
having the most influence are artificial intelligence, software engineering, and human 
factors engineering. Recent trends in ITS development have changed the focus to creating 
elaborate student models that reflect users’ current level of understanding and ability to 
apply problem solving skills. Despite the tranformations that the field of CA1 has 
experienced, it still remains an “attempt to produce computational models of interactive 
knowledge communication”. [Weng87] 

B. CURRENT TUTORING PARADIGMS 

Most of the current examples of intelligent tutoring systems can be classified 
according to one of five teaching strategies or paradigms [Kear87]. 

1. Mixed Initiative Tutors 

Mixed Initiative Tutors are the oldest style of intelligent tutoring systems. This 
method incorporates the Socratic method of teaching by engaging the student in 
conversation and attempting to lead the student to discovery. The tutor first attempts to 
discover the student's specific weaknesses or misconceptions, and then presents 
instructions designed to help the student discover these errors. Examples of this approach 
include the SCHOLAR and SOPHIE programs, both of which are discussed in extensive 

detail in [Weng87], 


6 






2. Diagnostic Tutors 

Diagnostic tutors try to identify the misconceptions a student may have in solving 
a problem by using a catalog or knowledge base of common problems. These systems 
typically focus on problems that stem from conceptual or semantic errors, which extends 
the analysis well beyond the issue of syntactic correctness. Although these tutors are 
suitable for most problem-solving applications, they are easier to implement for problems 
with closed solutions [Kear87], Examples of the diagnostic paradigm include BUGGY, 
DEBUGGY, and PROUST. 

3. Microworlds 

Microworlds involve developing a computational tool that allows a student to 
explore a problem domain. A relatively well known example of this paradigm is the LOGO 
programming environment developed at the Massachusetts Institute of Technology (MIT) 
by Seymour Papert as a tool for teaching mathematics and science to children. LOGO 
combines computational theory and artificial intelligence with Piaget's theory of learning. 
In this theory, people learn by naturally and spontaneously interacting with their 
environment [Pape80]. 

This actually represents a distinct shift in traditional computer based tutoring 
systems. Normally the computer is utilized to teach, or in the case of programmed 
instruction, to “program” the student. In LOGO, the student’s interaction with the tutor 
consists of programming the computer. This provides students with a sense of mastery over 
an otherwise intimidating machine, and simultaneously familiarizes them with conceptual 
ideas from science, mathematics, and the cognitive problem solving process [Pape80]. The 
lack of rigidity, discipline, and absolute control enforced by the tutor is typical of programs 
that use the microworld concept. The student is allowed to explore and discover the various 
relationships and scientific truths contained in the knowledge domain. Inherent in this 
paradigm, then, is the need for some type of supervision and assistance from other than the 
tutor. The astute reader will notice that this paradigm has received quite a bit more analysis 


7 







than the other models presented. This is because Piaget’s theory that people learn by 
naturally and spontaneously interacting with their environment is entirely consistent with 
our thesis. We feel that it is much more important to provide users with a learning 
environment than it is to provide them with a rigidly structured tutorial. 

4. Articulate Expert Systems 

Articulate Expert Systems can explain their decisions, which helps provide 
reasoning or analysis skills to the student. These systems typically consist of expert 
systems, which can be utilized to provide practice in problem solving and decision making 
skills. By providing the reasoning process used to arrive at conclusions in addition to the 
conclusions themselves, these systems help develop the cognitive process. Well known 
examples of these systems include GUIDON and MYCIN [Clan87J. 

5. Coaches 

Coaches observe the student's performance in some problem solving activity and 
provide advice and guidance that will help the student perform better. The complexity of 
these systems stems from the requirement that the tutor knows when in the course of the 
problem solving activity it should interrupt the student and offer advice. Once it has 
interrupted the student, it must also be able to determine the degree of assistance that is 
required to continue with the problem solving effort [Kear87], 

C. EVALUATING INTELLIGENT TUTORING SYSTEMS 

There is a distinct difference in the evaluation criteria that has been established for 
CAI as opposed to the standards typically applied to ITS. The success of CAI programs is 
directly related to the level of instructional effectiveness and efficiency. To ensure the 
quality of these programs there is extensive analysis and review during the development 
process, as well as a validation process following completion [Kear87]. 

With ITS, however, the success is primarily determined by its ability to perform 
those aspects of the system which provide the intelligence to the system. This often 


x 






involves evaluation of special processes involved in the instruction, including the system’s 
inference and reasoning mechanisms, diagnostic capabilities, cognitive process modeling, 
and remediation. Since the researchers involved with ITS come from such diverse fields 
as cognitive psychology, education and training, and computer science, the evaluation 
criteria used in any particular application is heavily influenced by the primary research 
goals of the developers. While this diversity has contributed significantly to the advances 
made in the field of cognitive science, it has also undermined standard software 
development practices. “Apparently, no systematic evaluation procedures (formative or 
summative) have been used in ICA1 to assure the quality of the program during the 
development process or to validate its success after development”. [Kear87] 

While a formal evaluation criteria is not universally used, prominent developers of 
ITS have constructed a set of standards to apply to their own systems. One such set 
proposes that an ITS can be evaluated based on how well it accomplishes four main 
activities: modeling of knowledge and reasoning, communication, cognitive processing, 
and tutoring [Wool92], From this set and the previous discussion we can conclude that the 
primary concern of intelligent tutoring system developers is in ensuring that their systems 
possess sufficient “intelligence” to facilitate the task of knowledge communication. 

D. A CRITICAL VIEW 

As the field of CAI gradually evolved into ITS, the change in priorities and 
development strategies has produced a number of impressive programs. The problem, 
however, is that very few of these systems are actually used. As we discussed in our 
introduction, there are a number of valid reasons that have been provided to explain the lack 
of practical benefits that this field has produced, all of which conveniently overlook one 
critical factor. These systems aren’t being used because they are too hard to use! Users 
who are trying to learn a new subject domain do not need the additional burden of learning 
a clumsy and inefficient interface. By relegating the effectiveness of these systems to a 
secondary role in the development and evaluation process, ITS developers have effectively 


9 





guaranteed that their systems are incapabie of accomplishing their stated purpose of 
tutoring students. 

An assumption that requires considerable rethinking is that these tutoring systems 
shall be the only means for students to gather information and learn the subject matter, and 
that these machines must be able to perform all of the tasks of a human tutor. One of the 
design criteria proposed earlier stated that ITS should be able to dynamically determine a 
student’s learning strategy so that it could employ the most appropriate teaching style from 
its diverse repertoire [Wool92j. This criteria expects computers to demonstrate human 
skills that many professional educators have been unable to master. This also implicitly 
assumes that a sufficient knowledge base or understanding of how people actually learn 
already exists, which is simply not true. “Almost every cognitive scientist would quickly 
acknowledge that our current theories of learning are woefully inadequate to explain or 
predict how people learn.” [Kear87] This lack of an adequate research basis further 
substantiates the requirement that these programs be evaluated on their level of 
instructional effectiveness and efficiency. 

Hamming [Hamm93] has stated unequivocally in several of his classes here at the 
Naval Postgraduate School (NPS) that the focus of computer research and development 
should be on the interaction between man and machine, and what the two of them can 
accomplish together that is important, not what they can do in isolation. Developers of 
intelligent systems seem to have the mistaken belief that in order to demonstrate the 
intelligence of a system it must be capable of acting completely autonomously. Intelligent 
tutoring systems do not have to replace teachers altogether in order to increase efficiency, 
effectiveness, and productivity. They can instead function as intelligent assistants, 
augmenting a particular course of instruction or extending a teacher’s influence (BiLe91 ]. 

Another key consideration that ITS developers overlook is the fact that most of their 
users will have a tangible desire to learn. Students who use these systems do so because 
they are interested in learning a particular knowledge domain, not because they are problem 
students who have been assigned a personal tutor for remediation. ITS developers have 


10 





tried to incorporate a multitude of teaching strategies and diagnostic capabilities so that 
they can accurately match the appropriate teaching and learning strategies. This assumes 
too much of the burden of the learning process. 

The burden of teaching is on the person who wants to teach. The 
burden of learning is on the person who wants to learn; not on the person 
who wants to teach. [Hill77] 

These students already possess the motivation to learn. What is needed of these 
tutorial systems is to facilitate these students’ efforts, to reduce the burden of learning for 
them by organizing and intelligently preparing the knowledge, and by providing an 
efficient and usable mechanism to access this information. 

One of the most critical evaluation criteria of an intelligent tutoring system is its 
interface with the student. How it presents and communicates the subject matter has 
profound influence on its success as a learning tool. Gause and Weinberg [GaWe89] claim 
that a majority of product development efforts fail simply because they produce a product 
that people don’t like or enjoy using. Several examples of tutoring systems whose failure 
has been solely attributed to lack of a usable interface can be found in [ ABCL90], We shall 
conclude our discussion of evaluation criteria with two quotes which succinctly capture the 
essence of our thesis. 

One might have thought that the discussion to this point would 
complete the description of our tutoring systems. We have stated how a 
tutor models a student and how it uses the model to achieve pedagogical 
goals. However, the discussion is abstract and leaves completely 
unspecified what the student actually experiences, which is the computer 
interface. We have learned that design of the interface can make or break 
the effectiveness of the tutor. [ABCL90] 

The significance of this critical aspect has been emphasized in every area of 
computer science. It is evidenced not only in end applications themselves, but in 
programming methodologies as well. If a tool, application, or methodology is 
unnecessarily difficult to learn or use, it simply will not be used, regardless of the potential 
for time savings, improved efficiency, or productivity. 


11 







Intelligent system developers sometimes short change the user 
interface of their programs. Once they succeed in getting the program to 
perform logically, they sometimes consider their job done. But much 
software, possibly otherwise worthwhile, goes unused because the user 
interface is not effective. To interest users in an intelligent system, the 
interface must be so well designed as to be inviting to use and also to inspire 
confidence in the system. [BiLe91] 

What this statement fails to convey is that design of the interface cannot be done at 
the end of the development - it must be developed concurrently with the computational 
aspect. Waiting until the final stages of the software development life cycle to begin work 
on the user interface establishes this attribute as the lowest priority quality attribute, 
effectively guaranteeing substandard results. 


12 






III. DESIGN CONSIDERATIONS 


The idea for the Intelligent Learning Environment grew from the author’s 
frustration with available tutoring systems. In addition to the unnecessarily difficult task 
of learning an entirely new interface for each new tutorial, the interfaces provided were 
often counter-intuitive, clumsy, and an unwelcome burden in the learning process. While 
many of the systems’ developers have created programs which satisfy most of the 
evaluation criteria discussed in the previous section, especially with respect to the 
computational aspect, they seem to have totally disregarded the interface element. 

It is important to realize that the creation of an effective and usable interface for a 
particular application will not solve the problem. Users would still be required to learn a 
new (hopefully superior) interface, and nothing would be done to facilitate the development 
of a consistent and familiar interface among diverse tutorial applications. What is needed 
is a system that not only provides a superior interface, but also provides a mechanism for 
other developers to easily incorporate this interface into their systems as well. It was with 
this goal in mind that the concept of a learning environment was developed. 

A. INTEGRATED SYSTEM DESIGN 

The purpose of developing a tutoring system is to communicate specific knowledge 
to a user or group of users. The development of a tutoring environment involves taking the 
level of abstraction used in development of tutorial applications one step further. Instead 
of developing a single application, creating an environment involves developing a system 
of applications. Inherent in this design is providing a mechanism for integrating a diverse 
set of subsystems. In order to maintain a consistent interface throughout this set, an 
alternative framework must be provided that tutorial developers may easily convert their 
prepared instructional material into. This process is greatly simplified by separating the 
presentation of instructional material from the student evaluation process, thereby creating 
a generic interface mechanism. This provides users with a familiar environment in which 
they can explore and learn different programming languages. They can exploit this 


13 







familiarity and concentrate on the task at hand - learning a new subject matter, without 
having to learn a new system as well. 

B. SYSTEM SPECIFICATIONS 

The intelligent learning environment has been developed to provide an effective 
and consistent means of communicating diverse knowledge domains to its users. In 
addition to providing the framework for intelligent tutoring system development, it also 
provides the means for incorporating hypertext-based on-line reference manuals and help 
systems. The primary purpose of these latter features is to provide users with a tool which 
can be used in subsequent programming endeavors. The usefulness of this environment can 
be enjoyed even by advanced users who have no interest in the tutorial applications. 

As discussed in the previous chapter, the Microworld paradigm is generally 
recognized as the design which is most flexible and gives the most control to the student. 
A student is allowed the freedom to learn about the topics that are of immediate interest, 
thereby increasing the student’s motivation to learn. Although the lack of discipline 
enforced by this paradigm often requires the need for some type of supervision and 
assistance from other than the tutor, this methodology is particularly suitable for tutor 
systems that attempt to cover a broad range of subjects in a single system, or for a group of 
smaller tutor systems all under the control of a single integration system [Camp90], These 
qualities are precisely what is necessary for the development of our integrated environment. 

The fundamental design considerations of the intelligent learning environment can 
be prioritized as follows: 

• Usability 

• Portability 

• Extensibility 

There are two important elements to notice about this priority list. First of all, the 
computational and logical aspects of the system are not even accounted for. This is because 
they are secondary considerations in the design of the learning environment. They are still 
vitally important in the development of the tutorial subsystems, especially in the student 


14 







evaluation components. The second point to be aware of is that these characteristics are 
often conflicting, meaning that improving the quality in one criteria requires diminishing 
the quality of another. In particular, creation of an elaborate and usable interface makes 
maintaining portability extremely challenging, primarily due to the close tie between 
screen manipulation actions and machine architecture [Delo91]. As the underlying goal of 
our development effort is to provide an interface which empowers our users, usability will 
always be the overriding concern. Our first and foremost objective is to facilitate the 
learning process. 

C. USER INTERFACE 

1. Graphical User Interface 

The term graphical user interface (GUI) basically describes an interface that 
utilizes windows, menus, buttons, icons, and other graphical objects which allows users to 
interact with the application through manipulation of a mouse or other pointing device. 
One important consideration is that although the system may contain a multitude of 
modules and subsystems which offer tremendous computational capabilities, these aspects 
are normally transparent to the user of the application. To the end user the interface 
represents the entire system; if the interface is lousy, then so is the system. 

Usability is defined as a combination of the following characteristics [HiHa93j: 

• Ease of learning 

• High speed of user task performance 

• Low user error rate 

• Subjective user satisfaction 

• User retention over time 

In other words, in addition to the qualitative aspects relating to the appearance and 
control mechanisms provided by an application, usability is directly related to the 
efficiency and effectiveness of the interface, as well as to the user’s reaction to the 
interface. It is important to note that this focus on user-centered design often increases the 
level of difficulty in developing the application tremendously. This is one of the reasons 


15 






that this attribute must be addressed early in the software development cycle. Since the 
purpose of our system is to provide a learning environment to its users, it was decided that 
providing an intuitive and easily navigable graphical user interface was a minimum 
requirement of our system. 

2. Selecting an Interface Development Platform 

While research has shown that windowing interfaces are easier to learn and use than 
character-based interfaces, there is a plethora of successful and popular windowing systems 
to choose from. Most notable for personal computer development are the Apple 
Macintosh, Microsoft Windows, and IBM’s OS/2, while MIT’s X Window System, Sun 
Microsystem’s OpenWindows, and Digital Equipment Corporation’s (DEC) 
DECWindows are available for workstations. The X Window System, by virtue of its 
operating system independence and network transparency, offers a great deal more 
flexibility and potential than any of the other systems mentioned. [JoRe92] 

The X Window System is an industry-standard software system that allows 
programmers to develop portable GUIs. It was developed at MIT’s Laboratory for 
Computer Science for Project Athena to fulfill that project’s need for a distributed, 
hardware-independent user interface platform [YoPe92], It was this promise of hardware- 
independence which first attracted us to this windowing platform. The X Window System 
is currently available for UNIX systems, DEC’s VAX/VMS systems, and many personal 
computers. While portability and cross-platform de velopment capabilities represent severe 
limitations of most of the windowing systems listed above, this is not the case for the X 
Window system. The hardware and operating system independence of X make it extremely 
portable and ideally suited for cross-platform development. “To a large extent, X Window 
is the right windowing system at the right time.” [JoRe92] 

The software architecture of the X Window system is actually comprised of several 
layers, as illustrated in Figure 1. At the lowest level above the network protocol is the 
standard C library routines, called Xlib. These routines are the same on every machine 





running X, which provide its operating system independence. The next layer in the 
hierarchy is the Xt lntrinsics library, which is built upon Xlib and offers object-oriented 
capabilities that support user interface development. This functionality is provided by 
widgets, which are basically interface component classes. 



X Applications 



Motif 

Widget Sets 

Athena Open Look 




Xt lntrinsics Toolkit 


X Library (XLIB) 


Figure 1. X Window System Hierarchy 

The widget sets that comprise the layer above the lntrinsics level offer more 
advanced user interface components, each of which is normally comprised of several of the 
Xt widget classes. X application developers normally use these widget sets in their 
programming efforts, since they offer integrated components at an appropriate level of 
abstraction. If specific functionality is required but is not offered at a particular level, 
developers can access the layer which does provide this capability. 

An important difference between X and many other window systems is that X does 
not define or restrict developers to any particular user interface style. In the words of its 
designers, X provides “mechanism without policy.” The Xlib and Xt layers are standard 
because they can support any kind of user interface [NyOr92], Thus, in addition to the 
portability inherent in this windowing environment, X also offers tremendous flexibility to 
application developers as well. 


17 








3. Providing Hypertext Capabilities 

Many of the guidelines for creation of usable interfaces and intelligent tutoring 
systems are contradictory. Part of the problem exists because many of these rules are 
heuristic in nature, especially in the relatively new field of graphical interface design. One 
guideline that appears to be based predominantly on common sense and experience is the 
admonition to use real-world analogies as much as possible [HiHa93]. In order to follow 
this advice we must recognize what analogy we are trying to represent in the first place. 

Trying to create the analogy of a human tutor has thus far consternated many 
tutorial developers, and is the essence of many of the problems with ITS’s today. This is 
one of the primary considerations in our decision to develop a learning environment for the 
user. The possible interactions with a human tutor are potentially unlimited, and would be 
infeasible to implement with current technology and available research. A much simpler 
analogy, that of an instructional manual or book, has still eluded adequate emulation, 
despite it representing the most natural and familiar interface to users. This analogy 
appears to satisfy the criteria that the best interfaces are those that are natural for the task 
that they are designed to perform [Blum92]. While many tutoring systems claim to provide 
this functionality, in reality they fall far short of creating even primitive capabilities. 

Rather than try to incorporate a myriad of tutoring styles into a single application in 
order to accommodate a diverse range of users, we shall instead try to model the paradigm 
of an instructional manual or tutorial that a user is interested in using. Although an author 
of any text book usually intends for the material to be read in the order presented, it would 
be preposterous to somehow restrict or force a reader to follow this sequence. A great deal 
of thought and design considerations went into the format and organization of the material 
to be presented. The order in which each topic is addressed is designed to provide the most 
logical flow of information to its reader, or the expected path to take. There are, however, 
absolutely no mechanisms for enforcing that every user follow this path. The antithesis of 
this, in fact, does exist. Readers are typically provided a table of contents which outlines 
major topics and subtopics, a list of tables and figures, and an extensive index. It would 


IX 





seem that every effort is being made to encourage users not to read this manual 
sequentially, although in reality we know that its designers are merely trying (quite 
successfully) to increase the usefulness of this reference material. It is intuitively obvious 
that any reference material that provided less capability would be inadequate, restrictive, 
and would not be willingly used. 

Similarly, the material presented in most tutorials is designed to be viewed in the 
same sequence as it was prepared, and mechanisms have always been available to do so. If 
additional mechanisms are not also provided to jump around, skim certain sections, or just 
get a feel for the depth of the material, then the user is effectively forced to follow a 
prescribed sequence. By providing the user with the control mechanism afforded through 
incorporation of hypertext capabilities it is possible to more closely model the instructional 
model paradigm. 

Providing hypertext capabilities in the tutorial module requires relinquishing 
explicit control on the part of developers. The prepared and intended sequence of 
instruction has not changed, only the enforcement mechanisms. The degree of control that 
tutorial authors sacrifice is transferred to the users, thereby empowering them with 
complete access and control. If a user is exposed to information that contains related topics 
or ideas that are not completely familiar, it is possible to immediately “jump” to those areas 
and gain the necessary understanding. If the user is already comfortable with these 
concepts, the normal course of instruction is not unnecessarily interrupted by digression. 

While the benefits of incorporating hypertext into the instructional material of a 
tutoring system have been established, we still need a mechanism which could provide 
these capabilities and not degrade our interface. Fortunately, the developers at the National 
Center for Supercomputer Applications (NCSA) have created a hypertext widget that can 
be used with the X Window System, known as the hypertext markup language (HTML) 
widget. This widget is a special purpose object that provides additional functionality not 
found in the widget sets that occupy the upper level of the X Window System hierarchy 
(see Figure 1). This is the same widget that provides the hypertext capabilities for Mosaic 


19 





and most world wide web (WWW) browsers. This widget allows us to provide users with 
the hypertext capabilities from within the graphical environment we have chosen for our 
development platform. 

D. PORTABILITY 

As mentioned in the discussion on design considerations, creating a usable interface 
often precludes maintaining portability. This is not the case, however, with the 
development platform which we have chosen. The X Window System is an industry- 
standard software system that allows programmers to develop portable graphical user 
interfaces. Furthermore, the hypertext widget developed at NCSA is written for the X 
system, which allows us to incorporate this additional capability without any sacrifice in 
portability. 

The code for the HTML widget is written so that is may be used with either the 
Motif widget set or the Athena widget set. These widget sets represent the top layer of the 
X System hierarchy, as shown in Figure 1. Although Motif is emerging as the standard 
among X platforms (and provides a much more polished interface), it is proprietary 
software that is not included with the standard X distribution from MIT. The Motif widget 
set must be purchased separately from the Open System Foundation vendors themselves, 
and restrictions apply to applications developed using their libraries. Since the HTML 
widget can be used with the Athena widget set, we chose to exploit the availability of this 
set over the ease of programming and enhanced features offered by Motif (the Athena 
widget set is included with both Release 4 and 5 distributions from MIT). 

The only major consideration remaining is the choice of the implementation 
language. Of the possible choices, the C programming language represents several distinct 
and significant advantages over other languages. C is widely available and a powerful 
programming language. In addition to being recognized as one of the best languages to use 
in implementing an application for several different machines, C offers excellent 
interfacing capabilities to external routines [Kear871. 


20 






Several other key design considerations also suggest that C be our implementation 
language. While X is not restricted to a single language or operating system, the most 
logical choice of programming languages is C. All of the low-level X library routines, 
called Xlib, are written in C. The Xt Intrinsics library, built upon Xlib (see Figure 1), which 
offers an object-oriented layer that supports the development of user-interface components, 
is also written in C. From the perspective of X application developers, however, the most 
important consideration may very well be the fact that numerous reference books which 
provide detailed examples and instruction are based on the C programming language. 

An additional consideration is that one of the fundamental components of 
intelligent tutoring systems is their student modeling and evaluation component. Often this 
consists of an expert system shell or program which must be integrated into the tutorial. 
One popular expert system language that is often used for such applications is CLIPS, 
which is an acronym for the C Language Integrated Production System. CLIPS was 
designed at NASA/Johnson Space Center with the specific purposes of providing high 
portability, low cost, and easy integration with external systems. CLIPS was written using 
the C programming language to facilitate these objectives. [GiRi94] 

Another feature which would greatly improve the effectiveness of any 
programming language tutorial is the incorporation of a syntax directed editor, which is a 
language-based program editor that can apply knowledge of a language’s context-free 
syntax to ensure that programs are always syntactically correct. They can also be used to 
enforce structured programming techniques or a particular programming style. The 
Synthesizer Generator, [Reps89], is a system that is designed to facilitate the creation of 
these language based editors and other programming tools. The synthesizer generator is 
written in C and runs under the UNIX operating system. 

Finally, the UNIX operating system (also written in C), provides several powerful 
programming utilities for application developers. Of particular interest are the two utilities, 
lex and yacc, which are tools for writing programs that transform structured input. They 
are capable of rapidly producing powerful lexical analyzers, parsers, and other input 


21 






handling programs. These tools automatically generate C program code, which can easily 
be integrated into separate applications or be used to create separately executable programs 
[LeMB92]. These tools are often used to perform the lexical analysis for code evaluators. 

While all of these tools are capable of interfacing with other programming 
languages, they have all beer specifically designed to exploit the portability and excellent 
interfacing capabilities of C. It would therefore seem quite illogical to attempt to 
implement an integrated system in any other programming language. 

E. EXTENSIBILITY 

Our final design consideration is that of extensibility. It is not sufficient to create a 
system that meets all of the known requirements of a particular set of users. This would 
guarantee that the system is obsolete before the completion of testing. The system must be 
flexible enough to accommodate modifications without requiring extensive rework and 
redesign. 

In order to provide this capability we have provided several mechanisms for 
expanding the system. Incorporating some of these mechanisms was actually necessitated 
by our decision to separate the instructional modules from the evaluation modules in order 
to provide non-linear access to the tutorial lessons. By relinquishing explicit control over 
the presentation of material we empowered our users, but forfeited access to standard 
modeling information. Traditional tutoring systems maintain information on which 
screens have been viewed by their users, and use this information in the construction of 
their student models. It is our contention that information on which screens have been 
viewed is irrelevant and misleading, and should not be used in the creation of a student 
model or in controlling the presentation of instructional material. 

There are, however, other means of accurately measuring student understanding 
and mastery. One common method is to administer quizzes to the students, as is done in 
many programming classes. Another is to analyze small sections of code for syntactic and 
semantic correctness. We have provided a simple and straight forward mechanism which 


22 






allows tutorial developers to implement either or both of these capabilities. This 
mechanism also allows independent development and modification of these separate tools, 
which facilitates production of prototype systems which can be tested and evaluated. 
While these features are obviously desirable in many applications, they may not be 
necessary or cost-effective in others. Tutorial developers are free to develop applications 
without any of these capabilities, and merely provide the instructional material as an on¬ 
line reference to augment course instruction. 

Ir. addition to the mechanisms we have incorporated for system administrators and 
tutorial authors to extend the environment, we have also provided a means for end users to 
extend the environment as well. In addition to the standard configuration file that is used 
to dynamically create the menu entries for the system, the environment is also designed to 
accept a configuration file as its only command line argument. The format of this file is 
identical to that of the system configuration file, although it will only affect the current 
invocation of the program. Thus users may develop and incorporate their own on-line 
hypertext help and quick reference manuals for use within the environment. 


23 










IV. IMPLEMENTATION DETAILS 

A. SYSTEM OVERVIEW 

The intelligent learning environment has been designed to dynamically integrate 
diverse tutoring subsystems, on-line reference manuals, and hypertext-help systems into a 
cohesive learning system. The environment is intended to be used on a multi-user system, 
such as UNIX, and to provide system administrators a great deal of flexibility in setting up 
a directory and file-system structure necessary to support this tool. The integration of the 
various subsystems is accomplished through creation of a system control center from which 
users can launch individual applications. These applications are all built upon the same 
basic framework, which provides a consistent look and feel throughout the environment. 
Tutorial developers are freed from the burden of creating an effective interface mechanism, 
and can focus on the preparation of instructional material instead. Although the format for 
the hypertext markup language is fairly straightforward and easy to Ieam, numerous tools 
are available via the internet which can transform several different file formats into the 
HTML format. 

B. INITIAL SETUP REQUIREMENTS 

In order to provide this flexibility to system administrators, two configuration files 
are necessary for the proper execution of the system. The first file is necessary to establish 
the proper path and environment variable settings which allow multiple users to access the 
system. A UNIX environment variable, “ILEHOME”, establishes the full path to the 
directory where the executable program and the second configuration file are located. 
While it is not strictly necessary that the program and configuration files be located in the 
same directory, it does simplify administration. The user’s path must also be modified so 
that it looks for the executable program in the proper directory. A sample setup file is 
shown in Figure 2. The additional information contained in this example is to 
accommodate special external applications, as will be discussed in following sections. 


25 




# Sample setup file for Intelligent Learning Environment 

# First section contains environment settings for system operation 
setenv ILEHOME /usr/local/iledir 

set path = (/usr/local/iledir Spath) 

# Following sections are for setting up special external applications that 

# go with individual tutorials 

# Setup for Ada tutorial 

setenv XADAHELP /usr/local/tutor/ada 
set path = (/usr/local/utils $path) 

# Setup for Clips tutorial 

set path = (/usr/workl/bin Spath) 


Figure 2. ILE Setup File 


Note that on UNIX systems the setup file can be centrally located and that users’ 
“.cshrc” file can be modified to include a statement that reads this file when starting a 
session. This allows an administrator to completely change the hierarchical structure of 
the entire system without affecting every potential user. The single, centrally located file 
can be modified to reflect these changes, maintaining complete access for all users. 

The second file, “ilemenu.dat”, is the system configuration file. The format of this 
file is fairly rigid in order to simplify the parsing requirements. It is through this file that 
the system can be dynamically extended and modified. The format of each line of this file 
consists of the following semi-colon separated fields: 

• Name of Application 

• Type of Application 

• Full path to directory where files are located 

• Name of first file to load (Home Page) 

• Name of auxiliary quiz or testing application 

• Name of auxiliary code evaluator or syntax directed editor front end 

The first entry is the name of the application and its appearance in this file is exactly 
how it will appear in one of the submenus of the system control center. Which specific 


26 







submenu it appears in is determined by the second field, whose valid entries consist of 
“TUTOR”, “MANUAL”, or “HELP”. The next two fields designate the directory in which 
all of the application files are located as well as the first page which is to be loaded when 
the application is selected. The remaining two fields correspond to the names of separately 
executable programs. These fields are only applicable to applications of type “TUTOR”, 
and provide the mechanism by which tutorial developers can incorporate student 
evaluation tools into the system. An example configuration file is shown in Figure 3. The 
actual system configuration file contains additional comments explaining the meaning and 
specific requirements of each field. This file must be named “ilemenu.dat” and be stored 
in the directory identified by the “ILEHOME” environment variable. 


# Sample configuration file for the Intelligent Tutoring System 
<Begin Data> 

Ada Tutorial;TUTOR;/usr/local/tutors/itsAda;itsadaOO.htm;NONE;xAdaEval; 
C Tutorial;TUTOR;/usr/local/tutors/itsCeedir;itsceeOO.htm;NONE;NONE; 
C++ Tutorial;TUTOR;/usr/local/tutors/itsCxx;itscxxOO.htm;NONE;NONE; 
Ada LRM;MANUAL;/usr/local/manual/Ada9x/;rm9x_OO.htm;NONE;NONE: 
Using UNIX:HELP;/usr/local/pub/introCS/;jxxl_OO.htm;NONE:NONE; 

Clips Help;HELP;/usr/local/pub/clips/;ciipsOO.htm;NONE;NONE; 


Figure 3. Sample Configuration File 

Note that because these special application programs identified in fields five and six 
are separately executable, the environment will most likely need to be modified in order to 
provide multiple users access. System administrators can easily modify the system setup 
file to include the information necessary for the proper execution of these external 
applications as well (see Figure 2). 

C. CONTROL CENTER 

In order to minimize the potential of overwhelming new users, a system menu is 
provided which serves as the control center for the environment (see Figure 4). Each of the 


27 







major categories of subsystems is represented on this menu, which should provide an 
intuitive interface to even novice users. Users can select the specific category they wish to 
explore, and are provided a pop-up menu which lists the available applications. 


Tutor 

Manual 

Help 

Exit 


Figure 4. System Menu 


In order to provide extensibility to our system, the topics that comprise each of the 
submenus are determined at run-time by parsing the configuration file, “ilemenu.dat”, as 
discussed in the previous section. This file determines the basic characteristics of the 
system that all users will experience. Advanced users can further extend the selection of 
subtopics available through a command line configuration file. This file must be in the 
same format as the system configuration file, which can conveniently be used as a template. 
The configuration file used as a command line parameter only affects the current execution 
of the program, and provides power users with a means of extending the usefulness of the 
environment even further. For a detailed explanation of this process, see “EXTENDING 
THE APPLICATION BY THE USER” on page 53. 

D. SUBSYSTEM OPERATION 

Although the system menu provides selections for three distinct subsystem areas, 
operation of these subsystems is actually defined by two modes: a tutoring mode and a 
reference mode. The reference mode may be viewed simply as an on-line hypertext 
document browsing tool. The non-linear access provided through hypertext capabilities is 
particularly well suited to reference manuals and help systems. The tutoring subsystem 
provides basically the same capabilities as the reference section, and offers additional 
features not available in the reference mode. It is possible to have both a tutor and reference 
window open concurrently, effectively operating the system in both modes. Although this 
capability is allowed by the environment, users will normally find that most monitors are 


28 











best suited for single mode operation. Below we first discuss the capabilities common to 
both subsystems to provide the conceptual framework necessary to understand operation of 
the integrated environment. 

1. Reference Mode 

Choosing an option from either the manual or help submenus causes a new window 
to be created, displaying the home page of the specific application (as identified in the 
configuration file). This file will be an actual hypertext document, with the hypertext links 
indicated by being underlined. These links can be selected by using the mouse or other 
pointing device to place the cursor over one of these items and pressing the selection 
button. This causes the hypertext link to be executed, which loads the new topic into the 
window. In order to encourage exploration without causing users to get irretrievably lost 
we have provided two mechanisms for backtracking through the sequence of hypertext 
jumps. The “Back” button is a single-step backtrack, reloading the previous document and 
positioning the hypertext link that originally caused the jump at the top of the viewing 
window. If multiple links have been explored and a user has lost a sense of exactly where 
in the document he or she should be, the “Home” button clears the record of previous jumps 
and reloads the home page of the document. 

Once the window has been created users may wish to replace the current material 
with another manual or help section. Rather than require them to close the window and 
restart the reference section, which may involve repositioning and resizing the window, we 
allow users to simply select the new material to be loaded. In order to minimize the 
overhead associated with maintaining the history list of hypertext jumps, once a user selects 
a new subtopic to load all of the backtracking information is cleared from memory, 
effectively restarting this section. This includes replacing the previous home page as well. 

Note that this feature has been included in order to extend the usefulness of the 
application, and is not available from within the tutorial section. The manual and help 
subsystems have been designed to provide on-line hypertext access to reference material 


29 




that may be used externally to any of the tutoring systems, especially in subsequent 
programming endeavors. 

2. Tutor Mode 

We stated that the tutoring subsystem provides fundamentally the same operational 
capabilities as the reference mode, but with additional features. These additional 
capabilities, however, made it imperative that we preclude users from restarting a tutorial 
application without properly closing the currently open one first. This is to enable 
applications to properly save any student modeling information obtained and to close all 
open files. This should not be viewed as a design trade-off, since it would be unreasonable 
to open multiple tutorials or jump from one tutorial to another, a capability quite reasonable 
to expect of reference material. 

The additional capabilities provided by the tutorial subsystem include a quiz 
application and a front end to a myriad of software engineering and testing tools, including 
code evaluators and syntax directed editors. These applications must be identified in the 
configuration file in order to be accessible from within a tutorial application. These 
features have been designed so that they are initiated as hypertext jumps from within the 
tutorial. Rather than load another hypertext document as is done with normal hypertext 
jumps, these special links cause the external applications to be loaded, passing the filename 
associated with the link as a command line parameter. This allows implementation of 
context-sensitive quiz evaluations and programming assignments. 

It is important to note that tutorial developers are not required to incorporate these 
additional features in order to implement a prototype tutorial. We purposely separate ■ the 
process of presenting the instructional material from the student evaluation process in order 
to provide this flexibility. Tutorial authors can easily transform existing course work or 
prepared instructional material into the HTML format needed to provide hypertext 
capabilities and focus on the quality and content of the instructional material without being 
distracted by concurrent development of quizzes, code evaluators, or other tools designed 


30 





to evaluate students and create elaborate student models. Once satisfied with the 
instructional material, tutorial authors can then focus their attention on these other tools. 
More importantly, this allows development teams to work independently on these projects 
as well. Once these external tools are properly tested and validated, they may be 
incorporated into the specific tutoring subsystem through modification of the ascii based 
configuration file. 

E. ADDITIONAL FUNCTIONALITY 

To facilitate the task of tutorial developers and to provide them with an additional 
feature that they can exploit, a default quiz application has been included. Authors may use 
the functionality of this tool in developing prototypes, or as a model in developing their 
own evaluators. We considered it important to include this capability since it provides an 
interrogative capability which can help develop the student’s cognitive process. In addition 
to illustrating key points that may be typical sources of confusion, users are provided with 
explanations as to why certain responses may be correct or incorrect. 

In order to use the default quiz, the corresponding entry in the configuration file 
must be “NONE”. Any other entry will be interpreted as a desire to override the default. 
As indicated in the previous section, these settings only set up the capability within the 
learning environment. Actual calls to these applications are made through hypertext links 
with non-standard filename extensions. The tutor subsystem examines these hypertext 
requests, and determines whether the jump is a standard hypertext jump or a special flag. 
If the jump is special, it then must determine if a corresponding special application has been 
specified. If one has been specified, the application is started via a system call, using the 
filename as a command line argument. If an external application has not been specified, 
then the default quiz function will be called, and this time the filename is passed as the 
parameter. 

The format of the quiz file is almost identical to that of a standard HTML file. The 
differences between the two types of jumps are illustrated in Figure 5. 





The format code for a standard jump is: 

<A HREF=#Anchor>Standard Jump</A> 
which appears to the user as: 

Standard Jump 

The format for a quiz answer is: 

<A HREF=##3_A>(A)</A> Response A<P> 
which appears to the user as: 

(A) Response A 

Figure 5. Quiz Formatting Codes 

The fundamental difference is that selections which designate user responses to the 
quiz questions must be distinguishable from standard hypertext jumps so that the 
application can tell whether the user is attempting to answer a question or jump to an 
alternative question. Note that to the user these links appear identical, and it is within the 
context with which they appear that distinguishes their purpose. The “##3_A” signals the 
quiz processor that this jump represents the user’s choice for question 3 is A. 

When the default quiz application is started it takes control over the system and 
opens a new hypertext window, loading the contents of the filename into the hypertext 
widget. In addition to the prepared quiz file, this function requires a corresponding solution 
file whose filename is identical to that of the quiz file, except that the “quiz” extension is 
replaced with a “soln” extension. Note that both of these files must be present in the tutorial 
application’s directory in order for the quiz to work properly. Failure to locate and read 
either of these files will generate an error message and return control back to the tutorial. 

The format of the solution file is shown below in Figure 6, and has been designed 
to simplify parsing while still providing explanatory comments for each possible response 
to quiz questions. 


32 







QUEST. 1 = B 
ANS_A 

The explanation for answer A goes here, explaining why incorrect. 

END_ANS 

ANS_B 

The justification for this being the correct answer goes here. 

END_ANS 

ANS_C 

A message explaining why C is incorrect goes here. 

END_ANS 

END_QUEST 

Figure 6. Quiz Solution Format 

These messages appear in a popup dialog box in response to the user selecting a 
particular solution. Note that if the responses are too long to fit into the dialog box that 
scrolling capabilities will automatically be incorporated. This provides authors with the 
means of providing a complete and meaningful explanation. 

The solution file can contain up to ten questions, and each question may have up to 
four possible alternatives. It is important for the solutions to match precisely with the 
questions, not only to ensure the accuracy of the responses to the students, but also to 
preclude any unpredictable responses from the system. The results of attempting to retrieve 
the solution to a non-existent question are undefined. 

F. EXTENDING THE LEARNING ENVIRONMENT 

We have already seen how easy it is to extend the environment from the perspective 
of system administrators and tutorial developers. A brief summary of this process is 
included here to ensure complete understanding of this concept. The key to extending the 
environment for all users is the file, “ilemenu.dat”. This file contains the menu entries for 
all of the major subtopics of the system. While the format of this file is fairly rigid, it is 
easy to install additional applications by simply following the examples provided. 

In addition to the capability of adding new tutorials, manuals, and help materials, 
the capabilities of tutorials already incorporated into the environment can be modified as 

33 








well. The last two fields of the configuration file facilitate this process. They correspond 
to external applications that can be invoked through special hypertext links from within the 
tutorial documents. This provides context-sensitive quiz and program evaluation 
capabilities to tutorial developers. As an added feature, authors can use the default quiz 
application which should expedite the prototype development process. 

Finally, users may extend the functionality of the environment for their own 
personal use by invoking the system with a configuration file as a command line parameter. 
This allows users to develop their own personal help files, quick reference files, and other 
program development tools which they may use in future efforts. An example of a typical 
use of this capability would be in the development of an example code or data structures 
help reference. Through the clipboard capabilities afforded by the X Window System, 
users could then cut and paste these examples into their own code, thus ensuring syntactic 
correctness and improving efficiency and productivity. 

G. CROSS PLATFORM CAPABILITY 

The intelligent learning environment has been designed to work on any system 
capable of operating the X Window System. The ILE has been compiled and tested on 
UNIX workstations as well as on a personal computer. The majority of the development 
work was actually completed on an Intel 80486 based personal computer running the Linux 
operating system. This operating system is a freely distributed UNIX clone that is available 
via the Internet. Since the ILE makes only standard C and X Window function calls, any 
system capable of X Window System development should be capable of compiling and 
operating the environment. 


34 






V. CREATING AN ADA TUTOR 


One of the stated benefits of the intelligent learning environment is the ease with 
which tutorial developers can transform their prepared instructional material into the 
appropriate format to be used with our system. In order to substantiate this claim we have 
prepared an Ada tutorial application. The instructional material was obtained from the ITS 
Ada Tutorial developed by DeLooze [Delo91]. This material consisted primarily of screen 
presentations, with the format each screen designed to fit on a standard 80 x 25 (column by 
row) display. In addition to the presentation of instructional material, the original work 
also included several pseudo programming assignments, which attempted to evaluate the 
student’s current level of understanding. The evaluation process had direct influence over 
the presentation of instructional material by requiring students to successfully complete the 
programming assignments before allowing them to view further material. 

One of the criticisms of this tutorial is that the evaluation of student’s solutions 
consisted of direct comparison to an “expert’s” solution, and that a single specific response 
was the only correct answer. An alternative method offered by Hoppe is to incorporate an 
expert system shell which can then be used to evaluate the code. He developed the Clips 
Ada Evaluator (CAE), an expert system shell designed to enhance the evaluation 
capabilities of the ITS Ada system. [Hopp92] 

A. DEVELOPING A PROTOTYPE TUTORIAL 

The first step in the transformation process is to modify the existing instructional 
material so that it is in the proper HTML format. Since the original material was in ascii 
format, we were able to experiment with one of the tools available which automatically 
transforms ascii files into HTML files. While this tool did accomplish the task as 
advertised, a great deal of work was still required in order to clean up the presentation and 
properly interconnect our files in the exact manner we desired. Since the task of 
transforming ascii files into HTML format is so straightforward, we decided to abandon the 
tool and do most of the work by hand. An example of the formatting commands needed to 


35 







transform a text file into the hypertext format is shown below. Figure 7 shows a small 
section of a lesson as it would appear in a standard ascii file. Figure 8 shows this same 
information with the embedded HTML formatting codes. Note that this File is still an ascii 
file, and can be edited and updated with a standard text editor. 


Lesson 8-1 Record Types 

We have seen that by using arrays we can describe data objects that contain many elements. 
One limitation of arrays is that all of the components of an array must be the same type. 
Array types cannot be used to represent real world objects that are made up of different 
types. For this capability, we need what is known as a record type. A record provides the 
means of encapsulating different types of related information into a single logical unit. 

The declaration of a record type is as follows: 
type Person is record 
First : string(1..15); 

Last : string(1.15); 

Age : integer; 

Wage: float; 
end record; 


Figure 7. Sample Lesson in Ascii Format 


<H2>Lesson 8-1 Record Types</H2xP> 

<P>We have seen that by using arrays we can describe data objects that contain many 
elements. One limitation of arrays is that all of the components of an array must be the same 
type. Array types cannot be used to represent real world objects that arc made up of 
different types. For this capability, we need what is known as a record type. A record 
provides the means of encapsulating different types of related information into a single 
logical unit.<P> 

<P>The declaration of a record type is its follows: 

<pre> 

type Person is record 
First : string! 1.. 15); 

Last : string! 1.15); 

Age : integer; 

Wage : float; 
end record; </pre> 


Figure 8. Sample Lesson in HTML Format 


36 












Figure 9 shows how this formatted section of a lesson would actually appear to the 
user. Note the distinct appearance provided by the formatting commands for the various 
parts of this document. Although a discussion of the HTML formatting commands is 
beyond the scope of this thesis, additional information is provided in the system help 
section of the learning environment. 



Lesson 8-1 Record Types 

have seen that by using arrays we can describe 
data objects that contain many elements. One 
limitation of arrays is that all of the components 
of an array must be the same type. Array types 
cannot be used to represent real world objects that 
are made up of different types. For this 
capability. we need what is known as a record type. 
A record provides the means of encapsulating 
different types of related information into a 
single logical unit. 

The declaration of a record type is as follows: 

type Person is record 

First : string(l..15); 

Last : stringd .15); 

Age integer; 

Wage float; 

end record; 


Figure 9. User’s View of Sample Lesson 


Once all of the files were in the HTML format, we then needed to modify the 
lessons to exploit the new screen presentation capabilities. While the previous format 
mandated that all pertinent information appear on a single screen, the scrolling capabilities 
provided by the X Window System provided much more flexibility. Several examples 
could be provided to illustrate each point, and sufficient comments could be added to 
explain key aspects of syntax and programming issues. 

Upon completion of this task, we had a working prototype for the tutorial. While 
we still did not have the student evaluation mechanisms in place, the basic instructional 
material was in place and ready to go. 


37 











B. 


ADDING CODE EVALUATION MECHANISM 


In order to simplify the development process, our initial intention was to 
incorporate the work that Hoppe had done in extending DeLooze’s ITS Ada tutorial 
[Hopp92]. The potential benefits of this code-reuse was the primary motivating factor in 
this decision. Although the promise of time-savings through code-reuse was extremely 
attractive, we also recognized that this would still represent considerable effort. The expert 
system shell used in the original work, CLIPS version 5.0, would need to be modified to 
work with version 6.0, in part to replace obsolete features, but more importantly to exploit 
the five major enhancements of this newer version [Nasa93a]. 

Another significant modification required involved restructuring of the interface. 
One of the major shortcomings of the CAE is that it does not present the problem statement 
to the user. Once users start the program, they must remember which problem they wish 
to solve, as well as the specifics of the problem itself. We decided that this is an 
unnecessary burden to place upon users, especially when considering the level of detail and 
the significance of the specification of the problem statement. Furthermore, since the 
purpose of developing the intelligent learning environment using the X Window System is 
to exploit the graphical user interface components it provides, developing a subsystem for 
this environment that interacted with the user but did not use these capabilities would 
produce an inconsistent interface and would be a disservice to our users. The effort 
required to produce a simple, front-end interface to our code evaluators is minimal, and 
dramatically increases the flexibility of this subsystem. 

1. Evaluator Interface 

The evaluator interface is a stand-alone X Window application. It requires a single 
command line parameter, which designates the filename of the problem statement to be 
used. The current implementation of this program has been designed for single problem 
solving sessions. Users may make multiple attempts at solving this problem during a single 

38 







session, but may not load another problem once started. The problem statement is read in 
from the file, and displayed in the top section of a divided window (see Figure 10). 







Figure 10. Initial Screen of Evaluator Interface 


The “Edit” menu allows users to complete the assignment in an editor they are most 
familiar with out of one of the following three editors: Vi, Emacs, and Xedit. While they 
are entering their solution the problem statement remains accessible, and the window can 
be moved or resized to accommodate user’s preferences. Once the user has completed and 
saved the assignment, then the evaluator selection of the “File” menu is enabled. Selecting 
this item causes the user’s solution to be passed to the actual expert system subshell for 
evaluation, and the results of the analysis are displayed in the lower section of the divided 
window (see Figure 11). Users may then review the analysis, and reiterate the process as 
often as they desire. 


39 














Figure 11. Analysis of User’s Solution 

Utilizing a front-end interface to the code evaluator offers distinct advantages in 
addition to providing a consistent interface throughout the learning environment. As we 
have demonstrated here, a prototype can be easily developed to ensure proper operation of 
the system. The actual expert system shell used in the evaluation of the user’s code can be 
developed and tested independently, and can be modified or replaced without affecting 
operation of the rest of the system. For instance, during the validation process it may 
become evident that the forward chaining mechanism provided by the Clips inference 
engine is inadequate and that a backward chaining mechanism is more appropriate to doing 
this kind of analysis. The entire expert system shell can then be replaced by another tool 
that directly implements backward chaining within its inference engine, such as those based 
on the PROLOG programming language [GiRi94]. 


40 

















2 . 


Expert System Code Evaluator 


We began testing and validation of the CAE after successfully converting the 
original code into Clips version 6.0 compliant code. During this phase we discovered that 
the principle limitation cited with the original version of ITS Ada, that it could not properly 
identify multiple correct solutions to a given problem, was a limitation of the CAE as well 
[Hopp92], Although both of these programs attempted to sufficiently restrict the scope of 
the problem domain in order to reduce the number of possible variations, neither of them 
could account for all of the possible solutions that remained. This can be attributed to the 
inherent ambiguity of the language used in the specification (English), as well as the 
expressiveness typically provided by higher order programming languages. These factors 
are directly responsible for the emergence of the software testing field as a separate 
discipline within computer science. 

Upon closer inspection of the problem statements, however, it was discovered that 
these assignments did not actually represent programming assignments at all. The scope of 
the problem domain had been reduced so drastically that it had become an exercise in 
creating a syntactically correct programming construct. These problems are more suitable 
to quiz questions, where a single, most correct answer can be identified from a set of 
possible solutions. The typical user misconceptions that have been documented in bug 
catalogs can be used as distractors, which when combined with the explanatory capabilities 
provided in the quiz system would greatly enhance the learning process. 

In view of these severe limitations we have decided to leave the evaluation portion 
of our tutorial implementation in its prototype form, which simulates evaluation of student 
code. We have converted all of the “programming” assignments into quiz questions and 
have incorporated them into the instructional material. Development of the code evaluation 
subsystem of this tutorial can continue independently, a built-in feature of the intelligent 
learning environment. Follow-on work can focus on the specific problem of code analysis, 
since the interface mechanisms have already been completed. 

41 









VI. A DETAILED EXAMPLE 


A. SAMPLE USER SESSION 

The intelligent learning environment is typically started from the command line 
prompt. The user is provided a greeting message and the control center menu, as shown in 
Figure 12. The purpose of the greeting is to advise users that several of the tutorial 
applications may need to save information into the user’s directory, and that it would be 
best to have a specific working subdirectory created for this purpose. Although this is not 
necessary to run the program, it does prevent the user’s home directory from becoming 
unnecessarily cluttered, and helps prevent different tutorial applications from interacting 
with each other’s files. 


Tutor 

Manual 

Help 

Exit 


Welcome to the Intelligent Learning Environment( 

Note that some of the tutorial applications may 
need to save work files or student information 
during the course of instruction. We recommend 
that if you plan on using these tutorials that you 
start the application from a subdirectory set up 
specifically for this purpose. 


OK 


Figure 12. Opening Screen 


43 


















The menu entries for each of the subsystems are contained in popup menus which 
are activated by selecting one of the control center buttons. The popup menu associated 
with the “Tutor” button appears in Figure 13. Remember that the submenu entries are 
dynamically determined from the global configuration file, “ilemenu.dat”. These menus 
are spring-loaded, and have been designed so that moving the cursor away from the menu 
closes the menu. This helps prevent novice users from inadvertently starting an unwanted 
application. 



Figure 13. Subsystem Menus 


1. Selecting the Ada Tutorial 

Selecting a tutorial application opens the window for the application and loads the 
first page of instruction (see Figure 14). Note that the Tutor selection from the main menu 
is no longer available while a tutorial application is running. Users may simultaneously 
open both a help window and a tutor window, although typically only one is expected to be 
necessary. 


44 

























































The results of selecting the “Ada Tutorial” menu item for the Tutor menu is shown 
in Figure 14. The underlined entries represent hypertext links, and are selected by 
depressing the mouse button while the cursor is over any portion of these underlined 
entries. The buttons at the top of the screen are navigational control mechanisms provided 
in addition to the hypertext capabilities and the scrollbar positioned on the right side of the 
window. The grayed or dimmed appearance of the “Back” and “Home” buttons indicate 
that these selections are not currently available. This is because these provide backtracking 
mechanisms to the user, and no jumps have been taken to backtrack from. 

Once the user has selected a hypertext link, the appearance of these button will 
automatically change, signalling the user that these capabilities have become available. 


45 





















Figure 15 shows the results of the user selecting the “Basics of Ada” hypertext link from 
the table of contents, as well as the appearance of the enabled backtracking buttons. 


Quit 


Back 


Home 


Chapter 1 Basics of Ada 

Section 1.1 Introduction 
Section 1.2 Character Set 
Section 2.3 Identifiers 
Section 1.4 Delimiters 
Section 1.5 Numeric Literals 
Section 1. 6 String Literals 
Section 1 .7 Comments 
Section 1.8 Reserved Words 


I 


Figure 15. Results of Hypertext Jump 


The previous two listings provide a glimpse of the degree of control provided to 
users. Each of the major topics has an expanded subtopic listing, allowing users to 
immediately proceed to the specific topic they are most interested in viewing. This allows 
users already using the tutorial to return to the exact lesson where they left off. Figure 16 
shows the results of selecting a specific subtopic from this listing, as well as the general 
appearance of the tutor lessons. The user can resize the window to the appropriate 
dimensions that provides the most readable presentation for the particular monitor and 
screen layout. 


46 





















Quit 


Back 


Home 


lesson 1-3 Identifiers 

(Next) 

Identifiers are used as names for various components of a 
program and for reserved words. The number of characters 
permitted in an identifier are limitless and all characters are 
significant. The first character must be a letter. This may be 
followed by any combination of numbers, letters or singular 
imbedded underscores. No spaces are permitted within an 
identifier since a space is a separator, lower case letters are 
interpreted in the same way as the corresponding upper case 
letter. Therefore, page_count and Page_Count would be identical. 

It is good Ida programming style to make identifiers as 
descriptive as possible. For example, an array of temperatures 
should be named " TENPERATURES " rather than T". In addition, Ada 
reserved words have special meanings and, therefore, they may 
not be used as names in a program. These reserved words will be 
covered in a later section (See Reserved Words ). 

Legal Identifiers 


Figure 16. Selecting a Specific Topic 


Although the scrollbar located on the right side of the window represents the normal 
method of navigating through the lessons, Figure 16 illustrates several other control 
mechanisms that are available. There are two hypertext links that can be executed from this 
view, one at the top of the screen labelled “ Next ”, and the other located near the bottom 
labelled “See Reserved Words ”. The backtracking capabilities can be utilized through 
selection of the push buttons located at the top of the window. 

The results of selecting the “Home” button from this or any subsequent window will 
cause the information contained in Figure 14 to be reloaded, effectively restarting the 
application. This would also clear the history list of jumps, and would disable both the 


47 













“Home” and “Back” buttons. Selecting the “Back” button, however, places the hypertext 
link that was last executed at the top of the viewing area, as shown in Figure 17. Note that 
this button remains enabled while backtracking until the history list is exhausted. 




Back 


Home 


Quit 


Section 1.3 Identifiers 


Section 1.4 Delimiters 


Section 1.5 Numeric Literals 


Section 1.6 Strina Literals 


Section 1 . 7 Comments 
Section 1.8 Reserved Words 


Chapter 2 Data Types 

Section 2.1 Data Types 
Section 2.2 Scalar Types 
Section 2.3 Integer Types 
Section 2.4 Subtypes and Derived 


Section 2.5 Character Types 



Figure 17. Selecting the Back Button 


The hypertext link named “Next” that appears at the beginning of every lesson (see 
Figure 16) will cause the contents of the following lesson to be displayed. This has been 
incorporated to provide browsing capabilities to the users. While this link enables users to 
sequentially skip through the lessons, a far more useful non-linear access method is also 
provided. This method allows immediate access to related topics that are referenced from 
within a particular lesson. An example of this is provided by the link labelled “See 
Reserved Words” (see Figure 16), which causes the lesson containing that specific topic to 
be displayed, as shown in Figure 18. 


48 




















Back 


Horn 


Quit 


Lesson 1-8 Reserved Words 


(Lesson 2) 

The identifiers listed below are called reserved words and are reserved 
for special significance in the Ada programming language. Host Ada 
programmers adhere to the practice of typing reserved words in lower 
case letters and all other text in uppercase letters. A reserved word 
must not be used as a declared identifier (See Identifiers ). 


abort 

declare 

generic 

of 

select 

abs 

delay 

goto 

or 

separate 

accept 

delta 


others 

subtype 

access 

digits 

if 

out 


all 

do 

in 


task 

and 


is 

package 

terminate 

array 

else 


pragma 

then 

at 

elsif 

limited 

private 

type 


end 

loop 

procedure 


begin 

entry 



use 

body 

except ion 

mod 

raise 



exit 


range 

when 

case 


new 

record 

while 

constant 

for 

not 

rem 

with 


function 

null 

renames 





return 

xor 


Figure 18. Jumping to Related Topic 


Often the related topic will contain a hypertext link to the original document. This 
is precisely the case for the example provided. The lesson on identifiers referenced the 
lesson on reserved words, since the lexical requirements of the programming language 
precluded using reserved words as identifiers. It is intuitively appealing that the lesson on 
reserved words would also reference this rule. Rather than unnecessarily digressing and 
interrupting the flow of either of the lessons, the user is provided a means of accessing this 
information on his or her own when it is necessary. 


49 









Once a user reaches the end of a particular chapter several options become available 
(see Figure 19). The last two entries perform as one would expect, replacing the current 
document with either the table of contents or with the lesson material for chapter two. 



Figure 19. Quiz and Program Options 


The first two entries, however, are what we have been referring to as special links. 
Selecting the first entry will cause a quiz application to be started, [f the configuration file 
contains an entry in the quiz field other than “NONE”, the name of the program in that field 
will be started; otherwise the default quiz will be started. Since their is no default code 


50 
















evaluator provided, the second entry will either start the program specified in the 
configuration file or ignore the request. 

2. Activating Special Links 

Since no external quiz has been specified, selecting the quiz entry causes the default 
quiz application to be started, and its appearance is shown in Figure 20. Note that the 
answers to the quiz questions appear to the user as hypertext links, but their meaning is 
obvious from the context in which they appear. 



Quiz Number One 

Question Number 1 

What is the meaning of the term ''use' in the following Ada statement: 

with TEXTJO; 
use TEXT_IO; 

• Include this file’s source code in our file. 

• (B} Borrow any needed code from this package and use it here in our code. 

• (Q Allow us to reference functions and ADT's from this package without 
fully specifying the reference. 

• Next Question 


Figure 20. Activating the Default Quiz 


In a similar manner, selecting a programming link would launch the code evaluator 
interface specified in the configuration file. The appearance of this application’s main 


51 















window is shown in Figure 21. A complete description of this subsystem is contained in 
the previous chapter. 




Figure 21. Activating the Code Evaluator 


B. EXTENDING THE APPLICATION 

The key to universally extending the application is the configuration file located in 
the directory identified by the environment variable “ILEHOME”. Modification of this file 
will normally be done by system administrators, since they are responsible for maintaining 
centrally located files and subdirectories. This also provides them the flexibility to modify 
directory structures and relocate entire hierarchical structures as they see fit, especially as 
new applications are developed. A typical directory consists of several subdirectories 
branching from a central tutorial directory, as described in the implementation section. If 
an artificial intelligence instructor decides to develop a tutorial for Prolog, Lisp, or Clips 
that may not currently exist, a means of incorporating it into the ILE is to simply modify 













the configuration file to include the necessary information. This would modify the system 
for all users, since this file determines the basic setup. If the instructor wished to restrict 
access to only those students currently enrolled in the class, the tutorial could be placed in 
a class account and then the students could modify their personal configuration file as 
described in the next section. 

Assuming that universal access is desired, here is how the system could be 
extended. Suppose that files are located in the following directory: “/tmp/local/cs0101”, 
that the home page is “introToCS.htm”, and that no special quiz, code evaluators, or other 
extensions have been developed thus far. Then the configuration file would simply need 
the following entry appended to it: 

Intro to CS;TUTOR;/tmp/local/cs()lCI/;introToCS.htm;NONE;NONE; 

This would cause “Intro to CS” to appear in the “Tutor” submenu of the control 
center. Instructions for making entries in the configuration file are provided in the 
comment section of the configuration file, although the previous entries necessary for the 
current setup can serve as an example when adding new applications. 

C. EXTENDING THE APPLICATION BY THE USER 

It is relatively easy for advanced users to extend the functionality of the learning 
environment by adding their own help and reference material. The system is set up to 
accept a command-line configuration file that any user can provide. The format for this file 
is identical to that of the main configuration file, which may be copied and modified. An 
example is also provided in the general help section of the environment which can be cut 
and pasted into a text editor of the users choosing. Since this configuration file is passed 
as a command-line argument, one obvious requirement is that the file must either be located 
in the current directory, or else the path must be fully specified when calling the program. 

In order to provide the hypertext capabilities for the user’s own heip and reference 
material a basic understanding of HTML is required. Again, since the goal of this system 
is to empower its users, a basic introduction and description of the language is included in 


53 





the basic help section. This will allow users without such knowledge the same opportunity 
as is provided users already familiar with the language. 

It would be reasonable for an individual taking a programming language course or 
a data-structures course to desire a convenient mechanism to access syntax and code 
examples for class programming assignments. The user could create an ascii file 
containing the example code and data structures, and then insert the necessary control 
information for the hypertext widget. Alternatively, the user may have access to a help file 
that another student has created. Simply by creating a configuration file similar to that 
shown in Figure 22, the user will have created a quick reference hypertext help file that can 
be accessed from within the learning environment. 


# Sample configuration file for the Intelligent Learning Environment 

# Note that spaces are significant and preserved 

# Format of semi-colon separated fields is as follows: 

# Name;Type;Full Path;Home Page;Special Appl;Special App2; 

# The last two fields apply to tutorials only, and should be “NONE” for all others 

# Second Field must be one of: “TUTOR”, “MANUAL”, or “HELP”. 

# Example: Ada Tutor;TUTOR^root/rTSENV/adaDir/;contents.htm;NONE;NONE; 
Unix Help;HELP7users/work l/delani/helpDir/;Unixhelp.htm;NONE;NONE; 

X Windows HeIp;HELP;/users/workl/delani/helpDir/;xwinHelp.htm;NONE;NONE; 
Data Structures;HELP;/users/work l/delani/cs33GO/;datastruct.htm;NONE;NONE; 


Figure 22. Sample User Configuration 

D. ADDING SOFTWARE ENGINEERING TOOLS 

As mentioned in the section describing the detailed implementation, hypertext links 
typically have an “htm” or “html” extension. This is not required, however, and developers 
can exploit the built in mechanisms by following alternative conventions. The system is 
currently set up to identify sound files, bitmap or image files, and postscript files as being 
special files and defers processing or these files to the system. It also recognizes filename 
extensions that begin with ‘q’ or ‘y’ as being hypertext links that require special handling 









as well. The first field after the home page in the configuration file indicates the special 
quiz handler. If “NONE” is specified, then the system assumes that either a simple 
hypertext quiz exists or that the tutorial designer had no intention of using quizzes. If, 
however, a special program is indicated, then this program will be called and the 
information contained in the hypertext link will be passed to the program. This way 
developers who wish to create elaborate student models that track student’s responses may 
do so. 

Similarly, the next field indicates any special code evaluator programs that may 
exist for the tutorial. This could include an elaborate front-end interface which provides 
syntax directed editing capabilities, special formatting capabilities, or any other special 
preparation that the particular code evaluators may need. For instance, earlier versions of 
the ITS Ada tutorial included an expert system shell which processed certain programming 
assignments. By specifying the name of the program in this field, this separate application 
is started, and the information contained in the hypertext link is passed as a command line 
argument. This information may indicate a particular problem assignment or other 
information necessary to intelligently begin this program. User input can then be obtained, 
passed to the evaluator portion, and feedback provided to the student. Once the student is 
completed with this section control can be returned to the learning environment. 

Although these mechanisms have been set up to facilitate the incorporation of quiz 
and code evaluation tools, there is nothing restricting their use to these functions. In the 
discussion of the implementation of the Ada tutorial we showed how we incorporated a 
front-end interface to a code evaluation system. As tutorial developers, we can change the 
purpose of this system to whatever we desire. If we only want to provide access to a syntax 
directed editor, we can either use the editor as our interface, or keep the level of indirection 
already provided and let this front-end serve as an integration mechanism to the syntax 
directed editor. Having this integration mechanism also allows us to incorporate other 
software engineering and software testing tools as well. This would be especially valuable 
for those tools which are not designed to interact with users. The interface could do all of 


55 






the pre-processing necessary for the tool, and then interpret the feedback and prepare it for 
the user to review. 

Note that the enhanced functionality of these tools is not necessary to provide a 
useful tutorial. We have merely provided the mechanisms to enable tutorial developers to 
expand the power and usefulness of their own applications. These evaluators may also 
remain completely separate from the tutoring environment, allowing developers to 
concentrate on their own work and not on providing multiple interfaces to their students. 
This is exactly what we have done with our code evaluator subsystem. Until it has been 
properly tested and validated it should not be a part of the learning environment. Once we 
are satisfied with its quality, we can easily incorporate it into the system by modifying the 
configuration files. 










VII. CONCLUSIONS 


A. ACCOMPLISHMENTS 

We have developed an integrated, extensible, intelligent learning environment 
designed to be used on the X Window System. We used this platform to exploit the rich 
graphical user interface it provides as well as its hardware and operating system 
independence. This learning environment provides the framework for producing hypertext 
based tutorials and reference materials without requiring explicit programming skills in any 
language. 

We have incorporated a tutorial for the Ada programming language to exemplify 
the ease with which tutorials can be developed from existing course work. This tutorial 
also provides a template for tutorial developers to facilitate rapid development of prototype 
tutorial systems. 

We have provided a means of modifying existing tutorials, enhancing then- 
functionality and usefulness, or replacing them altogether without requiring modification 
to the learning environment or recompilation. Expert system code evaluators and syntax 
directed editors may developed separately from the tutorial, and then integrated once 
adequate testing has been performed. 

We have created a mechanism for incorporating additional on-line reference 
manuals and help systems that can exploit the advantages of the non-linear access provided 
by the hypertext facility. 

We have provided users with a tool that can be used in many different ways. In 
addition to using the environment for its tutorial applications, users can also exploit the 
functionality of the help and reference sections to facilitate program development for 
software projects. Users are free to utilize the editors they are most familiar with, and can 
even cut and paste template or example source code from reference material into their own 
work, greatly improving efficiency and productivity. 


57 








We have also provided users with a means of extending the power and usefulness 
of the learning environment as their programming prowess develops. Users can easily 
create their own help and reference sections (or use those created by colleagues or 
associates), and can incorporate the material into the learning environment by preparing a 
personal configuration file and passing the name of the configuration file as a command 
line parameter. 

B FUTURE WORK 

We have mentioned the possibility of incorporating syntax directed editors 
throughout this discussion. This is one capability which we feel would add tremendous 
value to any programming language tutorial. In addition to guaranteeing syntactically 
correct structures, it can also be used to teach or enforce particular programming styles. 
The scope of this additional effort would have to be limited to a particular language tutorial, 
and would not apply to the environment universally. 

Another area for possible future development that would necessarily be language 
specific is the code evaluation subsystem. In order to be of any particular value this feature 
would have to be able to analyze code segments which are substantially more complex than 
simple constructs. The methodology used to provide this capability might then be used as 
a framework in development efforts for other programming languages as well. 


58 







APPENDIX A. SYSTEM ADMINISTRATION 


This file contains information necessary for creating tutorial applications for use 
with the Intelligent Learning Environment. The environment has been designed to 
integrate a variety of tutorial applications, reference manuals, and hypertext help systems. 
The hypertext help facilities were provided by the HTML widget, developed at NCSA 
(National Center for Supercomputer Applications). Since the environment has been 
developed for use with the Athena Widget Set. the HTML library must be compiled for this 
widget set as well. Although this is the default compiler option, systems that use these 
libraries for their Mosaic and WWW systems may have compiled the library using the 
Motif compiler options. If this is the case, then a separate library will need to be prepared 
for this system. Note that these libraries are also stored in non-standard subdirectories, 
which may cause problems during installation of the system. The makefile included with 
the system is set up to look in the current directory for both the HTML header file as well 
as the precompiled HTML library. This entry will need to be modified to reflect the actual 
directory location for these files. 

The hypertext markup language is a subset of the standard generalized markup 
language (SGML). These languages consist of embedded format commands, similar to 
those used for pretty printing and formatted display. The format of all of the instructional 
and reference material needs to be in this format in order to work properly. Examples that 
may be useful are the tutorial applications provided with the environment (itsada##.htm), 
as well as the various help and manual files included. Several tools are available for 
converting ascii code into HTML code, but the process is very straightforward. 
Information on how to complete this process is included with the help files incorporated 
into the system. 

The following is a sample setup file necessary for proper operation of the system. 
Users will need to source this file prior to starting the Intelligent Learning Environment. 







EXAMPLE SETUP FILE 


# This file sets up the environment variables for proper execution of the Intelligent 

# Learning Environment. This file can be sourced from users’ .cshrc file in order to allow 

# them to access all the program files 
setenv ILEHOME /usr/local/tutors 
set path= (/usr/local/tutors $path) 

# In addition to the above line, the path must also be set for any special quiz programs or 

# code evaluators indicated in the configuration file, itstutor.dat, which must be located in 

# the ILEHOME directory 

# For Example: Suppose itstutor.dat contained following entry: 

# CAPS Tutor;TUT;/usr/local/tutors/CAPS/;CAPS_OO.htm;C_Quiz;C_Edit; 

# The final two entries represent special quiz program and code evaluator programs. We 

# would need to include the path where the executables were stored in order to provide 

# access from our program. This may look something like the following: 

# set path=(/root/CAPS/quizDir /root/CAPS/editorDir $path) 

set path=(/users/workl/delani/UtilDir $path) 

setenv XADAHELP /usr/local/tutors 


This file is used to enable the dynamic creation of control center menus when the 
system is first started. This also allows system administrators to add new subsystems or 
reconfigure the existing directory structure without affecting multiple files. This directory 
is designed to provide a central location for the system help files and the system 
configuration file, “ilemenu.dat”. Although the executable program will normally be 
located in this same directory, this is not necessary, since administrators may want to 
centrally locate all executable binaiy files. The system will still function properly as long 
as the path statement properly reflects the directory in which the executable is stored. 

The last two entries of this setup file pertain to special applications that can be 
incorporated into the system. As the comments explain, these correspond to the last two 
fields of particular tutor or reference entry in the configuration file. This will be explained 
in more detail during the discussion of this file. 

The system configuration file and the system help files must be located in the 
directory identified by the “ILEHOME” environment variable. The configuration file must 
be named “ilemenu dat”, and the system help files must not be renamed either. Entries in 







the configuration file must follow the format explicitly as described in the comment section 
of that file. We have included an example here for completeness and as a reference in the 
event that the original file becomes corrupted. 

EXAMPLE CONFIGURATION FILE 

# Configuration file for Intelligent Tutoring System. The format of this file is fairly rigid, 

# as we did not want to have to do a complicated parse of the file. 

# NOTES: 

# — Spaces ARE significant and preserved 

# — semicolon is field separator 

# — Assumes no blank lines or comments once entries start 

# — Assumes all of fields are present (have entries) 

# - The only valid entries for 2nd field are “TUTOR”, ’’MANUAL”, and “HELP”, 

# which correspond to Menu Buttons 

# -- Fields 5 and 6 specify separate, executable applications and should have 

# environment variable settings already set up or be fully specified. If NO 

# separate applications are provided, these fields must be “NONE”. 

# FIELDS and example line: 

# Name; TYPE; Full Path; Home Page; Quiz App; Program Tool; 

# Ada Tutor;TUTOR;/root/ITS_ENV/ada_tutor/;contents.htm;NONE;NONE; 

# Note that file itsSetup contains information regarding proper setup of environment 

# variables for separate executables in fields 5 & 6 

# . - . - . 

<Begin Data> 

Ada TutoriaI;TUTOR;/usr/local/tutors/itsAda; itsadaOO.htm; NONE; xAdaEval; 

C Tutorial;TUTOR;/usr/local/tutors/itsCeedir/;itsceeOO.htm;NONE;NONE; 

C++ Tutorial;TUTOR;/usr/local/tutors/itsCxxdir/;itscxxOO.htm;NONE;NONE; 

Using Unix;HELP;/usr/locu»/helpdir/UsingUnix/;jxxl_OO.htm;NONE;NONE; 

Clips Help;HELP;/usr/local/helpdir/itsClips/;clipsOO.htm;NONE;NONE; 

Ada LRM;MANUAL;/usr/local/rnanual/Ada9xLRMdir/;rm9x_OO.htm;NONE;NONE; 

C Reference;MANUAL;/usr/local/manual/CeeREFdir/;ceerefOO.htm;NONE;NONE; 

C++ Reference;MANUAL;/usr/local/manual/CxxREFdir/;cxxrefDO.htm;NONE;NONE; 
<EOF> 


Please note that the <EOF> flag is shown here just for illustrative purposes. It 
should not appear when the file is viewed. The comments included in this file explain the 
format requirements as well as the significance of each field. The last two entries of each 
field correspond to the special applications we mentioned during the discussion of the 
system setup file. An entry of “NONE” indicates that no special application is currently 


61 







available. Any other entry represents a separately executable program that will be used 
when special jumps are encountered. Since these entries represent executable programs, 
the necessary path information must be properly set up in order for them to work when 
called from users’ directories. Although these fields are currently set up for a quiz and code 
evaluator, there is nothing to enforce that they be used as such. Hypertext links that have 
an extension beginning with the letter ‘q’ indicate calls to the application identified in field 
five, while links that have an extension beginning with ‘y’ indicate calls to the application 
identified in field six. Tutorial developers are free to change the functionality and 
semantics of these applications as they see fit. Furthermore, these hypertext links appear 
as normal links to the user of the application (see Figure 19 on page 50), and developers 
could provide proper indications to the user with respect to what selecting the link will 
actually accomplish. 

Also note that if the paths for these subsystems becomes sufficiently large it will 
cause the line to be wrapped to the following line. This is perfectly acceptable; do NOT 
place linefeeds or end of line markers in the file to improve the appearance. These will be 
erroneously interpreted as extra delimiters by the C function strtok(), which is being used 
to parse this file. 

The makefiles for all of the system elements are as follows: 

• MakelLE - For the Intelligent Learning Environment 

• MakeEval - For the Ada Code Evaluator Interface 

• MakeHman - For a utility HTML file browser, HyperMan. 

HyperMan is a convenience utility that was created during the development of the 
ILE. The functionality provided by the reference subsystem seemed quite desirable to have 
in a single, stand-alone application. This program allows tutorial and reference material 
developers to view their work in its display format while they are developing it (without 
having to modify the global setup for the ILE). This is also useful just for browsing help 
files located in the current directory. 


62 





Field five of the configuration file has been identified as corresponding to a special 
quiz application provided with the system. If this entry is “NONE”, then a default quiz 
application becomes available to tutorial developers. The default quiz has been provided 
merely as a convenience, and is not designed to create student models or actually evaluate 
a student’s understanding. It utilizes the hypertext capabilities of the HTML widget in 
order to provide immediate feedback to users in the form of a pop-up window containing 
explanations about quiz distractors. Typical user misconceptions and potential areas of 
confusion can be presented to users as distractors to quiz questions, and when the user 
selects these as the response to the quiz question, he or she is provided an explanation as to 
why the answer is correct or incorrect. The default quiz application included with the 
environment expects two files to be present in order to administer quizzes. The question 
file is designated with an extension of “quiz”, and the solution file is designated with 
“soln”. Note that both files MUST have the same base filename - as in following example: 

Quiz question file => section 1 .quiz 

Quiz solution file => section 1.soln 

The format for the question file is similar to that of a standard HTML file, with the 
exception that quiz answers are designated with the following anchor tag: 

<A HREF=##1_A> 

The “##” identifies the link as an answer to a question, and the “1_A” identifies the 
response as being “Question Number 1, Response A”. This differs from standard anchor 
tags, which appear as the following: 

• <A HREF=#TargetAnchor> 

• <A HREF=”filename.htm”> 

• <A HREF=”filename.htm#TargetAnchor> 

The first entry represents a hypertext link to a target anchor in the current file. The 
second link is to a file, and since no target anchor is specified the beginning of the file will 
be loaded. The final entry is to a specific target anchor in another file. This will cause the 
contents of that file to be loaded into memory, and then the specific anchor identified to be 


63 






positioned at the top of the viewing area. Note that the default quiz is currently 
implemented with single file capabilities only. Any attempts to jump to alternative files 
will be ignored, mainly due to the close correlation required between quiz question and 
solution files and their associated overhead. 


EXAMPLE QUIZ FILE FORMAT 

<HEADER><TITLE> Intelligent Tutoring System </TITLEx/HEADER> 

<A NAME=TopOfPage> <PxHl>Quiz Number One</HlxP> 

<A NAME=Questl> <P> <h2>Question Number l</h2xP> 

<H3>What is the meaning of the term “use” in the following Ada statement:</H3> 

<pre> 

with TEXTJO; 

<b>use</b> TEXT_IO; 

</pre> 

<ul> 

<lixA HREF=##l_A>(A)</A>Include this file’s source code in our file.<P> 
clixA HREF=## 1 _B>(B )</A>Borrow any needed code from this package and use it 
here in our code.<P> 

dixA HREF=##l_C>(C)</A>Use this package to resolve any references to functions or 
data types that are not defined in the current file. This allows us to access these functions 
and ADT’s without fully specifying the reference.<P> 
dixA HREF=#Quest2>Next Question</AxP> 

</ul> 


The last HREF listed is a standard HTML jump to an anchor within the same file. 
Currently the default quiz only allows same file jumps (single quiz). The format for the 
solution file is fairly rigid, in that each question has an explicit beginning and ending, as 
well as each of the answers to a particular question. The current implementation allows up 
to ten questions, and each question may have up to four possible answers. The quizzes may 
be incorporated anywhere within the instructional material, and provide a context sensitive 
testing capability. Although the default quiz does not create a student model, the source 
code can be used as an example for developers who wish to incorporate such capability, 
and then the name of the new quiz can be entered in field five to override the default. 


64 







EXAMPLE SOLUTION FILE FORMAT: 

# Solution file for Quiz Number One. Note the strict format requirements. 

QUEST_ 1 = C 
ANS_A 

Explanation why A is incorrect answer goes here 

END_ANS 

ANS_B 

Explanation why B is incorrect answer goes here 

END_ANS 

ANS_C 

Explanation as to why this is correct answer goes here 

END_ANS 

ANS_D 

Explanation why D is incorrect answer goes here 

END_ANS 

END_QUEST 

NOTE1: Each question begins with “QUESTJMUM = ANSWER”, where 
Answer must be single character which designates the correct response to the question. The 
whitespace between different responses and questions is ignored, but the whitespace within 
an answer (between ‘ANS_A’ and very next ‘END_ANS’) is considered important. Note 
that certain text editors may cause the explanation to have awkward appearance in the 
popup window. 

NOTE2: This format is only required if developers want to use the default quiz. 
Quizzes are started when a hypertext link in the tutorial has a “.quiz” extension. If no 
quizzes are desired, there should be no links to a “.quiz” file. If developers want to provide 
their own quiz application, this can be done by providing an entry other than “NONE” in 
the fifth field of the configuration file entry for that tutorial. For example, the following 
entry will cause a separate quiz application named “MY_QU1Z” to be loaded whenever a 
“.quiz” jump is encountered: 

Sample Tutor;TUTOR;/some/full/path/specification/;HomePage.htm;MY_QUIZ;NONE: 


65 






The entry in the last field is “NONE”, which indicates that “Sample Tutor” 
currently does not have a separate code evaluator application. An entry in this field would 
be called when the tutorial encountered a hypertext link to a file with a “.ylee” extension. 
Since there is no default code evaluator provided, an entry of “NONE” in this field causes 
jumps with the “.ylee” extension to be ignored. 

It is important to remember that developers do not have to follow the conventions 
established here and use fields five and six as quiz and code evaluators. They are free to 
incorporate their own tools and applications, and exploit the built in capability that the 
instructional material will automatically call these applications when a hypertext link with 
a special extension is encountered. 


66 




APPENDIX B. SOURCE CODE 


The following is the source code listing of the files that comprise the Intelligent 
Learning Environment. They are included here for completeness and as a reference for 
future development work. The code has been written to exploit the graphical user interface 
capabilities of the X Window System, and specifically the Athena Widget Set which is 
included with the standard distribution from MIT. The hypertext capabilities are provided 
by the HTML Widget developed at NCSA for use with their Mosaic system, and is the same 
widget set used by most world wide web (WWW) browsers. The following program files 
are included: 

• globals.h 

• main5.c 

• parseS.h 

• parse5.c 

• tutor5.h 

• tutor5.c 

• help5.c 

• utils5.h 

• utils5.c 

• quizS.h 

• quiz5.c 

GLOBALS.H 

**************************************************************************** 

Name: globals.h Global Header File for Intelligent Learning Environment 
Author: J tunes Delani 

Description: This is the header file for the Intelligent Learning Environment. The main program is the only 
source fde that uses this header file. The executable program consists of the following files (and their header 
files): main5.c, tutorS.c, help5.c, utils5.c, quiz5.c, parseS.c 

NOTE: The environment variable, ILEHOME, must be set to the directory that the configuration file, 
"ilemenu.dat”, and the system help files are located. The program depends on this to dynamically create the 
menu entries. The program uses the hypertext widget developed at NCSA to provide the hypertext 
capabilities. The makefiles assumes this library has been compiled for use with the Athena Widget set. 

* * * * * 4c * * # * * * * * * * * * * * ★ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ★ * * * * * * * * * * * * * * * * * * * * j 

#ifndef _GLOB ALS_H_ 

#dcfine _GLOBALS_H_ 

#include <sldio.h> 

#include <stdlib.h> 

#inciude <Xll/lntrinsic.h> 





#include <X1 l/StringDefs.h> 

#include <X11/Shell.h> 

#include <X1 l/Xaw/Form.h> 

#include <X1 l/Xaw/Box.h> 

#include <X1 i/Xaw/Coininand.h> 

#include <Xl l/Xaw/Dialog.h> 

#incJude <X1 l/Xaw/MenuButton.h> 

#include <X1 l/Xaw/SimpleMenu.h> 

#include <X1 l/Xaw/SmeBSB.h> 

#include <X1 l/Xaw/SmeLine.h> 

#include "tutor5.h” 

#include "parse5.h” 

/* 

* These variables are necessity to allow dynamic creation of menus. Executable program needs to be able 

* to find the configuration file from whatever directory it is started from. Environment variable and path 

* settings must be properly set up before running this program. 

*/ 

char * SYSHOME = “ILEHOME”; 

char * SYS_ConftgFileName = “ilemenu.dat”; 

char * SYS_HeIpFileName = “syshlpOO.htm”; 

/* These are currently the only valid menu entry types */ 
char * TutorType = •‘TUTOR”; 
char * ManualType = “MANUAL”; 
char * HelpType = “HELP”; 


static String fallback_resources[] = ( 

“* .Font: “courier-medium* 14*iso8859-1 ”, 

“•FixedFont: -adobe-courier-medium-r-nonnal-*-14-*-*-*-*-*-iso8859-1 ”, 
““FixedboldFont: -adobe-courier-bold-r-normal-*-14-*-*-*-*-*-iso8859-l”, 
“*FixeditalicFont: -adobe-courier-medium-o-normal-*- 14-*-*-*-*-*-iso8859-1”, 
““AnchorUnderlines: 1”, 

“*VisitedAnchorUnderlines: 1”, 

““DashedVisitedAnchorUnderlines: True”, 

““.name: Intelligent Tutoring Environment”, NULL. (; 

/* The following tire predefined strings for the popup dialog boxes in main program */ 
String ExilConfmn = “Do you really want to exit?”; 

String AboutVersion = 

“Preliminary Release of the Nn\ 

Intelligent Learning Environment N nNn\ 

Copyright 1994 \n 
Jim Delani”; 

Suing Start Up Message = 

“Welcome to the Intelligent Learning Environment !ViVi\ 

Note that some of the tutorial applications may\n\ 











need to save work files or student information^ 
during the course of instruction. We recommend \n\ 
that if you plan on using these tutorials that you\n\ 
start the application from a subdirectory set up\n\ 
specifically for this purpose,\n\n”; 

/* Callback functions needed in main function */ 

extern void exit_cb(); 

extern void greetUserQ; 

extern void about_cb(); 

extern void really_exit_cb(); 

extern void cancel_cb(); 

extern void StartTutorCB{): 

extern void StartHeipCBO; 

#endif 


MAIN5.C 


I ***************************************************************************** 


Name: main5.c Main program for Intelligent Learning Environment 

Author: Jim Delani 


Description: This program piuvides an intelligent learning environment whichenables a user to leam a 
variety of languages. The tutors and help systems incorporate hypertext by utilizing the HTML widget 
developed by NCSA for Mosaicand other WWW browsers. The system is configured by an ascii file, 
“ilemenu.dat”, which resides in the the ILEHOME directory. This environment variable must be set in order 
for the system to work properly, especially since the first thing the program does is look for the configuration 
file in that directory! The format for the config file is fairly rigid, and is used to provide system administrators 
with flexibility in setting up their own systems. It would seem natural to place all of the tutorials and reference 
manuals in subdirectories of ILEHOME, but this is not required. As new tutorials and references are created, 
it is easy to incorporate them into the program simply by modifying this configuration file. Advanced users 
may create their own help files and include them in the help portion by passing the appropriate command line 
arguments. The format of the file and the command line switches tire included in the basic help available 
from within the system. 

********************************************************************************y 

#include “giobals.h” 

Widget TopLevel, tutorB, pshell; 

TutorList tutorialPtr = NULL; 

TutorList userlnput = NULL; 

TutorList tempPtr = NULL; 

/* ARGSUSED */ 
int main(argc, argv) 
int argc; 
char *argv[j; 

I/* begin main */ 
int j; 


69 



XtAppContext app_context: 

f* NEVER call a Widget variable “exit”! */ 

Widget buttonBar. manualB, helpB, infoB, exitB: 

Widget tutorMenu, manualMenu, helpMenu. menuEntry; 

TutorStruct genericHelp; 

char SYS_Config[65): 

char * UserConfig; 

char * Sys_Home; 


Sys_Home = getenv(SYSHOME); 
strcat(Sys_Home, 
strcpy(SYS_Config, Sys_Home); 
strcat(SYS_Config, S YS_ConfigFileName); 




NOTE: Environment variable does NOT include milling '/' for path info. All of the code in the 
tutor and help files assume that the path includes the trailing 7’ and that the filename consists of 
only the actual name, ie “syshelpOO.htm” NOT ‘7syshlp00.htm” 

********************,******************************************************y 

/* Note that structure string elements are fixed size arrays */ 
strcpyfgenericHelp.Name, “Help on Help”); 
strcpyfgenericHelp.Type, HelpType); 
strcpyfgenericHelp.Path, Sys_Home); 
strcpyfgenericHelp.Home, SYS_HelpFileName); 
strcpyfgenericHelp.Quiz, “NONE”); 
strcpyfgenericHelp.Program, “NONE”); 
genericHelp.next = NULL; 

tutorialPtr = parseTutorList(SYS_Config, tutorialPtr); 


/* Parse configuration file passed in by user, append info to menu list */ 
iffarge > 1) 


UserConfig = strdup(argv[l]); 

tutorialPtr = parseTutorListfUserConfig, tutorialPtr); 


TopLevel = XtVaAppInitialize(&app_context, “athenalLE”, NULL, 0, 

&argc, argv, fallback_resources, NULL); 

XtVaSetValues(TopLevel. XtNname, “Intelligent Tutoring System", 

XtNwidth, 350, XtNheight,40, NULL); 

buttonBar = XtVaCreateM;inagedWidget(“buttonBar”, formWidgetClass, TopLevel, 

XtNheight, 75, NULLV, 

tutorB = XtVaCreateManagedWidgetf'Tutor”, menuButtonWidgetCIass, buttonBar, 

XtNLabel, “ Tutor “, XtNmenuName, “tutorMenu", 
XtNIeft, XtChainLeft. XtNtop, XtChainTop, 
XiNbottom, XtChainBottom, NULL); 

tutorMenu = XtCreatePopupShellC'tutorMenu”. sinpleMenuWidgetClass. tutorB, NULL. 0); 


70 








manualB = XtVaCrealeManagedWidgetCMtinuaT, menuButtonWidgetClass, buttonBar, 

XtNIabel, " Manual XtNfromHoriz, tutorB, 
XtNmenuName, “manualMenu”, XtNtop, XtChainTop. 
XtNbottom, XtChainBottom, NULL); 

manualMenu = XtCreatePopupShell(“inanualMenu”. simpleMenuWidgetClass, manualB, NULL, 0): 

helpB = XtVaCreateManagedWidgetC'Help”, menuButtonWidgetClass. buttonBar, 

XtNIabel, “ Help XtNmenuName, “helpMenu”. 
XtNfromHoriz, manualB, XtNtop, XtChainTop. 

XtNbottom, XtChainBottom, NULL); 

helpMenu = XtCreatePopupShell(“helpMenu”. simpleMenuWidgetClass, helpB, NULL, 0); 

inenuEntry = XtVaCreateManagedWidgetCgeneric”, smeBSBObjectClass, helpMenu, 

XtNIabel. “Using ILE”, NULL); 

XtAddCallback(menuEntry, XtNcallback, StartHelpCB, &genericHelp); 

tempPtr = tutorialPtr; 
while (tempPtr != NULL) 

< 

if (! strcmp(tempPtr->T ype, TutorType)) 

1 

menuEntry = XtVaCreateManagedWidget(tempPtr->Name, smeBSBObjectClass, 

tutorMenu, XtNIabel, tempPtr->Name. NULL); 
XtAddCallback( menuEntry, XtNcallback, StartTutorCB, tempPtr); 

1 

else if (!strcmp(tempPtr->Type, ManualType)) 

I 

menuEntry = XtVaCreateManagedWidget(tempPtr->Name, smeBSBObjectClass, 

manualMenu, XtNIabel, tempPtr->Name. NULL); 
XtAddCallback(menuEntry, XtNcallback, StartHelpCB, tempPtr); 

1 

else if (!strcmp(tempPtr->Type, HelpType)) 

I 

menuEntry = XtVaCreateManagedWidget(tempPtr->Name, smeBSBObjectClass, 

helpMenu, XtNIabel, tempPtr->Name, NULL); 
XtAddCallbackfmenuEntry, XtNcallback, StartHelpCB, tempPtr); 

1 

tempPtr = tempPtr->next; 


menuEntry = XtVaCreateManagedWidget(tempPtr->Name, smeBSBObjectClass, 

helpMenu, XtNIabel, “About...”, NULL); 
XtAddC;dlback(menuEntry, XtNcallback, about_cb, NULL); 

exitB = XtVaCreateM«magedWidget(“Exit", cominandWidgetClass, buttonBar, 

XtNIabel, “ Exit “, XtNfromHoriz, helpB, 
XtNright, XtChainRight, XtNtop. XtChainTop, 
XtNbottom, XtChainBottom, NULL); 
XtAddCallback(exitB, XtNcallback, exit_cb, NULL); 

greetUser(); 


71 






XtRealizeWidget(TopLevel); 

XtAppMainLoop(app_context); 

I 


/* 

* Callback associated with tutor menu which activates our Tutorials. This function is located in tutor5.c, 

* and uses information passed to disable calling widget (tutorB), and set up environment of the tutorial. 

* Need to allow tutor to disable button since we lose control from this side once we call StartTutor 
*/ 

void StartTutorCB(widget, client_data, call_data) 

Widget widget; 

XtPointer client_data, call_data; 

( 

TutorList tPtr = (TutorList)client_data: 

StartTutor(tutorB. tPtr, call_data); 

1 

/* Callback associated with both the Manual Menu and Help Menu. */ 
void StartHelpCB(widget, client_data, call_data) 

Widget widget; 

XtPointer client_data, call_data; 

I 

TutorList tPtr = (TutorList)client_data; 

StartHelpftPtr, call_data); 

1 


I* Popup dialog to welcome user and advise about directories */ 
void greetUserO 
( 

Widget okB, welcome_dialog; 

Position x, y; 

Dimension Rwidlh, Rheight; 
int Pwidth = 500, Pheight = 350; 

pshell = XtVaCreatePopupShell(“WeIcome!'\ transientShellWidgetClass, TopLevel. 

XtNwidth, Pwidth, XtNheight, Pheight, NULL); 

welcome_dialog = XtVaCreateManagedWidget(“Welcome”, dialogWidgetClass, psheil. 

XtNlabel, StartUpMessage, NULL); 

okB = XtVaCreateManagedWidget(“ OK ", commandWidgetClass, welcome_dialog, 

XtNhorizDistance. 220, NULL); 

XtAddC;dlb;tck(okB, XtNcallback. c;incel_cb, NULL); 

XtVaSetValues(pshell, XtNx, 120, XtNy, UK), NULL); 

XtPopup(pshell. XtGrabExclusive); 

I 


72 







* Callback n> provide user with opportunity to conlinn or cancel EXIT Exit application does not hav 

• menu ;ind may he triggered inadvertently. s< should provide user opportunity to ahon the exit 

*/ 

void exit_cl. m. client data. call data) 

Widget w'; 

XtPomter client _da(a: 

XtPomter caUdala. 

I 

Widget okB. cancelB. exit dialog: 

Position x. \. 

Dimension width, height; 

pshell = XiVaCreatePopupShellf contirm". transientShellW'idgetCl.iss, TopLevel. 

XtNwidth. «X). XlNheighl. 150. XiNlabel. ExilConfinn. NULL); 

exit dialog » XlVitCrealeManagedWidgelf ConfirmdiakigWidgetClass. pshell. 

XiNlabel. ExitConfirm. NULL); 

okB = XfVaCreaieManagedWidgelt" Exit ". commandWidgetClass. exit dialog. 

XlNhon/Distance. 40. NULL). 

XlAddCallhackiokB. XlNcallhack. really _exit_ch. NULL): 

ciincelB = XtVaCTealeManagedWidgeK "Cancel'. cominandW'idgelClass. exil.dialog. 

XtNhon/Distance. 40. XtNnght. XtChainKight. NULL): 
XtAddCallhackt cancelB. XlNcallhack. cancel_cb . NULL); 

XtVaGetVjiJucst TopLevel. XtNwidth. & width XiNheight. A height. NULL). 
XlTranslaleCoordstTapLevcI. (Position) width/2. (Posiuon) height/2. &x. &y). 
XtVaSetValues<pshell. XtNx. x - twidih/2). XiNy. y ♦ height. NULL): 

XtPopuptpshell. XtGruhExclusive): 

) 

/* C.dlhack associ;iled with our Inlo button which provides popup vctshhi dialog 
void about chtw. client data. call ditliii 
Wtdget w; 

XtPomter client_data. 

XlPomter call data; 

( 

Widget about dialog okB. 

Position x. \. 

Dimension width, height. 

pshell = XlV aCreatePopupShelh"About transienlShellWidgctClass. TopLevel 

XtNwidth. M*». XtNhcight.2tXi.NULL> 

ahiwti dialog = Xl\iiCreiiiebLutiigedWidgett' aNiut'. di.dogW HjgetClass. pshell 

XiNlabel. A bout Version NULL*. 

okB = Xi\aCreaieMiiiiagedWidgcif' OK ", vommandW idgetClass. about dialog 

XtNhori/Disiancc 120. NT'Ll.i. 






XtAddCallbackfokB. XtNcallhack. cancel_ch. NULL). 


XtVaGetValueslTopLevel. XtNwidth. &width. XtNheight. &height, NULL). 
XtTranslateCoordsfTopLevel. (Position) width/2. (Position) he. :ht/2. &x, &y): 
XtVaSetValues(pshell. XtNx. x • (width/2). XtNy. v + height. NULL): 

XtPopuptpshell. XtGrahExclusive): 


/* Callback used to remove any of the popub dialogs attached to pshell */ 
void cancelcMw. client data. calldata) 

Widget w. 

XtPointer client_data. call_dala: 

I 

XtPopdownt pshell). 


/* Callback associated with OK button of exit_ch. Co ahead and close up shop */ 
void reallv_exit_cb( w. clienidaia. call_data) 

Widget w : 

XtPointer client_data. call_data: 

I 

cxit(O): 


PARSES.H 

/. ........ . . 

Name: parser Vh Configuration file parser header file 
Author: James Delani 

Dcscnpuon: This file parses the configuration tile passed as a parameter and creates a linked list ol 
TutorStructs. Allows dynamic creation of menus based iwi an Ascii file. NOTE: the torm.il of the 
configuration tile is .cry rigid in order to simplify parsing. All of the fields are expected to have entries, and 
Mime fields only allow specific entries The following information is also contained in the system 
configuration file to facilitate development 
-- Spaces ARE significant and preser ved 
. semicolon is field separator 

Assumes no blank lines or comments once entries start 
Assumes all of fields are present (have entries i 

-- The only •. did entries lor 2nd field .ire Tl TOR . 1 MAN! AL .md HELP . correspond to Menu Buttons 
-- Fields s and ft specify separate, executable applications and should have environment sariaNe settings 
.dreads set up or Nr lulls specified If NOseftiraic applications are provided then these fields must fuse 
' NONE' as iheir entry 

• • The application indicated in Field S is auumaticail) called when a hypertext link has an extension 
hcginrang with q". as in scctHWil.qui/' (Standard HTML extensions are him' * html i 
- The application indicated in Field S is auhmalKalls called when a hspertext link has .in extension 
beginning with v". as in seclKWil >lee This is considered a special progi unining link 






Field specifications:: 

Field I: Name as ii will appear in Control Center Menu 
Field 2: Type of subsystem (which menu it goes in) 

Field 3: Full path to where hunl tiles are located (NOTE: MUST have trailing slash 7 ) 

Field 4: Home Page of subsystem (First httnl file to load) 

Field 5: Special Application (Currently for Quizzes) 

Field 6: Special Application (For Code evaluator interface) 

Example Line: 

Ada Tutor.TUTOn.7root/lTS_ENV/adii_tutor/:conients.htin:NONE:NONE: 

Remember: spaces ARE significant, every field mast have entry, and fields 2. 5. ;tnd 6 are special fields 

*********.*. ...... **/ 

•ifndef _CONFIG_PARSE_ 

“define _CONFIG_PARSE_ 

#include <sulio.h> 

#include <stdlib.h> 

#include <XI l/lntrinsic.h> 

•include <Xl l/StringDefs.h> 

•include <X 11/Shell.h> 

r 

* For comparison within main program Will cause default quiz to he k sided in case ol q" jumps, and 

* ;ind will cause "v" jumps to he ignored (no default evaluator is provided) 

*/ 

•define NONE NONE” 

/* Needed to store resulLs as we parse the configuration tile •/ 
typedef struct TutorStnict | 
char Name (2*11. /* For listing in Menus */ 

char Type! 10): f* either TUTOR'. MANUAL . or HELP'*/ 

char Patty 5<)|: /* directory of html files •/ 

char Home|25|: f* first file to load = fume page */ 

char Qutz|25|; f* Special Quiz application, or NONE V 
char Piugram|25|; /* Special Code evaluator, or NONE •/ 
sinici _TutorStnict * next: 

I TuturStruct. • TuurList: 

/* PUBLIC functions pnn: rutorLtsi is provided to facilitate debugging •/ 
extern TulorLisl parseTutorListt): 
extern void pnntTutorLisit): 


•endif 








PARSE5.C 


ltm****»***t, ********************************************************** *********** 

Name: parsed.c Configuration file parser version 5 
Author: James Delani 

Description: This fill parses the configuration file passed as a parameter and reates a linked list of 
TutorStructs. Allows dynamic creation of menus based on an Ascii file. Note that the format of the 
configuration file is very rigid in order to simplify parsing. All of the fields are expected to have entries. ;md 
some fields only allow specific entries. Refer to header file and sample configuration file for more info. 

****************************************************************** I 

#inc!ude parse5.h” 

r 

* Utility function which allows developers to view what was actually read in from the configuration file. 

* Cm be used in development * to ensure that entries were properly read. 

*/ 

void printTuiorList(iutorPTR) 

TutorList lutorPTR: 

1 

TutorList temp: 

if (tutorPTR != NULL) 

I 

temp = tutorPTR; 
printffName TypeVT); 
printfC^s V". temp->Name): 
pnnlff'T s Vi". temp->Type). 
while (temp >next != NULL) 

I/* want to print the contents of the record */ 
temp = temp->next: 
printfr^s V. temp->Name): 
pnmfrSfs Vi". temp->Type): 

1 

I 


r 

* Creates a linked list of TutorStructs a l ihe information is parsed by the parseTutorList (unction After 

* each line is read and interpreted this (i nction is called to add the new structure to the I irked list. 

•/ 

TutorList AddToTutorListl iLtstPir. leMpTRec) 

TutorList tListPtr. 

TutorStruct* tempTRec: 

I 

TutorList new, temp: 

new = maUoclM/eofiTutiN'Slruct)): 
if (new = NULL) 

pnntfi 'Error altocaung memory to ncwVf): 

‘new = ‘tempTRec: 




new->next = NULL; 


/* tListPtr must always point to the head of the list */ 
if (tListPtr =- NULL) /* empty list */ 


tListPtr = new; 


I 

temp = tListPtr; 
while(temp->next != NULL) 
temp =(*temp).next: 
lemp->next = new; 


new = NULL; 
retumf tListPtr); 


/* 

* Function which parses the configuration file and converts into a linked list of TuiorStruct's. Note that 
' numFields depends on the definition of the structure as it appears in the header file. Any changes to 

* these fields will have enormous inpact on this function, and must he accounted for here. 

*/ 

TutorLisi parseTulorLishfilename. tListPtr) 
char * filename; 

TutorList tListPtr. 

I 

FILE * fp; 

TutorStruct lempTRec: 
char linef 1601: 
int numFields = 6: 

char * seps = “;SlNn”: /* Spaces are significant! */ 
char * field: 
int numRec.v= 0: 

fp = fopeni filename, T"); 
if (Ip = NULL) 
pnntfrFile open failed!V); 

while ( (fgetsdine. sizeof(line). fp) != NULL) && (line|0| = # ) ) 

| I* For now -- Don't do anything */ ; 1 

r can process this line . then comes tutor and manual */ 

while < (fgetstline. sizeofOine). fp) != NULL) && (iinefO) !='#') ) 

I 

f* Fust call to stnok require passuig string to he converted which Ls used to set up function lor subsequent 
calls. Uses stmepy in all record assignments since arrays need to have AsciiZem term .nation!!! */ 
it < (field = stft«4c< line .seps)) != NULL) 

I 

/* Field number I is the name ;ls il will appear in MENU */ 
stmcpyltempTRev.Name. field. sireot(lempTRec.Name) I): 


77 





numRecs++; 


I 

f* Subsequent calls to strtok require NULL as first parameter */ 
if ((field = strtok(NULL,seps)) != NULL) 

I 

/* Field number 2 is for ‘REF’ type or ‘TUT’ type */ 
strncpy(tempTRec.Type, field, sizeof(tempTRec.Type) - 1); 
nuinRecs++: 

1 

if ((field = strtok(NULL,seps)) != NULL) 

( 

/* Field number 3 is path where files are located */ 
strncpv(tempTRec.Path , field, sizeof(tempTRec.Path) - 1): 
numRecs++; 

I 

if ((field = strtok(NULL.seps)) != NULL) 

I 

/* Field number 4 is first file to load or Home Page */ 
stmcpy(tempTRec.Hoine . field. sizeof(tempTRec.Home) - 1): 
numRecs++; 

I 

if ((field = strfok(NULL.seps)) != NULL) 

1 

/* Field number 5 is special quiz application assoc with tutor*/ 
stmcpyttempTRec.Quiz. field, sizeofitempTRec.Quiz) - 1); 
numRecs-M-; 

1 

if ((field = strtok(NULL,seps)) != NULL) 
i 

/* Field numher 6 is special code analysis program */ 

sirocpyt tempTRec. Program, field, sizeof(tempTRec.Prognun) - 1); 

numRecs++; 

} 

t* Ensure that line has been parsed properly. Any errors in config file cannot be tolerated, since would 
cause unpredictable errors *1 
if (numRecs != numFields) 

I 

printf(“Error in file format''/)”): 
printfCTrying to parse %s\n”. filemune): 
exit(O): 

1 

numRecs = (h 

tListPtr = AddToTutorListdListPtr. & tempTRec): 

I 

fclose(fp): 

ietum<tListPir): 


7X 







TUTOR5.H 


N;une: tutorS.h Header for Tutor subsystem of ILE, version 5 
Author: Jim Delani 

Description: Header file that is needed for proper execution of tutor and reference subsections of the 
Intelligent Learning Environment. Defines structures and public functions, as well as serving as centntl 
"include” file for most of X11 and Xaw include files. 

* % * a#e * * * * * * * * * * * * * * * * * * % * * 4 c 4 c * * 4c * * * * * * * * % * * * 4c * * * * * * * * * 4 c * % % * * * % * * * * 4c * * * * * * * * * * * * * * * j 

#ifndef HTML_TUTOR_ 

#defme HTML_TUTOR_ 

#include <stdio.h> 

#include <sys/types.h> 

#include <sys/stat.h> 

#include <string.h> 

#include <X11 /Intrinsic.h> 

#include <X 1 l/StringDefs.h> 

#include <X11/Shell.h> 

#include <X1 l/Xaw/Dialog.h> 

#include <X11/Xaw/Text.h> 

#include <X 1 l/Xaw/AsciiText.h> 

#include <X 1 l/Xaw/Command.h> 

#include <X1 l/Xaw/Form.h> 

#include <X 1 l/Xaw/Box.h> 

#include “HTML.h" 

#include "parse5.h” 

/* For use with fseek(); These should NOT be necessary but the Solboumes generated undefined errors 
(sporadically) for some of these. */ 

#ifndef SEEK_SET 
#define SEEK_SET 0 
#endif 

#ifndef SEEK_CUR 
#define SEEK_CUR 1 
#endif 

#ifndef SEEKJEND 
#define SEEK_END 2 
#endif 

/* 

* Public functions for the ITS Tutorial. Each opens up its own window and loads the designated file into 

* the HTML widget. StartTutor obviously starts the Intelligent tutor portion, and has extra facilities (quizzes 

* and program evaluator capabilities) built in. StartHelp is for reference manuals and help files, and merely 

* exploits the simple hypertext mechanism provided for by the HTML W.' -et written by NCSA for Mosaic 

* and WWW browsers 
*/ 

void StartTutorO: 
void SlartHelpt): 




/* 

* HTML Anchor Tags are designated with HREF, ;ind widget itself uses href to designate the name of the 

* anchor. Following the convention of widget code and also style used in Jeremy Payne’s example code. 

* This structure is used to maintain history of * hypertext jumps. This facilitates backtracking. 

*/ 

typedef struct _href ( 
char *href; 
int Cailingld; 
struct _href ‘next; 

( HREF_STRUCT; 

#endif 


TUTOR5.C 

^^*********************************************************************************** 
Name: HTML Help Window / Reference Manager 
Author: Jtunes Delani 

Description: Uses the Athena Widget set and the HTML widget set created by NCSAto provide hypertext 
help capabilities for an intelligent tutoring environment. Entry point is StartTutor, which expects a pointer to 
a TutorStruct as its second parameter. This is used to set up the proper setting to correctly utilize the tutorial. 
The user is provide backtracking capabilities as well as the ability to bailout/clear and return to the first or 
home page. Because of the multiple environment settings as we!' as the possible interaction with other 
facilities (code evaluators, syntax directed editors, etc.), once the user has decided to open a tutorial the Tutor 
button on the main window is disabled. In order to start another tutorial the user must first properly close the 
tutorial currently open. Note that the help facility may be opened concurrently with a tutorial, and that no 
such restriction is currently placed on the help section. The rational is that it is quite feasible to desire to move 
among different help, reference, or manual sections, and requiring a user to reposition the window would be 
an unnecessary inconvenience. However, it is assumed that once a tutorial is opened the user intends to 
complete a lesson or work within a single application. 

Special Acknowledgement: Incorporation of the HTML widget into this project was made considerably 
easier because of the help of Jeremy Payne at NCSA. He provided example code which showed how to 
perform the initialization of the widget as well as how to maintain a history list of hypertext jumps. The basic 
functionality provided in the on-line help systems is modelled after his work 
*************************************************************************************/ 
#include “tutor5.h” 

#include “utils5.h” 

#include “quiz5.IT 

extern Widget TopLevel: 
extern Display ‘display; 

static Widget TutorShell. TutorForm, ExitTutor. BackButton; 
static Widget TutorHome, TutorW. menu_box: 
static Widget Calling Widget; 

static char *tutorText=NULL; 
static char *current_href=NULL; 
static char TulorPath(80|; 
static char HomePagej 100); 


80 





static char *QuizApp=NULL; 
static char *ProgApp=NULL; 

static HREF_STRUCT *BackList=NULL; 

I* Callback functions needed in help section *1 

static void Anchor_callb;ick(); 

static void Back_callback(); 

static void Home_Callback(); 

static void Quit_callback(); 

/* Utility functions needed to manage widgets ;ind history */ 
static void StartITS_TutorO; 
static void ShutDownTutorO; 
static Boolean JumpO; 

/* Utility functions to provide quiz and code evaluation mechanism */ 
static void callProblemO; 
static void callQuiz(); 

I* 

* Starting point of tutorial as far as main procedure is concerned. Sets up environment and path variables. 

* since all jumps are local to the directory the file is located in. Also disables calling widget, which should 

* be tutor button, so that user cannot clobber all of our information and evaluator setup. 

*/ 

void StartTutor(widget. tutorPtr , call_data) 

Widget widget; 

TutorList tutorPtr; 

XtPointer call_data; 


I* TutorPath. HomePage, QuizApp, ProgApp, and CallingWidget are global variables since need to be 
accessed in independent callbacks. Fields of TutorStruct listed in conparse.h */ 
char TEMPI 1001; 
char *NoEntry = “NONE”; 

TutorStnict tutor, 

TEMP101 = \D'; 
tutor = ‘tutorPtr. 
strcatfTEMP. tutor.Path); 
strcpyfTutorPalh. TEMP); 
strcatfTEMP. lutor.Home); 
strcpy(HoinePage. TEMP); 

if(strcmp(tutor.Ouiz. NoEntiy)) 

Quiz App=slidup< tutw.Quiz); 

if(strcmp(tutor.Program. NoEntry)) 

ProgApp=strdup(lutor.Program): 

CallingWidget = widget; 

SuutlTS_T utort HotnePage); 

1 


HI 




/* Creates the window for the tutorial. Provides user with Exit, Back and Home buttons */ 
static void StartITS_Tutor(filename) 
char * filename; 

I 

int n; 

int menuBoxHt = 70; 
int horizDist = 20; 
int ininHeight= 300: 
int minWidth = 400; 

Widget FormB. FonnW: 

if(!loadAsciiFile(filename, &tutorText)) 

( 

Prints tartError( filename); 
return; 

1 

else 

1 

XtVaSetValuesfCallingWidget, XtNsensitive, False, NULL); 
current_href=strdup(filename); 

TutorSheli=XtVaCreatePopupShell(“ITS Tutor”, topLevelShellWidgetClass, TopLevel, 

XtNallowShellResize, True, XtNminHeight, minHeight. 
XtNminWidth, minWidth, NULL); 

TutorForm=XtVaCrcateManagedWidget(“TutorForm”, formWidgetClass. TutorShell. 

XtNborderWidth, 0, NULL); 

menu_box = XtVaCreateManagedWidgetCmenuBox". formWidgetClass. TutorForm. 

XtNborderWidth, 0. XtNheight. menuBoxHt. 

XlNwidth, minWidth, XtNleft, XtChainLeft, 

XtNtop, XtChainTop, XtNright, XtChainRight. NULL); 

ExilTutor=XtVaCreateManagedWidget<“ Quit ”, commandWidgetClass, menu_box, 

XtNhorizDistance, horizDist. XtNleft, XtChainLeft. 

XtNtop, XtChainTop, XtNbottom, XtChainBottom. NULL); 
XtAddCallbackfExitTutor, XtNcallback. Quit_callback, NULL); 


BackButton=XtVaCreateManagedWidgetC Back ”, commandWidgetClass. menu_box, 

XtNhorizDistance. horizDist. XtNfromHoriz. ExitTutor, 
XtNtop. XtChainTop. XtNbottom. XtChainBottom. 
XtNsensitive. False. NULL); 

XtAddCallback(BackBulton. XtNcallback. B;tck_callback. NULL); 

TutorHome=XiVaCreateManaged Widget(" Home ”, commandWidgetClass. menu_box. 

XtNhorizDistance, horizDist. XtNfromHoriz. BackButton. 
XtNtop. XtChainTop. XtNbottom. XtChainBottom. 
XtNsensitive. False. NULL): 

XtAddCallback(TutorHome. XtNcallback. Home Callback, filename): 








* 


TutorW=XtVaCreateManagedWidget( ‘TutorW”. htmlWidgetClass, TutorFonn, 

XtNfromVert, menu_box, XtNbottom, XtCh;iinBouom, 
XtNheight, minHeight, XtNwidth, minWidth. NULL); 
XtAddCallback(TutorW, WbNanchorCallback, Anchor_callback, (XtPointer)O); 

XtRealizeWidget(TutorShell); 

/* Parameters to HTML widget function call tire as follows: 

(Widget, string. Header, Footer, WidgetID. T;irget Anchor. Cached Info */ 
HTMLSetText(TutorW, tutorText, ‘NT, ‘NO”, 0, NULL, NULL); 

XtPopup(TutorShell, XtGrabNone); 

I 

) /* End StartlTS_Tutor Function */ 


Format for href is filename#targetanchor If no target ;inchor has been specified then the beginning of the 
* file is displayed. Else, the target anchor will be positioned at top of screen, 

*/ 

static Boolean Jump(new_href) 
char *new_href; 

I 

char *new_txt, *c; 

char *target_anchor=NULL; 

/* Returns ZERO if EQUAL!! */ 
if(strcmp(new_hrcf, HomePage)) 

I 

XtVaSetValues(TutorHome, XtNsensitive, True, NULL); 

XtVaSetValues(BackButton, XtNsensitive, True, NULL); 

I 

/* strrchr returns pointer to the Last occurence of char in string */ 
if((c=(char *)strrchr(new_href, ‘#’))!=NULL) 

I 

Uirget_anchor=(char * )(c+1): 

*c=N)’; 

I 

if(!loadAsciiFile(new_href, &new_txt)) 

I 

PrintLinkError(ne w_href): 
return; 

I 

if(tutorText!=NULL) 
frce( tutorText): 
iutorText=new_txt; 

f* Parameters to HTML widget function call are as follows: 

(Widget, string. Header. Footer. WidgetID. Target Anchor. Cached Info */ 

HTMLSetTexKTutorW, tutorText. 'Nr. 'Nr. 0. targeijinchor. NULL); 


returo(True): 







/* Function that responds to user selecting BACK button from options. */ 
static void Back_callhack(widget. client_data, call_data) 

Widget widget: 

XtPointer client_data, call_data; 

I 

if( BackL ist==NUL L) 
return; 
else 
1 

if(!strcmp(BackList->href, current_href)) 

HTMLGotoId(TutorW, BackList->CallingId); 
else if(Jump(BackList->href)) 

I 

free(current_href): 

current_href=strdup(BackList->hreO: 

HTMLGotoId(TutorW. BackList->Callingld): 

) 

PopBacklistf & BackList); 
if (BackList == NULL) 

XtVaSetValues(BackButton, XtNsensitive, False. NULL): 


/‘ 

* Callback function to respond to user clicking on the HOME button at the top of the HTML form. Currently 

* clears the entire BackList. similar to a reset or start over. Loads the First page visited (Home Page) 

*/ 

static void Home_Callback(widget, client_data, call_data) 

Widget widget; 

XtPointer client_data, call_data; 

{ 

char ‘target = strdup(HomePage); 

/* Note that even if same File currently loaded need to reread File 
since HomePage does not have CallingID associated with it */ 
if(Jump( target)) 

I 

ClearBackhst(&BackList); 

free(current_href): 

current_href=target; 

I 

else 

free( target); 

/* We need to disable the Home and Back buttons now */ 

XtVaSetValues(TutorHoine. XtNsensitive. False, NULL); 

XtVaSelValues(BackBulton, XtNsensitive, False, NULL); 

I 


K4 




/********************************************************************* 

Fields of the data parameter passed to Callback function: 

XEvent*event 

intelement_id => The ID of Anchor selected 
char*text => The String used to display anchor 
char*href => Name of target file & anchor to jump to 
*%***********%****%************%*************%*****%******************/ 

/* 

* Callback needed to be provided when instantiating HTML widget Currently a filename extension of q’ 

* or *y’ indicates special jump and needs to be handled accordingly. A jump which begins with a '#’ indicates 

* a jump within the same file, and needs to be handled a little differently than fully specified jumps. 

*/ 

static void Anchor_callback(widget. client_data, data) 

Widget widget; 

XtPointer client_data; 

WbAnchorCallbackData *data: 

1 

char *new_href=strdup(data->href); 
char *c, tempi 1(K)]; 
int CallingID; 

temp[0] = ‘\0’; 

CallingID = (*data).eleinent_id; 
if(*new_href = '#') 

( /* HTML-legal local jump within same file */ 
int newID; 
c = new Jiref; 
c++: 

strcat(temp, c); 

newID = HTMLAnchorToId(TutorW, temp); 
if(!newID) 

I 

printff'Unable to determine new Widget IDV); 

I 

HTMLGotoId(TutorW, newID); 
if(!PushBacklist(&BackList, current_href, CallingID)) 

PrintMemory Warning!); 

XtVaSetValuesfBackButton, XtNsensitive, True. NULL); 

XtVaSetValues(TutorHome, XtNsensitive. True. NULL); 
return; 

1 

else 

I 

f* First need to set up path information for file */ 

strcat(temp. TutorPath), 

strcat(temp. new_href); 

free(new_href); 

new_href = strdup(temp); 






/* Next need to check for special file extensions strchr returns pointer to 1st occurence */ 
if((c = (char *)strchr(new_href,!= NULL) 

I 

C++; 

if (*c ==' 4 ') 

I 

callQuiz(new_href); 

return; 

I 

else if (*c ==’y’) 

( 

callProblem(new_hreO; 

return; 

} 

else if ((*c ==’j’) II (*c == ‘g‘) II (*c == - x’)) 

I 

CallPictureViewer(new_href); 

return; 

I 

else if ((*c =’a’) II (*c == ‘w’)) 

{ 

CallAudioPlayer(newhref). 

return; 

I 

1 /* end if strrchr */ 
if(Juinp(new_hreO) 

I 

if(!PushBacklist(&BackList, current_href. CallinglD)) 

PrintMemoryWamingO; 

free(current_href); 

current_href=new_href; 

I 

else 

free(new_hreO: 

| f* end else not local jump */ 

I 

/* Clears out back list of href s. frees allocated memory, <tnd shuts down tutorial * 
static void ShulDownTutorf) 

I 

ClearBackIist(&BackList); 

if(tutorText!=NULL) 

I 

free(tutorText); 

tutorText=NULL; 

I 

if(current_href!=NULL) 

I 

lree(curTent_href); 

current_href=NULL; 





if(QuizApp!=NULL) 

( 

free(QuizApp); 

QuizApp=NULL; 


if(ProgApp!=NULL) 

I 

free(ProgApp); 

ProgApp=NULL: 

I 


XtPopdown(TutorShell): 

XtDestroyWidget(TutorShell); 

XtVaSetValues(CallingWidget, XtNsensitive. True. NULL); 


/* 

* Cillback function for Quit button. Provide level of indirection is in case we decide to provide 

* popup confirm dialog box 
*/ 

static void Quit_callback(widget, client_data, call_data) 

Widget widget; 

XtPointer client_data, call_data; 

1 

ShutDownTutor(); 

I 

/* Function which handles hypertext jumps to quiz questions. */ 
static void callQuiz(command_line) 
char * commandjine; 

( /* Returns ZERO if EQUAL!!! */ 
if(QuizApp != NULL) 

< 

char sysCommandf 100]; 
sysCommand[())=’M)’; 
strcat(sysCommand, QuizApp); 

strcat(sysComm;ind," “); f* To ensure sep;iration for cmd line */ 

strcat( sysCom mtind, comin;ind_line): 

system(sysCommand); 

) 

else 

I 

StartQuiz(cominandJine): 


X7 





/* 

* Function which handies jumps to program evaluator topics. Several ways to handle this, for now we will 

* just c;dl an ev;duator front end and pass the filenam which contains the problem statement. 

*1 

static void callProblem(commandJine) 
char * commandjine; 

{ 

if(ProgApp != NULL) 

I 

char sysCominandl 1(K)J; 
sysCommand[()|=’\0’; 
strcat(sysCommand, ProgApp); 

strcat(sysCommand. “ “); /* To ensure separation for cmd line */ 

strcat( sy sCom inand, com mand_line): 

system(sysCommand): 

I 

else 

I 

printf(“Attempted hypertext link to unspecified program.Nn”); 
printf(“Unable to complete request.Nn’’); 

I 


HELP5.C 

j******************************■**************************************+*** 

Name: helpS.c Help ;ind Manual Subsystem Version 5 
Author: James Delani 

Description: Uses the HTML widget set created by NCSA to provide hypertext help capabilities. This code 
is based on the Athena Widget Set which is included in the standard distribution of the X Window System 
available from MIT. Entry point is StartHelp, which expects a pointer to a TutorStnict as its second 
parameter. Of particular concern to this function is the path and Filename to load in'o the HTML widget (The 
other entries are mainly for the tutorial, and possibly for expansion later on). The user is provide backtracking 
capabilities as well as a bailout/clear capability to return to the opening screen. Once the user sets up the 
window he/she may select other help files to view without having to first close the window. This enables users 
to customize their own programming environment, and possibly switch between several different reference 
files 

.Special Acknowledgement: Incorporation of the HTML widget into this project was made considerably 
easier because of the help of Jeremy Payne at NCSA. He provided example code which showed how to 
perform the initialization of the widget as well as how to maintain a history list of hypertext jumps. The basic 
functionality provided in the on-line help systems is modelled after his work 

^34t^3te^^^4E^^^3^4c3|e4e4e4ca*c3#(4e3#e4ts«e4c3#ca#c4e3fca#r3#rskatea|c3fca«r%3«ca#c3^3*ca#e4c4e3fea#e%3fe3#ca#c3#e4ea#ca#cafc3|c4ca|e^3tca#c3|c3#c3#c4e4e3#t4e4e4ca#e3#ca|c4c3#e3te3tr j 

#include “tutorS.h" 

#include "utilsS.h" 

extern Widget TopLevel; 
extern Display *display; 

static Widget HelpShell. HelpFonn. ExitHelp, BackButlon; 
static Widget HelpHome. HeipW. menu_box: 





static Boolean HelpWindowOpen; 

static char *helpText=NULL: 

static char *current_href=NULL; 

static char HomePage[100]; 

static char HelpPath[80]; 

static HREF_STRUCT *BackList=NULL: 

/* Callback functions needed in help section */ 

static void Anchor_callback(): 

static void Back_callback(); 

static void Home_Callback(); 

static void Quit_callback(); 

static void StartITS_Help(); 

static void ShutDownHelpO; 

static Boolean Jump(); 

/* 

* Skirting point of help section as far as main procedure is concerned. Sets up environment and path 

* variables, since all jumps are local to the directory the file is located in. Note that (unlike tutorial) we 

* allow user to set up a help window and jump between different reference files. Although selecting new 

* help file will clobber till previous info, it does make it easier for user to manage environment, especially if 

* using as programmers reference tool. This also allows having single file for both Manual and Help 

* selections. 

*/ 

void StartHelp(tutorPtr, calf data) 

TutorList tutorPtr; 

XtPointer call_data: 

i 

/* HelpPath, HomePage, and HelpWindowOpen are globttl variables */ 
charTEMP[100]; 

TutorStmct tutor, 

TEMPIO] =‘Ml’; 
tutor = ‘tutorPtr: 
strcat(TEMP, tutor .Path); 
strcpy(HelpPath, TEMP); 
slrcat(TEMP, tutor.Home); 
strcpyfHomePage, TEMP); 

if(!HelpWindowOpen) 

StartJTS_Help(HomePage): 

else 

( 

ClearBacklisl(&BackList); 

XtVaSetValuesfHelpHome, XtNsensitive, False, NULL): 
if(Jump(HomePage)) 

I 

free(curTent_href): 
current_href = strdup( HomePage); 



/* Creates the help window. Provides user with Exit. Back ;ind Home buttons for navigation ;ind control.*/ 
static void StartITS_Help(niename) 
char *filename; 

I 

int n; 

int menuBoxHt = 70; 
int horizDist = 20; 
int minHeight= 300; 
int minWidth = 400; 

Widget FonnB, FonnW; 

iff! IoadAsciiFile( filename, &helpText)) 

1 

Prints tart£rror(filename): 
return; 

1 


HelpShell=XtVaCreatePopupShell(“ITS Help”, topLevelShellWidgetClass. TopLevel, 

XtNallowShellResize, True, XtNminHeight, minHeight. 
XtNminWidth, minWidth, NULL); 

HelpForm=XtVaCreateManagedWidget(“helpform”, formWidgetClass, HelpShell. 

XtNborderWidth, 0, NULL); 

menu_box = XtVaCreateManagedWidget('‘menuBox”. formWidgetClass, HelpForm. 

XtNborderWidth. 0, XtNheight, menuBoxHt. 

XtNwidth, minWidth. XtNleft. XtChainLeft, 

XtNtop, XtChainTop, XtNright, XtChainRight, NULL); 


ExitHelp=XtVaCreateManagedWidget(” Quit commandWidgetClass, menu_box, 

XtNhorizDistance, horizDist, XtNleft, XtChainLeft, 

XtNtop, XtChainTop, XtNbottom, XtChainBottom, NULL): 
XtAddCallback(ExitHelp, XtNcallback, Quit_callback, NULL); 


BackButton=XtVaCreateManagedWidget(“ Back ”, commandWidgetClass, menu_box. 

XtNhorizDistance, horizDist, XtNfromHoriz, ExitHelp. 
XtNtop, XtChainTop, XtNbottom. XtChainBottom, 
XtNsensitive, False, NULL); 

XtAddCallbackfBackButton, XtNcallback, Back_callback, NULL); 

HelpHome=XtVaCreateManagedWidget(” Home ”, commandWidgetClass, menu_box, 

XtNhorizDistance. horizDist, XtNfromHoriz. BackButton, 
XtNtop, XtChainTop, XtNbottom, XtChainBottom. 
XtNsensitive, False, NULL); 

XtAddCalIback(HelpHome. XtNc;dlb;ick, Home_C;dlback. NULL): 

HelpW=XtVaCreateManagedWtdget(“HelpW”, htmlWidgetClass, HelpFonn, 

XtNfromVert, menu_box, XtNbottom, XtChainBottom. 
XtNheight. minHeight, XtNwidth, minWidth. NLJLL): 


90 






XtAddCallback(HelpW, WbNanchorCallback, Anchor_callback. (XtPointer)O); 
XtRealizeWidget(HelpShell); 

[* Parameters to HTML widget function c;il! tire ;ls follows: 

(Widget, string. Header. Footer, WidgetID. Target Anchor, Cached Info) */ 

HTMLSetText(HeIpW, helpText, “\0”, 'NT. 0. NULL, NULL): 

current_href=strdup(filename); 

XtPopup(HelpShe!l, XtGrabNone): 

HelpWindowOpen = TRUE: 

) /* End StartITS_Help Function */ 

/* 

* Format for href is fi!ename#targetanchor If no target is specified we need to have beginning of file 

* displayed in window, otherwise will require target anchor to be positioned at top of window. 

*/ 

static Boolean Jump(new_href) 
char *new_href; 

1 

char *new_txt, *c; 

char *target_anchor=NULL; 

/* Returns ZERO if EQUAL!! */ 
if(strcmp(new_href, HomePage)) 

I 

XtVaSetValuesfHelpHome, XtNsensitive, True. NULL); 

XtVaSetValues(BackButton, XtNsensitive, True, NULL); 

} 

if((c=(char *)strrchr(new_href, ‘#’))!=NULL) 

{ 

target_;inchor=(ch;ir *)(c+l); 

*c=N)’; 

I 


if(!loadAsciiFile(new_href, &new_txt)) 

1 

PrintLinkError(new_href): 

return; 

I 


if(helpText!=NULL) 

free(helpText); 

helpText=new_txt: 

f* Ptmuneters to HTML widget function c;dl tire its follows: 

(Widget, string. Header, Footer, WidgetID, Target Anchor, Cached Info */ 
HTMLSetText(HelpW, helpText, “M)”. "N)". 0, target_anchor, NULL); 


retum(True); 






/* Function that responds to user selecting BACK button from options. */ 
static void Back_callback( widget. client_data, call_data) 

Widget widget; 

XtPointer client_data, call_data: 

I 

if(BackList==NULL) 

return; 

else 

I 

if(!strcmp(BackList->href, current_hreO) 

HTMLGotoId(HelpW. BackList->CallingId): 
else if(Jump(BackList->hreO) 

1 

free(current_href); 

current_href=strdup(BackList->href); 

HTMLGotold(HelpW. BackList->Callingld); 

I 

PopBacklistf&BackList); 
if (BackList == NULL) 

XtVaSetValues(BackButton, XtNsensitive, False. NULL); 


/* Callback function corresponding to HOME button. Acts ;is a Clettr/ Start Over button */ 
static void Home_Callback(widget, client_data, call_data) 

Widget widget; 

XtPointer client_data. call_data; 

I 

char *target=strdup(HomePage); 

if(Jump( target)) 

I 

ClearBacklistf&BackList); 

free(current_href); 

current_href=target; 

I 

else 

free(target); 

/* We need to disable the Home and Back buttons now */ 

XtVaSetValues(HelpHome. XtNsensitive, False, NULL); 

XtVaSetValues(BackButton, XtNsensitive. False, NULL); 


jit * * * * * * * * * * * «* * * * * * * * * * * * * * * * * ** * * * * * * * * * * * * * * * * ** * * * * * * * 4c * * * * * * ★ * * * * * 

Fields of the data parameter passed to Callback function: 

XEvent *event 

int eiementjd => The ID of Anchor that was selected 
char *text => The string used to display anchor 

char *href => The name of target file & anchor to jump to 

******************************★****************************************/ 


92 





/* Callback needed to be provided when instantiating HTML widget */ 
static void Anchor_callback( widget. client_data, data) 

Widget widget; 

XtPointer client_data; 

WbAnchorCaJlbackData *data; 

I 

char *new_href=strdup(data->href); 
char *c; 

char teinp[ 100); 
int CallingID; 

/* First check if hypertext link is to a specially formatted file, ie jpeg. gif t', etc. */ 
if((c = (char *)strchr(new_href,'.')) != NULL) 

I 

if ((*c =='j’) II (*c = ’g’) II (*c = ‘x’)) 

(/* filename.jpeg or filename.gif or filename.xbm */ 

CallPiclureViewer(new_href); 

return; 

} 

else if ((*c —’a') II (*c == ’w’)) 

(/* ftlename.au or ftlename.wav */ 

CallAudioPlayer(newhref); 

return; 

I 

| f* end if stnrchr */ 

/* If we get this far then it should be standard hypertext jump */ 
tempfO] = ‘\0’; 

CallingID = (*data).element_id; 

I* HTML => local jump within same file doesn’t require filename */ 

if(*new_href = #’) 

I 

int newID; 
c = new_href; 

C++; 

sU'caKtemp, c); 

newID = HTMLAnchorToId(HelpW, temp); 
if(!newID) 
t 

printfCAnchor didn't create ID\n”); 

newID = HTMLAnchorToId(HelpW, new_href); 

if(!newID) 

printff*Didn’t work with original href eitherlNn"); 

1 

HTMLGotoId(HelpW. newID); 
if(!PushBackIist(&BackList, current_href. CallingID)) 

PrintMemoryWarningO; 

XtVaSetV;dues(HelpHome, XtNsensitive. True. NULL); 
XtVaSetValues(BackButton, XtNsensitive, True. NULL): 
return; 

I 

else 


93 







I /* else target anchor is to specific file */ 
strcat(temp, HelpPath); 
strcat(temp. new_href); 
free(new_hreO: 
new_href = strdup(temp); 

if(Jump(new_href)) 

1 

if(!PushBacklist(&BackList. current_href. CallingID)) 
PrintMemoryWamingO; 
free(current_href); 
current_href=new_href; 

I 

else 

free(new_hreO; 

I 


/* Cle;irs out back list of href’s and shuts down tutorial */ 
static void ShutDownHelpO 
( 

if(helpText!=NULL) 

{ 

free(helpText); 

helpText=NULL; 

I 

ClearBacklistf&BackList); 
if(c urrent_href!=NULL) 

( 

free(current_href); 

current_href=NULL: 

I 


XtPopdown(HelpShell); 
XtDestroyWidget(HelpShell); 
HelpWindowOpen = FALSE; 


/* 

* Callback function for Quit button. Level of indirection is in case want to incorporate popup dialog 

* with exit confirmation message 

7 

static void Quit_callback(widget, client_data, call_data) 

Widget widget; 

XtPointer client_data, call_data; 

I 


94 


ShutDownHelpO; 





UTILS5.H 


j*t % * * ** * * * * * * * * % % * * * * * * ** * * * * ★ * * * * * ** * * * * *★ % * * * % ** * * 4c * * * * * * * * 4c * * * 34 c * * * * * 

Name: utils5.h Header file for Utility section of ILE 
Author: James Delani 

Description: Provides utility functions needed to facilitate backtracking capabilities and for loading contents 
of text files into the hyper text widget. This header file is included by the following programs: tutor?.c. 
help5.c, and quiz5.c. Note that the type 'Boolean' is defined in the Xt Intrinsics toolkit. If modify system so 
that doesn’t use this then will have to define type or change to type integer. Provide several functions for 
displaying error messages to stderr. PrintMemoryWaming designed to be used when PushBacklisl cannot 
allocate memory to add new item to backlist. PrintStartError for use when the system ctinnot read or properly 
load the filenames needed to start one of the subsystems causing abort of start operation. PrintLinkError 
for use when hypertext link requested cannot be performed, so system is ignoring request. 

*********************%**********************%******************************* j 

#ifndef _UT1LS_H_ 

#define _UTILS_H_ 

/* Public Functions provided */ 

Boolean PushBacklistO: 
void PopBacklistf); 
void ClearBacklist(); 

Boolean loadAsciiFile(); 
void PrintStartErrorO; 
void PrintMemoryWaming!); 
void PrintLinkError(); 

/* For handling special files designated in hypertext link */ 
void CallAudioPlayerO; 
void CallPictureViewer(); 
void CallPostScriptViewer(); 

#endif 

UTILS5.C 

^************************************************************************ 

Name: utils5.c Utility functions for Intelligent Learning Environment 
Author: J tunes Delani 

Description: Provides utility functions needed to facilitate backtracking capabilities and for loading contents 
of text files into the hyper text widget. Used by tutor5.c. help5.c, and quiz5.c. 
****************************************************************************/ 

#include ''tutor5.h" 

#include “utils5.h” 

/* Reads in the text file and loads it into string for the HTML widget */ 

Boolean loadAsciiFileffilename, txt_ptr) 
ch«ir ‘filename. “txt_ptr; 
i 

char * buffer; 
int bytes_read=<); 

FILE ‘filePtr; 
struct stilt file Jnfo; 


95 








if((filePtr=fopen(filename, "r”))—NULL) 
retum(False); 

if( slat(filename. &file_info) != 0) 

I 

fclose(filePir); 

return(False); 

I 

buffer=(ch;ir *)malloc(file_info.st_size + 5): 
if(buffer == (char *) NULL) 

{ 

fclose(filePtr); 

retum(False); 

) 

bytes_read = fread( buffer. 1, file_info.st_size. filePtr); 
fclose(FilePtr); 

bufferffile_info.st_size -1| = 'NO'; /* truncate buffer*/ 
if (bytes_read < file_info.st_size) 

{ 

free(buffer); 

retum(False); 

t 

*txt_ptr = strdup(buffer); 

free(buffer); 

retum(True); 


/* 

* Prints error message in the event that could not load hunl file into string. 

* Informs user why the link was not executed. 

*/ 

void PrintLinkErrorffilename) 
char * filename; 

( 

printf(“WARNING!\nCould not read filename: %s\n”, filename): 
printf(“Unable to execute hypertext link so ignoring request\n”); 

I 


/* 

* Prints error message in the event that could not load HomePage when starting up application. 

* Nomudly means path info incorrect or problem with file system. 

*/ 

void PrinlSl;irtError(filename) 
char * filename; 

I 

printf(“WARNlNG!\nCould not read filename: %s\n”. filename): 
printfC'Unable to start subsystem application as requested.W); 


96 



/* 

* Utility function that adds the current href to the backlist prior to making a hypertext jump. This allows 

* us to provide simple backtracking mechanism for user to single step back through jumps 
*1 

Boolean PushBacklist(back_!ist. href, widgetID) 

HR£F_STRUCT **back_list; 
char *href; 
int widgetID; 

1 

HREF_STRUCT *new; 

new=(HREF_STRUCT *)malloc(sizeof(HREF_STRUCT)); 
if (new == (HREF_STRUCT *)NULL) 
return False; 

else /* for semantic correctness */ 

I 

new->href=strdup(href); 

new->CallingId=widgetID; 

new->next=*back_list; 

*back_list = new; 
return True; 

1 


/* Utility function to pop single entry from Backlist (history of jumps). */ 
void PopBacklist(backJist) 

HREF_STRUCT **backjist; 

I 

HREF_STRUCT *tempPtr; 

/* Safety check before we do any thing */ 
if(*back_list==NULL) 
return; 

else /* for semantic correctness */ 

1 

tempPtr=*backJist; 

" l 'backJist=tempPtr->next; 

free(tempPtr->hreO; 

free(tempPtr); 


/* Utility function to clear Backlist and deallocate memory / 
void ClearBacklistfback Jist) 

HREF_STRUCT **back_list; 

I 

while(*back_Iist != NULL) 

PopBacklist(back_list); 


97 




/* Warning Message for allocation error cluing PushBacklist */ 
void PrintMeinoryWarningO 
1 

printf("WARNING: Error encountered while trying to dyn;unic;tlly allocate memory An"): 
printf(“This failure indicates system memory resources are dangerously low An”): 
printf(“which could be caused by a number of reasons. You may wish to exit\n”); 
printfC'the application and try again later..An”); 


/* 

* Function which handles jumps to jpeg, giff and xbm formatted files 

* P;isses filename as command line argument to xview 
*/ 

void CallPictureViewer(filename) 
char * filename; 

I 

char sysCoinmand) HR)]; 

sysCommand[0]=’\0': 
strcat(sysCoinmand, “xv “); 
streatf sysCoinmand, filename): 
system(sysCoinmand); 


/* Function which handles hypertext links to sound files */ 
void CallAudioPlayerffilename) 
char * filename; 

I 

printffAudio capabilities currently not implemented.Xn”); 
printff‘Unable to execute link as requested.\n“); 


/* 

* Function which will handle jumps to postscript files. (Currently not implemented) 

* Passes filename as command line argument to ghostview 
*/ 

void CallPostScriptViewer(fdename) 
char * filename; 
i 

char sysCominand] 100]: 

sysCommand(()|=’M)‘: 
strc;it(sysCoinmand. “gv “); 
strcat(sysComm;ind, filename): 
system(sysComin;ind); 



QUIZ5.H 

j+m *** ***** * *** * *** ** * ***** * ** * ***** ***** * ****** *** **** 4c 4C* * 4C ** * * *************** * 

Name: quiz5.h Header File for default quiz application for 1LE 
Author: Jim Delani 

Description: Header file for default quiz portion provide with the intelligent learning environment. This does 
not create an elaborate student model, nor maintain any information on the student. Simply provides a 
mechanism for tutorial authors to add quiz functionality without having to do work themselves. Requires 
both a question file and an answer file in order to work properly. Question files must have an extension of 
"quiz", as in “filename.quiz". while the solution file must he have the same base filename, but an extension 
of "soln". as in the following example: 

Quiz question file => section 1.quiz 
Quiz solution file ==> section I.soln 

Hypertext jumps that indicate answers to question must be labeled as follows: <A HR£F=##1_A> . where 
the '##' flags link as a quiz answer, and the ‘ l_A’ is interpreted as meaning “User has selected Question 1. 
Answer A". Currently allows up to 10 questions, and each question can have up to four distractors. Note 
that questions and answers should match exactly, and we do not guarentee results of trying to evaluate non¬ 
existent questions. The quiz function opens up a separate window and takes exclusive control over the system. 
Quiz questions and answers appear as normal hypertext jumps and are only distinguishable by the context in 
which they appear. 

********************************************************y 

#ifndef HTML_QU1Z_ 

#define HTMLQUIZ_ 

r 

* Public function for starting default quiz. Note that function expects fully specified filename (must include 

* path), and looks for solution file in stune directory. 

*/ 

void StartQuiz(); 

/* Callback functions needed from within quiz portion */ 

static void SignalAnswerO: 

static void exit_cb(): 

static void about_cb(); 

static void really_exit_cb(); 

static void cancel_cb(): 

f* For maintaining information on each question */ 
typedef struct _Quiz_Slruct | 
char Questionl 10): 
char Correct: 

String Message A; 

String MessageB 
String MessageC; 

String MessageD; 

1 QU£Z_STRUCT; 

static String ExitQuizConfinn = 

"Do you really want to exitTViNn"; 




static String AboutQuizVersion = 
‘Preliminary Release of Vi\ 
the QUIZZER!\n\n\ 

Created by Jim Delani\n”: 

#endif 


QUIZ5.C 

/************************************************************************* f* 

Name: quiz5.c Default Quiz Application for ILE 

Author: Jim Delani 

Description: Provides a Quiz interface mechanism in support of the intelligent learning environment. Uses 
the hypertext capabilities of the HTML widget to provide explanations as to why answers are correct or 
incorrect. Starting point of quiz function is StartQuiz, which expects fully specified filename as its only 
parameter. The path information is critical, since the function uses this information in conjunction with the 
filename information to read the solution file as well. For example, a filename of “/root/tmp/section 1 .quiz" 
will have a corresponding solution file of “/root/tmp/section l.soln" (or else this function will abort the quiz 
application. Note that the format of the solution file is fairly rigid, which was inteneded to make the parsing 
process a little easier. Format of solution file is as follows: 

. Beginning of Example . 

QUEST. 1 = C 
ANS_A 

message explaining why A not correct goes here 

END_ANS 

ANS_B 

message explaining why B not correct goes here 

END_ANS 

ANS_C 

message explaining why C IS CORRECT goes here 

END_ANS 

ANS_D 

message explaining why D not correct goes here 

END_ANS 

END.QUEST 

. End of Example - 

The number of questions is limited to 10, and each question may have up to four possible answers. Note that 
line 1 of the example states that Reply C is the correct answer to this question. All of the QUEST_, ANS_. 
and END_ANS tokens must appear in the leftmost column in order to be recognized (beginning of line) 

* ** * * ** ★ * * ★ * * * * * * * * ★ ★ * ★ * ★ * * * ** * 4c * * * * * * * * * * * * * * * * * * 4c * * * * * * * * * * * * * ★ * * * 4c * * ★ * * * j 

#include “tutorS.h” 

#include “utils5.h" 

#include "quiz5.h" 

#define ARRAYS1ZE 10 

extern Widget TopLevel; 
extern Display ^display; 

static Widget QuizShell, QuizForm, ExitQuiz, Quizlnfo: 


1(M) 










static Widget QuizW, QuizHome. QuizBack, menu_hox: 

static Widget CallingWidget. pshell: 

static int CallingID, NumWrong=0, NumRight=0; 

static char *quizText=NULL; 

static ch;ir HomePagef UK)); 

static char * current_href; 

static HREF_STRUCT *BackList=NULL; 

static QUIZ_STRUCT Currentlnfo: 

static QUI2_STRUCT * MessageArray[ARRAYSIZE]: 

static void Home_Callback(): 
static void Back_Callback(); 
static int NumQuestions = 0; 

/* Parses the solution file and loads into the Message array */ 
static Boolean load_solution(filename) 
char ‘Filename: 

< 

int arraylndex=0, bytes_read = 0; 

FILE ‘filePtr; 

long int startPos, endPos, AnswerLength, tempPos; 

char *c, ‘NewAnswer, MsgNum: 

char Iine[ 100]; 

char * seps = " \t\n="; 

char * field; 

QUIZ_STRUCT * tempAnswerPtr; 

Boolean Done = False; 

if((filePtr=fopen(filename, “r”))=NULL) 
retum(False); 

while ((fgetsfline, sizeoffline), filePtr) != NULL) && (stmcmpfline. “QUEST’. 5))) 
{ ; /* Ignore any comments or prolog */ | 
if (feofffilePtr)) 
return False; 

while (IDone) 

1 

tempAnswerPtr = (QUIZ_STRUCT *)malloc(sizeof(QUIZ_STRUCT)); 
ifftempAnswerPtr == NULL) 

1 

PrintMemoryErrorO; 
return False; 

1 


/* Now need to determine question number and correct answer. Currently do not use this, but will be 
necessary if desire to create elaborate student model. Note that if correct answer is not provided there is 
no way a student can match the correct answer! */ 
if((c = strchrOine, •=’)) != NULL) 

1 

*c = 'W; 

C++; 


101 







while(*c == ’ ") 
c++: 

tempAnswerPtr->Correct = *c: 

I 

else 

tempAnswerPtr->Correct = '\()’: 

strcpy(teinpAnswerPtr->Question,line); 
fgets(line. sizeof(line), filePtr); 

/* This loop processes all of the answers to a particular question, note that a maximum of four answers 
is allowed for any question.*/ 

while (strncmp(line, “END_QUEST’\ 9)) /* Returns Zero if EQUAL */ 

i 

/* Skip over any blank lines until get to start of answer*/ 
while (stmcmpdine. “ANS”, 3)) /* Returns Zero if EQUAL */ 

( 

fgets(line, sizeof(line), filePtr): 

I 

/* Format for answer is "ANS_X”, where X represents answer */ 
c = (char *)strchr(line,’); 

C++: 

MsgNum = *c; 

/* We are now at beginning of answer */ 
smrtPos = ftell(filePtr); 
fgets(line, sizeof(line), FilePtr): 

/* Now need to find out how big it is */ 

while (stmcmp(line, “END_ANS”, 7)) /* Returns Zero if EQUAL */ 

1 

endPos = ftell(filePtr); 
fgetsfiine, sizeof(line), filePtr); 

/* Note that we consume EndAns flag */ 

I 

tempPos = ftell(filePtr); 

AnswerLength = endPos - startPos: 

NewAnswer = (chtir *)malloc( AnswerLength + 5): 
if (NewAnswer == (char *)NULL) 

I 

PrintMemoryError(); 
return False: 

} 

fseek(filePtr, startPos, SEEK_SET); 

bytes_read = ffead(NewAnswer, 1, AnswerLength, filePtr); 

NewAnswer!AnswerLength -1] = ‘Ml’: 
if (bytes_read < AnswerLength) 

( 

printfC'Unknown read error occured while reading solution file.Nn”); 
return False: 


102 




switch (MsgNum) 

{ 

case A’: tempAnswerPtr->MessageA = (String)NewAnswer; break; 
case ET: tempAnswerPtr->MessageB = (String)NewAnswer; bre;ik; 
case *C': tetnpAnswerPtr->MessageC = (String)NewAnswer; bre;tk; 
case 'D’: teinpAnswerPtr->MessageD = (String)NewAnswer: break; 
default: ; 


fseek(filePtr, tempPos, SEEK_SET); 
startPos = endPos = tempPos; 

fgets(line, sizeof(line), filePtr); 

/* Looking for one of two Keys here, and need to consume whitespace */ 
while ((strncmpOine, “ANS”, 3)) && (strncmpOine. “END_QUEST", 9))) 
I 

igetsfline, sizeof(line), filePtr); 

1 

( /* while NOT EndQuest */ 

I* Note that EndQuest loop consumes Flag it is looking for */ 

Message Array [ ;irray Index ] = tempAnswerPtr; 
tempAnswerPtr = NULL; 
arraylndex ++; 

fgets(line, sizeofdine), filePtr); 

while ((!feof(filePtr)) && (stmcmpfline, “QUEST”. 5))) 

1 

fgets(line, sizeof(line), filePtr); 

/* ignore all blank spaces , need to get to next header */ 

I 

if (feof(filePtr) II (arraylndex >= ARRAYSIZE)) 

Done = TRUE: 

} f* while (! Done) */ 
fclose(filePtr); 
return True: 

I 


/* 

* Callback needed to be provided when instantiating HTML widget NOTE: Currently Quiz only allows 

* jumps within same filename. Maintaining two pointers, c ;ind new_href, since may want to allow multiple 

* files, then will have to maintain filentime info for back list. Easier to implement if already set up. 

V 

static void Anchor_callback(widget, client_data, data) 

Widget widget; 

XtPointer client_data; 

WbAnchorCallbackData *data; 


int newID, Index; 

char tempi KK)]; 

char * c. Solution, User Answer; 


103 



char * new_href = strdup(data->href); 
teinpfO] = 'NO': 

/* For the quiz, selecting an answer to a question returns an anchor with two '#" symbols. Any other 
anchor represents a legitimate jump, whether to another question, top of page or what have you. 
Currently the ONLY legal jumps tire within the same page. */ 
if(stmcmp(new_href. 2)==0) 

I 

/* format of answer = ##Nuin_Letter */ 
c = (char *)strrchrinew_href, 

*c = ''O’: 

User Answer = *(c+1); 
c-; 

Index = (atoi(c) - 1); 

Solution = (MessageArray[Index]->Correct); 

if(Solution == UserAnswer) 

I 

NumRight++; 

SignalAnswer(True, Index, UserAnswer); 
return; 

I 

else 

{ 

NumWrong++; 

SignalAnswer(False, Index, UserAnswer); 
return; 


else if(*new_href — *#’) 

( 

c= new_href; 

C++; 

strcat(temp, c); 

newID = HTMLAnchorToId(QuizW, temp); 
if(!newID) 

{ 

printf(“Error attempting local jump. \n”>; 
printff'Unable to complete hypertext link ;is requested.Nn"); 
) 

else 

I 

HTMLGotoId(QuizW, newID); 

CallingID = (*data).element_id; 
if (!PushBacklist(&BackList, current_href, CtillingID)) 
FVintMemoryWtimingO; 

XtVaSetVaJues(QuizHome, XtNsensitive, True, NULL); 
XtVaSetValues(QuizBack, XtNsensitive. True, NULL); 
return; 


104 






else 

printffQuiz currently has single file capabilities only.Nn"): 
printf(“Ignoring request to load external file.Nn"): 

) 


/*Function that responds to user selecting BACK button from options. */ 
static void Back_Callback(widget. client_data, call_data) 

Widget widget: 

XtPointer client_data. call_data; 

( 

if(BackList==NULL) 

return; 

else 

( 

HTMLGotoId(QuizW, BackList->CallingId); 

PopBacklistf&BackList); 

if (BackList == NULL) 

XtVaSetValues(QuizBack, XtNsensitive, False. NULL); 

I 


/* 

* Callback function to respond to user clicking on the HOME button at the top of the HTML form. 

* Currently clears the entire BackList, similar to a reset or start over. Loads Home Page (Fast page viewed 
*/ 

static void Home_Callback(widget, client_data, call_data) 

Widget widget; 

XtPointer client_data, call_data; 

I 

char * target = strdup(HomePage); 
char *textPtr; 

/* Note th;it even if same file currently loaded need to reread file since HomePage does not have 
CallingID associated with it */ 
if(loadAsciiFile(HomePage, &textPtr)) 

I 

ClearBacklistf&BackList); 

HTMLSetTexUQuizW, qui/Text, “NO”. “X)”. 0, NULL. NULL); 

I 

else 

freef target): 

/* We need to disable the Home and Back buttons now */ 

XtVaSetValues(QuizHoine, XtNsensitive, False, NULL); 

XtVaSetValues(QuizBack, XtNsensitive, False. NULL); 


/* 

* Free up allocated memory and exit application NOTE: attempting to free memory for Messages 

* causes segmentation errors when re-starting the quiz application. Appears to reclaim the memory on 

* its own during preliminary testing. 


105 






*1 

void ShutDownQuizO 

i 

QUIZ_STRUCT * teinpAnswerPtr; 
int i; 

/* Free up Quiz questions */ 
if(quizText!=NULL) 
i 

free(quizText); 

quizText=NULL; 

I 

if(current_href!=NULL) 

{ 

free(current_href): 

current_href=NULL; 

I 


XtPopdown(QuizShell); 

XtDestroyWidget(QuizShell); 

I 


/* 

* Starting point of quiz application. Calls Load text ;ind solution functions prior to creation of 

* application shells. 

*/ 

void StartQuiz( filename) 
char ‘filename; 

1 

int n; 

char * SolutionFile; 
char *c, tempi 100]; 
int horizDist = 20; 
int MinHeight = 300; 
int MinWidth = 400; 
int ButtonWidth = 70; 

Widget FormB, FormW; 
if(!loadAsciiFile(filename. &quizText)) 

I 

PrintStartError(filen;une); 

return; 

I 

else 

strcpy(HomePage, filename); 

t* Need to maintain current href for compatibility with other subsystems. 

May also be helpful for future expansion */ 
current_href=strdup(filename); 

strcpy(temp, filename); 

if( (c=(chtu *)strrchr(temp,'.’)) != NULL) 


106 






C++: 

*c = ‘NO’: 

strcat(temp, “soln”); 
if(! load_solution( temp)) 
( 

Prints tartError( temp); 
return; 


else 

{ 

PrintStartError(temp); 

return; 

} 

QuizShell=XtVaCreatePopupShell('TTS Quiz”, topLevelShellWidgetClass, TopLevel, 

XtNallowShellResize, True, XtNminHeight, MinHeight, 
XtNminWidth. MinWidth, NULL); 

QuizFonn=XtVaCreateManagedWidget(“htmlform”, fonnWidgetClass, QuizShell, NULL); 

menu_box = XtVaCreateManagedWidget(“fonnB”, formWidgetClass, QuizForm, 

XtNheight, 50, XtNborderWidth, 0, XtNwidth, MinWidth, 
XtNleft, XtChainLeft, XtNtop, XtChainTop, 

XtNright, XtChainRight, NULL); 

ExitQuiz=XtVaCieateManagedWidget(“Exit”, commandWidgetClass, menu_box, 

XtNhorizDistance, horizDist. XtNwidth, ButtonWidth, 

XtNlabel, “ Exit “, XtNleft, XtChainLeft, 

XtNtop, XtChainTop, XtNbottom, XtChainBottom, NULL); 
XlAddCallback(ExitQuiz, XtNcallback, exit_cb, NULL); 

QuizBack=XtVaCreateManagedWidget(“Back”, commandWidgetClass, menu_box, 

XtNsensitive, False, XtNhorizDistance. horizDist, 
XtNfromHoriz, ExitQuiz, XtNwidth, ButtonWidth, 
XtNlabel, “ Back ”, XtNtop, XtChainTop, 

XtNbottom, XtChainBottom, NULL); 
XtAddCallback(QuizBack, XtNcallback, Back_Callback, NULL); 

QuizHome=XtVaCreateManagedWidget(”Home”, commandWidgetClass, menu_box. 

XtNsensitive, Ftdse, XtNhorizDistance, horizDist. 
XtNfromHoriz, QuizBack, XtNwidth, ButtonWidth. 
XtNlabel," Home ”, XtNtop. XtChainTop, 

XtNbottom, XtChainBottom, NULL): 
XtAddCallback(QuizHome, XtNcallback. Home_Callback, NULL); 

QuizInfo=XtVaCreateManagedWidget( ‘Info”. commandWidgetClass, menu_box, 

XtNhorizDistance, horizDist, XtNfromHoriz, QuizHome, 
XtNwidth, ButtonWidth, XtNlabel, “ Info “, 

XtNtop, XtChainTop, XtNbottom, XtChainBottom. NULL): 


107 






XtAddCallback(Quizlnfo, XtNcallback, about_cb. NULL); 

OuizW=XtVaCreateManagedWidget(“htinl”, htmlWidgetClass, QuizForm. 

XtNfromVert, menu_box, XtNbottom, XtChainBottom. 
XtNheight. 3(K). XtNwidlh. 4(H), NULL); 
XtAddCallback(QuizW, WbN;inchorC;dlback. Anchor_callback, (XtPointer)O); 

XtRealizeWidget(QuizShell); 

HTMLSetText(QuizW. quizText. "MT, ‘M)”, 0, NULL. NULL); 

XtPopup(QuizShell. XtGrabExclusive); 

| /* End Start Quiz Function */ 

/* 

* Callback to provide user with opportunity to confirm or cancel EXIT. Exit application does not have 

* menu and may be triggered inadvertently, so should provide user opportunity to abort the exit 
*/ 

static void exit_cb(w. client_data. call_data) 

Widget w; 

XtPointer client_data; 

XtPointer call_data; 

I 

Widget okB, exit_dialog,cancelB; 

Position x. y; 

Dimension width, height; 

pshell = XtVaCreatePopupShellCconfirm". transientShellWidgetClass, TopLevel, 

XtNwidth. 300, XtNheight, 150, XtNlabel, ExitQuizConfirm. NULL); 

exit_dialog = XtVaCreateManagedWidgetC'Confirm”, dialogWidgetClass, pshell, 

XtNlabel, ExitQuizConfirm. NULL); 

okB = XtVaCreateManagedWidgeK" Exit", commandWidgetClass, exit_dialog, 

XtNlabel, “ OK ", XtNhorizDistance, 40, NULL); 
XtAddCallback(okB, XtNcallback, really_exit_cb, NULL); 

cancelB = XtVaCreateManagedWidget("Cancel”, commandWidgetClass, exit_dialog, 

XtNhorizDistance, 40, XtNright, XtChainRight, NULL); 
XtAddCallback(cancelB, XtNcallback, cancel_cb , NULL); 

XtVaGetValues(QuizW, XtNwidth, & width. XtNheight, &height, NULL); 

XtTranslateCoords(QuizW, (Position) width/2, (Position) height/2, &x, &y); 

XtVaSetValues(pshell, XtNx, x - (width/2), XtNy, y - (height/2), NULL); 

XtPopup(pshell, XtGrabExclusive); 


/* Popup dialog with message explaining why answer chosen is correct or incorrect. */ 
static void Signal.Answer(Correct, Index, Alpha) 

Boolean Correct; 
int Index; 



char Alpha; 

1 

Widget okB, info_dialog. fonnW. explanation; 

String Message; 

Position x, y; 

Dimension width, height; 

switch (Alpha) 

( 

case ‘A’; Message = MessageArray[Index]->MessageA; break 
case ‘B’: Message = MessageArray[Index]->MessageB; break 
case "C: Message = MessageArray[lndexl->MessageC; break 
case ‘D’: Message = MessageArrayfIndex]->MessageD; break 
default:; 

1 


pshell = XtVaCreatePopupShell("answer”, transientShellWidgetCiass, TopLevel, 

XtNwidth, 320, XtNheight.230, NULL); 

fonnW = XtVaCreateManagedWidget(“AnsFonn", formWidgetClass, pshell, 

XtNborderWidth, 0. XtNwidth, 320. XtNheight, 200, NULL); 

explanation = XtVaCreateManagedWidgetC'Explain”. asciiTextWidgetClass, formW, 

XtNscrollVertical. XawtextScrollWhenNeeded, 
XtNwrap, XawtextWrapWord, XtNstring, Message, 
XtNheight, 180, XtNwidth, 320. 

XtNleft, XtChainLeft, XtNrigbt, XtChainRight, NULL); 

okB = XtVaCreateManagedWidgetO' OK ", commandWidgetClass, formW, 

XtNfromVert, explanation, XtNhorizDistance. 120, NULL); 
XtAddCallback(okB. XtNcallback. cancel_cb, NULL); 

XtVaGetVaIues(QuizW, XtNwidth, &width, XtNheight, &height, NULL); 

XtTranslateCoords(QuizW, (Position) width/2, (Position) height/2, &x. &y); 

if(Correct) 

I 

XtVaSetValues(pshell, XtNx, x , XtNy, y - (height/2), NULL); 

1 

else 

{ 

XtVaSetValues(pshell, XtNx, x - (width/2), XtNy, y - (height/2). NULL); 

) 

XtPopup(pshell, XtGrabExclusive): 


/* 

* Callbtick associated with our Info button which provides user with popup dialog describing our 

* implementation. Typictd “Look what I did” type dialog 

V 

static void about_cb(w, client_data, call_data) 


109 








Widget w: 

XtPointer client_data; 

XtPointer cal!_data; 

( 

Widget okB, ahout_dialog; 

Position x, y; 

Dimension width, height: 

pshell = XtVaCreatePopupShell(“ About...”, transientShellWidgetClass, TopLevel. 

XtNwidth, 300. XtNheight.200, NULL): 

about_dialog - XtV;iCreateManagedWidget("about”. ditdogWidgelClass. pshell. 

XtNlabel, AboutQuizVersion, NULL): 

okB = XtVaCreateManagedWidget(“ OK commandWidgetClass, about_dialog, 

XtNhorizDistance, 120. NULL); 
XtAddCallback(okB, XtNcallback, cancel_cb, NULL); 

XtVaGetValues(QuizW, XtNwidth, &width, XtNheight, &height, NULL); 
XtTranslateCoords(QuizW, (Position) width/2, (Position) heighl/2, &x, &y); 
XtVaSetValues(psheIl, XtNx, x - (width/2). XtNy, y - (height/2), NULL); 

XtPopup(pshell, XtGrabExclusive): 

1 


/* Callback used to remove any of the popub dialogs .attached to pshell */ 
static void cancel_cb(w, client_data, call_data) 

Widget w; 

XtPointer client_data, call_data; 

I 

XtPopdown(pshell); 

1 


/* Cttllback associated with OK button of exit_cb. Go ahead and close up shop */ 
static void really_exit_cb(w. client_data, c;ill_data) 

Widget w; 

XtPointer client_data. call_data; 

I 

XtPopdown(pshell); 

ShutDownQuiz(); 


110 





REFERENCES 


[ABCL9()| 

[BiLe91] 

[Blum92| 

[Camp90] 

[Clan87] 

[Delo911 

[Ga >Ve89) 

[GiRi94] 

[Hamm93| 

|HeFe92] 

[Hill77] 

[HiHa93] 

[Hopp92] 

(JoRe92| 


Anderson, J., Boyle, C., Corbett, A., and Lewis, M., “Cognitive Modeling 
and Intelligent Tutoring”, in W. Clancey and E, Soloway (Ed.), Artificial 
Intelligence and Learning Environments , The MIT Press, 1990. 

Bielawski, L., and Lewand, R., Intelligent Systems Design, John Wiley and 
Sons, Inc., 1991. 

Blum, B„ Software Engineering: A Holistic View, Oxford University Press, 
1992. 

Campbell. L., An Intelligent Tutor System for Visual Aircraft Recognition, 
Master’s Thesis, Naval Postgraduate School, Monterey, CA, 1991. 

Clancey, W., Knowledge Based Tutoring: The Guidon Program, The MIT 
Press, 1987. 

DeLooze, L., ITS Ada: An Intelligent Tutoring System for the Ada 
Programming Language, Master’s Thesis, Naval Postgraduate School, 
Monterey, CA, 1991. 

Gause, D., and Weinberg, G., Exploring Requirements: Quality Before 
Design, Dorset House Publishing, 1989. 

Giarratano, J., and Riley, G., Expert Systems: Principles and Programming, 
PWS-Kent Publishing Co., 1994. 

Hamming, R., EC4000 and OS3001 Lecture Series, Naval Postgraduate 
School, Monterey, CA, 1993-1994. 

Heller, D., and Ferguson, P„ XMotif Programming Manual (for OSF/Motif 
Release 1.2), O'Reilly & Associates, Inc., 1992. 

Hill, N., Success Through a Positive Mental Attitude, Prentice-Hall, Inc., 
1977. 

Hix, D., and Hartson, H., Developing User Interfaces: Ensuring Usability 
Through Product and Process, John Wiley and Sons, Inc., 1993. 

Hoppe, W., Cognitive Modeling and the Evolution of the Student Model in 
Intelligent Tutoring Systems, Master’s Thesis, Naval Postgraduate School. 
Monterey, CA, 1992. 

Johnson, E., and Reichard, K., A’ Window Applications Programming, 
Management Information Services, Inc., 1992. 


II! 







[Kear87j 


[LeMB92| 


|Nasa93a] 


(NyOr92| 


[Pape80| 

|Reps89] 


[Skin86J 


[Weng87] 

[Wool92] 

[YoPe92] 


[Your89] 


Kearsley, G., Artificial Intelligence and Instruction, Addison-Wesley 
Publishing Company, 1987. 

Levine, J., Mason, T„ and Brown, D., Lex & Yacc, O'Reilly and Associates, 
Inc., 1992. 

NASA, CLIPS Reference Manual, Volume I: Basic Programming Guide, 
Software Technology Branch, Lyndon B. Johnson Space Center, Houston, 
TX, 1993. 

Nye, A., and O'Reilly, T., X Toolkit Intrinsics Programming Manual (OSF/ 
Mofif 1.2 Edition), O'Reilly & Associates, Inc., 1992. 

Papert, S., Mindstorms, Basic Book, 1980. 

Reps, T„ and Teitelbaum, T., The Synthesizer Generator: A System for 
Constructing Language-Based Editors, Springer-Verlag New York Inc., 
1989. 

Skinner, M., Design and Evaluation of a Computer-Assisted Instructional 
Program on Concepts in Applied Behavioral Analysis, University 
Microfilms International, 1986. 

Wenger, E., Artificial Intelligence and Tuto'ing Systems, Morgan Kaufman 
Publishers, Inc., 1987. 

Woolf, B., “AI in Education", in S. Shapiro (Ed.), Encyclopedia of Artificial 
Intelligence, Second Edition, John Wiley and Sons, Inc., 1992. 

Young, D., and Pew, J., The X Window System: Programming & Applications 
withXt, (Open-Look Edition), Prentice-Hall, Inc., 1992. 

Yourdon, E„ Modern Structured Analysis, Prentice-Hail Inc., 1989. 


112 






BIBLIOGRAPHY 


| Bark91 ] 
|Barn89| 

|Beiz9()| 
[BoGa91 ] 

[Brum94] 

[CoNi93] 

[CoYo91 J 

[CuGR92] 

[Ecke93| 

[Fire92] 

[FiLe911 

[Flan92] 

[Giar93] 

[Gonz911 

[Gonz93] 

(Good92| 


Barkakati, N., X Window System Programming, Sams Publishing, 1991. 

Barnes, J., Programming in Ada , Third Edition, Addison-Wesley Publishing 
Co., 1989. 

Beizer, B., Software Testing Techniques , Van Nostrand Reinhold, 1990. 

Boose, J., and Gaines, B., The Foundations of Knowledge Acquisition, 
Academic Press Limited, 1991. 

Brumbaugh, D., Object-Oriented Development: Building CASE Tools with 
C++, John Wiley and Sons, Inc., 1994. 

Coad, P., and Nicola, J., Object Oriented Programming, Prentice-Hall, Inc., 
1993. 

Coad, P., and Yourdon, E., Object Oriented Analysis, Prentice-Hall Inc. 
1991. 

Cutler, E., Gilly, D., and O'Reilly, T., The X Window System in a Nutshell, 
O'Reilly and Associates, Inc., 1992. 

Eckel, B„ C++ Inside and Out, Osborne McGraw-Hill, Inc., 1993. 

Firesmith, D., Object-Oriented Requirements Analysis and Logical Design: 
A Software Engineering Approach, John Wiley and Sons, Inc., 1992. 

Fisher, C., and LeBlanc, R., Crafting a Compiler With C, Benjamin/ 
Cummings Publishing Company, Inc., 1991. 

Ranagan, D., X Toolkit Intrinsics Reference Manual (for XU Release 4 and 
ReleaseS), O'Reilly & Associates, Inc., 1992. 

Giarratano, J„ CUPS User Guide, Software Technology Branch, Lyndon B. 
Johnson Space Center, Houston, TX, 1993. 

Gonzalez, D., Ada Programmer's Handbook and Language Reference 
Manual, Benjamin Cummings Publishing Company, Inc., 1991. 

Gonzalez, A., The Engineering of Knowledge Based Systems, Prentice-Hall 
Inc., 1993. 

Goodwin, M., User Interfaces in C and C++, MIS:Press, 1992. 


113 






[HaSt91] Harbison, S., and Steele, G., C: A Reference Manual , Prentice-Hall, Inc., 
1991. 

[Lafo91 ] Lafore, R., Object Oriented Programming in Turbo C++, Waite Group Press, 
1991. 

[Lee89| Lee, Y., A Knowledge Based Approach to Program Debugging , Technical 
Paper, NPS52-89-060, Naval Postgraduate School, Monterey CA, 1989. 

[LiDe89] Liebowitz, J., and DeSalvo, A., Structuring Expert Systems , Prentice-Hall 
Inc., 1989. 

[Loca93] Local Proceedings, AADEBUG'93, 1st International Workshop on 
Automated and Algorithmic Debugging, Linkoping University, Linkoping, 
Sweden, 3-5 May, 1993. 

[Luca92] Lucas, J., The C++ Programmer's Handbook, Prentice-Hall, Inc., 1992. 

[Nasa93b] NASA, CUPS Reference Manual, Volume II: Advanced Programming 
Guide, Software Technology Branch, Lyndon B. Johnson Space Center, 
Houston, TX, 1993. 

[Nasa93c] NASA, CUPS Reference Manual, Volume III: Interfaces Guide, Software 
Technology Branch, Lyndon B. Johnson Space Center, Houston, TX, 1993. 

[Niel90] Nielson, J., Hypertext and Hypermedia, Academic Press, Inc., 1990. 

[NyOr93] Nye, A., and O'Reilly, T„ X Toolkit Intrinsics Programming Manual (for 
Version 11), O'Reilly & Associates, Inc., 1993. 

[Paga911 Pagan, F., Partial Computation and the Contraction of Language Processors, 

Prentice-Hall Inc., 1991. 

[Perr83] Perry, W„ A Structured Approach to Systems Testing, QED Information 
Sciences, Inc., 1983. 

[Prat91] Prata, S., C++ Primer Plus: Teach Yourself Object Oriented Programming, 
Waite Group Press, 1991. 

[Schi92] Schildt, H., The Craft of C: Take-Charge Programming, Osborne McGraw- 
Hill, 1992. 

[ScKe89] Schneiderman, B., and Kearsley, G„ Hypertext Hands-On!: An Introduction 
to a New Way of Organizing and Accessing Information, Adison-Wesley 
Publishing Company, 1989. 

[Stit92] Stitt, M., Debugging: Creative Techniques and Tools for Software Repair, 
John Wiley and Sons, Inc., 1992. 


114 




[Stit93] Stitt, M., Building Custom Software Tools and Libraries, John Wiley and 
Sons, Inc., 1993. 

[Stro91] Stroustrup, B., The C++ Programming Language, Addison Wesley 
Publishing Company, 1991. 

[Vall92] Valley, J., C Programming for UNIX, SAMS Publishing, 1992. 

[Youn92J Young, D., Object Oriented Programming with C++ and OSF/Motif, 
Prentice-Hall Inc., 1992. 


115 




116 



INITIAL DISTRIBUTION LIST 


1. Defense Technical Information Center 
Cameron Station 

Alexandria, VA 22304-6145 

2. Dudley Knox Library 
Code 052 

Naval Postgraduate School 
Monterey, CA 93943-5101 

3. Chairman, Code CS 
Computer Science Department 
Naval Postgraduate School 
Monterey, CA 93943-5000 

4. Director, Training and Education 
MCCDC, Code C46 

1019 Elliot Road 
Quantico, VA 22134-5027 

5. Professor Yuh-jeng Lee, Code CS/Le 
Computer Science Department 
Naval Postgraduate School 
Monterey, CA 93943-5000 

6. Professor Mantak Shing, Code CS/Sh 
Computer Science Department 
Naval Postgraduate School 
Monterey, CA 93943-5000 

7. Captain James M. Delani Jr. 

Marine Corps Systems Command 
2033 Barnett Ave., Suite 315 
Quantico, VA 22134-5010 





