AD-A240 613 


ENTATION PAGE 


Form Aporovod 
OPM No 0704 0138 


^ 1 Hour 0*1 'osooosA •ncmotrg nm« > 0 / '«v>9wtng /wnxtonA sMrcrng tisang OiU lourcM gitntnng 4n0 manourwig rh* 3si 
IQ TTc out(36r. as: Dais of ary o(r«r asc«ct o< coA»ctoo ol fiformaion. ncluaing tuggacicrs for ntduong th« OurOtr (o WMrw^gion 
2^5 ^anarsun Za4% Higrway Suaa ^204 4/)tngion. VA 22202-4302. ana to tha Oflx:* or mtormaoor^ and Raguaiory Attars Cittica at 


1 AGENCY USE ONLY /leave d'ank) 


2 REPORT CATE 


3 REPORT TYPE AND DATES COVERED 

Final: 30 Jul 1991 to 01 Jun 1993 


4 iii'^E AND SUBTITLE 

Ada Compiler Validation Summary ReportiU.S. Na' y Ada/M, Version 4.0 
( OPTIMIZE), VAX 8550 (Host) to AN/AYK-14 (Bare Board)(Target), 
91062631,11175 


5 AUTHOR!Si 

National Institute of Standards and Technology 

Gaithersburg, MD 

USA 


PERFORMING CRGANiZATlCN NAME.S) ANO ADCRESStES; 

National Institute of Standards and Technology 
National Computer Systems Laboratory 
Bldg 255, Rm A266 
Gaithersburg, MD 20899 USA 


9 SPONSORiNG/MONITORING AGENCY NAMEiSi AND ADDRESSlES' 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, RM 3E114 
Washington, D C 20301-3081 



8 performing ORGANIZATION 
REPORT number 

NIST90USN510 8 1.11 


10 SPONSORINGvMONITORING AGENCY 
REPORT NUMBER 



12a Distribution,AVAILABILITY statement 

Approved for public release: distribution unlimited. 


12b DISTRIBUTION CODE 


' 3 ABSTRACT Maximum 2C0 worasi 


U S Navy Ada/M. Version 4.0 ( OPTIMIZE), Gaithersburg, VAX 8550, running VAX/'VMS Version 5.3 (Host) to AN/AYK-14 
(Bare Board)(Target), ACVC1.11. 

f! , . ^ ^ 


- 


W 




■0 1 • ’ ^ 
.31 m 


91-11055 




'4 SuBoE-’ 


Ada programming language, Ada Compiler Val Summary Report, Ada Compiler Val. 
Capability, Val Testing. Ada Val Office. Ada Val, Facility, ANSI,''MIL-STD-1815A, AJPO. 


'7 security class.F iCATiON 
OF REPORT 

UNCLASSIFIED 


NSN 7540 0^ '?80 


'S SECljRiTv CUVSSIF'CATION 


UNCLASSIFED 


19 SECUHHY ''* iOi*4 

OF ABSTRACT 

UNCLASSIFIED 


15 NUMBER OF PAGES 


16 PRICE CODE 


'to JMITATION OF *BSTT>«CT 


Standard Form 290 'Ftev 2 89) 
p.^fic/-r,hod by ANSI Std 239-128 





















NI3T90USN510 8 


AVF Control Nurriber: 

DATE COMPLETED 

BEFORE ON-SITE: 1991-04-05 
AFTER ON-SITE: 1991-06-26 
REVISIONS: 1991-07-30 


Ada COMPILER 
VALIDATION SUMM-ARY REPORT: 
Certificate Number; 910626S1.ill75 
U.S. NAVY 

Ada/M, Version 4.0 (/OPTIMIZE) 
VAX 8550 => AN/AYK-14 (Bare Board) 


Prepared By: 

Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 



t ■ ■ 

h 

I 

r 

. r. * 



AVF Control Number: NIST90USN510_8_1.11 
Certificate Information 


The following Ada implementation was tested and determined to pass 
ACVC 1.11. Testing was completed on 1991-06-26. 

Compiler Name and Version: Ada/M, Version 4.0 (/OPTIMIZE) 

Host Computer System: VAX 8550, running VAX/VMS Version 

5.3 

Target Computer System: AN/AYK-14 (Bare Board) 

A more detailed description of this Ada implementation is found in 
section 3.1 (Jt cnis report. 

As a result of this validation effort. Validation Certificate 
910626S1.11175 is awarded to U.S. NAVY. This certificate expires 
on 01 March 1993. 


This report has been reviewed and is approved. 




David K. Jel^erspn 
f, Information Systems 
ineering Division (ISED) 



, / 

^ __ 

Ada Valida^pn Facility 

Mr. L. Arnolfd Johnson 
Manager, Software Standards 
Validation Group 


Computer Systems Laboratory (CLS) 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


A 



Ada Validation Organization 
Directoi^ gfomputer & Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 








Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 










DECLARATION OF CONFORKANCE 


The following declaration of conformance was supplied by the 
customer. 


DECLARATION OF CONFORMANCE 


Customer: U.S. NAVY 

Certificate Awardee; U.S. NAVY 

Ada Validation Facility: National Institute of Standards and 

Technology 

Computer Systems Laboratory (CSL) 
Software Validation Group 
Building 225, Room A266 
Gaithersburg, Maryland 20899 

ACVC Version; 1.11 


Ada Implementation: 

Compiler Name and Version: Ada/M, Version 4.0 (/OPTIMIZE) 

Host Computer System: VAX 8550, running VAX/VMS Version 

5.3 

Target Computer System: AN/AYK-14 (Bare Board) 

Declaration: 

I the undersigned, declare that I have no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STD-1815A ISO 
3652-1987 in the implementation listed above. 


Customer Signature Dgite > 

Company U.S. Navy 
"^itie . . 

Certificate Awardee Signature DaZe 

Company U.S. Na’vy 

Title 



-- . TABLE OF CONTENTS 

CHAPTER 1.1-1 

^NIRODUCTION . 1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT .... 1-1 

1.2 REFERENCES.1-1 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENT.^TION DEPENDENCIES.2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-3 

CHAPTER 3.3-1 

PROCESSING INFORMATION . 3-1 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST E.XECUTION.3-2 

APPENDIX A.A-1 

MACRO PARAMETERS.A-1 

APPENDIX B.B-1 

COMPILATION SYSTEM OPTIONS . B-1 

LINKER OPTIONS . B-2 

APPENDIX C.C-1 

APPENDIX F OF THE Ada ST?VNDARD.C-1 





























CHAPTER 1 
INTRODUCTION 


The Ada iinplementation described above was tested according to the 
Ada Validation Procedures [Pro90] against the Ada Standard rAda&o_ 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implemientation. For any technical terms used in this 
report, the reader is referred to |;Pro90]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG39'. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552). The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5235 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to : 


Ada Validation Organization 
Computer and Software Engineering Division 
Institute for Defense Analyses 
1301 North Beauregard Street 
Alexandria VA 22311-1772 


1.2 REFERENCES 

;Ada33; Reference Manual for the Ada Programming Language , 

ANSI/MIL-STD-1315A, February 1933 and ISO 8652-1987. 


1-1 





;?ro90’ Ada— Cor.Diler Val ida - ^-: on Procedures . Version 2.1, Ada Joint 
Program Office, August 1990. 

;UG39] Ada Compiler Validation Cacabilitv User's Guide . 2i June 
1939 . 


^ . 3 u u X n. o X ^ 2 w ii. w 

Compliance of Ada implementations is tested by means of the .\CVC. 
T.he ACVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
pac.kages REPORT and SPPRT13, and the procedure CHECK_FILE are used 
for this purpose. The package REPORT also provides a set of 
ide.ntity functions used to defeat some compiler optimizations 
allowed by the .Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. Class B 
tests check that a compiler detects illegal language usage. Class 
3 tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that 
all violations of the Ada Standard are detected. Some of the class 
3 tests contain legal Ada code which must not be flagged illegal by 
t.he compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

I.n some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values — for example, the 
largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
mcdificaticns, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 


1-2 



the AVF. Th-is custonizaticn consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, pcssibly some inapplicable tests (see Section 3.2 
and :UG3 9]) . 

In order to pass an ACVC an Ada implementation must process each 
test cf t.he customiized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


.\da Ccm.piler The software and any needed hardware that have to 
be added to a given host and target computer 
system to allow transformation of Ada program.s 
into executable form and execution thereof. 

The means for testing compliance of Ada 
implementations. Validation consisting of the 
test suite, the support programs, the ACVC 
Capability user's guide and the template for 
the validation summary (ACVC) report. 

Ada An Ada compiler with its host computer system and 

I.mplementation its target computer system. 

Ada The part of the certification body which carries 

Validation out the procedures required to establish the 

Facility (AVF) com.pliance of an Ada implementation. 

Ada The part of the certification body that provides 

Validation technical guidance for operations of the Ada 

Organization certification system. 

(AVO) 

Compliance of The ability of the implementation to pass an ACVC 
an Ada version. 

Implementation 

Computer A functional unit, consisting of one or more 

System computers and associated software, that uses 

common storage for all or part of a program and 
also for all or part of the data necessary for 
the execution of the program; executes 
user-written or user-designated programs? performs 
user-designated data manipulation, including 
arithmetic operations and logic operations; and 
that can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 


Ada Compiler 
Validation 
Capability 
(ACVC) 


1-3 






Conformity — 


Cusroner 


Declaration of 
Conformance 


Host Computer 
System. 

Inapplicable 

rest 


Operating 

Svstem 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Im.plementation 


Validation 


Withdrawn 

test 


Fulfillment by a product, process or service rf 
all requirements specified. 

An individual or corporate e.itity who enters into 
an agreement with an AVF which specifies the term.s 
and conditions for .AVF ser'/ices (of any kind) to 
be performed. 

.A formal statement from a customer assuring that 
ccnformity is realized or attainable on the Ada 
implementation for which validation status is 
realized. 

A computer system where Ada source program.s are 
transformed into executable form. 

A test that contains one or more test objectives 
found to be irrelevant for the given Ada 
im.plementation. 


Software that controls the execution of program,s 
and that provides services such as resource 
allocation, scheduling, input/output control, 
ana data m.anagement. Usually, operating systems 
are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada 
programs are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated 
successfully either by AVF testing or by 
registration [Pro90]. 

The process of checking the conformity of an Ada 
compiler to the Ada programming language and of 
issuing a certificate for this implementation. 

A test found to be incorrect and not used in 
conformity testing. A test may be incorrect 
because it ha i an invalid test objective, fails 
to meet its test objective, or contains erroneous 
or illegal use of the Ada programming language. 


1-4 


CHAPTER 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 


Seme test 

s are with 

[drawn by the AVO from 

the ACVC 

because they do 

not confo 

rm to the 

Ada Standa 

r*d - f c 1 

lowing 94 

tests had been 

wit.hdrawn 

by the Ada Validati 

on Organizat 

ion (AVO) 

at the tim.e of 

validation testi.ng. 

The rationale for withdrawing each test is 

avaliable 

from eith 

er the AVO 

or the AVF. 

The publi 

.cation date for 

this list 

of withdrawn tests 

is 91-05-03. 



E23005C 

323006C 

C34006D 

C35508I 

C35508J 

C35503M 

C35508N 

C35702A 

C357023 

B41308B 

C43004A 

C45:14A 

C4 5 3 4 6A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

349003A 

3490033 

A74006A 

C74308A 

3830223 

B83022H 

3330253 

333025D 

3830263 

C33026A 

C83041A 

B85001L 

C36001F 

C9402iA 

C97116A 

C98003B 

3A2011A 

CB7001A 

C370013 

C37004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

3D13G23 

3Di306A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

3D4C0SA 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4C51D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7C06A 

CD7 0 0 6E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

3D3002A 

BD3004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2:i7A 

CE21173 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3113A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3312A 

CE3314A 

CE3902B 




2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability- 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Issues and commonly referenced in the 
format Al-dddd. For this implementation, the following tests were 
inapplicable for the reasons indicated; references to Ada Issues 
are included as appropriate. 

The following 327 tests have floating-point type declarations 
requiring mere digits than SYSTEM.MAX_DIGITS: 

C241I3C..Y (23 tests) 

C257Q6C..Y (23 tests) 

C357G8C..Y (23 tests) 


2-1 


C35705C..Y (23 tests) 
C35707C..Y (23 tests) 
C35302C..Z (24 tests) 



CJ lU 


^ “t 'y^ '.-j ^ 0 S^Sy 

04^4210..I (23 t2S^3/ 

^,-twD»_4^_. .t- (*-~* t03^S,.' 

C43641C. . 1 I, 23 tastis) 


C45321C..Y (23 tests 
C45521C..Z (24 test- 
C436 ..i*C - - Z (24 tests 


C4o012C..Z 


tests) 


; e :3 .nr.. 


2 33, 336C01T, and C360Q6H check for the predefir.e- 

;Ar; for this implementation, there is no such type. 


The fcllowing 21 tests check for the predefined type SH0RT_i;r 
for this i.mpleme.ntat ion, there is no such type: 


C454123 

C456113 

352004E 


2433023 

2456133 

25530~3 


C452313 
2455033 
C4 5 614 B 
B55B09D 


C453043 
C4 5 5 04 3 
C456313 
3860017 


C 4 3 6 3 2 3 
C36006D 


2354C4D, C452313, 336001X, C36006E, arc CD71G1G check for a 
credefined integer type uith a name other than INTEC-ER, 
EON’G_INTEGER, or SKCRT_Ih’TEGER; for this implementation, there is 
r. o s u c n y p t 

23 5'’13C, 3350G1U, and C36006G check for the predefined type 
lCh’G_FLOAT; for this implementation, there is no such type, 

235-133 and 336001Z check for a predefined floating-point type with 
a name other than ELCAT, LONG_FLOAT, or SH0RT_FL0AT; for this 
implementation, there is no such type. 

C43531M..? and C45532.M..P (8 tests) check fixed-point operations 
for types t.hat require a SYSTEM.MAX_MANTISSA of 47 or greater; for 
this implementation, there is no such type. 

245624A.,B (2 tests) check that the proper exception is raised if 
MACHIN'E_OVERFLOWS is FALSE for floating point types; for this 
implementation, MACHINE_OVERFLOWS is TRUE, 

264C05F uses 10 levels of recursive procedure calls nesting; this 
level of nesting for procedure calls exceeds the capacity of the 


Z64005G uses 17 levels of recursive procedure calls nesting; this 
test exceeds the li.nkable size of 128KBytes. 

36G01Y uses the name of a predefined fixed-point type other than 
UPJiTIGN; for this implementation, there is no such type. 

CD1009C checks whether a length clause can specify a non-default 
size for a floating-point type; this implementation does not 
suocort suc.n sizes. 


2-2 



CD2AS4A, CD2AS4E, CD2A84I..J (2 tests ), and CD2A840 use length 
Clauses to*” specify non-default sizes for access types; this 
inplenentat icn does not supporr such sizes. 

AE2101C uses instantiations of package SEQUENTIAL_IO with 
unccnsrrained array types and record types with discrininants 
without defaults; these instantiations are rejected by this 
conpiler. 

AE2101H uses instantiations of package DIRECT_IO with unconstrained 
array types and record types with discriminants without defaults; 
these instantiations are rejected by this compiler. 

The followir.g 2 64 tests check operations on sequential, text, and 


direct a 
files: 

cce 

3S f 

lies; this 

implem 

;entation does 

not 

support exte 

rnal 

OE2102A. 

. C 

(3) 

CE2102G. 

. H 

(2) 

CE2102K 



CE2102N.. 

Y (12) 

CE2103C. 

. D 

i 2 ) 

CE2104A. 

. D 

(4) 

CE2105A. 

. B 

(2) 

CE2106A. 

. B 

(2) 

CE2107A. 

. H 

(S) 

Ct2107L 



CE2108A. 

.H 

(8) 

CE2109A. 

. C 

(3) 

CE2110A. 

. D 

f4) 

CE2111 A. 

. I 

(9) 

CE2115A. 

. B 

(2) 

CE2120A. 

. B 

(2) 

CE22Q1A. 

• 

(3) 

EE2201D. 

. E 

(2) 

CE2201F. 

.N 

(9) 

CE2203A 


CE2204A. 

. D 

(4) 

CE2205A 



CE2206A 



CE2208B 



CE2401A. 

. C 

(3) 

EE2401D 



CE2401E. 

. F 

(2) 

EE2401G 



CE2401H. 

T 

« 

(3) 

CE2403A 



CE2404A. 

. B 

(2) 

CE2405B 



CE2406A 



CE2407A. 

. B 

(2) 

CE2408A. 

. B 

(2) 

CE2409A. 

. B 

(2) 

CE2410A. 

. B 

(2) 

CE2411A 



CE3102A. 

. C 

(3) 

CE3102F. 

.H 

(3) 

CE3102J . 

.K 

(2; 

CE3103A 



CE3104A. 

. C 

(3) 

CE3i06A. 

. 3 

(2) 

CE3107B 



CE3103A. 

.B 

(2) 

CE3109A 



CE3110A 


CE3111A. 

. B 

(2) 

CE3111D. 

.E 

(2) 

CE3112A. 

. D 

(4) 

CE3114A. 

• B 

(2) 

CE3115A 



CE3119A 



EE3203A 



EE3204A 


CE3207A 



CE3208A 



CE3301A 



EE330iB 



CE3302A 



CE3304A 



CE3305A 



CE3401A 



CE3402A 



EE3402B 



CE3402C. 

. D 

(2) 

CE3403A. 

.C 

(3) 

CE3403E. 

. f 

(2) 

CE3404B. 

. D 

(3) 

CE3405A 



EE3405B 


CE3405C. 

. D 

(2) 

CE3406A. 

. D 

(4) 

CE3407A. 

. C 

(3) 

CE3408A. 

. C 

(3) 

CE3409A 



CE3409C. 

. E 

(3) 

EE3409F 



CE3410A 



CE3410C. 

. E 

(3) 

EE34]OF 



CE3411A 



CE3411C 



CE3412A 



EE3412C 



CE3413A. 

• C 

(3) 

CE3414A 



CE3602A . 

. D 

(4) 

CE3603A 



CE3604A. 

. B 

(2) 

CE3606A. 

. E 

(5) 

CE3606A. 

. B 

(2) 

CE3704A. 

. F 

(6) 

CE3704M. 

.0 

(3) 

CE3705A. 

. E 

(5) 

CE3706D 



CE3706F. 

.G 

(2) 

CE3804A. 

. P 

(16) 

CE3805A. 

. B 

(2) 

CE3S06A. 

. B 

(2) 

CE3806D. 

.E 

(2) 

CE3806G. 

.H 

(2) 

CE3904A. 

. B 

(2) 

CE3905A. 

. C 

(3) 

CE3905L 



CE3906A 

. C 

(3) 

CE3906E. 

. F 

(2) 


2.3 TEST .MODIFICATIONS 

Modifications (see section 1.3) were required for 44 tests. 


2-3 





The foiicwiftg iesrs were split into two or more tests because this 
implsmer.raticn did rot report the violations of the Ada Standard .n 
tne way expected by the original tests. 


322003A 
333201C 
333Q03A 
354A01L 
397103E 
3C1109D 
3C1201L 


322004A 

3322Q2C 

3330033 

B55A01A 

BB1006B 

3C1201F 

BC3013A 


B23004A 

B33203C 

B33009A 

B61005A 

BC1102A 

3C1201G 

BE2210A 


B24005A 

B33301B 

B38009B 

B85008G 

BC1109A 

BC1201H 

BE2413A 


B24005B 

B37106A 

B44001A 

B35008H 

BC1109B 

BC1201I 


32 8 0 0 3 A 
B37301I 
B44004A 
B95063A 
BC1109C 
BC1201J 


233030C and C36007A were graded passed by Test Modification as 
directed by the AVO. These tests were modified by inserting 
"PRAGI'TA ELABORATE (REPORT);" before the package declarations at 
lines 13 and 11, respectively. Without tiie pragma, the packages 
may be elaborated prior to package Report's body, and thus the 
packages' calls to function REPORT.IDENT_INT at lines 14 and 13, 
respectively, will raise PROGPJO^_ERROR. 

234005P and C34005S were graded passed by Test Modification as 
directed by t.he AVO. These tests contain expressions of the form 
"I - X'FIRST - Y'FIRST", where X and Y are of an array type with a 
lower bound of INTEGER'FIRST; this implementation recognizes that 
"X'FIRST - Y'FIRST" is a loop invariant and so evaluates this part 
of the expression separately, which raises NUMERIC_ERROR. These 
tests were modified by inserting parens to force a different order 
of evaluation (i.p., to force the subtraction to be evaluated 
first) at lines 137 and 262/263, respectively; those modified lines 
are: 


/234005?, line 

IF NOT EQUAL (X 

;C34005S, li.nes 

IF NOT EQUAL (X 
Y 


137] 

(I), Y ((I - X'FIRST) + Y'FIRST)) THEN 
261..4 (only 262 & 263 were modified)] 
(I, J) , 

((I - X'FIRST) + Y'FIRST, 

(J - X'FIRST(2)) + 

Y'FIRST(2))) THEN 


2-4 





rHAPTER 3 


PROCESSING INFORMATION 


TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is 
described adequately by the information given in the initial 
pages of this report. 

For a point of contacr for technical information about this 
Ada implementation system, see: 

Mr. Christopher T. Geyer 
Fleet Combat Directions Systems Support Activity 
Code 81, Room 301D 
200 Catalina Blvd. 

San Diego, California 92147 
619-553-9447 


For a point of contact for sales information about this Ada 
im.plementation system, see: 

NCT APPLICABLE FOR THIS IMPLEMENTATION 

Testing of this Ada implementation was conducted at the 
customer's site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


a) Total Number of Applicable Tests 3429 

b) Total Number of Withdrawn Tests 94 

c) Processed Inapplicable Tests 647 

d) Ncn-Processed I/O Tests 0 

e) Mon-Processed Floating-Point 

Precision Tests 0 


3-1 





(c-d-e) 
(a-b*f) 


f) Total 'lumber cf Inapplicable Tests 647 

g) Total Number of Tests for ACVC 1.11 4170 


When this implementation was tested, the tests listed in section 
2.1 had been wit.hdrawn because of test errors. 


TEST EXECUTION 

Version 1.11 of the .ACVC comprises 4170 tests. When thj.s 
compiler was tested, the tests listed in section 2.1 had been 
withdrawn because of test errors. The AVF determined that 647 
tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing. 
In addition, t.he modified tests mentioned in section 2.3 were 
also processed. 

A magnetic tape containing the customized test suite (see 
section 1.3) was taken on-site by the validation team for 
processing. The contents of the magnetic tape were loaded 
directly onto the host computer. 

After the test files were loaded onto the host computer, the 
full set of tests was processed by the Ada implementation. 

The tests were compiled and linked on the host computer system 
and executed on the target computer system. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B 
for a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this 
test wore: 


FOR /OPTIMIZE the options were: 

/SUMMARY /OPTIMIZE /SOURCE /EMR /0UT=<filename> 


The options invoked by default for validation testing during 
this test were: 


FOR /OPTIMIZE the options were: 

:iO_MACHINE_CCDE NO_ATTRIBUTE NO_CROSS_REFERENCE 

N'O DIAGNOSTICS NO NOTES PRIVATE LIST CONTAINER GENERATION 


3-2 






C0DE_O»_WARNING NO_MEASURE DEBUG CHECKS NO_EXECUTIVE 
NO_RTE_ONLY TRACE_BACK 

Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVE. Selected 
listings examined on-site by the validation team were also 
archived. 


3-3 



APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for 
customizing the ACVC. The meaning and purpose of these 
parameters are explained in [UG89]. The parameter values are 
presented in two tables. The first table lists the values 
that are defined in terms of the maximum input-line length, 
which is the value for $MAX_IN_LEN—also listed here. 
These values are expressed here as Ada string aggregates, 
where "V" represents the maximum input-line length. 

Macro Parameter Macro Value 


$MAX IN LEN 120 


$BIG_ 

_ID1 

(1. 

, .V- 

II 

V 

'A* , 

V 

= > ' 

1' ) 



$BIG_ 

_ID2 

( y 
\ ^ - 

, .V- 

A 

II 

<-l 

'A' , 

V 

= > ' 

2') 



$BIG_ 

_ID3 

(1. . 

.V/2 

= > ' 

'A') & 

I 

3 ' & 

(1. 

.V-l-V/2 => 

'A' ) 

$BIG_ 

_ID4 

(1. . 

V/2 

= > ' 

'A') & 

1 

4 ' & 

(1. 

.V-l-V/2 => 

' A' ) 

$BIG_ 

_I.NT_LIT 

(1. 

. .V- 

3 => 

•0’ ) 

& 

"298 

It 



$BIG_ 

_REAL_LIT 

(1, 

. . V- 

5 => 

'O' ) 

& 

"690 

. 0" 



$BIG_ 

STRINGl 

1 If 

' & 

(1. . 

V/2 =5 


'A' ) 

& ' 

II t 



$BIG_STRING2 "" & (1..V-1-V/2 => 'A') & & "" 

$BLANKS (1. .V-20 => ' • ) 

$MAX_LEN_INT_BASED_LITERAL 

II2*" 4 (1.. V— 5 => '0') & "111" 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => '0') & "F.E:" 

$MJ^X STRING LITERAL "" & (1..V-2 => 'A') & "" 


A-1 



The following table contains the values for the remaining 
macro parameters. 

Macro Parameter Macro Value 


$ACC_SIZE 

$ALIGNMENT 

$COUNT_LAST 

$DEF.AULT_MEM_SIZE 

$DEFAULT_STOR_UNIT 

$DEFAULT_SYS_NAME 

$DELTA_DOC 

$ENTRY_ADDRESS 

$ENTRY_ADDRESS1 

SENTRY_ADDRESS2 

$FIELD_LAST 

$FILE_TERMINATOR 

$FIXED_NAME 

$FLOAT_NAME 

$FORM_STRING 

$F0RM_STRING2 

$GREATER_THAN_DURATION 

$GREATER THAN DURATION BASE 


16 

4 

32767 

65_536 

16 

ANAYK14 

240.oooo_oooo_ooco_oooo_oooo_o 
000 _ 0000 _ 001 » 

16408004 

16418004 

16428004 

32767 

t I 

NO_SUCH_TYPE 

NO_SUCH_TYPE 

It It 

"CANNOT_RESTRICT_FILE_CAPACITY" 
131071.5 
LAST 131073.0 


^GREATER THAN FLOAT BASE LAST 7.5E+75 


$GREATER THAN FLOAT SAFE LARGE 7.5E+75 


SGREATER THAN SHORT FLOAT SAFE LARGE O.OEO 


SHIGH PRIORITY 


15 





$ILLEGAL^EXTERNAL_FILE_NAME1 
$ILLEGAL_EXTERNAL_FILE_NAX!£2 

$INAPPROPRIATE_LINE_LENGTH 

$INAPPPOPRIATE_PAGE_LENGTH 

$INCLU0E_PRAGMA1 

$INCLUDE_PRAGMA2 

$INTEGER_FIRST 

$INTEGER_LAST 

$IN7EGER_LAST_PLUS_i 

$INTERFACE_LANGUAGE 

$LESS_THAN_DURATICN 

$LESS_THAN_DURATION_BASE_FIRS 

$LINE_TERMINATOR 

$LOW_PRIORITY 

$MACHINE_CODE_STATEMENT 

$MACHINE_CODE_TYPE 

$r-IANTISSA_DOC 

$MAX_DIGITS 

$MAX_INT 

$MAX_rNT_PLUS_l 

$MIN_INT 

SNAiME 

$NAME_LISY 

$NA.ME_SPECIFICATI0N1 
$NA-ME SPECIFICATI0N2 


BAD-CHARS'3.%:x@*()*&'%$=g:@ 

ANOTHER_BAD 
CHARS'=.%1X@*()*&'%$5@19 

-1 
— 1 _ 

PRAGMA INCLUDE ("A23006D1.TST" 
PRAGMA INCLUDE ("B28006F1.TST" 
-32768 
32767 
32_768 

MACRO_NORMAL 
-131071.5 
’ -131073.0 

ASCII.LF 
0 

instr'(Ir, r0,r0) 
instr 
31 
6 

2147483647 

2147483648 

-2147483648 

NO_SUCH_INTEGER_TYPE 

ANUYK44,ANAYK14 

X2120A 

X2120B 


A-3 



$ N AME j6-P EC IFICATI0N3 

$NEG_3ASED_INT 

$NEW MEM SIZE 

$NEW_STOR_UNIT 

$NEW_SYS_NAME 

$ PAGE_TERMINATCR 

$RECORD_DEFINITION 

$RECORD_NAME 

$TASK_SIZE 

$TASK_STORAGE_SIZE 

STICK 

$VARIABLE_ADDRESS 
$VARIABLE_ADDRESS1 
$VARIABLE_ADDRESS2 
SYOUR PRAGMA 


X3119A 

164FFFFFFFES 

65_536 

16 

ANUYK44 
ASCII.FF 

RECORD value : signed_byte; E 
RECORD; 

signed_byte_value 

32 

2043 

0.00003125 

16#0020# 

16#0021# 

16#00234 

EXECUTIVE 


A-4 





APPENDIX 3 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as 
this Appendix, are provided by the customer. Unless 
noted otherwise, references in this appendix are 
dccum.entation and not to this report. 


described 
specifica 
to com.pi 


B-1 



ersion 3 .d Ada/M ?SE Handbook 

9 March 1991 


Option Function 


EXZCOTIVE Enables pragn^a EXECUTIVE and allows I 

visibility to units which have been ! 

compiled with the RTE_ONLY option. I 

Default: NO EXECUTIVE I 

; ~ j 

MEASURE Generates code to monitor execution I 

frequency at t.he suoprogram level for 
the current unit. Derault: NO__MEASURE I 

I 

NO_CHECKS NO_CHECKS suppresses all run-time I 

error checking. CHECKS provides i 

run-ti.me error checking. ! 

Default: CHECKS 1 

i 

: no_code_on_warn;mg i 

NO_CODE_ON_WARNING means no code is 1 

generated when there is a diagnostic I 

of severity WARNING or higher. i 

C0DE_0N_WARNING generates code ! 

only if there are no diagnostics i 

- of a severity higher than WARNING. I 

Default: CODE ON WARNING 1 

i ■ “ I 

I NO_CONTAINER_GENERATION I 

NO_CONTAINER_GENERATrON means that no I 

I container is produced even if there i 

are no diagnostics. I 

CONTAINER_GENERATION produces a I 

container if diagnostic serverity I 

permits. i 

Default: CONTAINER GENERATION i 


Table F-4a - Special Processing Options 


-56 


F.14 Compiler Options 







Ada.y. ?S£ Har.dbccK 


VersiGP. 3.5 
29 March 1991 


i Opr 


r unct 


.cn 


NO 0E30G 


If NO_DEHUG 
inforciar ion 
a.nd e.xecuce 
included in 


is specified, only rhac 
needed co link, export 
the current unit is 
the compiler output. 


With the DE3GG option in effect, 
internal representations and 
additional symooiic information are 
stored .n the container. 

Default: DEBUG 


I NO TRACE BACK 


Disables the location of source 
exceptions that are not handled 
built-in exception handlers. 


Default: TRACE BACK 


by 


! q?':^:mize 


! RTE ONL'i 


Enables global cptrmizations in 
accordance with the optimization 
pragmas specified in the source 
program. If the pragma OPTIMIZE is 
not included, the optimizations 
emphasize TIME over SPACE. 

When N0_0?TIMIZE is in effect, no 
global optimizations are performed, 
regardless of the pragmas specified. 
Default: NO_OPTIMIZE 

Restricts visibility of this unit 
only to those units compiled with 
the EXECUTIVE option. 

Default: NO RTE ONLY 


Table E-Sb 


Special 


Processing 


Options 


(Continued) 


E.14 Comoiler Ootions 


F-57 








Ada/M ?SE HandbccK 


Versicr. 3.5 
2 9 Ma r c -d 1991 


Opt ion 


;nct 1 ; 


ATTRIBUTE 

"’reduces a Symbol Attribute Listing. 
(Produces an attribute cross-reference 
listing when both ATTRIBUTE and 

CROSS REFERENCE are specified.) 

Default: NO .ATTRIBUTE. 

CROSS_RE^ERENCE 

Produces a Cress-Rpf^^rence Listinc. 
(Produces an attrioute cross-reference 
listing when botn ATTRIBUTE and 

CROSS REFERENCE are specified.) 

Default: NO CROSS REFERENCE. 

DI.AGNCSTICS 

Produces a Diagnostic Surt-mary Listina. 
Default: NO DIAGNOSTICS. 

MAC.RINE CODE 

Produces a Machine Code Listina if 


cede ia generated. Code is generated 
wnen CONT.AINER_GENSRAriON option 15 
in effect and (1) there are no 
diagnostics of severity ERROR, SYSTE.M, 
or F.AT.AL, and/or (2) n6_CODE_ON_WARN:nG 
option is in effect and there are no 
diagnostics of severity nigher than 
.NOTE. .A diagnostic of severity NOTE 
IS reported when a Machine Code 
Listing is requested and no code is 
generated. OCTAL is an additional 
option that may be used with 
.MACKINE_CODE to output ocatal values 
on the listing instead of he.x values. 
Default: NO_.MACHINE_CODE. 

NOTES Includes diagnostics of NOTE severity 

level in the Source Listing. 

Default: NO_NOTES. 

SOURCE Produces listing of .Ada source 

statements. Default: NO_SOURCE. 

SU.MMARY Produces a Summary Listing; always 

produced when there are errors in the 
compilation. Default: NO_SUMMARY. 


Table r-6 - Ada/M Listing Control Options 


58 


F.14 Compiler Options 



















3-2 





<0 ll) 


sizr. 2.Z Ada, M ?SE Handboc< 

Marcr, 1991 


F.16 Linker Options 


Optirn 

? u r. c t i c n 

0E3UG 

Produces a linked container to be 
deougged. Lerault: N’O OEBL'G. 

LOAD 

Le f e r r ed. 

MEASTRE 

Produces a linked container to be 
analyzed. Default; N’O MEASL'RE. 

N’C_;0_SL’3STSTEy 

Does not automatically pull in Ada/.M 
predefined TO subsystem pnases 

STSTE.y 10 1 and S'ZSTEM 10 2. 

Default: I0_SU3SYSTE.M. 

PARTIAL 

Produces an incomplete linked 
container witn unresolved 
references. Default: NO P.ARTIAL. 

rtl_select:7e 

Similar to t.ne SELECTIVE option 
except that it only refers to RTLIB 
units. This option is not supported 
during phase links. t 

Defauit": N0_RTL_SELECTI7E. 

SEARCH 

Explicitly searches for the units to 1 
oe included in the linked container. ! 
Default: SEARCH for final links; ! 
NO SEARCH for phase links. 

SELECTIVE 

Maps into the program only the 
suoprograms called by the main i 

su'trogram. Default: SELECTIVE for 
final links; NO SELECTIVE for phase 
links. i 


Table F-10 


Ada 'M 


Linker Special 


Processing Options 


p 


62 


6 


inker Ooticns 







AdaM ?SE Handbook 


Cot ion 


CEH'CGMA? 

ela3_l;st 

lOAEMA? 

lOCAE SYM30LS 


SYMBOLS 

UNITS 


Table F 


Version 3.5 
2 9 Ma r c n 19 91 




Linker suminarv listing always 
produced. 

Defer red. 

Generates an elaboration order 
listing. Default: NO_ELA3_LIST. 

Generates a loadmap listing. 
Default: NO_LOADMA?. 

Generates a symbols listing with 
all internal as well as e:<ternal 
definitions in the program. 
L0CAL_SY.M30LS is tc be used in 
conjunction with the SYMBOLS 
option. If LOCAL_SYMEOLS is 
specified with NO_SYMBOLS, a 
WARNING is produced and the SY.MBOLS 
option is activated. 

Default: NO_LOCAL_SY.MBOLS 

Produces a Linker symbols listing. 
Default: N0_SYM30LS. 

Produces a Linker units listing. 
Default: NO UNITS. 


- Linker Listings Options 


F. 16 


n < e r 


F-63 









ersion 3.5 Ada/M ?SE Handbook 

9 March 1991 


jDt It 


r unc 


MSG 


Sends error messages to the file 
specified. The default is to send 
error messages to Message Output 
(usually the terminal). 

Sends all selected listings to the 
single file specified. The default 
is to send listings to Standard 
Output (usually tne terminal). 


Table ?-12 - Con 


1 Part (Redirection) Options 


-54 


F.16 Linker Options 







Ada/M ?SE Handbook. Version 3. 

29 March 199 

F.17 Exporter 

Options 

Option 

Function 

) 

AiK14 

Generate image for the AN/AYK-i4. ! 

Derau-.t;'-.i.K44- 

• DEBUG 

) 

Permits the generation of a load module 
with all debugginq facilities available. 

When NO DEBUG is in effect, no debugging 
facilities are made available. 

Default. NO_DEBUG. i 

i DYNAMIC 

1 

Deferred. i 

1 

1 EOAH 

Deferred. i 

1 MEASCRE 

1 

1 

1 

1 

1 

1 

i 

Permits the generation of a load module 
with all performance measurement 1 

facilities available. When NO .MEASURE i 

is in effect, no performance measurement 1 

facilities are m.ade available. ! 

Default: NO .MEASURE. 1 

! 

! NO_UYK44 

i 

1 

1 

Generate image for the AN/AyK-14. 1 

Default: UYK44. 

1 


Table F-i3 - Ada/M Special Processing Options 


.17 Exporter Options 


F- 








in rr’i 


r s io n 2 .0 

March 1991 

Ada/M PSE Handboc 

0 p n i 0 n 

Function 

MSG 

Sends error messages to the file 
speciEied. The aefauit is to sena 
error messages to Message Output 
(usually the terminal). 

pF'^'T’ 

Sends all selected listings to the ; 

single file specified, The default 

13 to send listings to Standard 

Output (usually the terminal). 



Taoie F-14 

- Control Part (Sedirection) Options 


o o 


F. 1 


Exporter Options 











Version 3.5 
29 March 1991 


.Ada/M ?S£ Kandbcck 


Option 

Function ; 

DEBUGMAP 

Deferred 

LOAOMA? 

Produces an Exporter Loadmap i 

Listing. This listing shows the 
location of each program section for 
each phase. Default: NO LOADMAP. i 

L0CAL_3YM30LS 

Includes names local to library 
package bodies in the Exporter ! 

Symbol Definition Listing, if 1 

produced. This option has no effect ! 

if NO SYMBOLS is'in effect. I 

Default: NO_LOCAL_SYMBOLS I 

(include only names ; 

which are externally visible). i 

1 

RTEXEC 

I 

Produces executive listings instead i 
of user application listings. It can i 
only be used with the /LOADMAP j 
option, i.e., /LOADMAP/RTEXEC. i 
Default: NO_RTEXEC. i 

SY.MBOLS 

Produces an Exporter Symbol j 

Definition Listing. This listing I 

shows the virtual and physirr.l 1 

locations of the symbols in memory I 

for each virtual memory phase. 

Default: NO SYMBOLS. ! 

~ i 

UNITS 

Produces an Exoorter Units Listing. ! 

Default: NOJJNITS. ' i 

i 


Table F-15 - Ada/M Exporter Listing Options 


?.11 Exporter Options 


F-67 










APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain m.achine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type INTEGER is range -32_768 .. 32_767; 

type LONG_INTEGER is range -2_147_483_647 .. 2_147_483_647; 

type FLOAT is digits 6 range 

-(16#0.FF_FFF8#E63) .. (16#0.FF_FFF8#E63); 

type DURATION is delta 2.0 ** (-14) range 
-131_071.0 .. 131_071.0; 

end STANDARD; 


C-1 




Ada/M ?SE Har.dbooK 


Verslor 
29 Marcn 


1 


- . 3 


19 91 


Appendix F 

The Ada Language for the AN/UYK-44 and AN/AYK-14 Targets 


The source 'anguage accepted by the compiler is Ada, as 
described io the Military Standard, Ada Programminq Language, 
ANSI/MIL-STD-i815A-1983,*17 February 1983 ("Ada Language 
Reference Manual"). 

The Ada definition permits certain implementation 
dependencies. Each Ada i.mpiementation is required to supply a 
complete description of its dependencies, to be thought of as 
Appendix F to the Ada Language Reference Manual. This section is 
that description for the AN/L;Y:<-44 and AN/AYK-14 targets. 


F.l Options 

There are several compiler options provided by all ALS/'N 
compilers that directly affect the pragmas defined in the Ada 
Language Reference Manual. These compiler options currently 
include the CHECKS and OPTI.MIZE options which affect the SUPPRESS 
and OPTIMIZE pragmas, respectively. A complete list of ALS/N 
compiler options can be found in Section 9. 

The CHECKS option enables all run-time error checking for the 
source file being compiled, which can contain one or more 
compilation units. This allows the SUPPRESS pragma to be used in 
suppressing the run-time checks discussed in the Ada Language 
Reference Manual, but note that the SUPPRESS pragma(s) must be 
applied to each compilation unit. The NO_CHECKS option disables 
all run-ti.me error checking for all compilation units within the 
source file and is equivalent to SUPPRESSing all run-time checks 
within every compilation unit. 

The OPTIMIZE option enables all compile-time optimizations 
for the source file being compiled, which can contain one or more 
compilation units. This allows the OPTIMIZE pragma to request 
either TIME-oriented or SPACE-oriented optimizations be 
performed, but note that the OPTIMIZE pragma must be applied to 
each compilation unit. If the OPTIMIZE pragma is not present, 
the ALS/N compiler's Global Optimizer tends to optimize for TI.ME 
over SPACE. The NO_OPTIMIZE option disables all compile-time 
optimizations for ail compilation units within the source file 
regardless of whether or not the OPTIMIZE pragma is present. 

In addition to those compiler options normally provided by 
the ALS/N Common Ada Baseline compilers, the Ada/M compiler also 
i.mplemenis the EXECUTIVE, DEBUG, and MEASURE options. 


Options 


F-01 







Version i.o Ada/M ?SE Har.dbcc< 

29 Marcn 1991 


The EXECl^IVE compiler option enables processing of PRAGMA 
EXECUTIVE and allows WITH of units compiled witn the RTE_ON'LU 
option. Ir NO_EXECUTIVE is specified on tne command line, tne 
pragma will be ignored and will have no effect on the generated 
code. 

The TE3UG compiler option enables processing of PRAGMA DEBUG 
to provide debugging support. If NO_DE3L'G is specified, the 
DEBUG pragmas shall have no effect. Program units containing 
DEBUG pragmas and compiled wit.n t.he DEBUG compiler option may be 
lin,<ed witn progra.m units containing DEBUG pragmas and comipiled 
witn the NO_DE3UG option; only those program units compiled witn 
tne DEBUG option shall nave additional DEBUG support. 

The MEASURE compiler option enables run-time calls to 
Run-Time Performance Measurement Aids (RTAids) to record the 
entrance into all subprograms whose bodies are in the 
compilation. Program units compiled with the MEASURE option may 
be linked with program units not compiled with the MEASURE 
option; at run-time, only tnose subprograms in program units 
com.Diled with the MEASURE option shall have this additional 
MEASURE suDDort. 


F-0 2 


F.l Options 







Ada/M ?SE Har.dbccK 


29 


7e r 3 1 ~ r. 
Marcn 


991 


F.2 Pragmas 

3cth i.T.plemer.tat icr.-def ir.ed and Ada language-defined pragmas 
are provided by all ALS/N compilers. These paragrapns descrioe 
rne pragmas recognized and processed by the Ada/M ccm.piler. The 
syntax defined in Section 2.3 of the Ada Language Reference 
Manual allows pragmas as the only element in a compilation, 
before a comipilation unit, at defined places within a compilation 
unit, or following a compilation unit. Ada/M associates pragm.as 
witn ccm.pilation units as follows: 

a. If a pragma appears before any compilation unit in a 
compilation, it will affect all following compilation units, 
as specified below and in Section 10.1 of the Ada Language 
Reference Manual. 

b. If a pragma appears inside a compilation unit, it will be 
associated with chat com.pilation unit, and with the listings 
associated with that compilation unit, as described in the 
Ada Language Reference Manual, or below. 

c. If a pragma follows a compilation unit, it will be associared 
wirh tne preceding compilation unit, and effects of the 
pragma will be found in the container of that ccm.pilation 
unit and in the listings associated with that container. 

The pragmas ME.MORY_SI2E, STORAGEJJNIT, and SYSTEM_NAME are 
descrioed in Section 13.7 of the Ada Language Reference Manual, 
They may appear only at the start of the first compilation when 
creating a program library. In the ALS/N, however, since program 
libraries are created by the Program Library Manager and not by 
the compiler, the use of these pragmas is obviated. If they 
appear anywnere, a diagnostic of severity level WARNING is 
generated. 


r 


2 


Pragmas 


r-03 






Vers:.on 3.5 
29 March 1991 


Ada/.M ?SE Handbccrc 


F.2.1 Language-Defined Pragmas 

The fcilowi.-'.g notes specify i-Tiplen’entation-specific cnanges 
to tncse pragmas described in Appendi.x 3 cf the Ada Langca 
.Reference .Manual. I'nmenticned pragmas are i.'nple.mented as 
in tne Ada language Reference .Manual. 

pragma INLINE (arg {,arg}); 

The arguments designate suoprcgrams. There are three 
instances in which tne INLINE pragma is ignored. Each 
cf these cases produces a warning .message which states 
that the INLINE did not occur. 

a. If the ccm.pilation unit containing the INLINEd 
subprogram depends on the compilation unit of its 
caller, a routine call is made instead. 

b. If the INLINEd subprogram's compilation unit 
depends on the compilation unit of its caller (a 
routine call is made instead). 

c. If an imm.ediately recursive subprogram call is made 
within the body of the INLINEd subprogram (the 
pragma INLINE is ignored entirely). 

pragma INTERFACE (language_name, subprogram_name); 

The language_name specifies the language and type of 
interface to be used in calls used to the externally 
supplied subprogram specified by subprogram_name. The 
only value allowed for the first argument (language 
name) is MACRO_NORMAL. MACRO_NORKAL indicates that 
parameters will be passed on the stack and the calling 
conventions used for normal Ada subprogram calls will 
apply. 

You must ensure that an assembly-language body 
container will exist in the program library before 
1 ir.King. 


F-04 


F. 2 


Language-Defined Pragmas 


rrxi 







Ada,M ?SE 


n 3 Pi G b c c K 6 r s i c Pi 3 . 5 

29 Marcr. 139: 


pragma OPTIMIZE (arg); 

The argument ia either TIME or SPACE. If TIME is 
specified, the optimizer concentrates on optimizing 
code execution time. If SPACE is specified, the 
optimizer concentrates on optimizing code size. The 
default is If tne OPTIMIZE option is enaoled and pragm.a 
OPTIMIZE is not present, global optimization is still 
performed with the default argu.ment, SPACE. Program 
units containing OPTIMIZE pragmas and compiled witn the 
OPTIMIZE option may be linked with program units 
containing OPTIMIZE pragmas and compiled with tne 
NO_OPTI.MIZE option; but only those program units 
compiled with the OPTIMIZE option will have global 
optimization support. SPACE. 

pragma PRIORITY (arg); 

The argument is an integer static expression in the 
range 0..15, where 0 is the lowest user-specifiable 
task priority and 15 is the highest. If the value of 
tne argument is cut of range, the pragma will have no 
effect otner than to generate a WARNING diagnostic. A 
value of zero will be used if priority is not defined. 
The pragma will have no effect when not specified in a 
task (type) specification or the outermost declarative 
part of a subprogram. If the pragma appears in the 
declarative part of a subprogram, it will have no 
effect unless that subprogram is designated as the main 
subprogram at link time. 

pragma SUPPRESS (arg {,arg}); 

This pragma is unchanged with the following exceptions: 

Suppression of OVERFLOW_CHECK applies only to integer 
operations; and PRAGMA SUPPRESS has effect only within 
the compilation unit in which it appears, except that 
suppression of ELABORATION_CHECK applied at the 
declaration of a subprogram or task unit applies to all 
calls or activations. 


E. 2 .1 


Language-Defined Pragmas 


F - 0 5 





c : < 


Versicn j.5 Ada. M ?SE Har.do 

29 Marcn 1991 


F.2.2 Implementation-'defined Pragmas 

near. 1 r.g rf irose oracnas 
ed ir Apperdix 3 of tre 


pragrr.a 2E3L'G; 


This paragrapn describes the use and 
reccqrired by .Ada, M uT.icr are rcc spec.fi 
.Ada larquaqe P.efererce .Manual. 


This praqrr.a enaoles me incl-ision cf full synoolic 
.nfcrnarion and support for one E.Tibedded Target 
Teouqqer. The TE3uG PRAGiMA is enabled oy tne DEBUG 
cc.TUT.and line option and has no effect if this option is 
not provided. This pragma must appear within a 
compilation unit, oefore the first declaration or 
statement. 

pragma EXECUTIVE ;(arg) ; ; 

This pragm.a allows you to specify that a co.mpilation 
unit -3 to run in the e.'cecutive state of tne machine 
and, or utilize privileged instructions. The pragma has 
no effect if tne compiler option NO_EXECUTIVE is 
enacled, e.tner e.xplicitly o: oy default. 

If rRAG.MA EXECUTIVE is specified without an argument, 
executive state is in effect for the compilation unit 
and tne code generator does not generate pri”il.^gcd 
instructions for the compilation unit. If PRAGMA 
EXECUTIVE (INHERIT) is specified, a subprogram in the 
co.mpilation unit inherits the state of its caller ahd 
tne code generator does not generate privileged 
instructions for the compilation unit. If PRAGMA 
EXECUTIVE (PRIVILEGED) is specified, the executive 
state is in effect and the code generator may generate 
privileged instructions for the compilation unit. In 
the absencs of PRAGMA EXECUTIVE, the compilation unit 
executes in tasK state and the code generator does not 
generate privileged instructions. 

PRAGMA EXECUTIVE is applied once per compilation unit, 
so its scope is the entire compilation unit. PRAGMA 
EXECUTIVE may appear between tne context clause and the 
outer.most unit. If there is no context clause, PRAGMA 
EXECUTIVE must appear within that unit before the first 
declaration or statement. The placement of the pragma 
before the context clause has no effect on any or all 
following compilation units. If PRAGMA EXECUTIVE 
appears in the specification of a compilation unit, it 
must also appear in the body of that unit, and vice 
versa. If the pragma appears in a specification but is 
aoser.t from the body, you are warned and the pragma is 
effective. If the pragma appears in the body of a 
compilation unit, but is absent from the corresponding 


F-06 


F.2.2 I.mplementation-Defined Pragmas 






Ada M ^S£ Har.dbcc< 


2 9 


7e r 3 : “n 
Ma r cr. 


9 91 


specification, you are varned and the pragma has no 
effect. PRAG.HA EXZC'JTIVZ dees net propagate to 
s^ounits. If a suounit is compiled without PRAGMJk 
EXZCUTI7E and tne oarent of the suounit is comoiled 
Wi-n PRAC.MA ZXZC'JTIVZ, you are warned and RRAG.^ 
ZXZC'JTIVZ nas no effect on tne suounit. 

p'agma rAST_:N'TZRR'J?T_~NTRy (entry_name, I.'-'-MZD I ATE ) ; 

This pragma provides for situations of high interrupt 
rates witn simple processing per inte’’rupt, {such as 
adding data to a ouffer), and where comple.x processing 
occurs only after large numbers of tnese interrupts, 
'such as wnen tne buffer is full). This allows for 
lower overnead and faster response capability by 
restricting you to disciplines that are commensurate 
witn li.mitations norm.ally found in machine level 
interrupt service routine processing. 

pragma MEASURE ( e.x^ r act ion_set, [arg {,arg}i); 

This pragm.a enaoles one or m.cre performance measurem.ent 
features. Pragma MEASURE specifies a user-aefined 
extraction set for the Run-Ti.me Performance Measure.ment 
Aids and E.mbedded Target Profiler. The user-defined 
extraction set consists of all occurences pragma 
MEASURE throughout the program. Extraction_set is a 
numeric literal, which is an index into a user-supplied 
table. Arg is a variable or a list of variables whose 
values are reported at this point in the execution. 
These values describe the nature (TYPE) of the values 
collected to an independent data reduction program. 
Pragma .MEASURE is enabled by the MEASURE command line 
option and has no effect if this option is not 
provided. This pragma should be applied to a package 
body rather than a package specification. 

pragma STATIC (INTERRUPT_HANDLER_TASK); 

The pragma STATIC is only allowed immediately after the 
declaration of a task body containing an immediate 
interrupt entry. The argument is 

INTERRUPT_HANDL£R_TASK. The effect of this pragma will 
oe to allow generation of nonreentrant and nonrecursive 
code in a compilation unit, and to allow static 
allocation of all data in a compilation unit. This 
pragma shall be used to allow for procedures within 
immediate (fast) interrupt entries. The effect will be 
for the compiler to generate nonreentrant code for the 
affected procedure bodies. If a STATIC procedure is 
called recursively, the program is erroneous 


Z . 2 . 2 


Implementation-Defined Pragmas 


E-07 





Versicr. ^.5 Ada/M ?Sc rar.dooc< 

29 Marcn 1991 


pragma TICK (arg ) ; 

This is a system configuration pragma. It takes a 
single argum.ent of type universal_reai, vnich specifies 
tne value of the named numner SYSTEM.TICK. This pragma 
may appear only at tne start of the first compilation 
••v-nen creating a program library. If this pragma 
appears elsewnere, a diagnostic of severity WARNING is 
oenerated. 

pragma TITLE (arg); 

This is a listing control pragma. It takes a single 
argument of type string. The string specified will 
appear on tne second line of eac.n page of the source 
listing produced for the compilation unit within which 
It appears. The pragma should be the first lexical 
unit to appear within a compilation unit (excluding 
comments). If it is not, a warning message is issued. 

pragm,a TR I7IAL_ENTRY (NAME: ent r y_s imple_name ) ; 

This pragma is only allowed within a task specification 
after an entry declaration and identifies a 
Trivial_Entry to the system. A trivial entry 
reoresents a synchronization point, contained in a 
noimal Ada task, for rendezvous with a fast interrupt 
entry ocdy. The body of a trivial entry must be null. 

pragma UNMAPPED (arg {,arg}); 

The effect of this pragma is for unmapped (i.e., not 
consistently mapped within the virtual space) 
allocation of data in a compilation unit. The 
arguments of this pragma are access types to be 
unmapped. If a program tries to allocate more UNMAPPED 
space than is available in the physical configuration, 
STORAGE_ERROR will be raised at run-time. PRAGMA 
UNMAPPED must appear in the same declarative region as 
the type and after the type declaration. 


E-08 


F.2.2 Implementation-Defined Pragmas 




Ada/M ?SE: HandbccK 


Ver 3 icp. 2.5 
2 9 Marcr. 19 91 


F.2.3 ^cope of Pragmas 

The scope for eac.n pragma previous!'/ do'^crioed as differing 

from one Ada Language Reference Manual is given oelo'v. 

DEBUG Applies co ohe compilaticn unit in whicn tne praoma 

appears. 

EXECUTIVE Applies to the compilation unit in whicn tne pragma 

appears, i.e., to all subprograms and tasKS witnin 
the unit. Elaboration code is not affected. The 
pragma is not propagated from specifications to 
bodies, or from bodies to subunits. T.he pragm.a 
must appear consistently in the specification, 
body, and subunits associated wit.n a library unit. 

?AST_INTERRU?T_ENTRY 

Applies to the compilation unit in which the prag.m.a 
appears. 

INLINE .Applies only to subprograms named in its 

arguments. If the argument is an overloaded 
subprogram name, the INLINE pragma applies to 
all definitions of that subprogram name which 
appear in the same declarative part as the 
INLINE pragma. 

INTERFACE Applies to all invocations of the named 
imported subprogram. 

MEASURE No scope, but a WARNING diagnostic is 

generated. 

MEMORY_SIZE No scope, but a WARNING diagnostic is 
generated. 

OPTI.MIZE Applies to the entire compilation unit in 

which the pragma appears. 

PRIORITY Applies to the task specification in which it 

appears, or to the environment task if it 
appears in the main subprogram. 

STATIC Applies to the compilation unit in which the pragma 

appears. 

STORAGE_'JNIT No scope, but a WARNING diagnostic is 
generated. 

SUPPRESS Applies to the block or body that contains 

the declarative part in which the pragma 
appears. 


F.2.3 Scope of Pragmas 


F-09 






Version 3.5 
29 March 1991 


Ada/M ?SE Har.dbcc< 


SYSTEM 

TICK 

TRIVIA 

CNMAP? 


IJAME — No scope, but a WARNING diagnostic is 
generated. 

Applies to the entire progrort library in 
which the pragma appears. 

The compilation unit within whicn the pragm.a 
occurs. 

_ENTRY Applies to the compilation unit in which the pragm.a 
appears. 

D Applies to all objects of the access type 

named as arguments. 


F-10 


F.2.3 Scope of Pragmas 






Ada,'M ?SE I-iandbccK 


7e r 5 lor. 2 . ■ 
29 Marcn 139: 


P.3 Attributes 

The following notes augment the language-requi 


e predefined attributes 
age Reference Manual. 

f ou 

nd 1 

T'mach:ne_emax 

is 

63. 

T'.MACHINE EMIN 

is 

-64. 

T ' MJ\CH INE_MANT IS SA 

1 s 

6 . 

T ' M-ACHINE_OVERFLOWS 

is 

TRUE 

T ' MACHINE_RADi;< 

is 

16. 

T ’ MAiCHINE_ROUNDS 

is 

F ALS 


red d e fin. 
f tne Ada 


F.3 Attributes 


F-11 




m t/i 


Vers.cr: 3.5 Ada/M ?SE Har.d'ccc< 

2 9 .Marc.-'. 1991 


F.4 Predefined Language Environment 

Tr.e predefined Ada language envirnn.T.ent consists of tne 
pac<ages STANDARD and SiSTE.M, wn.ic.n are descrroed Pelcw. 


F.4,1 Package STANDARD 

Tne pacKage ST.ANDARD contains tne following definitions in 
addiricn to tnose specified in Appendix C of the Ada Language 
-Reference Manual. 

TTPE boolean IS (false, true); 

TZR occlean'SIZE TSE 1; 

TYPE integer IS RANGE -32 768 .. 32_767; 

TYPE long_integer IS RANGE -2_147_483_648 .. 2_147_483_647; 

TYPE float IS DIGITS 6 RANGE 

-(i5#o.rr"rr3#ES3) .. (i5#o.Frrrrs#E63); 

-- Add.tiens to predefined subtypes: 

Y3TYPE long_natural IS long_integer RANGE 0..integer'LAST; 
Y2TYPE long_pcsitive IS long_integer RANGE 1..integer'LAST; 

PTR cnaracter’SIZE USE 3; 

TYPE string IS ARRAY (positive RA.NGE <>) OF character; 

PRAG.MA PACK (string); 

TYPE duration IS DELTA 2.0 ** (-14) 

RANGE -13i_071.0 .. 131_071.0; 

-- The predefined exceptions; 

con3traint_error : exception; 

nu.T.eric_er7or ; exception; 

progra.m^error ; exception; 

storage~error : exception; 

tas<ing~error : exception; 


F-12 


F.4.1 Package STANDARD 










Ada M ?SE Har.dbcok 


Version ;.5 
29 Marcn 1391 


P. 4.2 ^Ckage SYSTEM 

The SYSTEM packages for Ada/M are as follows: 


F.4.2.1 AN/aYK-44 SYSTEM 

The package SYSTEM for the AN/UYK_44 is: 

TYPE name IS (anuyk44, anaykl4); 

3yscem_name : CONSTANT system.name := system.anuyk44; 

storage_anit : CONSTANT := 16; 

memory_si 2 e : CONSTANT := 65_536; 

TYPE address IS RANGE 0..system,memory_si 2 e - 1; 

FOR address'SIZE USE 16; 

— System Dependent Named Numbers 

min_int : CONSTANT := -(2**31); 

max_int : CONSTA.NT := (2**31)-1; 

max_digits : CONSTANT := 6; 

max_mantissa : CONSTANT := 3‘1; 

fine_delta : CONSTANT := 

240.0000_0000_0000_0000_0000_0000_0000_OQ1#; 
tick : CONSTANT := 3.125e-05; 

— 1/32000 seconds is the basic clock period. 

— Other System Dependoi.t Declarations 

SUBTYPE priority IS integer RANGE 0..15; 

TYPE entry_kind IS (normal, immediate); 

physical_memory si 2 e ; CONSTANT := 2**22; 

TYPE physical_a3dre3s IS 

RANGE 0..system.physical_memory_si 2 e - 1; 

TYPE external_interrupt_word IS RANGE 0 .. 65_536; 

Address clause (interrupt) address codes for the 

ANUYK-44 

Cla3S_I_Unhandled_address 
Clas3_II_Unhandled_address 
Class III Unhandled address 


: CONSTANT 

address := 16#0800#; 
: CONSTANT 

address ;= 16#1800#; 
; CONSTANT 

address := 16#2800#; 


P.4.2.1 


AN/UYK-44 SYSTEM 


F-I3 










Version 3.5 Ada/M ?SE rlandbccK 

29 Marc.n 1991 


--Class 

C?_Memory_Resume_address 

C?_Memory_?ar i •:y_addr ess 

;cc_.Memory_?ar i ty_address 

IOC_Memory_Resume_address 

?ower_"aul t:_addr ess 

- Class 

C? Instruction Fault address 


rupts - 

CONSTANT 


address 

CONSTANT 

:= 16#10004; 

address 

CONSTANT 

;= 16#1400#; 

address 

CONSTANT 

:= 16#17004; 

address 

CONSTANT 

:= 16(*1A00#; 

address 

rrupts — 

:= 16#1F00#; 


: CONSTANT 


Zxecutive_Mode_Fault_address : 

address 

CONSTANT 

: = 

16#2200#; 

IOC_Instruction_Fault_address : 

address 

CONSTANT 

: = 

16#2300#; 

IOC ?rotect_Fault_address : 

address 

CONSTANT 

: = 

16#2400#; 

C?_?rctect_Fault_address 

address 

CONSTANT 


16#2500#; 

once_oniy_pti : CONSTANT duration 

address 

: = 0.0; 


16#2900#; 

— Used to indicate that a PTI 

is not to 

be 

periodic. 


SUBTYPE pti_address IS address RANGE 16#2F01#..16#2F1F#; 
TYPE pti_state IS {active,inactive,unregistered); 


- Class III (I/O) interrupts 

.'lMIO_Discrete_Interrupt_address : CONSTANT 

~ address := 

MMIO_External_Interrupt_address : CONSTANT 

address := 

.'<MIO_Output_Data_Ready_address ; CONSTANT 

address := 

MMIO_Input_Data_Ready_address : CONSTANT 

address := 

IOC__Intercomputer_Timeout_addres3 : CONSTANT 

address := 

IOC_External_Int_Discrete_address : CONSTANT 

address := 

IOC__Output_Chain_Interrupt_address : CONSTANT 
~ address := 

IOC_Input_Chain_Interrupt_address : CONSTANT 

address := 


16#3C00# 

16#3D00# 

16#3E00# 

16#3F00# 

16#3C00# 

16#3D00# 

16#3E00# 

16#3F00# 


F-14 


F.4.2.1 AN/UYK-44 SYSTEM 






















Ada/M PSE Handbook 


Versicr. 3.5 
2 9 Marc.”! 19 91 


— The following exceptions are provided as a "convention" 

— wnereby the Ada program can be compiled with all i-mplicit 

— checks suppressed (i.e., pragma SUPPRESS or equivalent), 
-- explicit checks included as necessary, the appropriate 

-- exception raised when required, and then the exception is 
-- either handled or the Ada program terminates. 

access_check 
discriminant_check 
index_check 
length_cneck 
range_check 
division_check 
over flow_check 
elabcration_check 
storage_check 

— implementation-defined exceptions. 

unresolyed_reference : EXCEPTION; 
system_error : EXCEPTION; 

capacity_error : EXCEPTION; 


EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

E.XCEPTION 

EXCEPTION 

EXCEPTION 



F.4.2.1 AN/UYK-44 SYSTEM 











Version 3.5 Ada/M ?SE H 

29 March 1991 


F.4.2.2 AN/^K7l4 SYSTEM 

The package SYSTEM for the AN/AYK-14 is: 

TYPE name IS ;anuyk44, anaykl4); 

3ystem_name : CONSTANT system.name := system.anay<14; 

storage_unit : CONSTANT := 16; 

memory_si 2 e : CONSTANT := 65_536; 

TYPE address IS RANGE 0 .. system..memory_3 i ze - 1; 

FOR address'SIZE USE 16; 

— System Dependent Named Numbers 

min_int : CONSTANT := -(2**31); 

max_int ; CONSTANT ;= {2**31)-l; 

max_digits : CONSTANT := 6; 

.'nax_mantissa : CONSTANT := 31; 

fine_delta : CONSTANT := 

2 40.0000_QOOO_0000__0000_QOOO_0000_0000_0014 ; 
tick : CONSTANT := 3.125e-05; 

-- 1/32000 seconds is the basic clock period. 

— Other System Dependent Declarations 

SUBTYPE priority IS integer RANGE 0..15: 

TYPE entry__kind IS (normal, immediate); 

physical_memory_si 2 e : CONSTANT := 2**22; 

TYPE physical_address IS 

RANGE 0..system.physical_memory_size - 1; 

TYPE external_interrupt_word IS RANGE 0 .. 65_536; 

Address clause (interrupt) address codes for the 

ANAYK-14 

: CONSTANT 

address := 16#0800# 
; CONSTANT 

address := 16#1800# 
: CONSTANT 

address := 16#2800# 


Clas3_I_unhandied_address 
Class_II_Unhandled_addres3 
Class III Unhandled address 


a.ndbocx 


E-16 


F.4.2.2 AN/AYK-14 SYSTEM 










Ada/M ?SE Handboo< 


Veraic- 3.5 
2 9 Marcr. 1991 


Class I interrupts 


.Memory Resume address 


CONSTANT 

address := 15^1000# 

.Memory Rarity address 


CONSTANT 

address := 1641400!* 

Thermal Overload_address 


CONSTANT 

address := 1541900# 

IO_Failure_address 


CONSTANT 

address := 15413004 

Hardware 3IT Fault_address 


CONSTANT 

address := 1641C004 

Hardware Fault Warning_address 


CONSTANT 

address := 15410004 

Rower Fault address 


CONSTANT 

address := I641F004 


- Class II interrupts - 

CP_Instruction_Fauit_address : CONSTANT 

address := 16#2200#; 

Execut ive_.*4cde_Inst ruction_Fault_address : 

CONSTANT 

address := 15^2300#; 

IO_In3truction_Fault_address : CONSTANT 

address := 15#2'00#; 

System_Reset_address : CONSTANT 

address := 16#2500#; 

Overtemp_address : CONSTANT 

address := 16#2700#; 

Memory_?rotect Fauit_address : CONSTANT 

address := 16#2900#; 

Sxternai_Interrupt_2_address : CONSTANT 

address ;= 16#2C00#; 

External_Interrupt_3_address ; CONSTANT 

address := 16#2D00#; 

External_Interrupt_4_addre33 : CONSTANT 

address := 16#2E00#; 

once_only pti : CONSTANT duration ;= 0.0; 

— Used to indicate that a PTI is not to be periodic. 

SUBTYPE pti_addres3 IS address RANGE 16#2F01# ..16#2F1F#; 

TYPE pti_3tate IS (active,inactive,unregistered); 

- Class III (I/O) interrupts - 

IO_Channel_Abnormal_address : CONSTANT 

address := 16#3C00#; 

External_Interrupt_address : CONSTANT 

address := 16#3D00#; 

Output_Chain_Interrupt_addres3 : CONSTANT 

address := 16#3E00#; 

Input_Chain_Interrupt_address : CONSTANT 

address := 16#3F00#; 


F.4.2.2 AN/AYK-14 SYSTEM 


F-i7 





















Version 3.3 Ada,-M ?SE :-:ar.do''o< 

29 Marc.n 1991 


-- The fcrir-l-owing exceptions are provided as a ''convention" 

— whereby the Ada program can be compiled with all implicit 

— cnecks suppressed (i.e., pragm.a SUPPRESS or equivalent), 

— explicit checxs included as necessary, the appropriate 

— exception raised when required, and then the exception is 

— eitner handled or the Ada program terminates. 

access_checi< 
discriminant_check 
index_chec< 
length_check 
range_cneck 
diVISion_check 
over flow_check 
elaboration_check 
storage_check 

— implementation-defined exceptions, 

unresolved_reference : EXCEPTION; 
syste.m_er ror : EXCEPTION; 

capacity error : EXCEPTION; 


EXCEPTION; 

EXCEPTION; 

EXCEPTION; 

EXCEPTION; 

EXCEPTION; 

EXCEPTION; 

EXCEPTION; 

EXCEPTION 


F-13 


F.4.2.2 AN/AYK-14 SYSTEM 









/ 


Ada/M ?SE HandbocK Versicr. 2.3 

2 3 Marcr. 1391 

F.5 ChjLracter Set 

Ada compilations may be expressed using tne followir.a 
characters in addition to the basic character set: 

Icwer case letters: 

a b c d e f g h i j < 1 m n o p q r s t u v w x y z 
special characters: 

! $ % ? 3 L ] ' ‘ ^ ' 

The following transliterations are permitted: 

a. Exclamation point for vertical bar, 

b. Colon for sharp, and 

c. Percent for double-quote. 


F.5 Character Set 






Version 3.5 
2 9 .Marc.^. '.991 


Ada, M ?SE 


cc< 


Hando 


F.6 DeciaraLtIqn and Representation Restrictions 

Z;eclaraiions are described in Section 3 of tne Ada dancuace 
Reference Manual, and representation specifications are described 
in Section 13 of tne .Ada Language Reference Manual and discussed 
nere. 

In tne following specifications, t.ne capitalized word SIZE 
indicates t.ne numoer of bits used to represent an oD]ect of tn.e 
type under discussion. The upper case symbols D, L, R, 
correspond to those disoussed in Section 3.5.9 of the .Ada 
Language Reference Manual. 


F.6.1 Integer Types 

Integer types are specified wioh constraints of the form: 
RANGE L..R 

where: 

R <= S’ZSTEM.MA;<_INT i L >= S'ZSTEM.MIN_INT 

For a prefix "t" denoting an integer type, length specifications 
of the form: 

."OR t'SIZE USE n ; 

may specify integer values n such that n in 2.. 16, 

R <= 2**(n-l)-i s, L >= -(2**(n-l)) 
or else such that 

R <= (2**n)-l & L >= 0 
and 1 < n <= 15. 

For a stand-alone object of integer type, a default SIZE of 16 is 
used when: 

R <= 2**15-1 & L >= -2**15 

Otherwise, a SIZE of 32 is used. 

For components of integer types within pac)<ed composite 
objects, the smaller of the default stand-alone SIZE or the SIZE 
from a length specification is used. 


F-20 


^ fi ■' 


Integer Types 



Ada. M ?SE Har-docc-; '/■ers.tr. ' .5 

2 9 Marcr. 199 1 

F.6.2 Elpating Types 

ricacing types are specified vitf. ccns t r a i r. t s cf tr.e ftrc.: 
DIGITS G 


wr.ere G .s ar. ir.tecer in tne ranee 1 tnroaen 6 . 

Far a prefix "t" denoting a floating pc.nt type, lengtn 
specifications of tne fern'.; 

FCR t'SI’Z USE n; 

nay specify integer valoes n = 32 when G <= 6. All floating 
point values have SIZE = 32. 


F.6.3 Fixed Types 

Fixed types are specified with constraints of the forn: 
GELGA G R.ANGE L..R 


w .n e r e ; 


.MA.X (*.SS{R), A3S(L) 


actual deita 


<= 2**31-1. 


The actual delta defaults to the largest integral power of 2 less 
than or equal to the specified delta G. (This i.Ttplies that fixed 
values are stored rir,ht-aligned. ) 

For fixed point types, length specifications of the form: 
for T'SIZE use N; 

are permitted only when N in 1 ,. 32, if: 

R - actual_delta <= 2**(N-1)-1 * actual delta, and 
L ^ actual delta >= -2**{n-l) * actual)5elta 


or 


R - actual_delta <= 2**(N)-1 * actual_delta, and 
G >= 0 


F.6.3 Fixed Types 








Vers-on 3.5 Ada, M ?SE Har.dbcc.< 

29 March 1991 


For sband-alcLae .OD]ect3 of fixed point type, a default size of 32 
13 used. For components of fixed point types witnin pacxed 
composite ob'ects, tne size from one length specification will ce 
used. 

For specifications of the form: 

FCR t ' SMALL L’SE n ; 


are permitted for any value of X, 
specified either cs a base 2 
tnat when X is soecified as 


sucn tna 
value or as a 
tner than a ocwer 


X <= D. X must oe 


;f 2, actua; 


:e - ta 


will still be tne largest integreal power of two less tnan X. 


F.6.4 Enumeration Types 

In the absence of a representation specification for an 
enumeration type "t," the internal representation of t'FIRST is 
0. The default size for a stand-alone object of enumeration type 
"t" is 16, so the internal representations of t'FIRST and t'LAST 
octh fall witnin the range 

-2**13 .. 2**15 - 1, 

For enumeration types, length specifications of the form: 

FOR t'SIZE USE n; 

and/or enumeration -representations of the formi: 

FOR t USE <aggregate>; 

are permitted for n in 2..16, provided the representations and 
the SIZE conform to the relationship specified above. 

Or else for n in 1..16, is supported for enumeration types 
and provides an internal representation of: 

t'FIRST >= 0 ., t'LAST <= 2**(t’SIZE) - 1. 

For components of enumeration types within packed composite 
ob;ect3, the smaller of the default stand-alone SIZE and the SIZE 
from a length specification is used. 

Enumeration representations for types derived from the 
predefined type STANDARD.BOOLEAN will not be accepted, but length 
specifications will be accepted. 


F-22 


F.6.4 Enumeration Types 








Ada/M ?SE Har.dbccK Versicn 3.5 

2 9 Marcr. 199 1 


F.6.5 ^cess Types 

For access type, "t," length specifications of the forT.: 

FOR t'SIZF USE n; 

will noo affect tne runoi.ne i.-nplementarion of "t," therefore n = 
15 13 the only value permitted for SIZE, which is the value 
returned by the attribute. 

For collection size specification of the form: 

FOR t ' STOR.AGE_SIZE USE n ; 

for any value of "n" is permitted for STORAGE_SIZE (and that 
value will be returned by the attribute call). The collection 
size specification will affect the implementation of "t" and its 
collection at runtime by limiting the number of objects for type 
"t" tnat can be allocated. 

The value of t'ST0RAGE_SI2E for an access type "t" specifies 
tne maxim.um numoer of storage_units used for all objects in the 
collection for type "t.” This includes all space used by the 
allocated objects, plus any additional storage required to 
mainta 1 n the collection. 


F.6.6 Arrays and Records 

For arrays and records, a length specification of the form: 

FOR t'size USE n; 

may cause arrays and records to be packed, if required, to 
accommodate the length specification. If the size specified is 
not large enough to contain any value of the type, a diagnostic 
message of severity ERROR is generated. 

The PACK pragma may be used to minimize wasted space between 
components of arrays and records. The pragma causes the type 
representation to be chosen such that the storage space 
requirements are minimized at the possible expense of data access 
time and code space. 

A record type representation specification may be used to 
describe the allocation of components in a record. Bits are 
numbered 0..15 from the right. 16 starts at the right of the 
next higher numbered word. Each location specification must 
allow at least n bits of range, where n is large enough to hold 
any value of the subtype of the component being allocated. 
Otherwise, a diagnostic message of severity ERROR is generated. 
Components that are arrays, records, tasks.- or access variables 
I may not be allocated to specified locations. If a specification 

i 

I 


F.6.5 Arrays and Records 


F-23 








Version 3.5 
29 Marc.n 1991 


Ada/M ?SE Handoccrc 


of this fortiL_i3_ entered, a diagnostic r.essage of severioy ER.ROR 
is generaced. 

For records, an alignment clause of ihe form: 

AT MOD n 

specify alignments of 1 word (word align.ment) or 2 words 
■; doub 1 ewe rd a 1 1 gnment) . 

If it is determinable at compile tim.e that the SIZE 
record or array type or subtype is outside the range of 
STANDARD.LONG_INTEGER, a diagnostic of severity WARNING 
generated. Declaration of suen a type or subtype would 
NUMERIC ERROR when elaborated. 


F.6.7 Other Length Specifications 

Length Specifications are described in Section 13.2 of the 
Ada Language Reference Manual. 

A length specification for a tas< type "t" of t.he form: 

FOR t'STORAGE_SIZE use n; 

specifies the number of SiSTEM.STORAGE_UNITS that are allocated 
for the execution of each task object of type "t." This includes 
the runti.me stack for the task object but does not include 
objects allocated at runtime by the task object. If a 
t'STORAGE_SIZE is not specified for a task type "t," the default 
value is 8K (words). 

A length specification for a task type "t" of the form: 

FOR t'SIZE USE n; 
is allowable only for n = 32. 


c 



raise 


F-24 


F.6.7 Other Length Specifications 






Ada/M ?SE Handbook 


) 




Version 3.5 
29 .Marcn 19 31 


F.7 Sy#4:ein Generated Names 

Hefer co Section 13.7 of one Ada Language Reference Manual 
and one section above on one Predefined Language Envircn.oreno for 
a discussion of package SYSTEM. 

The sysoem name is chosen based on ohe targeo(s) supporoed, 
but 10 cannot be changed. In ohe case of Ada/.M, the sysoemi nam.e 
13 .A.NUYX4 4 or ANAYK14. 


F.a Address Clauses 

Refer to Section 13.5 of the Ada Language Reference Manual 
for a description of address clauses. All rules and restrictions 
described there apply. In addition, the following restrictions 
apply. 

An address clause may designate a single task entry. Such an 
address clause is allowed only within a task specification. The 
meaningful values of the si.mple_e.xpression are the allowable 
interrupt entry addresses as defined in Table F-1. The use of 
ot.ner values will result in the raising of a PROGRAM__ERROR 
exception upon creation of the tasK. 

If more than one task entry is equated to the same interrupt 
entry address, the most recently executed interrupt entry 
registration permanently overrides any previous registrations. 

At most one address clause is allowed for a single task 
entry. Specification of more than one interrupt address for a 
task entry is erroneous. 

Address clauses for objects and code other tha task entries 
are allowed by the Ada/M target, but they have no effect beyond 
changing the value returned by the 'ADDRESS attribute call. 


3 


Address Clauses 


F-25 







Version 3.5 
29 March 1991 


Ada/M ?SE Har.dboo< 


1 

AN/UYK-44 Interrupc Suirjnary ■ 

j 

1 

Class 0 interrupts (with interrupt 

entry address) include; 


1 

i 

0 Class I Llnhandled Interrupt 

16(t0800# 


I 

Class I interrupts {witn interrupc 

entry address) include: 



o Class II Cnhandled 

16#1800# 



o C? Memory Resume 

16#1000# 

i 


o C? Memory Rarity 

16#1400# 


1 

o IOC Memory Rarity 

16#1700# 

1 

i 

o IOC Memory Resume 

16#1A00# 

I 


o Power Fault 

16#1F00# 

j 

1 


Class :: interrupts (with interrupc 

entry address) include: 

j 

! 

o Class III Cnhandled 

16#2800# 

1 

1 

1 


o Floating Rome Over/Underflow 

16#2100# UNDEFINABLE 

1 


0 C? Instruction Fault 

16#2200# 

( 


0 Executive Mode Fault 

16#2300# 

i 


0 IOC Instruction Fault 

16#24C ^ 



o IOC Protect Fault 

16#25L 4 



o Executive Return 

16#2600# INDEFINABLE 



o Overtemp address 

16#2700# 



o CP Protect Fault 

16#2900# 



o Real-Time Clock 

16#2E00# UNDEFINABLE 



o Monitor Clock 

16#2F00# UNDEFINABLE 





— + 


Table F-la - Interrupt Entry Addresses 


F. 8 


-26 


Address Clauses 















Ada/M ?SE HandbcoK 


V e r s 1 c r. 3.5 
29 Ma r c r. 19 91 


; .AN/UYK-44 I.Tterrupc Su.Tunary 

t 


Class ::: interrupts (with interrupt entry address) include: 


L6#3C00# 

1643D00# 

16#3E00# 

16#3F00# 

16#3C00# 

1643D00# 

16#3E00# 
i5#3F00# 

1 For all class III interrupts, the following interpretations 

j ^PP^y: 

! IC => IOC, CHANNEL pair, i6#00#..1640F# indicates IOC 0 
16#10#..15*lFf indicates IOC 1 
16#20#..16#2Ft indicates IOC 2 
16#30# . . 16)^3F!f indicates IOC 3 

{ CC => CHANNEL number, I6#00#..16#3Ff indicates channel 0..63 


o MMIO Discrete Interrupt 
o MMIO External Interrupt 
0 MMIO Output Data Ready 
o .MMIO Input Data Ready 
o IOC Intercomputer Timeout 
o IOC External Interrupt/Discrete 
o IOC Output Chain Interrupt 
o IOC Input Chain Interrupt 


Table F-lb - Interrupt Entry Addresses (Continued) 


F.8 Address Clauses 


F-27 









Version 3.5 
29 Marc.n 1991 


Ada/M ?S£ HandbccK 


AN/AYK-14 Interrupt Summary 


Class 0 interrupts {with interrupt entry address) include: 


o Class I Cnhandled Interrupt 164080u 


Class I interrupts {with interrupt entry address) include: 


o Class II Unhandled 
o C? Memory Resume 
o C? Memory Parity 
o Thermal Overload 
o 10 Failure 
o Hardware BIT Fault 
o Hardware Fault Warning 
o Power Fault 


1641800# 

16#1000# 

1641400# 

1641900# 

1641300# 

1641000# 

1641D00# 

1641F00# 


Class II interrupts (with interrupt entry address) include: 


i ° 

Class III Unhandled 

1642800# 


1 


Floating Point Over/Underflow 

1642100# 

UNDEFINASLE 


1 

CP Instruction Fault 

1642200# 


) 

o 

Executive Mode Fault 

1642300# 


1 

0 

IOC Instruction Fault 

1642400# 



o 

System Reset 

1642500# 



o 

Executive Return 

16#2600# 

UNDEFINABLE 


o 

Overtemp address 

1642700# 



o 

C? Protect Fault 

1642900# 



o 

Real-Time Clock 

16#2E00# 

UNDEFINABLE 


o 

^ M « « « 

Monitor Clock 

16#2F00# 

UNDEFINABLE 

B 


Table F-lc - Interrupt Entry 

Addresses 

(Continued) 



F->28 


F.a Address Clauses 















Ada/M ?SE Har.d’Dca< 


Versicn 3.5 
29 Marcn 1991 


AN/A’/K-14 Incerrupr Su.'nmary 


Class III interrupts (winh interrupt entry address) include: 


o 10 C.^annel Abnor.tal 
o External Interrupt 
o Output Chain Interrupt 
o Input Chain Interrupt 


i6#3C00# 

16#3D00# 

16#3E00# 

L543F00# 


For all class III interrupts, the following interpretations 
apply: 

' IC => IOC, CHANNEL pair, 16#00#..16#0F# indicates IOC 0 
i 15#10#..16#1F# indicates IOC 1 

I 15#20#..16#2FI indicates IOC 2 

‘ 16#30#..16#3Ft indicates IOC 3 

' CC => CHANNEL number, 1640016#3F# indicates channel 0..63 


I 


Table F-ld - Interrupt Entry Addresses (Continued) 


F.8 Address Clauses 


F-29 










Version 3.5 
29 March 1991 


Ada/M ?SE HandbccK 


F.9 Oncheciced Conversions 

Refer co Section 13.10.2 of the Ada Language Reference Manual 
for a description of i;ncheCKED_CONVERSION. It is erroneous if 
your Ada program performs L'N'CHECKED_CONVERSION wnen the source 
and target objects have different sizes. 


F.IO Restrictions on the Main Subprogram 

Refer to Section 10.1 (3) of the Ada Language Reference 
Manual for a description of the main subprogram. The subpic 
designated as the main suoprogram cannot have parameters. T 
designation as the main subprogram of a suoprogram whose 
specification contains a formai_part results in a diagnostic of 
severity ERROR at lin< time. 

The main subprogram can be a function, but the return value 
will not be available upon completion of the main subprogram's 
execution. The m.ain subprogram may not be an import unit. 


F-30 


r 


10 Restrictions on the Main Subprogram 


r.Q 






Ada/M ?SE Handbook 


Version 
29 Marcn : 


991 


F.ll I^ut/Output 

Refer to Section 14 of the Ada Language Reference Manual for 
a discussion of Ada Input/Output and to Section 12 of the Ada/M 
Run Ti.T.e Environment HandbcoK for more specifics on the Ada/M 
inpuo/output subsystem. 

The Ada/M Input/Output subsystem provides the following 
packages: TEXT_l6, SEQCJSNTIAL_IO, DrRECT_:o, and L0W_LEVEL_:0. 
These packages execute in the context of the user-written Ada 
program tas< maKing tne I/O request. Consequently, all of tne 
code that processes an I/O request on behalf of the user-written 
Ada program executes sequentially. The package IO_EXCE?TIONS 
defines all of the exceptions needed by the packages 
SEQUENTIAL_IO, DIRECT_IO, and TEXT_IO. The specification of this 
package is given in Section 14.5 of the Ada Language Reference 
Manual. This package is visible to all of the constituent 
packages of the Ada/M I/O subsystem so that appropriate exception 
handlers can be inserted. 

I/O in Ada/M is performed solely on external files. Mo 
allowance is provided in the I/O subsystem for memory resident 
files (i.e., files which do not reside on a peripheral device). 
This is true even in the case of temporary files. With the 
external files residing on the peripheral devices, Ada/M maxes 
the further restriction on the number of files that may be open 
on an individual peripheral device. 

Section 14,1 of the Ada Language Reference Manual states that 
all I/O operations are expressed as operations on objects of some 
file cype, rather than in terras of an external file. File 
objects are implemented in Ada/M as access objects which point to 
a data structure called the File Control Block. This File 
Control Block is defined internally to each of the high-level I/O 
packages; its purpose is to represent an external file. The File 
Control Block contains all of the I/O-specific information about 
an external file needed by the high-level I/O packages to 
accomplish requested I/O operations. 


F.11.1 Naming External Files 

The naming conventions for external files in Ada/M are of 
particular importance. All of the system-dependent information 
needed by the I/O subsystem about an external file is contained 
in the file name. External files may be named using one of three 
file naming conventions: standard, temporary, and user-derived. 


F.11.1 Naming External Files 


F-31 






/ersicn 3.5 Ada/M ?SE Har.dbccfc 

29 March 1991 


F. 11.1.1 St^dard File Names 

The standard external file naming convention used in Ada/M 
identifies t.ne specific location of t.ne external file in terms of 
tne pnysical device on which it is stored. For this reason, you 
snculd be aware of the configuration of the peripheral devices on 
the AN.'JYK-44 or AN/.AiK-14 at your particular site. 

Standard file names consist of a six character prefix and a 
file name of up to fourteen characters. The six character prefix 
has a predefined format. The first and second characters must be 
eitner'"CT," "MT," or "TT," designating an AN/l:SH- 26 Signal Data 
Recorder/Reproducer Set, the RD-358 .Magnetic Tape Subsyste.m, or 
the AN/USQ-59 Data Terminal Set, respectively. These characters 
must be in upper case. 

The third and fourth characters specify the channel on which 
the peripheral device is connected. Since there are sixty-four 
cnannels on tne Ada/M system, the values for the third and fourth 
positions must lie in the range "00" to "63." 

The range of values for the fifth position in the external 
file name's prefix (the unit numoer) depends upon the device 
specified oy the characters in tne first and second positions of 
the external file name. If the specified peripheral device is 
tne AN/USK-26 magnetic tape drive, the character in the fifth 
position must oe one of the characters "0," "1," "2," or 
"3." This value determines which of the four tape cartridge 
units available on the AN/USH-26 is to be accessed. If the 
specified peripheral device is the RD-358 magnetic tape drive, 
the character in the fifth oosition must be one of the characters 
"0," "1," "2," or "3." This value determines which of the four 
tape units available on the RD-358 is to be accessed. If the 
specified peripheral device is the AN/USQ-69 militarized display 
terminal, the character in the fifth position must be a "0." The 
AN/USQ-69 has only one unit on a channel. 

The colon (:) is the only character allowed in the sixth 
position. If any character other than the colon is in this 
position, the file name will be considered non-standard and the 
file will reside on the default device defined during the 
elaboration of CONFIGURE_IO. 

Positions seven through twenty are optional to your Ada 
program and may be used as desired. These positions may contain 
any printable character you choose in order to make the file name 
more intelligible. Embedded blanxs, however, are not allowed. 


F-32 


F.11.1.1 Standard File Names 





Add, M ?SE Hdr.cbcc< Ver3:.~r. ■ . ' 

29 Marcr. 1991 


The iQcaticn of an external file on a peripheral devioe 13 
thus a ■function of the first six characters of tne file na.te 
regardless of the characters that tiight follow. For example, if 
tne external file "CTOOO :01d_Data'' has been created and not 
subsequently closed, an attempt to create the external file 
"CTOOO:New_Data" will cause the exception DEVICE_ERROR (rather 
tnan MA.ME_ERRCR or CSE_FRROR) to be raised because the perioneral 
device on cnannel " 00 " and cartridge " 0 " is already in use. 

You are advised that any file name beginning with "xxxxx;" 
(where x denotes any printable character) is assumed to oe a 
standard external file name. If this external file name dees not 
conform to the Ada/M standard file naming conventions, the 
exception NAME_ERROR will be raised. 


F.11.1.2 Temporary File Names 

Section 14.2.1 of the Ada Language Reference Manual defines a 
temporary file to be an external file that is not accessible 
after completion of the main subprogram. If the null string is 
supplied for the external file name, the external file is 
considered temporary. In this case, the high level I/O paexages 
internally create an external file name to be used by the lower 
level 1, 0 paexages. The internal naming scheme used by the I,'0 
subsystem is a function of the type of file to be created (text, 
direct or sequential), the temporary nature of the external file, 
and tne number of requests .made thus far for creating te.mporary 
external files of the given type. This scheme is consistent with 
the requirement specified in the Ada Language Reference Manual 
that all external file names be unique. 

The first three characters of the file name are "TEX," "DIR," 
or "SEQ." The next six characters are "_TEMP ." The remaining 
characters are the i.mage of an integer which denotes the number 
of temporary files of the given type successfully created. There 
are two types of temporary files; one is used by SEQUENTIAL_IO 
and DIRECT_IO, and the other is used by TEXT_IO. For instance, 
the temporary external file name "TEX_TEMP_10" would be the na.me 
of the tenth temporary external file successfully created by your 
Ada program through calls to TEXT_IO. 


.2 Temporary File Names 


33 







rn ft ft 


Version 3.5 Ada/M ?SZ HandoocK 

29 March 1991 


F.11.1.3 Oafr-Derived File Names 


.A random string cental 

n 1 ng 

a sequence or 

characters 

n f 

^ 0 

cne to twenty .may also be 

used 

to na.me an ex 

ternal file. 



files witr. names 

c f t f*. 

13 nature are 

considered 

* 

0 e 

oermane.nt external files. 

lOU 

are cautioned 

from usino 

nam 

.es 


vnich corforrr. to toe scneme used oy tr.e 1,0 suosystem to na.r.e 
temporary external fries (see list item ”b"). 

It is not possible to associate tvc or more internal files 
with tr.e sarnie external file. The exception TSZ_ERROR will oe 
raised if this restriction is violated. 


F.11.2 The FORM Specification for External Files 

Section 14.2.1 of the Ada Language Reference Manual defines a 
string argu.ment called tne FORM, which supplies system-dependent 
information tnat is somietimes required to correctly process a 
request to create or open a file. In .Ada/M, the string argument 
supplied to the FOR.M para.meter on calls to CREATE and OPEN is 
retained while the file is open, so tnat calls to the function 
FO.RM can return tne string to ycur Ada program. Form options 
specified ^n calls to CREATE have tne effects stated below. Form 
options specified on calls to OPEN nave no effect. 

The REWIND and APPEND opticns are mutually exclusive; an 
attempt to specify both options on a call to CREATE will raise 
tne exception ■JSE_ERROR. 

The NOHEAD option may be specified in comoination with either 
the REWIND or the APPEND option. 

If one form option is specified, the FORM string should 
contain only the option, without any extraneous characters. If 
wo form options are specified, the FORM string should contain 
he first form option followed by a comma followed by the second 
orm option. The form options may be specified in any 
combination of upper and lower case. 

If the supplied FORM string is longer than the maximum 
allowed FORM string (13 characters), CREATE and OPEN will raise 
tne exception USE_ERROR. 

If the procedure CREATE does not recognize the options 
specified in the FORM string, it raises the exception [JSE_ERROR. 
The procedure OPEN does not validate the contents of the supplied 
FORM string. 


F-3 4 


11.2 The FORM Specification for External Files 








Ada M ?SE Handbcc.< Veraicr. 2.5 

2 9 Marcr. 1391 

?03i-cir;nir.g argu-nents allow control of tape oefore tts use. 
The following positioning arguments are availab_e: 

a. REWIND - specifies t.nat a rewi.nd will be cerformed crior to 
tne requested op’^ration. 


0 . NOREWIND - specifies tnat tne tape remains positioned as is 


c . 

APPEND - spec 

1 f ies 

tnat the 

tape 

be positioned at the locioa 


end of tape ( 

lEGT) 

prior to 

tne 

requested operation. The 


lEOT 13 denct 

ed oy 

two ccnsecuti 

ve tape_m.ar <3. 


Note that, to 

0 r S U 

re a taoe 

file 

created bv a orevicus 


program is availaole for use by a new program, you must nave 
Knowledge of tne tape being used and must use t.ne APPEND form, 
option when creating new files. 

The form.atting argu.ment specifies information about tape 
form.at. If a form.atting argu.ment is not supplied, the file is 
assumed to contain a format header record determined by the .AIS/'N 
I 0 syste.m. The rollowing formatting argument is available: 

a. NOHEAD - specifies that the designated file has no header 
record. This argument allows the reading and writing of 
tapes used on computer systems using different header 
formats. Note that files created with the NOHEAD option 
cannot oe opened oy tne .Ada/M I/O subsystem. 


Th.e EOfRM Specifica 


on for External Files 


11 . 2 


r-3 5 









Ada/M ?SZ 


Version 3.5 
2 9 .Maron 19 91 


; Ha.ndbccK 


F.11.3 File~i^ocessing 

Processing allowed on Ada.'M files is rnfloenced by one 
cnaracoeristics of one underlying device. The following 
resoricoions apply: 


a. Only one file nay oe open on an individual .A.‘^/USn-26 tape 
caroridge ao a oi.ne. 

o. Only one input and one output file may 
on an AN. TSQ-69 term.inal at one ti.m.e. 

0 . An .Ada program is erroneous if it does 
all files It creates or opens. 

d. The attempt to CREATE a file with the mode IN_FI1E is not 
supported sinoe tnere will oe no data in the file to read. 


simultaneously oe open 
not close or delete 


F-3 6 


F.11.3 File Processing 






Ada/M ?SE Handbeck 


Version 
29 Maren 


1 . D 


99 1 


P.11.4 JText Input/Output 

TEXT 10 is invoked by your Ada program to perform sequential 
access I/O operations on text files (i.e, files whose content: is 
in human-readable form). TEXT_IO is not a generic package and, 
tnus, Its subprograms may be invoKed directly from your program, 
using cb]ect3 with base type or parent type in the 
language-defined type character. TEXT_I0 also provides the 
generic pacKages INTEGER_IO, EL0AT_I0, EIXED_I0, and 
ENUMERATI0N_I0 for the reading and writing of numeric values and 
enumeration values. The generic packages within rEXT_I0 require 
an instantiation for a given element type before any of their 
subprograms are invoked. The specification of this package is 
given in Section 14.3.10 of the Ada Language Reference Manual. 

The implementation-defined type COUNT that appears in Section 
14.3.10 of the Ada Language Reference Manual is defined as 
f c1lews: 

type COUNT is range 0.. INTEGER'LAST; 

The implementation-defined subtype FIELD that appears in Section 
14.3.10 of the Ada Language Reference Manual is defined as 
follows: 


subtype FIELD is INTEGER range 0..INTEGER'LAST; 

At the beginnihg of program execution, the STANDARD_rNPUT 
file and the STANDARD_OUTPUT file are open, and associated with 
the files specified by you at export time. Additionally, if a 
program terminates before an open file is closed (except for 
STANDARD_INPUT and STANDARD_OUTPUT), the last line added to the 
file may be lost; if the file is on magnetic tape, the file 
structure on the tape may be inconsistent. 

A program is erroneous if concurrently executing tasks 
attempt to perform overlapping GET and/or PUT operations on the 
same terminal. The semantics of text layout as specified in the 
Ada Language Reference Manual, Section 14.3.2, (especially the 
concepts of current column number and current line) cannot be 
guaranteed when GET operations are interweaved with PUT 
operations. A program which relies on the semantics of text 
layout under those circumstances is erroneous. 

For TEXT_IO processing, the line length can be no longer than 
532 cnaracters. An attempt to set the line length through 
SET_LINE_LENGTH to a length greater than 532 will result in 
USE ERROR. 


F.11.4 Text Input/Output 


F-3-' 





Ada/ M ?SE Har.cbcoK 


Version 3.5 
29 Marcn 1991 


F.11.5 Se<iT*eJVtial Input/Output 

3ZQVENTIAL_I0 is invoked by your Ada program to perform 1, 0 
on tne records of a file in sequential order. T.de SEQUENT:al_: 0 
pacKage also requires a generic instantiation for a given element 
type oefore any of its suoprograms may be invoked. Once tne 
package SEQCENTIAl_IO is made visible, it vill perform any 
service defined by t.ne suoprograms declared in its specification. 
Ttie specification of this pacKage is given in Section 14.2.3 of 
tne Ada Language Reference Manual. 


The following restrictions are im.ocsed on 

package SEQUENTIAL_:0: 

a. SEQLJENTIAL_IO cannot be instantiated with 
array type. 

o. SEQU£NTIAL_IO cannot be instantiated with 
discriminants with no default values. 

c. Ada VM does not raise OATA_ERROR on a read 
data input from the external file is not o 
type (see the Ada Language Reference .Manua 


the use of the 

an unconstrained 

a record type with 

operation if the 
f the instantiating 
1, Section 14.2.2). 


F.I1.6 Direct Input/Output 

Calls to the subprograms of an instantiation of DIR£CT_IO 
have one of three possible outcomes. The exception USE_ERROR is 
raised if an attempt is made to CREATE and/c’’ OPEN a file since 
direct access I/O operations are not supported in .Ada/M. The 
exceotion STATUS_ERROR is raised on calls to subprograms other 
than'CREATE, OPEN, and IS_OPEN. The function IS^OPEN always 
returns the value FALSE. 

The implementation-defined type COUNT that appears in Section 
14.2.5 of the Ada Language Reference Manual is defined as 
follows: 

type COUNT is range 0..LONG_INTEGER’LAST. 

The following restrictions are imposed on the use of the 
package OIRECT_IO: 

a. DIRECT_IO cannot be instantiated with an unconstrained array 
type. 

0 . 2)IRECT_I0 cannot be instantiated with a record type with 
discriminants with no default values. 


F-3 3 


F.11.6 Direct Input/Output 



Ada/M ?SE HandbooK 


Versi-cn 3.5 
2 9 .Marc.d 1991 


F.11.7 ^-fcow Level Input/Output 

LOW_LEVEL_IO i3 invoked by your Ada program to initiate 
physical operations on peripheral devices, and thus executes as 
part of a program task. Requests made to L0W_LEVEL_;0 from your 
program are passed t.nrough tne RTEXEC_GATEWAY to t.ne cnannel 
progra.ms in CHANNEL_IO. Any status check or result information 
is the responsibility of the invoking subprogram and can be 
octained from tne subprogra.m R£CEIVE_CONTROL wit.hin LOW_LEVEL_IO. 

The pacKage LOW_L£VEL_IO allows your progra.m to send I/O 
commands to tne 1,0 devices (using SEND_CONTROL) and to receive 
status information fro.m the I/O devices (using RECEIVE_CONTROL) . 

A progra.m is erroneous if it uses LOW_LEVEL_IO to access a device 
that is also accessed by high-level I/O packages sucn as 
SEQUENTIAL_IO and TEXT_IO. The following is excerpted fro.m the 
package L0W_1EVEL_I0. 

-- IO_CHANNEL_RANGE is the type for the parameter DEVICE for 

— both SEND_CONTROL and RECErVE_CONTROL. DEVICE identifies 

-- wnich device to perform the operation for, and tne channel 

— nu.moer is a convenient means for identifying a device. 

SL'BTYRE io_channel_range IS integer RANGE 0..63; 

— Range of values allowed for channel number. 

SUBTYPE buffer_address IS system.physical_address; 

— Type of variables used to.specify 
— address of buffer for the I/O operation. 

SUBTYPE ccmmand_word IS lcng_integer RANGE 0..65535; 

— Data structures used in communication with the AN/USH-26. 

ush26_programs : CONSTANT := 3; 

— Number of channel programs in CHANNEL_IO for 
— AN/USH-26 devices. 

SUBTYPE ush26_operation IS integer 

RAN^'-E 0 . . Iow_level_io.ush26_programs ; 

— Indicates to CHANNEL_IO which channel program to use. 

U3h26_reset_channel : CONSTANT ush26_operation ; 

ush26_read_data : CONSTANT ush26_operation : 

ush26_write_data : CONSTANT ush26_operation ; 

ush26 control : CONSTANT ush26_operation : 



E.11.7 Low Level Input/Output 


F- 3 9 









ersion 3.5 
9 March 1991 


Ada/M ?SE Handboc< 


TYPE ushZF^data IS RECORD 

-- Data passed to SEND_CONTROL for operations on 
— AN/USH-26 devices. 

operation : low_level_io.ush26_operation; 

-- -Kind of operation requested of LGW_LEVEL_IO: 

-- read data, write data, control, or initialize, 
command : lGw_level_io.command_word; 

-- Command to send to the device. 
data_length : integer range 0..integer'last; 

-- Numoer of words of data in the buffer. 
buffer_addr : lcw_level_io.buffer_address; 

-- Physical address of data buffer. 

END RECORD;' 

- Data structures used in communication with the AN/USQ-69. 

usq6 9_programs : CONST.ANT := 4; 

— Numoer of channel programs in CHANNEL_IO for 
— AN/’JSQ-6 9 devices. 

SUBTYPE 'Usq69_operation IS integer 

RANGE 0. . low_levei_io. usq6 9_prcgra.ms ; 

— Indicates to CKANNEL_IO which channel program to use. 

usq69_reset_char.nel : CONST.ANT usq69_operation := 0; 

usq69_header : CONSTANT usq69_operation := 1; 

jsq69_read_data : CONSTANT usq69_operation := 2; 

usq69_write_data : CONSTANT usq69_operation := 3; 

usq69_eoc : CONSTANT usq69_operation := 4; 

TYPE asq69_data IS RECORD 

— Information needed to do I/O to a AN/USQ-69 device, 
operation : low_Ievel_io.usq69 operation; 

— Kind of operation requested of LOW_LEVEL_IO; 

— read data, write data, control, or initialize, 
command : low_level_io.conunand_word; 

— Command to send to the device. 
data_length : integer range 0..integer'last; 

— Number of words of data in the buffer. 
buffer_addr : low level_io.buffer address; 

— Physical address of data buFfer. 

END RECORD; 

rd358_prograras : CONSTANT := 3; 

— Number of channel programs in CHANNEL_IO for 
-- RD-358 devices. 

SUBTYPE rd358_operation IS integer 

RANGE 0 ..low_level_io.rd358_programs; 

— Indicates to CHANNEL 10 '^ich channel program to use. 


-40 


F.11.7 Low Level Input/Output 








Ada/M PSE Har.dboQK 


Version 3 . 
29 Maron 199 


rdSSSTreset channel 

CONSTANT 

rd358 

_operation 

:= 0; 

rd358_read data 

CONSTANT 

rd358 

_cperation 

: = 1; 

rd3 58_write_daca 

CONSTANT 

rd358 

_operation 

:= 2; 

rd3 58_cont rol 

CONSTANT 

rd358 

_operation 

: = 3; 


TYPE rd2 53_dat;a IS RECORD 

-- Information needed to do I/O to an RD-358 device, 
operation : lcw_levei_io.rd358_operation; 

-- Kind of operation requested of L0W_LEVE1_I0: 

— read data, write data, control, or initialization 
command : low_level_io.command_word; 

— Command to send to the device. 
data_Iength ; integer range 0..integer'last; 

-- Number of words of data in the buffer. 
buffer_addr : low_level_io.buffer_address; 

-- Physical address of data buffer. 

END RECORD; 

— Types used for intercomputer I/O operations. 

ic_pcograms : CONSTANT := 10; 

— Numoer of cnannel programs in CHANNEL_IO for 
-- AN/CSH-26 devices. 


SUBTYPE intercomputer_operation IS integer 
RANGE 0..low_level_io.ic_programs; 

— Indicates to CHANNEL_IO which channel program to use. 


ic_reset_channel 
ic_read_data 
LC_write_data 
ic control 


CONSTANT intercomputer_operation 
CONSTANT intercomputer_operation 
CONSTANT intercomputer~operation 
CONSTANT intercomputer_operation 


0 ; 


TYPE intercomputer_data IS RECORD 

— Information needed to do I/O to an intercomputer 

— channel. 

operation ; low_level_io.intercomputer_operation; 

— Kind of operation requested of LOW_LEVEL_IO; 

— read data, write data, control, or initialization 
command : low_level_io.command_word; 

— Command to send to the other computer. 
data_length : integer range 0..integer'last; 

— Number of words of data in the buffer. 
buffer_addr : low level_io.buffer address; 

— Physical address of data buFfer. 

END RECORD; 


F.11.7 Low Level Input/Output 


F- 4 


Ui tsj » 










Ada/M ?SE Har.dbccK 


’/ersion 3.5 
29 March 1991 


— Data type-identifiers for RECE:ve_CONTROL . 

TYPE io_status_word IS NEW Long_integer RANGE 0..65535; 

-- Ysed to pass I/O status word to RECSiyE_CONTROL. 

S'JBTYPE exrernal_interrupt_word IS 

sysrem. exrernai_int:er rupr_word : 

-- SEND_CCNTROL is an overloaded Ada procedure which passes I/O 
-- control information to a procedure in CHANNEL_IO in order to 
-- carry out a read, write, or control operation. In Ada/M, 

-- there are four overloaded subprograms for SEND_CONTROL, one 
-- for each of the following purposes : 

send data/command to an AN/USH-26 device, 
send data/command to an AN/USQ-69 device, 
send data/command to an RD-353 device, 
send data/command to another computer. 

— The following versions of the overloaded procedure 

-- SEND_CONTROL are used for sending data to specif:c tyoes of 
-- devices. The difference between t.he various forms of this 
-- procedure lies in the DATA parameter, which is a record with 
-- a field that specifies the control command to send to the 

— device. The data type of this field is different for each 

— type of device. 

-- S£ND_CONTROL for AN/USH-26 devices. 

PROCEDURE SEND_CONTP.OL ( 

device : IN low_level_io.io_channel_range; 

— Channel number of the peripheral device, 
data : IN OUT low_level_io.ush26_data 

— I/O control information for AN/USH-26 devices. 


-- SEND_CONTROL for AN/USQ-69 devices. 

PROCEDURE SEND_CONTROL ( 

device : IN low_level_io.io_channel_range; 

— Channel number of the peripheial device, 
data : IN OUT low_level_io.usq69_data 

' I/O control information for AN/USQ-69 devices. 

) ; 


-- SEND_CONTROL for RD-358 devices. 

PROCEDURE SEND_CONTROL ( 

device : IN low_level_io.io_channel_range; 

— Channel number of the peripheral device, 
data : IN OUT low_level_io.rd358_data 

-- I/O control information for AN/USQ-69 devices 


F-4 2 


F.il.7 Low Level Input/Output 






Ada/M PSE HandbooK, 


Version 3.5 
29 .Marc.n 1991 


— SfiNDj^CONTROL for Interccmpucer cha.nnel. 

PROCEDURE SEND_CONTROL ( 

device : IM low_level_io.io_channel_range; 

-- Channel number of the peripheral device, 
data : IN OUT low_level_ic.intercompucer_data 

— I/O control information for AN/USQ-69 devices. 


-- RECEIVE_CONTROL is a procedure which passes I/O control 
-- information to a procedure in CHANNED_IO in order to ootain 
-- the value for the input transfer count for the specified 
-- channel. 

PROCEDURE RECEIVE_CONTROL ( 

device : IN low_level_io.io_channel_ranqe; 

-- Device type for which status is requested, 
data : IN OUT low_level_io.io_status_word 

-- External interrupt word for channel soecified. 

) ; 

-- RECEIVE_CONTROL for getting the external interrupt data 

-- for the soecified channel. 

PROCEDURE RECEIVE_CONTROL ( 

device : IN low_level_io.io_channel_range; 

— Channel number of the peripneral device, 
data : IN OUT 1 ow_level_io. exter'.'’.al_inter rupt_word 
— Incut count for channel soecified. 

); 

— RECEIVE_CONTROL for getting input transfer count. 

PROCEDURE RECEIVE_CONTROL ( 

device : IN low_level_io.io_channel_range; 

— Channel number of the peripheral device, 
data : IN OUT integer 

— Input count for channel specified. 

) ; 


P.12 System-Defined Exceptions 

In addition to the exceptions defined in the Ada Language 
Reference Manual, this i.mplementation pre-defines the exceptions 
shown in Table F-2 below. 


E.12 System-Defined Exceptions 


F-43 






Version 3.5 
29 Marcn 1991 


Ada/M ?SE Handbook 


Name 

Significance 

ca?ac;ty_errcr 

Raised by the Run-Time Executive when 
Pre-Runcime specified resource limits 
are exceeded. 

SYSTEM ERROR 

Serious error detected in underlying 
.AN/UYK-44 or AN/AYK-14 operating 
system. 

i i:nresolved_referencs 

i 

Attempted call to a subprogram whose 
body is not linked into the executable 
program image. 

ACCESS_CH£CK 

i 

The ACCESS_CHECK exception has been 
raised explicitly within the program. 

OISCRIMINANT_CHECK 

DISCRIMINANT_CHECK exception has been 
raised explicitly within the program. 

orv:s:oN_CHECK 

The DIVISION_CHECK exception has been 
raised explicitly within the program. 

; elaborat:on_checx 

i 

! 

The ELABORATION_CHECK exception has 
been raised explicitly within the 
program. 

1 INDEX_CHECK 

1 

The INDEX_CHECK exception has been i 

raised explicitly within the program. 

j 1ENGTH_CHECK 

The LENGTH_CHECK exception has been j 

raised explicitly within the program. j 

I 

1 OVERFLOW_CHECX 

1 

The OVERFLOW_CHECK exception has been 
raised explicitly within the program. 

RANGE_CHECK 

The RANGE_CHECK exception has been 
raised explicitly within the program. 


Table F-2 - System Defined Exceptions 


E-44 


F.12 System-Defined Exceptions 











Ada/M ?SE Handbook 


Version 2. 
29 Maron 199 


F.13 Machine Code Insertions 

The Ada language pernrics machine code insertions as defined 
in Section 13.3 of the Ada Language Reference Manual. This 
section describes the specific details for writing machine code 
insertions as provided oy the predefined pacKage MJ\CHIN'E_COD£. 

Tcu may, if desired, include AN/UYK-44 or A.N/AYK-14 
instructions within an Ada program. This is done by including a 
procedure in the program which contains only record aggregates 
defining machine instructions. The package MACHINE_CODE, 
included in the system program library, contains type, record, 
and constant declarations which are used to form the 
instructions. Each field of the aggregate contains a field of 
tne resulting machine instruction. These fields are specified i 
the order in which they appear in the actual instruction. 

A procedure containing machine-code insertions looks similar 
to tnis : 


with machine_code; use machine_code; 
procedure macnine_sampies is 
begin 

instr'(OPCODE,A,M,Y); — first instruction 
instr'(OPCODE,A,M,Y); — second instruction 

instr'(OPCODE,A,M,Y); — last instruction 
end ; 

OPCODE, A, M, and Y in all these examples are replaced by the 
actual opcode, A register, M register, and Y field desired for 
each AN/UYK-44 or AN/AYK-14 instruction. Whenever possible, 
MACHO/M mnemonics are used to specify the opcode field. The .A 
and M register fields are specified as RO, Rl, ... R15. The Y 

field may be specified by any static expression which will fir i 
a 16-bit integer. For certain instructions such as unary 
arithmetic operations, the opcode and either the A or M register 
determine which instruction is executed. The specification of 
these instructions and certain others is somewhat more 
complicated and is explained in detail below. Here are some 
examples of possible MACRO/M instructions and the Ada/M record 
aggregates that correspond to them; 


.MACRO/M 

Ada/M 

spt A,Y,M 

instr'(spt,A,M,Y) ; 

Ir A,M 

instr’(Ir,A,M); 

1 A,Y,M 

instr'(1,A,M,Y); 

mi A,M 

instr'(mi,A,M) ; 

o r k A, Y, M 

instr'(ork,A,M,Y); 


F.13 Machine Code Insertions 


F-4 







Version 3.5 
29 March 1991 


Ada/M ?SE l-iandDccK 


In some cases, A or M register fields do not appear in 
MACRO/M instruction because the field is always zero in the 
macnine instruction. RO must be used in that field of the 
aggregate in Ada/M, however, since no missing fields are al 
Here are some exa.mples where that occurs: 


SCO 

ewe 


MACRO/M 


Ada/M 


Ipi M 
Ip Y,M 
sfsc M 


instr'(Ipi,rO,M); 
instr'(Ip,rO,M,Y) ; 
instr'(sfsc,rO,M); 


Some MACRO/M mnemonics are ambiguous and are assembled into 
one of two or more opcodes based on the operands specified in tne 
instruction. Ada/M opcode mne.monics must be unambiguous, so 
either the letter K (indicating an RK format instruction) or the 
letter X (indicating an RX format instruction) has been added to 
the end of otherwise ambiguous mnemonics. Some examples of this 
are as follows: 

MACRO/M Ada/M 


jz A,Y,M instr’( jz)</A,M,Y) ; 

jpA,*Y,M instr'(jpx,A,M,Y); 


For those MACRO/M mnemonics which determine both the opcode 
and either the A or M register, the MACRO/M mnemonic 
(disambiguated as above if necessary) is used for the A or M 
field and an opcode mnemonic is invented. Some examples of this 
are as follows: 

MACRO/M Ada/M 


pr A 
drtr A 
sqr A 

jrie Y,M 
her 


instr'(ua_opcode,A,pr); 
instr'(ua_opcode,A,drtr); 
instr'(us_opcode,A,sqr); 
instr'{cjk_opcode,jnek,M,Y); 
instr'(ec_opcode,he r,r 0) ; 


F-46 


F.i3 Machine Code Insertions 












Ada/M ?SE nandbccK 


Ve r 3 icr. 2.5 
29 Marc.". 1991 


You must be able to ir.ciude aata as well as instructions in 
mac.nine code. The MACHINE_CODE pa-xage defines record types 
wnich allow you to create indirect words, signed bytes, unsigned 


bytes, words, double words, and 
format for including data is as 

Data 


indirect word (iw J,Y,X) 
unsigned byte (0 .. 255) 
word (15-0it value) 
double word (32-bit value) 
float value {32-bit value) 


bloating point nu.iiDers. The 
follows: 

Ada/.M 


indirect_word'(J,X,Y); 
unsigned_byte_value'(7ALTE); 
word_value'(VALUE); 
doubie_word_value’(VALUE); 
float value'(VALUE); 


Table ?-3 contains a list of .MACRO/M instructitns and their 
Ada/.M machine code equivalents, sorted by .MACRO/M mnemonic. 


F. 13 


Machine Code Insertions 


F-47 





Version 3.5 
29 Marc.^i 1991 


Ada/M ?SE Har.dbccK 


MACRO/M 


Ada M 


a A , T , M 


instr ’ 

(a,A,M,Y); 

a CCS A 


instr ' 

{.tf opcode, A, acos ) ; 

acr M. 


instr' 

( 1oa r,r 0 , M ) ; 

ad A,:,M 


instr ' 

{ ad,A,M,Y) ; 

adi A,M 


instr ' 

(adi,A,M) ; 

adr A,M 


instr ' 

(adr,A,M); 

ai A,M 


instr ' 

(ai,A,M) ; 

a K A , Y , M 


instr’ 

( ak,A,M, {) ; 

aid A,Y,M 


instr ' 

(ald,A,M,Y) ; 

a 1 d r A, M 


instr ' 

( aldr,A,M); 

alcg A 


instr ' 

(mf opcode,A,alog); 

! a 13 A, Y , M 


instr ■ 

(als,A,M,Y); 

1 alsr A,M 


instr ' 

(alsr,A,M); 

and A,Y,M 


instr' 

(and,A,M,Y) ; 

! andi A,M 


instr ’ 

(andi,A,M); 

: andk A,Y,M 


instr ‘ 

(andk,A,M,Y); 

andr A,M 


instr ' 

(andr,A,M); 

ar A,M 


instr' 

( a r , A, M) ; 

ard A,Y,M 


instr ' 

(ard,A,M,Y) ; 

ardr A,M 


instr ' 

( ardr,A,M); 

3 r s A ^ 1 / M 


instr ' 

( a r s , A, M, Y ) ; 

a r s r A, M 


instr ' 

( a r s r , A, M) ; 

asm A 


instr ' 

(nif_opcode,A,asin) ; 

atan A 


instr ' 

(.Tif ODCcde,A,atan) r 

! ba A,Y,M 


instr' 

(ba,A,M,Y); 

be A,Y , M 


instr' 

(bc,A,M,Y); j 

I bci A,M 


instr' 

( bci , A . M '/ ; i 

! bex A,Y,.M 


instr' 

(bcx,A,M,Y); 1 

bexi A,M 


instr ' 

{ bexi,A,M) ; j 

i bf 'Y,M 


instr ' 

(bf,rO,M,Y); 

j b f i M 


instr ' 

{ bfi,rO,M) ; ! 

bl A,Y,M 


instr' 

(bl,A,M,Y); 1 

bli A,M 


instr' 

(bii,A,M); 1 

dIx A,Y,M 


instr' 

(blx,A,M,Y) ; 

blxi A,M 


instr ' 

{blXx,A,M) ; 

bs A,Y,M 


instr * 

(bSfArMf.^) ; 

bsi A,M 


instr ' 

(bsi,A,M) ; 

bsu A,Y,M 


instr ' 

(bsu,A,M,Y); ! 

bsx A,Y,M 


instr ' 

(bsx,A,M,Y); ! 

bsxi A,M 


instr ' 

{ bsxi,A,M) ; 

built-in test 

- dec 

instr ' 

(bit opcode,dec) ; i 

1 built-in test 

- eec 

instr ' 

( bit_opcode,eec) ; 


Table F-3a - Machine Code Instructions 


F-48 


13 Machine Code Insertions 









Ada. 


?SZ HandbcOfC 


7e r s icp. 
29 Marcn : 


j 0 

991 


! SiACRO/M 



Ada/ M 


1 built-in test 

- 

icp 

instr 

' (011 cDcode,ICO); 

built-in test 

- 

ids 

instr 

’(bit opcode,ids): 

built-in test 

- 

imp 

instr 

'(bit opcode,imp); 

bui1t-in test 

- 

1 rm 

instr 

' (bit opcode,1rm); 

oui1t-in test 

- 

r scs 

i n s c r 

' (bit ODcode,rscs); 

built-in test 

- 

sel 

instr 

' (bit opcode,sel); 

built-in test 

- 

srm 

instr 

'(bit ODcode , s rmi) ; 

C A , Y , M 



instr 

' (c,A,M,Y); 

cbr A,M 



instr 

' (cbr,A,M) ; 

ccr A,M 



instr 

' (loar,A,M); 

cd A,Y.M 



instr 

’ (cd,A,M,Y) ; 

cdi A,M 



ins’' r 

' (cdi,A,M) ; 

1 cdr A,M 



instr 

’ (cdr,A,M) ; 

c i A, M 



instr 

’ (ci,A,M) ; 

c< A,Y,M 



instr 

’ (ck,A,M,Y); 

cl A,Y,M 



instr 

' (cl,A,M,Y) ; 

1 cld A,Y,M 



instr 

’ (cld,A,M,Y) ; 

cldr A,M 



instr 

' (cldr,A,M); 

C1 i A, M 



ini tr 

’ (cli,A,M); 

ci:< A,Y,M 



instr 

' (ci:<,A,M,Y) ; 

c 1 r A, M 



instr 

’ (Clr,A,M) ; 

els A,Y,M 



instr 

’ (cls,A,M,Y) ; 

c 13 r A, M 



instr 

' (clsr,A,M); 

1 cm A,Y,M 



instr 

' ;cm,A,M,Y); 

cmi A,M 



instr 

’ (cmi,A,M); 

i cmk A,Y,M 



instr 

’ (cmk,A,M,Y); 

cmr A,M 



instr 

' ( cmr,A,M) ; 

i ent A 



instr 

’(us opcode,A,cnt) ; 

cos A 



instr 

’ (raf opcode,A,cos ); 

c r A, M 



instr 

’ ( cr,A,M); 

d A,Y,M 



instr 

’ (d,A,M,Y); 

data - double 

word 

double word value'(VALUE); 

data - float 



float 

value’(VALUE) ; 

! data - signed 

byte 

signed byte value '( VALUE ); 

data - unsigned 

byte 

unsigned byte value ' (VALUE) ; 

data - word 



word 

w^alue ’ (VALUE) ; 

dci r 



instr’(uc opcode,rO,dcir ); 

dcr 



instr 

’(uc opcode,rO,dcr ); 

dd A,Y,M 



instr ' {dd,A,i'i, Y) ; 

ddi A,M 



instr 

' (ddi,A,M) ; 

ddr A,M 



instr 

’ (ddr,A,M) ; 

d i A, M 



instr 

■(di,A,M); 

dk A,Y,M 



instr 

’(dk,A,M,Y); 


Table F-3b - Machine Code Instructions (Continued) 


F.i3 Machine Code Insertions 


F-4 9 










Vers-cr. 3.5 
29 Marcn 1991 


Ada/M ?SE HandbccK 


.MACRO/M Ada/M 


' dm 

instr' 

(uc ODCode,r9,dm); 



dr A, M 

' S C ^ * 

(dr,A,M); 



d r 0 r A 

instr' 

( ua opcode A, dror ) ; 



drtr A 

instr' 

( ua opcode,A,dr 0 r ) ; 



eci r 

instr' 

(uc opcode,rO,ecir 

; 


ecr 

instr' 

(uc opcode,rO,ecr); 



i er A 

instr' 

(uc ODCode,A,er); 



exD A 

instr' 

(mf oDcode,A,exo); 



; fa A,Y,M 

instr' 

(fa,A,M,Y); 



fai A,M 

instr' 

(fai,A,M); 



' far A,M 

instr' 

(far,A,M); 



i fc A,Y 

instr' 

(mp opcode,A,fc); 
word value'(Y): 



, fd A,i,M 

instr ' 

( fd,A,M,Y) ; 



; fdi A,M 

instr ' 

( fdi,A,M) ; 



: fdr A,M 

instr ' 

( fdr,A,M) ; 


i 

1 flc A 

instr ■ 

(mp opcode,A,fIc ) ; 


i 

fled A 

instr ' 

(mo opcode,A,fled ) , 


l 

fm A,Y,M 

instr ' 

( fm,A,M,Y) ; 


; 

f m i A, M 

instr ’ 

( fmi,A,M) ; 


' 

fmr A,M 

instr ’ 

( fmr,A,M) ; 



fsu A,Y,M 

instr ' 

( fsu,A,M,Y) ; 



f s u 1 A , M 

instr ' 

( fsui,A,M) ; 



fsur A,M 

instr ' 

( f sur,A,M) ; 


i 

fxc A 

instr ' 

(mp opcode,A,fxc ) ; 



fxed A 

instr ’ 

(mp opcode,A,fxed) ; 



ib A 

instr ' 

( us opcode,A,ib ); 



ick A,Y 

instr ' 

(e6 opcode,A,ick , Y 

; 


ioc A,Y,M 

instr ' 

( iocr,A,M) ; 



! 


word value '( Y ); 



iocr 

instr ’ 

( iocr,rO,rO ) ; 



iror A 

instr ' 

( ua opcode, A, iror ) , 



1 irtr A 

instr ' 

( ua opcode,A,irtr ) 



13 A 

instr ’ 

( us opcode,A,is ) ; 



iw Y,Y,X 

indirect word '(J » X ,Y ); 



1 ] *'^-M 

instr ' 

( c]x opcode,jx,M) ; 



j ] 

instr ' 

(cjk opcode,jk,M) ; 



: jb *Y,M 

instr ' 

(cjx opcode,jbx,M) 



i ] D Y , M 

instr ' 

(cjk opcode,jbk,M) 



jbr M 

instr' 

( cjr opcode,jbr,M) 


; 

i :c *Y,M 

instr ' 

(cjx opcode,jcx,M) 



' :c Y,M 

instr' 

(cjk opcode,jck,M) 


1 

: c r M 

instr' 

(cjr opcode,jer,M) 



:e *Y,M 

1 nst r ' 

(cjx opcode,jex,M) 


j 

:e Y,M 

instr ' 

(cjk opcode,jek,M) 


1 

- 


Taole F-3c - Machine Code Instructions (Continued) 


F-50 


3 Machine Code Insertions 













Ada/M ?SE riar.dbooK 


Vers. or. 2 
2 9 Marcr. 19 


MACRO/M 

Ada/M 



jer M 

i n s t r ' 

(cjr opcode, 

2 er ,M) ; 

2 q e * / , M 

instr' 

(C 2 /C opcode. 

2 ge;<,M) ; 

:qe Y,M 

i n s t r ' 

(ciK opcode. 

2 ge.< ,M) ; 

' G e r M 

instr' 

(C 2 r opcode, 

2 ger,M) ; 

:<3 1,*Y,M 

instr ' 

(C2:< opcode. 

2 k s X1, M) 

:k3 

instr' 

(C2< ODCode, 

2 .< s X1, M) 

'.<3 2,*Y,M 

instr' 

(C2X ODCode, 

2 k s X 2 , M ) 

:<3 2,Y,M 

instr' 

(cjk opcode. 

2 k 3 < 2 , M 1 

:K3r I,M 

instr' 

(C 2 r opcode. 

2 k 3 r 1, M ) 

: i< 3 r 2 , M 

instr' 

(C2r ODCode, 

2 k 3 r 2 , M ) 

::.t *Y,M 

instr' 

( 2 i-ttx , r 0 , M, Y 

) ; 

:i.Ti Y,M 

instr' 

;jImk,rO,M,Y 

); 

jlr A,*Y,M 

instr' 

(jlrx,A,M,Y) 

; 

:lr A,Y,M 

instr' 

(jirk,A,M,Y) 

; 

;:rr A,M 

instr’ 

( -i 1 r r , A, M) ; 


:i3 *Y,M 

instr' 

(C2X ODCOde, 

jlsx,M); 

'Is Y,M 

instr' 

(cj'x opcode. 

2lsx,M); 

;l3r M 

instr' 

(c'r opcode. 

:l3r,M) ; 

-n A,*Y ,M 

instr ' 

{ 2 c.x , A, M , Y ) ; 


:n A,Y,M 

instr ' 

( 2nk,A,M,Y) ; 


2ne *Y,M 

instr' 

(cjx opcode, 

2 nex,M); 

:ne i . M 

i n s t ^ ' 

(C2k ODCode, 

2ne<,M); 

2ner M 

instr ' 

(cjr opcode, 

jner,M); 

:nr A,M 

instr' 

( j n r , A, M) ; 


jnz A,*Y,M 

instr ' 

(]n 2 x,A,M,Y) 

/ 

jnz A,Y,M 

instr' 

(jn 2 k,A,M,Y) 

? 

2 n 2 r A, M 

instr' 

(jnzr,A,M); 


20 *Y,M 

instr' 

(cjx opcode, 

jox,M) ; 

20 Y,M 

instr' 

(cjk opcode, 

jok ,M) ; 

2 or M 

instr' 

(cjr opcode. 

j o r , M) ; 

2P A,*Y,M 

instr ' 

(jpx,A,M,Y); 


jo A,Y,M 

instr' 

(jpk,A,M,Y); 


^pr A,M 

instr' 

(jpr,A,M); 


2pt *Y,M 

instr' 

(cjx opcode. 

jptx,M); 

]pt Y,M 

instr ' 

(cjk opcode. 

jptk,M); 

jptr M 

instr' 

(cjr opcode. 

jptr,M); 

2r M 

instr ’ 

(cjr opcode. 

j r , M) ; 

js ♦Y^M 

instr' 

(cjx opcode. 

jsx,M) ; 

js Y,M 

instr' 

(cjk opcode. 

jsk,M) ; 

jsr M 

instr' 

(cjr opcode. 

2 s ^); 

22 A,*Y,M 

instr' 

(jzx,A,M,Y); 


22 A,Y,M 

instr' 

( jz)<,A,M,Y) ; 


2 2r A,M 

instr' 

(jzr,A,M); 



Table r-3d - Machine Code Instructions (Continued) 


F.13 Machine Code Insertions 

















Version 3.5 
29 March 1991 


Ada/M ?SS 


Har.dbcGK 


MACHO/M 

Ada/M 



1 A,Y,M 

instr' 

( 1, A, M, Y ) ; 


la A,M 

instr■ 

(la,A,M); 


lad A,M 

ir.str ■ 

(lad,A,M); 


laid A,M 

instr' 

(laid,A,M); 


lals A,M 

instr ' 

(lals,A,M); 


lard A,M 

instr ' 

{lard,A,M); 


lari A,M 

instr ' 

{lar 1 ,A,M); 


larm A,Y,M 

instr ‘ 

(larm,A,M,Y); 


larr A,M 

instr' 

(larr,A,M); 


lars A,M 

instr ' 

(lars,A,M); 


Ibxi A,Y,M 

instr ' 

(loxi,A,M,Y); 


Ic A,M 

' n s ^ * 

(Ic,A,M); 


Icep A 

instr' 

(us encode,A,Iceo); 


1 c 1 c A, M 

instr' 

(lclc,A,M); 


1 c 1 d A, M 

instr' 

(Iclc,A,M); 

i 

1 

Icr A 

instr' 

( uc opcode,A,Icr ); 


lord A 

instr ' 

( uc encode,A,Icrd ); 


Id A,Y,M 

instr • 

( ld,A,Y,M); 


Idi A,M 

instr ' 

(Idi,A,M): 


1 d i V A, M 

instr' 

(Idiv,A,M) ; 


Idx A,Y,M 

instr ■ 

( ldx,A,M,Y) ; 


Idxi A,M 

instr ' 

( Idxi,A,M) ; 


lem A 

instr ' 

(uc opcode,A,lem) ; 


li A,M 

instr ' 

( j. i , A , M ) ; 

; 

lir A,M 

instr ' 

( lir,A,M) ; 


Ij D 

instr ’ 

(1 j . D ) ; 

: 

Ije D 

instr ’ 

( lje,D) ; 

i 

Ijge D 

instr ' 

( l]ge,D) ; 

; 

l]i □ 

instr ' 

( 1 j i , D ) ; 


1 j Im D 

instr ' 

( 1jlm,D) ; 


lils D 

instr ' 

( 1jls,D) ; 


Ijne D 

instr' 

( 1jne,D) ; 


lx A,Y,M 

instr ' 

(lk,A,M,Y) ; 


11 A,M 

instr' 

{ 11,A,M); 


llrd A,M 

instr' 

( llrd,A,M); 


Hr 3 A,M 

instr ■ 

( ilrs,A,M) ; 


Im A,Y,M 

instr' 

( lm,A,M,Y) ; 

1 

Imap A,Y,M 

instr ’ 

( l.map, A, M , Y ) ; 


Imr A,Y,M 

instr ' 

; Imr,A,M,Y) ; 

1 

Imul A,M 

instr ' 

( Imul,A,M) ; 


Ip Y,M 

instr ' 

( Ip,rO,M,Y) ; 


Ipa A,Y,M 

i.nstr ' 

( lpa,A,M,Y) ; 


1 pa i A,M 

instr ' 

( Ipai,A,M) ; 



Table F-3e - Machine Code Instructions (Continued) 


F-52 


F.13 Machine Code Insertions 










Ada/M PSE HandbooK 


Version 3. 
2 3 Marcr. 159 


1 MACRO/M 

Ada/M 


Ipal< A,Y,M 

instr' 

{Ipak,A,M,Y); 

Ipar A,M 

instr' 

(Ipar,A,M); 

Ipi M 

i n s n r ' 

( 1 o 1 , r 0 , M) ; 

Ipl A,V,M 

instr' 

(lpl,A,M,Y); 

' Ipli ;i,M 

instr' 

{Ipli,A,M); 

1 1D r A 

instr' 

{uc CDcode,A,Icr) ; 

1 Ir A,M 

instr' 

( 1 r , A, M) ; 

Ird A,Y,M 

instr ' 

{ lrd,A,M,Y) ; 

Irdr A,M 

instr' 

{ Irdr,A,M); 

Irs A,i,M 

instr' 

(lr3,A,M,Y); 

Irsr A,M 

instr' 

(Irsr,A,M); 

isor A 

instr 

(uc opcode,A,Iscr); 

Ist:r A 

instr' 

( uc opcode,A,Istr); 

Isu A,M 

instr' 

( lsu,A,M); 

Isud A,M 

instr' 

(Isud,A,M); 

1 lx A,Y,M 

instr' 

(lx,A,M,Y); 

1 Ixi A,M 

instr' 

{Ixi,A,M); 

i m A, Y , M 

instr' 

(m,A,M,Y); 

mb A,M 

instr’ 

(mb,A,M); 

md i A, M 

instr' 

(mdi,A,M) ; 

mdm A,Y,M 

instr' 

( mdm,A,M,Y ) ; 

md r A, M 

instr' 

(md r,A,M) ; 

1 mi A,M 

instr' 

(mi,A,M); 

mk A,Y,M 

instr' 

(mk,A,M,Y); 

mr A,M 

instr' 

(mr,A,M); 

ms A,Y,M 

instr' 

( ms,A,M,Y ) ; 

msi A,M 

instr' 

(msi,A,M); 

ms k A,Y, M 

instr' 

(msk,A,M,Y); 

ms r A, M 

instr' 

( ms r , A, M) ; 

nf A 

instr' 

(mp opcode,A,n f); 

nr A 

instr’ 

{ ua opcode,A,nr) ; 

ock A,Y 

instr' 

(e6 opcode,A,ock,Y); 

ocr A 

instr’ 

( ua opcode,A,ocr) ; 

or A,Y,M 

instr' 

( 0 r , A, M, Y) ; 

ori A,M 

instr' 

( o r i , A, M) ; 

ork A,Y,M 

instr’ 

(ork,A,M,Y): 

orr A,M 

instr' 

(orr,A,M); 

pr A 

instr' 

(ua opcode,A,pr); 

qal A,Y 

instr' 

(mp_opcode,A,qal ); 
word value'(Y); 

qa r A, Y 

instr' 

(mp_opcode,A,qa r); 
word value'(Y) ; 

qgt A,Y,M 

instr' 

(qgt,A,M,Y); 

qpb A,Y,M 

instr' 

(qpb,A,M,Y); 


Table F-3f - Machine Code Instructions (Continued) 


F. 13 


r - :3 


Machine Code Insertions 









Version 3.5 
29 March 1991 


Ada/M ?SE HandbccK 


1 

MACRO/M 

Ada/M 


qpt A,'£,M 

instr'(qpt,A,M, Y) ; 


rex Y,M 

instr' ( rex,rO,M,Y) ; 


rf A 

instr '(■T’P opcode,A, rf ) ; 


rfo A 

instr' (^P opcode,A,rfp) ; 


r h A 

instr’(mp opcode , A,rh ); 


rhp A 

instr (mp opcode,A,rhp); 


rim A,Y,M 

instr'(smap,A,M,Y;; 


rr A 

instr'(ua opcode,A, r r) ; 


rvr A 

instr'(us opcode , A , rvr ); 


3 A,Y,M 

instr' (s,A,.M,Y) ; 


sari A,M 

instr '( sari,A,M) ; 


sarm A,Y,M 

instr '( sarm,A,M,Y) ; 

1 

sarr A,M 

instr' ( sarr , A,M) ; 

' 

3 b r A , M 

instr '( sbr,A,M) ; I 

' 

sbxi A,Y,M 

instr '( sbxi , A,M,Y) ; | 


scr A 

instr'(uc opcode , A , scr ); I 

i 

3 c r d A 

instr’(uc opcode,A,scrd) ; | 


sd A,Y,M 

instr '( sd,A,M,Y) ; ' 


3di A,M 

instr '( sdi,A,M) ; 1 


3dx i Y.M 

instr '( sdx,A,M,Y ); 


3dxi A,M 

instr ’( sdxi,A,M); 


sedr A,M 

instr '{ sedr,A,M); 


3 e r A, M 

instr ’( ser,A,M)r 


sfr A 

instr'(us opcode,A,sfr ) ; 


sgt A,Y,M 

instr '( sgt,A,M,Y) ; 

I 

1 

3i A,M 

instr ’{ si,A,M) ; 


sin A 

instr’ (mf opcode,A,sin ); 

! 

sir A,M 

instr '( sir,A,M) ; 


3m A , Y , M 

instr '( sm,A,M,Y ); 

i 

smap A,Y,M 

instr '( smap,A,M, Y); 


smc A 

instr’(us opcode,A,smc) ; 


smr A,Y,M 

instr ’( smr,A,M, Y); 


3pl A,Y,M 

instr ’( spl,A,M, Y); 

1 

spli A,M 

instr ’( spli,A,M) ; 


SDt A,Y,M 

instr ’( spt,A,M,Y) ; 


sqr A 

instr*(us opcode,A,sqr ); 


sqrt A 

instr’(us opcode,A,sqrt ); 


33or A 

instr’(uc opcode,A,ssor ); 

! 

33tr A 

instr’(uc opcode,A,sstr ); 


3U A,Y,M 

instr ’( su,A,M,Y ); 


3ud A,Y,M 

instr '( sud,A,M,Y) ; j 


3udi A,M 

instr ’( sudi,A,M) ; | 


sudr A,M 

instr '( sudr,A,M) ; ! 


Table F-3g - Machine Code Instructions (Continued) 


54 


Machine Code Insertions 







Ada/M PSE HandbcoK 


Version 3.5 
29 Marcn 1991 


MACRO/M 

Ada/M 


sui A,M 

instr' 

(sui,A,M); 

suk A,Y,M 

instr ' (suk,A,M,Y); 

s u r A, M 

instr' 

(sur,A,M); 

s X A, Y , M 

instr' 

{sx,A,M,Y); 

s X i A, M 

instr' 

(sxi,A,M); 

S2 Y,M 

instr' 

(sz,rO,M,Y); 

szi M 

instr' 

(S 2 i,rO,M); 

tan A 

inscr' 

(mf opcode,A,tan) 

tcdr A 

instr' 

( ua opcode,A,tcdr 

ter A 

instr' 

(ua opcode,A,ter ) 

vf A 

instr' 

{tip oDCode, A, vf ) ; 

vfQ A 

instr' 

(mp opcode,A,vfp) 

vh A 

instr' 

(T.p opcode, A, vh ) ; 

vhp A 

instr' 

(mp_opcode,A,vhp) 

wem A,Y,M 

instr' 

(lmap,A,M,Y); 

wemk AM,Y 

instr' 

{e6 opcode,A,M,Y) 

wim A,Y,M 

instr' 

(lmap,A,M,Y); 

wi.Tik A,Y,M 

instr' 

(e6 opcode,A,M,Y) 

xj A,*Y,M 

instr' 

( X j X , A, M, Y ) ; 

X] A,Y,M 

instr ' 

{ X j k , A, M, Y ) ; 

x]r A,M 

instr'(xjr,A,M); 

xor A,Y,M 

instr' 

(xor,A,M,Y); 

xori A,M 

instr' 

(xori,A,M); 

xork A,Y,M 

instr' 

(xork,A,M,Y); 

xorr A,M 

instr’ 

{xorr,A,M); 

xsdi A,M 

instr’ 

{xsdi,A,M); 

xsi A,M 

instr’ 

(xsi,A,M); 

zbr A,M 

instr’(zbr,A,M); 


Table F-3h - Machine Code Instructions (Continued) 


F.13 Machine Code Insertions 








