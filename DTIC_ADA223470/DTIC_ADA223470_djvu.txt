AD-A223 470 





* 


AV? Control Number; AVF-IA3G-060 



Ada COMPILER 

VALIDATION SUMMARY REPORT: 

Certificate Number: #89120711.10262 
TARTAN LABORATORIES INCORPORATED 
Tartan Ada ULTRIX/68K Version IIvT-2 
MicroVAX 11 to Tektronix 8541 Emulator for 68020 


Completion of On-Site Testing: 
7 December 1989 



Prepared By: 
lABG mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 
Vest Germany 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 


f 




DtSTRigUT TON STATE M EITT K 

Approved for public releases 
DiauiDuuon Uakouted 


^0 06 25 Jff$f 









REPORT DOCUMENTATION PAGE I 



AREPCr 

Final 


l.aaCNCYUBEOHArdMivatoi^ i tlCKMriMTE |.«l>^Tn)C AM) (MTES COVERED 

I? Dec. 90 ro 7 Dec, 91 

cmEANOfUlTiTLE Ada Compiler Validation Summary Report :Tartan 
'oratories Incorporated, Tartan Ada ULTRIX/68K, Version INT-2(Host) 
icroVAX II to Tektronix 8541 Emulator for 68020 (Taraetl 
89120711.10262 

•.Auman(t) " “ " 

lABG-AVF 

Ottobrunn. FEDERAL RSyUBLIC OP GERMANY 


lABG-AVF, Industrieanlagen-Betriebsgeselschaft 
De^t. S2T 

£instetnstrasse 20 

D-8012 Ottobrunn 

federal republic of-GERMANY 


#. aRONECRMQMMnORMa AOENCY NAUEtS) AM>AOQRE»(ES) 

Ada Joint Program Office 

United States Department of Defense 

Washington, "ll.C. 20301-3081 


JCTWRMfgWOANUWXN 

ICRORTMMER 

AVF-IABG-060 


1«. »gl«D«4Q^OMTOR»tt MENCY 
REPORT MAMER 



I2a DBTnaarOMAVAtABUTY ETXTEICNT 

Approved for public release; distribution unlimited. 


tafc. O BT«a i mowoooe 


13 . AUTRACT (M iii n w i iflC e e m l i ) 

Trtan Laboratories Incorporated, Tartan Ada ULTRIX/68K Version INT-2, Ottob“ •*' West 
Germany, MlcroVAX II under ULTRIX V2,2 (Host) to Tektronix 8541 Emulator frr 68020 under 
TekDB V5.04 (Target), ACVC 1.10. 

✓ 


'M.MJECTIfRMB Ada programming language, Ada Compiler Validation 
Summary Report, Ada Compiler Validation (Capability, Validation 
Testing, Ada Validation Office, Ada Validation Facility, ANSI/MIL- 
STD-IsTsa, Ada Joint Program Office _ ■_ 


iS.iaMERCFRMaES 



























t 


Ada Compiler Validation Summary Report: 

Compiler Name: Tartan Ada ULTRIX/68K Version INT-2 
Certificate Number: #89120711.10262 
Host: HicroVAX II under ULTRIX V2.2 

Target: Tektronix 8541 Emulator for 68020 under TekDB V5.04 
Testing completed 7 December 1989 using ACVC 1.10. 


This report has been reviewed and is approved. 



Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 










TABLE OF CONTE2«fTS 

CHAPTER 1 INTRODUCTION . 1 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT . . . . 1 

1.2 USE OF THIS VALIDATION SUMI-fARY REPORT.2 

1.3 REFERENCES.3 

1.4 DEFINITION OF TERMS . 3 

1.5 ACVC TEST CLASSES.4 

CHAPTER 2 CONFIGURATION INFORMATION . 7 

2.1 CONFIGURATION TESTED . 7 

2.2 IMPLEMENTATION CHARACTERISTICS . 8 

CHAPTER 3 TEST INFORMATION.13 

3.1 TEST RESULTS.13 

3.2 SUMMARY OF TEST RESULTS BY CLASS.13 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.14 

3.4 WITHDRAWN TESTS.14 

3.5 INAPPLICABLE TESTS . 14 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . 18 

3.7 ADDITIONAL TESTING INFORMATION 

3.7.1 Prevalidation.19 

3.7.2 Test Method.19 

3.7.3 Test Site .20 

APPENDIX A DECLARATION OF CONFORMANCE 

APPENDIX B APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 


APPENDIX E 


COMPILER AND LINKER OPTIONS 

























CHAPTER 1 


INTRODUCTION 


This Validation Summary Report (VSR^ describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, Ai'fSI/NIL-STD-1315A. 
This report explains all technical terms used within it and thoroughly 
reports the results pX—t-eating this compiler using the Ada Compiler 
Validation Capability* (ACVO^^ An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that is 
not in th e Standard. \ 

Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between implementations. 
The Ada Standard permits some implementation dependencies—for example, the 
maximum length of identifiers or the maximum values of integer types. 
Other differences between compilers result from the characteristics of 
particular operating systems, hardware, or implementation strategies. All 
the dependencies observed during the process of testing this compiler are 
given in this repor t. 


The information in this report is derived from the 
during validation testing. The validation proces 
suite of standardized tests, the ACVC, as inputs to 
evaluating the results. \|The purpose of validating 
of the compiler to the Ada;, Standard by testing that 
implements legal language constructs and that it 
illegal language constructs. The testing also ident 
implementation dependent, but is permitted by 
classes of tests are used. These tests are designed 
compile time, at link time, and during execution. 


test results produced 
s includes submitting a 
an Ada compiler and 
is to ensure conformity 
the compiler properly 
identifies and rejects 
ifies behavior that is 
the Ada Standard. Six 
to perform checks at 


P- J 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 


This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 




INTRODUCTION 


To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by lABG mbH, Abt SZT according to 
procedures established by the Ada Joint Program Office and administered by 
the Ada Validation Organization (AVO). 


1.2 USE OF THIS VALIDATION SUNHARY REPORT 

Consistent with the national laws of the originating country, the AVO may 
make full and free public disclosure of this report. In the United States, 
this is provided in accordance with the ’’Freedom of Information Act" 
(5 U.S.C. #S52) . The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject compiler has no nonconformities 
to the Ada Standard other than those presented. Copies of this report are 
available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 


lABG mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 

Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 





I ? JT F " D iJ C TI Oi'J 


1.3 REFERENCES 

f 

1. Reference Manual for the Ada Programming Language, 
ANSI/MIL-STD-1315A, February 1933 and ISO 3652-1S37. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide, December 1985. 


1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to the 
Ada programming language. 

Ada An Ada Commentary contains all information relevant to the 

Commentary point addressed by a comment on the Ada Standard. These 

comments are given a unique identification number having the 
form Al-ddddd. 

Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

Applicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines. 

AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and technical 
support for Ada validations to ensure consistent practices. 

Compiler A processor for the Ada language. In the context of this 

report, a compiler is any language processor, including 
cross-compilers, translators, and interpreters. 

Failed test An ACVC test for which the compiler generates a result that 

demonstrates nonconformity to the Ada Standard. 


Host 


The computer on which the compiler resides. 



INTRODUCTIOW 


Inapplicable An ACVC test that uses features of the language that a 

test compiler is not required to support or may legitimately 

support in a way other than the one expected by the test. 

Passed test An ACVC test for which a compiler generates the expected 

result. 

Target The computer which executes the code generated by the 

compiler. 

Test A program that checks a compiler's conformity regarding a 

particular feature or a combination of features to the Ada 
Standard. In the context of this report, the term is used to 
designate a single test, which may comprise one or more 
files. 

Withdrawn An ACVC test found to be incorrect and not used to check 

test conformity to the Ada Standard. A test may be incorrect 

because it has an invalid test objective, fails to meet its 
test objective, or contains illegal or erroneous use of the 
language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name identifies 
the class to which it belongs. Class A, C, D, and E tests are executable, 
and special program units are used to report their results during 
execution. Class B tests are expected to produce compilation errors. 
Class L tests are expected to produce errors because of the way in which a 
program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal Ada 
programs with certain language constructs which cannot be verified at run 
time. There are no explicit program components in a Class A test to check 
semantics. For example, a Class A test checks that reserved words of 
another language (other than those already reserved in the Ada language) 
are not treated as reserved words by an Ada compiler. A Class A test is 
passed if no errors are detected at compile time and the program executes 
to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is compiled and 
the resulting compilation listing is examined to verify that every syntax 
or semantic error in the test is detected. A Class B test is passed if 
every illegal construct that it contains is detected by the compiler. 












IIITRODUCTTON 


Class C tests check the run time system to ensure that legal Ada programs 
can be correctly compiled and executed. Each Class C test is self-checking 
and produces a PASSED, FAILED, or HOT APPLICABLE message indicating t'ue 
result when it is executed. 

Class D tests check the compilation and execution capacities of a compiler. 
Since there are no capacity requirements placed on a compiler by the Ada 
Standard for some parameters—for example, the number of identifiers 
permitted in a compilation or the number of units in a library—a compiler 
may refuse to compile a Class D test and still be a conforming compiler. 
Therefore, if a Class D test fails to compile because the capacity of the 
compiler is exceeded, the test is classified as inapplicable. If a Class D 
test compiles successfully, it is self-checking and produces a PASSED or 
FAILED message during execution. 

Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the Ada 
Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is rejected 
by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is attempted. 
A Class L test passes if it is rejected at link time—that is, an attempt 
to execute the main program must generate an error message before any 
declarations in the main program or any units referenced by the main 
program are elaborated. In some cases, an implementation may legitimately 
detect errors d’'’"''ng compiJa*'3on of tt'® <'est. 

Two library units, the package REPORT and the procedure CHECK_FILE, support 
the self-checking features of the executable tests. The package REPORT 
provides the mechanism by which executable tests report PASSED, FAILED; or 
NOT APPLICABLE results. It also provides a set of identity functions used 
to defeat some compiler optimizations allowed by the Ada Standard that 
would circumvent a test objective. The procedure CHECK_FTLE is used to 
check the contents of text files written by some of the Class C tests for 
Chapter 14 of the Ada Standard. The operation of REPORT and CHECE_FILE is 
checked by a set of executable tests. These tests produce messages that 
are examined to verify that the units are operating correctly. If these 
units are not operating correctly, then the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended to 
ensure that the tests are reasonably portable without modification. For 
example, the tests make use of only the basic set of 55 characters, contain 
lines with a maximum length of 72 characters, use small numeric values, and 
tests. However, some tests contain values that require the test to be 






IMTPODUCTTO” 


custoinized according to iiTiplementaticn-specif ic 7alues--for axarnpla, an 
illagal file name. list of the ''alues ns^d for this validation 13 
provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable to 
the implementation. The applicability of a test to an implementation is 
considered each time the implementation is validated. A test that is 
inapplicable for one validation is not necessarily inapplicable for a 
subsequent validation. Any test that was determined to contain an illegal 
language construct or an erroneous language construct is withdrawn from the 
ACVC and, therefore, is not used in testing a compiler. The tests 
withdrawn at the time of this validation are given in Appendix D. 




CONFIGURATION INFORMATION 


CHAPTER 2 

CONFIGURATION INFORMATION 


2.1 CONFIGURATION TESTED 

The candidate compilation system for chis validation was tested under 
following configuration: 


Compiler: Tartan Ada ULTRIa/ 68K Version INT-2 
ACVC Version: 1.10 
Certificate Number: *89120711.10262 
Host Computer: 

Machine: HicroVAX II 

Operating System: ULTRIX V2.2 

Memory Size: 9 ”3 

Target Computer: 

Machine: Tektronix 3541 Emulator for 63020 
Operating System: TekDB V5.04 


th 


Memory Size: 


64 KB + 1 MB 






COMFTGURATION INFORMATION 


2.2 IMPLEMENT.ATION CHARACTERISTICS 

One of the purposes of validating compilers is to determine the behavior of 
a compiler in those areas of the Ada Standard that permit implementations 
to differ. Class D and E tests specifically check for such implementation 
differences. However, tests in other classes also characterize an 
implementation. The tests demonstrate the following characteristics: 


a. Capacities. 

1) The compiler correctly processes a compilation containing 
723 variables in the same declarative part. (See test 
D29002K.) 

2) The compiler correctly processes tests containing loop 

statements nested to 55 levels. (See tests D55A03A..H (3 
tests).) 

3) The compiler correctly processes tests containing block 

statements nested to 65 levels. (See test D560013.) 

4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tests D64005E..G (3 tests).) 


b. Predefined types. 

1) This implementation supports the additional predefined types 
SHORT_INTSGER, BYTE_INTEGER, and L0NG_FL0AT in the package 
STANDARD. (See tests B86001T..Z (7 tests).) 


c. Expression evaluation. 

The order in which expressions are evaluated and the time at which 
constraints are checked are not defined by the language. While 
the ACVC tests do not specifically attempt to determine the order 
of evaluation of expressions, test results indicate the following: 

1) None of the default initialization expressions for record 
components are evaluated before any value is 
checked for membership in a component's subtype. (See test 
C32117A.) 

2) Assignments for subtypes are performed with the same precision 
as the base type. (See test C35712B.) 


CONFIGUR rt TI on INFO R ;■! A T T On 


3) This iraple'-Tientation uses no extra bits for extra precision 
and uses ali extra bits for extra range. (See test C35903A.I 

4) MUMERIC_ERROR is raised for predefined and largest integer and 
no exception is raised for smallest integer when an integer 
literal operand in a comparison or membership test is outside 
the range of the base type. (See test C45232A.) 

5) No exception is raised when a literal operand in a fixed- 
point comparison or membership test is outside the range of 
the base type. (See test C45252A.) 

6) Underflow is gradual. (See tests C45524A..Z (25 

tests).) 


Rounding. 

The method by which values are rounded in type conversions is not 
defined by the language. While the ACVC tests do not specifically 
attempt to determine the method of rounding, the test results 
indicate the following: 

1) The method used for rounding to integer is round to even. 
(See tests C46012A..Z (26 tests).) 

2) The method used for rounding to longest integer is round 
to even. (See tests C46012A..Z (26 tests).) 

3) The method used for rounding to integer in static universal 
real expressions is round to even. (See test C4A014A.) 


Array types. 

An implementation is allowed to raise NUMERIC_ERROR or 
CONSTRAINT_SRROR for an array having a 'LENGTH that exceeds 
STANDARD.INTEGER'LAST and/or SYSTEM.MAX_INT. For this 

implementation: 

1) Declaration of an array type or subtype declaration with more 
than SYSTEM,HAX_rNT components raises NUMERIC_ERROR for 
one dimensional array types, two dimensional array types and 
two dimensional array subtypes, and no exception for one 
dimensional array subtypes. (See test C36003A.) 

2) NUMERIC_ERROR is raised when an array type with 

INTEGER'LAST + 2 components is declared. (See test 

C36202A.) 









CONFIGURATION INFORMATION 


3) NUMERIC_ERROR is raised when an array type vnth 

SYSTEM.MAX_INT + 2 components is declared. (See test 

C36202B.) 

4) A packed BOOLEAN array having a 'LENGTH exceeding INTEGER'LAST 

raises NUMERIC__ERROR when the array type is declared. (See 

test C52103X.) 

5) A packed two-dimensional BOOLEAN array with more than 

INTEGER'LAST components raises NUHERIC_ERROR when the array 

type is declared and exceeds INTEGER'LAST. (See test 

C5*2104Y.) 

6) In assigning one-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

7) In assigning two-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

8) A null array with one dimension of length greater 
than INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAINT_ERROR 
either when declared or assigned. Alternatively, an i.mplemen- 
tation may accept the declaration. However, lengths must 
match in array slice assignments. This implementation raises 
NUHERIC_ERROR when the array type is declared. (See 
test E52103Y.) 


f. Discriminated types. 

1) In assigning record types with discriminants, the expression 
is evaluated in its entirety before CONSTRAINT_ER.ROR is raised 
when checking whether the expression's subtype is compatible 
with the target's subtype. (See test C52013A.) 


g. Aggregates. 

1) In the evaluation of a multi-dimensional aggregate, the test 
results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 

2) In the evaluation of an aggregate containing subaggregates, 

not all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 

3) CONSTRAINT ERROR is raised after all choices are 


• 






configuphTIon information 


evaluated when a bound in a non-null range of a non-null 
aggregate does not belong to an index subtype. (See test 
E432113.) 


h. Pragmas. 

1) The pragma INLINE is supported for functions and 
procedures. (See tests LA3004A..B (2 tests), EA3004C..D (2 

tests), and CA3004E..F (2 tests).) 


i. Generics. 

This compiler enforces the following two rules concerning 
declarations and proper bodies which are individual compilation 
units; 

0 generic bodies must be compiled and completed before their 
instantiation. 

o recompilation of a generic body or any of its transitive 
subunits makes all units obsolete which instantiate that 
generic body. 

These rules are enforced whether the compilation units are in 
separate compilation files or not. AI408 and AI506 allow this 
behaviour. 

1) Generic specifications and bodies can be compiled 

in separate compilations. (See tests CA1012A, CA2009C, 

CA2009F, BC3204C, and BC3205D.) 

2) Generic subprogram declarations and bodies can be 
compiled in separate compilations. (See tests CAi012A and 
CA2009F.) 

3) Generic library subprogram specifications and bodies can be 
compiled in separate compilations. (See test CA1012A.) 

4) Generic non-library package bodies as subunits can 
be compiled in separate compilations. (See test CA2009C.) 

5) Generic non-library subprogram bodies can be 
compiled in separate compilations from their stubs. (See test 
CA2009F.) 

6) Generic unit bodies and their subunits can be 
compiled in separate compilations. (See test CA3011A.) 

7) Generic package declarations and bodies can be 






COHFIGURATIO?'f IMFOR-ATIOW 


compiled in separate compilations. {See tests CA2C09C, 
BC3204C, and 8032050.) 

8) Generic library package specifications and bodies can be 

compiled in separate compilations. (See tests 

BC3204C and BC3205D.) 

9) Generic unit bodies and their subunits can be 
compiled in separate compilations. (See test CA3011A.) 


Input and output. 

1) The package SEQUENTTAL_IO can be instantiated vith 

unconstrained array types and record types with 

discriminants without defaults. (See tests AE2101C, EE2201D, 

and EE2201E.) 

2) The package DIRECT_I0 can be instantiated with 

unconstrained array types and record types with 

discriminants without defaults. (See tests AE2101H, EE2401D, 

and EE2401G.) 

3) The director, AJPO, has determined (AI-00332) that every call 
to OPEN and CREATE must raise USS_ERR0R or IJAr!E_ERR0R if file 
input/output is not supported. This implementation exhibits 
this behavior for SEQUENTIAL_IO, DIRECT_T0, and TEXT_I0. 







TEST IMEORHhTTON 


CHAPTER 3 
TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 512 tests were inapplicable to this implementation. 
All inapplicable tests were processed during validation testing except for 
201 executable tests that use floating-point precision exceeding 
that supported by the implementation, and for 233 executable tests 
that use file operations not supported by the implementation. 
Modifications to the code, processing, or grading for 31 tests were 
required to successfully demonstrate the test objective. {See section 
3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 

A 

S 

TEST 

C 

CLASS 

D 

E 

L 

TOTAL 

Passed 

129 

1132 

1821 

17 

16 

46 

3161 

Inapplicable 

0 

6 

494 

0 

12 

0 

512 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


1 T 






3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 

2 

3 

4 

5 

6 

CHAPTER 
7 8 

9 

10 

11 

12 

13 

14 

TOTAL 

Passed 

198 

577 

545 

245 

172 

99 

162 

332 

133 

36 

252 

334 

76 

3151 

N/A 

14 

72 

135 

3 

0 

0 

4 

0 

4 

0 

0 

35 

245 

512 

Wdrn 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 UITHDR.AWN TESTS 

The following 44 tests were withdrawn from ACVC Version 1.10 
at the time of this validation: 


E28005C 

A39005G 

B97102E 

C97116A 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A31G 

CD2A83G 

CD2A84M 

CD2A84M 

CD50110 

CD2B15C 

CD7205C 

CD2D11B 

CD5007B 

ED7004B 

ED7005C 

ED7005D 

ED7006C 

ED7006D 

CD7105A 

CE3301A 

CD7203B 

CE3411B 

CD7204B 

CD7205D 

CE2107T 

CE3111C 


See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of features 
that a compiler is not required by the Ada Standard to support. Others may 
depend on the result of another test that is either inapplicable or 
withdrawn. The applicability of a test to an implementation is considered 
each time a validation is attempted. A test that is inapplicable for one 
validation attempt is not necessarily inapplicable for a subsequent 
attempt. For this validation attempt, 519 tests were inapplicable for the 
reasons indicated: 

a. The following 201 tests are not applicable because they ha'^e 
floating-point type declarations requiring more digits than 
SYSTEM.MAX DIGITS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 






TEST INFORMATION 


C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


b. C35702A and B86001T are not applicable because this implementation 
supports no predefined type SHORT_FLOAT. 

c. The following 16 tests are not applicable because this 
implementation does not support a predefined type LONG_INTEGER: 

C45231C C45304C C45502C C45503C C45504C 

C45504F C45611C C45613C C45614C C45631C 

C45632C B52004D C55B07A B55B09C B86001W 

CD7101F 


d. C45531M..P (4 tests) and C45532M..P (4 tests) are not applicable 

because the value of SYSTEM.MAX_MANTISSA is less than 32. 

e. B86001Y is not applicable because this implementation supports no 
predefined fixed-point type other than DURATION. 

f. B86001Z is not applicable because this implementation supports no 
predefined floating-point type with a name other than FLOAT, 
LONG_FLOAT, or SHORT^FLOAT. 

g. CA2009A, CA2009C, CA2009F and CA2009D are not applicable because 

this compiler creates dependencies between generic bodies, and 
units that instantiate them (see section 2.2i for rules and 
restrictions concerning generics). 

h. CD1009C, CD2A41A..E (5 tests), and CD2A42A..J (10 tests) are not 
applicable because this implementation imposes restrictions on 
'SIZE length clauses for floating point types. 

i. CD2A61I is not applicable because this implementation imposes 
restrictions on 'SIZE length clauses for array types. 

j. CD2A84B..I (8 tests) and CD2A84K..L (2 tests) are not applicable 
because this implementation imposes restrictions on 'SIZE length 
clauses for access types. 

It. CD2A91A..E (5 tests) are not applicable because 'SIZE length 
clauses for task types are not supported. 

1. CD2B11G is not applicable because 'STORAGE_SIZE representation 
clauses are not supported for access types where the designated 
type is a task type. 


15 



TEST INFORMATION 


m. CD2B15B is not applicable because a collection size larger than 
the size specified was allocated. 

n. The following 238 tests are inapplicable because sequential, text, 
and direct access files are not supported: 


CE2102A..0 

(3 

tests) 

CE2102G..H 

(2 

tests) 

CE2102K 



CE2102N..Y 

(12 

1 tests) 

CE2103C..D 

(2 

tests) 

CE2104A..D 

(4 

tests) 

CE2105A..B 

(2 

tests) 

CE2106A..B 

(2 

tests) 

CE2107A..H 

(8 

tests) 

CE2107L 



CE2108A. .B 

(2 

tests) 

CE2108C..H 

(6 

tests) 

CE2109A..C 

(3 

tests) 

CE2110A,.D 

(4 

tests) 

CE2111A.,I 

(9 

tests) 

CE2115A..B 

(2 

tests) 

CE2201A..0 

(3 

tests) 

CE2201F..N 

(9 

tests) 

CE2204A..D 

(4 

tests) 

CE2205A 



CE2208B 



CE2401A..0 

(3 

tests) 

CE2401E..F 

(2 

tests) 

CE2401H..L 

(5 

tests) 

CE2404A..B 

(2 

tests) 

CE2405B 



CE2406A 



CE2407A..B 

(2 

tests) 

CE2408A..B 

(2 

tests) 

CE2409A..B 

(2 

tests) 

CE2410A-.B 

(2 

tests) 

CE2411A 



CE3102A..B 

(2 

tests) 

EE3102C 



CE3102F..H 

(3 

tests) 

CE3102J..K 

(2 

tests) 

CE3103A 



CE3104A..0 

(3 

tests) 

CE3107B 



CE3108A..B 

(2 

tests) 

CE3109A 



CE3110A 



CE3111A..B 

(2 

tests) 

CE3111D..E 

(2 

tests) 

CE3112A..D 

(4 

tests) 

CE3114A..B 

(2 

tests) 

CE3115A 



EE3203A 



CE3208A 



EE3301B 



CE3302A 



CE3305A 



CE3402A 



EE3402B 



CE3402C..D 

(2 

tests) 

CE3403A..C 

(3 

tests) 

CE3403E..F 

(2 

tests) 

CE3404B..D 

(3 

tests) 

CE3405A 



EE3405B 



CE3405C.,D 

(2 

tests) 

CE3406A..D 

(4 

tests) 

CE3407A..0 

(3 

tests) 

CE3408A..C 

(3 

tests) 

CE3409A 



CE3409C..E 

(3 

tests) 

EE3409F 



CE3410A 



CE3410C..E 

(3 

tests) 

EE3410F 



CE3411A 



CE3411C 



CE3412A 



EE3412C 



CE3413A 



CE3413C 



CE3602A..D 

(4 

tests) 

CE3603A 



CE3604A..B 

(2 

tests) 

CE3605A..E 

(5 

tests) 

CE3606A..B 

(2 

tests) 

CE3704A..F 

(6 

tests) 

CE3704M..0 

(3 

tests) 

CE3706D 



CE3706F..5 

(2 

tests) 

CE3804A..P 

(16 

1 tests) 

CE3805A..B 

(2 

tests) 

CE3806A..B 

(2 

tests) 

CE3806D..E 

(2 

tests) 

CE3806G..H 

(2 

tests) 


16 



CE3905A..C (3 tests) CE3905L 

CE3906A..C (3 tests) CE3906E..F (2 tests) 

These tests were not processed because their inapplicability can 
be deduced from the result of other tests- 

o. Tests CE2103A..B (2 tests) and CE3107A raise USE_ERROR although 
NAME_ERROR is expected. These tests report FAILED but they were 
graded not applicable because this implementation does not support 
permanent files. 

p. EE2201D, EE2201E, EE2401D, EE2401G are inapplicable because 

sequential, text, and direct access files are not supported. 


ly 



3.6 TEST, PROCESSING, AMD EVALUATION MODIFICATIONS 


It is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVT m cases where 
legitimate implementation behavior prevents the successful completion of an 
(otherwise) applicable test. Examples of such modifications include: 
adding a length clause to alter the default size of a collection; splitting 
a Class B test into subtests so that all errors are detected; and 
confirming that messages produced by an executable test demonstrate 
conforming behavior that was not anticipated by the test (such as raising 
one exception instead of another). 

Modifications were required for 81 tests. 

a. The following tests were split because syntax errors at one point 
resulted in the compiler not detecting other errors in the test; 


B2200:A 

B24007A 

B24009A 

B25002B 

B32201A 

B34005N 

B34005T 

B34007H 

B35701A 

B36171A 

B36201A 

B37101A 

B37102A 

B37201A 

B37202A 

B37203A 

B37302A 

B33003A 

B33003B 

B38008A 

B38008B 

B38009A 

B33009B 

B38103A 

B38103B 

B38103C 

B38103D 

B38103E 

B43202C 

B44002A 

B48002A 

B48002B 

B48002D 

B48002E 

B48002G 

343003E 

B49003A 

B49005A 

B49006A 

B49007A 

B49009A 

B4A010C 

B54A20A 

B54A25A 

B53002A 

B58002B 

B59001A 

B59001C 

B59001I 

B62006C 

B67001A 

B67001B 

B67001C 

B67001D 

B74103E 

B74104A 

B85007C 

B91005A 

B95003A 

B95007B 

B95031A 

B95074E 

BC1002A 

BC1109A 

BC1109C 

BC1206A 

BC2001E 

BC3005B 

BC3009C 

BD5005B 




b. For the two tests BC3204C and BC3205D, the compilation order was 
changed to 

BC3204C0, Cl, C2, C3M, C4, C5, C5, C3H 
and 

BC3205D0, D2, DIM 

respectively. This change was necessary because of the compiler's 
rules for separately compiled generic units (see section 2.2i for 
rules and restrictions concerning generics). Vhen processed in 
this order the expected error messages were produced for BC3204C3H 
and BC3205D1M, 

c. The two tests BC3204D and BC3205C consist of several compilation 
units each. The compilation units for the main procedures are 
near the beginning of the files. When processing these files 
unchanged, a lin)? error is reported instead of the expected 
compiled generic units. Therefore, the compilation files were 
modified by appending copies of the main procedures to the en'^ of 



these files. When processed, the e.^pected error -nessages were 
generated by the compiler. 

d. Tests C39005A, CD7004C, CD7005E and CD700?E wrongly presume an 
order of elaboration of the library unit bodies. These tests were 
modified to include a PRAGt'fA ELABORATE (REPORT) ; 

e. Test E28002B checks that predefined or unrecognized pragmas may 
have arguments involving overloaded identifiers without enough 
contextual information to resolve the overloading. It also checks 
the correct processing of pragma LIST. For this implementation, 
pragma LIST is only recognised if the compilation file is compiled 
without errors or warnings. Hence, the test was modified to 
demonstrate the correct processing of pragma LIST. 

f. Tests C45524A and C45524B contain a check at line 136 that may 
legitimately fail as repeated division may produce a quotient that 
lies within the smallest safe interval. This check was modified 
to include, after line 138, the text: 

ELSIF VAL <= F'SAFE_SMALL THEN COMMENT ("UNDERFLOW SEEMS GRADUAL"); 

For this implementation, the required support package specification, 
SPPRT13SP, was rewritten to provide constant values for the function names. 


3.7 ADDITIONAL TESTING INFORMATION 

3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 produced 
by the Tartan Ada ULTRIX/68K Version INT-2 compiler was submitted to the 
AVF by the applicant for review. Analysis of these results demonstrated 
that the compiler successfully passed all applicable tests, and the 
compiler exhibited the expected behavior on all inapplicable tests. 

3.7.2 Test Method 

Testing of the Tartan Ada ULTRIX/68K Version INT-2 compiler using ACVC 
Version 1.10 was conducted by lABG on the premises of TARTAN. The 
configuration in which the testing was performed is described by the 
following designations of hardware and software components: 

Host Computer: 

Machine: HicroVAX II 

Operating System: ULTRIX V2.2 

Memory Size: 9 MB 





Tilh? 1 1 lun 


Target Computer: 

Hachine: Tektronix 8541 Emulator for 63020 
Operating System: TekDB V5.04 

Memory Size: 64 KB + 1 MB 

Compiler: 

Tartan Ada ULTRIX/68K Version INT-2 

The original ACVC vfas customized prior to the validation visit in order to 
remove all withdrawn tests, inapplicable I/O tests and tests requiring 
unsupported floating point precisions. Tests that make use of 
implementation specific values were also customized. Tests requiring 
modifications during the prevalidation testing were modified accordingly. 

A tape containing the customized ACVC was read by the host computer. 

After the test files were loaded to disk, the full set of tests was 
compiled and linked. All executable tests were transferred via an RS232 
line to the target computer where they were run. Results were transferred 
to the host computer in the same way, where they were evaluated and archiv¬ 
ed. 

The compiler was tested using command scripts provided by TARTAN 

LABORATORIES INCORPORATED and reviewed by the validation team. The 
compiler was tested using no option settings. All chapter B tests were 
compiled with the listing option on (i.e. -La). The linker was called 
with the command 

alib68 link <testname> 

A full list of compiler and linker options is given in Appendix E. 


3.7.3 Test Site 

Testing was conducted at TARTAN LABORATORIES INCORPORATED, Pittsburgh and 
was completed on 7 December 1989. 


20 





DECLARATIOiJ OF CONFORMANCE 


APPENDIX A 

DECLARATION OF CONFORMANCE 


TARTAN LABORATORIES INCORPORATED h^s submitted the following 
Declaration of Conformance concerning the Tartan Ada 'JLTRIX/'SEK 
Version INT-2 compiler. 






DECLARATION OF CONFORMANCE 


Compiler Implementor; Tartan Laboratories Incorporated 

Ada Validation Facility; lABG mbH, Dept. SZT 

Ada Compiler Validation Capability (ACVC) Version: l.io 


Base Configuration 

Base Compiler Name; 

Base Compiler Version; 

Host Computer; 

Target Computer; 

Implementor's Declaration 


Tartan Ada ULTRIX/68K 
Version INT-2 

Micro VAX II under ULTRIX V2.2 
Tektronix 8541 Emulator for 68020 


I, the undersigned, representing Tartan Laboratories Incorporated, 
have implemented no deliberate extensions to the Ada Language 
Standard ANSI/MIL-STD-1815A in the compiler(s) listed in this 
declaration. I declare that Tartan Laboratories Incorporated is the 
owner of record of the Ada Language compiler(s) listed above and, as 
such, is responsible for maintaining said compiler(s) in conformance 
to ANSI/MIL-STD-1815A. All certificates and registrations for Ada 
Language compiler(s) listed in this declaration shall be made only in 
the owner's corporate name. 

-- Date: 7. 

Tartan Laboratories Incorporated 
Ea Lieblein, Sr. VP, Development 


Owner's Declaration 


I, the undersigned, representing Tartan Laboratories Incorporated, 
take full responsibility for implementation and maintenance of the 
Ada compiler(s) listed above, and agree to the public disclosure of 
the final Validation Summary Report. I declare that all of the Ada 
Language compilers listed, and their host/target performance, are in 
compliance with the Ada Language Standard ANSI/MIL-STD-1815A. 



Date: 




o. 




/fc^ 


Tartan Laboratories Incorporated 
Ed Lieblein, Sr. VP, Development 






APPENDIX F OF THE Ada STANDARD 




APPENDIX B 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies corres¬ 
pond to implementation-dependent pragmas, to certain machine- 
dependent conventions as mentioned in chapter 13 of the Ada Stan¬ 
dard, and to certain allowed restrictions on representation 
clauses. The implementation-dependent characteristics of the 
Tartan Ada ULTRIX/63X Version INT-2 compiler, as described in 
this Appendix, are provided by TARTAN LABORATORIES INCORPORATED. 
Unless specifically noted otherwise, references in this appendix 
are to compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, are 
contained in Appendix F. 




Chapter 5 

Appendix F to MIL-STD-ISISA 


This chapter contains the required Appendix F to Military Standard. Ada Programming Language, 

ANSI/MIL-STD-1815A (Amencan Nauonal Standards Insumie. Inc.. February IT, L983) . 

5 . 1 . PRAGMAS 

5.1.1. Predefined Pragmas 

This section summanzes the effects of and restrictions on predefined pragmas. 

• .Access collections are not subject to automatic storage reclamation so pragma CONT^CLLZO has no effect. 
Space deallocated by means of UNCH£C:<i 3 _ 3 H:A:.lCCArrCN -viil be reused by the allocation of new 
objects. 

• Pragma £iAacRAr2 is supponcd. 

• Pragma inline is supported. The body for an inlined subprogram need not appear in the same compila- 
uon unit as the call. Inlining will uike place only if the subprogram body is present in the library and is not 
obsolete. 

• Pragma INTEAEi^CE is not supported. The implementation-defined pragma rCR£I3N_3CDy (see Sec¬ 
tion 5.l.2.2j can be used to interface to subprograms wntten in other languages. 

• Pragma LIST is supported but has the intended eifcct only if the command line opuon -La was supplied 
for compilation, and the listing generated was not due to the presence of errors and/or warnings. 

• Pragma OPTI.MIIE is supported except when at the outer level ahat is. in a package specification or 
body). 

• Pragma P.ACX is fully supported. 

• Pragma PAGE is supported but has the intended effect only if the command line opuon -La was supplied 
for compilation, and the listing generated was not due to the presence oi errors and/or warnings. 

• Pragma PRICRiry is fully supported. 

• Pragma SUPPRESS is fully supported as required by Ada LR.M 1 l.T. 

• Future releases of the compiler will support the loilowmg oragmas: MEMCR^_5II£, 3HAAE2. 
STCSAGEJJNIT and SY3T£.M_NAWE. 

A warning message will be issued if an unsupported pragma is supplied. 


5.1.2. fmpiementation-Oe/ined Pragmas 

Implementation-defined pragmas provided by Tartan arc Jesenbed m the tollowmg secuons. 

5.IJ.I. Pragma LINECAG£_NA.'tE 

The pragma LINKAGE_na.v.£ associates an Ada entity with a stnng that is meaningful e.xtemally: e.g.. to a 
linkage editor. It takes the form 

pragma LIN'[<AGE_.'rA.ME i,\da-<impie-niime. iir:ng-:onstant) 


S-1 





USER .VIANLAL rOR TaRT.AN aDA ULTRtX/fiSK 


The Ada-simple-name must be the name ot an Ada enuty declared in a package specification. This endcy must be 
one that has a mniime representauon; e.g., a subprogram, exception or object. It may not be a named number or 
string constanL The pragma must appear after the declaration of the entity in the same package specificaaon. 

The effect of the pragma is to cause the strin§-consta/u to be used in the generated assembly code as an 
external name for the associated Ada entity. It is the responsibility of the user to guarantee that this string 
constant is meaningful to the linkage editor and that no illegal linkname clashes arise. 


5.2JJ. Pragma rGR=:rGN_3CD'; 

.A subprogram 'vntten in another language can be called from an .Ada program. Pragma rCRSIGN 3CDy is 
used to indicate that the body for a non-generic top-level package specification is provided in the form of an 
object module. The bodies for several subprograms may be contained in one object module. 

Use of the pragma r0R£IGN_3CD'r dictates that all subprograms, excepuons and objects in the package are 
provided by means of a foreign object module. In order to successfully link a program including a foreign body, 
the object module for that body must be provided to the library using the alci:63 foreign command 
described in Section a.7. 

The pragma is of the form; 

pragma rGREIGN_30Dy (langiun’e jiame \, iianorauon '■ounne lame, ] 

The parameter language^riame is a string intended to allow me compiier to idenufy the calling convention ased 
by the foreign module tbut this functionality is not yet in operation). Currently, tne programmer must ensure that 
the calling convenuon and data representauon of the foreign body procedures are compaubie with those used by 
the Tartan Ada compiler. Subprograms called by tasks should be reentrant. 

The optional dabcrationjotuinejiame string argument provides a means to initialize the package. The 
rouane specified as the elaboration jouanejiame. which .will be called for the elaboration of this package body, 
must be a global rouane in the object module provided by the user. 

•A specificauon that uses this pragma may contain uniy subprogram declarauons. object decarauons that use 
an unconstrained type mark, and number declarations. Pragmas may also appear :n the package. The type mark 
for an object cannot be a task type, and the object declaration must not have an iniual value expression. The 
pragma must be given poor to any declarauons wiihm die package specificauon. If die pragma is not located 
before the first declarauon. or any restriction on the declarations is vioiated, the pragma is ignored and a warning 
IS generated. 

The foreign body is enurely responsible for miuaiixing ibjects declared ;n a package utilizing pragma 
?GR£IGN_3CD'f. In parucular. the user should be aware that the implicit miualizaiions desenbed in LRM 3.2.1 
are not done by the compiler. (These implicit initializations are associated wuh object of access types, certain 
record types and composite types containing components ut the preceding kinds of types.! 

Pragma gINKAGE_.vawe should be used for all declarations m the package, including any declarauons in a 
nested package specification to be s'urc that there arc no conilicting link names. If pragma 1INKAGE_MAME is 
not used, the cross-reference gualifier, -x, (see Section 3.2! .should be used when invoking the compiler and the 
resulting cross-reference table of linknames m.spectcd ;o itlentify the linknames as.signed by the compiler and 
determine that there are no contlicung linknames isce al.<o .Section 3.5 1 . 

In the following example, we want to call a tuncuon 3..T.r. .vnicn computes polynomials and is wntien in C. 


5-2 





■APPENDIX F TO MIL-STD-1815A 


package MATH_rUNCS is 

pragma r0RklGN_30DY ("C") ; 

function POLYNOMIAL (X: INTEGER) return INTEGER; 

—Ada spec macching ;:he C roucine 
pragma LINKAGS_NAME (polynomial, '•pi.-nn'*) ; 

—Force compiler co use name “pimn'* when referring to this 
— function 
end MATH_rt;NC3; 

with MATH_?TJNCS; use MATH_~UNCS 
procedure MAIN is ~ 

X:INTEGER ;- POLYNOMIAL(10) ; 

— Will generate a call to '•plmn" 

begin ... 
end MAIN; 

To compile, link and run the above program, you do the following steps; 

1. Compile MATH_rUNCS 
1 Compile MAIN 

3. Obtain an object module (e.g. .math .toff) containing the compiled code for pl.mn, convened to TOFF; 
if the module is written in assembly code, for example, using the oa3ys_to_toff utility (See Object 
File Utilities, Chapter 4) 

4. Issue the command 

alihoa foreign mac.h_funcs math, toff 

5. Issue the command 

alibSa link main 

Without Step 4, an attempt to link will produce an error message informing you of a missing package body for 
MATH_?UNC3. 

Using an .Ada body from another .Ada program library. The user may compile a body written in Ada for a 
specificauon into the library, regardless of the language specified in the pragma contained in the specification. 
This capability is useful for rapid prototyping, where an Ada package may serve to provide a simulated response 
for the functionality that a foreign body may evenuially produce, li also allows the user to replace a foreign body 
with an Ada body without recompiling the specification. 

The user can either compile an Ada body into the library, or use the command alib63 foreign (See 
Section 4.7) co use an Ada body from another library. The Ada body from another library must have been 
compiled under an idenacal specification. The pragma linkage__name must have been applied to ail endues 
declared in the specification. The only way to specify the linkname for the elaborauon rouune of an Ada body is 
with the pragma roR£iGN__3aDY. 

Using Calls to the Operating System. In some cases, the foreign code is actually supplied by the opencing 
system (in the case of system calls) or by runtime libraries for other programming languages such as C. Such 
calls may be made using a dummy procedure to supply a file specificauon to the al.Li:o3 f oreigncommand. 
You need a dummy . cof f file which may be obtained m a number of ways. One way is to compile the 
procedure 

procedure DUMMY is 
begin 
null; 
end; 

Then. use the library command 

ali.'a6d foreign pk^ dummy. :off 

where p/kg is the name of the package that conuins the pragma linkage_nam£ for the operanng system call. 








USER MA.NTJAL FOR TARTAN ADA L;LTRE</68fC 


For example to use the ULTRIX system call _saj:k in the program TEST: 

Package MEMORY is 

pragma FOREIGN BODY ("ASM"); 
procedure GST vfRTUAL memory (MEM; INTEGER) ; 
pragma LINKAGS_NAME “GET VtRTUAL_MEMCRY, " sOrk "); 
end MEMORY; “ “ 

with MEMORY; 
procedure TEST is 


begin 

GET_VIRTUAL_MEMORY (MEM) ; 
end TEST; 

Obtain the file duitroy. cof f. Then use 

aiidSS foreign .nemory diinmy.aaff 
to include the body for the system call in the library. 


52. IMPLEMEi\TATION-DEPENDEyT ATTRIBUTES 

No implementation-dependent attributes are currently supported. 

52. SPECIFICATION OF THE PACKAGE S YSTEM 

The parameter values specified for the 68K target in package SYSTEM [LRM 13.T. 1 and Annex C] are: 

package SYSTEM is 

type ADDRESS is new INTEGER; 
type NAME is (MCSaOOO); 


SYSTEM .NAME 

constant NAME :« .MC53 000; 

STORAGE (INIT 

constant 

- 

3; 

MEMORY SIZE 

constant 


1 000 000; 

MAX INT 

constant 

■m 

2~147 433 347 

MIN~INT 

constant 

m 

-MAX INT - 1; 

.max'digits 

constant 

m 

13; 

.MAX MANTISSA 

constant 

m 

31; 

FINE DELTA 

constant 

- 

2*1.0*e-31; 

TICK 

constant 

» 

0.01; 


subtype PRIORITY is INTEGER range 10 .. 200; 

OEFAULT_?RIORITY : constant PRIORITY :» PRIORITY'FIRST; 

RUNTIME_SRRGR ; exception; 
end SYSTEM; 

5 . 4 . RESTRICTIONS ON REPRESENTATION CLAUSES 

The following sections explain the basic restncaons for representanon specificauons followed by additional 
restrictions applying to specific kinds of clauses. 

5.4.1. Basic Restriction 

The basic restncuon on rcprescntauon specifications [LRM 13.11 that they may be given only for types 
declared in terms of a type definition, excluding a generic_cyp9_dafir.ic:.on (LRM 12.1) and a 
private cype def i.nAt.:.on (LR.M 7.4). .Any representauon clause in vioiauon of these rules is not obeyed 
by the compiler, a diagnostic message is issued. 


3-i 







■APPENDIX F TO MIL-S7D-1815A 


Further resiricdons are explained in ihe following sections. .\ny representauon clauses violating those restric¬ 
tions are not obeyed but cause a diagnostic message to be issued. 

5.42. Length Clauses 

Length clauses [LRM 13.2] are, in general, supponed. For details, refer to the following sections. 

5.42.1. Size Specifications far Types 

The rules and restrictions for size specifications applied to types of various classes are described below. 

The following principle rules apply; 

1. The size is specified in bits and must be given by a static expression. 

2. The specified size is taken as a mandate to store objeca of the type in the given size wherever feasible. 
No attempt is made to store values of the type in a smaller size, even if possible. The following rules 
apply with regard to feasibility; 

• An object that is not a component of a composite object is allocated with a size and alignment that 
is referable on the target machine; that is. no attempt is made to create objects of non-referable size 
on the stack. If such stack compression is desired, it can be achieved by the user by combining 
multiple stack variables in a composite object; for example 

Cype .My_Snujn is (.\,3); 
for .My___enum'size use L; 

V,W; My_enum; -- will occupy cwo storage 

— units on t.ne stac.k 

— (if allocated at all) 
type rec is record 

7, W; My_enum; 
end record” 
pragma Facklrec); 

0: rec; — will occupy one storage unit 

• A formal parameter of the type is sized according to calling conventions rather than size 
specifications of the type. Appropriate size conversions upon parameter passing take place 
automadcally and are transparent to the user. 

• Adjacent bits to an object that is a component of a composite object, but whose size is 
non-referable, may be affected by assignments to the object, unless these bits are occupied by other 
components of the composite objecc that is. whenever possible, a component of non-referable size 
is made referable. 

In all cases, the compiler generates correct code for all operauons on objects of the type, even if they are 
stored with differing representauonal size in different contexts. 

Note; A size specification cannot be used to force a certain size m value operations of the type; for 
example 

cype my_i.'ic is range 0.. 55335; 
for my_inc'3ize use 15; — o.<. 

A,3; my_inc; 

....a”- 3... — ".".13 operation will generally oe 
— e.xecuted on 32-3it values 

3. A Size specificauon for a type specifies the size for objects of this type and of ail its subtypes. For 
components of composite types, whose subtype would allow a shoner representauon of the component, 
no attempt is made to take advantage of such shorter represeniauons. In contrast, for types without a 
length clause, such components may be represented m a lesser number of bits than the number of bits 
required to represent all values of the type. Thus, in the example 


5-3 




USER MANUAL FOR TARTAN ADA ULTRIX/6SK 


zype MY_rNT is range 0..2»*1S-1; 
for MY_INT'SI2E use 15; — (1) 
subtype SMALL_.'«_INT is range 0..255; 

type R is record 

X: SMAI.L__^«_I^IT; 

end record; 

the component RJC will occupy 16 bits. In the absence ot the length clause at (,1). R.X may be represented 
in 3 bits. 

For the following type classes, the size specificanon must coincide with the default size chosen by the compiler 
for the type: 

• access types 

• floating-point types 

• task types 

No useful effect can be achieved by using size specifications for these types. 

S.42J. Size Specificadon for Scalar Types 

The specified size must accommodate all possible values of the type including the value 0 (even if 0 is not in 
the range of the values of the type). For numeric types with negauve values the number of bits must account for 
the sign biL No skewing of the representation is attempted. Thus 
type nty_inc Ls range 100..lOl; 
requires ax least 7 bits, although it has only two values, while 
type .tiy^inc is range -101..'100; 
requires 3 bits to account for the sign biL 

A size specification for a real type docs not affect the accuracy of operadons on the type. Such influence 
should be exerted via the accuracy_defLnicron of the type (LR.M 3.5.7, 3.5.9). 

.A size spccificadon for a scalar type may not specify a size larger than the largest operauon size supported by 
the target architecture for the respecuve class of values of the type. 

5.42 J. Size Specificadon far Array Types 

A size specification for an array type must be large enough to accommodate ill components of the array under 
the densest packing strategy explained below in adherence to any alignment constraints on the component type 
(see Section 5.4.7). 

The size of the component type cannot be influenced by a length clause for an array. Within the limits of 
representing all possible values of the component subtype (but not necessarily of its type), the representauon of 
components may, however, be reduced to the minimum number of bits, unless the component type carries a size 
specification. 

If there is a size specification for die component type, but not for the array type, the component size is 
rounded up to a referable size, unless pragma p.^cx is given. This applies even to boolean types or other types 
chat require only a single bit for the represenuiuon of all values. 

5.42.4. Size Specificadon for Record Types 

\ size specificanon for a record type docs not mfiuence the default type mapping of a record type. The size 
must be at least as large as the number of bits determined by type mapping. Infiuence over packing of com¬ 
ponents can be exerted by means of (partial) record representation clauses or by Pragma ?kCK. 

Neither the size of component types, nor the representauon of component subtypes can be influenced by a 
length clause for a record. 


5-6 





APPENDIX r TO ME.-STD-1815A 


The only implementadon-dependeni components allocated by Tanan Ada in records contain dope information 
for arrays whose bounds depend on discriminants of the record or contain relative offsets of components within a 
record layout for record components of dynamic size. These implementation-dependent components cannot be 
named or sized by the user. 

A size specification cannot be applied to a record type with components of dynamically determined size. 

Note: Size specificadons for records can be used only to widen the representadon xcomplished by padding at 
the beginning or end of the record. Any narrowing of the representadon over default type mapping must be 
accomplished by representadon clauses or pragma ?AC:<. 

5.4 JJ. Sptciflcaaon of Collection Sizes 

The specificadon of a coUecdon size causes the collecdon to be allocated with the specified size. It is 
expressed in storage units and need not be stauc; refer to package SYSTEM for the meaning of storage units. 

Any attempt to allocate more objects than the coUecnon can hold causes a stcrags_ERROR excepdon to be 
raised. Dynamically sized records or arrays may carry hidden administiauve storage requirements that must be 
accounted for as part of the collecdon size. Moreover, alignment constraints on the type of the allocated objects 
may make it impossible to use all memory locadons of the allocated coilecuon. Furthermore, some administra- 
dve overhead for the allocator must be taken into xcount by the user (currently l word per allocated object). 

In the absence of a specificadon of a collecdon size, the coilecuon is extended automadcaily if more objects 
are iilocnnyl than possible in the collecdon onginally allocated with the compiler-established default size. In this 
case. STORAGS ERROR is raised only when the available target memory is exhausted. If a collecdon size of 
zero is specified, no xcess collecdon is allocated. 

5.4 JJ. Specification of Task Activation Size 

The specificadon of a task acdvadon size causes the cask acuvadon io be allocated with the specified size. It 
is expressed in storage units; refer to package SYSTEM, for the meaning of storage units. 

Any attempt to exceed the xdvauon size during execuuon causes a 3TCRAG£_ERROR excepdon to be 
raised. Unlike collecdons. there is generally no extension of task acuvadons. 

5.4J.7. Specification of' SMALL 

Only powers of 2 are allowed for ' SMALL. 

The length of the representadon may be affected by this specificauon. If a size specificadon is also given for 
the type, the size specificadon cakes precedence; the specificauon of ' small must then be xcommodatable 
within the specified size. 

5.4.3. Enumeration Representation Clauses 

For enumenidon representadon clauses [LRM 13.3], the following restncuons apply: 

• The internal codes specified for the literals of the enumcrauon type may be any integer value between 
INTEGER' ITRST and INTEGER' LAST. It is Strongly advised to not provide a representauon clause that 
merely duplicates the default mapping of cnumerauon types, which assigns consecuuve numbers in as¬ 
cending order starting with 0. since unnecessary runume cost is incurred by such duplicadon. It should be 
noted that the use of attributes on enumeradon types with uscr-spcctfied encodings is costly at run ame. 

• Am’' types, whose index type is an enumeration type with non-conuguous value encodings, consist of a 
condguous sequence of components. Indexing mio the array involves a runume transladon of the index 
value into the corresponding posiuon value of the enumcrauon type. 


5-7 






USER MA>rUAL FOR TARTAN ADA ULTRIX;63K 


5.4.4. Record Representation Clauses 

The alignment clause of record representation clauses [LRM 13.-1] is observed. The specified expression 
must yield a target-dependent value. 

Static objects may be aligned at powers of 2 up to a page boundary. The specified alignment becomes the 
minimum alignment of the record type, unless the minimum alignment of the record forced by the component 
allocation and the minimum alignment requirements of the components is already more stringent than the 
specified alignment. 

The component clauses of record representation clauses are allowed only for components and discriminants 
of statically determinable size. Not all components need to be present Component clauses for components of 
variant parts are allowed only if the size of the record type is statically determinable for every variant. 

The size specified for each component must be sufficient to allocate all possible values of the component 
subtype (but not necessanly the component type). The location specified must be compauble with any alignment 
constraints of the component type: an alignment constraint on a component type may cause an implicit alignment 
constraint on the record type itself. 

If some, but not all, discriminants and components of a record type are described by a component clause, then 
the discriminants and components without component clauses are allocated after those with component clauses; 
no attempt is made to utilize gaps left by the user-provided allocauon. 

5.4.5. Address clauses 

■ddress clauses (LRM 13.51 are supported with the following restrictions: 

• When applied to an object, an address clause becomes a linker directive to allocate the object at the given 
address. For any object not declared immediately within a top-level library package, the address clause is 
meaningless. .Address clauses applied to local packages are not supponed by Tanan Ada. Address clauses 
applied to library packages are prohibited by the syntax: therefore, an address clause can be applied only to 
a package if it is a body stub. 

• .Address clauses applied to subprograms and tasks axe implemented according to the LRM rules. When 
applied to an entry, the specified value idenufies an interrupt in a manner customary for the targeu 
Immediately after a task is created, a runtime call is made for each of its entries having an address clause, 
establishing the proper binding between the entry and the interrupt. 

• Specified addresses must be constants. 

5.4.6. Pragma 

Pragma ?.AC:< (LRM 13.1 ] is supported. For details, refer to the following secaons. 

5.4.6.1. Pragma ?.AC:< for Arrays 

If pragma ?ac:< is applied to an array, the densest possible represenution is chosen. For details of packing, 
refer to the explanaaon of size specifications for arrays (Secuon 5.-1.2.3'). 

If. in addition, a length clause is applied to 

1. the array type, the pragma has no effect, since such a length clause already uniquely determines the array 
packing method. 

2. the component type, the array is packed densely, observing the component’s length clause. Note that the 
component length clause may have the effect of prevenung the compiler from packing as densely as 
would be the default if pragma ?.AC:< is applied where there was no length clause given for the com¬ 
ponent type. 






APPENDIX r TO MIL-STD-1S15A 


5.-i.6^. The Predefined Type String 

Package standard applies Pragma RACK to the type stc-ng. However, when applied to character arrays, 
this pragma cannot be used to achieve denser packing than is the default for the target: I character per 3-bit 
word. 

S.4.6J. Pragma ^kCKfor Records 

If pragma P.’^CX is applied to a record, the densest possible representation is chosen that is compatible with 
the sizes and alignment constraints of the individual component types. Pragma pack has an effect only if the 
sizes of some component types are specified explicitly by size specifications and are of non-referable nature. In 
the absence of pragma PACK, such components generally consume a referable amount of space. 

It should be noted that default type mapping for records maps components of boolean or other types that 
require only a .dngle bit to a single bit in the record layouL if there are multiple such components in a record. 
Otherwise, it allocates a referable amount of storage to the componenL 

If pragma P.acx is applied to a record for which a record representation clause has been given detailing the 
allocation of some but not all components, the pragma P.ACX affects only the components whose allocation has 
not been detailed. .Vloreover. the strategy of not uulizing gaps between explicidy allocated components still 
applies. 

5JJ. Minimal Alignment for Types 

Certain alignment properties of values of certain types are enforced by the type mapping rules. Any represen¬ 
tation specificauon that cannot be satisfied within these constraints is not obeyed by the compiler and is ap¬ 
propriately diagnosed. 

•Alignment constrauits are caused by propcmes of the target architecture, most notably by the capability to 
extract non-aligned component values from composite values in a reasonably efficient manner. Typically, restric- 
aons exist that make extrtxdon of values that cross certain address boundares very expensive, especially in 
contexts involving array indexing. Permitting data layouts that require such complicated extractions may impact 
code quality on a broader scale than merely in the local context of such extractions. 

Instead of describing the precise aigonthm of establishing the minimal .liignmem of types, we provide the 
general rule that is being enforced by the alignment rules: 

• So object of scalar type including components or subcomponents of a composite type, may span a target- 
dependent address boundary that would mandate on extraction of the object's vaiue to be performed by two 
or more extractions. 

SJ. IMPLEMENTATION-GENERATED COMPONENTS IN RECORDS 

The only implementation-dependent components allocated by Tartan .Ada m records contain dope information 
for arrays whose bounds depend on discnminanis of the record. These components cannot be named by the user. 

5 . 6 . INTERPRETATION OF EXPRESSIONS APPEARING IN ADDRESS CLAUSES 

Section 13..5.1 of the Ada Language Reference .Manual describes a syntax for ossociaung interrupts with task 
entnes. Tartan Ada implements the address clause 
for TOENTRT use at incID; 

by associaung the interrupt specified by :D with the ccencry iniry of the task containing this address 
clause. The interpretation of i.nciD is both machine and compiler dependent. 

The Motorola 680x0 specification provides 256 interrupts that may be associated with task entries. These 
interrupts are identified by an integer in the range 0..255. corresponding to the interrupt vector numbers in secuon 
6.2.1 of the 68020 User’s Manual. When you specify an interrupt .add.'T<:<; clause, the incID argument is 
interpreted as follows; 


5-9 







USER MANUAL FOR TARTAN ADA LLTRC</6.SK 


• [f ihe argument is in the range ()..255. a full support interrupt association is made between the interrupt 
specified by the argument and the task entry. That is, Lbe runtimes make no assumptions about the task in 
question. This is the slower method. 

• If the argument is in the range 256..511. a fast interrupt association is made between the interrupt number 
(argument-256) and the task entry. This method provides faster execution because the runtimes can 
depend upon the assumptions previously desenbed. 

For the difference between full support and fast interrupt handling, refer to Section 8.5. 

5 . 7 . RESTRICTIONS ON UNCHECKED CONVERSIONS 

Tartan supports UNCHECKiw_CONVH;RsrCN with a restriction that requires the sizes of both source and 
target types to be known at compile time. The sizes need .not be the same. If the value m the source is wider than 
that in the target, the source value will be truncated. If narrower, it will be zero-extended Calls on instantiations 
of UNCHSCXED_CDNV'£RSICN are made inline automatically. 

5 . 8 . IMPLEMENTATION-DEPENDENT ASPECTS OF INPUT-OUTPUT PACKAGES 

Tartan Ada supplies the predefined input/ouiput packages D:.R£Ct_:':. SEQUE.vrrAL_:o. 7SXT_:o, and 
1CW_L£’/S1_IQ as required by LR.M Chapter l-i. However, since the target computer is used in embedded 
applicauons lacking both standard I/O devices and tile systems, the functionality of DIRSCT_:o. 
3 c:GUSNTIAI._IC. and 'r£XT_;G is limited. 

2IRECT__IO and 3SQUSNT7.M_IO raise US£_iRRCR if a file open or tile access is attempted. TSXT__IO 
is supported to C’JRRENT_0UT?UT and from C'JRR£Nr_;.N?UT. a routine that takes explicit file names raises 
•JSE ERROR. 


5 . 9 . OTHER IMPLEMENTATION CHARACTERISTICS 

The following mformauon is supplied in addition to that required by Appendix F to .V1IL-STD-18I5A. 

5.9.1. Definition of a Main Program 

.Any .Ada library subprogram unit may be designated the mam program for purposes of linking (using the 
aiib63 command) provided that the subprogram has no parameters. 

Tasks initiated m imported library units follow the same rules for lerminauon as other tasks [described in 
LRM 9.4 (6-10)1. Specifically, these tasks are not icnninatctl simply because the mam program has terminated. 
Terminate altemauves in selective wait statements in library ia.sk,s ore therefore strongly recommended. 

5.9.2. Implementation of Generic Units 

■All instantiauons of genenc units, except the prctlcfincd generic •jnc:-iec:<ED_ccnvers:cn and 
L^1CHEC!<SD_DEAX,LQC.ATICN subprograms, arc implemented by code duplicauons. No attempt at shanng 
code by multiple mstanuations is made m this release oi Tanan Ada. Code shanng will be implemented in a 
later release.) 

Tartan .Ada enforces the restnetion that the body oi a generic unit must be compiled before the unit can be 
instantiated. It does not impose the restriction that the upecitlcation and body of a genenc unit must be provided 
as part of the same compilauon. A recompilation ot the body oi j genenc unit will obsolete any units that 
instanaated this genenc unit. 


5-10 




APPENDIX ?TO MIL-STD-IS15A 


5.9.J, Implementation~Defined Characteristics in Package STANDARD 
The impiementation-dcpendem characteristics in package STANDARD [Annex C] are: 
package STANDARD Is 

type 3TTS_INTSGcR is range -123 . . 127; 

type SHORT INTEGER is range -32753 .. 32757 ; 

type INTEGER is range -2_147_433_54a . . 2_147_433_547; 

type nOAT is digits a range -15 + 0.7 =t?_~“ 3 4£-^32 .. 15 + 0.7???_rr9#S-r32 ; 

type DONG EDOAT is digits 3 range -15 + 0.75TF_r?rE_:~"r_?E#E-255 .. 

“5+0.7--T_?E-~_rrEr rEa+E-2S5 ; 
type DURATION is delta 3.0001 range -36400.0 .. 36400.0; 

— DURATION'SMADD = 2+1.0+E-14 (chac i3, 5.103515E*- see) 

end STANDARD; 

5.9.4. Attributes of Type Duration 

The type DURATION is denned with ihe following charactenstics: 

DURATION' DELTA is 0.0001 .SCC _ 

DURATION' SMALL is 6.103516E'^' sec 
DURATION' riRST is -86400.0 sec 
DURATION' LAST is 36400.0 scc 

5.9.5. Values of Integer Attributes 

Tartan Ada supports the predetmed integer types INTEGER. 3 HCRT_:ntsGSR and 3TTS_INTSGER. The 
range bounds of the predciined type INTEGER arc: 

INTEGER' FIRST = -I—jl 
INTEGER' LAST = I'-jl-l 

SHORT INTEGER'EIRST =-2—15 

3hgrt“integer' last = 2" I 5-1 

3YTE_INTEGER' FIRST = -128 
3YT£_INTEGER'LAST * 127 

The range bounds for subtypes declared m package TEXT_I0 are: 

COUNT' FIRST =0 

COUNT'LAST * INTEGER'LAST - I 

?OSITIVE_COUNT'FIRST = 1 
?OSITIVE_COUNT'LAST sINTEGER' LAST - 1 

FIELD' FIRST = 0 
FIELD'LAST = 20 

The range bounds for subtypes declared m packages DIRECT_1C are: 

COUNT'FIRST a 0 

COUNT'LAST = INTEGER' LAST 

?03ITIVE_COUNT'FIRST = 1 
?CSITIVe”C0UNT' last = COUNT' LAST 


5-11 











USER MANUAL FOR TARTAN AOa ULTRDC.MK 


5.9.6. Values of Floating-Point Attributes 

Taitan Ada supports the predefined floating-point types 
Attribute 

DIGITS 

MANTISSA 

SMAX 

S?SIICN 

approximately 

SMALL 

approximately 

large 

approximately 

SAFS_EMAX 

SAcS_3MALL 

approximately 

SArE_LARGE 

approximately 

riRST 

approximately 

LAST 

approximately 

machine_radix 

MACHINE_MANTI3SA 
MACHINE_£MAX 
MAGHINE_EMIN 
I-IACHINE RCCNDS 


z .-OA * and mONG z 4.^v. 
Value for "LOAT 

6 

21 

3-t 

16»*0.I(X)0 000#E-t 
9.5367-IE-07 

IfWl.SOOO 000#E-21 
2.53-i9AE-;6 

l6^«).FFrr FS0»E-r:i 
i.93-i:sE-:5 

126 

1640.2000 000#E-31 
5.37“a7E.39 

164O.3FFF_FE0#E+j2 

S.;(rn6Ei-37 

.|640.-FrF_FFOEf3 

-'.-O'-tlE-jS 

ln40."FrF_FFC.4E-3: 

i.’nuiE+Js 

11 

126 

-126 

TRUE 


MACHINE DVERFLCWS 




appendix r TO MIL STD-lSiiA 


Attribute 

DIGITS 

MANTISSA 

SMAX 

S?SIION 
approximately 

SMALL 

approximately 

LARGE 

approximately 

3ArE_EMAX 

3AcE_SMALL 

approximately 

3A?E_LARGS 

approximately 

riRST 

approximately 

LAST 

approximately 
MACHINE_RADIX 
MACHIN£_MANT13 SA 
MACHINE_EMAX 
MACHINE_EMIN 
MACHINE ROUNDS 


' MACHINE OVERELCWS 


Value for LONG riCAT 

15 

53 

Z&l 

16#0.-tOOO_0000_0000_000#E-12 
«.S8lTSil970013E-16 

: &f0. SCOO_OOCO_r)000_iXO#E -51 
1.94^6922743 316E-62 

16^.FFFF_FFFF_FFFF_EOO#E-t-51 
:.5711008708143E^ I 

1022 

!6^-).:000 000()jX)00_000#E-255 
1.1125369292536.308 

16#0.3FFF FrFr_rrrF_F80#E-f:56 
4.0942328371557E^307 

-16*0.7FFr FFFr .FFFF_FEjfE*256 
•8.988465674312E•^307 

16i*(')." FFF _ FFrF _?FFF_FE0# E f 25 6 
8.9XS4656743115E-307 

51 

1022 
- 11)22 


5-i: 






TEST PARAMETERS 


APPENDIX C 
TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, such 
as the maximum length of an input line and invalid file names. A test that 
makes use of such values is identified by the extension -TST in its file 
name. Actual values to be substituted are represented by names that begin 
with a dollar sign. A value must be substituted for each of these names 
before the test is run. The values used for this validation are given 
below. The use of the operator signifies a multiplication of the 
following character, and the use of the character signifies 

concatenation of the preceeding and following strings. The values within 
single or double quotation marks are to highlight character or string 
values: 

Name and Meaning Value 

$ACC_SIZE 32 

An integer literal whose value 
is the number of bits sufficient 
to hold any value of an access 
type. 

SBIG_ID1 239 * 'A' & '1' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID2 except 
for the last character. 

$BIG_ID2 239 * 'A' & '2' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID1 except 
for the last character. 

$BIG_ID3 120 * ’A’ i '3' 4 119 * 'A' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID4 except 
for a character near the middle. 




TEST PARAMETERS 


Name and Meaning Value 

$BIG_ID4 120 * 'A' & '4' & 119 * 'A' 

An identifier the size of the 
maximum input line length which 
is identical to SBIG_ID3 except 
for a character near the middle. 

$BIG_INT_LIT 237 * 'O' & "298" 

An integer literal of value 298 
with enough leading zeroes so 
that it is the size of the 
maximum line length. 

$BIG_REAL_LIT 235 * 'O' & "590.0" 

A universal real literal of 
value 690.0 with enough leading 
zeroes to be the size of the 
maximum line length. 

$BIG_STRING1 ”” & 120 * 'A' & "" 

A string literal which when 
catenated with BIG_STRrNG2 
yields the image of BIG_ID1. 

$BIG_STRING2 '"' & 119 * 'A' & '1' & "" 

A string literal which when 
catenated to the end of 
BIG STRINGl yields the image of 

bigIidi. ■ 

$BLANKS 220 * ’ ' 

A sequence of blanks twenty 
characters less than the size 
of the maximum line length. 

SCOUNT_LAST 2147483646 

A universal integer literal 
whose value is TEXT_IO.COUNT'LAST, 

$DEFAULT_MEM_SIZE 1_000_000 

An integer literal whose value 
is SYSTEM.MEMORY_SIZE, 

SDEFAULT_STOR_UNIT 8 

An integer literal whose value 
is SYSTEM.STORAGE UNIT. 





TEST PARAMETERS 


Name and Meaning Value 

$DEFAULT_SYS_NAME MC68000 

The value of the constant 
SYSTEM.SYSTEM_NAME. 

$DELTA_DOC 2#1.0#E-31 

A real literal whose value is 
SYSTEM.FINE_DELTA. 

SFIELD_LAST 

A universal 

literal whose 

TEXT_IO.FIELD'LAST. 

SFIXED_NAME THERE_IS_NO_SUCH_FTXED_TY?E 

The name of a predefined 
fixed-point type other than 
DURATION. 

$FLOAT_NAME THERE_IS_NO_SUCH_FLOAT_TYPE 

The name of a predefined 
floating-point type other than 
FLOAT, SHORT FLOAT, or 

LONG_FLOAT. 

$GREATER_THAN_DURATTON 100_000.0 

A universal real literal that 
lies between DURATION'BASE’LAST 
and DURATION'LAST or any value 
in the range of DURATION. 

$GREATER_THAN_DURATION_BASE_LAST 100_000_000.0 

A universal real literal that is 
greater than DURATION'BASE'LAST. 

SHIGH^PRIORITY 200 

An integer literal whose value 
is the upper bound of the range 
for the subtype SYSTEM.PRIORITY. 

$ILLEGAL_EXTERNAL_FILE_NAME1 /M0N_EXISTENT_DIRECT0RY1/FILE1 

An external file name which 
contains invalid characters. 

$ILLEGAL_EXTERNAL_FILE_NAME2 /NON_EXISTENT_DIRECTORY2/FILE2 

An external file name which 
is too long. 


20 

integer 
value is 






TEST PARAMETERS 


Marne and Meaning 
$INTEGER_FIRST 

A universal integer literal 

whose value is INTEGER'FIRST. 

$INTEGER_LAST 

A universal integer literal 

whose value is INTEGER'LAST. 

$INTEGER_LAST_PLUS_1 

A universal integer literal 

whose value is INTEGER'LAST + 1. 

$LESS_THAN_DURATION 

A universal real literal that 
lies between DURATION'BASE'FIRST 
and DURATION'FIRST or any value 
in the range of DURATION. 

$LESS_THAM_DURATIOM_BASE_FIRST 

A universal real literal that is 
less than DURATION'BASE'FIRST. 

SLOW_PRIORITY 

An integer literal whose value 
is the lower bound of the range 
for the subtype SYSTEM.PRIORITY. 

$MANTISSA_DOC 

An integer literal whose value 
is SYSTEM.MAX.MANTISSA. 

$MAX_DIGITS 

Maximum digits supported for 
floating-point types. 

$MAX_IN_LEN 

Maximum input line length 
permitted by the implementation. 

SMAX_INT 

A universal integer literal 
whose value is SYSTEM.MAX_INT. 

SMAX_INT_PLUS_1 

A universal integer literal 
whose value is SYSTEM.HAX_INT+1. 


Value 

-2147483648 

2147483647 

2147483648 

- 100 _ 000.0 

- 100 _ 000 _ 000.0 

10 

31 

15 

240 

2147483647 

2147483648 




TEST PARAMETERS 


Name and Meaning Value 

$MAX_LEN_INT_BASED_LITERAL "2;" & 235 * '0' & "11;" 

A universal integer based 
literal whose value is 2#11# 
with enough leading zeroes in 
the mantissa to be MAX_rN_LEN 
long. 

$MAX_LEN_REAL_BASED_LITERAL "16:" & 233 * 'O' & "F.E: 

A universal real based literal 
whose value is 16:F.E: with 
enough leading zeroes in the 
mantissa to be MAX_IN_LEN long. 

$HAX_STRING_LrTERAL ' & 238 * 'A' & "" 

A string literal of size 
MAX_IN_LEN, including the quote 
characters. 

$MIN_INT -2147483648 

A universal integer literal 
whose value is SYSTEM.MIN_INT. 

SMIN_TASK_SIZE 32 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
no entries, no declarations, and 
"NULL;" as the only statement in 
its body. 

$NAME BYTE_rNTEGER 

A name of a predefined numeric 
type other than FLOAT, INTEGER, 

SHORT^FLOAT, SHORT_INTEGER, 

LONG_FLOAT, or LONG_INTEGER. 

$NAME_LIST MC68000 

A list of enumeration literals 
in the type SYSTEM.NAME, 
separated by commas. 

SNEG_BASED_INT 8#777777777776# 

A based integer literal whose 
highest order nonzero bit 
falls in the sign bit 
position of the representation 
for SYSTEM.MAX INT. 





TEST PARAMETERS 


Name and Meaning 
SNEW_MEM_SIZE 

An integer literal whose value 
is a permitted argument for 
pragma MEMORY_SIZE, other than 
$DEFAULT_MEM_SIZE. If there is 
no other value, then use 
$DEFAULT_MEM_SIZE. 

$NEW_STOR_UNIT 

An integer literal whose value 
is a permitted argument for 
pragma STORAGE_UNIT, other than 
$DEFAULT_STOR_UNIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGE_UNIT. 

$NEW_SYS_NAME 

A value of the type SYSTEM.NAME, 
other than $DEFAULT_SYS_NAME. If 
there is only one value of that 
type, then use that value. 

$TASK_SIZE 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
a single entry with one 'IN OUT' 
parameter. 

STICK 

A real literal whose value is 
SYSTEM.TICK. 


Value 
1 000 000 


3 


MC68000 

96 


0.01 



APPENDIX D 


WITHDRAWN TESTS 

Some tests are withdrawn from the ACVC because they do not conform to the 
Ada Standard. The following 44 tests had been withdrawn at the time of 
validation testing for the reasons indicated. A reference of the form 
Al-ddddd is to an Ada Commentary. 

a. E28005C This test expects that the string "— TOP OF PAGE. 

63" of line 204 will appear at the top of the listing page due 
to a pragma PAGE in line 203; but line 203 contains text that 
follows the pragma, and it is this that must appear at the top 
of the page. 

b. A39005G This test unreasonably expects a component clause to 

pack an array component into a minimum size (line 30). 

c. B97102E This test contains an unitended illegality: a select 

statement contains a null statement at the place of a selective 
wait alternative (line 31). 

d. C97116A This test contains race conditions, and it assumes that 
guards are evaluated indivisibly. A conforming implementation 
may use interleaved execution in such a way that the evaluation 
of the guards at lines 50 & 54 and the execution of task CHANGING- 
_OF_THEjGUARD results in a call to REPORT.FAILED at one of 
lines 52 or 56. 

e. BC3009B This test wrongly expects that circular instantiations 
will be detected in several compilation units even though none of 
the units is illegal with respect to the units it depends on; by 
AI-00256, the illegality need not be detected until execution is 
attempted (line 95) . 

f. CD2A62D This test wrongly requires that an array object's size 
be no greater than 10 although its subtype's size was specified 
to be 40 (line 137) . 

g. CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] These 
tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them 
to a derived subprogram (which implicitly converts them to the 
parent type (Ada standard 3.4:14)). Additionally, they use the 
'SIZE length clause and attribute, whose interpretation is 
considered problematic by the WG9 ARG. 





WITHDRAWN TESTS 


h. CD2A81G, CD2A83G, CD2A84N & M, & CD5011O [5 tests] These tests 

assume that dependent tasks will terminate while the main pro¬ 
gram executes a loop that simply tests for task termination; this 
is not the case, and the main program may loop indefinitely 
(lines 74, 85, 86 & 96, 86 & 96, and 58, resp.). 

i. CD2B15C & CD7205C These tests expect that a 'STORAGE_SIZE 
length clause provides precise control over the number of 
designated objects in a collection; the Ada standard 13.2:15 
allows that such control must not be expected. 

j. CD2D11B This test gives a SMALL representation clause for a 
derived fixed-point type (at line 30) that defines a set of 
model numbers that are not necessarily represented in the 
parent type; by Commentary AI-00099, all model numbers of a 
derived fixed-point type must be representable values of the 
parent type. 

k. CD5007B This test wrongly expects an implicitly declared sub¬ 

program to be at the the address that is specified for an un¬ 
related subprogram (line 303). 

l. ED7004B, ED7005C & D, ED7006C & D [5 tests] These tests check 

various aspects of the use of the three SYSTEM pragmas; the AVO 
withdraws these tests as being inappropriate for validation. 

m. CD7105A This test requires that successive calls to CALENDAR.- 

CLOCK change by at least SYSTEM.TICK; however, by Commentary 

Ar-00201, it is only the expected frequency of change that must 
be at least SYSTEM.TICK—particular instances of change may be 
less (line 29). 

n. CD7203B, & CD7204B These tests use the 'SIZE length clause and 

attribute, whose interpretation is considered problematic by 
the WG9 ARG. m 

o. CD7205D This test checks an invalid test objective: it treats 

the specification of storage to be reserved for a task’s 
activation as though it were like the specification of storage 
for a collection. 


p. CE2107I This test requires that objects of two similar scalar 
types be distinguished when read from a file—DATA_ERROR is 
expected to be raised by an attempt to read one object as of 
the other type. However, it is not clear exactly how the Ada 
standard 14.2.4:4 is to be interpreted; thus, this test objective 
is not considered valid, (line 90) 



WITHDRAWN TESTS 


q. CS3111C This test requires certain behavior, when two files are 

associated with the same external file, that is not required by 
the Ada standard. 

r. CE3301A This test contains several calls to END_OF_LINE & 
END_OF_PAGE that have no parameter: these calls were intended 
to specify a file, not to refer to STANDARD_rNPUT (lines 103, 
107, 118, 132, & 136). 

s. CE3411B This test requires that a text file's column number be 

set to COUNT'LAST in order to check that LAYOUT_ERROR is raised 
by a subsequent PUT operation. But the former operation will 

generally raise an exception due to a lack of available disk 

space, and the test would thus encumber validation testing. 





Chapter 3 

Compiling Ada Programs 


The ;:ada63 command is used lo compile and assemble Ada compilation units. 

3.1. THE cada63 COMMAND FORMAT 

The cadaoS command has this format: 

ca<la€d {option.^] file... [option...] 

Arguments that stan with a hyphen are interpreted as options; otherwise, they represent filenames. There 
must be at least one filename, but there need not be any opuons. Options and filenames may appear in any order, 
and all opuons apply to all filenames. For on explanation of the available opnons. see Section j2. 

If a source file does not reside in the directory in whic.h the compilaaon takes place./T/e must include a path 
sufficient to locate the file. It is recommended that only one compilation unit be placed in a file. 

Files ore processed in the order in which they appear on the command line. The compiler sequentially 
processes all compilation units in each file. Upon successful compilation of a unit: 

• the Ada program library ada. db is updated to reflect the new compilation time and any new dependencies 

• one or more separate compilation files and/or object files are generated 

If no errors are detected in a compilation unit. tada63 produces on object module and updates the library. If 
any error is detected, no object code file is produced, a source listing is produced, and no library entry is made for 
that compilaaon unit. If warnings are generated, both an object code file and a source listing ate produced. For 
further details about the process of updating the library, files generated, replacement of exisdng files, and 
possible error conditions, see Sections 3.3 through 3.6. 

The output from cada63 is a file of type . scoff or . cof f. for a specitlcauon or a body unit respectively, 
containing object code. Some other files are left in the direcajry as well. See Secuon 3.-* for a list of extensions 
of files that may be left in the directory. 

3.2. OPTIONS 

Comttuind line opuons indicate special acuons to be performed by the compiler or special output file 
properties. 

The following command line options may be used: 

-a Generate an assembly code tile. The assembly code tile has on extension . a or .as 

(see Section 3.-i>. 

-g Output debugging mfotmaaon. 

Cause compiler to omit data segments with the text of enumeranon literals. This text 
is normally produced for exported enumerauon types m order lo s'Upport the 
' IMAGE aitnbme. You should use -i only when you can guarantee that no unit 
that will import the enumerauon type will use ’ i.magE. However, if you are 
compiling a unit with an enumerauon type that is not visible to other compilation 
units, this option is not needed. The compiler can recognize when ' IMAGE is not 
used and will not generate the supporting stnngs. 


3-1 









USER MANUAL FOR TARTAN ADA ULTRIX/68K 


-La Generate a listing, even if no errors were found. The default is \o generate a listing 

only if an error is found. 

-Ln Never generate a listing. The default is to generate a listing only if an error is found. 

-n-n Stop compilation after n errots have been detected. 

-Opa Control the level of opamiradon performed by the compiler, requested by n. The 

opdmizadon levels available are: 

n = 0 Minimum - Performs context determinadon, constant folding, al¬ 
gebraic manipuladon. and short circuit analysis. 

n = I Low - Performs level 0 opdmizadons plus common subexpression 
eliminadon and equivalence propagaDon within basic blocks. It 
also optimizes evaluadon order. 

n = 2 Space - This is the default if none is supplied. Performs level 1 
opdmizadons plus flow analysis which is used for common sub¬ 
expression eliminadon and equivalence propagaaon across basic 
blocks, ft also penbrms invariant expression hoisong, dead code 
elimmadon. and assignment lolling. Level 2 also performs lifenme 
analysis which is used to improve register ailocadon. It also per¬ 
forms inline expansion of subprogram calls indicated by Pragma 
INLINE which appears in the same compiiadon uniL 

n = 3 Time - Performs level 2 opdmizadons plus inline expansion of 
subprogram calls which the optimizer decides are profitable to ex¬ 
pand (from an execudon dme perspecuve). Other opdmizadons 
which improve execudon dme at a cost to image size are per¬ 
formed only at this level. 

-V Print out compiler phase names. The compiler pnnts out a short descripdon of each 

compiiadon phase m progress. 

-q Do not print out compiler phase names. 

-w Suppress warning messages. 

~S C ACOEILORSZ1 Suppress the given set of checks: 

A ACCSSS_CHEC:< 

C CONSTRAINT CHECK 

0 DISCRIMINANT CHECK 

S SLABORATICN CHECK 

1 INDEX ZHZC:<~ 

L LSNGrH_CHECK 

0 OVERFLOW CHECK 

R .RANGE CHECK 

S STORAGE CHECK 

2 "2ERO"D':vISICN_CHECK 

The -3 opdon has the same effect as a global pragma SUPPRESS applied to the 
source file. If the source program also contains a pragma SUPPRESS, then a given 
check is suppressed if either the pragma or the switch specifies it; that is. the effect 
of a pragma SUPPRESS cannot be negated with the command line opuon. See 
LRM 11.7 for further details. Examples are: 

-soz Suppress ovsrflow_check and •• zero '‘D :visicn_ckec:<. 

-S Suppress all checks. 

-SC Suppress C0NSTRAINT_2RRCR. equivalent to -SADILR. 


3-2 




COMPUJ^G ADa programs 


-X Cause the compiler to generate a cross reference fUe containing entries of ’he form 

Ada-name^>linkname at line 

This option will allow users to find the linJcname generated for the given Ada-namg, 
and use linkname to set breakpoints in debuggers. The file will have the extension 
. ;crf (See Section 3.3). 

In addition, the output from the compiler may be redirected using the redirection facility including ‘s’ for 
aclerr; for example 

% ttadaoR cax_3pec . ada >5 cax_3pec . c:ca 

3 J. WHAT UPDATES ARE MADE TO THE PROGRAM LIBRARY 

Simply stated, upon successful comptladon of a unit. 

• the Ada program library ada. db is updated to reflect the new compilauon time and any new dependencies 

• one or more separate compilation files and/or object files are generated. 

However, more complicated situations can arise. The following items list the types of compiladon unit and 
address the range of sioiadons that can arise. 

• In all cases the rransitive closure of the dependencies of a compilauon unit in the library must be consis¬ 
tent that is. the unit must be compiled consistently as defined in secuon 10.3 of the LRM. A secondary 
unit can have its specification in its context clause, although it >s redundanu For a more complete 
discussion of closure, see Secuon d.S. 

• A package specification replaces any librarv' unit in the library with the same name, or is simply added if 
no such library unit exists. 

• A package body replaces any exisung body of a pxkage specu'icadon with the same name. If no such 

. specificauon exists, on error message is issued. If such a specificauon exists, but the body does not match 

the spectficadon in the sense of Secuon 7.1 of the LRM. error messages are issued. 

• A subprogram specification replaces any library unit in the library with the same name, or is simply 
added if no such library unit exists. 

• .A subprogram body replaces any exisung body of a (generic or non-genenc) subprogram specification 
with the same name. If no such specification exists, on implicit specificauon is derived from the body and 
entered into the library as noted above for subprogram specificauon. If a specu'icadon exists, but the body 
does not match the specificadon in the sense of Secuon 6.3 of the LRM. error messages are issued. If any 
library unit other than a subprogram specification exists with the same name, the new implicit specificauon 
replaces chat library unit 

• Generic package specifications and subprogram specifications act as explicit specifications, i.e.. cor¬ 
responding bodies must match their specificauons. If a generic unit is instanuated. a dependency is created 
on the generic body. 

• Generic insances compiled as library units are treated in the same way as their non-generic counterparts. 

• When an instantiation replaces the body of a library unit, ail secondary units of that library unit are now 
obsolete and ore deleted. 

• A subunit with a parent unit conuuntng an uppropnaie body stub exisung m the library replaces any 
subunit with the same subunit name, compnsed of the stub's name and the name of the ancestor unit, or is 
simply added, if no such subunit exists. unit containing stubs will only be entered into the library if the 
simple names of ail its stubs are unique for all stubs denved from its common ancesuar. An enor message 
is issued if no parent unit exists in the library, the parent unit exists but does not have a relevent stub, or the 
parent unit and body stub exist but the subunit does not match the stub or its specificauon. 


3-3 




USER MANUAL FOR TARTAN ADA ULTRK/SSK 


• When the parent unit of a subunit is recompiled and the parent no longer contains a stub for the subunit, 
the subuniL which is now obsolete, is deleted. 

3.4. FILES PRODUCED OR USED BY THE COMPILATION SYSTEM 

Files with the following extensions are contained in the standard paclcages directories or can be created by 
compiling or linidng an Ada program: the file name is the name of a compilation uniu but may be compressed to 
conform to length limitadons. 

bod Representauon of the body of a generic, and/or the visibility information available to 

any subunits or genenc bodies, body-name. bod is read when compiling a program that 

instantiates body-name or a genenc contained in a body-name, or is a subunit of 
body-name. 

di Representation of a unit specification, luxu-name. dc. is read during the compilation of a 

program that docs a 'with umt-name". 

Isc A listing produced by die Ada compiler. 

map A link file produced by the Tartan linker. 

3 The assembly language file produced by compiling an Ada unit body when the -a 

opdon is given. 

scoff The object file produced by compiling an Ada unit specuicadon, 

cof f The object file produced bv compiling an Ada unit body. 

.'crf Cross reference files that relate Ada names with compressed and disambiguated names 

used in the object or assembly language file. 

:tcaf An executable image created by linking a mam program. 

The following are the extensaons used for files that are created temporarily during the linking process; 

ec 0 f The elaboradon scnpt generated by the library 

iu.3 List of all object files to be linked by the linker 

Icf Control file for the linker. 

Addidonally, temporary files are created during compilaaon that have the some file extensions listed above, but 
also have a unique 3 digit hexadecimal number concatenated to the extension. Any of the above files will appear 
in the directory only if a link or compilaaon is abnotmally terminated. These files should then be deleted by the 
user. 

The parser creates several addidonal temporary files having the extensions csr. ced. csb, and cse that 
should be deleted by the user if left by an interrupted compilaaon. 

Files having the following extensions are controlled by the libmnan and compiler da., bod, toff and 
scoff. The user should not use these extensions for any other purpose. ala.b6a deiaca command will 
automaacally delete these files, when the respective unit is deleted trom the library. If the user deletes these files 
in any other way. subsequent invocations of the compiler or librarian will have unpredictable results, including 
fatal crashes. We therefore advise that the user never delete these files by operaung system commands. 

3 J. THE CROSS REFERENCE MAP OF UNKNAMES 

A cross reference of symbolic names to linknames is generated with the opuon -x to the cada63 command. 
The aosS'ieference file has the extension ..-trc: the file name is that of the compiled unit but possibly 
compressed to match restnctions. as shown in the example below. 

For longer unit*names. the cross reference file generated may not have an immediately obvious name, in 
order to find it it may be necessary to search the current working directory tor a recently produced file with 
extention :<rf. 


3-4 








COMPILING ADA PROGRAMS 


Example: 

File crBxantple_3pec. ada 

package THIS_rS_A_LQNG packags_mame is 
package another_long_?ackage_.vame is 

procedure LONG PROCEDURE NAME_THA'r_MILL HAVE_SHOR'r LINKNAME; 
end ANOTHER_LONG PACXAGeJnAME; “ 

end this_is_a_long_pac:<age_name; 

Fie crexainpia_body. ada 

package body ■rHIS_IS_A_LONG_?AC:<AGS_NAMS is 

package body ANOTHER LCNG_?ACXAGE__NAME is separata; 
end THIS_IS_A_L0NG__?AC:<AGE_NAME; 

Fie crexamcla. sep 

separate (THIS IS a_long package name) 
package body anotIier LaNG_PAC:<AGE name is 

procedure long_procsdur£_name_that_will_have_3hcrt_l:nkname is 
begin ~ ~ ~ ~ 

nuil; 

end LONG PROCEDURE NAME_THAT WILL HAVE SHORT LINKNAME; 
end ANOTHER_LONG_PACKAGE_NAME; 

The commands: 

Cada€3 crexantple^spec.ada 
tada63 crexampla^body.ada 
tada63 -x crexanmle.sep 

produce the file chssiagpckgnm, nchrlngpckgnnieOOl. xrf which appears below; 

-LinJcname Crass Reference Map thssingpcxgna.nchringpckgnaeOOl- 

Shi3__i3_3_long_pac!<age_name->xxth33)cgnm001 at 3 

_pac)cage__nanieTOO at 1 

^ti 3 _i 3 _a_long_?ackage_nameTanother_^long_package_nameTanocher_long_paclcage 
__name->another_long_package__namef00 at 2 

tha.3__i3_a_longZ?ackage_naine'fanocher_long_pac.<age_.-',araeirl3ng_proc8dure_naine 
^thac_wLli_have_3rtort_linknaffle“>xxch33(cgmi001i;ingpctdtln.<nrof00 at 3 

In the above cross reference file; 

• The first line represents the name for the elaborauon code for the package 

THIS_IS_A_LCNG_?acxage_name. The symbols representing the specification and body have 
respectively ^DECLARE and T3CDY postpended. 

• The second line is the name of the data segment for the package THr3_:3_A__LCNG_?AC:<AGS_NAME. 

• The third line is the name of the data segment for the package ancthsr_lcng_?acxags_name. 

• The name for the LONG_?RCCSDUR£_NAMS_THAr_wiLL_HAVS_3HCRT_LINKNAME procedure is on 
the fourth line. 

• The fifth line is the name for the elaboration vanabie for the procedure 

LONG_?RCCEDURS_NAME_THAT_WILL_;-iAVS_3HORT_LINKNAME. Ada rules require that the body 
of a subprogram is already elaborated before it can be called. If it is not already elaborated the exception 
?RCGRAM_SRRCR must be raised. For exh subprogram ihai may require an elaboration check the 
compiler generaies a vanabie that is used to record dtat the body of die subprogram has been elaboraied. 
The name of the eiaborauon vanabie is generated by posq^ending TGCTC to the name of the subprogram. 
The eiaborauon variable name is then subjxt to the same compression aigonthms as the rest of the 
symbols in the program. 


3-5 



USER MAXUAL FOR TARTAX .\Da ULTRIX/6SK 


The ULTRIX command 
is -it *.xrf 

will help you locate the cross reference listing. In order to view the contents of the cross reference file, make 
sure that your terminal is set to wrap around mode. The identifier appearing at the left is the idendfier that 
appears in the Ada source code. The name to the right of the '•>’ is the linkname that is supplied for that 
idendfier to id. The “at <7iumder>" gives the line number in the source code where the idcndSer is found. 
A Cross Reference Map can be used to verify that there ore no conflicting linknames in a program library that 
uses subprograms written in another language (see Secdon 5.12.2 that discusses the pragma S'0REiaN_30D'!f). 
It is also useful for assembly-level debugging. 

3.6. COMPILER DIAGNOSTIC MESSAGES 

The compiler and library issue diagnostic messages that appear at your termmal and in the opdonal comptler- 
generaied Usdng. Most messages issued by Tanan Ada UI.TR1X/68K contain a reference to the Ada LRM 
secdon and paragraph relevant to the error. This secdon explains the Icinds of diagnosdc messages that are 
generated, how the compiler attempts to deal with problems that caused the messages and how you should go 
about correcting a program. 

A comprehensive lisdng of all the messages the compiler can issue is contained in Appendix Secdon A.1. A 
similar lisdng of all the messages the library can issue is contained in Appendix Secdon A2. 

2.6.1. Message Severity Levels 

Every message issued by the compiler is assigned a seventy level that indicates how serious the problem is. 
There are four message categories. 

1. Afatai error is serious enough to suspend compilation immediately after the error is discovered. This is 
the only class of error that inhibits further analysis of the source program. An example of a fatal error 
message (in this case from the library) is: 

Fatal 6301; <iibrary administration file name> iS i.^ccrapaciola 
wit.h c.his version of c.he liorary. 

2. An error is serious enough to prevent the generadon of object code, but the compiler attempts to recover 
from the error and condnues checking the source for addidonal errors. An e.xample of an error is: 

Error 2060: This record field has already seen assigned 
in Che aggregate (4.3 (6)) 

3. A warning does not stop the compiler from geneiaung object code, but may sail be an indicadon of a 
programming error. When a warning occurs, the code generated may not be what you intended. An 
example of a warning is: 

* Warn 4001: Elaboration of t.his subtype will raise ron3Cr3i.".t_9rror 
at runtime (3.3.2). 

■1. An informaaonai message provides you with addidonal mformaaon when you use some library com¬ 
mands (see, for example, Secdon -t.6). Informauonai messages are issued only by the library, not by the 
compiler. An example of on informauonai message is: 

I.nfo 6011: The files required for linjci.ng ay <unit_<ind> 

<unitjume> are consistent (10.3). 

3.62. Message Formats 

The format of messages appearing on the standard error output and in the lisung tile is similar. Here is an 
example: 


3-6 






COMPILrvC ADA PROGRAMS 


51 3l : atringd .. discr:..-a) ; 

61 s2 : string(1 .. 2 • discria); 

^ 1 

*** I Error 2204: A discriminant may not be used in this 
*** expression (3.7.1 (6)) 

71 end record/ 

The numbered lines in the example are lines from the source program. The source line in question is followed by 
the messages atKi pointers to the exact location of the problem. 

On the terminal, horizontal lines are used to separate messages coming from different parts of the source 
program, for example: 

51 si : stringd .. discrtm) ; 

SI s2 : stringd .. 2 • discri.m) ; 

/% ^ 

1 Error 2204: A discriminant may not be used 
••• in this expression (3.7.1 (S)) 

71 end record; 


141 null; 

131 when .numeric error I constrai.nc error -> 

” ^1 “ 

»»» 1 Error 3112: A given exception may only appear once 

»*• in a handler (11.2 (5)) 

IS I null; 

In a listing file, a message chain xcompanies each diagnostic message. The message chain indicates where 
in the program the next and previous messages occur, for example: 


3-7 



USER MANUAL FOR TARTAN ADA ULTRIX/68K 


Ada ULTRIX/S3K INT-2 Copyright 1989, Tartan Laboratortas Incorporated. 
•** First diagnostic is on line 6 
11 procedure 3ainpia_program is 

21 subtype small int is integer range 1 .. 10; 

31 

41 type rec(discrim ; 3mall_inc) is record 
51 si : stringd .. di^crim) ; 

SI 32 : stringd .. 2 • discrim); 

‘1 

*** 1 Error 2204: A discriminant may not be used rn this 

*»* expression (3.7.1 (S)) 

*•» Next diagnostic is on line 15 
7 1 end record; 

31 

91 X ; rec (5) ; 

101 begin 

111 X :* (6, '•12345'', "abcde") ; 

12 I exception 

13 I when constraint error »> 

141 null; 

151 when numeric_error | conscraint_error »> 

»»* Previous diagnostic was on li.ne 6 

*** 1 Error 3112: A given axceotion may only aooear once 

•»* in a handler (11.2 (5))' 

IS I null; 

17 I end samole orogram; 

131 “■ 

*** Last diagnostic was on line 15 

**• Errors: 2, Warnings: 0 
The message chain is especially helpful when working with large lisungs. 

Whether on the standard error output or in a lisung file, the list of messages is followed by a summary line 
containing a count of the number of errois in each seventy class, for example: 

? Errors: 2, Warnings: 1 

3.6.3. Message Generation 

Tartan Ada ULTRIX/68K has many internal phases, any one of which con issue diagnostic messages. .Mes¬ 
sages are collected in memory until the ume comes to generate the message lisung. At that time, all the messages 
are sorted by their posidon in the source program and ore pnnted. 

When you examine a program listing conuumng many messages, remember that the order in which the 
messages appear in the lisung is not necessarily the order in which the messages were generated. This fact may 
be important when one error causes another. It is advisable to start correcung your program according ua the 
messages having the lowest numbers and work towards the higher numbers, making an intermediate compilauon 
if necessary. 

3.6.4. About Syntax Errors and Recovery 

Tanan Ada ULTRIX/68K incorporates a parser which is capable of analyzing and correcnng all syntactic 
erron in the source program. This secUon descnbes the various error messages that may be issued by the parser. 
When a syntax error is detected, no object code is generated. 

The parser divides the source program text into lexical elements, or tokens, such as idenUfiers, reserved 
words, constants, etc. When the parser encounters a token that it does not expecL it issues an error message that 





COMPIXJNC ADA PROGRAMS 


indicates the position at which the error was detected and the action that was token to correct the enor. Here are 
some examples of the recovery actions: 

In the example below, the trailing “S” does not match any of the valid tokens of Ada and so the parser 
deletes it. 

II procedure bad_3yncax is 

2\ subtype byte is integer range 0 .. 253; S 

•** 1 Error 104: ril-fomed token deleted. 

31 X : integer; 

The compiler also deletes a token occupying an inappropriate place. In the following e.Tampie, it deletes the 
superfluous token “while”. 

3 1 begin 

61 far while i in I .. 10 loop 

A 5 

•** 1 Error 121: Parse error; token deleted. 

7 I X : - X 1 ; 

In the following example, the missing symbol is inserted, and parsing condnues undisturbed. 

41 i : integer 

51 b : boolean; 

1 Error 120: Parse error; token inserted. 

51 begin 

In the following example, the syntacdcally incorrect symbol is replaced by the proper symbol 

17 I end looo; 

181 X 15: 

■» ^ 

1 Error 122: Parse error; this token deleted, " inserted. 

191 

3.6.4.J. yfulti’Token Insertion 

The parser may also insert several tokens in an aaempt to repair the constructs whose closing tokens (e.g.. 
“end if;”) are missing. An example of this recovery is: 

10 I end if; 

III end looo; 

"1,2,3 

1 Error 120; Parse error; token "if” inserted. 

2 Error 120: Parse error; token i.nserted. 

*»* 3 Error 120; Parse error; token "end" inserted. 

12 1 end bad_oroc; 

In this example an addidonai “end if; ” was missuig. .Note, however, that the maximum number of 
tokens that can be inserted in succession is limited. 

3.6.4 J. Complex Recovery SPruefy 

If all the simple fix-up and mulu-ioken inseraon techniques above ore unsuccessful, the parser attempts a 
more massive corrccaon by deiedng many successive or preceding phrases of the program. Foe example. 

51 y 5; case bad_ta3e -s 

S* wnere :c"y -> :t ;« 3; 

1 Error 123: Parse error; lii-fomed "<stacement>". 

7* when 2 x - 3; 

The caret (^) locates the place where the parser detects an error. The compiler indicates the elided pordon of 
the source pro g ram by underlining with asiensks. In the first (and possibly the last line), only the tokens deleted 


3-9 







USER MANUAL FOR TARTAN ADA UXIRDC/SSK 


are underlined. The lines following the first line are not underlined, but when the enure line is deleted, the 
symbol after the line number (e.g., lines 6 and 7) changes from a vertical bar (I) to an asterisk. (The above case 
statement contained three enors. The closing “end case; “ was also deleted.) 

In liics the above example, when the parser has deleted more than one token, the eiror message is 
Error 123: Parse error; ill-formed “<name>". 

The name contained within the angle bracket pair is that of the giammadcai element that the parser expected to 
find in this position. Occasionally, the deledon of tokens starts at a point texmally preceding the reported error 
because no legal interpretadon of an enclosing construct can be found due to the error within the construct. 

Under rare circumstances, you may see an error message 
Error 127: Parse error; unexpecced end-of-file. 
pointing to a token within the program, with the rest of the program marked as deleted. This message points to 
the position in the program where the paner detected a syntax error. It indicates that, despite all attempts, the 
error recovery was unsucessfiil undl the end-of-file was reached. In this case, correct all the errors reported and 
examine the program for missing keywords that end complicated syntacdc constructs: also, especially examine 
the few lines that precede and follow this message for syntacdc errors. 


I 


3-10 




LSER MANUAL FOR TARTAN ADA ULTRIX/63K 




4.8. THE link SUBCOMMAND 

The linlc command checks that the unit within the library specified by the user has the legal form for a main 
unit, checks that all its dependencies are consistenu finds all required object files, and links the main p ro gr am 
with its full closure (See Section 4.5) producing an executable image. The format of the link command is 

aXil363 link ^option...] Ada-name [option...] 

where the Ada-name specifies the unit in the library to be made the main program. 

The following opuons may be used: 

-c Provide a trace of the load command indicating what files are being loaded 

-K Create a shell script file that may be redirected to sh to cause the Ada program to be linked. The 
user assumes full responsibility for the consistency of the program when this script is run instead 
of using the alib6a link command. 

-M Provide a load map 

-o filename 

Name the final oucpui file from the loader filename 


4-10 






