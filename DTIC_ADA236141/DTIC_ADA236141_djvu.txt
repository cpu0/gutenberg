MTATION PAGE 


Form Approved 
OPM No. 0704-01B8 


AD-A236 141 


hour per reapome. includir^g ihe time tor re\^e«ring inetruclione. seerehing existing data sources gathering and mainiaining ttte data 
lie burden estimaie or any other aspect of this colection of information. Including suggestions tor reducing this burden, to Washing 
Jefferson Davis Highway. Suite 120C. Arlington. VA 222024302. and to the Office of Information and Regulalory Attain. Office of 


*ORT DATE 


3. REPORT TYPE AND DATES COVERED 
Final: 15 Aug 1990 to 01 Mar 1993 


4. TITLE AND SUBTITLE 

Alsys Limited, Atsyconp_037, Version 5.2, INMOS T800 transputer on a B405 
TRAM (bare) with an INMOS BOOS (Host) to INMOS T800 transputer implemented 
on a B405 TRAM (bare), using an IBM PC/AT (Target), 901114N1.11065 


6. AUTHOR(S) 

National Computing Centre Limited 
Manchester, UNITED KINGDOM 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

National Computing Centre Limited 
Oxford Road 
Manchester Ml 7ED 
UNITED KINGDOM 


9, SPONSORING/MONITORING AGENCY NAME{S) AND ADDRESS(ES) 

Ada Joint Program Office . 

United States Department of Defense . v 

Washington, D.C. 20301-3081 



0. PERFORMING ORGANIZATION 
REPORT NUMBER 

AVF VSR 90502/75-910403 


10. SP0NS0RINGA40NIT0Rir*3 AGENCY 
REPORT NUMBER 


11, SUPPLEMENTARY NOTES 




12a. DISTRIBUTION/AVAILABILITY STATEMENT 

Approved for public release; distribution unlimited. 


12b. DISTRIBUTION CODE 


13. ABSTRACT (Maximum 200 words) 

Alsys Limited, Alsycomp_037, Version 5.2, Manchester England, INMOS T800 Transputer on a B405 TRAM (bare) with an 
INMOS BOOS Communications link implemented in an IBM PC/AT (under MS-DOS 3.1 and INMOS Iserver V1.3)(Host) to 
INMOS T800 transputer implemented on a B405 TRAM (bare), using an IBM PC/AT under MS-DOS 3.1 running INMOS 
Iserver 1.3 for file-server support via an INMOS BOOS board link (Target), ACVC 1.11. 


14 SUBJECT TERMS 


Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. OHice, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17 SECURITY CLASSIFICATION 
OF RcrCTiT 

UNCLASSIFIED 


18. SECURITY CLASSIFICATION 


UNCLASSIFED 


19. SECURITY CLASSIFICATION 
OF ABSTR ACT 

UNCLASSIFIED 


15. NUMBER OF PAGES 


16. PRICE CODE 


20. LIMITATION OF ABSTRACT 


NSN 7540-01-280-550 


Standard Form 298, (Rev 2-89) 
Prescribed by ANSI Std. 239-128 

















AVF Control Number AVF VSR 90502^5-910403 


Ada COMPILER 

VALIDATION SUMMARY REPORT: 

Certificate Number #901114N 1.11065 
Alsys Limited 
Alsycomp_037 Version 5.2 

INMOS T800 transputer on a B405 TRAM (bare) with an 
INMOS BOOS Communications link implemented in an IBM PC/AT 
(under MS-DOS 3.1 and INMOS Iserver V13) 

INMOS T800 transputer implemented on a B405 TRAM (bare), 
using an IBM PC/AT under MS-DOS 3.1 running INMOS Iserver 1.3 for 
file-server support via an INMOS BOOS board link 


V' 

Prepared by 
Testing Servian 

The National Computing Centre Limited 
Oxford Road 
Manchester 
Ml TED 
England 


VSR Version 90-0S-15 


AVF_VSR_90502/75 
AlsyCOMP_037 Version 5.2 


VnlKlaUon Summary Report 
Alsys Limited 



I -. — 

i 

i 



!{\-\ 

! 







TABLE OF CONTENTS 


TABLE OF CONTENTS 

CHAPTER 1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT. 1 

1.2 REFERENCES . 1 

1.3 ACVC TEST CLASSES . 2 

1.4 DEFINITION OF TERMS . 3 

CHAPTER 2 

2.1 WITHDRAWN TESTS. 1 

2.2 INATPUCaBLE TESTS . 1 

2.3 TEST MODIFICATIONS . 4 

CHAPTERS 

3.1 TESTING ENVIRONMENT . 1 

3.2 SUMMARY OF TEST RESULTS. 1 

3.3 TEST EXECUTION. 2 

APPENDIX A 
APPENDDC B 
APPENDIX C 


Validatioa Summaiy Report AVF_VSR_90502/75 

Ahys limited Table of Contents - Page i of i AlsyCOMP_037 Version 5.2 
















Ccrtilicate Information 


The following Ada implementation was tested and determined to pass ACVC 1.11. Testing was 
completed on 901114. 

Compiler Name and Version: Alsycomp_037 Version 5.2 

Host Computer System: INMOS T800 transputer on a B405 TRAM (bare) with an 

INMOS BOOS Communications link implemented in an IBM 
PC/AT (under MS-DOS 3.1 and DJMOS Iserver V13) 

Target Computer System: INMOS T800 transputer implemented on a B40S TRAM 

(bare), using an IBM PC/AT under MS-DOS 3.1 r unnin g 
INMOS Iserver 13 for file-server support via an INMOS 
BOOS board link 

A more detailed description of this Ada implementation is found in section 3.1 of this report. 

As a result of this validation effort, Validation Certificate #901114N1.11065 is awarded to Alsys 
Limited. This certificate expires on 01 JUNE 1992. 


This report has been reviewed and is approved. 


Jane Pink 

Testing Services Manager 

The National Computing Centre Limited 

Oxford Road 

Manchester 

Ml 7ED 

England 


Ada V^lic^on Organization 
Director, Compter & Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria 
VA 22311 



Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Wuihiii^ion 
DC 20301 


91-00483 


91 5 24 002 


ValidatkMi S ummat y Report 


AVF VSR_905(»2/75 


Alsys 1 imi led 


Page ii of iii 


AlsyCOMP_037 Venkn 5.2 


DECLARATION OF CONFORMANCE 


The following declaration of conformance was supplied by the customer. 

DECLARATION OF CONFORMANCE 
Customer Alsys Limited 

Ada Validation Facility: The National Computing Centre Limited 

Oxford Road 
Manchester 
Ml TED 
United Kingdom 


ACVC Version: 1.11 


Ada Implementation: 

Ada Compiler Name; 
Version: 

Host Computer System: 

Target Computer System: 

Customer’s Declaration 


Alsycomp_037 
Version 52 

ENMOS T800 transputer on a B40S TRAM (bare) with an 
INMOS BOOS Communications link implemented in an IBM PC/AT 
(under MS-DOS 3.1 and INMOS berver V13) 

INMOS T800 transput^' implemented on a B40S TRAM (bare), 
using an IBM PC/AT under MS-DOS 3.1 running INMOS Iserver 
13 for Gle-server support via an INMOS BOOS board link 


I, the undersigned, representing Alsys Limited, declare that Alsys limited has no knowledge of 
deliberate deviations from the Ada Language Standard ANSI/MILrSTD-lSlSA in the 
implementation(s) listed in this declaration. 



Signature Date 


Valwlatioii Summaiy Report 
Abyi limited 


Page iii of iii 


AVF_VSR-90502/75 
Abycoinp_037 Venion 5.2 




INTRODUCTION 


CHAPTER 1 
INTRODUCTION 


The Ada implementation described above was tested according to the Ada Validation Procedures 
[Pro90] against the Ada Standard [Ada83] using the current Ada Compiler Validation Capability 
(ACVC). This Validation Summary Report (VSR) gives an account of the testing of this Ada 
implementation. For any technical terms used in this report, the reader is referred to [Pro90]. A 
detailed description of the ACVC may be found in the current ACVC User’s Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada Certification Body may make 
full and free public disclosure of this report. In the United States, this is provided in accordance with 
the "Freedom of Information Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this report. 

The organizations represented on the signature page of this report do not represent or warrant that 
all statements set forth in this report are accurate and complete, or that the subject implementation 
has no nonconformities to the Ada Standard other than those presented. Copies of this report are 
available to the public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield 
VA 22161 

Questions regarding this report or the validation test results should be directed to the AVF which 
performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria 
VA 22311 


1.2 REFERENCES 

[Ada83| Reference Manual for the Ada Programming Language. 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987 

lPro90l Ada Compiler Validation Procedures , 

V'ersion 2.1, Ada Joint Program Office, August 1990. 


ValiUatioD Summary Report 


AVF_VSR_9050y75 


Alsys limited 


Chapter 1 - Page 1 of 4 


AlsyCOMP_037 Vcisioii 5.2 







INTRODUCTION 


[UG89] Ada Comniler Validation Capabililv User’s Guide. 

21 June 1989. 


13 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC contains a 
collection of test programs structured into six test classes: A, B, C, D, E, and L. The first letter of 
a test name identifies the class to which it belongs. Class A C, D, and E tests are executable. Class 
B and class L tests are expected to produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and produce a PASSED, FAILED, or 
NOT APPLICABLE message indicating the result when they are executed. Three Ada library units, 
the packages REPORT and SPPRT13, and the procedure CHECK FILE are used for this purpose. 
The package REPORT also provides a set of identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test objective. The package 
SPPRT13 is used by many tests for Chapter 13 of the Ada Standard. The procedure CHECK_F1LE 
is used to check the contents of text files written by some of the Class C tests for Chapter 14 of the 
Ada Standard. The operation of REPORT and CHECK_FILE is checked by a set of executable tests. 
If these units are not operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class B tests are not executable. 
Each test in this class is compiled and the resulting compilation listing is examined to verify that all 
violations of the Ada Standard are detected. Some of the class B tests contain legal Ada code which 
must not be flagged illegal by the compiler. This behaviour is also verified. 

Class L tests check that an Ada implementation correctly detects violation of the Ada Standard 
involving multiple, separately compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by implementation-specific 
values - for example, the largest integer. A list of the values used for this implementation is 
provided in Appendix A. In addition to these anticipated test modifications, additional changes may 
be required to remove unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this implementation are described in section 2.3. 
For each Ada implementation, a customized test suite is produced by the AVF. This customisation 
consists of making the modifications described in the preceding paragraph, removing withdrawn tests 
(see section 2.1) and, possibly some inapplicable tests (see Section 3.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of the customized test suite 
according to the Ada Standard. 


Validatioo Summaiy Report 


AVF_VSR_90502/75 


Abys Limited 


Chapter 1 - Page 2 of 4 


AlsyCOMP_037 Version 5.2 





INTRODUCTION 


1.4 DEFINITION OF TERMS 


Ada Compiler 


Ada Compiler 
Validation 
Capability (ACVC) 

Ada Implementation 


Ada Validation Facility 
(AVF) 

Ada Validation 
Organization (AVO) 

Compliance of an Ada 
Implementation 

Computer System 


Conformity 


Customer 


Declaration of 
Conformance 


The software and any needed hardware that have to be added to a 
given host and target computer system to allow transformation of 
Ada programs into executable form and execution thereof. 

The means for testing compliance of Ada implementations, consisting 
of the test suite, the support programs, the ACVC user’s guide and 
the template for the validation summary report. 

An Ada compiler with its host computer system and its target 
computer system 

The part of the certification body which carries out the procedures 
required to establish the compliance of an Ada implementation. 

The part of the certification body that provides technical guidance for 
operations of the Ada Certification system. 

The ability of the implementation to pass an ACVC version. 


A functional unit, consisting of one or more computers and 
associated software, that uses common storage for all or part of a 
program and also for all or part of the data necessary for the 
execution of the program; executes user-written or user-designated 
programs; performs user-designated data manipulation, including 
arithmetic operations and logic operations; and that can execute 
programs that modify themselves during execution. A computer 
system may be a stand-alone unit or may consist of several inter¬ 
connected units. 

Fulfilment by a product, process or service of all requirements 
specified. 

An individual or corporate entity who enters into an agreement with 
an AVF which specifies the terms and conditions for AVF services 
(of any kind) to be performed. 

A formal statement from a customer assuring that conformity is 
realized or attainable on the Ada implementation for which 
validation status is realized. 


Host Computer System A computer system where Ada source programs are transformed into 

executable form. 


Validation Summary Report 


AVF_VSR_90502/75 


Alsys Limited 


Chapter 1 - Page 3 of 4 


AbyCX)MP_037 Venioo 5.2 






INTRODUCTION 


Inapplicable test 
Operating System 

Target Computer 
System 

Validated Ada Compiler 

Validated Ada 
Implementation 

Validation 

Withdrawn test 


Validation Summary Report 


A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

Software that controls the execution of programs and that provides 
services such as resource allocation, scheduling, input/output control, 
and data management. Usually, operating systems are predominantly 
software, but partial or complete hardware implementations are 
possible. 

A computer system where the executable form of Ada programs are 
executed. 

The compiler of a validated Ada implementation. 

An Ada implementation that has been validated successfully either 
by AVF testing or by registration [Pro90]. 

The process of checking the conformity of an Ada compiler to the 
Ada programming language and of issuing a certificate for this 
implementation. 

A test found to be incorrect and not used in conformity testing. A 
test may be incorrect because it has an invalid test objective, fails to 
meet its test objective, or contains erroneous or illegal use of the 
Ada programming language. 


AVF_VSR_90502/75 


Alsys limited 


Chapter 1 - Page 4 of 4 


AlsyCOMP_037 Verakm 5.2 







IMPLEMENTATION DEPENDENCIES 


CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 
2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for withdrawing each test is 
available from cither the AVO or the AVF. The publication date for this list of withdrawn tests is 
90-10-12. 


E28005C 

B28006C 

C34006D 

B41308B 

C43004A 

C45114A 

C45346A 

C45612B 

C45651A 

C46022A 

B49008A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

B85001L 

C83026A 

C83041A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7(K)5E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE.3812A 

CE3814A 

CE3902B 





2.2 INAPPLICABLE TESTS 


A test is inapplicable if it contains test objectives which are irrelevant for a given Ada 
implementation. The inapplicability criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Issues and commonly referenced in the format Al-dddd. For this 
implementation, the following tests were inapplicable ''or the reasons indicated; references to Ada 
Issues are included as appropriate. 


The following 201 tests have floating-point type declarations requiring more digits than 
SYSTEM.MAX_D1GITS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


Validatioa Summary Report 


AVF_VSR_90502/7S 


Aisys Limited 


Chapter 2 - Page 1 of 5 


AI^COMP_037 Venkm 5.2 









IMPLEMENl’ATION DEPENDENCIES 


The following 21 tests check for the predefined type LONG_INTEGER: 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45612C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001W 

C86006C 


CD7101F 

C35404D, C45231D, B86001X, C86006E, and CD7101G check for a predefined integer type with a 
name other than INTEGER, LONG_INTEGER, or SHORTJNTEGER. 

C35702A, C35713B, C45423B, B86001T. and C86006H check for the predefined type 
SHORT_FLOAT. 

C35713D and B86001Z check for a prede~ned floating-point type with a name other than FLOAT, 
LONG_FLOAT, or SHORT_FLOAT. 

C45531M..P (4 tests) and C45532M..P (4 tests) check fixed-point operations for types that require a 
SYSTEM.MAX_MANTISSA of 47 or greater. 

C45536A C46013B, C46031B, C46033B and C46034B contain ’SMALL representation clauses which 
arc not powers of two or ten. 

C45624A checks that the proper exception is raised if MACHINE_OVERFLOWS is FALSE for 
floating point types with digits 5, For this implementation, MACHI'NE_0VERFL0WS is TRUE. 

C45624B checks that the proper exception is raised if MACHlNE_OVERFLOWS is FALSE for 
floating point types with digits 6. For this implementation, 'MACHINE_OVERFLOWS is TRUE. 

C86001F recompiles package SYSTEM, making package TEXT IO, and hence package REPORT, 
obsolete. For this implementation, the package TEXT IO is dependent upon package SYSTEM. 

B86001Y checks for a predefined fixed-point type other than DURATION. 

C96005B checks for values of type DURATION’BASE that are outside the range of DURATION. 
There are no such values for this implementation. 

CD1009C uses a representation clause specifying a non-default size for a floating-point type. 

CD2A53A checks operations of a fixed-point type for which a length clause specifies a power-of-ten 
lypc’small. (See 2..3) 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use representation clauses specifying 
non-default sizes for access types. 

BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code insertions. 


Validation Summaiy Report 


AVF_VSR_90502/75 


Alsys Limitcxl 


Chapter 2 - Page 2 of 5 


AlsyCOMP_037 Versioa 5.2 




IMPLEMENTATION DEPENDENCIES 


The tests listed in the following table are not applicable because the given file operations are 
supported for the given combination of mode and file access method. 


Test 

File Operation 

Mode 

File Access Method 

CE2102D 

CREATE 

IN FILE 

SEQUENTIAL lO 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL IQ 

CE2102F 

CREATE 

INOUT FILE 

DIRECT lO 

CE2102I 

CREATE 

IN FILE 

DIRECT lO 

CE2102J 

CREATE 

OUT FILE 

DIRECT lO 

CE21C2N 

OPEN 

IN FILE 

SEQUENTIAL lO 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL lO 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL lO 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL lO 

CE2102R 

OPEN 

INOUT FILE 

DIRECT lO 

CE2102S 

RESET 

INOUT FILE 

DIRECT lO 

CE2102T 

OPEN 

IN FILE 

DIRECT lO 

CE2102U 

RESET 

IN FILE 

DIRECT lO 

CE2102V 

OPEN 

OUT FILE 

DIRECT lO 

CE2102W 

RESET 

OUT FILE 

DIRECT lO 

CE3102E 

CREATE 

IN FILE 

TEXT lO 

CE3i02F 

RESET 

Any Mode 

TEXT lO 

CE3102G 

DELETE 

TEXT lO 

CE3102I 

CREATE 

OUT HLE 

TEXT lO 

CE3102J 

OPEN 

IN FILE 

TEXT lO 

CE3i02K 

OPEN 

OUT FILE 

TEXT lO 


CE2107B..E (4 tests), CE2107L, CE2110B and CE2niD attempt to associate multiple internal 
sequential files with the same external file when one or more filer is open for writing. The proper 
exception is raised when this association is attempted. 

CE2107G..H (2 tests), CE2110D, and CE2111H attempt to associate multiple internal direct files with 
the same external file when one or more files is open for writing. The proper exception is raised 
when this association is attempted. 

CE2203A checks that WRITE raises USE_ERROR if the capacity of the external file is exceeded for 
SEQUENTIAL_IO. This 'mplementation can not restrict file capacity. 

CE2401H, EE2401D and EE2401G use instantiations of DIRECT_IO with unconstrained array and 
record types; this implementation raises USE_ERROR on the attempt to create a file. 

CE2403A checks that WRH E raises USE-ERROR if the capacity of the external file is exceeded for 
DIRECT_IO. This implementation does not restrict file capacity. 

CE3111B, CE3111D..E (2 tests), CE3114B, and CE3115A attempt to associate multiple internal text 
files with the same external file when one or more files is open for writing. The proper exception 
is raised when this association is attempted. 


Validation Summary Report 


AVF VSR_90502/7S 


/Jays IJmitol 


Ch.ipter 2 - Page 3 of 5 


AlsyCOMP_037 Version 5.2 








IMPLEMENTATION DEPENDENCIES 


CE3202A expects that function NAME can be applied to the standard input and output files; in this 
implementation these files have no names, and USE_ERROR is raised. [See 2.3]. 

CE33()4A checks that USE ERROR is raised if a call to SET LINE LENGTH or 
SET_PAGE_LENGTH specifies a value that is inappropriate for the external file. This 
implementation does not have inappropriate values for either line length or page length. 

CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the page number exceeds 
COUNT’LAST. For this implementation, the value of COUNT’LAST is greater than 150000 making 
the checking of this objective impractical. 


2 3 TEST MODIFICATIONS 


.Modifications (see section 1.3) were required for 26 tests. 


The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the way 
expected by the original tests. 


B23004A 

B32202A 

B45012A 

B74401R 

B97103E 

BC3009C 


B24007A 

B32202B 

B61012A 

B91004A 

BA1101B2 

BC3204D 


B24009A 

B32202C 

B74304A 

B95069A 

BA1101B4 


B28003A 

B37004A 

B74401F 

B95069B 

BC2001D 


CD2A53A was graded inapplicable by Evaluation Modification as directed by the AVO. The test 
contains a specification of a power-of-10 value as small for a fixed-point type. The AVO ruled that, 
under ACVC 1.11, support of decimal smalls may be omitted. 

CE3202A was graded inapplicable by Evaluation Modification as directed by the AVO. The test will 
abort with an unhandled exception (USE ERROR) when function NAME is invoked for the standard 
input file. The AVO ruled that this behaviour is acceptable pending a resolution of the issue by the 
ISO WG-9 Ada Rapporteur Group. 

CE3605A was graded passed by Test Modification as directed by the AVO. This test attempts to 
write a line with 516 characters; this exceeds the implementation’s default limit of 503, and USE- 
ERROR is raised. This behaviour is allowed by AI-00534, and so the test was modified as follows; 

On line 74, ‘86’ was changed to ‘83’ 

ON line 81, ‘517’ was changed to ‘499’ 

The modified test was processed and passed. 

EA3004D was graded passed by Evaluation and Processing Modification as directed by the AVO. The 
test requires that either pragma INLINE is obeyed for the invocation of a function in each of three 


Validation Summary Kcport 


AVF_VSR_90502/75 


Abys Limited 


Chapter 2 - Page 4 of 5 


AIsyCOMP_037 Version 5.2 







IMPLEMENTATION DEPENDENCIES 


contexts and that thus three library units are made obsolete by the re-compilation of the inlined 
function’s body, or else the pragma is ignored completely. This implementation obeys the pragma 
except when the invocation is within a package specification. When the test’s files are processed in 
the given order, only two units are made obsolete; thus, the expected error at line 27 of file 
EA3004D6M is not valid and is not flagged. To confirm that indeed the pragma is not obeyed in this 
one case, the test was also processed with the files re-ordered so that the re-compilation follows only 
the package declaration (and thus the other library units will not be made obsolete, as they are 
compiled later); a "NOT APPLICABLE" result was produced, as expected. The revised order of files 
was 0-1-4-5-2-3-6. 


AVF_VSR_90502/75 


Validation Summary Report 
Alsys limited 


Chapter 2 - Page 5 of 5 


AlsyCOMP_037 Venkm 5.2 








PROCESSING INFORMATION 


CHAPTERS 

PROCESSING INFORMATION 
3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is described adequately by the information 
given in the initial pages of this report. 

For a point of contact for technical information about this Ada implementation system, see: 

Jon Frosdick 
Alsys Limited 
Partridge House 
Newtown Road 
Henley-on-Thames 
Oxfordshire 
RG9 lEN 

For a point of contact for sales information about this Ada implementation system, see: 

John Stewart 
Alsys Limited 
Partridge House 
Newtown Road 
Henley-on-Thames 
Oxfordshire 
RG9lEN 

Testing of this Ada implementation was conducted at the customer’s site by a validation team from 
the A\T. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test of the customized test 
suite in accordance with the Ada Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable and applicable), a result was obtained that conforms to the Ada 
Programming Language Standard. 


a) 

Total Number of Applicable Tests 

3780 

b) 

Total Number of Withdrawn Tests 

81 

c) 

Processed Inapplicable Tests 

309 

d) 

Non-Processed I/O Tests 

0 


Validation Summaiy Report 


AVF_VSR_90502/75 


Alsys t Jiiiii«t 


Chapter 3 - Page 1 of 3 


AlsyCOMP_037 Vereioo 5.2 





PROCESSING INFORMATION 


e) Non-Processed Floating-Point Precision Tests 0 
0 Total Number of Inapplicable Tests 309 (c-l-d+e) 

g) TotalNumberofTestsforACVCl.il 4170 (a-l-b-l-f) 

All I/O tests of the test suite were processed because this implementation supports a file system. All 
floating-point precision tests were processed because this implementation supports floating-point 
precision to the extent that was tested. When this compiler was tested, the tests listed in section 2.1 
had been withdrawn because of test errors. 


3.3 TEST EXECUTION 

Version 1.11 of the ACVC comprises 4170 tests. When this compiler was tested, the tests listed in 
section 2.1 had been withdrawn because of test errors. The AVF determined that 309 tests were 
inapplicable to this implementation. All inapplicable tests were processed during validation testing. 
In addition, the modified tests mentioned in section 2.3 were also processed. 

A Magnetic tape containing the customized test suite (see section 1.3) was taken on-site by the 
validation team for processing. 

The contents of the magnetic tape were loaded onto a SUN 3/160. These were then transferred 
across to a Microvax II using File Transfer Protocol on an Ethernet link where they were stored until 
required by the host. 

The final stage was to transfer the individual files to the IBM PC/AT host, again by means of 
Ethernet File Transfer Protocol. 

After the test files were loaded onto the host computer, the full set of tests was processed by the Ada 
implementation. 

The tests were compiled and linked on the host computer system, as appropriate. The executable 
images were transferred to the target computer system by the communications link described above, 
and run. The results were captured on the host computer system. 

Testing was performed using command scripts provided by the customer and reviewed by the 
validation team. See Appendbc B for a complete listing of the processing options for this 
implementation. It also indicates the default options. The options invoked explicitly for validation 
testing during this test were: 


AVF_VSR_90502/75 


Validatkxi Summary Report 
Abys Limited 


Chapter 3 - Page 2 of 3 


AbyCOMP_(B7 Versioa 5.2 







PROCESSING INFORMATION 


CALLS = INLINED 
REDUCTION=EXTENSIVE 
EXPRESSIONS=EXTENSIVE 

OBJECT=PEEPHOLE 
OUTPUT=<file> 

WARNING=NO 

DETAIL=NO 

SHOW=NONE 

ERROR=999 

FILE_WIDTH=79 

FILE_LENGTH=999 


Allows inline insertion of code for subprograms. 

Perform extensive high level optimisations. 

Perform extensive common sub-expression elimination 
optimisations. 

Perform peephole optimisations. 

<file> specifies the name of the compilation listing 
generated. 

Do not include warning messages. 

Do not add extra detail to the error messages. 

Do not print a header and do not include an error summary 
in the compilation listing. 

Set the maximum number of compilation errors permitted 
before compilation is terminated to 999. 

Set width for listing file to 79 columns. 

Disable insertion of form feeds in the output. 


In addition, the following options were used to produce full compiler listings: 

TEXT Print a compilation listing including full source text. 

The default options were used for the Binder 

Test output, compiler and linker listings, and job logs were captured on Magnetic tape and archived 
at the AVF. The listings examined on-site by the validation team were also archiv^. 


Validation Summaiy Rqxxt 


AVF_VSR_90502/75 


Alsys Limited 


Chapter 3 - Page 3 of 3 


AlsyCOMP_037 Veraioa 5.2 






MACRO PARAMETERS 


APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. The meaning and 
purpose of these parameters are explained in [UG89]. The parameter values are presented in two 
tables. The first table lists the valued that are defined in terms of the maximum input-line length, 
which is the value for $MAX_IN-LEN—also listed here. These values are expressed here as Ada 
string aggregates, where "V" represents the maximum input-line length. 


Macro Parameter Macro Value 


$MAX_IN_LEN 

$B1G_ID1 

$BIGJD2 

$BIG_ID3 

$BIG_ID4 

$B1G_INT_LIT 

$BIG_REAL_LIT 

$BIG_STRING1 

$BIG_STRING2 

SBLANKS 

$MAX_LEN_INT_BASED_LITERAL 

$MAX_LEN_REAL_BASED_LITERAL 

$MAX_STRING_LITERAL 


255 

(1..V-1 => ’A’, V => T’) 

(1..V-1 => ’A’, V => ’2’) 

(1..V/2 => ’A’) & 3’ & (1..V-1-V/2 => ’A’) 
(1..V/2 => ’A’) & ’4’ & (1..V-1-V/2 => ’A’) 
(1..V-3 => ’O’) & "298" 

(1..V-5 => ’O’) & "690.0" 

’"’ & (1..V/2 => ’A’) & ’"’ 

’"’ & (1..V-1-V/2 => ’A’) & ’1’ & ”” 

(1..V-20 => ”) 

"2:" & (1..V-5 => ’O’) & "11:" 

"16:" & (1..V-7 => ’O’) & "F.E:" 

’"’ & (1..V-2 => ’A’) & ’"’ 


Validation Summaiy Report 


AVF_VSR_90502^5 


Alsys limited 


Appendix A - Page 1 of 4 


AlsyCOMP_037 Vcnkn SO. 








MACRO PARAMETERS 


MACRO PARAMETERS 

The following table lists all of the other macro parameters and their respective values. 


Macro Parameter 

$ACC_S1ZE 

SALIGNMENT 

$COUNT_LAST 

SDEFAUL r_MEM_SIZE 

$DEFAULT_STOR_UNIT 

$DEFAULT_SYS_NAME 

$DELTA_DOC 

$ENTRY_ADDRESS 

$ENTRY_ADDRESS1 

$ENTRY_ADDRESS2 

$FIELD_LAST 

$FILE_TERMINATOR 

$FIXED_NAME 

$FLOAT_NAME 

$FORM_STRING 

$FORM_STRING2 

SGREATER THAN DURATION 


Macro Value 

32 

4 

2147483647 

4294967296 

8 

TRANSPUTER 

2#1.0#E-31 

ADDRESS_OF_MEM_BLOCK3 

ADDRESS_OF_MEM_BLOCKl 

ADDRESS_OF_MEM_BLOCK2 

255 
* > 

NO_SUCH_TYPE 

NO_SUCH_TYPE 

n ti 

"CANNOT_RESTRICT_nLE_CAPACITY" 

100000.0 


$GREATER_THAN_DURATION_BASE_LAST 

10000000.0 

$GREATER_THAN_FLOAT_BASE_LAST 1.0E40 
SGREATER THAN FLOAT SAFE LARGE 1.0E38 


V alida tion S ummar y RepCMl AVF_VSR_90502/7S 

Alsys Limited Appendix A - Page 2 of 4 AliyCOMP_037 Venioa 5^ 







MACRO PARAMETERS 


SGREATER THAN SHORT FLOAT SAFE LARGE 


$HIGH_PRIORITY 

$ILLEGAL_EXTERNAL_FILE_NAME1 

$ILLEGAL_EXTERNAL_FILE_NAME2 

$INAPPROPRIATE_LINE_LENGTH 

$INAPPROPRIATE_PAGE_LENGTH 

$INCLUDE_PRAGMA1 

$INCLUDE_PRAGMA2 

$INTEGER_FIRST 

$INTEGER_LAST 

$INTEGER_LAST_PLUS_1 

$INTERFACE_LANGUAGE 

$LESS_THAN_DURATION 

$LESS_THAN_DURATION_BASE_FIRST 

$LINE_TERMINATOR 

$L0W_PR10RITY 

$MACHINE_CODE_STATEMENT 

$MACHINE_CODE_TYPE 

$MANTISSA_DOC 

$MAX_DIGITS 

$MAX_INT 

$MAX_INT_PLUS_1 

$MIN INT 


SHORT_FLOAT_NOT_SUPPORTED 

10 

?#~@’({}l + = 

[{}] +=?#~@’ 

-1 

-1 

PRAGMA INCLUDE (’’A28006D1.TST") 
PRAGMA INCLUDE ("B28006Dl.TSr’) 
-2147483648 
2147483647 
2147483648 
OCCAM 
- 100000.0 
- 10000000.0 
ASCII.LF 
1 

NULL; 

NO_SUCH_TYPE 

31 

15 

2147483647 

2147483648 

-2147483648 


Validalkm Sammaiy Report 


Abys Lioiited 


Appendix A - Page 3 of 4 


AVF_VSR_90502/75 
AbyCX>MP_a37 Venkn 5.2 




MACRO PARAMETERS 


SNAME 

$NAME_LIST 

$NAME_SPECIFICATIONl 

$NAME_SPECIFICATION2 

$NAME_SPECIFICATION3 

$NEG_BASED_INT 

$NEW_MEM_SIZE 

$NEW_STOR_UNIT 

$NEW_SYS_NAME 

$PAGE_TERMINATOR 

$RECORD_DEFINITION 

iRECORD_NAME 

$TASK_SIZE 

$TASK_STORAGE_SIZE 

STICK 

$VARIABLE_ADDRESS 

$VARIABLE_ADDRESS1 

$VARIABLE_ADDRESS2 

$YOUR_PRAGMA 


ValidatioD Summaiy Repoft 
Abyi 1 imilcd 


NO_SUCH_TYPE 

180X86,180386,MC680X0,S370,TRANSPUTER,VAX 

X2120A 

X2120B 

X3119A 

16#FFFFFFFF# 

RELEVANT_TESTS_ WITHDRAWN 
RELEVANT_TESTS_WITHDRAWN 

RELEVANT_TESTS_ WITHDRAWN 
♦ > 

NEW INTEGER 

NO_SUCH_MACHINE_CODE_TYPE 

32 

2048 

64.0E-6 

ADDRESS_OF_MEM_BLOCK3 

ADDRESS_OF_MEM_BLOCKl 

ADDRESS_OF_MEM_BLOCK2 

NO_SUCH_PRAGMA 


Appendix A - Page 4 of 4 


AVF_VSR_90502/75 
AbyC0MP_(07 Vcnkm S2 






COMPILATION SYSTEM OPTIONS 


APPENDIX B 

COMPILATION SYSTEM OPTIONS 


Compiler Options 
SOURCE^file jiame 
LIBRARY =library_name 
ANNOTATE="" 

LEVEL=UPDATE 

ERRORS=999 

CHECKS=ALL 

GENERICS=INLINE 

MEMORY=500 OR 1000 

CODE=4 

DATA=1 

INTERFACE=4 

OUTPUT =file_name 
TEXT=YES or NO 


WARNING=NO 


The name of the source file. 

The name of the Ada program library. 

User specified character string annotating compilation unit 
as stored in library. 

Compilation level - complete compilation of source code into 
object code and update of program library. 

Number of errors permitted before compilation is 
terminated. 

All run time checks to be performed, except those explicitly 
suppressed by use of pragma SUPPRESS. 

Place code of generics instantiations inline in the same unit 
as the instantiation rather than in separate units. 

Number of Kbytes reserved in memory for compiler data 
(before swapping commences). Set to 500 for the 
AlsyCOMP_037 validation and 1000 for the AlsyCOMP_017 
validation due to different host memory availability. 

Number of transputer prefix instructions used to construct 
Ada code addresses. 

Number of transputer prefix instructions used to construct 
Ada data addresses. 

Number of transputer prefix instructions used to construct 
interface code addresses. 

Compilation listing file name. 

Controls inclusion of full source test in the compilation 
listing. Set to YES for tests requiring compilation listings (ie 
B tests). Set to NO for tests not requiring compilation 
listings (ie non-B tests). 

Do not include warning messages in the compilation listing. 


Validatioo Summaiy Rqxxt 


AVF_VSR_90502/75 


Alsys Limited 


Appendix B - Page 1 of 3 


AbyCX)MP_037 Veisioo 5.2 








COMPILATION SYSTEM OPTIONS 


SHOW=NONE 

DETAIL=NO 

ASSEMBLY=NONE 

STACK=8 

CALLS=INLINED 
REDUCTION=EXTENSIVE 
EXPRESSIONS=EXTENSIVE 
OBJECT=PEEPHOLE 
COPY=NO 

DEBUG-NO 
TREE=NO 
nLE_ WIDTH=79 
FILE_LENGTH=9999 

Binder Options 
PROGRAM =unit_name 
LIBRARY =library_name 
LEVEL=LINK 

OBJECT=AUTOMATIC 


Validation Summaiy Report 


Do not print a header on compilation listing pages, nor an 
error summary at the end. 

Do not print extra detail in error messages in the 
compilation listing. 

Do not include an assembly listing of generated code in the 
compilation listing. 

Maximum size in bytes for objects allocated in the main 
execution stack. Objects bigger than this limit are allocated 
on an auxiliary stack. 

Alow inline insertion of code for subprograms. 

Optimise run-time checks and remove dead code. 

Optimise expression evaluation. 

Optimise locally the object code as it is generated. 

Do not save a representation of the source code in the 
program library. 

Do not save information for debugging. 

Do not save information for cross referencing. 

Width of compilation listing page in columns. 

Length of compilation listing page in lines (effectively 
unpaginated). 


The name of the main unit of the Ada program. 

The name of the Ada program library. 

Binding level - complete bind to produce an object module, 
followed by invocation of the INMOS ilink and iboot tools to 
produce a bootable load module. 

Load module name derived automatically from PROGRAM 
name. 


AVF_VSR_90502A7S 


Atsys Limited 


Appendix B - Page 2 of 3 


Al9COMP_037 Vetsioa S.2 






COMPILATION SYSTEM OPTIONS 


UNCALLED=REMOVE 

SLICE=NO 

HISTORY=MAIN 

ENTRY_POINY=AUTOMATIC 

SIZE_MAIN = 160 

RATIO_MAIN=20 

FAST_MAIN=NO 

SIZE_TASK=16 

RATIO_TASK=50 

FAST_TASK=NO 

TARGET=DEFAULT 

DIRECnVES="" 

MODULES="" 

SEARCH="" 


OVTPVT = file _name 
DATA=NONE 

WARNING=NO 
DEBUG=NO 


Remove the code for uncalled subprograms from the load 
module. 

Invoke the task scheduler only at synchronization points. 

Trace the propagation of exceptions unhandled in the main 
program. 

Entry point name derived automatically from PROGRAM 
name. 

Number of Kbytes allocated to the main program stacks. 

Percentage of SIZE_MAIN allocated to the primary stack. 

Allocated the stacks of the main program in external memory 
(as opposed to on-chip memory). 

Default number of Kbytes allocated to task stacks (in 
absence of explicit length clause). 

Percentage of SIZE_TASK allocated to the primary stack. 

Allocated task stacks in external memory (as opposed to on- 
chip memory). 

Use the default OCCAM harness code for the target 
processor. 

User specified directives for the INMOS linker tool. 

Use specified object modules to be included in the INMOS 
link step. 

User specified object libraries to be included in the INMOS 
link step. 

Binder listing file name. 

Do not print additional mapping information in the binder 
listing. 

Do not print warning messages in the binder listing. 

Do not save information for debugging. 


AVF_VSR_9050Z/7S 


Validatioa Summaiy Rqxirt 
Abys Limited 


Appendix B - Page 3 of 3 


AlfyCOMP_037 Venioo 5.2 






APPENDIX F OF THE Ada STANDARD 


APPENDIX C 

APPENDIX F OF THE Ada STANDARD 


rhc only allowed implementation dependencies correspond to implementation-dependent pragmas, 
lo certain machine-dependent conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The implementation-dependent characteristics 
of this Ada implementation, as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to compiler documentation and not to 
this report. Implementation-specific portions of the package STANDARD, which arc not a part of 
Appendix F, are: 


package STANDARD is 

type INTEGER is range -2**31 .. 2**3I-1; 
type SHORT_INTEGER is range -2**7 .. 2**7-l; 

type FLOAT is digits 6 range -(2.0-2.0**127 .. (2.0-2.0**(-23))*2.0**127; 
type LONG_FLOAT is digits 15 range -(2.0-2.0**(-51))*2.0**1023 .. 

(2.0-2.0**(5i))*2.0**1023; 

type DURATION is delta 2.0**-14 range -131_072.0 .. 131_071.0 


end STANDARD; 


Validalkia Summary Report 


AW VSR 90502/75 


Abys I imited 


Appendix C - Page 


AlsyCOMP_037 Version 5.2 



Alsys Ada Compilation System 


for the Transputer 
APPENDIX h 

Implementation Dependent Characteristics 


Version 5 


Alsys S^. 

29, Avenue Lucien-Rene Duschesne 
78170 Lo Celle St. Cloud, France 


Als\s Inc. 

67 South Bedford Street 
Burlington, MA 01803-5] 52, U.S^. 


Alsys GmbH 
Am Ruppurrer Schloft 7 
D- 7500 Karlsruhe 51,Germany 


Alsys Ltd 

Partridge House, Newtown Road 
Henley-on-Thames 
Oxon. RG9 ]EN, U.K 


Alsys AB 

Patron Pehr Vdg 10 
Box 1085 

14] 22 Huddinge, Stockholm, Sweden 


Alsys KKE 
223-1 Yamashita-oho 
Naka-ku, Yokohama, 231, Japan 


Copyright 1990 by Alsys 


All rights reserved. No part of this document may be reproduced in any form or by any 
means without permission in writing from Alsys. 

Printed: August 1990 

Alsys reserves the right to make changes in specifications and other information 
contained in this publication without prior notice, and the reader should in all cases 
consult Alsys to determine whether such changes have been made. 


PREFACE 


This, Appehdix F is for programmers, software engineers, project managers, educators and 
students who want to develop an Ada program for the INMOS transputer. 

This appendix is a required part of the Reference Manual for the Ada Programming 
Language, ANSl/MIL-STD 1815A, January 1983 (throughout this appendix, citations in 
square brackets refer to this manual). 

This document assumes that the reader has some knowledge of the architecture of the 
transputer. Access to the document Occam2 Toolset User Manual (Ref. 3) which 
describes the program development environment for occam as supplied by INMOS 
would also be advantageous. 


Preface 


I 


// 


Alsys Ada for the Transputer, Appendix F, v5 







TABLE OF CONTENTS 


INTRODUCTION 


1 Implementation-Dependent Pragmas 

1.1 INLINE 

1.2 INTERFACE 

1.2.1 Calling Conventions 

1.2.2 Parameter-Passing Conventions 

1.2.3 Parameter Representations 

1.2.4 Restrictions on Interfaced Subprograms 

1.3 INTERFACE NAME 

1.4 INDENT 

1.5 Other Pragmas 

2 Implementation-Dependent Attributes 

3 Specification of the Package SYSTEM 

4 Restrictions on Representation Clauses 

4.1 Enumeration Types 

4.2 Integer Types 

4.3 Floating Point Types 

4.4 Fixed Point Types 

4.5 Access Types 

4.6 Task Types 

4.7 Array Types 

4.8 Record Types 


Table of Contents 




5 

Conventions for Implementation-Generated Names 

47 

6 

Address Clauses 

49 

6.1 

Address Clauses for Objects 

49 

6.2 

Address Clauses for Program Units 

49 

6.3 

Address Clauses for Entries 

49 

7 

Restrictions on Unchecked Conversions 

51 

8 

Input-Output Packages 

S3 

8.1 

NAME Parameter 

53 

8.2 

FORM Parameter 

53 

8.2.1 

File Sharing 

54 

8.2.2 

Binary Files 

55 

8.2.3 

Buffering 

56 

8.2.4 

Appending 

57 

8.3 

USE.ERROR 

57 

9 

Characteristics of Numeric T^pes 

59 

9.1 

Integer TVpes 

59 

9.2 

Floating Point Type Attributes 

60 

9.3 

Attributes of Type DURATION 

61 


REFERENCES 

63 


INDEX 

65 


Als)’s Ada for the Transputer, Appendix F, vS 



INTRODUCTION 


Implementation-Dependent Characteristics 


This appendix summarizes the implementation-dependent characteristics of the AJsys 
Ada Compilers for the INMOS transputer. This document should be considered as the 
Appendix F to the Reference Manual for the Ada Programming Language ANSI/MIL- 
STD 1815A, January 1983, as appropriate to the Alsys Ada implementation for the 
transputer. 

Sections 1 to 8 of this appendix correspond to the various items of information required 
in Appendix F jF)*; sections 9 and 10 provide other information relevant to the Alsvs 
implementation. The contents of these sections is described below; 

1. The form, allowed places, and effect of every implementation-dependent pragma. 

2. The name and type of every implementation-dependent attribute. 

3. The specification of the package SYSTEM 113.7). 

4. The list of all restrictions on representation clauses [13.1). 

5. The conventions used for any implementation-generated names denoting 
implementation-dependent components )13.4). 

6. The interpretation of expressions that appear in address clauses. 

7. Any restrictions on unchecked conversions [13.10.2]. 

8. Any implementation-dependent characteristics of the input-output packages [14]. 

9. Characteristics of numeric types. 


* Throughout this manual, citations in square brackets refer to the Reference Manual 
for the Ada Programming Language, ANS1/MIL-STD-1815A, January 1983. 


Implementation -Dependent Characteristics 


1 



Throughout this appendix, the name Ada Run-Tune Executive refers to the run-time 
library routines provided for all Ada programs. These routines implement the Ada heap, 
exceptions, tasking control, I/O, and other utility functions. 


Alsys Ada for the Transputer, Appendix F, v5 


CHAPTER 1 


Implementation-Dependent Pragmas 

1.1 INLINE 

Pragma INLINE is fully supported, except for the fact that it is not possible to inline a 
function call in a declarative part. 

1.2 INTERFACE 

Ada programs can interface to subprograms written in Occam through the use of the 
predefined pragma INTERFACE (13.9] and the implementation-defined pragma 
INTERFACE_NAME. 

Pragma INTERFACE specifles the name of an interfaced subprogram and the name of 
the programming language for which calling and parameter passing conventions will be 
generated. Pragma INTERFACE takes the form specified in the Reference Manual: 

pragma INTERFACE {language_name, subprogram jiame): 

where: 

■ language jiame is the name of the other language whose calling and * .^rameter 
passing conventions are to be used. 

■ subprogram Jiame is the name used within the Ada program to refer to the 
interfaced subprogram. 

The only language name currently accepted by pragma INTERFACE is occam. 

The language name used in the pragma INTERFACE does not necessarily correspond to 
the language used to write the interfaced subprogram. It is used only to tell the 
Compiler how to generate subprogram calls, that is, which calling conventions and 
parameter passing techniques to use. 


Implementation-Dependent Pragmas 


3 



The language name occam is used to refer to the standard Occam calling and parameter 
passing conventions for the transputer |Ref. 4, Section 5.10]. The programmer can use 
the language name occam to interface Ada subprograms to subroutines written in any 
language that follows the standard occam calling conventions. 


1.2.1 Calling Conventions 

The following calling conventions are required for code to be called from Ada by use of 
the pragma interface to occam. 

On entry to the subprogram, the registers A, B and C are undefined. For the T8 only, the 
floating point registers FA, FB and FC are similarly undefined. The return address and 
any parameters are accessed relative to the workspace pointer, W, by the subprogram. 

There are no assumptions concerning the contents of the register stacks (A, B, C and FA, 
FB, FC) upon return from the interfaced subprogram, other than for interfaced 
subprograms which are functions (see below). However, the workspace pointer, W, 
should contain the same address upon return from the interfaced subprogram as it 
contained before the call. 

The setting of the error flag is ignored on return. 


1.2.2 Parameter-Passing Conventions 

On entry to the subprogram, the first word above the transputer workspace pointer 
contains the return address of the called subprogram. Subsequent workspace locations 
(from W+1 to W+n, where n is the number of parameters) contain the subprogram 
parameters, which are all one word in length. 

There is always an implicit vector space parameter passed as the last parameter to all 
interfaced subprograms. This points to an area of free memory which can be used by the 
Occam compiler to allocate arrays declared in the interfaced subprogram. 

Actual parameters of mode in which are access values or scalars of one machine word or 
less in size are passed by copy. If such a parameter is less that one machine word in 
length it is sign extendi to a full word. For all other parameters the value passed is the 
address of the actual parameter itself. 


4 


Alsys Ada for the Transputer, Appendix F, vS 


Since all large scalar, non-scalar and non-access parameters to interfaced subprograms 
are passed by address, they cannot be protected from modification by the called 
subprogram even though they may be formally declared to be of mode in. It is the 
programmer’s responsibility to ensure that the semantics of the Ada parameter modes 
are honoured in these cases. 

If the subprogram is a function whose result is at most one machine word in length, 
register A is used to return the result. All other results are returned by address in 
register A. 

No consistency checking is performed between the subprogram parameters declared in 
Ada and the corresponding parameters of the interfaced subprogram. It is the 
programmer’s responsibility to ensure correct access to the parameters. 


1.2 J Parameter Representations 

This section describes the representation of values of the types that can be passed as 
parameters to an interfaced subprogram. The discussion assumes no representation 
clauses have been used to alter the default representations of the types involved. 

Chapter 4 describes the effect of representation clauses on the representation of values. 

Integer Types [3.5.4] 

Ada integer types are represented in two’s complement form and occupy a byte 
(SHORT_INTEGER) or a word (INTEGER). 

Parameters to interfaced subprograms of type SHORT_INTEGER are passed by copy 
with the value sign extended to a full machine word. Values of type INTEGER are 
always passed by copy. The predefined type LONG_INTEGER is not available. 

Enumeration Types [3.5.1] 

Values of an Ada enumeration type are represented internally as unsigned values 
representing their position in the list of enumeration literals defining the type. The first 
literal in the list corresponds to a value of zero. 

Enumeration types with 256 elements or fewer are represented in 8 bits. All other 
enumeration types are represented in 32 bits. 


Implemeniarion-Dependent Pragmas 


5 




Consequently, the Ada predefined type CHARACTER (3.5.21 represented in 8 bits, 
using the standard ASCII codes (C) and the Ada predefined type BOOLEAN (3.5.3] is 
represented in 8 bits, with FALSE represented by the value 0 and TRUE represent^ by 
the value 1. 

As the representation of enumeration types is basically the same as that of integers, the 
same parameter passing conventions apply. 

Floating Point Types [3.5.7,3.5.8] 

Ada floating-point values occupy 32 (FLOAT) or 64 (LONG_FLOAT) bits, and are held 
in ANSI/IEEE 754 floating point format. 

Parameters to interfaced subprograms of type FLOAT are always passed by copy. 
Parameters of type LONG FLOAT are passed by address. 

Fixed Point Types (3.5.9,3.5.10] 

Ada fixed-point types are managed by the Compiler as the product of a signed mantissa 
and a constant small. The mantissa is implemented as an 8 or 32 bit integer value. 

Small is a compile-time quantity which is the power of two equal or immediately inferior 
to the delta specified in the declaration of the type. 

The representation of an actual parameter of a fixed point type is the value of its 
mantissa. This is passed using the same rules as for integer types. 

The attribute MANTISSA is defined as the smallest number such that: 

2 •• MANTISSA > = max (abs (upper_bound), abs (lower_bound)) Ismail 

The size of a fixed point type is; 

MANTISSA Size 

1.. 7 8 bits 

8.. 31 32 bits 

Fixed point types requiring a MANTISSA greater than 31 are not supported. 


6 


Alsys Ada for the Transputer, Appendix F, v5 




Access Types [3.8] 


Values of access types are represented internally by the address of the designated object 
held in single word. The value MIN_INT (the smallest integer that can be represented in 
a machine word) is used to represent null. 

Array Types [3.6] 

Ada arrays are passed by address; the value passed is the address of the first element of 
the first dimension of the array. The elements of the array are allocated by row. When 
an array is passed as a parameter to an interfaced subprogram, the usual consistency 
checking between the array bounds declared in the calling and the called subprogram is 
not enforced. It is the programmer’s responsibility to ensure that the subprogram does 
not violate the bounds of the array. 

When passing arrays to Occam, it may be the case that some of its bounds are undefined 
in the source of the interfaced subprogram. If this is true, the missing bounds should be 
passed as extra integer value parameters to the subprogram. These parameters should be 
placed immediately following the array parameter itself and in the same order as the 
missing strides appear in the occam source. 

Values of the predefined type STRING (3.6.3) are arrays, and are passed in the same way: 
the address of the first character in the string is passed. Elements of a string are 
represented in 8 bits, using the standard ASCII codes. The elements are packed into one 
or more words and occupy consecutive locations in memory. 

Record Types [3.7] 

Ada records are passed by address; the value passed is the address of the first component 
of the record. Components of a record are aligned on their natural boundaries (e.g. 
INTEGER on a word boundary) and the components may be re-ordered by the Compiler 
so as to minimize the total size of objects of the record type. If a record contains 
discriminants or components having a dynamic size, implicit components may be added 
to the record. Thus the default layout of the internal structure of the record may not be 
inferred directly from its Ada declaration. The use of a representation clause to control 
the layout of any record type whose values are to be passed to interfaced subprograms is 
recommended. 


Implementation -Dependent Pragmas 


7 



1.2.4 Restrictions on Interfaced Subprograms 

Interfaced occatn subprograms must be compiled using the UNIVERSAL error mode 
(X). In this mode, there is no error checking and any run-time errors in the Occam code 
are ignored. This ensures that processes do not execute a STOPP or STOPERR 
instruction and avoids the unpredictable results which may occur if this is allowed to 
happen. 

Parameters which are of a task or private type, or are access values not of mode in, 
should not be passed to interfaced subprograms. 

It is not possible to interface to occam functions which return floating point values, nor 
to those which have more that one return value. Also, records and arrays cannot be 
returned from interfaced subprograms. 


8 


AlsysAda for ihe Transputer, Appendix F, v5 



1.3 INTERFACE NAME 


Pragma INTTERFACE NAME associates the name of an interfaced subprogram, as 
declared in Ada, with its name in the language of origin. If pragma INTERFACENAME 
is not used, then the twi names are assumed to be identical. 

This pragma takes the form: 

pragma 1 NTERFaCE_NAM,_ (subprogramjiame,srringjiteral)^ 
wheic: 

■ subprogram jiame is the name used within the Ada program to refer to the 
interfaced subprogram. 

■ srrirtgjiieral is the name by which the interfaced subprogram is referred to at link¬ 
time. 

The use of 1NTERFACE_N AME is optional and is not needed if a subprogram has the 
same name in Ada as in the language of origin. It is necessary, for example, if the name 
of the subprogram in its original language contains characters that are not permitted in 
Ada identifiers. Ada identifiers can contain only letters, digits and under'cbres, whereas 
the INMOS linker allows external names to contain other charaaers, for example full 
stops. These characters can be specified in thes/n/ig literal argument of the pragma 
INTERFACE_NAME. 

The pragma INTERFACE_NAME is allowed at the same places of an Ada program as the 
pragma INTERFACE (13.9J. However, the pragma INTERFACE_NAME must always 
occur after the pragma INTERFACE declaration for the interfaced subprogram. 


Example 

package SAMPLE DATA is 

function SAMPLE_DEVICE (X : INTEGER) return INTEGER; 
function PROCESS_SAMPLE (X : INTEGER) return INTEGER; 
private 

pragma INTERFACE (OCCAM, SAMPLE_DEVICE); 
pragma INTERFACE (OCCAM, PROCESS_SAMPLE); 
pragma INTERFACE NAME (PROCESS_SAMPLE, process.sample"); 
end SAMPLE_DATA; 


Implementation-Dependent Pragmas 


9 


1.4 INDENT 


This pragma is only used with the Alsys Reformatter (AdaReformar); this tool offers the 
functionalities of a source reformaiter in an Ada environment. 

The pragma is placed in the source file and interpreted by the Reformatter. 

pragma INDENT(OFF) 

The Reformatter does not modify the source lines after the OFF pragma INDENT, 
pragma INDENT(ON) 

The Reformatter resumes its action after the ON pragma INDENT. Therefore any source 
lines that are bracketed by the OFF and ON pragma INDENTS are not modified by the 
Alsys Reformatter. 


1.5 Other Pragmas 

Pragmas IMPROVE and PACK are discussed in detail in the section on representation 
clauses (Chapter 4). 

Pragmas STORAGE_SIZE_RaTIO and FAST_PRIMARY which are applicable only 
to task types are discussed in detail in section 4.6. 

Pragma PRIORITY is accepted with the range of priorities running from 1 to 10 (see the 
definition of the predefined package SYSTEM in Chapter 3). The undefined priority (no 
pragma PRIORITY) is treated as though it were less than any defined priority value. 

In addition to pragma SUPPRESS, it is possible to suppress checks in a given compilation 
by the use of the Compiler option CHECKS. 

The following language defined pragmas have no effect. 

CONTROLLED 

MEMORY_SIZE 

OPTIMIZE 

storage_unit 

SYSTEM_NAME 

Note that all access types are implemented by default as controlled collections as 
described in [4.8). 


10 


Alsys Ada for the Transputer, Appendix F, \’5 



CHAPTER 2 


Implementation-Dependent Attributes 


In addition to the Representation Attributes of (13.7.2) and (13.7.3), the four attributes 
listed in section 5 (Conventions for Implementation-Generated Names), for use in 
record representation clauses, and the attributes described below are provided: 

TDESCRlPTOR_SIZE For a prefix T that denotes a type or subtype, this 

attribute yields the size (in bits) required to hold a 
descriptor for an object of the type T, allocated on 
the heap or written to a file. If T is constrained, 
TDESCRlPTOR_SlZE will yield the value 0. 

T1S_ARRAY For a prefix T that denotes a type or subtype, this 

attribute yields the value TRUE if T denotes an 
array type or an array subtype; otherwise, it yields 
the value FALSE. 


Limitations on the use of the attribute ADDREISS 

The attribute ADDRESS is implemented for all prefixes that have meaningful addresses. 
The following entities do not have meaningful addresses. The attribute ADDRESS will 
deliver the value SYSTEM.NULL_ADDRESS if applied to such prefixes and a compilation 
warning will be issued. 

■ A constant or named number that is implemented as an immediate value (i.e. does 
not have any space allocated for it). 

■ A package specification that is not a library unit. 

■ A package body that is not a library unit or subunit. 

If the attribute ADDRESS is applied to a named number, a compilation error will be 
produced. 


Implementation-Dependent Attributes 


II 




12 


Alsys Ada for the Transputer, Appendix F, v5 






CHAPTER 3 


SpeciHcation of the Package SYSTEM 


package SYSTEM is 

Type NAME is (180X86, 

180386, 

MC680X0, 

S370, 

TRANSPUTER, 

VAX); 

SYSTEH_NAME : constant NAME := TRANSPUTER; 

STORAGE UNIT constant :: 8; 

MAX INT' : constant := 2*»31 • 1; 

MIn'inT ; constant :* - <2*»31); 

MAx'manTISSA : constant := 31; 

F1nI_DELTA : constant := 2#1.0«-31; 

MAX DIGITS : constant := 15; 

MEMOfiY_SIZE : constant := 2**32; 

TICK : constant := 64.Oe - 6; 

subtype PRIORITY is INTEGER range 1 .. 10; 

type ADDRESS is private; 

NULL ADDRESS : constant ADDRESS; 


function VALUE (LEFT : in STRING) return ADDRESS; 

subtype ADDRESS.STRING is STR1NG(1..8); 

function IMAGE (LEFT : in ADDRESS) return A0DRESS_STR1NG; 


type OFFSET is range -(2**31) .. 2*»31-1; 

'■ This type is used to measure a nutSwr of storage units (bytes), 
function SAME_SEGMENT (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 
ADDRESS ERROR : exception; 


function (LEFT : in ADDRESS; RIGHT : in OFFSET) return ADDRESS; 

function (LEFT : in OFFSET; RIGHT : in ADDRESS) return ADDRESS; 


Specification of the Package SYSTEM 


13 




function (LEFT ; in ADDRESS; RIGHT : in OFFSET) return ADDRESS; 


function (LEFT : in ADDRESS; RIGHT : in ADDRESS) return OFFSET; 


function <•<=" 
function •'<" 
function '■>='• 
function ">" 


(LEFT, RIGHT : in ADDRESS) 
(LEFT, RIGHT : in ADDRESS) 
(LEFT, RIGHT : in ADDRESS) 
(LEFT, RIGHT : in ADDRESS) 


return BOOLEAN 
return BOOLEAN 
return BOOLEAN 
return BOOLEAN 


function “mod" (LEFT : in ADDRESS; RIGHT : in POSITIVE) return NATURAL; 


type ROUNO_OIRECTION is (DOWN, UP); 

function ROUND (VALUE : in ADDRESS; 

DIRECTION : in ROUND DIRECTION; 

MODULUS : in POSItTvE) return ADDRESS; 


generic 

type TARGET is private; 

function FETCH_FROM_ADDRESS (A : in ADDRESS) return TARGET; 
generic 

type TARGET is private; 

procedure ASSIGN_TO_ADDRESS (A : in ADDRESS; T : in TARGET); 

•• These routines are provided to perform READ/URITE operations in memory. 


type OBJECT_LENGTH is range 0 .. -1; 

•• This type is used to designate the size of an object in storage units. 

procedure MOVE (TO : in ADDRESS; 

FROM : in ADDRESS; 

LENGTH : in 06JECT_LENGTH); 


end SYSTEM; 


The function VALUE may be used to convert a string into an address. The string is a 
sequence of up to eight hexadecimal characters (digits or letters in upper or lower case in 
the range A..^ representing the address. The exception CONSTRAINT_ERROR is raised 
if the string does not have the proper syntax. 

The function IMAGE may be used to convert an address to a string which is a sequence of 
exactly eight hexadecimal digits. 

The function SAME_SEGMENT always returns TRUE and the exception 
ADDRESS_ERR0R is never raised as the transputer is a non segmented architecture. 


14 


AlsysAda for the Transputer, Appendix F, vS 



The functions "+" and with an ADDRESS and an OFFSET parameter provide support 
to perform address computations. The OFFSET parameter is added to, or subtracted 
from the address. The exception CONSTRAlNT_ERROR can be raised by these 
functions. 

The function with the two ADDRESS parameters may be used to return the distance 
between the specified addresses. 

The functions "<=",*<",•>=" and ">" may be used to perform a comparison on the 
specified addresses. The comparison is unsigned. 

The function "mod" may be used to return the offset of LEFT address relative to the 
memory block immediately below it starting at a multiple of RIGHT storage units. 

The function ROUND may be used to return the specified address rounded to a specific 
value in a particular direction. 

The generic function FETCH_FROM_ADDRESS may be used to read data objects from 
given addresses in store. The generic function ASS1GN_T0_ADDRESS may be used to 
write data objects to given addresses in store. These routines may not be instantiated 
with unconstrained types. 

The procedure MOVE may be used to copy LENGTH storage units starting at the address 
FROM to the address TO. The source and destination locations may overlap. 


Specification of the Package SYSTEM 


IS 



16 


Alsys Ada for the Transputer, Appendix F, v5 






CHAPTER 4 


Restrictions on Representation Clauses 


This section explains how objects are represented and allocated by the AJsys Ada 
Compiler for the Transputer and how it is possible to control this using representation 
clauses. 

The representation of an object is closely connected with its type. For this reason this 
section addresses successively the representation of enumeration, integer, floating point, 
fixed point, access, task, array and record types. For each class of type the representation 
of the corresponding objects is described. 

The transputer supports operations on the data types byte, word and double-word, so 
these data types are used to form the basis of the representation of Ada types. The word 
length is 32 bits. Currently, the compiler does not support operations on double 32 bit 
word quantities. This affects the representation of integer, fixed point and enumeration 
types. 

Except in the case of array and record types, the description of each class of type is 
independent of the others. To understand the representation of an array type it is 
necessary to understand first the representation of its components. The same rule 
applies to a record type. 

Apart from implementation defined pragmas, Ada provides three means to control the 
size of objects: 

■ a (predefined) pragma PACK, when the object is an array, an array component, a 
record or a record component 

■ a record representation clause, when the object is a record or a record component 

■ a size specification, in any case. 

For each class of types the effect of a size specification is described. Interaction between 
size specifications, packing and record representation clauses is described under array 
and record types. 


Restrictions on Representation Clauses 


17 




Size representation clauses on types derived from private types are not supported when 
the derived type is declared outside the private part of the defining package. 


4.1 Enumeration Types 

Internal codes of enumeration literals 

When no enumeration representation clause applies to an enumeration type, the 
internal code associated with an enumeration literal is the position number of the 
enumeration literal. Then, for an enumeration type with n elements, the internal codes 
are the integers 0,1,2,..., n-1. 

An enumeration represenution clause can be provided to specify the value of each 
internal code as described in [13.3). The Alsys Compiler fully implements enumeration 
representation clauses. 

As internal codes must be machine integers the internal codes provided by an 
enumeration representation clause must be in the range -2^’.. 2^’-l. 


Encoding of enumeration values 

An enumeration value is always represented by its internal code in the program 
generated by the Compiler. 


Enumeration subtypes 

Minimum size: The minimum size of an enumeration subtype is the minimum number 
of bits that is necessary for representing the internal codes of the subtype values in 
normal binary form. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M are 
the values of the internal codes associated with the first and last enumeration values of 
the subtype, then its minimum size L is determined as follows. For m > = 0, L is the 
smallest positive integer such that M < = 2^-1. For m < 0, L is the smallest positive 
integer such that -2 '* < = m and M < = 2*' *-l. 


18 


Alsys Ada for ihe Transputer, Appendix F, vS 



For example; 


type COLOR is (GREEN. BLACK, WHITE, RED, BLUE. YELLOW); 

- The minimum size of COLOR is 3 bits. 

subtype BLACK_AND_WH1TE Is COLOR range BLACK.. WHITE; 

- The minimum size of BLACK_AND_WH1TE is 2 bits. 

subtype BLACK_OR_WHITE is BLACK_AND_WHITE range X .. X; 

- Assuming that X is not static, the minimum size of BLACK_OR_WHlTE is 

- 2 bits (the same as the minimum size of the static type mark 

- BLACK_AND_WHITE). 

Size: When no size specification is applied to an enumeration type or first named 
subtype, the objects of that type or first named subtype are represented as either 
unsigned bytes or signed words. The Compiler selects automatically the smallest such 
object which can hold each of the internal codes of the enumeration type (or subtype). 
The size of the enumeration type and of any of its subtypes is thus 8 bits in the case of an 
unsigned byte, or the machine word size (32 bits) in the case of a signed word. 

When a size specification is applied to an enumeration type, this enumeration type and 
each of its subtypes has the size specified by the length clause. The same rule applies to a 
first named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies. 

For example: 

type EXTENDED is 

( - The usual American ASCII characters. 


NUL, 

SOH, 

STX, 

ETX, 

EOT, 

ENQ. 

ACK, 

BEL, 

BS, 

HT, 

LF. 

VT, 

FF. 

CR, 

SO, 

SI, 

DLE, 

DCl, 

DC2, 

DC3. 

DC4, 

NAK, 

SYN, 

ETB, 

CAN, 

EM, 

SUB, 

ESC. 

FS, 

GS, 

RS, 

US, 

’ 

•I* 

• t 



’S’. 


’&’, 

itt 

t 


•)’. 

»♦» 


f 1 


• t 

r. 

'O’, 

'T. 

’2’, 

■3’, 

’4’. 

’5’, 

’6’. 


’S’, 

•9’, 


■ , 




» 


’A’, 

■B’. 

’C, 

’D’. 

’E’, 

’F, 

•G’. 

■H’, 

T, 

’J’. 

’K’. 

’L’. 

•M’, 

’N’, 

•O’, 

’P’, 

'O’. 

’R’, 

’S’, 

T. 

’U’, 

’V’, 

•w. 

’X’, 

'Y', 

’Z’. 

T. 

r. 

•1'. 

1 A f 

t 



'a', 

’b’. 

’c’. 

’d’. 

’e’, 

T, 



Restrictions on Representation Clauses 19 










h’. 

'r. 

T. 

’k’. 

■1', 

’m\ 

’n’, 

’o’, 

P'. 

■q'. 


's’. 

’t’. 

’u', 

\\ 

’w’, 

x'. 

y. 



T. 



DEL 


— Extended characters 
LEFT_ARROW, 

RlGHT_ARROW, 

UPPER_ARROW, 

LOWER_ ARROW, 

upper_1eft_corner. 

UPPER_RIGHT_CORNER, 

LOWER_RIGHf_CORNER, 

LOWER_LEFT_CORNER, 

...); 

for EXTENDED’SIZE use 8; 

- The size of type EXTENDED will be one byte. Its objects will be represented 

- as unsigned 8 bit integers. 

The AJsys Compiler fully implements size specifications. Nevertheless, as enumeration 
values are coded using integers, the specified length cannot be greater than 32 bits. 

Object size: Provided its size is not constrained by a record component clause or a 
pragma PACK, an object of an enumeration subtype has the same size as its subtype. 

Alignment: An enumeration subtype is byte aligned if the size of the subtype is less than 
or equal to 8 bits, word aligned otherwise. 

Object address: Provided its alignment is not constrained by a record represenution 
clause or a pragma PACK, the address of an object of an enumeration subtype is a 
multiple of the alignment of the corresponding subtype. 


20 


Alsys Ada for the Transputer, Appendix F, i’5 




4.2 Integer Types 

PredeHned integer types 


In the Alsys Ada implementation for the transputer the following predefined integer 
types are available: 

type SHORTJNTEGER is range -2*‘07 .. 2**07-l; 

type INTEGER is range-2»*31.. 2**3M; 


Selection of the parent of an integer type 
An integer type declared by a declaration of the form: 
type T is range L.. R; 

is implicitly derived from one of the predefined integer types. The compiler 
automatically selects the predefined integer type whose range is the shortest that 
contains the values L to R inclusive. 


Encoding of integer values 

Binary code is used to represent integer values, using a conventional two’s complement 
representation. 


Integer subtypes 

Minimum size: The minimum size of an integer subtype is the minimum number of bits 
that is necessary for representing the internal codes of the subtype values in normal 
binary form (that is to say, in an unbiased form which includes a sign bit only if the range 
of the subtype includes negative values). 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M are 
the lower and upper bounds of the subtype, then its minimum size L is determined as 
follows. For m > = 0, L is the smallest positive integer such that M < = For m < 

0, L is the smallest positive integer such that -2^ * <= mandM <= 2i- *-l. 


Restrictions on Representation Clauses 


21 



For example: 

subtype S is INTEGER range 0 .. 7; 

- The minimum size of S is 3 bits. 

subtype D is S range X .. Y; 

- Assuming that X and Y are not static, the minimum size of 

- D is 3 bits (the same as the minimum size of the static type mark S). 

Size; The sizes of the predefined integer types SHORT_lNTEGER and INTEGER are 
respectively 8 and 32 bits. 

When no size specification is applied to an integer type or to its first named subtype (if 
any), its size and the size of any of its subtypes is the size of the predefined type from 
which it derives, directly or indirectly. 

For example: 

type S is range 80.. 100; 

- S is derived from SHORT_lNTEGER, its size is 8 bits. 

type J is range 0.. 65535; 

- J is derived from INTEGER, its size is 32 bits. 

type N is new J range 80.. 100; 

- N is indirectly derived from INTEGER, its size is 32 biu. 

When a size specification is applied to an integer type, this integer type and each of iu 
subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies. 


22 


Alsys Ada for the Transputer, Appendix F, v5 




For example; 


type S is range 80.. 100; 
for S’SIZE use 32; 

- S is derived from SHORTJNTEGER, but its size is 32 bits 

- because of the size specification. 

type J is range 0.. 255; 
forJ’SIZE use 8; 

- J is derived from INTEGER, but its size is 8 bits because 

- of the size specification. 

type N is ne\*' J range 80.. 100; 

- N is indirectly derived from INTEGER, but its size is 8 bits 

- because N inherits the size specification of J. 

The Alsys Compiler implements size specifications. Nevertheless, as integers are 
implemented using machine integers, the specified length cannot be greater than 32 bits. 

Object size: Provided its size is not constrained by a record component clause or a 
pragma PACK, an object of an integer subtype has the same size as its subtype. 

Alignment: An integer subtype is byte aligned if the size of the subtype is less than or 
equal to 8 bits, wo''d aligned otherwise. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of an integer subtype is a multiple of 
the alignment of the corresponding subtype. 


Restrictions on Representation Clauses 


23 



4.3 Floating Point Types 

PredeFined Hoating point types 

There are two predefined floating point types in the Alsys implementation for 
transputers: 

type FLOAT is 

digits 6 range -(2.0 - 2.0*’(-23))*2.0*'127 .. (2.0 - 2.0**(-23))»2.0*’127; 


type LONG_FLOAT is 

digits 15 range -(2.0 - 2.0»*(-51))’2.0*M023 .. (2.0 - 2.0**(-51))’2.0**1023; 


Selection of the parent of a floating point type 
A floating point type declared by a declaration of the form: 
type T is digits D (range L.. R); 

is implicitly derived from a predefined floating point type. The Compiler automatically 
selects the smallest predefined floating point type whose number of digits is greater than 
or equal to D and which contains the values Land R. 


Encoding of floating point values 

In the program generated by the Compiler, floating point values are represented using 
the ANSWEEE 754 standard 32-bit and 64-bit floating point formats as appropriate. 

Values of the predefined type FLOAT are represented using the 32-bit floating point 
format and values of the predefined type LONG FLOAT are represented using the 64- 
bit floating point format as defined by the standard. The values of any other floating 
point type are represented in the same way as the values of the predefined type from 
which it derives, directly or indirectly. 


24 


Alsys Ada for the Transputer, Appendix F, v5 




Floating point subtypes 


Minimum size; The minimum size of a floating point subtype is 32 bits if its base type is 
FLOAT or a type derived from FLOAT and 64 bits if its base type is LONG_FLOAT or 
a type derived from LONG_FLOAT. 

Size: The sizes of the predefined floating point types FLOAT and LONG_FLOAT are 
respectively 32 and 64 bits. 

The size of a floating point type and the size of any of its subtypes is the size of the 
predefined type from which it derives directly or indirectly. 

The only size that can be specified for a floating point type or first named subtype using a 
size specification is its usual size (32, or 64 bits). 

Object size: An object of a floating point subtype has the same size as its subtype. 

Alignment: A floating point subtype is always word aligned. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of a floating point subtype is a 
multiple of the alignment of the corresponding subtype. 


Resnictions on Representation Clauses 


25 





4.4 Fixed Point Types 

Small of a fixed point type 

If no specification of small applies to a fixed point type, then the value of small is 
determined by the value of delta as defined by |3.5.9). 

A specification of small can be used to impose a value of small. The value of small is 
required to be a power of two. 

Predefined fixed point types 

To implement fixed point types, the Alsys Compiler for the transputer uses a set of 
anonymous predefined types. These are; 

type SHORT_FIXED is delta D range -2**7*S.. (2**7-l)‘S; 
for SHORT_FIXED’SMALL use S; 

type FIXED is delta D range -2**3rS.. (2**3M)*S; 
for FIXED’SMALL use S; 

where D is any real value and S any power of two less than or equal to D. 

Selection of the parent of a fixed point type 
A fixed point type declared by a declaration of the form: 

type T is delta D range L.. R; 
possibly with a small specification: 
for rSMALL use S; 

is implicitly derived from a predefined fixed point type. The Compiler automatically 
selects the predefined fixed point type whose small and delta are the same as the small 
and delta of T and whose range is the shortest that includes the values L and R. 

Encoding of fixed point values 

In the program generated by the Compiler, a safe value V of a fixed point subtype F is 
represent^ as the integer: 

V/FBASE’SMALL 


26 


Alsys Ada for the Transputer, Appendix F, v5 




Fixed point subtypes 


Minimum size: The minimum size of a fixed point subtype is the minimum number of 
binary digits that is necessary for representing the values of the range of the subtype 
using the small of the base type (that is to say, in an unbiased form which includes a sign 
bit only if the range of the subtype includes negative values). 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, s and S being 
the bounds of the subtype, if i and I are the integer representations of m and M, the 
smallest and the greatest model numbers of the base type such that s < m and M < S, 
then the minimum size L is determined as follows. For i > = 0, L is the smallest positive 
integer such that 1 < = 2^-1. For i < 0, L is the smallest positive integer such that - 
2*' * < = i and I < = 2’- ‘-l. 

For example: 

type F is delta 2.0 range 0.0.. 500.0; 

- The minimum size of F is 8 bits. 

subtype S is F delta 16.0 range 0.0.. 250.0; 

- The minimum size of S is 7 bits. 

subtype D is S range X.. Y; 

- Assuming that X and Y are not static, the minimum size of D is 7 biu 

- (the same as the minimum size of its type mark S). 

Size: The sizes of the sets of predefined fixed point types SHORT_FlXED, and FIXED are 
8 and 32 bits respectively. 

When no size specification is applied to a fixed point type or to its first named subtype, 
its size and the size of any of iu subtypes is the size of the predefined type from which it 
derives directly or indirectly. 

For example: 

type F is della 0.01 range 0.0.. 1.0; 

- F is derived from a 8 bit predefined fixed type, its size is 8 bits, 
type L is delta 0.01 range 0.0.. 300.0; 

- L is derived from a 32 bit predefined fixed type, its size is 32 bits, 
type N is new L range 0.0.. 2.0; 

-- N is indirectly derived from a 32 bit predefined fixed type, its size is 32 bits. 


Restrictions on Representation Clauses 


27 



When a size specification is applied to a fixed point type, this fixed point type and each of 
its subtypes has the size specified by the length clause. The same role applies to a first 
named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies. 

For example: 

type F is delta 0.01 range 0.0.. 1.0; 
forFSIZEuse 32; 

F is derived from a 8 bit predefined fixed type, but its size is 32 bits 
-- because of the size specification. 

type L is delta 0.01 range 0.0.. 300.0; 
for FSIZE use 16; 

-- F is derived from a 32 bit predefined fixed type, but its size is 16 bits 

- because of the size specification. 

-- The size specification is legal since the range contains no negative values 

- and therefore no sign bit is required. 

type N is new F range 0.8.. 1.0; 

-- N is indirectly derived from a 16 bit predefined fixed type, but its size is 
-- 32 bits because N inherits the size specification of F. 

The Alsys Compiler implements size specifications. Nevertheless, as fixed point objects 
are represented using machine integers, the specified length cannot be greater than 32 
bits. 

Object size: Provided its size is not constrained by a record component clause or a 
pragma PACK, an object of a fixed point type has the same size as its subtype. 

Alignment: A fixed point subtype is byte aligned if its size is less than or equal to 8 biu, 
word aligned otherwise. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of a fixed point subtype is a multiple 
of the alignment of the corresponding subtype. 


28 


Alsys Ada for the Transputer, Appendix F, v5 



4.5 Access Types 

Collection Size 

When no specification of collection size applies to an access type, no storage space is 
reserved for its collection, and the value of the attribute STORAGE_SIZE is then 0. 

As described in [13.2], a specification of collection size can be provided in order to 
reserve storage space for the collection of an access type. The AJsys Compiler fully 
implements this kind of specification. 


Encoding of access values 

Access values are machine addresses represented as machine word - sized values (i.e. 32 
bits). 


Access subtypes 

Minimum size: The minimum size of an access subtype is that of the word size of the 
target transputer. 

Size: The size of an access subtype is the same as its minimum size. 

The only size that can be specified for an access type using a size specification is its usual 
size. 

Object size: An object of an access subtype has the same size as its subtype, thus an 
object of an access subtype is always one machine word long. 

Alignment: An access subtype is always word aligned. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of an access subtype is always on a 
word boundary, since its subtype is word aligned. 


Restrictions on Representation Clauses 


29 



4.6 Task T^pes 

Storage for a task activation 

When no length clause is used to specify the storage space to be reserved for a task 
activation, the storage space indicated at bind time is used for this activation. 

As described in [13.2J, a length clause can be used to specify the storage space for the 
activation of each of the tasks of a given type. In this case the value indicated at bind time 
is ignored for this task type, and the length clause is obeyed. 

Both the length clause and the bind time parameter specify the combined size of the 
task’s primary and auxiliary stacks. Further bind time parameters specify the percentage 
of this storage size to be allocated to the primary stack and indicate whether or not to 
attempt to allocate the primary stack in fast internal memory. These bind time 
parameters indicate the default action and can be overridden using the implementation 
defined pragmas ST0RAGE_S1ZE_RAT10 and FAST_PRIMARY. 

pragma STORAGE_SlZE_RATIO ( taskjianic, integerJitcra !); 

pragma FAST_PR1MARY ( taskjiame , YES | NO ); 

These two pragmas are not allowed for derived types. They apply to the task type 
taskjiame. For each pragma, the pragma and the declaration of the task type to which it 
applies must both occur within the same declarative part or package speciBcation, 
although the declaration of the task type must precede the pragma. 

Pragma STORAGE_SIZE_RATIO specifies the percentage of the total storage size 
reserved for the activation of the task to be used as the task’s primary stack. Any 
remaining storage space will be used as the task’s auxiliary stack. In the absence of the 
pragma the default ratio specified at bind time is used for the activation. 

Pragma FAST_PRIMARY specifies whether or not an attempt should be made to 
allocate the task’s primary stack in fast internal memory. In the absence of the pragma 
the default indication specified at bind time is used for the activation. 


30 


Als)'s Ada for the Transputer, Appendix F, v5 



Encoding of task values 

Task values are represented as machine word sized values. 


Task subtypes 

Minimum size: The minimum size of a task subtype is 32 bits. 

Size: The size of a task subtype is the same as its minimum size. 

The only size that can be specified for a task type using a size specification is its usual 
size. 

Object size: An object of a task subtype has the same size as its subtype. Thus an object 
of a task subtype is always 32 bits long. 

Alignment: A task subtype is always word aligned. 

Object address: Provided its alignment is not constrained by a record representation 
clause, the address of an object of a task subtype is always on a word boundary, sitvce its 
subtype is word aligned. 


Restrictions on Representation Clauses 


31 



4.7 Array Types 

Layout of an array 

Each array is allocated in a contiguous area of storage units. All tne components have 
the same size. A gap may exist between two consecutive components (and after the last 
one). All the gaps have the same size. 


component Gap Component Cap Component Gap 


Components 

If the array is not packed, the size of the components is the size of the subtype of the 
components. 

For example: 

type A is array (1.. 8) of BOOLEAN; 

“ The size of the components of A is the size of the type BOOLEAN: 8 bits. 

type DECIMAL_DIG1T is range 0.. 9; 
for DECIMAL_D1GITS1ZE use 4; 
type BINARY_C0DED_DEC1MAL is 

array (INTEGER range < >) orDECIMAL_DlGIT; 

- The size of the type DECIMAL_D1GIT is 8 bits. Thus in an array of 

- type BlNARY_CODED_DECIMAL each component will be represented in 

- 4 bits as in the usual BCD representation. 

If the array is packed and its components are neither records nor arrays, the size of the 
components is the minimum size of the subtype of the components. 


32 


Alsys Ada for the Transputer, Appendix F, v5 



For example: 


type A is array (1 ..8) of BOOLEAN; 
pragma PACK(A); 

- The size of the components of A is the minimum size of the type BOOLEAN: 

- 1 bit. 

type DECIMAL_DIGIT is range 0 .. 9; 
type BINaRY_CODED_DECIMAL is 

array (INTEGER range <>) of DECIMAL_DIGIT; 
pragma p'ACK(BINARY_CODED_DEaMAL); 

- The size of the type DECIMAL_DIGIT is 8 bits, but, as 

- BIN ARY_C0DED_DECIMAL is packed, each component of an array of this 

- type will be represented in 4 bits as in the usual BCD representation. 

Packing the array has no effect on the size of the components when the components are 
records or arrays. 


Gaps 

If the components are records or arrays, no size specification applies to the subtype of 
the components and the array is not packed, then the Compiler may choose a 
representation with a gap after each component; the aim of the insertion of such gaps is 
to optimize access to the array components and to their subcomponents. The size of the 
gap is chosen so that the relative displacement of consecutive components is a multiple 
of the alignment of the subtype of the components. This strategy allows each component 
and subcomponent to have an address consistent with the alignment of its subtype 

For example: 

type R is 
record 

K; INTEGER; - INTEGER is word aligned. 

B : BOOLEAN; -- BOOLEAN is byte aligned, 
end record; 

- Record type R is word aligned. Its size is 40 bits, 
type A is array (1.. 10) of R; 

- A gap of three bytes is inserted after each component in order to respect the 
” alignment of type R. The size of an array of type A will be 640 bits. 


Restrictions on Representation Clauses 


33 




1 




1 


■ 

1 



D| 

B 


1 

1 


B 

B 


1 _ 




Component Cap Component Gap Component Cap 
Array of type A: each subcomponent K has a word offset. 


If a size specification applies to the subtype of the components or if the array is packed, 
no gaps are inserted. 

For example: 

type R is 
record 

K: INTEGER; 

B : BOOLEAN; 

end record; 

type A is array (1.. 10) of R; 
pragma PACK(A); 

-- There is no gap in an array of type A because A is packed. 

-- The size of an object of type A will be 400 bits. 

type NR is new R; 
for NR’SIZE use 40; 

type B is array (1.. 10) of NR; 

- There is no gap in an array of type B because NR has a size specification. 

- The size of an object of type B will be 400 bits. 



Component Component Component 

Array of type A or B: a subcomponent K can have any byte offset. 


34 


Alsys Ada for the Transputer, Appendix F, v5 









Array subtypes 


Size: The size of an array subtype is obtained by multiplying the number of its 
components by the sum of the size of the components and the size of the gaps (if any). If 
the subtype is unconstrained, the maximum number of components is considered. 

The size of an array subtype cannot be computed at compile time 

■ if it has non-static constraints or is an unconstrained array type with non-static 
index subtypes (because the number of components can then only be determined at 
run time). 

■ if the components are records or arrays and their constraints or the constraints of 
their subcomponents (if any) are not static (because the size of the components and 
the size of the gaps can then only be determined at run time). 

As has been indicated above, the effect of a pragma pack on an array type is to suppress 
the gaps and to reduce the size of the components. The consequence of packing an array 
type is thus to reduce its size. 

If the components of an array are records or arrays and their constraints or the 
constraints of their subcomponents (if any) are not static, the Compiler ignores any 
pragma PACK applied to the array type but issues a warning message. Apart from this 
limitation, array packing is fully implemented by the Alsys Compiler. 

The only size that can be specified for an array type or first named subtype using a size 
specification is its usual size. Nevertheless, such a length clause can be useful to verify 
that the layout of an array is as expected by the application. 

Object size: The size of an object of an array subtype is always equal to the size of the 
subtype of the object. 

Alignment: If no pragma PACK applies to an array subtype and no size specification 
applies to its components, the array subtype has the same alignment as the subtype of its 
components. 

If a pragma PACK applies to an array subtype or if a size specification applies to its 
components (so that there are no gaps), the alignment of the array subtype is the lesser 
of the alignment of the subtype of its components and the relative displacement of the 
components. 


Restrictions on Representation Clauses 


35 



Object address: Provided its alignment is not constrained by a record representation 
clause, the address of an object of an array subtype is a multiple of the alignment of the 
corresponding subtype. 


4.8 Record Types 

Layout of a record 

Each record is allocated in a contiguous area of storage units. The size of a record 
component depends on its type. Gaps may exist between some components. 

The positions and the sizes of the components of a record type object can be controlled 
using a record representation clause as described in (13.4). In the Alsys implementation 
for transputer targets there is no restriction on the position that can be specified for a 
component of a record. If a component is not a record or an array, its size can be any size 
from the minimum size to the size of its subtype. If a component is a record or an array, 
its size must be the size of its subtype. 

In a record representation clause, the first storage unit (that is, a byte) and the first bit 
position within a storage unit are numbered zero. Bits are ordered, and thus numbered, 
least significant bit first within a storage unit. Storage units are numbered such that 
lower numbers have the least significance in a machine word. 

A component clause may be specified such that the component overlaps a storage unit 
boundary. In this case, the bits are numbered in sequence from the least significant bit of 
the first storage unit to the most significant bit of the last storage unit occupied by the 
component. For example: 

type BIT_3 Is range 0.. 7; 
rorBIT_3’SIZEuse3; 

type B1T_5 is range 0.. 31; 
for BITJ’SIZE use 5; 

type BIT_8 Is range 0.. 255; 
for BIT_8’S1ZE use 8; 


36 


Alsys Ado for the Transputer, Appendix F, vS 



type R is 
record 

FIRST: BIT_3; 

SECOND; B1T_8; 

THIRD : B1T_5; 
end record; 
for R use 
record 

FIRST at 0 range 0.. 2; 

SECOND at 0 range 3 10; 

- Component SECOND overlaps a storage unit boundary. 

THIRD at 1 range 3 .. 7; 
end record; 
for R’SIZE use 16; 


Most Significant 
Bit <HS6) 


1 0 









third 


SECOND 


firstI 

1 




1 



7 

3 

2 

0 7 3 

2 

0 


Storage unit nuitser 


Least Significant 
Bit (LSB> 


Bit nun<ber within 
storage unit 


Resen(aiion of a Record of type R 


A record representation clause need not specify the position and the size for every 
component. 

If no component clause applies to a component of a record, its size is the size of its 
subtype. Its position is chosen by the Compiler so as to optimize access to the 
components of the record; the offset of the component is chosen as a multiple of the 
alignment of the component subtype. Moreover, the Compiler chooses the position of 
the component so as to reduce the number of gaps and thus the size of the record 
objeas. 

Because of these optimisations, there is no connection between the order of the 
components in a record type declaration and the positions chosen by the Compiler for 
the components in a record object. 


Restrictions on Representation Clauses 


37 




Pragma PACK has no further effect on records. The AJsys Compiler always optimizes the 
layout of records as described above. 


Indirect components 

If the offset of a component cannot be computed at compile time, this offset is stored in 
the record objects at run time and used to access the component. Such a component is 
said to be indirect while other components are said to be direct; 



Beginning of the record 
Conpile time offset 


Coirpile time offset 


Rvjn time offset 


A direct and an indirect component 


If a record component is a record or an array, the size of its subtype may be evaluated at 
run time and may even depend on the discriminants of the record. We will call these 
components dynamic components. 


38 


Alsys Ada for the Transputer, Appendix F, v5 



For example: 

type DEVICE is (SCREEN, PRINTER); 

type COLOR is (GREEN, RED, BLUE); 

type SERIES is array (POSITIVE range < >) of INTEGER; 

type GRAPH (L : NATURAL) is 
record 

X : SER1ES(1 .. L): - The size of X depends on L 
Y ; SERIES(1 .. L); - The size of Y depends on L 

end record; 

Q ; POSITIVE; 

type PICTURE (N : NATURAL; D : DEVICE) is 
record 

F: GRAPH(N); - The size of F depends on N 
S : GRAPH(Q); -- The size of S depends on Q 
case D is 

when SCREEN = > 

C: COLOR; 
when PRINTER = > 
null; 

end case; 
end record; 

Any component placed after a dynamic component has an offset which cannot be 
evaluated at compile time and is thus indirect. In order to minimize the number of 
indirect components, the Compiler groups the dynamic components together and places 
them at the end of the record; 


Restrictions on Representation Clauses 


39 



D = SCREEN 
N = 2 


D s PRINTER 
N = 1 


S OFFSET 


F OFFSET 


Beginning of the record 
- Cofnpile time offsets — 


S OFFSET 


F OFFSET 


Hun time offsets 





The record type PICTURE: F and S are placed at the end of the record 


Thanks lo this strategy, the only indirect components are dynamic components. But not 
all dynamic components are necessarily indirect: if there are dynamic components in a 
component list which is not followed by a variant pan, then exactly one dynamic 
component of this list is a direct component because its offset can be computed at 
compilation time. 


40 


Atsys Ada for the Transputer, Appendix F, v5 




For example: 



- Y OFFSET 


L 




X 


Y 


Beginning of the record 
Conpite time offset 


Compile time offset 
Size dependent on discriminant L 
' Ron time offset 

Size dependent on discriminant L 


The record type GRAPH: the dynamic component X is a direct component. 


The offset of an indirect component is always expressed in storage units. 

The space reserved for the offset of an indirect component must be large enough to store 
the size of any value of the record type (the maximum potential offset). The Compiler 
evaluates an upper bound MS of this size and treats an offset as a component having an 
anonymous integer type whose range is 0.. MS. 

If C is the name of an indirect component, then the offset of this component can be 
denoted in a component clause by the implementation generated name C’OFFSET. 


Implicit components 

In some circumstances, access to an object of a record type or to its components involves 
computing information which only depends on the disaiminant values. To avoid 
unnecessary recomputation, the Compiler stores this information in the record objects, 
updates it when the values of the discriminants are modified and uses it when the objects 
or their components are accessed. This information is stored in special components 
called implicit components. 


Restrictions on Representation Clauses 


41 






An implicit component may contain information which is used when the record object or 
several of its components are accessed. In this case the component will be included in any 
record object (the implicit component is considered to be declared before any variant 
part in the record type declaration). There can be two components of this kind; one is 
called RECORD_SIZE and the other vaRIANTJNDEX. 

On the other hand an implicit component may be used to access a given record 
component. In this case the implicit component exists whenever the record component 
exists (the implicit component is considered to be declared at the same place as the 
record component). Components of this kind are called ARRAY_DESCRIPTORs or 
RECORD_DESCRIPTORs. 

RECORDJIZE 

This implicit component is created by the Compiler when the record type has a variant 
part and its discriminants are defaulted, it contains the size of the storage space 
necessary to store the current value of the record object (note that the storage effectively 
allocated for the record object may be more than this). 

The value of a RECORD_SlZE component may denote a number of bits or a number of 
storage units. In general it denotes a number of storage units, but if any component 
clause specifies that a component of the record type has an offset or a size which cannot 
be expressed using storage units, then the value designates a number of bits. 

The implicit component RECORD_SIZE must be large enough to store the maximum 
size of any value of the record type. The Compiler evaluates an upper bound MS of this 
size and then considers the implicit component as having an anonymous integer type 
whose range is 0.. MS. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R’RECORD_SIZE. 

VARIANTJNDEX 

This implicit component is created by the Compiler when the record type has a variant 
part. It indicates the set of components that are present in a record value. It is used when 
a discriminant check is to be done. 

Component lists that do not contain a variant part are numbered. These numbers are the 
possible values of the implicit component VARIANTJNDEX. 


42 


Als)’s Ada for the Transputer, Appendix F, i’5 



For example; 


type VEHICLE is (AIRCRAFT, ROCKET, BOAT, CAR); 

type DESCRIPTION (KIND : VEHICLE := CAR) is 
record 

SPEED: INTEGER; 
case KIND is 

when AIRCRAFT | CAR = > 

WHEELS: INTEGER; 
case KIND is 

when AIRCRAFT = > — 1 

WINGSPAN; INTEGER; 
when others = > —2 

null; 
end case; 

when BOAT = > --3 

STEAM : BOOLEAN; 
when ROCKET = > --4 

STAGES: INTEGER; 
end case; 
end record; 

The value of the variant index indicates the set of components that are present in a 
record value; 


Variant Index 

Set 

1 

<KIND. SPEED, WHEELS, WINGSPAN} 

2 

UIMD, SPEED, WHEELS} 

3 

{KINO, SPEED, STEAM} 

U 

{KINO, SPEED, STAGES} 


A comparison between the variant index of a record value and the bounds of an interval 
is enough to check that a given component is present in the value: 


Restrictions on Representation Clauses 


43 




Conponent 

Interval 

KINO 


SPEED 

-- 

WHEELS 

1 .. 2 

WINGSPAN 

1 .. 1 

STEAH 

3 .. 3 

STAGES 

4 .. 4 


The implicit component vaRIANT INDEX must be large enough to store the number V 
of component lists that don’t contain variant parts. The Compiler treats this implicit 
component as having an anonymous integer type whose range is 1 .. V. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R’VaRIANTJNDEX. 

ARRA YJDESCRIPTOR 

An implicit component of this kind is associated by the Compiler with each record 
component whose subtype is an anonymous array subtype that depends on a discriminant 
of the record. It contains information about the component subtype. 

The structure of an implicit component of kind ARRAY_DESCRIPT0R is not described 
in this documentation. Nevertheless, if a programmer is interested in specifying the 
location of a component of this kind using a component clause, he can obtain the size of 
the component using the ASSEMBLY parameter in the COMPILE command. 

The Compiler treats an implicit component of the kind ARRAY DESCRIPTOR as having 
an anonymous record type. If C is the name of the record component whose subtype is 
described by the array descriptor, then this implicit component can be denoted in a 
component clause by the implementation generated name CARRAY_DESCRIPTOR. 

RECORD_DESCRlPTOR 

An implicit component of this kind is associated by the Compiler with each record 
component whose subtype is an anonymous record subtype that depends on a 
disCTiminant of the record. It contains information about the component subtype. 

The structure of an implicit component of kind RECORD_DESCRIPTOR is not described 
in this documentation. Nevertheless, if a programmer is interested in specifying the 
location of a component of this kind using a component clause, he can obtain the size of 
the component using the ASSEMBLY parameter in the COMPILE command. 


44 


Alsys Ada for the Transputer, Appendix F, vS 




The Compiler treats an implicit component of the kind RECORD_DESCRIPTOR as 
having an anonymous record type. If C is the name of the record component whose 
subtype is described by the record descriptor, then this implicit component can be 
denoted in a component clause by the implementation generated name 
CRECORD_DESCRIPTOR. 


Suppression of implicit components 

The Alsys implementation provides the capability of suppressing the implicit 
components RECORD SIZE and/or variaNT_ 1NDEX from a record type. This can be 
done using an implementation defined pragma called IMPROVE. The syntax of this 
pragma is as follows: 

pragma IMPROVE (TIME | SPACE, (ON = >] simple_name ); 

The first argument specifies whether TIME or SPACE is the primary criterion for the 
choice of the representation of the record type that is denoted by the second argument. 

If TIME is specified, the Compiler inserts implicit components as described above. If on 
the other hand SPACE is specified, the Compiler only inserts a VARIANTJNDEX or a 
RECORD_SlZE component if this component appears in a record representation clause 
that applies to the record type. A record representation clause can thus be used to keep 
one implicit component while suppressing the other. 

A pragma IMPROVE that applies to a given record type can occur anywhere that a 
representation clause is allowed for this type. 


Record subtypes 

Size: Unless a component clause specifies that a component of a record type has an 
offset or a size which cannot be expressed using storage units, the size of a record subtype 
is rounded up to a whole number of storage units. 

The size of a constrained record subtype is obtained by adding the sizes of its 
components and the sizes of its gaps (if any). This size is not computed at compile time 

■ when the record subtype has non-static constraints, 

■ when a component is an array or a record and its size is not computed at compile 
time. 


Restrictions on Representation Clauses 


45 



The size of an unconstrained record subtype is obtained by adding the sizes of the 
components and the sizes of the gaps (if any) of its largest variant. If the size of a 
component or of a gap cannot be evaluated exactly at compile time, an upper bound of 
this size is used by the Compiler to compute the subtype size. 

The only size that can be specified for a record type or first named subtype using a size 
specification is its usual size. Nevertheless, such a length clause can be useful to verify 
that the layout of a record is as expected by the application. 

Object size: An object of a constrained record subtype has the same size as its subtype. 

An object of an unconstrained record subtype has the same size as its subtype if this size 
is less than or equal to 4 Kbyte. If the size of the subtype is greater than this, the object 
has the size necessary to store its current value; storage space is allocated and released as 
the discriminants of the record change. 

Alignment: When no record representation clause applies to its base type, a record 
subtype has the same alignment as the component with the highest alignment 
requirement. 

When a record representation clause that does not contain an alignment clause applies 
to its base type, a record subtype has the same alignment as the component with the 
highest alignment requirement which has not been overridden by its component clause. 

When a record representation clause that contains an alignment clause applies to its base 
type, a record subtype has an alignment that obeys the alignment clause. 

Object address: Provided its alignment is not constrained by a representation clause, the 
address of an object of a record subtype is a multiple of the alignment of the 
corresponding subtype. 


46 


Alsys Ada for the Transputer, Appendix F, v5 


CHAPTER 5 


Conventions for Implementation-Generated Names 


Special record components are introduced by the Compiler for certain record type 
definitions. Such record components are implementation-dependent; they are used by 
the Compiler to improve the quality of the generated code for certain operations on the 
record types. The existence of these components is established by the Compiler 
depending on implementation-dependent criteria. Attributes are defined for referring to 
them in record representation clauses. An error message is issued by the Compiler if the 
user refers to an implementation-dependent component that does not exist. If the 
implementation-dependent component exists, the Compiler checks that the storage 
location specified in the component clause is compatible with the treatment of this 
component and the storage locations of other components. An error message is issued if 
this check fails. 

There are four such attributes; 

TRECORD_SIZE For a prefix T that denotes a record type. This attribute 

refers to the record component introduced by the Compiler 
in a record to store the size of the record object. This 
component exists for objects of a record type with 
defaulted discriminants when the sizes of the record objects 
depend on the values of the discriminants. 

TVARIANTJNDEX For a prefix T that denotes a record type. This attribute 

refers to the record component introduced by the Compiler 
in a record to assist in the efficient implementation of 
discriminant checks. This component exists for objects of a 
record type with variant type. 

C’ARRAY_DESCRIPT0R For a prefix C that denotes a record component of an array 

type whose component subtype definition depends on 
discriminants, litis attribute refers to the record 
component introduced by the Compiler in a record to store 
information on subtypes of components that depend on 
discriminants. 


Conventions for Implementation Generated Names 


47 



C’RECORD DESCRIPI OR For a prefu C that denotes a record component of a record 

type whose component subtype definition depends on 
discriminants. TTiis attribute refers to the record 
component introduced by the Compiler in a record to store 
information on subtypes of components that depend on 
discriminants. 


48 


Alsys Ada for the Transputer, Appendix F, vS 



CHAPTER 6 


Address Clauses 

6.1 Address Clauses for Objects 

An address clause can be used to specify an address for an object as described in [13.5). 
When such a clause applies to an object no storage is allocated for it in the program 
generated by the Compiler. The program accesses the object using the address specified 
in the clause. 

An address clause is not allowed for task objects, nor for unconstrained records whose 
maximum possible size is greater than 4 Kbytes. 


6.2 Address Clauses for Program Units 

Address clauses for program units are not implemented. 


6.3 Address Clauses for Entries 

Address clauses for entries are not implemented. 


Address Clauses 


4? 



50 


Abys Ada for the Transputer, Appendix F, v5 




CHAPTER 7 


Restrictions on Unchecked Conversions 


Unconstrained arrays are not allowed as target types. 

Unconstrained record types without defaulted discriminants are not allowed as target 
types. 

If the source and the target types are each scalar or access types, the sizes of the objects 
of the source and target types must be equal. It a composite type is used either as the 
source type or as the target type this restriction on the size does not apply. 

If the source and the target types are each of scalai or access type or if they are both of 
composite type, the effect of the function is to return the operand. 

In other cases the effect of unchecked conversion can be considered as a copy: 

■ if an unchecked conversion is achieved o^ a scalar or access source type to a 
composite target type, the result of the function is a copy of the source operand: the 
result has the size of the source. 

■ if an unchecked conversion is achieved of a composite source type to a scalar or 
access target type, the result of the function is a copy of the source operand: the 
result has the size of the target. 


Restriction^ on Unchecked Conversions 


51 



Als)'s Ada for the Transputer, Appendu T, v5 








CHAPTER 8 


Input-Output Packages 


The predefined input-output packages SEOUENTIALJO (14.2.3), DIRECTJO (14.2.5), 
TEXTJO (14.3.10) and IO_EXCEPnONS (14.5) arc implemented as described in the 
Language Reference Manual. 

It should be noted that, in order to generate output, calls to PUT procedures should be 
followed by a call to either PUT_LINE or NEW LINE. 

The package LOW LEVELJO (14.6), which is concerned with low-level machine- 
dependent input-output, is not implemented. 

All access to the services of the host system are provided through the INMOS supplied 
iserver tool (Ref.3), so much of Ada input - output is host independent. 


8.1 NAME Parameter 

No special treatment is applied to the NAME parameter supplied to the Ada procedures 
CREATE or OPEN (14.2.1). This parameter is passed immediately on to the INMOS 
server and from there to the host operating system. The file name can thus be in any 
format acceptable to the host system. 


8.2 FORM Parameter 

The FORM parameter comprises a set of attributes formulated according to the lexical 
rules of (2), separated by commas. The FORM parameter may be given as a null string 
except when DIRECTJO is instantiated with an unconstrained type; in this case the 
record size attribute must be provided. Attributes are comma-separated; blanks may be 
inserted between lexical elements as desired. In the descriptions below the meanings of 
natural,positive, etc., are as in Ada; attribute keywords {represented in upper case) are 
identifiers (2.3) and as such may be specified without regard to case. 

USE ERROR is raised if the FORM parameter does not conform to these rules. 


Input-Output Packages 


53 


The attributes are as follows; 

8.2.1 File Sharing 

This attribute allows control over the sharing of one external file between several 
internal files within a single program. In effect it establishes rules for subsequent OPEN 
and CREATE calls which specify the same external file. If such rules are violated or if a 
different file sharing attribute is specified in a later OPEN or CREATE call, 
USE_ERROR will be raised. The syntax is as follows; 

NOT_SHARED | 

SHARED = > access mode 


where 

QCcess_mode :;= READERS | SINGLE_WRITER | ANY; 

A file sharing attribute of; 

NOT_SHARED implies only one internal file may access the 

external file. 

SHARED = > READERS imposes no restrictions on internal files of 

mode IN FILE, but prevents any internal files 
of mode OUT_FILE or INOUT_FILE being 
associated with the external file. 

SHARED = > SINGLE_WRITER is as SHARED = > READERS, but in 

addition allows a single internal file of mode 
OUT_FILE or INOUT_FILE. 

SHARED = > ANY places no restriction on external file string. 

If a file of the same name has previously been opened or created, the default is taken 

from that file’s sharing attribute, otherwise the default depends on the mode of the file; 

for mode IN FILE the default is SHARED « > READERS, for modes INOUT_FILE 

and OUT_fTlE the default is NOT_SHARED. 


54 


Alsys Ada for the Transputer, Appendix F, v5 



8.2.2 Binary Files 

Two FORM attributes, RECORD_SIZE and RECORD_UNIT, control the structure of 
binary files. 

A binary file can be viewed as a sequence (sequential access) or a set (direct access) of 
consecutive RECORDS. 

The structure of such a record is: 

1 HEADER ] OBJECT ( UNUSED_PART) 

and it is formed from up to three items: 

a an OBJECT with the exact binary representation of the Ada object in the executable 
program, possibly including an object descriptor 

a a HEADER consisting of two word sized fields; 

- the length of the object in bytes 

- the length of the descriptor in bytes 

a an UNUSED_PART of variable size to permit full control of the record’s size 

The HEADER is implemented only if the actual parameter of the instantiation of the lO 
package is unconstrained. 

The file structure attributes take the form: 

RECORD_SIZE = > size_in_bytes 
RECORD_UNIT = > sizejn bytes 

Their meaning depends on the object’s type (constrained or not) and the file access mode 
(sequential or direct access): 

a) If the object’s type is constrained; 

- The RECORD_UNIT attribute is illegal 

- If the RECORD_SIZE attribute is omitted, no UNUSED_PART will be 
implemented: the default RECORD SIZE is the object’s size 


Inpur-Outpui Packages 


55 



- If present, the RECORD_SIZE attribute must specify a record size greater than 
or equal to the object’s size, otherwise the exception USE_ERROR will be 
raised 

b) If the object’s type is unconstrained and the file access mode is direct; 

- The RECORD_UNlT attribute is illegal 

- The RECORD_SlZE attribute has no default value, and if it is not specified, a 
USE_ERROR will be raised 

- An attempt to input or output an object larger than the given RECORD_SIZE 
will raise the exception DATa_ERROR 

c) If the object's type is unconstrained and the file access mode is sequential: 

- The RECORD_SIZE attribute is illegal 

- The default value of the RECORD_UNIT attribute is 1 (byte) 

- The record size will be the smallest multiple of the specified (or default) 
RECORD_UNlT that holds the object and its header. This is the only case 
where records of a file may have different sizes. 

In all cases the value given must not be smaller than a minimum size. For constrained 
types, this minimum size is ELEMENT_TYPE'S1ZE / SYSTEM.STORAGE_UNIT; 
USE_ERROR will be raised if this rule is violated. For unconstrained types, the 
minimum size is ELEMENT_TYPE’DESCRlPTOR_SIZE / 
SYSTEM.STORAGE_UNIT plus the size of the largest record which is to be read or 
written. If a larger record is processed, DATA_ERROR will be raised by the READ or 
WRITE. 


8.2J BufTering 

This attribute controls the size of the buffer used as a cache for input-output operations: 
BUFFER_S!ZE = > size_in_bytes 

The default value for BUFFER_SIZE is 0; which means no buffering. 


56 


Alsys Ada for the Transputer, Appendix F, i’5 


8.2.4 Appending 


parameter of the OPEN command. If 

used in the FORM parameter of the CREATE command, USE_ERROR will be raised. 
The affect of this attribute is to cause writing to commence at the end of the existing file. 
The syntax of the APPEND attribute is simply: 

APPEND 

The default is APPEND = > FALSE, but this is overridden if this attribute is specified. 

In normal circumstanas. when an external file is opened, an index is set which points to 
the beginning of the file. If the APPEND attribute is present for a sequential orfo^r a text 
file, then data transfer will commence at the end of the file. For a direct access file the 
value of the index is set to one more than the number of records in the external file. 

This attribute is not applicable to terminal devices. 


8,3 USE_ERROR 

The following conditions will cause USE_ERROR to be raised: 

• Specifying a FORM parameter whose syntax does not conform to the rules given 

ahnvp 


Sp^ifying the RECORD.SIZE FORM parameter attribute to have a value of zero or 
failing to specify RECORD_SlZE for instantiations of DIRECT lO for unconstrained 
types. 


■ Specifying a RECORD_SIZE FORM parameter attribute to have a value less than 
that required to hold the element for instantiations of DIRECT lO and 
SEQUENTIAL IO for constrained types. 

■ Violating the file sharing rules stated above. 

■ Attempting to perform an input - output operation which is not supported by the 
INMOS iserver due to restrictions of the host operating system. 

■ Errors detected whilst reading or writing (e.g. writing to a file on a read-only disk). 


Input-Output Packages 


57 



58 


Alsys Ada for the Transputer, Appendix F, v5 






CHAPTER 9 


Characteristics of Numeric Types 
9.1 Integer Types 

The ranges of values for integer types declared in package STANDARD are as follows: 
SHORTJNTEGER -128.. 127 - 2**7 - 1 

INTEGER -2147483648.. 2147483647 - 2 * ’ 31 - 1 

Other Integer Types 

For the packages DIRECT_IO and TEXT_!0, the ranges of values for types COUNT 
and POSITIVE_COUNT a7e as follows: 

COUNT 0.. 2147483647 - 2* *31 - 1 

POSITIVE_COUNT 1 •• 2147483647 - 2”31 - 1 

For the package TEXT IO, the range of values for the type FIELD is as follows: 
FIELD 0.255 -2**8-l 


Characteristics of Numeric Types 


59 



9.2 Floating Point Type Attributes 


FLOAT 


DIGITS 

MANTISSA 

EMAX 

EPSILON 

SMALL 

LARGE 

SAFE_EMAX 

SAFE_SMALL 

safe_large 

FIRST 

LAST 

MACHINE_RADIX 

MACHINE_MANT1SSA 

MACH1NE_EMAX 

MACH1NE_EMIN 

MACHINE_ROUNDS 

MACHINE_OVERFLOWS 

SIZE 


6 

21 

84 

2.0 *♦ -20 
2.0 •* -85 

2.0 ** 84 * (1.0 - 2.0 ** -21) 
125 

2.0 •* -126 

2.0 •* 125 ♦ (1.0 - 2.0 ** -21) 
-2.0 ** 127 ♦ (2.0 - 2.0 ** -23) 
2.0 •* 127 * (2.0 - 2.0 ** -23) 

2 

24 

128 

-125 

TRUE 

TRUE 

32 


Approximate 

value 


9.54E-7 

2.58E-26 

1.93E+25 

1.18E-38 

4.25E+37 

-3.40E+38 

3.40E+38 


60 


. ilsys Ada for the Transputer, Appendix F, v5 




LONG float 


DIGITS 

MANTISSA 

EMAX 

EPSILON 

SMALL 

LARGE 

SAFE_EMAX 

SAFE_SMALL 

SAFE_LARGE 

FIRST 

LAST 

MACH1NE_RADIX 

machine”mantissa 

machine“emax 

machine'emin 

MACHINE~ROUNDS 

machine overflows 
size 


Approximate 


value 


15 

51 

204 


2.0 *• -50 

8.88E-16 

2.0 ** -205 

1.94E-62 

2.0 ** 204 • (1.0-2.0** -51) 

1021 

2.57E-f61 

2.0 ** -1022 

2.22E-308 

2.0 *• 1021 * (1.0-2.0 ** -51) 

2.25E+307 

-2.0** 1023 *(2.0-2.0 **-51) 

-1.79E+308 

2.0** 1023* (2.0-2.0**-51) 

2 

53 

1024 

-1021 

TRUE 

TRUE 

64 

1.79E+30S 


9.3 Attributes of Type DURATION 


duration-delta 2.0**-14 

DURATION-SMALL 2.0 **-14 

duration-large 131072.0 

DURATION-FIRST -86400.0 

DURATION-LAST 86400.0 


Characteristics of Numeric Types 


61 



62 


Alsys Ada for ihe Transputer, Appendix F, v5 




REFERENCES 


[1] Reference Manual for the Ada Programming Language 
(ANSI/M1L-STD-1815A-1983). 

[2] Occam2 Reference Manual. 

INMOS Limited 
Prentice Hall, 1988. 

[3] Occam2 Toolset User Manual. 

INMOS Limited. 1989. 

INMOS document number 72 TDS 184 00. 

[4] Transputer Instruction Set - A Compiler Writer’s Guide 
INMOS Limited 

Prentice Hall, 1988 


References 



64 


Alsys Ada for the Transputer, Appendix F, \’5 





INDEX 


ADDRESS attribute 11 
restrictions 11 
Append attribute 57 
ARRAY_DESCRlPTOR attribute 47 
ASCII 6,7 
Attributes 11 

ARRAY DESCRIPTOR 47 
DESCRlPTOR_SlZE 11 
1S_ARRAY 11 
RECORD_DESCRIPTOR 48 
RECORD_SlZE 47. 53 
representation attributes 11 
VAR1ANT_1NDEX 47 

BOOLEAN 6 

CHARACTER 6 
COUNT 59 

DESCRIPTOR SIZE attribute 11,56 
DIRECTJO 53,59 
DURATION 
attributes 61 

Enumeration types 5 
BOOLEAN 6 
CHARACTER 6 

FAST_PR1MARY 10,30 
FIELD 59 

File sharing attribute 54 
Fixed point types 6 
DURATION 61 
FLOAT 6,60 
Floating point types 6 
FLOAT 6,60 
LONG FLOAT 6,61 


FORM parameter 53 
FORM parameter attributes 
append 57 

file sharing attribute 54 
record size attribute 57 

Implementation-dependent attributes 
11 

Implementation-dependent pragma 3 
Implementation-generated names 47 
IMPROVE 10 
INDENT 10 
INLINE 3 

Input-Output packages 53 
DIRECT lO 53 
10_EXCEPT10NS 53 
LOW LEVEL_10 53 
SEQUENTIAL lO 53 
TEXT lO 53 
INTEGER 5,59 
Integer types 5,59 
COUNT 59 
FIELD 59 
INTEGER 5,59 
POSlTIVE_COUNT 59 
SHORTJNTEGER 5,59 
INTERFACE 3 
INTERFACE_NAME 3.9 
Interfaced subprograms 
Restrictions 8 
IO_EXCEPTIONS 53 
IS_ARRAY attribute 11 

Languagename 3 
LONG_FLOAT 6,61 
LOW_LEVEL_IO 53 


Index 


65 



NOT_SHARED 54 
Numeric types 
integer types 59 

Occam 4 

PACK 10 

Parameter representations 5 
Access types 7 
Array types 7 
Enumeration types 5 
Fixed point types 6 
Floating point types 6 
Integer types 5 
Record types 7 

Parameter-passing conventions 4 
POSITIVE COUNT 59 
Pragma INLINE 3 
Pragma INTERFACE 3 
language_name 3 
Occam 4 

subprogram_name 3 
Pragma INTERFACE_NAME 3 
string_literal 9 
subprogram_name 9 
Pragmas 

FAST PRIMARY 10.30 
IMPROVE 10 
INDENT 10 
INTERFACE 3 
INTERFACE NAME 9 
PACK 10 
PRIORITY 10 

STORAGE_SIZE_RATIO 10,30 
SUPPRESS 10 
PRIORITY 10 


characteristics 59 
Fixed point types 61 
RECORD_DESCRIPTOR attribute 
48 

RECORD_SlZE attribute 47,53,57 
Representation attributes 11 
Representation clauses 17 
restrictions 17 

SEQUENTIAL lO 53 
SHARED 54 
SHORT_INTEGER 5,59 
STORAGE SIZE RATIO 10, 30 
STRING 7~ 

String literal 9 
Subprogram name 3,9 
SUPPRESS "lO 
SYSTEM package 13 

TEXTJO 53,59 

Unchecked conversions 51 
restrictions 51 
USE_ERROR 53,57 

VARIANT_INDEX attribute 47 


66 


Alsys Ada for the Transputer, Appendix F, v5 



