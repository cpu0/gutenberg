REPORT DO AD-A246 509 


PiMc (ipoctlnQ buniwi tor M eolMlion ol ManiMbon b I 
i«adMl,Mli<wlMtngthooolKiionalHonMlioa Sondi 
HoodquvIM Sonic*. OtadoiM lor Mbinialion Cborbloi 
ltaiM«*nMn(indBudgb. WUhkiBton.OC 20601 


LY (Laava 


i 


I Fom Approved 

OPM No. 0704-0188 


atom, MiicNng uMng dbo •owow gahoring (lid moHbnlng (to d«a 
t lnloniimDn.>iclud>ig ( iggw i l n m tor iQdudngdib burton, to WMliIngoin 
. ^-4302. ond to >i* ORb* ol Inloniitllon (nd FbguMory Alhiin. Offioo of 




4. TITLE AND SUBTITLE 

TeleSoft, IB<M Ada 370, Version 1.2.0 (wfth optimization) IBM 4381. MVS/ESA Rel. 
3.1 (Opt) (Host & Target). 910612W1.11167 


6. AUTHOR(S) 

Wright-Patterson AFB, Dayton, OH 
USA 


RFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

Ada Validation Facility, Language Control Facility ASD/SCEL 
Bldg. 676, Rm 135 

Wright-Patterson AFB, Dayton, OH 45433 


S. FUNDING NUMBERS 


& 



a. PERFORMING ORGANIZATION 
REPORT NUMBER 

AVF-VSR-474-0292 


9. SPONSORINGA40NITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm 3E114 
Washington, D.C. 20301-3081 


12a. DISTRIBUTION/AVAILABIUTY STATEM 

Approved for public release; distribution unlimited. 


10. SPONSORINGARONITORING AGENCY 
REPORT NUMBER 



12b. DISTRIBUTION CODE 


13. ABSTRACT (Maximum 200 words) 

TeleSoft, IB<M Ada 370, Version 1.2.0 (with optimization) IBM 4381. Wright-Patterson AFB, MVS/ESA Rel. 3.1 (Opt) 
(Host & Target), ACVC 1.11. 




DTIC 

|ELECTE 
FEB 281992 


D 




Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-ST0-1815A, AJPO. 




17. 

OF REPORT 
UNCLASSIFIED 


18. SECURITY CLASSIFICATION 

UNCLASSIFED 


19. SECURITY CLASSIFICATION 
OF ABSTRACT 

UNCLASSIFIED 


15. NUMBER OF PAGES 


16. PRICE CODE 


20. UM RATION OF ABSTRACT 


MSN 7540-01-280-550 


Standard Form 298, (Rav. 2-89) 
Prescribed by ANSI Std. 239-128 















AVF Control Number: AVF-VSR-474-0292 

4 February 1992 
91-04-24-TEL 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 910612W1.11167 
TeleSoft 

IBM Ada/370, Version 1.2.0 (with optimization) 

IBM 4381, MVS/ESA Rel. 3.1 (Opt) -> IBM 4381, MVS/ESA Rel. 3.1 (Opt) 


Prepared By: 
Ada_Validation_Facility 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 


92-04683 

llilililii 


2 24 0 00 






Certificate Information 


The folloving Ada implementation was tested and determined to pass ACVC 
1.11. Testing vas completed on 12 June 1991. 

Compiler Name and Version: IBM Ada/370, Version 1.2.0 (vith optimization) 

Host Computer System: IBM 4381, MVS/ESA Rel. 3.1 (Optimized) 

Target Computer System: IBM 4381, MVS/ESA Rel. 3.1 (Optimized) 

Customer Agreement Number: 91-04-24-TEL 


See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 

910612V1.11167 is awarded to TeleSoft. This certificate expires on 1 June 

1993. 


This report has been reviewed and is approved. 



Steven P. Vilson 
Technical Director 
ASD/SCEL 

Vright-Patterson AFB OH 45433-6503 


Institute 


Alexandria VA 22311 


g h Organization 

puter and Software Engineering Division 
Defense Analyses 




-Ada Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 


Washington DC 20301 







DECLARATION OF CONFORMANCE 





TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 


1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 


APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 


APPENDIX C 


APPENDIX F OF THE Ada STANDARD 















CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro90] against the Ada Standard [Ada83] using the 
current Ada Compiler Validation Capability (ACVC). This Validation Summary 
Report (VSR) gives an account of the testing of this Ada implementation. 

For any technical terms used in this report, the reader is referred to 
[Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national lavs of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the computers, operating systems, and compiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject implementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1-1 






INTRODUCTION 


1.2 REFERENCES 

[Ada83] Reference Manual for the Ada Programming Language , 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro90] Ada Compiler Validation Procedures , Version 2.1, Ada Joint 
Program Office, August 1990. 

[UG89] Ada Compiler Validation Capability User's Guide , 21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: A, 
B, C, D, E, and L. The first letter of a test neune identifies the class to 
which it belongs. Class A, C, D, and E tests are executable. Class B and 
class L tests are expected to produce errors at compile time and link time, 
respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECR_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class 
B tests are no.t executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 


1-2 





INTRODUCTION 


For each Ada Implementation, a customized test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragraph, removing withdrawn tests (see section 2.1), and 
possibly removing some inapplicable tests (see section 2.2 and IUG89J). 

In order to pass sui ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 

Ada Compiler The software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compiler The means for testing compliance of Ada implementations. 
Validation consisting of the test suite, the support programs, the ACVC 

Capability user's guide and the template for the validation summary 

(ACVC) report. 

Ada An Ada compiler with its host computer system and its 

Implementation target computer system. 

Ada Joint The part of the certification body which provides policy and 
Program guidance for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification body which carries out the 

Validation procedures required to establish the compliamce of an Ada 
Facility (AVF) implementation. 

Ada The part of the certification body that provides technical 

Validation guidance for operations of the Ada certification system. 

Organization 
(AVO) 

Compliance of The ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer 
System 


A functional unit, consisting of one or more computers and 
associated software, that uses common storage for all or 
part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 




INTRODUCTION 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 

ISO 

LRH 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


Fulfillment by a product, process, or service of all 
requirements specified. 

An individual or corporate entity who enters into an 
agreement with an AVF which specifies the terms and 
conditions for AVF services (of auiy kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

International Organization for Standardization. 

The Ada standard, or Language Reference Manual, published as 
ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRH take the form ''<section>.<subsection>:<paragraph>.'' 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro90]. 

The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 







CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 


The following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 


publication 

date for this 

list of withdrawn tests 

is 3 May 1991 

ft 

E28005C 

B28006C 

C34006D 

C35508I 

C35508J 

C35508H 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

C83026A 

B83026B 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD70P6E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 




2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant 
for a given Ada implementation. Reasons for a test's inapplicability may 
be supported by documents issued by the ISO 2 uid the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 






IMPLEMENTATION DEPENDENCIES 


The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.HAX_DIGITS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L.,Y (14 tests) 
C45524L..Z (15 tests) 
C4S641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


The following 20 tests check for the predefined type L0NG_INTEGER; for 
this implementation, there is no such type: 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001V 

C86006C 

CD7101F 

C35404D, C45231D, B86001X, 

C86006E, 

and CD7101G check for a predefined 

integer type 

with a name other 

than INTEGER, 

L0NG_INTEGER, or 


SHORT INTEGER; for this implementation, there is no such type. 


C35713B, C45423B, R86001T, and C86006H check for the predefined type 
SH0RT_FL0AT; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with a 
name other than FLOAT, L0NG_FL0AT, or SH0RT_FL0AT; for this 
implementation, there is no such type. ~ 

C45423A, C45523A, and C4S622A check that the proper exception is 
raised if MACHIN£_0VERFL0VS is TRUE and the results of various 
floating-point operations lie outside the range of the base type; for 
this implementation, MACHINE_0VERFL0VS is FALSE. 

C45531M..P and C45532N..P (8 tests) check fixed-point operations for 
types that require a SYSTEM.NAX_MANTISSA of 47 or greater; for this 
implementation, MAX_MANTISSA is less than 47. 

B86001Y uses the name of a predefined fixed-point type other than type 
DURATION; for this implementation, there is no such type. 

CA2009C and CA2009F check whether a generic unit can be instantiated 
before its body (and any of its subunits) is compiled; this 
implementation creates a dependence on generic units as allowed by 
AI-00408 and AI-00506 such that the compilation of the generic unit 
bodies makes the instantiating units obsolete. (See section 2.3.) 

CD1009C checks whether a length clause can specify a non-default size 
for a floating-point type; this implementation does not support such 
sizes. 


2-2 






IMPLEMENTATION DEPENDENCIES 


CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2AB40 use length clauses 
to specify non-default sizes for access types; this inpleinentation 
does not support such sizes. 

BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code 
insertions; this inplementation provides no package MAC3IINE_C0DE. 

AE2101H, EE2401D, and EE2401G use instantiations of package DIRECT__I0 
with unconstrained array types auid record types W7.th discriminants 
without defaults; these instantiations are rejected by this ccanpiler. 

CE2401H uses instantiations of DIRECT_IO with unconstrained record 
types with discriminants with defaults; this implementation raises 
USE_ERROR on the attenpt to create a file with such a type. 

The tests listed in the following table check that USE_ERROR is raised 
if the given file operations are not supported for the given 
combination of mode amd access method; this implementation supports 
these operations. 


Test 

File Operation Mode 

File Access Method 

CE2102D 

CREATE 

IN FILE 

SEQUENTIAL 10 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL 10 

CE2102F 

CREATE 

INOUT FILE 

DIRECT 10 

CE2102I 

CREATE 

IN FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OUT FILE 

sequential”10 

CE2102Q 

RESET 

aTT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

OUT FILE 

DIRECT_IO 

CE3102E 

CREATE 

IN_FILE 

TEXT_IO 

CE3102F 

RESET 

Any Mode 

TEXT_IO 

CE3102G 

DELETE 


TEXT_IO 

CE3102I 

CREATE 

OUT FILE 

TEXT_IO 

CE3102J 

OPEN 

IN FILE 

TEXT_IO 

CE3102K 

OPEN 

OUT FILE 

TEXT_IO 


The following 16 tests check operations on sequential, direct, and 
text files ^en multiple internal files are associated with the same 
external file and one or more are open for writing; USE_ERROR is 
raised vhen this association is attempted. ~ 


C:E2107B..E CE2107G..H CE2107L CE2110B CE2110D 


2-3 





IMPLEMENTATION DEPENDENCIES 


CE2111D CE2111H CE3111B CE3111D..E CE3114B 

CE3115A 


CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the 
page number exceeds COUNT'LAST; for this implementation, the value of 
COUNT'LAST is greater than 150000, making the checking of this 
objective impractical. 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 28 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the 
way expected by the original tests. 

BAIOOIAI BA2001C BA2001E2 BA3006A6M BA3006B3 

BA3007B7 BA3008A4 BA3008B5 BA3013A6 BA3013A7M 


C52008B was graded passed by Test Modification as directed by the AVO. 
This test uses a record type with discriminants with defaults; this test 
also has array components whose length depends on the values of some 
discriminants of type INTEGER. The test was modified to constrain the 
subtype of the discriminants. Line 16 was modified to declare a 
constrained subtype of INTEGER, and discriminant declarations in lines 17 
and 25 were modified to use that subtype; the lines are given below: 

16 SUBTYPE SUBINT IS INTEGER RANGE -128 .. 127; 

17 TYPE REC1(D1,D2 : SUBINT) IS 

25 TYPE REC2(D1,D2,D3,D4 : SUBINT := 0) IS 


CA2009C and CA2009F were graded inapplicable by Evaluation Modification as 
directed by the AVO. These tests contain instantiations of a generic unit 
prior to the compilation of that unit's body; as allowed by AI-00408 and 
AI-00506, the compilation of the generic unit bodies makes the compilation 
unit that contains the instantiations obsolete. 

BC3204C and BC3205D were graded passed by Processing Modification as 
directed by the AVO. These tests check that instantiations of generic 
units with unconstrained types as generic actual parameters are illegal if 
the generic bodies contain uses of the types that require a constraint. 
However, the generic bodies are compiled after the units that contain the 
instantiations, and this implementation creates a dependence of the 
instantiating units on the generic units as allowed by AI-00408 and 
AI-00506 such that the compilation of the generic bodies makes the 
instantiating units obsolete—no errors are detected. The processing of 
these tests was modified by re-compiling the obsolete units; all intended 


2-4 







IMPLEMENTATION DEPENDENCIES 


errors were then detected by the compiler. 

CD1009A, CD1009I, CD1C03A, CD2A21C, CD2A24A, CD2A31A, CD2A31B, CD2A31C 
were graded passed by Evaluation Modification as directed by the AVO. 
These tests use instantiations of the support procedure L£NGTH_CHECK, 
which uses Unchecked_Conversion according to the interpretation given in 
AI-00590. The AVO ruled that this interpretation is not binding under 
ACVC 1.11; the tests are ruled to be passed if they produce Failed 
messages only from the instances of LENGTH_CHECK—i.e, the allowed 
Report.Failed messages have the general form: 

" * CHECK ON REPRESENTATION FOR <TYPE ID> FAILED." 


CE2203A and CE2403A were graded passed by Test Modification as directed by 
the AVO. These tests check that USE ERROR is raised if the capacity of 
the external file is exceeded; but tHey require that the capacity can be 
limited to 4096 characters or less. This Implementation can restrict file 
capacity in units of disk tracks, whose size is approximately 48K bytes. 
The two tests were revised at lines 45 & 54 (2 lines in each test) to use 
the form parameter "BLKSIZE 512 PRIMARY 1 SECONDARY 0", which restricts 
capacity to one track. The upper bound of the loop range at line 73 of 
each test was changed from 9 to 100, to attempt to write 50K bytes. 

EE3301B, EE3405B, and EE3410F were graded passed by Evaluation 
Modification as directed by the AVO. These tests check certain I/O 
operations on the current default output file, including standard output. 
This implementation outputs the ASCII form-feed character which has no 
effect on the standard IBM output devices; in general, there is no common 
form-feed mechanism for the devices. Thus, the printed output from this 
test did not contain the expected page breaks. The AVO ruled that these 
tests should be considered passed if none of the tests' internal checks 
was failed (i.e., if the tests report "TENTATIVELY PASSED"). 


2-5 





CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 


The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For technical and sales information about this Ada implementation, contact: 

IBM Canada, Ltd 
844 Don Mills Road 
North York, Ontario 
Canada M3C IB7 
ATTN: Antony Niro 

31/257/844/TOR 


Testing of this Ada implementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were withdrawn 
because of test errors (item b; see section 2.1), those that require a 
floating-point precision that exceeds the implementation's maximum 
precision (item e; see section 2.2), and those that depend on the support 


3-1 







PROCESSING INFORMATION 


of a file system — if none is supported (item d). All tests ^ssed, 
except those that are listed in sections 2.1 and 2.2 (coijnted in items b 
and f, below). 


a) Total Number of Applicable Tests 3777 

b) Total Number of Withdrawn Itests 94 

c) Processed Inapplicable Tests 98 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 201 

f) Total Number of Inapplicable Tests 299 


g) Total Number of Tests for ACVC 1.11 4170 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the validation team for processing. The contents of the 
magnetic tape were loaded directly onto the host computer. 


After the test files were loaded onto the host conpiter, the full set of 
tests was processed by the Ada in^jlementation. 


Testing was performed using command scripts provided by the customer emd 
reviewed by the validation team. See Appendix B for a conplete listing of 
the processing options for this inplementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were: 


ADA dsname (options) 
options 


description 


dsname Dsname specifies the file to be conpiled. 

ERROR(LIST) Creates a listing file only vdien errors are 

encountered. ’H'.e file contains compile-time error 
messages interspersed with the source code. 

COMPILE I MAIN | BIND Con{}ile is the defaiilt option causing a 

conpile only. BIND will be used in those 
instances for subunits needing to be 
conpiled prior to the main program. MAIN 
is specified for mains and will allow 
execution to take place. 


OPT(AUTO) 


This option is used \diere optimized 
3-2 






processing informaticn 


results are desired. 


Test output, compiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 


3-3 




APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, vhich is 
the value for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada strlng~aggregates, where "V" represents the maximum input-line 
length. 


Macro Parsuneter 


Macro Value 


$MAX_IN_LEN 

$BIG_ID1 

$BIG_ID2 

$BIG_ID3 

$BIG_IDA 

$BIG_INT_LIT 

$BIG_REAL_LIT 

$BIG_STRING1 

$BIG_STRING2 

$BLANKS 


200 — Value of V 
(1..V-1 => 'A', V => '1') 

(1..V-1 => 'A', V => '2') 

(1..V/2 => 'A') & '3' & (1..V-1-V/2 -> 'A') 

(1..V/2 => 'A') & '4' & (1..V-1-V/2 -> 'A') 

(1..V-3 => '0') & ”298" 

(1..V-5 => '0') & "690.0" 

& (1..V/2 .> 'A') & 

& (1..V-1-V/2 -> 'A') & '1' & 

(1..V-20 => ' ') 


$MAX LEN INT BASED LITERAL 

“ “ “ "2:" & (1..V-5 -> '0') & "11;" 


$MAX LEN REAL BASED LITERAL 

" "16;" & (1..V-7 -> '0') & "F.E;" 

$MAX_STRING_LITERAL & (1..V-2 «> 'A') & 

A-1 





MACRO PARAMETERS 


The following table lists all of the other macro parameters and their 
respective values. 


Macro Parameter 

Macro Value 

$ACC_SIZE 

32 

$ALIGNMENT 

4 

$COUNT_LAST 

2_147_483_646 

$DEFAULT_MEM_SIZE 

16777215 

$DEFAULT_STOR_UNIT 

8 

$DEFAULT_SYS_NAME 

IBM370 

$DELTA_DOC 

2#1.0#E-31 

$ENTRY_ADDRESS 

ENT_ADDRESS 

$ENTRY_ADDRESS1 

ENT_ADDRESS1 

$ENTRY_ADDRESS2 

ENT_ADDRESS2 

$FIELD_LAST 

1000 

$FILE__TERMINATOR 

1 ! 

$FIXED_NAME 

N0_SUCH_TYPE 

$FLOAT_NAME 

N0_SUCH_TYPE 

$FORM_STRING 

If If 

$FORM_STRING2 

CANNOT_RESTRICT_FILE_CAPACITY 

$GREATER THAN DURATION 

86401.0 


$GREATER THAN DURATION BASE UST 

T31075.0 

$GREATER THAN FLOAT BASE LAST 

7.I37006E+75 

$GREATER THAN FLOAT SAFE LARGE 

7.I3004E+75 


A-2 





MACRO PARAMETERS 


$GREATER THAN SHORT FLOAT SAFE LARGE 

~ 7.2I7E+75 

$HIGH_PRIORITY 255 

$ILLEGAL_EXTERNAL_FILE_NAME1 

BADCHAR*Z 

$ILLEGAL_EXTERNAL_FILE_NAME2 

BAD-CHAR!@“ 

$INAPPROPRIATE LINE_LENGTH 

1029 

$INAPPROPRIATE_PAGE_LENGTH 

-1 

$INCLUDE_PRAGMA1 PRAGMA INCLUDE ("A28006D1.TST"); 

$INCLUDE_PRAGMA2 PRAGMA INCLUDE ("B28006F1.TST"); 

$INTEGER_FIRST -2147483648 

$INTEGER_LAST 2147483647 

$INTEGER_LAST_PLUS_1 2147483648 

$INTERFACE_LANGUAGE C 

$LESS_THAN_DURATION -86401.0 

$LESS_THAN_DURATION BASE_FIRST 

~ 131073.0 

$LINE_TERMINATOR ' ' 

$WW_PRIORITy 0 

$MACHINE_CODE_STATEMENT 

NULL; 

$MACHINE_CODE_TYPE NO_SUCH_TYPE 

$MANTISSA_DOC 31 

$MAX_DIGITS 15 

$MAX_INT 2147483647 

$MAX_INT_PLUS_1 2147483648 

$MIN_INT -2147483648 

$NAME NO SUCH_TYPE_AVAILABLE 


A-3 





MACRO PARAMETERS 


$NAME_LIST 

mc68000,anuyk44 , ibm370 

$name_specific:ationi 

'TEST3.X2102A' 

$NAME_SPECIFICATION2 

'TEST3.X2102B' 

$NAME_SPECIFICATION3 

'TEST3.X3119A' 

$NEG_BASED_INT 

16#FFFFFFFE# 

$NEW_MEM_SIZE 

16777215 

$NEW_STOR_UNIT 

8 

$NEW_SYS_MAME 

IBM370 

$PAGE_TERMINATOR 


$RECORD_DEFINITION 

NEV INTEGER; 

$RECORO_NAME 

NO_SUCH_MACHINE_CODE_TYPE 

$TASK_SIZE 

32 

$TASK_STORAGE_SIZE 

1024 

$TICK 

0.000001 

$VARIABLE_ADDRESS 

VAR_ADDRESS 

$VARIABLE_ADDRESS1 

VAR_ADDRESS1 

$VARIABLE_ADDRESS2 

VAR_ADDRESS2 

$YOUR_PRAGMA 

PRIORITY 


A-4 





APPENDIX B 

COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 


LINKER OPTIONS 

The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation and not 
to this report. 


B-1 






Compiling a Source Program 


Chapter 2. Compiling Ada Programs 

This chapter describes how to use the IBM Ada/370 compiler. You should have 
available a copy of IBM AdaJ370 Language Reference (SC09-1297) or 
ANSI/MIL-ST0-181SA. the Ada LRM. 

If you need help getting started with IBM Ada/370. see Chapter 9. IBM Ada/370 
Tutorial. 


Compiling a Source Program 

The AOA command compiles a source program. The following sections show 
you how to use this command under VM/CMS. MVS TSO. and as an MVS bat*" 
job. 


Using the AOA Command under VM/CMS 


» 0A- 


y-fllejtame- 


r, 


■fi lejype-i -H 

*—/I lejiwde-* 
^oaipjjnitjiame ■■ ■ 


'— {-options- 


—(-flwdf/fers—J-)—' 




The "7” option displays syntax information, including a list of the ADA options, on 
the screen. 


Most situations require that you pass the file name of the source file. The 
compilation unit name is required when you use the Bind option, or when you 
use the Run and NOCOmpile options. The filejype and tilejnode default to ADA 
and *. respectively. 


When you specify a compiler option in AOA. you can use the minimum unique 
abbreviation. For example, you can specify CReate as CR. 

Many compiler options are matched by an opposite. For example, the opposite 
of the MAP option is the NOMAP option. For such cases, one of the options is 
designated as the default. For an option that takes a numerical value, a 
particular value may be assigned as the default. The compiler uses default 
settings unless you override them by specifying the nondefault options to ADA. 

Precede the list of options by a blank space and a left parenthesis, and separate 
them from each other by blank spaces. A closing parenthesis is optional. 


O Coovf'qnt IBM Corp. 1891 


2-1 





Compiling a Sourea Program 


Some of the options have modifiers, which you .lust enclose in parentheses 
Where you can enter multiple modiners to an option, such as with the Xref 
option, separate the modifiers with a comma. 

Here are some examples: 

1 ADA EXAMPLE 

Example 1 compiles EXAMPLE ADA * using the default options. 

2. ADA EXAMPLE (LIBRARY (DEMO LIBRARY) DEBUG 

Example 2 compiles EXAMPLE ADA * with the LIBrary and Oebuq options. 
LlBrary causes the compiler to use a Tile containing an alternative library 
The library has the name DEMO LIBRARY *. 

3. ADA EXAMPLE (XREF (BYUNIT,FULL) 

Example 3 compiles EXAMPLE ADA ' with the Xref option to produce a 
cross-reference listing. The listing is ordered by compilation unit and 
includes cross-references to all visible units. 


Using the ADA Command under MVS TSO 

D 

*•—EX 'Quallfier.CllST(kDA)' — ’-r 


-|- dsname -r 

I—' '-quoHfttr.dsnme ^'' 




i 

-(-cptions- 




•—{-moat fieri —*-)—• 




Linder MVS, the qualifier at Q is the high-level qualifier assigned to IBM 
Ada/370 by your system administrator. In examples for this book, we use the 
high-level qualifier ADA. The qualifier at Q is the high-level qualifier for the 
data set you are specifying. By default, the high-level qualifier is set by the 
PROFILE PREFIX command. This, in turn, defaults to your TSO logon identifier. 

The ”?" option displays syntax information, including a list of the ADA options, on 
the screen. 

Most situations require that you pass the file name of the source file. The 
compilation unit name is required when you use the Bind option. 

When you specify a compiler option in ADA, you can use the minimum unique 
abbreviation. For example, you can specify CReate as CR. 

Many compiler options are matched by an opposite. For example, the opposite 
of the MAP option is the nomap option. For such cases, one of the options is 
designated as the default. For an option that takes a numerical value, a 
particular value may be assigned as the default. The compiler uses default 
settings unless you override them by specifying the nondefault options to ADA. 


2-2 IBM Ada/370 





Compiling a Source Program 


Precede the list of options by a blank space and a left parenthesis, and separate 
them from each other by blank spaces. A closing parenthesis is optional 

Some of the options have modifiers, which you must enclose in parentheses 
Where you can enter multiple modifiers to an option, such as with the Xref 
option, separate the modifiers with a comma. 

Here are some examples; 

1. EX ’AOA.CLISTCAOA)' ‘EXAMPLE* 

Example 1 compiles EXAMPLE using the default options. 

2. EX 'A0A.CLIST(A0A)‘ ‘EXAMPLE (LIBRARY (“DEMO.LIBRARY'*) DEBUG’ 

.Example 2 compiles EXAMPLE with the LiBrary and Debug options. LIBrary 
causes the compiler to use a data set containing an alternative library. The 
library has the name OEMO.UBRARY The compiler also savss information 
needed by the IBM Ada/370 debugger. 

3. EX ‘ADA.CLISTCAOA)* “‘USER 1.EXAMPLE" (XREF (B.UNIT,FULL)’ 

Example 3 compiles EXAMPLE with the high-level qualifier USERI. It includes 
the Xref option to produce a cross-reference listing. The listing is organized 
by compilation unit and includes cross-references to all visible units 

Compiling a Program with Job Control Language (JCL) 

This section describes how to invoke the compiler as a batch job under MVS 
using Job Control Language (XL). For information on how to invoke the binder 
using JCL. see ' Invoking the Binder with Job Control Language (JCL)" on 
page 3-2. 

The AOAC cataloged procedure invokes the compiler on a source file. 


- 

//MYPROC JOS ',MSGCUSS-0.MSCLEVEL-(1,1),N0TIFY>USER1, 

// CLAS5.A 

//• 

//• PURPOSE: TO RUN THE AOA COMPILER 
//• 

//COMPILE EXEC PR0C«A0AC.A0ASRC-'USERI.AOA.SOURCE(HELLO)', 

// USER«USER1. CMPPRM«'CHECX’ 

V__ 

Figure 2-f. Using ths AOAC Cafa/oged Procsdun to invoke the BinOer 

The preceding example job. MYPROG. compiles member HELLO in the source 
POS. uSERt.AOA.SOURCE. The user's name. USERI. is identified with the USER 
variable. This variable is used as a high-level qualifier to construct data-set 
names for the compiler, such as USER1.A0A.UBRARY. which is the default library. 
Your job card will probably be different, because it depends on your site's 
conventions. 

After you execute this job. the Ada program contained in member HELLO is 
compiled Into the working sublibrary of USERI .ADA.LIBRARY. 

A sample of AOAC cataloged procedure appears in Figure 2-2 on page 2-4. The 
exact location of AOAC may depend on your site's conventions. 


Chapter 2. Compiling Ada Programs 2*3 






Compiling a Source Program 


//AOAC 

// 

// 

//* 

//* ERASE 
//* 

// 

//ADAINFO 
// 

//. 

//* 

//. 

//STEPl 

// 

//STEPLIB 
//COMOUT 
//AGAIN 
//AOALI8 
//ADAINFO 
// 

// 

//AOALIST 

// 

// 

//AOAUTl 

// 

// 

//M0AUT2 

// 

// 

//A0AUT3 

// 

// 

//A0AUT4 

// 

// 


PROC CMPPRM-' ',MEMSIZE-8196K, 

STPLIB*'ADA110.LOAOLIB',MAXTIHE-60, 

VlO-V10,SYSDA-SYSALLOA.SYSOUT-‘*' 

ADA.INFO DATASET 

EXEC PGM-IEFBR14 

00 OSN-iUSER..ADA.INFO,0ISP-(M00,DELETE), 
SPACE-(1,1),UNIT-»SYS0A 


INVOKE THE COMPILER 


EXEC PGM-£VGCOMP,PARM-*&CMPPRM’,REGI0N-4MEMSIZE, 
TIME-4MAXTIME.DYNAMNBR-65 
00 OSN-iSTPLIB.OISP-SHR 

DO SYS0UT-iSYS0UT,0CB-(LRECL-l20,BLKSIZE-12G) 

00 OS N-&AOASRC,0ISP-SHfl,FREE-ENO,0CB-8UFN0-4 

00 OSN-iUSER..A0A.LI8RARY,DISP-5HR 

00 OSN-iUSER..AOA.INFO,OISP-(MEW,PASS,CATLG), 

OCB-(RECFM-V0,LRECL=512.BLKSIZE-312O,DSOflG-PS), 

SPACE-(80,(10,50)),UNIT-iSYSDA 

00 OSN-iUSER..LISTIN6,0ISP-(M00,CATLG,CATLG), 

0CB-(RECFM-VBA,LRECL-259,BLKSIZE-3120,0S0RG-P0,8UFN0-2), 

SPACE-(132,(500,2000,20)),UNIT-iSYSDA 

00 SPACE-(132,{500,2000)), 

OC8-(fiECFM-F0,LRECL«136,BLKSIZE-34OO,OSORG-OA,8UFNO-2), 

UNlT-iSYSOA 

00 SPACE-(132,(500,2000)), 

OCB-(RECFM-vB,LRECL«136,BLKSIZE-3120,DSORG-PS,0UFNO-2), 

UNIT-iViO 

00 SPACE-(132,(500,2000)), 

0C8-(RECFH-FB,LRECL-1028,BLKSIZE-2056,DSORG-OA,BUFNO-2), 
UNIT-iSYSDA 

00 SPACE-(132,(500,2000)), 

OCB-(RECFH-FB,LRECL-132,BLKSIZE-2640,OSORG-OA,BUFNO-2), 
UNIT-iSYSOA 


figure 2-2. AOAC Cataloged Procedure 


Symboffc Variables for AOAC Cataloged Procedure 

The AOAC cataloged procedure includes several symbolic JCL substitution 

variables you can modify to specify the various options available. 

Symbolic 

Variable Description 

AOASRC Specifies the data-set name (OSN) for the Ada source file. This 
name must be set in order to successfully compile an Ada 
program. 

CMPPRM Specifies options to the compiler in the PARM field. This variable, 
found in Step 1 of the AOAC cataloged procedure, specifies 
options to the compiler in the PARM field. These options are the 
same ones used when you invoke the compiler with the ADA 
command. 


2-4 IBM Ada/370 









Compiling a Source Program 


MAXTIME 

MEMSIZE 

STPLIB 

SYSOA 

SYSOUT 

USER 

VIO 


The compiler options have the tollowing syntax: 


i , 


options 

i 

— (-Hiodifters — 




Table 2*2 on page 2-8 lists the valid options, their modifiers, and 
defaults. 

Sets a maximum amount of time for the compiler job step to run 
(via the TIME parameter on a JCL EXEC card). The default value is 
60 minutes, but this value can be changed when the cataloged 
procedure is installed. 

Specifies the amount of memory in which to run the compiler job 
step (via the REGION option on a JCL EXEC card). The greater the 
memory, the better the performance of the compiler. The default 
value IS 8198Kb, but this value may be changed, depending on 
your site's conventions. 

Indicates the data-set name of the partitioned data set that 
contains the compiler module. EVGCOMP. This default can be 
changed when the cataloged procedure is installed. 

Specifies the UNIT for permanent data set allocations. The 
default is SYSALLOA, but this value can be changed depending on 
your site's conventions. 

Identifies the output class for the compiler output. The default is 
but this can be changed, depending on your site's 
conventions. 

Indicates the high-level qualifier that is required to build data-set 
names used by the compiler. You must specify this variable. It 
is common to set this variable to your TSO logon identifier. 

Specifies the UNIT for temporary data set allocations. The default 
is VIO. but the default can be changed depending on your site's 
conventions. 


Chapter 2. Compiling Ada Programs 2-5 






Th« Compiler Options 


The Compiler Options 

The ADA command invokes the IBM AdaVSTO compiler Table 2-1 provides a 
brief summary of Ihe compiler options. The square brackets enclose optional 
modifiers. You do not actually enter the brackets as part of the command 
syntax. For the specific syntax of each option, see the option descriptions on the 
pages specified in the table. 


Table 2'l (Page 1 of 2). Compiler Options 

Option 

Default 

Function 

Pago 

Asm 

NOAsm 

Aaaembiy listing. 

2-9 

(NOGen 


Suppress listing of expanded generics. 


i NOSysl 


Suppress listing of system-supplied generics. 


Bind 

compile 

Bind previously-compiled main unit. 

2-10 

CHeck 

compile 

Compile with syntactic and semantic checking only. 

2-10 

(Nosemanticl 


Compile with syntactic checking only 


COmpi1e 

compile 

Compile code for a library unit. 

2-11 

CReate [number_ofjjnita\ 

NOCReate 

Initialize working sublibrary for the compiler. 
numberjofjjnits is number of compilation units in 
sublibrary. 

2-11 

D«buq 

NOOebuq 

Output information for debugging. 

2-13 

Error 

NOError 

Specify action to be taken when errors occur. Must 
include at least one modifier. 

2-13 

(Count - number) 


Abort compilation after number errors. 


(Listl 


Generate interspersed listing of errors and source 
code. 


Generate 

NOGenerate 

(VM/CMS) 

Generate a load image. 

2-14 

NOGenerate 

Generate (MVS) 



INI i St (ma»_number) 

compile 

Compile multiple source files with one invocation of 
the compiler, maxjiumber is the maximum number 
of compilation failures during input list processing. 

2-15 

LIBrary library_name 


Specify Ada library name. 

2-15 

List 

NOLISt 

Generate interspersed listing of errors and source 
code. 

2-16 

MAIn [eompjunil_name] 

compile 

Compile and bind code for a main unit. 

2-16 

HAP 

NOHAP 

Produce linkage map during binding. Use with MAIn. 
Bind, or Run options. 

2-17 

NOCOmp 11e 

compile 

Suppress the compiler. 

2-17 

Run 

NORun 

Execute main program. 

2-18 


2-9 IBM Ada/370 

































































The Compiler Options 


Tabit 2-1 (Page 2 of 2). Compiler Options 

Option 

Ooftuit 

Function 

Page 

Suppress 

NOSuppress 

Suppress solocted run>time chocks or line information 
tables in generated obiect code. Must include at 
least one modifier. 

2-18 

(Lineinfo) 


Suppress generation of line information tables. 


(Checks 


Suppress all run-time checks. 


1 Elab) 


Suppresses only elaboration checks. 


Trace 

NOTrace 

Display diagnostic messages from the compiler. 

2-19 

Xref 

NOXref 

Produce a cross-reference listing. 

2-19 

(Byunit| 


Order the listing by compilation unit. 


(Full! 


Cross-reference all visible units. 



Chapter 2. Compiling Ada Programs 2*7 











Tha Compilar Options 


Compiler Options for Use with ADAC Cataloged Procedure 

This section defines the standard options for the CMPPRM symbolic variable 
when you invoke the compiler as a batch job under MVS. For more information 
on CMPPRM, see "Symbolic Variables for ADAC Cataloged Procedure ’ on 
page 2*4. Descnptions of the options appear on the pages shown. 


Table 2-2. Compiler Options for JCL 

Option 

Default 

Function 

Page 

ASM 

NOASM 

Assembly listing. 

2-9 

(NOGEN 


Suppress listing of expanded generics. 


1 NOSYS] 


Suppress listing of system<supplied genencs. 


CHECK 

COMPILE 

Comptia with syntactic and semantic checking only. 

2-10 

(NOSEMANTIC] 


Compile with syntactic checking only. 


COMPILE 

NOCOMPILE 

Compile code for a library unit. 

2-11 

CREATE [number_of_i/n/(s| 

NOCREATE 

Initialize working sublibrary for the compiler. 
numberjofjjnita is number of compilation units in 
sublibrary. 

2-11 

OONAMES 

al<f_name •* new_name 


Specify the Data Description (00) names that identify 
the data sets used by the compiler and binder It 
must include at least one modifier. 

2-12 

DEBUG 

NOOEBUG 

Output information for debugging. 

2-13 

ERROR 

NOERROR 

Specify action to be taken when errors occur. Must 
include at least one modifier. 

2-13 

(COUNT - number! 


Abort compilation after number errors. 


ILISTI 


Generate interspersed listing of errors and source 
code. 


LIST 

NOLIST 

Generate interspersed listing of errors and source 
code. 

2-16 

SUPPRESS 

NOSUPPRESS 

Suppress selected run>time checks or line information 
tables in generated object code. Must include at 
least one modiEer. 

2-18 

(LINEINFO] 


Suppress generation of line information tables. 


(CHECKS 


Suppress all run>time checks. 


1 ELAB] 


Suppresses only elaboration checks. 


TRACE 

NOTRACE 

Display diagnostic messages from the compiler. 

2-19 

XREF 

NOXREF 

Produce a cross-reference listing. 

2-19 

(BYUNIT] 


Order the listing by compilation unit. 


(FULL) 


Cross-reference all visible units. 



2*8 IBM Ada/370 














































Asm Option 


Detailed Descriptions of Compiler Options 

The following detailed descriptions of the compiler options include syntax 
diagrams. In these diagrams, uppercase characters indicate the minimum 
abbreviation of options and their modifiers. Options and modifiers that are 
underscored are the defaults. 


Asm Option 



The Asm option produces pseudo*assembiy language for the object code 
interspersed with the Ada source for each compilation unit. It causes the 
creation one listing for each source file. Asm also provides information on the 
relative offset and size allocation of each data item or constant. This listing is 
called the data map. For more information on the listing produced by Asm. see 
“Source and Assembly Listings” on page 7*1. 

If you use the Asm option at the same time you invoke the IBM Ada/370 binder, 
the compiler also produces a binder listing. 

The NOGen modifier suppresses the listing of code generated for expanded 
generics. Otherwise, listings include the code generated for all expanded 
generics. 

The NOSys modifier suppresses the listing of code generated for system-supplied 
generics. 

Use NOGen or NOSys to reduce the size of listings. 

Undur VMtCMS 

The name of the listing file takes the form source LISTING A. where source is the 
file name of the source file. 

Under MVS 

The name of the listing data set takes the form qua/t/fer.USTlNGfsource) where 
qualiHer is the TSO logon identifier and source can be either the name of the 
member of a partitioned data set (PDS) used as source or the second qualifier in 
the name of a sequential data set. 


Chapter 2. Compiling Ada Programs 2*9 



Ch«ck Option 


Bind Option 


Check Option 


-T—Bind— 
t- COwill 


The Bind option binds a main program that has been previously compiled as a 
library unit. As output. It produces an object file. When you use this option, 
enter the compilation unit name in place of the source file name. You can only 
use the Bind option for compilation units that reside in the working sublibrary of 
the Ada program library. 

To invoke the binder when you compile the source (rather than in a separate call 
to ADA), use the ha In option. 

You cannot use the Bind option in combination with MAIn. CHeck. INIist. compile, 
or NOCOmpi 1e. If you enter more than one of these options. IBM Ada/370 only 
accepts the last one m the command line. If you do not use any of these 
options, the default is compile. 

Undmr VMfCMS 

The object file created by compiling with the Bind option has the Tile type text. 

Under MVS 

The object file is a POS created by compiling with the Bind option. It takes the 
form qualifier QBMcompjumt). where qualifier is your TSO logon identifier and 
compjjnit is the compilation unit name. 


-r-CHeck— 
L-COeotle” 


n;: 


(-NosMintlc- 




The CHeck option causes the compiler to perform only syntactic and semantic 
error checking. Because no object code is produced, you can save compilation 
time and disk space during error checking. If you include the Nosemantic 
modifier, the compiler only performs syntactic error checking. 

You cannot use the CHeck option in combination with HAIn, Bind. INIist. CCknpile. 
or NOCOmpi I e. If you enter more than one of these options. IBM Ada/370 only 
accepts the last one in the command line. If you do not use any of these 
options, the default is compile. 


2*10 IBM Ada/370 




Create Option 


Compile Option 


The compile option causes all compilation units in the source nie to be library 
units, rather than main units. 

You can also make a library unit into a main unit using the Bind option. 

You cannot use the COmpi le option in combination with MAln. Bind. CHeck. INHst. 
or NOCOmpi le. If you enter more than one of these options. IBM Ada/370 only 
accepts the last one in the command line. If you do not use any of these 
options, the default is compile. 


Create Option 


CReate- 


I— {-t»jaberj)f_untts —)—^ 


i-IIOCReate- 


CReate initializes the working sublibrary for the compiler. The compiler creates a 
new sublibrary, deleting the previous copy, if one exists. 

The number_ofjjnits variable specifies the number of compilation units the 
sublibrary can contain. The default is 200. The largest number of units a 
sublibrary can contain is 4671. 

This number indicates an approximate size for the sublibrary. The number of 
units that actually fit into a sublibrary depends upon their size and complexity. 
For further information on sublibraries, see Chapter 5. Working with the Ada 
Library System. 

When you use CReate in conjunction with the LIBrary option, it initializes the 
working sublibrary in the library specified by LIBrary. 

You cannot use CReate in combination with the Bi nd option. 

NOCReate is the default. With NOCReate. the compiler does not initialize the 
working sublibrary. 


Chapter 2. Compiling Ada Programs 2*11 





ODNAMES Option (MVS JCL Only) 


OONAMES Option (MVS JCL Only) 

i I 

—OOHAHES— {-a I djiame—fyewjtme -^—) 


OOHAMES specifies the Data Oescnption (DD) names that identify the data sets 
used by the compiler and binder. OONAMES always requires a value. 

For use with the compiler. old_nam» has one of the following values: 

AOAIN 

AOAINFO 

AOAUB 

AOALIST 

AOAUT1 

AOAUT2 

AOAUT3 

A0AUT4 

For use with the binder, oidjtame has one of the following values: 


AOAINFO 

AOAUB 

AOAUST 

AOAUTt 

AOAUn 

AOAUT3 

A0AUT4 

Usually, you do not need to change the 00 names associated with the compiler. 


This example of a JCL code fragment uses OONAMES to identify a new DO name 
specifying the source file and the ada library: 

//MYSTEP EXEC PGM-EVGCOHP,PARM-'ODNAMES(ADAIN-MYSOURCE,AOALIB-MYLIB)' 
//MYSOURCE 00 OSN-quoft/fer.A0A.S0URCE(PR0GRAMl) 

//MYLIB 00 0 SN-< 7 «oit/ter. ADA.LIBRARY 


2*12 l8MAda/370 





Error Option 


Debug Option 


j D eiHig-r—---- 

MtODsbug-• 

The Debug option causes information used by the IBM Ada/370 debugger to be 
placed in the working sublibrary. When used with the MAin or Bind options. Debug 
produces a debugging map. which is required by the debugger. 

For more information about debugging, see Chapter 8. The IBM Ada/370 
Debugger. 

With NOOebug. the compiler does not place debugging information into the working 
sublibrary. 

Under VMICMS 

The debug map file takes the name eompjunit OEBUGMAP a where compjjnit is 
derived from the name of the compilation unit. 

UnPmr MVS 

The debug map file takes the name qualifl»r O£BUCMAP{compjjnit). where 
qualifier is the high-level qualifler and compjjnit is derived from the name of the 
compilation unit. 


Error Option 


r 

^ 

* 1 Error ■ (—pCount •rntsbe r— 

U.lst- 

L-aOError-—- 

r' 



Error controls the way the compiler behaves when it finds errors in the source 
Tile. You must choose at least one of the modifiers. 

The Count modiTier specifles the number of errors that cause the compiler to stop 
processing. The compiler includes syntax, semantic, and warning errors in the 
count. For example, C0UNT«5 causes the compiler to stop processing after it finds 
five errors. If you omit the Count modifier, the compiler stops processing when it 
finds 32767 errors, the default error limit. 

The List modifier creates a file containing compile-time error messages 
interspersed with the source code. If there are no errors, the compiler does not 
generate the listing. To generate this listing regardless, use the List option. 

See "List Option" on page 2-18. 

With NOError. the compiler does not modify its behavior when it finds errors 
during processing. 

(/ntfer VMICMS 

The listing file created by the List modifier is called source USTING A, where 
source is the file name of the source file. 


Chapter 2. Compiling Ada Programs 2*13 





0«n«rat« Option 


Undmr MVS 

The listing Hie created by the List modifier is called Qua/ifier USVNC(source). 
where cfualitier is the TSO logon identifier and source is the file name of the 
source data set. 


Generate Option 

The Generate option generates a load image. 
Under VMICMS 

»• ■■ [ G ew^at f ^ — ^ - 


Under VM/CMS, when you compile with the Generate option, the ADA command 
also invokes the binder, producing an object Tile. The compiler then uses the 
object file to produce the load module. This option assumes that the source file 
contains a main program. The load module created by the Generate option has 
the name compjjmt MODULE A. where compjjnit is derived from the 
compilation unit name. 

With NOGenerate. the compiler does not generate an executable load module. 
Under MVS 



The NOGenerate option suppresses the invocation of the linkage editor alter 
binding a main program. Use this option when you want to invoke the linkage 
editor with options that differ from the default. For example, you would use 
NOGenerate when you want to link the main program with non>Ada object code. 

The load module created by the Generate option has the name 

qualifier.LOM{compjjnit]. where compjjnit is derived from the name of the 

compilation unit. 

The NOGenerate option has no effect when used in combination with NOCOmpi le. or 
when you compile the program as a library unit instead of a main unit. 

You cannot use NOGenerate in combination with the Run option. 


2-14 IBM Ada/370 




Library Option 


Inlist Option 




MrOnBlle - 


-[-max number- 




The INIist option compiles multiple source files with a single invocation of the 
compiler. When you use this option, enter the name of the file containing the 
input list in place of the source file name. For more information on the use of 
input lists, see "Compiling Multiple Source Files” on page 2-20. 

If a source file fails to compile, the compiler continues to process the remaining 
files. You can specify that the compiler stops processing after a certain number 
of source files fail to compile. To do so. use the maxjiumber variable. 

You cannot use INI ist in combination with the Bind. CHeck, MAIn, COtnoile or 
NOCOmpi 1e options. If you enter more than one of these options. IBM Ada/370 
only accepts the last one in the command line. If you do not use any of these 
options, the default is compile 


Library Option 


LlBrary —(—I tbraryjiame —) 


The LlBrary option specifies the name of the Ada library file to be used by the 
compiler. The libraryjtame modifier is the name of a library file that contains 
the names of one or more sublibraries. 

When you do not specify the LlBrary option, the compiler uses the default library 
file. Under VM/CMS. it has the name AOA LIBRARY * Under MVS. it has the 
name quaf/fier aoa library, where qualifier is the TSO logon identifier. For 
information concerning libraries and sublibraries, see Chapter 5. Working with 
the Ada Library System 

Under VMtCMS 

You can provide the libraryjiame variable in either of two formats. The 
preferred is rile_name niejype niejnode. The other format is 
rilejnode:filejr}arne.rtlejype. In both formats, if you specify only the file name. 
fllejype defaults to LIBRARY and file mode defaults to If you do not specify 
a library file. AOA searches for AOA LIBRARY '. 

For example, to specify library PROJt LIBRARY A. when you compile the file 
MYPROG. enter 

AOA MYPROG (LIB(PROJl)) 

It is recommended that you do not select an alternative file type for the Ada 
library file. Retaining the default file type maintains consistent file naming 
conventions for all users. 


Chapter 2. Compiling Ada Programs 2*15 




Main Option 


Und9r MVS 

A library can be either a sequential data set or a member of a POS. The 
libraryjnarriB variable can be any valid data-set name format. For example, to 
specify'library PROJi .UBRARY on USERI when you compile the data set 
MYPROG.SOURCE enter 

EX 'AOA.CLIST{AOA)' "‘USERI. MYPROG.SOURCE" {LIB('‘USERI.PROJl.LIBRARY")' 


List Option 


] ■ Ll! 

L-itOI 


ISt— 

ifikm- 


The List option creates a file containing a listing for each source file. The listing 
contains compile-time messages interspersed with the source code. If there are 
multiple compilation units in a source file. List places the listings for all units 
into a single file. 


Undar VMICMS 

The compilation listing file takes the form source LISTING A. where source is the 
file name of the source file. 


Undar MVS 

The compilation listing file takes the form qualifier.UViHlUseurce), where 
quauner is the tso logon identifier and source can be either the name of the 
member of a POS used as the source or the second qualifier in the name of a 
sequential data set. 


Main Option 


•• j HAIli— 
LcOeatlt 


I—f 


unit ni 


3 


The MAin option causes the compiler to produce code for the source file as an 
Ada main program. The MAIn option compiles a program and performs the 
binding operation without the need to specify any other option. 

If the Ada source file contains one or more library compilation units in addition 
to the main compilation unit, enter the name of the main program in the 
compjjnitjiama variable. 

You cannot use the MAin option in combination with Bind, CHeck. INIist. compile, 
or NOCOmpi le. If you enter more than one of these options. IBM Ada/370 only 
accepts the last one in the command line. If you do not use any of these 
options, the default is compile. 

Undar VMICMS 

The object file created by compiling with the MAin option takes the form 
eompjjnit TEXT A. where compjunit is the compilation unit name. 

Undar MVS 

The object file created by compiling with the MAin option takes the form 
qualifler.OBJ(comp_unit), where qualifier is the TSO logon identifier and 
compjunit is the compilation unit name. 


2«16 IBM Ada/370 



Nocompile Option 


Map Option 


- , -- 

>- Notap -- 

The MAP option causes the compiler to produce a linkage map when the IBM 
Ada/370 binder processes a main program. 

Use MAP in combination with either MAin or Bind, both of which invoke the binder. 
You can also use map in combination with Run as long as you do not use the 
NOCOflipi le option. 

With NOMAP. the compiler does not create a linkage map when the IBM Ada/370 
binder processes a main program 

Und 0 r VMtCMS 

The map Tile is called obiect AOAMAP A. where ob/ect is the Tile name of the 
object file. 

Undtr MVS 

The map file is called pua/i/ier AOAMAP(comp_uniO. where qualifiBr is the T50 
logon identifier and corr.pjjnit is the name of the main compilation unit. 

Nocompile Option 


»•—pNOComiic-j-—-—^ 

L- COitte -1 

The NOCOmpi le option causes the ADA command to suppress the compilat‘' 3 n step. 
Thus, you can use NOCOmpi le with Run to run an Ada program that has already 
been compiled. When you use NOCOmpi le with Run. enter the compilation unit 
name in place of the source file name. 

You can also use NOCOmoi le with the CReate to create a new working sublibrary 
without having to compile the source code. 

You cannot use the NOCOmpi le option in combination with MAIn. Bind. CHeck. INIist. 
or compile. If you enter more than one of these options. IBM Ada/370 only 
accepts the last one in the command line. If you do not use any of these 
options, the default is compile. 


Chapter 2. Compiling Ada Programs 2-17 




Suppress Option 


Run Option 


The Run option loads and executes a main program. The compiler assumes that 
the program is a main unit. You can either compile and run a program, or run a 
precompiled program. To run a previously compiled and bound program, use 
Run in combination with the NOCOmpile option. When you use Run with NOCOmoiie. 
you must specify the compilation unit name, rather than the Ada source Tile 
name. 

With NORun. the compiler does not execute the program. 


Suppress Option 


-Suppress—( i — Unelwfe 
r^heeks- 


MtOSunnress - 


The Si;opress option suppresses selected run-time checks and line information in 
generated object code, resulting in smaller, faster modules. You must choose at 
least one of the modifiers. Use of either the Suppress option or pragma Suppress 
causes the compiler to suppress run-time checks. For more information on 
pragma Suppress, see the chapter on tuning in the IBM Ada/370 Programmer's 
Guide. 

The Lineinfo modifier suppresses the generation of line information tables, thus 
saving the space required to produce them. These tables display the Ada 
source line number when an unhandled exception occurs. If you compile your 
code with this option and an unhandled exception occurs during run time, the 
error information does not include a line number 

The Checks modifier suppresses all run-time checks. 

The El ab modifier only suppresses elaboration checks made by other units on 
this unit. This differs from the way pragma Suppress works. The pragma 
suppresses elaboration checks made on other units from the unit in which it 
resides. 

If you choose both the Checks and Elab modifiers, the Checks modifier takes 
precedence. 

With NOSuppress. the compiler does not suppress selected run-time checks and 
line information in generated object code. 


2-1 8 IBM Ada/370 




Xrcf Option 


Trace Option 


Tracr- 




race- 


The Trace option displays diagnostic messages from the comptier. This option is 
intended for use in submitting problems to IBM. For more information, see the 
IBM Ada/370 Diagnosis Guide. 


Xref Option 



The Xref modifier produces a cross-reference listing for each compilation unit 
contained in the source file. It creates one listing file for each source file. 

Byunit causes Xref to display symbols by compilation unit. By default, the Xref 
listing displays symbols in alphabetic order. 

Full causes Xref to cross-reference each compilation unit with all unit 
specifications that are visible to it. A unit specification is visible if it is an import 
to the compilation unit, if the compilation unit is a body, its parent and its 
parent's imports are also visible. Full does not display cross references for the 
private parts of imponed units. By default, Xref only cross-references the 
compilation units specified in the command. For more information, see 
“Cross-Referencer ■ on page 7-2. 

VMtCMS Usage 

The listing file takes the form source LISTING A. where source is the file name of 
the source file. 

MVS Usage 

The listing file takes the form gua/ffier USTlNG(source). where qualifier is the TSO 
logon identifier and source can be either the name of the member of a 
partitioned data set (POS) used as source or the second qualiTier in the name of 
a sequential data set. 


Chapter 2. Compiling Ada Programs 2-19 






Compiling Multipio Source Files 


Compiling Multiple Source Files 

An input list is a Tile containing a list of the names of Hies to be compiled. Using 
input lists, you can compile multiple source Tiles with a single invocation of the 
compiler. This reduces the time it takes to compile a group of source files 
because it eliminates some redundant activities within the compiler. 

The names of source files appear in the input list, along with other information 
that controls the compilation process. The compiler processes items in the input 
list in sequential order. Besides the object code that is the usual result of 
compilation, the compiler produces a file that contains information on the results 
of the success or failure of each compilation. 

If you use a compiler option that produces compilation listings (Asm. List. Error, 
or Xref. the compiler produces a separate listing for each compilation unit. 

To compile multiple Tiles with the ADA command, use the INHst option. 

If the compiler detects errors during compilation of any source file in the list, it 
goes on to the next source Tile. There may be cases, especially with a large 
input list, where it is not advisable to continue through the entire input list when 
multiple source files abort. The INlist option has a variable that allows you to 
specify the maximum number of source file compilation failures to allow. The 
next failure causes the compiler to stop processing the input list. 

Undf VMfCMS 
The command string 

ADA MYLIST (IN(6) 

compiles the source Tiles in the input list MYUST INUST. setting the failure limit at 
six. 

Under MVS 

The command string 

EX 'AOA.CLIST(AOA)' 'MYLIST.IHLIST (IH(6)’ 

compiles the source Tiles in the input list MYUST iNUST. setting the failure limit at 
six. The compiler uses the default high-level qualiTier. 

Constructing the Input List 

An input list contains two types of information, names of source files to be 
compiled and compile-time options. 

The syntax for each line of the input list is; 

name — - i-. — . — . 

-cempile-ttmejiptton^ 

-• comment - 

-blank JL tne - 

The rules for creating the input list are: 

• Place only put one liie name or compile-time option on a line. 

• Do not place comments on the same line with other information. 

• If the first nonblank character in a line is that line is a comment tine. 


2*20 IBM Ada/370 




Compiling Multiple Source Files 


• The compiler ignores blank lines. 

* Pile names do not have to start in the Tirst column. 

This VM/CMS file list follows the rules correctly. 

• rES, THIS IS A COMMENT 

AEILE ADA A 
BFILE AOA A 

eiStie AOA A 
BZSUe AOA A 

CFILC AOA A 

If an error occurs during input list processing, the compiler updates the working 
sublibrary with information about the units that have been compiled successfully 
Also, the compiler places information about the results in an output file. For 
more information about the contents of this file, see “Getting Information on an 
Input List Compilation" on page 2-22. 

VMtCMS Sourem file Namms 

Enter the names of source Files into the input list. If you leave out the File type, 
the compiler assumes the File type is ADA. 

Input List Compiler Interpretation 

MrFfLE MTFILE AOA • 

myfile test myfile test * 

MYFILE TEST A MYFILE TEST A 

MVS Sourea Data Sat Namaa 

Enter the names of source data sets into the input list either fully or partially 
qualified. Enclose fully qualified names inside a pair of single quotation marks. 

If you leave out the high-level qualifier, the compiler assumes the current TSO 
logon identifier 

Input Ust Compiler interpretation 

myfile 'qoa/i7Ter.MYFILE' 

MYFILE. TEST 'qua/i/fer MYFILE. TEST' 

■OTHER.MYFILE.TEST’ ’OTHER.MYFILE. TEST' 

Embedding Compilo-TIma Options In the Input Ust 

You can place compile-time options and input list options within the input list. 
Options set when you invoke the compiler apply to each source file until they are 
overridden by an option embedded in the input list. Options that appear in the 
input list apply to ail following source files until they are overridden by other 
embedded options. A specific option can appear multiple times in an input list. 


AOFTIOIfS-i-cwJWt lerjoptton -1 - — ■ »»^ 



Chapter 2. Compiling Ada Programs 2*21 





Compiling Muitipio Source Files 


The compiler options you can embed in input lists are: 

ASM 

CHECK 

COMPILE 

DEBUG 

ERROR 

INLIST 

LIST 

SUPPRESS 

XREF 


There is one valid inputjistjoption, DEFault. The OEFault option causes the 
compiler to reset ail options to their states as set by the ADA command. DEFaui t 
is only valid as part of the AOPTIONS command in an input list. 


The following example shows an input list with embedded options, along with 
descriptions of how the options change. This example uses VM/CMS File naming 
conventions: MVS users should use MVS conventions. 


Input List 


Hew Options Change 


AFILE AOA A 
tOPTIONS 0E8UG 
8FILE AOA A 
MPT IONS NOOEBUG 
CFILE AOA A 
MPTIOHS OEFAULT 
EFILE AOA A 
MPTIONS OEBUG 
FFILE AOA A 


Command'iine options 
Command-line options plus Oebug 
Command-line options plus NOOebug 
Command-line options only 
Command-line options plus Oebug 


Ggtting Information on an Input List Compilation 

The compiler creates a Ole and places information about of the compilation into 
it. Each line in the input list also appears in this file. Following each line from 
the input list containing the name of a source Ole is a line that shows 
compilation status for the file. Source files that compile successfully show a 
return code of zero for each compilation unit in the file. Files that do not compile 
show the return code of the error that caused the failure. There are also 
descriptive messages where return codes do not provide enough information. 


The return codes that can appear are; 

Code Explanation 

0 Execution complete. No erron occurred. 

4 Execution complete. Warnings were issued, but no errors occurred. 

8 Source code errors, such as syntactic or semantic errors, were detected. 
Look for specific errors in the console listing. 


Below is a brief example of an input list and the OUTPUT file that might result. 
This example uses VM/CMS file naming conventions; under MVS the output 
follows MVS conventions. 


2>22 IBM Ada/370 








Generating Recompilation Scripts 


Sample Input List MYLiST INPUT A 

(OPTIONS ASM 
FILEONC ADA A 
(OPTIONS OEF 
FILETUO ADA A 
(OPTIONS 0LTZ 

Sample OUTPUT File 

INPUT LIST processing MYLIST INPUT A - yyyy-arm-dd hh;m;ss • options {options 

(OPTIONS ASM 

FILEONE ADA A 

RC-ee FILEONE ADA A1 

(OPTIONS OEF 

FILETWO ADA A 

RC-Oe FILETWO AOA A1 

(OPTIONS BLTZ 

»* ERROR IN INPUT LIST COMMAND SYNTAX 
VMICMS Fi/e Name 

The name of the OUTPUT file takes the form inputJistjiame OUTPUT A. where 
inputJist_name is the file name of the input list. 

MVS Data Set Name 

The name of the output data set takes the form 

qualifier OKjTPKlVinputJistjname). where qualifier is the current TSO logon 
identifier and input Jistjiame is the name of the input list. 


Generating Recompilation Scripts 

VMICMS Syntax 

AOARECOM — comp_ un i ijiane ----- 


-(-pUbrery—(-1 tbraryjiam-)- 


Body- 




MVS Syntax 

oe-€X 'quel f/fer.CLlST(ADARECON)'— '-cemp^unttjjame- - — » 


-(-^Library —(-1 tbraryjxme-)- 


-Body- 


■CJ 


The AOARECOM Command generates a recompilation order list. When a library 
consists of many compilation units that depend on (possibly multiple levels of) 
with statements, it can be difficult to determine the proper compilation order if 


Chapter 2. Compiling Ada Programs 2’23 




Generating Recompilation Scripts 


the specification of a unit needs to be recompiled. To use aoarecom. you must 
have compiled the compilation units into a specified library at least once. 
AOARECOM reads the library to build a recompilation list of the units that depend 
upon the specified unit. This list contains the source file names of the units that 
need to be recompiied. Therefore, if you move an Ada compiiation unit to a new 
source fiie. you must modify the recompilation list. 

For AOARECOM to correctly generate the recompilation list, the association 
between file names and compilation units cannot change between the time they 
are compiled and the AOARECOM invocation. 

The file list produced under either VM/CMS or MVS is suitable for input to the 
INI 1st option to the AOA command. For more on this subject, see "Compiling 
Multiple Source Files'* on page 2-20. 

Do not change the names of the source file, separate the specification and body 
into different files, or perform any other change that alters the relationship 
between that file and the compilation unit or units it contains between the time 
you make the recompilation list and the time you perform the recompilation. 

You can to edit the recompilation list after running AOARECOM. to make changes 
to the recompilation order list. 

Also. AOARECOM produces a correct source file list only if each file contains a 
single compiiation unit. 

Precede the options by a blank space and a left parenthesis, and separate them 
from each other by blank spaces. A closing parenthesis is optional. 

The LIBrary option allows you to specify the name of the library file, 
library that AOARECOM is to read. 

If you specify the BOOy option. AOARECOM assumes that compjjnitjiama refers 
to the body of a compilation unit. By default. compjjnit_nama refers to the 
specification of a compilation unit. 

Under VMICMS 

You can provide the libraryjtama variable in either of two formats. The 
preferred format is filajnama filajypa lilejrtoda. The other format is 
niajnodafilajiama.filaJypa. In both formats, if you specify only the file name. 
aiajypa defaults to UBRARY and flla mode defaults to "*** If you do not specify 
a library file, AOA searches for AOA LIBRARY *. 

The recompilation list goes into a file called compjunit inlist a. 

The command 

AOMECW MY_PR0G (L(MrLI8.LIBRARY)) 

generates a recompilation fist that includes all units within MYUB LIBRARY that 
must be recompiled if you recompile MY_PROG, also found in that library. 

Under MVS 

If you do not specify lib_name, the default is <7oa///7er.AOA.LiBRARY. 

The recompilation list goes into a file called ouali/ier.lNUST(eomp_unit), where 
qualiHer is your TSO logon identifier. 


2*24 IBM Ada/370 








Separate Compilation of Generics 


The command 

EX 'AOA.CLISTCAOARECOM)' 'MY_PR0G (L(MYLIB))' 

generates a recompilation list that includes all units within pt/a/z/ier MYLIB that 
must be recompiled if you recompile MY_PR0G. also found in that library 


Separate Compilation of Generics 

IBM Ada/370 supports separateiy'Compiled generics. You can compile a generic 
specification in in Tile and its generic body in a separate nie. 

If you plan to compile your generics separately, compile the generic body before 
you attempt to instantiate the generic. The generic body must be compiled and 
visible in the library before the instantiation can occur. 

You can compile instantiations before you compile the generic body. If you do. 
the compiler issues a warning. When you compile a generic body, all 
instantiations of the generic become obsolete. You must recompile all 
instantiations of the generic after you compile a new generic body. 

For more information on the compiling and instantiation of generic units, see 
Chapter 12 of the LRM. 


Chapter 2. Compiling Ada Programs 2*25 





Saparat* Compilation of Genarics 


2-26 IBM Ada/370 




Using the IBM Ada/370 Binder 


Chapter 3. Binding and Linking an Ada Program 

The purpose of this chapter is to show you the different ways to invoke the IBM 
Ada/370 binder or the linkage editor, and to explain when you need to use them. 

The flexibility in symbol naming allowed by Ada makes implementation of the 
language difficult in environments using pre-existing linkage editors and loaders. 
To alleviate this problem. IBM provides a special Ada linker called the IBM 
Ada/370 binder. It combines object modules produced by the IBM Ada/370 
compiler and outputs them as a standard IBM object module. 

This partially-linked object module is further processed by the system 
linker/loader to produce an executable load module. The IBM Ada/370 binder 
provides full support of Ada requirements for symbol naming. It also drastically 
reduces the number of external definitions and references that must be 
processed by the host system linker. 

An Ada program can use pragma Interface to call subprograms written in a 
programming language other than Ada. The system linker puts the 
standard-format object modules produced for these subprograms into the 
executable load module it creates for an Ada program. 

The IBM Ada/370 binder also includes run-time environment routines as part of 
its output. 


Using the IBM Ada/370 Binder 

To invoke the IBM Ada/370 binder, compile an Ada main program using the MAin 
option of the AOA command. The system invokes the binder. The binder can 
produce a link map describing the contents of the partially linked object module 
it generates. The link map provides you with detailed information about the 
run-time memory locations of the various pieces of code that make up your 
program. 

Another option to the AOA command. Bind, causes IBM Ada/370 to bypass the 
compilation step. This allows you to bind a compilation unit that you have 
previously compiled as a library unit as a main program. 

The Generate option of the ADA command takes binder output and uses system 
utilities to generate a toad module. 

For more information on the HAIn. Bind, and Generate options to the ADA 
command, see "The Compiler Options" on page 2-6. 

You must rebind your main program when you recompile any Ada compilation 
units used in the program. You do not have to rebind the program if you 
recompile non-Ada routines that your Ada program calls, but you still have to 
link the program again with the linkage editor or loader. 


O Cooyngni iBM Corp. 1991 


3-1 






invoking the Binder with Job Control Language (JCL) 


invoking the Binder with Job Control Language (JCL) 

This section describes how to invoke the binder as a batch job under MVS using 
Job Control Language (JCL). For information on how to invoke the compiler 
using JCL. see "Compiling a Program with Job Control Language (JCL)" on 
page 2-3. 

The ADAS cataloged procedure invokes the IBM Ada/370 binder to bind an Ada 
main program that has been compiled using the IBM Ada/370 compiler. The 
output of the binder is an System/370 relocatable object data set. You can 
submit this data set to the linkage editor to generate an executable load module. 


//MYPROG JOB •.MSCCLASS-O.MSGLEVEL-d.D.NOTIPf-USERl. 
// CLASS>A 

//* 

//* PURPOSE: TO RUN THE ADA BINDER 
//• 

//BIND EXEC PR0C-A0AB.UNIT.HELL0. 

// USER>USER1 


Figure 3-f. Using the AOAB Cataloged Procedure to Invoke the Binder 

The preceding example shows a job. called MYPROG. which binds the Ada mam 
compilation unit HELLO. The user identifier USER) is specified with the USER 
variable. This variable is used as a high-level qualifier to construct data-set 
names for the compiler, such as USERi .AOA.UBRARY. This library is the default 
Ada library. Your job card will probably be different, because it depends on your 
site's conventions. 

As this job executes, the compiler creates relocatable object code in 
USER! 08J(HELL0). This object code was generated for the Ada main 
compilation unit called HELLO. 


3*2 IBM Ada/370 




Invoking th« Binder with Job Control Language (JCL) 


A sample of the aoA 8 cataloged procedure appears in Figure 3-2. The exact 
location of A0A8 may depend on your site's conventions. 


//ADAB 

PROC BNOPRM-' ‘,MEMSIZE-8196K, 

// 

STPLIB-'AOAl10.LOAOLIB',MAXTIHE-60, 

// 

VlO-V10,SYSOA-SYSALLOA,SYSOUT-*•*,UNIT»' ' 

//**“**** 

//* 

INVOKE THE BINDER 

//. 

//STEPl 

EXEC PGM-£VGBIHD,PARM-'&UNIT. ( &BN0PRM'.REGION-SHEMSIZE, 

// 

TIHE-&MAXTIME,DYNAMNBR-65,C0N0-(4,Lr) j 

//STEPLIB 

00 0SN«iSTPLIB,0ISP-SHR 

//CONOUT 

00 SYSOUT-4SYSOOT,OCB-(LRECL-120,BLKSIZE-12O) 

//AOALIB 

00 0SN«&USER..ADA.LIBRARY,DISP-SHR 

//AOAOBJ 

00 0SN-&USER..0BJ,DISP-(M0D.CATLG,CATLG). 

// 

OCB-(RECFM-FB.LRECL-80,BLKSIZE-3120,OSORG-PO,BUFNO-4), 

// 

SPACE-(60,(16000,16000,20)).UNIT-&SYS0A 

//AOAHAP 

00 0SN-4USER..AOAHAP,OISP-(MOO,CArLG,CATLG), 

// 

OCB-(RECFM-VB,LRECL-1023,BLKSIZE-3120,OSORG-PO,8UFN0-2), 

// 

SPACE-(132.(1000,2000,20)),UNIT-iSYSDA 

//AOAOHAP 

00 0SN-4USER..OEBUGHAP,DISP-(MOD,CATLG,CATLG), 

// 

OCB-(RECFM-VB,LRECL-1023,BLKSIZE-3120,OSORG-PO,BUFNO-2), 

// 

SPACE-(132,(1000,2000,20)),UNIT-ASYSOA 

//AOALIST 

00 0SN-4USER..LISTING,DISP-(MOO,CATLG,CATLG), 

// 

OCB-(RECFH-VBA,LRECL-2S9,BLKSIZE-312e,OSORG-PO,BUFNO-2), 

// 

SPACE-(132,(500,2000,20)),UNIT-4SYS0A 

//AOAUTl 

00 SPACE-(132,(500,2000)), 

// 

OCB-(RECFM-FB,LRECL-136,BLKSIZE-3406,DS0R6-0A,BUFNO-2), 

// 

UNIT-4SYS0A 

//A0AUT2 

00 SPACE-(132,(500,2000)), 

// 

OCB-(RECFM-¥8,LRECL-136,BLKSIZE-3120,OSORG-PS,BUFKO-2), 

// 

UNir-4V(0 

//A0AUT3 

00 SPACE-(132,(500,2000)), 

// 

OCB-(RECFM-FB,LRECL-1028,BLKSIZE-2056,OSORG-OA,BUFNO-2), 

// 

UNIT-4SYS0A 

//A0AUT4 

00 SPACE-(132,(500,2000)), 

// 

0CB-(RECFM-FB,LRECL-132,BLKSIZE-2640,OSORG-OA,BUFNO-2). 

// 

UNir-4SYS0A 


figure 3-2. ADAB Cataloged Procetiure 


Chapter 3. Binding and Linking an Ada Program 3*3 










Invoking tho Binder with Job Control Language (JCL) 


Symbolic Variables for ADAS Cataloged Procedure 

The ADAB cataloged procedure includes several symbolic JCL substitution 
variables you can modify to specify the various options available. 


Symbolic 

Variable 

BNOPRM 

MAXTIME 

MEMSIZE 

STPLIB 

srsoA 

SYSOUT 

UNIT, 

USER 

VIO 


Oeacriptlon 

Specifies options to the binder in the FARM field. A list of options 
you can specify in BNOPRM. along with a syntax diagram, appears 
in "Binder Options for Use with ADAB Cataloged Procedure" on 
page 3-5. 

Sets a maximum amount of time for the binder job step to run 
(using the TIME parameter on a JCL EXEC card). The default value 
is 60 minutes, but can be changed when the cataloged procedure 
is installed. 

Specifies the amount of memory in which to run the binder job 
step (using the REGION option on a JCL EXEC card). The greater 
the memory, the better the binder's performance. The default 
value is S196Kb. but this value may be changed when you install 
the cataloged procedure. 

Indicates the data-set name of the partitioned data set that 
contains the binder module. MVSBINDE. The default is the load 
library AOA.LOAOiJB but you can change this default when you 
install the cataloged procedure. 

Specifies the UNIT for permanent data set allocations. The 
default is SYSALLOA. but this name can be changed depending on 
your site's conventions. 

Identifies the output class for the binder output. The default is 
***. but this default can be changed, depending on your site’s 
conventions. 

Indicates the compilation unit to be bound. You must specify this 
variable. 

Indicates the high-level qualifier level qualirier required to build 
data set names used by the binder. You must specify this 
variable. It is common to set it to your TSO logon identifier. 

Specifies the UNfT for temporary data set allocations. The default 
is VIO, but this default can be changed depending on your site's 
conventions. 


3-4 


IBM Ada/370 





Linking Programs that Call Non-Ada Routines 


Binder Options for Use with ADAB Cataloged Procedure 

This section defines the standard options for the BNOPRM symbolic substitution 
variable. This '/artable. found in STEP2 of the AOAB cataloged procedure, 
specifies options to the binder in the PARM field. 

The binder options have the following syntax; 




Lions 

i 

—{-iMdlfi ers—^ 

-)- 



Table 3-1 lists the valid options, their modifiers, and defaults. Descriptions of 
the options appear on the pages shown. 


Table 3~1 Binder Options lor JCL 

Option 

Oafault 

Function 

Page 

ASM 

NOASM 

Assembly listing. 

2-9 

(NOGEN 


Suppress listing of expanded generics. 


1 NOSYS] 


Suppress listing of system-supplied generics. 


OONAMES 

oidjtame • newjname 


Specify the Data Description (00) names that identify 
the data sots used by the compiler and binder. It 
must include at least one modifier. 

2-12 

DEBUG 

NOOEBUG 

Output information for debugging. 

2-13 

MAP 

NONAP 

Produce linkage map during binding. 

2-17 

TRACE 

NOTRACE 

Display diagnostic messages from the compiler. Only 
for use in submitting problems to IBM. 

2-19 


Unking Programs that Call Non-Ada Routines 

Pragma Interface enables Ada compilation units to call non-Ada routines. The 
following sections show you how to compile and link programs that take 
advantage of this feature. 

User-written routines do not reside in the Ada library system. The only method 
available to connect non-Ada routines with the Ada routines that call them is to 
load them under VM/CMS or link-edit them under MVS A call to a non-Ada 
routine results in the generation of an external reference. This external 
reference is unresolved following normal ADA processing. You must take special 
steps in order to resolve virtual address constants to non-Ada routines. 


Chapter 3. Binding and Linking an Ada Program 3-S 

























Unking Programs that Cali Non-Ada Routines 


Under VM/CMS 

The following table explains the data sets used in calling non-Ada routines. 


Table 3-2. VM/CMS Files Used in Calling Non-Ada Routines 

File 

Oeeeription 

TEST AOA A 

File containing source for the main program. 

TEST 

Compilation unit name. 

TEST TEXT A 

nie containing the object code of the Ada routines. 

ROUTINE TEXT A 

File containing the object code of the non-Ada routines. 


The following example shows the correct procedure for compiling and linking 

AOA rESr (MAIN NORUN 
LOAD TEST ROUTINES 
GENHOO TEST 

The ADA command creates the obiect file TEST TEXT A The LOAD loads the 
object files TEST TEXT and ROUTINES TEXT into virtual storage and establishes the 
proper linkages between them. The order in the LOAD is important. The Ada 
module must go first. The GENMOD command uses the two object files to create 
a load module with the name TEST MODULE A. 

You may need to precede the commands in this example with a GLOBAL TXTUB 
command to resolve any missing external references from the LOAD command. 
The need for its use depends on how you load the non-Ada routines. For more 
information on the GLOBAL command, see the Virtual Machine/System Product 
CMS Command and Macro Reference. 


Under MVS 

Non-Ada routines do not reside in the Ada library system The only method 
available to connect non-Ada routines with the Ada routines that call them is to 
link-edit them. A call to a non-Ada routine results in the generation of an 
external reference. This external reference is unresolved following normal ADA 
processing. You must take special steps in order to resolve virtual address 
constants to non-Ada routines. This section explains those steps. 

The following table explains the data sets used in calling non-Ada routines. 


Table 3-3 (Page 1 of 2). 

MVS Data Sets Used in Calling Non-Ada Routines 

Data Set 

Oaacrfptiwn 

guaf/f/er.TEST.AOA 

Data set obtaining source for the main program, 
whose compilation unit name is Test. 

qualifier.HOHAZA.OS4 

Data set containing the object code of the non-Ada 
routines. 

qualifier.OBJ 

Partitioned data set containing the object coda of the 

Ada routines. 

qualifier LOAD 

Partitioned data set containing the executable load 
modules; also called the ’’load library." 


There are two methods for compiling and linking an Ada program with non-Ada 
routines. The first involves binding with NOGenerate. then linking the foreign 


3-6 


IBM Ada/370 






Linking Programs that Call Non-Ada Routinas 


language code manually M/ith the linkage editor. The second Involves placing 
the code in a partitioned data set (POS) such that the object goes into the object 
library created by the Bind option. The following two examples show how to use 
these methods. 

Using the Linkage Editor 

First compile the main program, using the NOGenerate option. 

EX 'AOA.CLIST(AOA)' 'TEST.AOA (MAIN NOGENERATE' 

This member contains one or more unresolved references to non-Ada code. The 
following call to the linkage editor resolves the unresolved external references 
associated with those calls. 

LINK ('USERl.NONAOA.OBJ*,'USERl.OBJ(TEST)') 

The TEST load library member is now fully linked and ready to execute. 

Using a Partitionad Data Sat 

If you choose to use a partitioned data set. use the following steps; 

1 Place the foreign language routine's object code into a partitioned data set. 

2. Issue the TSO ALLOC command for a 00 name of SYSUB and then associate 
this with the POS containing the non-Ada object code. 

ALLOC OO(SYSLIB) 0A('USERl.NONAOA.OBJ’) SHR 

3. Bind the main program (or compile and bind) without using the NOGenerate 
option. The LINK within AOA will refer to the SYSUB allocation as it attempts 
to resolve references to the non-Ada routines. 

The TEST load library member is now fully linked to be executed. 

For more information on LINK, see the UNK command in the IBM publication. 
MVS/Extended Architecture TSO Extensions TSO Command Language Reference. 


Chapter 3. Binding and Unking an Ada Program 3*7 






Unking Programs that Call Non-Ada Routines 



3<4 IBM Ada/370 





APPENDIX C 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementatlon^dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this Appendix are to compiler documentation and not to this 
report. Implementation-specific portions of the package STANDARD, which 
are not a part of Appendix F, are: 


package STANDARD is 

type INTEGER is range -2 147 483 648 .. 2_147_483_647; 
type SHORT_INTEGER is range -32_768 .. 32_767; 

type FLOAT is digits 6 range -7.23701E+75 .. 7.23701E+75; 
type LONG_FLOAT is digits 15 range -7.23700557733225E+75 

.. 7.23700557733225E+75; 

type DURATION is delta 2#1.0#E-14 range -86400.0 .. 86400.0; 
end STANDARD; 


C-1 








ATTACHMENT A 


APPENDIX F 

OF THE LANGUAGE REFERENCE MANUAL 

Th« Ada language definition allows for certain target dependencies in a controlled manner. 
This section, called Appendix F as prescribed in the LRM, describes implementation*dependent 
characteristics of the IBM Ada/370, Version 1.1.0 running under CMS or MVS. 

1. Implementation-Defined Pragmas 

PRAGMA INTERFACE( Assembly, <subroutine name> ); 

PRAGMA INTERFACE( Assembler, <subroutine_name> ); 

PRAGMA INTERFACE( Fortran, <subroutine_name> ); 

PRAGMA SUPPRESS_ALL; 

to cause Pragma SUPPRESS to be invoked simultaneously for all the following 
condition^names: accessjcheck, discriminantjcheck, indexjcbeck, length check, 

division_check, elaborationjcheck, and storage check. ~ 

PRAGMA NOJUPPRESS ( <identifier> ); 

to prevent the suppression of checks within a particular scope. Particularly useful when a 
section of code that relies upon predefined checks executes correctly, but, for performance 
reasons, the suppression of checks in the rest of the code is needed. 

PRAGMA COMMENT (stringjiteral); 

embeds string Jiteral into object code. 

PRAGMA IMAGES (enumeration_type, <immediate>| <deferred>); 

generates a table of images for the enumeration type, defearred causes the table to be 
generated only if the enumeration type is used in a compilation unit. 

PRAG\U INTERFACE INFORhUTION 

(<name>, 

<linkjDame>, 

<mechanism>, 

< parameters >, 

<clobbered jregs >); 

when used in association with pragma INTERFACE, will provide access to any routine 
whose name can be specified by an Ada string literal. 

PRAGM\ PRESERVE _LAYOUT ( ON »> <Record_Type_Name> ); 

forces the compiler to maintain the Ada source order of components of a given record type, 
thereby preventing the compiler from performing this record layout optimization. 

* PRAGMA INLINE (procedure^name); 

to specify a subprogram body which should be expanded inline at each call whenever 
possible. 

■»*PRAGMA OS_TASK (priority); 




to specify the relative urgency of each MVS task created. 

••PRAGMA ALLOCATION DATA 

(<acceasjtype>, 

<re8idence_jnode >, 

< allocation _duration >. 

< subpool _number >, 

<discrete user data>); 

to associate MVS virtual storage attributes with an Ada access type. 

•Note that PRAGMA INLINE is effective only when the optimizing option is selected at 
compile time. If optimizing is not selected the pragma is ignored and a warning is issued. 

••Note that PRAGMA OS_TASK and PRAGMA ALLOCATION_DATA are effective only 
when compiling for an MVS target. Both pragmas require that an MVS runtime be present. 


2. Implementation-Defined Attributes 

2.1. Integer Type Attributes 

Extended_Image ( Item, <Width>, <Base>, <Based>, <Space_IF_Positive> ); 

to return the image associated with Item as defined in Text_^IO.Integer_IO. The Text 10 
definition states that the value of Item is an integer literal with no underlines, no exponent, 
no leading zeroes (but a single zero for the zero value), and a minus sign if negative. 

Extended_Value (Item); 

to return the value associated with Item as defined in Text_IO.lDteger_^IO. The Text^IO 
definition states that given a string, it reads an integer value from the beginning of the 
string. The value returned corresponds to the sequence input. 

Extended_Width ( <Ba8e>, <Based>, <Space_IF_Po8itive> ); 
to return the width for a subtype specified. 

2.2. Enumeration Type Attributes 
Extended_lmage ( Item, <Width>, <Uppercase>); 

to return the image associated w'ith Item as defined in Text_IO.Enumeration_IO. The 
Text_IO definition states that given an enumeration literal, it will output the value of the 
enumeration literal (either an identifier or a character literal). The character case 
parameter is ignored for character literals. 

Extended_Value ( Item ); 

to return the image associated with Item as defined in Tcxt_IO.Enumeration_IO. The 
Text_IO definition states that it reads an enumeration value from the beginning of the given 
string and returns the value of the enumeration literal that corresponds to the sequence 
input. 

Extended_Width; 

to return the width for a specified subtype. 


2.S. Floating Point Attributes 

Extended^bnsge ( Item, <Fore>, <Aft>, <Exp>, <Base>, <Baaed> }; 

to return the image associated with Item as defined in Text_IO.Float_IO. The Text_IO 
definition states that it outputs the value of the parameter Item as a decimal literal with 
the format defined by the other parameters. If the value is negative, a minus sign is 
included in the integer part of the value of Item. If Exp is 0, the integer part of the output 
has as many digits as are needed to represent the integer part of the value of Item or is zero 
if the value of Item has no integer part. 

Extended^Value (Item ); 

to return the value associated with Item as defined in TextJ[O.Float_IO. The Text_IO 
definition states that it skips any leading zeroes, then reads a plus or minus sign if present, 
then reads the string according to the syntax of a real literal. The return value is that 
which corresponds to the sequence input. 

Extended_Digit8 ( <Base> ); 

to return the number of digits using base in the mantissa of model numbers of the specified 
subtype. 

2.4. Fixed Point Attributes 

Extended^Image (Item, <Fore>, <Aft>, <Exp>, <Base>, <Based> ); 

to return the image associated with Item as defined in TextJ10.Fixed_I0. The TextJlO 
definition states that it outputs the value of the parameter Item as a decimal literal with 
the format defined by the other parameters. If the value is negative, a minus sign is 
included in the integer part of the value of Item. If Exp is 0, the integer part of the output 
has as many digits as are needed to represent the integer part of the value of Item or b zero 
if the value of Item has no integer part. 

Extended_Value ( Image ); 

to return the value associated with Item as defined in Text_IO.Fixed_IO. The Text__IO 
definition states that it skips any leading zeroes, reads a plus or minus sign if present, then 
reads the string according to the syntax of a real literal. The return value is that which 
corresponds to the sequence input. 

Extended_Fore ( <Base>, <Based> ); 

to return the minimum number of characters required for the integer part of the based 
representation specified. 

Extended_Aft ( <Base>, <Based> ); 

to return the minimum number of characters required for the fractional part of the based 
representation specified. 

3. Package SYSTiUM 

The current specification of package SYSTEM is provided below. 


With Unchecked_Conversion; 
PACKAGE System IS 





- CUSTOMIZABLE VALUES 


TYPE Name IS (MC68000, ANUYK44, IBM370); 

System Name : CONSTANT came := IBM370; 

Memory Sixe : CONSTANT (2 ** 24)-l; 

Tick ~ : CONSTANT 1.0 / (10 ** 6); 

- NON-CUSTOMIZABLE, IMPLEMENTATION-DEPENDENT VALUES 


Storage Unit : CONSTANT := 8; 

Min_Inr : CONSTANT :* -(2 ** 31); 

Max_Int : CONSTANT := (2 ** 31) - 1; 

Max Digits : CONSTANT 15; 

Max_Mantissa : CONSTANT 31; 

Fine_^Delta ; CONSTANT 1.0 / (2 ** Max_Mantissa ); 

Subtype Priority IS Integer RANGE 0 .. 255; 


- ADDRESS TYPE SUPPORT 


type Memory is private; 
type .\ddress is access Memory; 

Null_Address : Constant Address ;= null: 

type Address_Value is RANGE -(2''*31) .. (2'*’*31)-1; 

Hex 80000000 : constant Address \'alue := - 16^80000000;?: 
Hex_90000000 : constant Address_Value : - - 16#70000000 <p: 

Hex AOOOOOOO : constant Address_Value ;= - 16^60000000*; 
Hex_BOOOOOOO : constant Address_Value := - 16*50000000#; 
Hex_C0000000 : constant Address_Value := - 16#40000000#; 
Hex_D0000000 : constant Address Value := - 16#30000000#; 
Hex_E0000000 : constant Address Value - 16#20000000#; 
Hex_F0000000 : constant Address Value := - 16#10000000#; 

function Location is new Unchecked_Conversion (Address_^Value, Address); 

function Label (Name: String) return Address: 
pragma Interface (META, Label); 






























- CALL SUPPORT 


type Subprogram_Value IS 
record 

Procjtddr : Address; 

Parent_frame : Address; 
end record; 

Max Object Sixe : CONSTANT Max int; 

Max_RecordjCount : CONSTANT Max_Ittt; 

Max Text Io_Count : CONSTANT Max Int-1; 

MaxJTextjo Field : CONSTANT1000; “ 

private 

type Memory is 
record 
null; 

end record; 
end SYSTEM; 

4. Representation Clauses 

Thb implementation supports address, length, enumeration, and record representation 
clauses with the following exceptions: 

Address clauses are not supported for package, for entry, for tasktype, for 
subprograms. 

Enumeration .clauses are not supported for boolean representation clauses. 

The size in bits of representation specified records is rounded up to the next highest multiple 
of 8, meaning that the object of a representation specified record with 25 bits will actually occupy 
32 bits. 

Non>supported clauses are rejected at compile time. 

5. Implementation*Generated Names 

There are no implementation-generated names denoting implementation-dependent 
components. Names generated by the compiler shall not interfere with programmer-defined 
names. 

8. Address Clause Expression Interpretation 

Expressions that appear in Address clauses are interpreted as virtual memory addresses. 

7. Unchecked Conversion Restrictions 

Unchecked^Conversion is allowed except when the target data subtype is an unconstrained 
array or record type. If the size of the source and target are static and equal, the compiler will 
perform a bitwise copy of data from the source object to the target object. 



Where the sizes of source and target differ, the following rules will apply: 

• ff the size of the source is greater than the size of the target, the high address bits wiU 
be truncated in the conversion. 

• If the size of the source is less than the size of the target, the source will be moved into 
the low address bits of the target. 

The compiler will issue a warning when Unchecked Conversion u instantiated with unequal 
azes for source and target subtype. UncheckedjConversion between objects of different or non¬ 
static sizes will usually produce less efficient code and should be avoided, if possible. 

8. Implementation-Dependent Characteriatica of the I/O Packages 

• Sequential_10, Direct_10, and Text_IO are supported. 

• Low_Level_IO is not supported. 

• Unconstrained array types and unconstrained types with discriminants may not be 
instantiated for I/O. 

• File names follow the conventions and restrictions of the target operating system. 

• In Text 10, the type Field is defined as follows: subtype Field is integer range 

0 .. 1000 ; ” 

• In Text 10, the type Count is defined as follows: 

0..2 147 483 646; 


t]rpe Count is range 



