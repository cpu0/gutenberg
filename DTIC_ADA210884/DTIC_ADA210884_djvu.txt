AD-A210 884 




UNCLASSIFIED_ 


ClASSlf ICATlOfc Qf this >*GC (^v^^n0^r^ fwtfffcO 

REPORT DOCUMENTATION PAGE 



u.<p ixmL'cnoNi 

tov-.r 7 i;s' 


1. RtPORI NJMBIR 


|2. 60V1 ACCESSION NO. |3 NtCl^HNI S C*U,.OG NCWdiA 


4. TITlC (tndii/btitit) 

Si£ 

Ada Compiler Validation Summary Reportj eonr 

AG, Siemens BS2000 Ada Compiler V2.0, SieriTens 7.590( 

(host and target), 89030611.10059 


1 . AUlHORu; 

lABG^ 

Ottobrunn, Federal Republic of Germany. 


•. fERFORMlNG 0RGAN12ATJ0K ANO AOORISS 
lABG, 

Ottobrunn, Federal Republic of Germany. 


11. co"ao:ling office name and Aponiss 
Ada Joint Program Office 
United States Department of Defense 
Washington, DC 2u301>3061 


14. MOMIORING AGENCY NAME A ADDHLSSOf difitrent from Controlling Office) 
lABG, 

Ottobrunn, Federal Republic of Germany. 


16. DISTRIBJTION STATEMENT (of thii Report) 


S. Type Of REPOAT i PIP30D COVERED 

Siemens ^ March 1989 - 1 Dec. 1990 


6. performing *t>RG. REPORT NUMBER 


8. contract or ARANT NUMEERp; 


10. program element. PRCJECT. TASa 
AREA 8 MORA UNIT NUMBERS 


12. REPORT DATE 


IS. security Class (oI this report) 
UNCLASSIFIED 


IS*. g^C^ASS^FlCATlON.'DOMSGRADlNG 

N/A 


Approved for public release; distribution unlimited. 


IB . CEymORDS (Continue on reverte ilOf if rteieuer) eriOidentify 6> block number) 

Ada Prograrr-T.ing language, Ada Compiler Validation Suirjr.ary Report, 
Compiler Validation Capability, ACVC, Validation Testing, Ada 
Validation Office, AVO, Ada Validation Facility, AVF, AKSl/MIL-STI 
1815A, Ada Joint Prograit Office, AJPO 


20 , ABSTRAC T (Continue on reverie tide if netetui) end identify by block number) 

Siemens BS2000 Ada CompUar V2.0, Siemens AG. lABG, Ottobrunn. Siemens 7.590G 
BS2000/V9.0 (host and target), ACVC 1.’'' 


under 



DD 






















AVF Control Numeer 


IABG-VSR-025 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
CartiFicate Number: 89030611.10059 
Siemens AG 

Siemens BS2000 Ada Compiler V2.0 
Siemens 7.590G Host and Target 


Completion or On-Site Testing: 
atn Marcn 1989 


Preoarea 3v: 
IA33 morii Abt SZT 
Einsternstr 20 
D-3012 Ottoorunn 
Vest Germany 


Prepared For: 

Aoa Joint Program Office 
United States Department ot DeFense 
Uasfjington DC 20201-3081 



Accesion f-'C)r 

NTIS CRA&i 
DFlC 7AH 
U .an-^io 
J'JSlifrCJliuM 

By. 

DlSt’iblition / 


□ 

□ 


Avjil.ibiiily Copies 


I Avj., j .a lot 


H 


V 










Ada Compiler Validation Summary Report: 


Compiler Name: Siemens BS2000 Ada Compiler V2.0 
Certificate Number: B90306I1.10059 


Host and Target: Siemens 7.590G under BS2000/V9,0 


Testing Completed 6th March 1989 Using ACVC 1.10 


This report has been reviewed and is approved. 





lABG mbH\ Abt SZT 
Dr. S. Heilbrunner 
Einsteinstr 20 
D-8012 Ottobrunn 
Uest Germany 



Institute for Defense Analyses 
Alexandria VA 22211 


Ada Joint Program Office 
Dr. John Solomond 
Director 

Washington D.C. 20301 












Ada Compiler Validation Summary Report: 


Compiler Name: Siemens BS2000 Ada Compiler V2.0 
Certificate Number: 89030611.10059 

Host and Target: Siemens 7.590G under BS2000/V9.0 

Testing Completed 6th March 1989 Using ACVC 1.10 


This report has been reviewed and is approved. 



lABG mbH\ Abt SZT 
Dr. S. Heilbrunner 
Einsteinstr 20 
D-8012 Ottobrunn 
Uest Germany 



Ada Joint Program Office 
Dr. John Solomond 
Director 

Washington D.C. 20301 









CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1-1 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.1-2 

1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-3 

1.5 ACVC TEST CLASSES.1-4 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED . 2-1 

2.2 IMPLEMENTATION CHARACTERISTICS . 2-2 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.3-1 

3.2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 UITHDRAUN TESTS.3-2 

3.5 inapplicable TE5T5 . 3-2 

3.6 TEST, PROCESSING. AND EVALUATION MODIFICATIONS . . 3-6 

2.7 ADDITIONAL TESTING INFORMATION . 3-7 

3.7.1 Preval idation.3-7 

3.7.2 Test Method .3-7 

3.7.3 Test Site .3-B 

APPENDIX A DECLARATION OF CONFORMANCE 

APPENDIX E APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 

COMPILER AND LINKER OPTIONS 


APPENDIX E 





























CHAPTER 1 


INTRODUCTION 



This Validation Sunmary Report describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 

reports the results oj . testing this compiler using the Ada Compiler 

Validation Capability i^ACVC) An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada 'Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that is 
not in the Standa rd.^ 

Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between implementations. 
The Ada Standard permits some implementation dependencies--for example, the 
maximum length of identifiers or the maximum values of integer types. 
Other differences between compilers result from the characteristics of 
particular operating systems, hardware, or implementation strategies. All 
the dependencies observed during the process of testing this compiler are 
given in this report .n 

The information in this report is derived from t.he test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, tne ACVC, as inputs to an Ado compiler and 
evaluating the results. The purpose of validating is to ensure conforrity 
of the compiler to the Ada Standard by testing that tne compiler properly 
implements legal language constructs and that it icentifies and rejects 
illegal language constructs. The testing also identifies behavior that is 
implementation dependent, but is permitted by the Adc Standard. Six 
classes of tests are used. These tests are designed to perform checks at 
compile time, at link time, and during execution. 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 



This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 


1-1 









INTRODUCTION 


To attenpt to identify any language constructs supported by the 
conpiler that do not conform to the Ada Standard 

. To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by the AVF according to procedures 
established by the Ada Joint Program Office and administered by the Ada 
Validation Organization (AVO). On-site testing was completed 6th March 
19B9 at Siemens AG, Munich. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO may 
make full and free public disclosure of this report. In the United States, 
this is provided in accordance with the "Freedom of Information Act" 
(5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject compiler has no nonconformities 
to the Ada Standard other than those presented. Copies of this report are 
available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 

or from: 

lABG mbH, Abt SZT 
Einsteinstr 20 
0-8012 Ottobrunn 
West Germany 

Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 









INTRODUCTION 


1.3 REFERENCES 


1. BfiifiCfiOffi Nanuiil far Ibe BEDacamiilcs Laoauasfi. 
ANSI/HIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. SI&OEllsr ^alidallflQ Ecfidfidunds and iiuidcliDfii. Ada Joint 
Program OFF ice, 1 January 1987, 

3. Add CfiDElIdC ydliddlifiO CdEddlllly l!)El£lD£DlA££l £uld£f SoFTech, 
Inc., December 1986. 

4. Ada CciDEilfiE YaildaliflD CaEabilily Uianls Suida. December i986. 


1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set oF Ada 

programs that tests the conFormity oF an Ada compiler to the 
Ada programming language. 

Ada An Ada Commentary contains all inFormation relevant to the 

Commentary point addressed by a comment on the Ada Standard. These 

comments are given a unique identiFication number having the 
Form Al-ddddd. 

Ada Standard ANSI/NIL-STD-1815A, February 1983 and ISO 8652-1987. 

Applicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible For 

conducting compiler validations according to procedures 
contained in the Ads £2E;EiiSIl Viiillatlon EZ£ 2 Sdiir£x §nd 
alildfiliCSS. 

AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices For the purpose oF 
maintaining a uniform process For validation oF Ada 
compilers. The AVO provides administrative and technical 
support For Ada validations to ensure consistent practices. 

Compiler A processor For the Ada language. In the context oF this 

report, a compiler is any language processor, including 
cross-compilers, translators, and interpreters. 

Failed test An ACVC test For which the compiler generates a result that 

demonstrates nonconformity to the Ada Stanoard. 

Host The computer on which the compiler resides. 


X- 


1-3 










INTRODUCTION 


Inapplicable An ACVC test that uses features of the language that a 

test coipiler is not required to support or may legitinately 

support in a way other than the one expected by the test. 

Passed test An ACVC test for which a compiler generates the expected 

result. 

Target The computer which executes the code generated by the 

compi ler. 

Test A program that checks a compiler’s conformity regarding a 

particular feature or a combination of features to the Ada 
Standard. In the context of this report, the term is used to 
designate a single test, which may comprise one or more 
files. 

An ACVC test found to be incorrect and not used to check 
conformity to the Ada Standard. A test may be incorrect 
because it has an invalid test objective, fails to meet its 
test objective, or contains illegal or erroneous use of the 
language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name identifies 
the class to which it belongs. Class A, C, D, and £ tests are executable, 
and special program units are used to report their results during 
execution. Class B tests are expected to produce compilation errors. 
Class L tests are expected to produce errors because of the way in which a 
program library is used at link time. 

Class A tests ensure tr.e successful comoilction and execution of legal Ada 
programs with certain language constructs which cannot be verified at run 
time. There are no explicit program ccmoonents in a Class A test to check 
semantics. For example, a Class A test checks tnat reserved words of 
another language (otner tnan those aireaoy reserved in tr.e Ada language) 
are not treated as reserved words by an Ada compiler. A Class A test is 
passed if no errors are detected at compile time ano the program executes 
to produce a PASSED message. 

Class E tests check that a compiler detects illegal language usage. 
Class fi tests are not executable. Each test in this class is compiled and 
the resulting compilation listing is examined to verify that every syntax 
or semantic error in the test is detected. A Class B test is passed if 
every illegal construct thai it contains is detected by the compiler. 


Withdrawn 

test 


X 


1-4 









INTRODUCTION 


Class C tests check the run tine system to ensure that legal Ada programs 
can be correctly compiled and executed. Each Class C test is seH-checking 
and produces a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when it is executed. 

Class D tests check the compilation and execution capacities of a compiler. 
Since there are no capacity requirements placed on a compiler by the Ada 
Standard for some parameters--for example, the number of identifiers 
permitted in a compilation or the number of units in a library-a compiler 
may refuse to compile a Class D test and still be a conforming compiler. 
Therefore, if a Class D test fails to compile because the capacity of the 
compiler is exceeded, the test is classified as inappl icuble. If a Class D 
test compiles successfully, it is self-checking and produces a PASSED or 
FAILED message during execution. 

Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the Ada 
Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is rejected 
by tfis compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is attempted. 
A Class L test passes if it is rejected at link time—that is, an attempt 
to execute the main program must generate an error message before any 
declarations in the main program or any units referenced by the main 
program are elaborated. In some cases, an implementation may legitimately 
detect errors during compilation of the test. 

Two library units, the package REPORT and the procedure CHECK_FILE, support 
the self-checking features cf the executable tests. Tr.e package REPORT 
provides the mechanism by which executaoie tests report PASSED, FAILED, or 
NOT APPLICABLE results. It also oroviaes a se: of identity functions used 
to defeat some compiler optimizations allowed by the Ada Standard that 
would circumvent a test objective. The procedure CHECK.FILE is used to 
check the contents of text files written by some of the Class C tests for 
Chapter 14 of the Ada Standero. The operation of REPORT and CHECK_F1LE is 
Checked by a set of executable tests. These tests produce messages that 
are examined to verify that the units are operating correctly. If these 
units are not operating correctly, then the validation is net attempted. 

The text o^ each test in the ACVC follows conventions that are intended to 
ensure that the tests are reasonably portable without modification. For 
example, the tests make use of only the basic set of 55 characters, contain 
lines with a maximum length of 72 characters, use small numeric values, and 
place features that may not be supported by all implementations in separate 
tests. However, some tests contain values that require the test to be 


1-5 






INTRODUCTION 


customized according to implementation-specific va]ues--for example, an 
illegal file name. A list of the values used for this validation is 
provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable to 
the implementation. The applicability of a test to an implementation is 
considered each time the implementation is validated. A test that is 
inapplicable for one validation is not necessarily inapplicable for a 
subsequent validation. Any test that was determined to contain an illegal 
language construct or an erroneous language construct is withdrawn from the 
ACVC and, therefore, is not used in testing a compiler. The tests 
withdrawn at the time of this validation are given in Appendix D. 


X 


1-6 








CHAPTER 2 


CONFIGURATION INFORMATION 


2.1 CONFIGURATION TESTED 

The candidate conpilation system For this validation was tested under the 
Following conFiguration: 

Compiler: Siemens BS2000 Ada Compiler V2.0 
ACVC Version: 1.10 
Cer:iFi:ate Number: 89020611.10059 
Host and Target Computer: 

Machine: Siemens 7.590G 

Operating System: BS2000/V9.0 


Memory Size: 


64 ME 









CONFIGURATION INFORMATION 


2.2 IMPLEMENTATION CHARACTERISTICS 

One oF the purposes of validating compilers is to determine the behavior of 
a compiler in those areas of the Ada Standard that permit implementations 
to differ. Class D and E tests specifically check for such implementation 
differences. However, tests in other classes also characterize an 
implementation. The tests demonstrate the following characteristics: 


a. Capacities. 

(1) The compiler correctly processes a compilation containing 723 
variables in the same declarative part. (See test D29002K.) 

(2) The compiler correctly processes tests containing loop 
statements nested to 65 levels. (See tests D55A03A..H (B 
tests).) 

(3) The compiler correctly processes tests containing block 
statements nested to 65 levels. (See test D56001B.) 

(4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tests D64005E..G (3 tests).) 


b. Predefined types. 

(1) This implementation supports the additional predefined type 
SHORT.INTEGER in the package STANDARD. (See tests B86001T..Z 
(7 tests).) 


c. Expression evaluation. 

The order in which expressions are evaluated and the time at which 
constraints are checkea are not defined by the language. While 
the ACVC tests do not specifically attempt to oetermine the order 
of evaluation of expressions, test results indicate the following: 

(1) None of the default initialization expressions for record 
components are evaluated before any value is checked for 
membership in a component’s subtype. (See test C32117A.) 

(2) Assignments for subtypes are performed with the same precision 
as the base type. (See test C35712B.) 

(3) Thi implementation uses no extra bits for extra precision and 
Uj' all extra bits for extra range. (See test C35903A.) 


2-2 






CONFIGURATION INFORMATION 


(4) CONSTRAINT.ERROR is raised for integer and largest integer and 
no exception is raised tor smallest integer when an integer 
literal operand in a comparison or membership test is outside 
the range of the base type. (See test C45232A.) 

(5) CONSTRAINT.ERROR is raised when a literal operand in a 
Fixed-point comparison or membership test is outside the range 
oF the base type. (See test C45252A.) 

(6) UnderFlow is not gradual. (See tests C45524A..2 (26 tests).) 


d. Rounding. 

The method by which values are rounded in type conversions is not 
deFined by the language. While the ACVC tests do not speciFically 

attempt to determine the method oF rounding, the test results 

indicate the Following: 

(1) The method used For rounding to integer is round away From 

zero. (See tests C46012A..Z (26 tests).) 

(2) The method used For rounding tc longest integer is round away 
From zero. (See tests C46012A..Z (26 tests).) 

(3) The method used For rounding to integer in static universal 

real expressions is round away From zero. (See test C4A014A.) 


e. Array types. 

An implementation is allowed to raise NUMERIC.ERROR or 

CONSTRAINT ERROR For an arrav havina a ’LENGTH that exceeds 

STANDARD.INTEGER’LAST and/or SYSTEM.MAX.INT. For this 
imo1ementetion: 

(1; Test C36002A oeals with an array type oeclaration with 

SYSTEM.MAX.INI components. Tne parameters oF the type 

declaration can be evaluated at compile time. No type 

cescriptor is provided by the compiler. The elaboration oF 

tne type declaration will only checx the index bounds (and not 
the length oF the array). No exception will be raised. (See 
test C36003A.) 

(2) Test C36202A deals with an array type declaration with 

INTEGER’LAST + 2 components. The parameters oF the type 

declaration cannot be evaluated at compile time. A type 

descriptor is provided by the compiler which contains the 

length oF the array. The elaboration oF the type descriptor 
will calculate the length oF the array. NUMERIC.ERROR will be 


2-3 










CONFIGURATION INFORMATION 


raised s'nce the length exceeds the ad»issable range. (See 
test C3620ZA.) 

(3) NUMERIC.ERROR is raised when an array type with SYSTEM.MAX.INT 
* 2 corponents is declared, for the same reasons as for test 
C36202A above. (See test C36202B.) 

(4) A packed BOOLEAN array having a ’LENGTH exceeding INTEGER’LAST 
raises NUMERIC ERROR when the array type is declared. (See 
test C52103X.) 

(5) A packed two-dimensional BOOLEAN array with more than 

INTEGER’LAST components raises NUMERIC.ERROR when the array 
type is declared. (See test C52104Y.) 

(B) In assigning one-dimensional array types, the expression is 

evaluated in its entirety before CONSTRAINT.ERROR is raised 
when checking whether the expression’s subtype is compatible 
with the target’s subtype. (See test C52013A.) 

(7) In assigning two-dimensional array types, the expression is 

not evaluated in its entirety before CONSTRAINT.ERROR is 
raised when checking whether the expression’s subtype is 

compatible with the target’s subtype. (See test C52013A.) 


f. A null array with one dimension of length greater than 
INTEGER’LAST may raise NUMERIC.ERROR or CONSTRAINT.ERROR either 
when declared or assigned. Alternatively, an implementation may 
accept the declaration. However, lengths must match in array 
slice assignments. This implementation raises NUMERIC.ERROR when 
the array type is declared. (See test E52103Y.) 


g. Discriminated types. 

(11 In assigning record types with di scr iminants, the expression 
is evaluated in its entirely before CONSTRAINT.ERROR is raised 
when checking whether the expression’s subtype is compatible 
with the target’s subtype. (See test C52013A.) 


h. Aggregates. 

(1) In the evaluation of a multi-dimensional aggregate, the test 
results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 


2-4 










CONFIGURATION INFORMATION 


(2) In the evaluation oF an aggregate containing subaggregates, 
not all choices are evaluated before being checked For 
identical bounds. (See test E43212B.} 

(3) CONSTRAINT.ERROR is raised aFter all choices are evaluated 
when a bound in a non-null range oF a non-null aggregate does 
not belong to an index subtype. (See test E43211fi.) 


Pragmas. 

(1) The pragma INLINE is not supported For Functions or 
procedures. (See tests LA3004A..B (2 tests), EA3004C..D (2 
tests), and CA3004E..F (2 tests).) 


Generics. 

(1) Generic speciFications and bodies can be compiled in separate 
compilations. (See tests CA1012A, CA2009C, CA2009F, BC3204C, 
and BC3205D.) 

(2) Generic subprogram declarations and bodies can be compiled in 
separate compilations. (See tests CA1012A and CA2009F.) 

(3) Generic library subprogram specifications and bodies can be 
compiled in separate compilations. (See test CA1012A.) 

(4) Generic non-library package bodies as subunits can be compiled 
in separate compilations. (See test CA2009C.) 


(5) 

Generic 

non-library subprogram 

bodies 

can 

be 

compiled 

in 


separate 

compi1 at ions From their 

stubs. 

(See 

test 

CA2009F. 

) 

(6) 

Generic 

unit bodies and their subunits 

can 

be 

compiled 

in 


separate 

compilations. (See test 

CA3011A 

.) 




(7) 

Generic 

package declarations and 

bodies 

can 

be 

compiled 

in 


separate compilations. (See tests CA2009C, BC3204C, and 

BC3205D.) 

(6) Generic library package specifications and bodies can be 
compiled in separate compilations. (See tests 6C3204C and 
BC3205D.) 

(?) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 


2-5 







CONFIGURAriON INFORMATION 


k. Input and output. 

(1) The package SEQUENTIAL.IO cannot be instantiated with 

unconstrained array types or record types with discrininants 
without defaults. (See tests AE2101C, EE2201D, and EE2201E.) 

(2) The package DIRECT_IO cannot be instantiated with 

unconstrained array types or record types with discriminants 
without defaults. (See tests AE2101H, EE2401D, and EE2401G.) 

(3) Nodes IN FILE and OUT.FILE are supported for SEQUENTIAL.IO. 
(See tests CE2102D..E, CE2102N, and CE2102P.) 

(4) Modes IN FILE, OUT FILE, and INOUT FILE are supported for 
DIRECT l6. (See tests CE2102F, CE2102I..J (2 tests), CE2102R, 
CE2102T, and CE2102V.) 

(5) Modes IN FILE and OUT FILE are supported for text files. (See 
tests CE3102E and CE3102I..K (3 tests).) 

(6) RESET and DELETE operations are supported for SEQUENTIAL 10. 
(See tests CE2102G and CE2102K.) 

(7) RESET and DELETE operations are supported for DIRECT^IO. (See 
tests CE2102K and CE2102Y.) 

(B) RESET and DELETE operations are supported for text files. 
(See tests CE3102F..6 (2 tests), CE3104C, CE3110A, and 
CE3114A.) 

(9) Overwriting to a sequential file truncates to the last element 
written, (See' test CE220BB.) 


(10) 

Temporary sequential files are given 
when closed. (See test CE2108A.) 

names 

and not deleted 

(11) 

Temporary direct files are given names 
closed. (See test CE2108C.) 

and 

not deleted 

when 

(12) 

Temporary text files are given names 
closed. (See test CE3112A.) 

and 

not deleted 

when 

(13) 

More than one internal file can be associated with 
external file for sequential files when reading only, 
tests CE2107A..E (5 tests), CE2102L, CE2110B, and CE2111D 

each 

(See 

.) 


(14) More than one internal file can be associated with each 
external file for direct files when reading only. (See tests 
CE2107F..H (3 tests), •CE2110D and CE2111H.) 


2-6 







CONFIGURATION INFORMATION 


(15) More than one internal file can be associated with each 
external file for text files when reading only. (See tests 
CE3111A..E (5 tests), CE3114B, and CE3115AJ 


2-7 




CHAPTER 3 


TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. Uhen this compiler was 
tested, 43 tests had been withdrawn because of test errors. The AVF 
determined that 401 tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing except foi' 201 
executable tests that use floating-point precision exceeding that supported 
by the implementation. Modifications to the code, processing, or grading 
for 16 tests were required to successfully demonstrate the test objective. 
(See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 5UMHART OF TEST RESULTS BY CLASS 


RESULT 

A 


TEST 

CLASS 
„2_ 

► 

._L_. 

TOTAL 

Passed 

127 

1130 

1933 

17 

22 

44 

3273 

Inapplicable 

2 

6 

383 

0 

6 

2 

401 

Withdrawn 

1 

2 

34 

0 

6 

0 

43 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


X 


3-1 











TEST INFORMATION 


3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT CHAPTER TOTAL 

_2_3_4_5_ k _2_fi_ 1 _Ifi_11_12_13_ li _ 


Passed 


198 572 544 245 172 99 159 233 131 


36 252 254 278 3273 


N/A 

14 

77 

136 

3 

0 

0 

7 

0 

6 

0 

0 

115 

43 

Udrn 

1 

1 

0 

0 

0 

0 

0 

1 

0 

0 

1 

35 

4 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 


3.4 WITHDRAWN 

TESTS 





The following 43 tests were 

withdrawn 

from ACVC 

Version 1.10 

at the time of 

this validation 

• 





E28005C 

A39005G 

B97102E 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A62D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD:A83G 

CD2A84N 

CD2AB4H 

CD50110 

CD2B15C 

CD7205C 

CD2D11B 

CD5007B 

E07004B 

ED700SC 

ED7005D 

ED7006C 

ED7006D 

CD7105A 

CD7203B 

CD7204B 

CD7205D 

CE2107I 

ce3ii:c 

CE3301A 

CE3411B 





' 

See Appendix 0 

for the reason that each of these 

tests was withdrawn. 


401 

43 

3717 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of features 
that a compiler is not required by the Ada Standard to support. Others may 
depend on the result of another test that is either inapplicable or 
withdrawn. The applicability of a test to an implementation is considered 
each time a validation is attempted. A test that is inapplicable for one 
validation attempt is not necessarily inapplicable for a subsequent 
attempt. For this validation attempt, 401 tests were inapplicable for the 
reasons Indicated: 

a. The following 201 tests are inapplicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAX.DIGITS: 


3-2 










TEST INFORMATION 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..2 (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


b. C3550BI, C35506Ji C35S08M, and C3SS06N are inapplicable because 

they include enumeration representation clauses For BOOLEAN types 
in which the representation values are other than (FALSE => 0, 

TRUE => 1). Under the terms oF AI-00325, this implementation is 

not required to support such representation clauses. 

c. C35702A and B86001T are inapplicable because this implementation 
supports no predeFined type SHORT_FLOAT. 

d. C35702B and B86001U are inapplicable because this implementation 
supports no predefined type LONG.FLOAT. 

e. The Following U tests are inapplicable because this 
implementation does not support a predeFined type LONG.INTEGER: 


C45231C 

C45304C 

C45502C 

C455C3C 

C45504C 

C45504F 

C45611C 

C45613C 

C45614C 

C45631C 

C45632C 

CD7101F 

B52004D 

C55B07A 

B55B09C 

B86001U 

F. C4S531M..P (4 

tests) and 

C45532M..P (4 

tests) 

are inaoDlicable 


because this implementation has a value of MAX_HANTISSA oF less 
than 48. 


g. C86001F is inapplicable because, For this implementation, the 

package TEXT_IO is dependent upon package SYSTEM. These tests 
recompile package SYSTEM, making package TEXT_I0, and hence 
package REPORT, obsolete. 

h. B86001X, C45231D, and CCTIOIG are inapplicable because this 

implementation does not support any predefined integer type with a 
name other than INTEGER, LONG.INTEGER, or SHORT.INTEGER. 

i. B86001Y is inapplicable because this implementation supports no 

predeFined Fixed-point type otner than DURATION. 

j. B66001Z is inapplicable because this implementation supports no 

predeFined Floating-point type with a name other than FLOAT, 
LONG.FLOAT, or SHORT.FLOAT. 

k. LA3004A, LA3004B, EA3004C, EA3004D, CA3004E, and CA3004F are 

inapplicable because this implementation does not support pragma 
INLINE. 


X- 


3-3 











TEST INFORMATION 


1. The FoMowing 14 tests are inapplicable because o-f restrictions on 
’SIZE length clauses -for floating point types: 


CD1009C 

C02A41A 

C02A41B 

C02A41E 

CD2A42A 

CD2A42B 

CD2A42C 

CD2A42D 

CD2A42E 

CD2A42F 

CD2A42G 

CD2A42H 

CD2A42I 

CD2A42J 


The following 

22 tests are inapplicable 

because of restrictions on 

’SIZE length 

clauses i 

as detailed in Appendix F of the Ada 

Standard: 





CD2A61A 

CD2A61B 

CD2A61F 

CD2A61H 

CD2A61I 

CD2A61J 

C02A62A 

CD2A62B 

CD2A71A 

CD2A71B 

CD2A72A 

CD2A72B 

CD2A84E 

CD2AB4C 

CD2A84D 

CD2A84E 

CD2A84F 

CD2A84G 

CD2A64H 

CD2A84I 

CD2A84K 

CD2A84L 




CD2B1S6 is inapplicable 1 

because a col lection size 

larger than the 

size specified 

was allocated by this implementation. 

The following 76 tests are inapplicable 

because this 

implementjtion 

does not : 

support address 

clauses: 


CD5003B 

CD5003C 

CD5003D 

CD5003E 

CD5003F 

CD5003G 

CDS003H 

CD5003I 

CD5011A 

CD5011B 

CD5011C 

CD5011D 

CD5011E 

CD5011F 

COSOllG 

CD5011H 

COSOllI 

CD5011K 

CBSOllL 

CDSOllH 

CD5011N 

CDSOllO 

CD5011R 

CD5011S 

CD5012A 

CD50i2B 

CD5012C 

CD5012D 

CD5012E 

CD5012F 

CD5012G 

CD5012H 

CD5012I 

CD5012J 

CD5012L 

C05012M 

CDS013A 

C05013B 

CD5013C 

CD5013D 

CD5013E 

CD5013F 

CD5013G 

CD5013H 

CD5013I 

CD5012K 

CI)5013L 

CD5013M 

CD5013N 

CD50130 

CD5013R 

CD5013S 

CD5014A 

CD5014B 

CDSOiAC 

CD5014D 

CD5014E 

CD5014F 

CD5014G 

CD5014H 

CD5014I 

CD5014J 

C05014K 

CD5014L 

CD5014M 

CD5014N 

CDS0140 

CD5C14R 

CD5014S 

CD5014T 

CD5014U 

CD5014V 

CD5014U 

CD5014X 

CD5014Y 

CD5014Z 





AEriOlC, EE22 

OID, and 

EE2201E use 

instantiat 

ions of package 

SEQUENTIAL.IO 

with unconstrained array 

types and 

record types with 

discriminants 

without defaults. These 

instantiations are rejected 

by this compiler. 




AE2101H, EE2401D, and 

EE2401G use 

instantiations of package 

DIRECT_IO with unconstrained array 

types and 

record types with 

discriminants 

without defaults. These 

instantiat 

ions are rejected 


by this compi1er . 


3-4 






TEST INFORMATION 


r. CE21020 is inapplicable because this inpiementation supports 

CREATE with IN.FILE mode ^or SEQUENTIAL.IO. 

s. CE2102E is inapplicable because this implementation supports 

CREATE with OUT.FILE mode For SEQUENTIAL.10. 

t. CE2102F is inapplicable because this implementation supports 

CREATE with INOUT.FILE mode For DIRECT.IO. 

u. CE2102I is inapplicable because this implementation supports 

CREATE with IN.FILE mode For DIRECT.IO. 

V. CE2102J is inapplicable because this implementation supports 

CREATE with OUT.FILE mode For DIRECT.IO. 

w. CE21G2N is inapplicable because this implementation supports OPEN 
with IN.FILE mode For SEQUENTIAL.IO. 

X. CE21020 is inapplicable because this implementation supports RESET 
with IN.FILE mode For SEQUENTIAL.IO. 

y. CE2102P is inapplicable because this implementation supports OPEN 
with OUT.FILE mode For SEQUENTIAL.IO. 

2 . CE2102Q is inapplicable because this implementation supports RESET 

with OUT.FILE mode For SEQUENTIAL.IO. 

aa. CE2102R is inapplicable because this implementation supports OPEN 

with INOUT.FILE mode For DIRECT.IO. 

ab. CE2102S is inapplicable because this implementation supports RESET 
with INOUT.FILE mode For DIRECT.IO. 

ac. CE2102T is inapplicable because this implementation supports OPEN 

with IN.FILE mode For DIRECT.IO. 

ad. CEC102U is inapplicable because this implementation supports RESET 
with IN.FILE mode For DIRECT.IO. 

ae. CE2102V is inapplicable because this implementation supports OPEN 

with OUT.FILE mode For DIRECT.IO. 

aF. CE2102U is inapplicable because this implementation supports RESET 
with OUT.FILE mode For DIRECT.IO. 

ag. CE2107B..E (4 tests), CE2107L, CEZllOB and CE2111D are 

inapplicable because multiple internal Files cannot be associated 
with the same external File when one or more Files is writing Fo'' 
sequential Files. The proper exception is raised when multiple 
access is attempted. 


3-5 










TEST INFORMATION 


ah. CE21076..H (2 tests), CE2110D, and CE2111H are inapplicable 

because multiple internal Tiles cannot be associated with the same 
external file when one or more files is writing for direct files. 
The proper exception is raised when multiple access is attempted. 

ai. CE3102E is inapplicable because text file CREATE with IN.FILE mode 
is supported by this implementation. 

aj. CE3102F is inapplicable because text file RESET is supported by 
this implementation. 

ak. CE3102G is inapplicable because text file deletion of an external 
file is supported by this implementation. 

al. CE3102I is inapplicable because text file CREATE with OUT_FILE 
rode is supported by this Implementation. 

am. CE3102J is inapplicable because text file OPEN with IN.FILE mode 
is supported by this implementation. 

an. CE3102K is inapplicable because text file OPEN with OUT.FILE mode 
is not supported by this implementation. 

ao. CE3111B, CE2111D..E (2 tests), CE3114B, and CESIISA are 

inapplicable because multiple internal files cannot be associated 
with the same external file when one or more files is writing for 
text files. The proper exception is raised when multiple access 
is attempted. 


3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases where 
legitimate implementation behavior prevents the successful completion of an 
(otherwise) applicable test. Examples of such modifications include: 
adding a length clause to alter the default size of a collection; splitting 
a Class B test into subtests so that all errors are detected; and 
confirming that messages produced by an executable test demonstrate 
conforming behavior that was not anticipated by the test (such as raising 
one exception instead of another). 

Modifications were required for 16 tests. 

The following tests required the inclusion of 

"PRAGMA ELABORATE (REPORT);" 


X- 


3-6 










TEST INFORMATION 


A39005A CD7004C CD7005E CD7006E 

The following tests were split because syntax errors at one point 
resulted in the conpiler not detecting other errors in the test: 

B22003A B24007A B24009A B35302A B38003A B38009A 

B38009B B49003A B49005A B67001C B95032A B97103E 


3.7 ADDITIONAL TESTING INFORMATION 
3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 produced 
by the Siemens B52000 Ada Compiler V2.0 was submitted to the AVF by the 
applicant for review. Analysis of these results demonstrated that the 
compiler successfully passed all applicable tests, and the compiler 
exhibited the expected behavior on all inapplicable tests. 


3.7.2 Test Method 

Testing of the Siemens BS2000 Ada Compiler V2.0 using ACVC Version 1.10 was 
conducted on-site by a validation team from the AVF. The configuration in 
which the testing was performed is described by the following designations 
of hardware and software components: 

Host and Target computer: Siemens 7.590G 

Host and Target operating system: BS2000/VP.O 

A magnetic tape containing all tests except for witnorawn tests and tests 
requi"ing unsupported floating-point precisions was taken on-site by the 
vaiication tear for processing. Tests that make use of 
implementation-specific values were customized before being written to tne 
magnetic tape. Tests recuiring modifications during the preval idation 
testing were induced in their modified form on the magnetic taoe. 

The contents of the magnetic tape were loaded directly onto the host 
computer. 


After the test files were loaded to disk, the full set of tests was 
compiled , linked, and all executable tests were run on the Siemens 7.590G. 
Results were printed from the host computer. 

The compiler was tested using command scripts provided by Siemens AG and 
reviewed by the validation team. The compiler was tested using all default 
option settings. See Appendix E for the list of options and their meaning. 


X- 


3-7 










TEST INFORMATION 


Tests were conpiied, linked, and executed (as aporopriate) using a single 
coeiputer. Test output, conpilation listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 


3,7.3 Test Site 

Testing was conducted at Siemens AG, Munich and was completed on 6th March 
1989. 


X 


3-8 











APPENDIX A 


DECLARATION OF CONFORMANCE 


Siemens AG has submitted the following Declaration of 
Conformance concerning the Siemens BS2000 Ada Compiler V2.0. 


■V 


A-1 






DECLARATION Of CONFORMANCE 


DECLARATION OF CONFORMANCE 


Compiler Implementor: SIEMENS AG, Miinchen, FR6 

Ada Validation Facility: IAB6 mbH, 8012 Ottobrunn, FRG 

Ada Compiler Validation Capability (ACVC) Version: 1.10 


Base Configuration 

Base Compiler Name: Siemens BS 2000 Ada Compiler V2.0 

Host and Target Architecture: Siemens 7.590G 

Host and Target OS and Version: Siemens BS2000A/9.0 


Derived Compiler Registration 

Derived Compiler Name: Same as above 

Host and Target Architecture: 7.531,7.536,7.541,7.551 

7.530,7.550,7.560, 

7.561.7.571,7.550, 

7.560.7.570,7.580.7.590 

7.700 

Host and Target OS and Version: BS2000A/7.5, V7.6, V8.0, V8.5. V9.0, V9.2. 

V9.5 

Implementor's Declaration 

I, the undersigned representing SIEMENS AG, have implemented no deliberate 
extensions to the Ada Language Standard ANSI/MIL-STD-1815A in the 
compiler(s) listed in this declaration. I declare that Siemens AG is the owner of 
record of the Ada language compiler(s) listed above and, as such, is responsible 
for maintaining said compiler(s) in conformance to ANSI/MIL*STD-1815A. All 
certificates and registrations for Ada language compiler(s) listed in this 
declaration shall be made only in the owner's corporate name. 


March 8.1989 

SIEMENS AG U 

Dr. \N. Hoyer, Deputy Manager 


I, the undersigned, representing SIEMENS AG, take full responsibility for 
implementation and maintenance of the Ada compiler(s) listed above, and agree 
to the public disclosure of the final Validation Summary Report. I declare that all 
of the Ada language compilers listed, and their host/target performance, are in 
compliance with the Ada Language Standard ANSI/MIL-STD-1815A. 


_ 

SIEMENS AG U 

Dr. W. Hoyer, Deputy Manager 


Date: March 8, 1989 













APPENDIX B 


APPENDIX F OF THE Ada STANDARD 


The only' allowed inplenentat ion dependencies correspond to 
inplementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in chapter 13 oT the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics oF the Siemens BS2000 Ada Compiler V2.0 , as described in 
this Appendix, are provided by Siemens .AG. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. Implementation-specific portions of the package 
STANDARD, which are not a part of Appendix F, are: 


package STANDARD is 


type INTEGER is range -2.147 483.646 .. 2 147 483 647; 
type SHORT.INTEGER is range -32.678 .. 32.767; 

type FLOAT is digits 15 range -281.0SE212 .. 281.0E212; 

type DURATION is delta 2S1.0E-14 range -131 071.0 .. 131 071.0; 
OURATION’SMAlL : 281.0E-14; 


end STANDARD; 


B-1 










F. Implementation-Dependent Characteristics 


1 


3 


The Ada language definition allows for certain machine-dependences in a controlled manner. No 
machine-dependent syntax or semantic extensions or restrictions are allowed. The only allowed 
implementation-dependences correspond to implementation-dependent pragmas and attributes, 
certain machine-dependent conventions as mentioned in chapter 13, and certain allowed restric¬ 
tions on representation clauses. 

This appendix summarizes all implementation-dependent chararteristics of the Siemens BS2000 Ada 
Compiler. It describes; 

(1) The form, allowed places, and effect of every implementation-dependent pragma. 

(2) The name and the type of every implementation-dependent attribute. 

(3) The specification of the package SYSTEM (see 13.7). 

(4) The list of all restrirtions on representation clauses (see 13.1). 

(5) The conventions used for any implementation-generated name denoting implementation- 
dependent components (see 13.4). 

(6) The interpretation of expressions that appear in address clauses, including those for 
interrupts (see 13.5). 

(7) Any restriaion on unchecked conversions (see 13.10.2). 

(8) Any implementation-dependent characteristics of the input-output packages (see 14). 


F.1 Implementation-Dependent Pragmas 


There are no impiementation-defined pragmas. 

The only language names accepted by pragma INTERFACE are ASSEMBLER and COBOL 

The only priority accepted by pragma PRIORITY is represented by an expression of the static value 0 
(cf. the definition of the subtype PRIORITY in package SYSTEM). 


F,2 Implementation-Dependent Attributes 


1 


There are no implementation-dependent attributes apart from those described in F.5. 










Implementation-Dependent Characteristics 


F.3 Specification of the Package SYSTEM 


1 package SYSTEM is 

type ADDRESS is new INTEGER; 
type NAME is (BS2000): 

SYSTEM.NAME ; constant NAME : = BS2000; 

STORAGE-UNIT ; constant: = 8; 

MEMORY-SIZE : constant: = 4_000_000; 

- System-Dependent Named Numbers: 

MIN-INT : constant: = - 2-147.483-648; 

MAX- MT : constant := 2-147-483-647; 

MAX-DIGITS : constant: = 15; 

MAX-MANTISSA : constant := 31 ; 

FINE-DELTA : constant: = 2.0*»(-30); 

TICK : constant r= 0.000.1; 

- Other System-Dependent Declarations 
subtype PRIORITY is INTEGER range 0 .. 0; 

end SYSTEM; 


F.4 Restrictions on Representation Clauses 


Length Clauses: 

For the specification of SIZE all values from Oto INTEGER’LAST can be given. The length clause is 
accepted if the value specified is not smaller than the number of bits used to represent all possible 
values. 

^ The following list shows the smallest values allowed for some types, 
boolean types : 1 Pit 

access types 32 bits 

task types 32 bits 

INTEGER 32 b ts 

FLOAT 64 bits 

CHARACTER 8 bits 

DURATION 32 bits 

3 Generally a representation clausefor a derived type of a private type is rejected if the full declara¬ 
tion is a composite type and if the derived type has to be packed to fulfil the representation clause. 

4 Specification of SMALL for a fixed-point type : the specified value must be a power of 2; other 
values are not accepted. 

5 Enumeration Representation Clauses: 

An enumeration representation clause is not accepted for a type derived from the predefined 
enumeration type BOOLEAN. ' 

An enumeration representation clause is not accepted for a derived type if a constraint is given for 
the parent subtype associated with this derived type 


6 








Implementation-Dependent Chararteristics 


7 An enumeration representation clause is not accepted if any of the internal codes does not lie 
within the range SYSTEM.MIN__INT to SYSTEM.MAX_INT. 

8 Component Clauses: 

In addition to the restrictions stated in the LRM 13.4 the following implementation-depenaent 
restrictions on the values of the static expressions given in a component clause exist: 

9 Consider the component clause 

COMPONENT at EXP range LOW .. UPP 

10 Define 

component offset := EXP • SYSTEM.ST0RAGE_UN1T LOW; 
and 

component size : = max ( UPP - LOW ■♦•1,0); 

11 Both values for component offset and component size must lie in the range 0..SYSTEM.MAX INT; 
otherwise, the component clause is not accepted. 

Furthermore, the following restrictions depending on the type associated with the corresponding 
component apply: 

:2 ( 1 ) for components of some discrete type the following restriaions apply; 

component offset no further restriaions. 

component size must be less than or equal to 32. 

:3 (2) for components of some fixed point type the following restriaions apply: 

component offset no further restriaions. 

component size must be less than or equal to 32 

(3) for components of some floating point type the following restriaions apply: 
component offset must be a multiple of 64 

component size must equal 64. 

’5 (4) for components of some access type the following rest.-tcfons apply 

component offset must be a multiple of 32. 

component size must equal 32. 

16 (5) for components of some task type the following restriaions apply: 

components offset must be a multiple of 32. 

components size must equal 32. 

17 ( 6 ) for components of some array type the following restriaions apply: 

component offset must be a multiple of the alignment of the array elements in terms of 

bits. 

component size must equal the size of the array type. 

18 (7) for components of some record type the following restriaions apply: 

component offset must be a multiple of the maximum over the alignments of the 

record components and a multiple of the user-specified alignment (if 
any) for the record type in terms of bits, 
component size must equal the (maximum) size of the record type . 

X 

19 Alignment clauses: 

An alignment given in an alignment clause is accepted only if the value (in terms of storage units) 
does lie within the range 1 .. 8 . 












Implementation-Dependent Characteristics 


20 An alignment given in an alignment clause is accepted only if the value (in terms of bits) is a multiple 
of the maximum over the alignments of all components of the corresponding record type. 


F.5 Conventions for Implementation-Generated Names Denoting Implemen¬ 
tation-Dependent Components in Record Representation Clauses 

’ Implementation-dependent components may be added to record objetts by the compiler. 

2 Storage place specification for implementation-dependent record components can be achieved 
solely by means of implementation-dependent attributes. The following list shows all 
implementation defined attributes and the restrictions applied to the corresponding 
implementation dependent components. 

3 For a record type R ; 

R'RECORD SIZE For any record object of type R this implementation-defined 

attribute denotes an implicit component which yields the number of 
bits allocated for the record objett. 

The implementation-dependent component exists only if the objects 
of type R may vary in size. 

R'VARIANT INDEX For any record objea of type R this implementation-defined 

attribute denotes an implicit comoonent which yields a value used to 
determine which components exist for the given record objec 

The implementation-dependent comoonent exists only if R is a 
record type with a variant part. 

i For a component C of a record type R : 

C'DOPE For any record objea of type R tnis imoiementation-defined 

attribute denotes an implicit component which yields the offset of 
the component C relative to the staa of the record. 

The implementation-dependent component exists only if the 
component C is of a component type whose constraint is dynamic. 

C’ARRAY_DESCRIPTOR For any record objea of type R this implementation-defined 

attribute denotes an implicit component which yields values used to 
describe the component C. 

The implementation-dependent component exists only if C is of an 
array type and if the component subtype definition for C includes an 
index constraint which contains at least one discriminant of R. 


CRECORD_DESCRIPTOR For any record objea of type R this implementation-defined 

attribute denotes an implicit component which yields values used to 
describe the component C. 




Implementation-Dependent Charaaeristics 


5 


6 


7 


The implementation -dependent component exists only if C is of a 
record type and if the component subtype definition for C includes a 
discriminant constraint which contains at least one discriminant of R. 

Any of these implementation-defined attributes can be used only as component names in 
component clauses. Any other use of these anributes is illegal. 

Any of these implementation-defined attributes can be used only if the corresponding 
implementation-dependent component exists for the corresponding record type or record 
component, respectively: otherwise, the corresponding component clause is not accepted. 

The following restrictions apply to the component offset and component size for the above-defined 
implementation-dependent components in corresponding component clauses: 


RECORD__SIZE : 

component offset must be a multiple of 32. 

component size must equal 32. 


VARIANT_1NDEX; 
component offset 
component size 


must be a multiple of 16. 
must equal 16. 


DOPE: 

component offset 
component size 


must be a multiple of 16. 
must equal 16. 


ARRAY_DESCRIPTOR : 

comporrent offset must be a multio'e of 32, 

component size must equal 32 • n, if n is the number of dimensions of the array type 

associated witn the corresoondmg component. 


RECORD_DESCRlPTOP. 
component offset 
component size 


must be a multiple of 32. 
must eaual 32. 


F.6 interpretation of Expressions Appearing in Address Clauses 

Address clauses are not yet supported. 

F.7 Restrictions on Unchecked Type Conversions 

The Siemens BS2000 Ada compiler supports the generic function UNCHECKED-CONVERSION with 
the following restriaion: 












Implementation-Dependent Characteristics 


2 The actual generic subtype corresponding to the formal generic type TARGET must not be an 
unconstrained array type, and it must not be an unconstrained type with discriminants that have no 
defaults. The instances gained from UNCHECKED.CONVERSION return a target value whose bit 
pattern is a left-aligned copy of that of the source value. The number of bits transferred corresponds 
to the size of the target subtype. If the size of the source value is greater than the size of the target 
subtype, then the source value information is truncated on the right hand side, i.e. the low order 
bits are ignored. If the size of the source value is not greater than the size of the target subtype, 
then - again - as many bits are transferred as corresponds to the size of the target subtype, and no 
padding with zeroes, spaces or other charaaers is performed. 


F.8 Implementation-Dependent Characteristics of the Input-Output Packages 


F.8.1 Introduction 


’ The SEQUENTIALIO, DIRECT.IO and TEXTJO packages are all written in Ada and they make calls on 
BASIC_lO which is a “typeless" package working with addresses and byte counts. SEQUENTIALIO 
and DIRECT.lO are generic packages, also I!SITEGER_I0, FIXED_lO, FLOAT_IO and ENUMERATIONJO 
in TEXTJO are generic. 

2 The routines written in assembler language have the name ADARTSBx with x in 1 .. 9, A .. Q, while 
the BASIClO routines have nearly the same names as in the input-output packages of Ada. 


F.8.2 Conventions for name and form 


External files are supported by the SAM, ISAM, SYSDTA, SYSOU" and SYSLST BS2000 files where the 
value of the parameter FORM of the CREATE and OPEN procedures determines which access method 
is selected. 


2 The set of allowable values of FORM is given below together with the type of BS2000 file 
corresponding to it. Leading blanks and lower-case letters are not allowed in the FORM string. 

2 value of FORM BS2000 access method 


SAM 

ISAM 

SYSDTA 

SYSOUT 

SYSLST 

SAM.PRINT 

ISAM.PRINT 

PAM 

EAM 

OMF 


Sequential Access Method 
Indexed Sequential Access Method 

The file (or device) associated with the BS2000 system file SYSDTA 

The file (or terminal) associated with the BS2000 system file SYSOUT 

The file (or printer) associated with the BS2000 system file SYSLST 

Like SAM but with printer control charaaers in the first column (see below) 

Like ISAM but with printer control characters in the first column (see below) 

Primary Access Method 

Evanescent Access Method 

Objea Module Format 


4 


Each input-output package operates on a subset of the allowable forms. 









Implementation-Dependent Charaaeristics 


5 SAM, ISAM, SAM_PRINT, ISAM.PRINT and PAM files are identified by the value of the parameter 
NAME of the CREATE and OPEN procedures whose chararters must conform to the BS2000 file 
naming conventions as described below. The value of the parameter NAME is ignored for other 
values of FORM. 


6 


The syntax associated with the string NAME is as follows 


NAME 

file_name 


cat_id 

link_name 

user_id 

admin_name 

name 

name-character 


::= .link_namelfile_name 
:: = ;cat_id: $ user_id . name { . name } ( 
SuserJd . name { . name } | 
$admin_name | 
name { . name } 

::= name-Character 

:: = name-Character { name-character } 

:: = name-character { name-character) 
:: = name-character { name.charaaer} 
; ; = name-Character { name-character} 

:: = upper-caseJetterI digit] 
special-character 


special-character :;=$[(§(#(- 


BS2000 imposes the following additional restrictions upon the syntax of NAME. 

1. The maximum length of a link-name or a userJd is eight charaaers. 

2. The maximum length of a file-name starting with :cat_id; is 54 charaaers. 

3. The maximum length of a file_name starting with Suser.id is 51 characters. 

4. The maximum length of an admin_name is 47 charaaers unless it contains onn or more 

periods in which case the maximum length is 53 charaaers. 

5. The maximum length of a file.name staaing with name is 41 charaaers. 

6. The first charaaer of a name must not be a special character, and the last charaaer must not 
be a hyphen. 

A fiie-name must include at least one letter. 


7 . 










Implementation-Dependent Charaaeristics 


8 Example of using TZXIJO: 


with TEXTJO; useTEXT.IO; 
package FILE-MANAGEMENT is 

ACTUAL-FILEI : TEXTJO.FILE_TYPE 
ACTUA1_FIL£2 : TEXTJO.FILE-TYPE 
ACTUA1_FILE3 : TEXT-IO.FILE-TYPE 


begin 

Create a BS2000-SAM file with name A.SAM.FILE 


TEXTJO.CREATE (FILE => ACTUAL-FILEI, 

MODE = > OUT-FILE. 

NAME = > “A.SAM.FILE", 

FORM = > “SAM”); 

Create a BS2000-ISAM file with the link name ABCD and with file-name 
AN.ISAM.FILE 

BS2000 command; ” /FILE AN.ISAM.FILE,LINK = ABCD" (Note; no 

TEXTJO.CREATE (FILE = >ACTUAI_FILE2, 

MODE = > OUT-FILE, 

NAME = > “.ABCD", ~ Note; with 
FORM =>"ISAM'); 

Open the BS2000-5AM file with link-name XYZ and with file-name A.SAM.FILE 
BS2000 command; "/FILE A.SAM.FILE.LINK = XYZ' (Note; no 


"EXT-IO.OPEN 


(FILE = >ACTUAL-FiLE3, 

MODE = > IN-FILE, 

NAME => ".XYZ", - Note; with 

FORM = > "SAM"), 


end FILE-MANAGEMENT; 


F.8.3 File management 


2 


This seaion describes the implementation restrictions which apply to the sequential, direa and text 
input-output packages equally. The maximum number of oD)ects which may be stored in an external 
file is dependent upon the maximum number of recoros or the maximum number of blocks which 
may be stored in its underlying BS2000 file. The values given below state this maximum for each 
FORM provided that limits imposed by the system configuration are not otherwise reached. For the 
direct and sequential input-output packages, each objea is stored in a separate record or block; for 
the text input-output package, each line is stored in a separate record. 


FORM Maximum Number of Records / Blocks 


SAM 

ISAM 

SAM-PRINT 


configuration dependent limit 
99 999 999 records 
configuration dependent limit 













Implementation-Dependent Charaaeristics 


3 


4 


ISAM_PRINT 

PAM 

EAM 

OMF 

SYSDTA 

SYSOUT 

SYSLST 


99 999 999 records 
configuration dependent limit 
configuration dependent limit 
configuration dependent limit 
configuration dependent limit 
configuration dependent limit 
configuration dependent limit 


Two alternative record formats are available for ISAM and SAM files, varying and constant length. 
TEXTJO always uses varying length records whereas DIRECTJO and SEQUENTIALIO support both 
formats. A varying length record format is used if an instance of direct or sequential input-output 
packages uses unconstrained element-types. Otherwise a fixed length record format is used where 
the length equals the value of (ELEMENT TYPE’SIZE + 7) / 8 (that are the number of bytes needed 
for this special type). 


The maximum size of the objects which can be stored in an external file is restricted. The universal 
integer value which results from the apolication of the SIZE attribute to every object accessed by the 
package must lie within a range which is dependent upon the FORM and whether constant or 
varying size records are being used. The exception USE-ERROR is raised if this constraint is violated. 


FORM 

constant/va tying 

OBJECT’SIZE (bits) 

SAM 

constant 

1 .. 16 384 

SAM 

varying 

1 .. 16 352 

SAM-PRINT 

varying 

1 .. 16 352 

ISAM 

constant 

1 .. 16 320 

ISAM 

varying 

1 .. 16 288 

ISAM-PRINT 

varying 

1 .. 16 288 

PAM 

constant/varying 

1 .. 16368 

EAM 

constant/varying 

1 .. 16368 

OMF 

constant 

16368 

SYSDTA 

varying 

1 .. 2 032 

SYSOUT 

varying 

1 .. 2 032 

SYSLST 

varying 

1 .. 2 032 


6 The default value in TEXT_IO for the FORM parameter is SAM.PRINT, in SEQUENTIA1_I0 it is SAM, 
wnile in DIRECT.IO it is ISAM. 

7 SAM and ISAM files with no null string for NAME are permanent files in that their lifetimes are 
independent of the currently running Ada program and of the BS2000 tasks m which they were 
created. Permanent files may be closed in one BS2000 task and opened subsequently in the same or 
another task without loss of their contents (for MODE = IN or IN.OUT). 

8 A null string for NAME specifies an external file that is not accessible after the completion of the 
main program (a temporary file). 

8 The BS2000 names for temporary files are 

'#ADA.xxxx.yymmdd.zzzzzz.nnnnn' with 

xxxx :: = decimal number (tsn of the current BS2000 task) 

yymmdd :: = decimal number (current date) 

zzzzzz :: = decimal number (time in seconds filled up with leading 0) 

nnnnn :: = decimal number (range 10000 .. 99999). 













Implementation-Dependent Characteristics 


10 When a SAM or ISAM file (selected by the value of NAME) is opened, there is no check that the form 
of the BS2000 file corresponds to the value of the FORM parameter of the OPEN procedure. There is 
no check either that the input-output package opening a SAM or ISAM file is the same package as 
the one which created the file. If either of these conditions is violated, the program may deliver 
unexpeaed results. 

11 PAM is the primary blockoriented access methoc of BS2000 to enable random access to blocks of 
2048 bytes. 

12 EAM is the access method to temporary files of BS2000. It enables ranaom access to blocks of 2048 
bytes. In SequentiaUO and Direct_lO these files are only accessable within one Ada-Program. A 
string for NAME is ignored. 

13 OMF is the access method to generate object modules. An OMF-files is a special form of an EAM-fiie. 

1* SYSDTA, SYSOUT and SYSLST files are temporary files whose lifetime ends with that of the BS2000 

task which created them. 

15 The SYSDTA, SYSOUT and SYSLST files are unique within a BS2000 task. SYSDTA and SYSOUT are 
ooened by the elaboration of TEXT.IO. SYSDTA is the FORM of the Ada STANDARD.INPUT file, while 
SYSOUT is the FORM of the Ada STANDARD.OUTPUT file. The user may open SYSDTA at most once 
at a time additionally to STANDARDJNPUT. Also only one file may be opened at a time with FORM 
parameter SYSLST. Opening a file with these FORM parameters causes a SYSFILE command for the 
BS2000 system. Therefore, reading from tne BS2000 system file SYSDTA is equivalent to reading 
from STANDARD-INPUT, but both have their own FCB. A close on a file with the FORM parameter 
SYSDTA or SYSLST causes a redireaion of the BS2000 system files SYSDTA and SYSLST to (PRIMARY) 
via a SYSFILE command. The user may redirea SYSDTA or SYSLST to (PRIMARY), too, by opening a 
file with the FORM parameter SYSDTA or SYSLST and NAME parameter (PRIMARY). A SYSOUT file 
may not be opened or deleted because its redirection is impossible and STANDARD-OUTPUT is 
opened with the FORM parameter SYSOUT during the elaboration 

No assumptions should be made about the way objects are stored in the various BS2000 files extent 
as described for the TEXT.IO package. For example, the mapping of indices onto ISAM keys may 
differ Detween different versions of the input-output packages. 


F.8.3.1 SEQUENTIALJO 


The value of the FORM parameter of the CREATE and OPEN procedures is restriaed to SAM, PAM. 
EAM and OMF. 

The package SEQUENTlAL-lO cannot be instantiated with unconstrained array types and 
unconstrained record types with discriminants that have no defaults. 


F.8.3.2 DIRECT 10 


The value of the FORM parameter of the CREATE and OPEN procedures is restriaed to ISAM, PAM. 
EAM and OMF. 









Implementation-Dependent Characteristics 


The package DIRECTJO cannot be instantiated with unconstrained array types and unconstrained 
record types with discriminants that have no defaults. 

The value of an index may be set in the range 1 .. INTEGER’LAST. 


F.8.3.3 TEXT 10 


The value of the FORM parameter of the CREATE procedure is restricted to SAM, ISAM, SAM-PRINT 
and ISAM-PRINT, while the OPEN procedure may use SYSLST and SYSDTA additionally. 

The lines contained in text files are variable in length in the range 1 .. 1980 chararters. The upper 
bound for the subtype FIELD is 500; 

The upper bound for the type COUNT is 1980. 

In printable files (FORM = SAM_PRINT, FORM = ISAM-PRINT) lines are stored in the second to 2001st 
character of a BS2000 variable length file record. The ASCII charaaers of the Ada program are 
represented by their corresponding EBCDIC characters in the BS2000 files. The first charaaer of the 
record is a printer control charaCTer where ' ‘ means line-feed and A’ page feed. Thus BS2000 files 
created by a call to TEXT-IO can be printed using the /PRINT command (with SPACE = E) or displayed 
using the EDOR and EDT text file editors. The printer control charaaers are used to implement the 
line and page terminators and can be manioulated using the standard line and page control 
procedures. The transfer of lines to BASICIO is done by NEW-LINE, NEW-PAGE , CLOSE and RESET - 
or if a line is filled up. 

An emcty line after a page terminator is identified by an EBCDIC.NUL in the second column. Other 
empty lines are identified by an EBCDIC.SOH in the first and a EBCDIC.BLANK m the second column. 
Since TEXT-IO converts ASCII.NUL to EBCDIC.NUL this special charaaer may not be used m the first 
column of the first line of a new page as the only charaaer m this line (that is the second column of 
the BS2000 file). 

Two FORM oarameters (SAM and ISAM) may be usee by TEXT_lO to suoport files without printer 
control charaaers m the first column. 

In these files the end of a line is mteroreted as a line terminator. A page terminafor is an 
EBCDIC.NUL in the last column of the line. Therefore the user may not outout an EBCDIC.N „ to the 
last column of a line without an incrementation of the current page by TEXT- 10 on reading the file 
again. An EBCDIC.STX in the first column designates an empty line. 

The MODE of the SYSLST file is restriaed to OUT-FILE. 

The MODE of the SYSDTA file is restriaed to IN-FlLE. 

The standard input file has the FORM SYSDTA and the standard output file has the FORM SYSOUT. 
In the dialogue mode of BS2000 a call of NEW-PAGE on STANDARD-OUTPUT causes the deletion of 
the screen and a call of NEW-LINE with an empty internal buffer causes the output of a line feed. 

The transfer of charaaers from TEXT_IO to BASIC-10 is done line by line. All charaaers are stored m 
an internal buffer. The line is displayed after calling PUT-LINE, NEW-LINE, NEW-PAGE, CLOSE and 
RESET. On the other hand the terminal represents the two distina files STANDARD-OUTPUT and 
STANDARD-INPUT in one 'file' (terminal). Therefore, a sequence of PUT - GET - PUT routine calls 
without calling NEW-LINE or NEW.PAGE causes the following display sequence at the terminal. 










Implementation-Dependent Characteristics 


11 Example: 

with TEXT.IO; use TEXT.IO; 
package DIALOGUE is 
begin 


PUT (STANDARD.OUTPUT,” THE USER AT THE TERMINAL IS '); 

GET (STANDARD.INPUT, USER. NAME); - the user enters 'TOM WHO IS NOT' 
PUT (STANDARD-OUTPUT, ' CRAZY'); 

NEW LINE (STANDARD.OUTPUT); 

end DIALOGUE; 


12 Example of the interaction (characters typed by the user are italicized): 

- the user has to enter something, assume he enters 'TOM WHO IS NOT' 

•TOM WHO IS NOT 

THE USER AT THE TERMINAL IS CRAZY 

13 The user intented to get: 

THE USER AT THE TERMINAL IS 

•TOM WHO IS NOT 

CRAZY 


The user should use in those cases a sequence of P'JT.LiNE - GET - P'J"^ - NEW LINE. Then the example 
would display: ^ 

THE USERATTHETERMINALIS 

•TOM WHO IS NOT 

CRAZY 


■5 


A text file read from a terminal (via SYSDTA) is handlea l.r.e a file with SAM, that means page 

terminators and empty lines are recognized by an EBCDIC..NUL or EBCDIC.5TX as oescnoec aoove for 
SAM files. 










APPENDIX C 


TEST PARAMETERS 


Certain tests in the ACVC make use imclementation-dependent values, such 
as the maxinum length oT an input line and invalid file names. A test that 
makes use of such values is identified by the extension .T5T in its file 
name. Actual values to be substituted are represented by names that begin 
with a dollar sign. A value must be substituted for each of these names 
before the test is run. The values used for this validation are given 
below. The use of the operator signifies a multiplication of the 
following character. The use of the character signifies concatenation 
of the preceeding and following strings. The values within single or 
double quotation marks are to highlight characters or string values^ 


tiding ini !9£jQiBS V£ly£ 

iACC.SIZE 22 

An integer literal whose value 
is the number of bits sufficient 
to hold any value of an access 
type. 

SBIG.ICl 239 « ’A’ I 

An identifier the size of the 
maximum input line length which 
is identical to SEIG.IDZ except 
for the last character. 

SBIG.ID2 239 * ’A’ I ’2’ 

An identifier the size of the 
maximum input line length which 
is identical to IBIG.IDl except 
for the last character. 

IBIG.ID3 120 * ’A’ I ’3’ S 11? * ’A’ 

An identifier the size of the 
maximum input line length which 
is identical to IBIG.IDA except 
for a character near the middle. 









TEST PARAMETERS 


(liBfi and Ssaaina 

•BIG.ID4 120 * ’A’ 

An identifier the size of the 
naximum input line length which 
is identical to iBIG_lD3 except 
for a character near the middle. 


■4’ & 119 * ’A’ 


IBIG.INT.LIT 237 * ’0’ & "298" 

An integer literal of value 298 
with enough leading zeroes so 
that it is the size of the 
maximum I ine length. 


<BIG.REAL.LIT 235 * ’0’ S "690.C" 

A universal real literal of 
value 690.0 with enough leading 
zeroes to be the size of the 
maximum 1ine length. 

ABIG.STRINGl & 120 * ’A’ & 

A string literal which when 
catenated with BIG_5TRING2 
yields the image of BIG.IDl. 


<SIG.STRING2 ”” & 119 * ’A’ I 'V I 

A string literal whicn when 
catenated to the end of 
BIG STRINGl yields the image of 
BIG.IDl. 


$ BLANKS 

A sequence of blanks twenty 
characters less than the size 
of the maximum line length. 


220 


$COUNT_LA5T 1950 

A universal integer 

literal whose value is 
TEXT IC.COUNT’LAST. 


♦DEFAULT.MEM.SIZE 4_000_000 

An integer literal whose value 
is SYSTEM.HEHORY.SIZE. 


$DEFAULT_STOR.UNIT 8 

An integer literal whose value 
is SYSTEM.STORAGE.UNIT. 


C-2 











TEST PARAMETERS 


. tjSBfi (IfiiDlnS 

lOEFAULT.SYS.NAME 

The value of the constant 
SYSTEM.SYSTEM.NAME. 

ADELTA.DOC 

A real literal whose value is 
SYSTEM,FINE.DELTA. 

$FIELD.LAST 

A universal integer 

literal whose value is 
TEXT.IO.FIELD’LAST. 

AFIXED.NAME 

The name of a predefined 
fixed-point type other than 
DURATION. 

*FLOAT_NAH£ 

The name of a predefined 
floating-point type other than 
FLOAT, SHORT.FLOAT, or 

LONG.FLOAT. 

$GREATER.THAN.DURATION 

A universal real literal that 
lies between DURATION’BASE’LAST 
and DURATION’LAST or any value 
in the range of DURATION. 

$GREATER.THAN.DURATION_BASE_LAST 
A universal real literal tna; is 
greater than DURATION’BASE’LAST. 

IHIGH.PRIORITY 

An integer literal whose value 
is the upper bound of the range 
for the subtype SYSTEM.PRIORITY. 

«ILLEGAL.EXTERNAL_FILE.NAM£1 

An external file name wnich 
contains invalid characters, 

♦ILLEGAL_EXTERNAL.FILE_NAHE2 

An external file name which 
is too long. 

AINTEGER.FIRST 

A universal integer literal 
whose value is INTEGER'FIRST. 


BS2000 

2.0**(-3l) 

500 

NQ.SUCH.FLOAT.NAME 

NO_SUCH.FLOAT.NAME 

131071,5 

200000.0 

0 

BAD.FILE.NAME 

MUCH-TOO-LONG-NAHE-FOR-A-CORRECT- 

BSZOOO-FILE 

-21A7463648 









TEST PARAMETERS 


Nm Slid Kfijoiss 


IINTEGER.LAST 

A universal integer literal 
whose value is INTEGER’LAST. 

2147483647 

*INTEG£R_LAST_PLUS_1 

A universal integer literal 
whose value is INTEGER’LAST + 1. 

2147483648 

$less.than.duration 

A universal real literal that 
lies between DURATION’BASE’FIRST 
and DURATION’FIRST or any value 
in the range oF DURATION. 

-131071.5 

$LESS_THAN.DURATION.BASE_FIRST 

A universal real literal that is 
less than DURATION’BASE’FIRST. 

-200000.0 

$LOU.PRIORITY 

An integer literal whose value 
is the lower bound of the range 
for the subtype SYSTEM.PRIORITY. 

0 

$NANTIS3A.D0C 

An integer literal whose value 
is SYSTEM.MAX.MANTISSA. 

31 

JMAX.DIGITS 

Maximum digits supported for 
floating-point types. 

15 

VMAX.IN.LEN 

Maximum input line length 

permitted by the implementation. 

240 

SMAX.INT 

A universal integer literal 

whose value is SYSTE.M .MAX.INT. 

21^74636^7 

^HAX.INT.PL'JS.l 

A universal integer literal 

whose value is SYSTEM.HAX.INT^l. 

21474S2648 

$HAX_L£N.INT_BASED.LITERAL 

A universal integer based 

1 iteral whose value is ZhllS 
with enough leading zeroes in 
the mantissa to be MAX.IN.LEN 
long. 

"2:" & 235 » ’0’ & "11:" 

' C 

-4 













TEST PARAMETERS 


(!dll£ £Cd HfiAOlOa 

IMAX.LEN.REAL.BASED.LITERAL 

A universal real based literal 
whose value is 16:F.E: with 
enough leading zeroes in the 
nantissa to be MAX_IN_LEN long. 

$MAX.STRING_LITERAL 

A string literal ot size 
HAX_1N_L£N, including the quote 
characters. 

SNIN.INT 

A universal integer literal 
whose value is SYSTEM.HIN_INT. 

$MIN,TASK.SIZE 

An integer literal whose value 
is the number oT bits required 
to hold a task object which has 
no entries, no declarations, and 
"NULL:" as the only statement in 
its body. 

INAME 

A name ot a predeTined numeric 
type other than FLOAT, INTEGER, 
SHORT FLOAT, SHORT INTEGER, 
LONG.FLOAT, or LONG.INTEGER. 

$name_l:5t 

A list o-f enumeration literals 
in t.re type SYSTEM.NAME, 

separated by commas. 

SNEG.BASED.INT 

A baseo integer litera! wnose 
highest oraer nonzero bit 

•falls in the sign bit 
position of the representation 

for SYSTEM.MAX.INT. 

INEU.ME.M.SIZE 

An integer literal whose value 
is a permitted argument for 

pragma MEMORY SIZE, other than 
$DEFAULT_MEH.SIZE. If there is 
no other value, then use 
$DEFAULT_MEH_SIZE. 


C 


Uiilt 

"16:" I 233 * ’0’ I "F.E:" 

i 118 * ’A’ I 

-2147483648 

32 

LONG.LONG.INTEGER 

BS2000 

8«3777'777776lf 

4 000.000 









TEST PARAMETERS 


tj»£ iOd (SfijQlQS 
•NEW.STOR.UNIT 

An integer literal whose value 
is a permitted argument for 
pragma STORAGE.UNI7, other than 
♦DEFAULT.STOR.UNIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGE.UNIT. 

INEU.SYS.NAHE 

A value of the type SYSTEM.NAME, 
other than ADEFAULT.SYS.NAHE. If 
there is only one value of that 
type, then use that value. 

ATASK.SIZE 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
a single entry with one MN OUT’ 
parameter. 

♦ TICK 

A real literal whose value is 
SYSTEM.TICK. 


Ulilt 

8 


BS2000 


32 


0.0001 


C-6 





APPENDIX D 


WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to the 
Ada Standard. The following 43 tests had been withdrawn at the time of 
validation testing for the reasons indicated. A reference of the form 
Al-ddddd is to an Ada Commentary. 


a. E28005C This test expects that the string TOP OF PAGE. --63" 
of line 204 will appear at the too of the listing page due to a 
pragma PAGE in line 203; but line 203 contains text that follows 
the pragma, and it is this that must appear at the top of the 
page. 

b. A39005G This test unreasonably expects a component clause to pack 
an array component into a minimum si:e (line 30). 

c. B97102E This test contains an unitended illegality: a select 
statement contains a null statement at the place of a selective 
wait a 1ternat i ve (line 31). 

d. BC3009B This test wrongly expects that circular instantiations 
will be detected in several compilation units even thougn none of 
the units is illegal with re- scect to the units it depends on; by 
AI-00256, the illegality need not be detected until execution is 
attempted (line 95). 

e. CD2A62D This test wrongly requires that an array object’s size be 
no greater than 10 although its subtvpe’s size was specified to be 
40 (line 137). 

f. CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D C16 tests] These 
tests wrongly attempt to check the size of objects of a derived 
type (for which a ’SIZE length clause is given) by passing them to 
a derived sub- program (which implicitly converts them to the 
parent type (Ada standard 3.4:14)). Additionally, they use the 
’SIZE length clause and attribute, whose interpretation is 
considered problematic by the UG9 ARG. 


X- 


0-1 










WITHDRAWN TESTS 


g. CD2A61G. C02A83G, CD2A84N I M, i CD50110 [5 tests] These tests 

assuae that dependent tasks will terminate while the main pro¬ 
gram executes a loop that simply tests for task termination; this 
is not the case, and the main program may loop indefinitely (lines 
74, 85, 86 8 96, 66 & 96, and 56, resp.). 

h. CD2B15C i CD7205C These tests expect that a 'STORAGE.SIZE length 
clause provides precise con- trol over the number of designated 
objects in a collection; the Ada standard 13.2:15 allows that such 
control must not be expected. 

i. C02D11B This test gives a SMALL representation clause for a 
derived fixed-point type (at line 30) that defines a set of model 
numbers that are not necessarily represented in the parent type; 
by Commentary AI-00099, all model numbers of a derived fixed-point 
type must be representable values of tne parent type. 

j. CD5007B This test wrongly expects an implicitly declared 
subprogram to be at the the address that is specified for an 
unrelated subprogram (line 303). 

k. ED7004B, ED7005C & D, ED7006C & D [5 tests] These tests check 
various aspects of the use of the three SYSTEM pragmas; the AVO 
withdraws these tests as being inappropriate for validation. 

l. CD7105A This test requires that successive calls to CALENDAR.CLOCK 
change by at least SYSTEM.TICK; however, by Commentary AI-00201, 
it is only the expected frequency of change that must be at least 
SYSTEM.TICK--particular instances of change may be less (line 29). 

m. CD7203B, S CD7204B These tests use the 'SIZE length clause and 
attribute, whose interpretation is consice-ss protlematic by the 
UG9 ARG. 

n. CD7205D This test checks an invalid test objective: it treats the 
specification of storage to be reserved fo" a task's activation as 
tnough it were like the soeci t ication o- storage for a co'iect'cn. 

0 . CE2107I This test requires that orjects of two similar scalar 

types be distinguished wnen reao from a f i 1 e--DAT A_ERROR '.s 
expected to be raised by an attempt to read one object as of tne 
other type. However, it is not clear exactly how tne Ada standard 
14.2.4:4 is to be interpreted; thus, tnis test objective is not 
cons idered valid, (line 90) 

p. CE3111C This test requires certain behavior, when two files are 
associated with the same external file, that is not required by 
the Ada standard. 


D-2 





WITHDRAWN TESTS 


q. CE3301A This test contains several calls to EN0_0F_LINE S> 

END_OF_PAGE that have no parameter: these calls were intended to 
specify a file, not to refer to STANDARD.INPUT (lines 103, 107, 

llfi, 132, & 13S). 

r. CE3411B This test requires that a text file’s colunn number be set 
to COUNT’LAST in order to check that LAYOUT.ERROR is raised by a 
subsequent PUT operation. But the former operation will generally 
raise an exception due to a lack of available disk space, and the 
test would thus encumber validation testing. 


D-3 











AVf Control Number: IA6G-VSR-025 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 89030611.1D059 
Siemens AG 

Siemens BS2000 Ada Compiler V2.0 
Siemens 7.590G Host and Target 


Completion of On-Site Testing: 
6th March 1989 


Prepared By: 
lABG mbH, Abt SZT 
Einsteinstr 20 
0-8012 Ottobrunn 
West Germany 


Prepared For: 

Ada Joint Program Off ice 
United States Department of Defense 
Washington DC 20301-3081 


APPENDIX E 

COMPILER AND LINKER OPTIONS 






COMOPT Festlegen derCompileroptionen 


Mit der COMOPT-Anweisung konnen fur eine Ada-Bibliothek Compileroptionen 
festgelegt werden. Beim Einrichten einer Bibliothek werden gewisse Standard- 
werte eingestellt, die dann mit der COMOPT-Anweisung modifiziert werden 
konnen. Alle Parameter dieser Anweisung konnen auch bei der COMPILE- und 
UPDATE-Anweisung verwendet werden, sie gelten dann aber nur fur die Dauer 
ae.'' Ubersetzung. D<e COMOPT-Anwetsung verandert nur die Voreinsrellungen, 
die explizit genannt werden. Werden kerne COMOPT-Parameter angegeben, so 
werden die aKtuellen Werte am Bildschirm angeiaigt. 

Seim Einrichten e:ner Bibiiothek geiten folgende Voreinsteilungen; 


ADDSOURCE 

DEBUG 

KEEPXRE= 

LISTMODE 

OPTIMIZE 

RUNMODE 


YES 

NO 

NO 

(NOOBJECT,NOOPTIONS, 
SOURCE.NOSTORAGE,NOXREr^) 
NO 

BATCH 


comopt-cmd = 

COMOPT [comopt-param{,comopt-par6m}] ; 


comcot-oaram :: = 


A[DDSOURCE] 

DiEBUC-I 


< 


=X.RE = 


! c r ^ r * 




X., . • I y 1 ^ ^ .. 


= ye£-or_no 
= ceougmoce 
= yes_or_,-;c 
= ''stmcc:e{,,.'£trr,oce'- 
= /es-0'--rz 
~ "w n rn.Gc " 


aeougm.oce : = 

N(0] 1 R[ESTRiCTEDj i F[ULLi 
listmode :: = 


OBJ(ECT] 

OPTIIONS] 

SIOURCE] 

STIORAGE] 

X[REF] 


NOOBJ(ECT] 

NOOPT[IONS] 

NOS[OURCE] 

NOSTIORAGE] 

NOX[REF] 


runmode ;;= B^ATCH] | D[1AL0GUE] 










tit 

fit 


ADDSOURCE Dieser Parameter aktiviert ode*' deaktiviert die Quelltextver- 
waltung bei fehlerfreien Ubersetrungen. 

= YES Der (fehlerfreie) Quelltext und das Compilerlisting werden 

unter der Ada-Einheit verwaltet. Das Ouellfragment bleibt 
unverandert in der Bibliothek. Die Ouelltext-Verwaltung ist 
nur aktiv, wenn ein Ouellfragment genau eine Ada-Uberset- 
zungseinheit enthalt und der Name des Fragments mit dem 
Namen dieser Ubersetzungsemheit ubereinstimmt; andern- 
falls wird die Quelltextverwaltung automatisch deaktiviert. 

= NO Die Ouelltextver^altung ist nicht aktiv; das Compilerlisting 

und die Ouelle emer Ada-Einhe;i smd nur ais Fragmente ver- 
fugbar. 


DEBUG Gibt an, mit weichen Debugger-Anweisungen die ubersetzte 

Einheit getestet werden kann. 

= NO Die Ubersetzungseinheit kann mcnt mit dem Debugger ge¬ 

testet werden. 

= RESTRICTED Es ist nur "passives" Testen durch den Debugger mdglich, d.h. 

es konnen wohl Haitepunkte gesetzt una Variabienwerte 
ausgeben werden, es ist aber nicnt zugeiassen, den inhalt der 
Vanabien zu verandern. 

= FULL Alle Debugger-Anweisungen werden unterstutzt. Der Modus 

ist nur mit OPTIMIZE = NO kompatibel. 


=XRE= 

= YES Es wire information m der 3iDiiotrie.< abgeiect, die das Erste!- 

ien eme’’ ciocaien Oue’'ve''we'S.iste ermcglicnt. 

= 'jC Es '/'/iro ke'^-e 'n-cmafc^ e'" Due'^vei'weisiisting aoce- 


De*;r::em OS"' oes emeucte'' Comone'nsf.ncs Es 

v3''r', gesteur" .ve^oe'^. oo oa'"" r'^ma se"' soiie'' 

- ae--Oue'lte.xt SOURCE; 

- de" Obieccoce ;CB:EC~i 

- cas SDe;cr.e'’aDDMC ce-" var;5o e-' 'S~ORAGE) 

- die Ouerverweisiiste vXREF} 

- die Compiieroptionen (OPTIONS) 

Das erzeugte Listing enthalt be: einer fehlerhaften Uber- 
setzung immer den Queiltext mit den Fehiermeldungen. 

OPTIMIZE 

= YES Es wird eine Optimierung zum Eiiminieren von unndtigen 

Laufzeit-Checks eingeschaltet. Diese Optimierung ist nicht 
vertraglich mit der Debuggeroption DEBUG = FULL. 

Es wirdlceine Optimierung durchgefuhrt. 


NO 








LINKOPT Festlegen der Binderoptionen 


Mit der LINKOPT-Anweisung konnen fur die ArbeiTsoibiioThek die Binderoptio¬ 
nen festgeiegt werden. Beim Einrichten der Bibiiothek werden gewisse Stan- 
dardwerte eingestellt, die dann mit der LINKOPT-Anweisung modifiziert werden 
konnen. Alle Parameter dieser Anweisung konnen aucn bei der LINK-Anweisung 
verwendet werden, sie gelten dann aber nur fur oie Oauer aes Bmcens. Die 
LINKOPT-Anweisung verandert nur die Voremsteilungen, oie expiizit genannt 
wurden. Wercen keme Parameter angegeben, so we'^aen die aktue'len Werte 
am Bildschirm angezeigt. 

Das Binder-Listing wire standardma3ic in die Datei LL..ma/n_orocram, cie e*’- 
zeucte Phase m die Date* GO ma/n-orogram gesenr^eoen. De'' Name ma/r_orc- 
gram leitet sicn aus cem Namen .ma/n_jnitname ces -iauotorogramms ac. Be' 
oer Transformation aes Namens wire cer Unterstr:c.n curen emen Bmdest'icn e''- 
setzt. Namen mit mehr als 35 Zeichen werden aogescnnuten. 

Der Parameter RUNMODE legt fest, ob das Bmeen im Diaiog oee'" ais Batcn-^^-c- 
zeB durchcefuhrt wire. Im Fall RUNMODE = DIALOGUE wire cas Aca-3incen im 
Dialog durc.ngefuhrt, und die Steueranweisungen an cen BSBOOO-Bincer we''den 
m eie BSZOOO-Datei LK-.m/a/n-program geschneoen De’’ BSZOOO-Bmee'' kann 
schiieBend im NebenorozeB Oder nacn Beencen cer Aca-^'ocrammierum 
bung mit ".'DO LK.main_program'' aufeerufen we''den. m ycreingesteilten 
RUNMODE = BATCH we.'den cas Ada-Bincen unc cas BSZCCC-Bmee.n zusamme'' 
im Baten-PrezeB durchgefuhr. 


StandardmaBig giit: 

DEBUG 
INS I RFILE 
L:ST=:LE 
..STMOD 

F E 5 C - « E : 

^ ‘ ’w' 

'< •; 


;.iNKOPT i iinKopt-param {uinKopt-oara.m}^ , 

linkoDt-oaram :; = 

D(E3UG] = deougmoce I 

1NSTRF[ILE] = instrfiie I 

LI5TF[1LE] = listfile 1 

LISTM[pDE] = (link_listmode {,link_list;.iode}) I 

PHASE[F1LE] = phasefile I 


= NO 

= (DE=AULT} 

= (DEFAULT; 

E = (NOE-A5. NOMA? NCC = ~ C\S. \0'SC = ~ 
NOUN1T5, NCXRE=' 

E = :de=-ul“: 

= 'NOr^E, 


<0 CJIlL 












RESOLVEILIB] = resolvelib 


RUN[MODE] 

runmode 

XS 

= 

yes_or_no 

debugmode 

: = N(01 1 

R[ESTRICTED] 1 1 

instrfile 

:= filename ; (DEFAULT) 

linkJistmode 

: = 


E.'L.-3! 


i noe:la3! 

iVl[AP] 


1 NCM[AP] 

OP^liONSj 

1 NOOPT[lONS] 

SiORTi 


1 NCS[ORT] 

U[NITS] 


1 NOU[NrS] 

X[RE=] 


i NOX[REFj 

'istfiie = 

filename 

(DE.^AULT) 

onasefile :: = 

filenam.e 

.(DE=AUL- 

resoivelib :: = 

filename 

(NONE; 

runmoce :: = 

3[ATC-; 

Dfiv-'t-CGcr, 



= -.ES.~-C.ED Ei wtra nur ocss.ves "esten e^auc; a^ic" /'/e'^n a'nzeTie 
Uberseizungseinneiien nnit DEBUG = F jL- uoersctr: wurcen). 

= FULL Der besm Ubersetzen angecebene Testmodus wird von den 

Ubersetzungseinheiten ubernommen (d.h. eine Uberset- 
zungseinheit. die rnit DEBUG = FULL ubersetzt wurde, kann 
auch aktiv getestet werden; eine Ubersetzungsemheit, die 
mit DEBUG = RESTRICTED ubersetzt wurde, kann nur passiv 
getestet werden; Ubersetzungseinheiten mit DEBUG = NO 
kdnnen uberhaupt nicht getesiet werden). 


INSTRFILE 


Dieser Parameter legt den Namen der Ausgabedatei fest, in 
der die Anweisungen fur den BS200C-Binder abgelegt wer¬ 
den. In Abhangigkeit vom Parameter DUNMODE = wird ent- 


















I n 

ttj 


weder eine BS2000-DO-Pro2eaur oder eine BS2000-Enter- 
Prozedur erzeugt. 

= filename Die Binderanweisungen werden in der Datei filename abge- 
legt. 

= (DEFAULT) Die Binderanweisungen werden in der Datei LK.ma/n.pro- 
gram abgelegt. 


LISTFILE Legt die Ausgabedatei fest, in der das Listing abgelegt wer¬ 

den soli. 

= filename Das 3:nce'':ist;ng /virc .n ce’'Date:'i'ename abce'egt. 

= (DEFAULT) Das 3inaeriist:nc a rc ce" Date: -L..'na/,n_orogram aoge- 
legt. 

L'STMODE = Legt den Umfang ces e'^ze'jgte'' Bince’-iistings fest. Bei den 
fcicencen Ootionen ernalt man :m Bincenisting; 

- E_A3: c:e E'aoorat.'onsre'henfoige, 

- MAP; cie Programmubersicnt oes BSZOOO-Binde'-s, 

CPT. cie Bincerootionen, 

- SORT' Gie aipnabetisch scrtierte Liste ce'’ P-ogramm- 

aoscnnitte, 

- XREF; die DuerverA/eisiiste ces BSZCCO-Bincers, 

- UNITS; ein Verzeichnis oiler E:nne;ten ,,n der HuiJe, 


^HASE-iLE Legt den Namen der Datei fest. n cie c®’’ Bmce’’ das gebun- 

cene P^ogramm scnreiben scii st oe'^eits em.e Date' mit die- 
sem Namien vomancen, so wro mesa vcrne’' ce’cscnt. 



CuLE_. 3 <enr,;e:cnnet c:e Co'e<t.m,cc-:b.oi.c:ne< m,: cen in ance- 

ren -’■ogram.'^ie.'-soracnen cescn.-:eoenen ^.•'.te'' 0 'ogrammen. 

= filename Die Objektmodulbibliothek hat cen Namen filename. 

= (NONE) Es wird kerne weitere Obiektmodulbibliothe.k verwendet. 


RUNMODE Legt fest, ob das Binden im Dialog oder ais Batch-ProzeB 

durchgefuhrt wird. 

= BATCH Das Ada-Binden und das BS2000-Binden werden zusammen 

als Batch-ProzeB durchgefuhrt. 

= DIALOGUE In diesem Fall wird das Ada-Binden im Dialog durchgefuhrt, 
und die Steueranweisungen an den BS2000-Binder werden in 









die BS2000-Datei LK.ma/n>program geschrieben. Der BS2000- 
Binder kann anschlieSend im NebenprozeQ mit "/DO 
LK.ma/n-program" aufgerufen werden. 


Definiert, in welcher Betriebssystemversion das Programm 
ablaufen soil. 

Es soil in einer XS-fahigen Version abiaufen. 

Es soil in der 24-Bit-Version von BS2000 ablaufen. 











