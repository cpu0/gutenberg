REPORT DOC 

AD-A262 923 


MENTATION PAGE Xr" fSJ 

im«l«d fO 1 hou' par ra•pO(^M ifiCiutfiog <rv> (>rn« kv rayvawnnf; if«!r^ont aaa^C^ rvjj •S:»’ Ag S*‘« *W‘C#» gat'**' AJJ 

n o> irtlorpnalton Sand oommanu fagaAj ng fh»» bwrdar' aai»m«j# mr>Tf oina* aapaci o’ aoi>aciK>' o* 

k«f1ar» Sarvica Dirado^ala to/ in(onnatK>r Oparattont ard ^pons i?i5 Ja’tanaon Daw* H.$*^»*af SH-5#'?Oi v* 

Atta>ni Ottioa of Maragan^ent and 8tX)ga' Wa*n.ng;on DC 2Q5C3 


12 REPORT 


3 REPORT TYPE AND DATES 

Final: 18 Dec 92 


4 TITLE AND 

Validation Summary Report. TeleSoft, TeleGen2 Ada Cross Development 
System for Sun-4 to i960, Version 4.1.1. Sun-4/e>0 Workstation (Host) to 
Cyclone CVME962 System (Target), 92121811.11303 


I 5 I UNDiNG 


lABG-AVF 

Ottobrunn, Federal Republic of Germany 


7 PERFORMING ORGANIZATION NAME(S) AND 

IABG-AVF, Industrieanlagen-Betriebsgeselschaft 
Dept. SZT/ Einsteinstrasse 20 
D-8012 Ottobrunn 

FEDERAL REPUBLIC OF GERMANY 


9. SPONSORINGTi40NITORING AGENCY NAME(S) AND 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm 3E114 
Washington. D.C. 20301-3081 


bal 


8 PERFORMING 
ORGANIZATION 

lABG-VSR 112 


10 SPONSORlNG'MONlTORlNG 
AGENCY 



12a DISTRIBUTION/AVAILABILITY 

Approved for public release; distribution unlimited. 


13 (Maximum 200 

TeleSoft. TeleGen2 Ada Cross Development System for Sun-4 to i960. Version 4.1.1, Sun-4/690 Workstation 
(Host) to Cyclone CVME962 System (Target), ACVC 1.11. 



93-06536 


98 3 30 074 


14 SUBJECT 


15, NUMBER OF 


Ada programming language, Ada Compiler Val. Summary Report, Ada (Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, I 


17, security 
CLASSIFICATION 

UNCLASSIFIED 


18 SECURITY 


UNCLASSIFED 


19. SECURITY 
CLASSIFICATION 

UNCLASSIFIED 


20 LIMITATION OF 


NSN 


Standard Form 298, (Rev 2 89) 
Prescribed by ANSI Sid 



















Cartificat* Information 


The following Ada implementation was tested and determined to pass AC"»C 
1.11. Testing was completed on December 18, 1992. 


Conpilar Kama and Varaion: TalaGanl^ Ada Croaa Oavalopmant Syatam 

Cor Sun-4 to i9fi0, Varaion 4.1.1 

Boat Computar Syatam: Sun Microayatama Sun'4/690 

uodar SunOS Ralaaaa 4.1.3 

Targat Computar Syatam: Cyclona CVMBSSS Syatam (i960XA Board 

with MC Procaaaor Bara Machinal 


See Section 3.1 for any additional information about the testing environment. 

As a result of this validation effort. Validation Certificate 92121811.113C3 i 
awarded to TeleSoft. This certificate expires 24 months after ANSI acproval c 
ANSI/MIL-STD-1015B. 



QtSa Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 

mir 











AVF Control Number-, lABG 
Cecember 


Xd* COKPXLKR 

VALIDATION SDIOIARY REPORT: 
Cartificat* Nvosbar: 92121811.11303 
TalaSoft 

T«l«G*n2^ Ada Croaa Davalopmant Syatam 
for Sun-4 to i9€0, Varaion 4.1.1 
Sun-4/690 Morkatation Boat 
Cyclona CVMB962 Syatam Targat 
(1960XA Board with MC Procaaaor Bara Machina) 


Prepared By: 
lABG mbH, Abt. ITE 
Einsteinstr. 20 
W-e012 Ottobruim 
Germany 





Cartificat* Xnformatloa 


The following Ada implementation was tested and determined to pass AO/C 
1.11. Testing was completed on December 10, 1992. 


Cosqpllar NasM and Varslon: TalaGan2^ Ada Cross Davalopmant System 

for Sun-4 to i960. Version 4.1.1 

Bost Computer System: Sun Microsystems Sun-4/690 

under SunOS Release 4.1.3 

Target Computer System: Cyclone CVKB962 System {i960XA Board 

with MC Processor Bare Machine) 


See Section 3.1 for any additional information about the testing environment. 

As a result of this validation effort. Validation Certificate ?212ieil.113C3 is 
awarded to TeleSoft. This certificate expires 24 months after ANSI approval of 
ANSI/MIL-STD-1815B. 


This report has been reviewed and is approved. 




lABG, Abt. ITE 
Michael Tonndorf 
Einsteinstr. 20 
W-8012 Ottobrunn 
Germany 


Ada Validation Organization 
Director, Computer 6 Softwa r4 Engineering Division 
Institute for Defense Ana>^ les 
Alexandria VA 22311 



Ada Joint Program Office 
Dr. John So^r^ond, Director 
Department^^f Defense 
Washington DC 20301 





Declaration Of Conformance 


Customer: 

Certificate Awardee: 

Ada Validation Facility: 

ACVC Version: 

Ada Implementation 

Ada Compiler Name and Version: 

Host Computer System: 

Target Computer System: 


TeleSoft 

5959 Cornerstone Court West 
San Diego, CA USA 92121 

TeleSoft 

(ABG, Dept. ITE 
W-8012 Ottobrunn 
Germany 

1,11 


Te!eGen2™ Ada Cross Development 
System for Sun-4 to i960. 

Version 4.1.1 

Sun Microsystems Sun-4/690 
SunOS Release 4.1.2 

CVME962 System 

(i960XA Board with MC Processor Bare) 


Declaration: 

I the undersigned, declare that I have no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STD-1815A, 
ISO 8652-1987, FIPS 119 as tested in this validation and documented 

Report. 


Date:_ Lijf^ ^ 


V. P., General Counsel 


in the Vatidatkan Summary 



Ra^nTonS'ATPirra 

TeleSoft 





TABLE OF CONTEOTS 

CHAPTER 1 INTRODUCTION 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM AND LINKER OPTIONS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 















CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro92] against the Ada Standard [Ada83] using the 
current Ada Compiler Validation Capability {ACVO . This Validation Summai"/ 
Report (VSR) gives an account of the testing of this Ada implementation. 

For any technical terms used in this report, the reader is referred to 
[Pro92] . A detailed description of the ACVC may be found in the current 
ACVC User's Gui^^s [UG89] . 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this repc 
In the United States, this is provided in accordance with the "Freedom c 
Information Act" (S U.S.C. #552). The results of this validation apply 
only to the computers, operating systems, and compiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warramt that all statements set forth in this report are 
accurate aind complete, or that the subject implementation has no 
nonconformities to the Ada Standard other thaui those presented. Copies of 
this report are available to the public from the AVT which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results should be 
directed to the AVF which^ performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1001 North Beauregard Street 
Alexandria VA 22311 


1-1 


M 





1.2 REFERENCES 


[Ada83] Reference Manual for the Ada Programming Language , 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-198’’. 

[Pro92] Ada Compiler Validation Procedures . Version 3.1, Ada Joint 
Program Office, August 1992. 

[UG89] Ada Coiroiler Validation Capability User's Guide , 21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the AC/C. The AC.’C 
contains a collection of test programs structured into six test classes: 

A, B, C, D, E, and L. The first letter of a test name identifies the class 
to which it belongs. Class A, C, D, and E tests are executable. Class B 
and class L tests are expected to produce errors at compile time auid link 
time, respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and S?PRTi3, 
and the procedure CHECK_FILE are used for this purpose. The package REPORT 
also provides a set of identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time., and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values -- for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 




INTRCDUCTION 


For each Ada implementation, a customized test suite is produced by the 
AVF. This customization consists of making the modifications described 
in the preceding paragraph, removing withdrawn tests (see section 2 .;,. and, 
possibly some inapplicable tests (see Section 2.2 and [UG89’;. 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 

Ada Compiler The software amd any needed hardware that have to be added 
to a given host amd target computer system to allow 
transformation of Ada programs into executaible form, and 
execution thereof. 

Ada Compiler The means for testing compliance of Ada implementations, 
Validation consisting of the test suite, the support programs, the AC.'C 

Capability user's guide and the template for the validation summary 

(ACVC) report. 

Ada An Ada compiler with its host computer system and its 

Implementation target computer 'system, 

Ada Joint The part of the certification body which provides policy and 

Program guidance for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification body which carries out the 

Validation procedures required to establish the compliance of an Ada 
Facility (AVF) implementation. 

Ada The part of the certification body that provides technical 

Validation guidance for operations of the Ada certification system.. 

Organization 
(AVO) 

Compliance of The ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer A functional unit, consisting of one or more computers and 

System associated, software, that uses common storage for all or 

part of a ,program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 





Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 

ISO 

Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


Fulfillment by a product, process or sejrv'ice of all 
requirements specified. 

An individual or corporate entity who enters into an 
agreement with an AVF which specifies the terms and 
conditions for AVF services {of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source programs are transformed 
into executeible form. 

A test that contains one or more test ob 3 ectives found to be 
irrelevant for the given Ada implementation. 

International Organization for Standardization. 

Software that controls “he execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial 
or complete hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro92]. 

The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity- 
testing. A test may be incorrect because it has am invalid 
test objective, fails to meet its test objective, or 
contains eyrroneous or illegal use of the Ada programming 
language.- 




CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 


The following tests have 

been withdrawn 

by the AVO 

The rati 

onale for 

withdrawing each 

test is 

available from 

either the 

AVO or the 

AVF. The 

publication date 

for this 

list of withdrawn tests 

is 02 Augus 

t 1991. 

E2800SC 

B28006C 

C32203A 

C34006D 

C35508I 

C35SC8J 

CSSSOSM 

C35508N 

C3S702A 

C35702B 

B4i30aB 

C43C04A 

C45114A 

C45348A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B6 3 C 2 ^ 

B83022H 

B83025B 

B83025D 

C83026A 

B83026B 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC12263 

BC3009B 

BD1B02B 

BD1B06A 

ADlBOeA 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A4iA 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4 024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD700SE 

AD7006A 

CD7006E 

AD7201A 

AD720iE 

CD72043 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE311SA 

CE3118A 

CE3411B 

CE3412B 

CE36C~B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 



2.2 INAPPLICABLE TESTS 


A test is inappliceUsle if. it contains test objectives which are irrelevant 
for a given Ada implementation. Reasons for a test's inapplicability may be 
supported by documents issued by the ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 




IMPLEMEriTATION DEPEXCENCIES 


The following 159 tests have floating-point type declarations requirin'- 
digits than SYSTEM.MAX_DIGITS; 


C241130..Y (11 tests) 
C357060..Y (11 tests) 
C3S708O..Y (11 tests) 
C452410..Y (11 tests) 
C454210..Y (11 tests) 
C45S240..2 (12 tests) 
C456410..Y (11 tests) 


C35705O..Y (11 tests) 
C35707C..Y (11 tests) 
C35802O..2 (12 tests) 
C453210..Y (11 tests) 
C4S521C..2 (12 tests) 
C456210..2 (12 tests) 
C46012O..2 (12 tests) 


mere 


The following 20 tests chec)c for the predefined type LONG_INTEGERfor this 
implementation, there is no such type: 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C4S502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45613C 

C45614C 

C45631C 

C45632C 

BS2004D 

C55B07A 

B55B09C 

B86001W 

C86006C 

cr;7ioiF 


C35713B, C45423B, B86001T, and C86006H chec)c for the predefined type 
SHCRT_FLOAT; for this implementation, there is no such type. 

C45531M..P (4 tests) and C45332M..P (4 tests' chec)c fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater,- for this 
implementation, MAX_MANTISBA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLOWS is FALSE for floating point types; for this 
implementation, MACHINE_OVERFLOWS is TRUE. 

B86001Y checks for a predefined fixed-point type other than DUR?.TI0N; for 
this implementation, there is no such type. 

CA2009C and CA2009F check whether a generic unit can be instantiated 
before its body (and any of its subunits) is compiled; this 

implementation creates a dependence on generic units as allowed by 
AI-00408 and AI-00506 such that the compilation of the generic unit 
bodies makes the instantiating units obsolete. (See section 2.3.) 

CD1009C uses a representation clause specifying a non-default sire for a 
floating-point type; this implementation does not support such sizes. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use representation 
clauses specifying non-default sizes for access types; this implementation 
does not support such siz^s. 

AE2101H, EE2401D, and EE2401G use instantiations of package DIRECT_IO with 

unconstrained array types and record types with discriminants without 
defaults; these instantiations are rejected by this compiler. 


2-2 





IMPLEMENTATICN DEPENT? 


The tests listed in the following table check that USE_ERROR is raised 
if the given file operations are not supported for the given comcinat icr. 
of mode and access method; this implementation supports these cperaticns 


Test 

File Ooeration 

Mode Fi 

le Access Method 


CE2102D 

CREATE 

IN_FILE 

SEQUENTIAL 10 


CE2102E 

CREATE 

OUT_FILE 

SEQU^NTIA-L Xw 


CE2102F 

CREATE 

INOUT FILE 

DIRECT 10 


CE2102I 

CREATE 

IN_FILE 

DIRECT 10 


CE2102J 

CREATE 

OUT_FILE 

DIRECT 10 


CE2102N 

OPEN 

IN_FILE 

SEQUENTIAL_IO 


CE2102O 

RESET 

IN_FILE 

seqlt:ntial ic 


CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 10 


CE2102Q 

RESET 

OUT_FILE 

SEQUENTIAL IC 


CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 


CE2102S 

RESET 

INOUT FILE 

DIRECT 10 


CE2102T 

OPEN 

IN FILE 

DIRECT 10 


CE2102U 

RESET 

IN FILE 

DIRECT 10 


CE2102V 

OPEN 

OLT FILE 

DXRHCT XO 


CE21C2W 

RESET 

0-JT_FILE 

DIRECT IC 


CE3102E 

CREATE 

IN FILE 

TEXT IC 


CE3102F 

RESET 

Any Mode 

TEXT IC 


CE3102G 

DELETE 

- - -. 

TEXT 10 


CE3102I 

CREATE 

OL’T_FILE 

TEXT IC 


CE3102J 

OPEN 

IN_FILE 

i JL/k * ^ ^ 


CE3102K 

OPEN 

OUT_FILE 

rzx7_io 


The following 

IS tests check operations on seq-iential, di 

rect, and 

text files when multiple internal files 

are associated with 

the .same 

external file 

and one or 

more are open for writing; USE 

ERROR IS 

raised when th 

IS association 

IS attempted. 



CE2107B. 

.E CE2107G..H 

CE2107L 

CD211:B CE211CD 


CE2111D 

CH2111H 

CE311XB 

CE31L1D..E CE3114B 


CE3115A 





CE2203A checks 

that WRITE raises USE ERROR 

if the capacity of 

the 

external file 

is exceeded for 

SEQUENTIAL_I 

0. This implementa 

tion does 

not restrict file capacity. 




CE2403A checks 

that WRITE raises USE ERROR 

if the capacity of 

the 

external file 

is exceeded for 

DIRECT 10. 

This implementation 

does net 

restrict file 

capacity. 




CE3304A checks 

that USE ERROR 

is raised if 

a call to SET_LINE 

LENGTH or 

SET_PAGE_LENG'rH specifies a value that is 

inappropriate for t. 

he external 


file. This implementation does not have inappropriate values for either 
line length or page length. 

CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the page 
number exceeds COUNT'LAST. For this implementation, the value of 
COUNT'LAST is greater than 150000 making the checking of this objective 
impractical. 


2-3 




2.3 TEST MODIFICATIONS 


Modifications (see section 1.3) were required for 15 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the wav 
expected by the original tests. 

B71001Q BAIOOIA BA.2001C BA2001E BA3C06A 

BA3006B BA3007B BA3008A BA3008B BA3013A 

CS2008B was graded passed by Test Modification as directed by the AVC. This 
test uses a record type with discriminants with defaults; this test also has 
array components whose length depends on the values of some discriminants of 
type INTEGER. On elaboration of the type declaration, this implementation 
raises NUMERIC_ERROR as it attempts to calculate the maxim.um possible size 
for objects of the type. The AVO ruled that this behavior was acceptable, 
and that the test should be modified to constrain the subtype of the 
discriminants. Line 16 was modified to create a constrained subtype of 
INTEGER, and discriminant specifications in lines 17 and 25 were modified to 
use that subtype,- these lines are given below: 

16 SUBTYPE SUBINT IS INTEGER RANGE -128 .. 127; 

17 TYPE REC1(D1,D2 : SUBINT) IS 

25 TYPE REC2(D1,D2,D3,D4 : SUBINT := 0) IS 


CA2009C and CA2009F were graded inapplicable by Evaluation Modificaticn as 
directed by the AVO. These tests contain instantiations of a generic unit 
prior to the compilation of that unit's body; as allowed by AI-C04C8 and 
AI-00506, the compilation of the generic unit bodies ma)tes the compilation 
unit that contains the instantiations obsolete. 

BC3204C and BC3205D were graded passed by Processing Modification as 
directed by the AVO. These tests chec)c that instantiations of generic 
units with unconstrained types as generic actual parameters are illegal if 
the generic bodies contain uses of the types that require a constraint. 
However, the generic bodies are compiled after the units that contain the 
instantiations, ouid this implementation creates a dependence of the 
instantiating units on the generic units as allowed by AI-00408 and 
AI-00506 such that the compilation of the generic bodies makes the 
instantiating units obsolete--no errors are detected. The processing of 
these tests was modified by re-compiling the obsolete units,- all intended 
errors were then detected by the compiler. 


2-4 



CHAPTER 3 

PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For information about this Ada implementation system, see: 

TeleSoft 

5959 Cornerstone Court West 
San Diego, CA 92121, USA 
Tel: (619) 457-2700 


Testing of this Ada implementation was conducted at the customer's site by a 
validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pro92]. 

For all processed tests UnapplicaUole and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


3-1 





PROCESSING INFOR^MATION 

The list of items below gives the number of ACVC tests in various categories. 
All tests were processed, except those that were withdrawn because of test 
errors (item b; see section 2.1), those that require a floating-point precision 
that exceeds the implementation's maximum precision (item e; see section 22, 
and those that depend on the support of a file system -- if none is supported 
(item d). All tests passed, except those that are listed in sections 2.1 and 
2.2 (counted in items b and f, below). 


a) 

Total Number of Applicable Tests 

3829 


b) 

Total Number of Withdrawn Tests 

95 


c) 

Processed Inapplicable Tests 

87 


d) 

Non-Processed I/O Tests 

0 


e) 

Non-Processed Floating-Point 




Precision Tests 

159 


f) 

Total Number of Inapplicable Tests 

246 

(c+d+e) 

g) 

Total Number of Tests for ACVC 1.11 

4170 

(a+b-»f) 


3.3 TEST EXECUTION 

A magnetic data cartridge with the customized test suite (see section 1.3' 
was ta)ten on-site by the validation team for processing. The contents of the 
data cartridge were loaded to the host computer using networ)cing facilities. 

After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada implementation. 

The tests were compiled and linked on the host computer system. The 
executable images were transferred to two identical target computer systems 
by a serial communications link, and run. The results were captured from the 
host computer system onto a magnetic data cartridge. 

Test output, compiler and linker listings, emd job logs were captured on a 
magnetic data cartridge and archived at the AVE. The listings examined on¬ 
site by the validation team were also archived. 

Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a complete listing of 
the processing options for this implementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test are given in the following section, which was supplied by 
the customer. 


3-2 




LRM Annotations 


TeleGen2 pragmas 


3.10. LRM Appendix F - Impiementation-Dependent 
Characteristics 

The Ada language definition allows for certain target dependencies These 
dependencies must be described in the reference manual for each implementation 
This section addresses each point listed in LRM Appendix F. Topics that require 
further clarification are addressed in the sections referenced in the summarv' 

3.10.1. (1) Implementation-dependent pragmas 

TeleGen2 has the following implementation-dependent pragmas: 

pragma Access_Address 
pragma Comment 
pragma Export 
pragma Images 
pragma Interface_Infonnation 
pragma No_Suppress 
pragma Preserve_Layout 
pragma Protected_Call 
pragma Protected__Retum 
pragma Shareability 
pragma Suppress_All 

3.10.1.1. Pragma Access_Address 

This pragma is only valid in the extended architecture mode. Pragma 
Access_Address specifies the address type (Virtual, Linear, or AD) used to 
represent objects of the specified access type. When this pragma is absent, the 
address type defaults to Linear in the protected architecture mode and to Virtual 
in the extended architecture mode. The syntax of this pragma is 

pragma Access__Addre5s (<access__type_name>, <address type>) 
<address_type> ; Virtual j Linear ) AD 

This pragma is aUoi'ed at the place of a declarative item. It must refer to an 
access type declared earlier in the same declarative part or package specification. 
The pragma may not occur after a forcing occurrence of the name of the access 
type. 

This pragma may not be associated with an access type whose designated subtvpe 
is a task type or has a task subcomponent, or to an access type that already has an 
Access_Address pragma associated with it. 

The compiler rejects a pragma Access_Address on an access type that also has a 
length clause for ’Storage_Size. 


UG-2109N.V1.1(SPARCJ960) 17DEC92 


3-11 





TeleGen2 pragmas 


TeleGen2 for SPARCxi960 


3.10.1.2. Pragma Comment 

Pragma Comment is used for embedding a comment into the object code. The 
syntax is 

pragma Comment ( <strlng_literal> ); 

where <string literal> represents the characters to be embedded in the object 
code. Pragma Conunent is allowed only within a declarative part or immediately 
within a package specification. Any number of comments may be entered into the 
object code by use of pragma Comment. 

3.10.1.3. Pragma Export 

Pragmi. Export enables you to export an Ada subprogram or object to either the 
C language or assembly. The pragma is not supported for Pascal or FORTRAN 
Use of the language name "interrupt" allows a parameterless procedure to be used 
as the entry point for an interrupt handler. The syntax of the pragma is 

pragma Export ( [ Name »> ] <subprogram__or_object_name> 

[, [ Link__Name «> ] <string_literal> ] 

[, [ Language ■■> ] <identifier> ] ) ; 

The syntax and use of the pragma is explained in detail in Section 4.3.3. 

3.10.1.4. Pragma Images 

Pragma Images controls the creation and allocation of the image and index tables 
for a specified enumeration type. The syntax is 

pragma Images(<enumeratlon_t 7 pe>. Deferred); 

pragma Images(<enumeration_type>, Immediate); 

The syntax and use of the pragma is described in detail in Section 4.2.3. 

3.10.1.5. Pragma Interfacejnformation 

Pragma Interface Information provides information for the optinaizing code 
generator when interfacing jion-Ada languages or doing machine code insertions. 
Pragma Interface_Information is always associated with a pragma Interface except 
for machine code insertion procedures, which do not use a preceding pragma 
Interface. The syntax of the pragma is 

pragma Interface_Information 

(Name, -- Ada subprogram, required 

Link_Name, -- string, default - 

Mechanism. -- string, default - 

Parameters, -- string, default - "" 

Regs^Clobbered); -- string, default - "" 

Section 43 . 2.2 explains the syntax and usage of this pragma. 


3*12 


UG-2109N.Vl.l(SPARC.i960) 17DEC92 







LRM Annotations 


TeleGen2 pragmas 


3.10.1.6. Pragma No_Suppress 

Pragma No_Suppress is a TeleGen2-defmed pragma that prevents the suppression 
of checks within a particular scope. It can be used to override pragma Suppress in 
an enclosing scope. The pragma uses the same syntax and can occur in the same 
places in the source as pragma Suppress. The syntax is 

pragma No_Suppress (<ldencifler> [, [ON ->] <name>]); 

<identif ier> The type of check you do not want to suppress. 

<name> The name of the object, type/subtype, task unit, generic unit, or 
subprogram within which the check is to be suppressed. < name > 
is optional. 

Section 2.2.2.2 explains the use of this pragma in more detail. 

3.10.1.7. Pragma Preserve_Layout 

The TeIeGen2 compiler reorders record components to minimize gaps within 
records. Pragma Preserve_Layout forces the compiler to mainuin the Ada source 
order of components of a given record type, thereby preventing the compiler from 
performing this record layout optimization. 

The syntax of this pragma is 

Pragma Preserve_Layout ( ON -> <record_type> ); 


Preserve_Layout must appear before any forcing occurrences of the record type 
and must be in the same declarative part, package specification, or task 
specification. This pragma can be applied to a record type that has been packed 
If Preserve_Layout is applied to a record type that has a record representation 
clause, the pragma only applies to the components that do not have component 
clauses. These components will appear in Ada source order after the components 
with component clauses. 

3.10.1.8. Pragma Protected^aK 

Pragma Protected_Call requires the caller of the subprogram to clear global 
registers not used to pass parameters before calling the affected subprogram. This 
pragma is used to prevent callee access to caller data structures. The syntax of 
this pragma is 

pragma Protected_Call [(<s\ibprogram>[, <subprogram>...])]; 

The < subprogram > argument can be a subprogram, a renamed subprogram, a 
derived subprogram, or a generic formal subprogram. Generic subprograms are 
not allowed. A pragma Protected_Call on a renamed subprogram applies to ail 
calls to the renamed subprogram, through any renaming declaration, or through 
the original subprogram declaration. The pragma applies only to the specified 


UG-2109N.Vl.l(SPARCi960) 17DEC92 


3-13 






TeieGen2 pragmas 


TeleGen2 for SPARCxi960 


subprograms that are visible from the point of the pragma. This implies that the 
pragma applies to all overloaded subprograms specified by < subprogram >. If no 
argument is supplied, the pragma applies to all explicit subprogram calls found m 
the enclosing scope. 

The pragma is allowed at the place of a declarative item and is in effect from the 
point of the pragma to the end of the enclosing scope. If the pragma appears in a 
package specification, it does not apply to the corresponding package body. 
Subprograms with a pragma Protected_Cail cannot ^ inlined. The pragma is 
checked for when the optimizer is invoked. 

3.10.1.9. Pragma Protected_Retum 

Pragma Protected_Retum requires a subprogram to clear global registers not 
used to pass parameters before returning to the subprogram's caller. This pragma 
is used to prevent caller access to callee data structures. The syntax is 

pragma Protected_Retun\; 

Protected_Retum may occur only in the declarative section of a subprogram. The 
pragma is valid in a generic subprogram and applies to all instantiations. A 
subprogram with a pragma Protected_Retum cannot be inlined. The pragma is 
checked for when the optimizer is invoked. 

3.10.1.10. Pragma Shareability 

Pragma Shareability is used only in a library unit package specification and 
specifies that the unit is a visible unit for a domain. The routines specified in the 
unit will be accessible through the procedure table of the domain containing the 
unit, and the visible data of the unit will be visible to other domains. The syntax of 
this pragma is 

pragma Shareability [<<shareabillty_t 7 pe>)]; 

<shareability_t 7 pe> :Domain | System | User 

The optional <shareability_type> argument defaults to Domain in the extended 
architecture mode and System in the protected architecture mode of processor 
operation. Subprograms iiv-a specification containing pragma Shareability cannot 
be inlined. The pragma is checked for when the optimizer is invoked. 

See Sections ‘’Nuse_share and ‘’Nprag_share for more information on the use of 
this pragma. 

3.10.1.11. Pragma Suppress_AII 

Suppress_All is an implementation-defined pragma that suppresses all checks in a 
given scope. Pragma Suppress_All takes no arguments and can be placed in the 
same scopes as pragma Suppress. 


3-14 


UG.2109N-Vl.l(SPARCa960) 17DEC92 






LRM Annotations 


TeleGen2 attributes 


In the presence of pragma Suppress AH or any other Suppress pragma, the scope 
that contains the pragma will have checking turned off. This pragma should be 
used in a safe piece of time-critical code to allow for better performance 

3.10.2. (2) Implementation-dependent attributes 

TeleGen2 has the following implementation-dependent attributes 

’Linear__Address 
’Offset (in MQ) 

’Subprogram_Entry 

’Subprogram_Value 

’Extended_Image 

’Extended_Value 

’Extended_Width 

’Extended_Aft 

’Extended_Digits 

’Extended_Fore 

Note that the predefined attribute ’Address has different semantics in extended 
mode versus protected mode. In extended mode, System.Address is virtual rather 
than linear. 

3.10.2.1. ’Linear_Address 

The attrfeute ’Linear__Address directly parallels, and is syntactically identical to, 
the Ada predefined attribute ’Address, but the resulting value is the linear address 
(as opposed to the virtual address) of the prefix, System.Linear_Address. The 
syntax of this attribute is 

X ' Llnear__Addr e s s 

A ’Linear^^Address attribute may be associated with any entity that resides in a 
linear address space. This implies that a ’Linear Address of a variable in the 
public data objects is not allowed. 

While more applicable to extended mode programming, this attribute is also 
supported for protected mode execution. 

3.10.2.2. ’Offset 

’Offset yields the ofeet of an Ada object from its parent frame. This attribute 
supports machine code insertions as described in Section 5.4.2.2. 

3.10.2.3. ’Subprogram__Entry 

The attribute ’Subprogram_Entry yields a value of type 
System.Subprogram_EntTy. This value is a record that represents the program 
unit’s entry in the domain subprogram table. The record contains two fields, an 
offset into the table and an access descriptor: 


UG-2109N-V1.1{SPARCJ960) 17DEC92 


3-lS 






TeleGen2 attributes 


TeleGen2 for SPARCxi960 


offset : System.Ordinal; 

Domain AD ; Mixed Vord; 


A Subprogram_Entry attribute may be associated with any subprogram that 
resides in a package specification containing pragma Shareability. This implies 
that it is incorrect to use ’Subprogram_Entry of a subprogram that is not in a 
shareable specification. 

3.10.2.4. ’Subprogram_Vaiue 

This attribute yields a value of type System.Subprogram_Vaiue. This value is a 
record that represents the address of the procedure and the address of its parent’s 
frame: 

Proc__addr : Address; 

Parent_frame : Address; 

The attribute is defined only for procedures without parameters. 

3.10.2.5. Extended attributes for scalar types 

The extended attributes extend the concept behind the text attributes ’Image, 
’Value, and ’Width to give the user more power and flexibility when displaying 
values of scalars. Extended attributes differ in two respects from their predefined 
counterparts: 

1. Extended attributes take more parameters and allow control of the 
format of the output string. 

2. Extended attributes are defined for all scalar types, including fixed and 
floating point types. 

Named parameter associations are not currently supported for the extended 
attributes. 


Extended versions of predefined attributes are provided for integer, enumeration, 
floating point, and fixed point types: 


Integer 

’Extended_Image 
’Extended_^Value 
“Extended Width 


Enumeration 

’Extended_Image 
’Extended Value 
’Extended^Width 


Floating Point 

’Extended_Image 

’Extended_Value 

’Extended_Digits 


Fixed Point 

’Extended_Image 
’Extended Value 
’Extended_Fore 
’Extended Aft 


For integer and enumeration types, the ’Extended_Value attribute is identical to 
the ’Value attribute. For enumeration types, the ’Extended_Width attribute is 
identical to the ’Width attribute. 


3-16 


UG-21l)9N-Vl.l(SPARC.i960) 17DEC92 






LRM Annotations 


TeleGen2 attributes 


The extended attributes can be used without the overhead of including Text lO in 
the linked program. The following examples illustrate the difference between 
instantiating Text_IO.Float_IO to convert a float value to a string and using 
Float’Extended_Image: 


with Text_IO; 

function Convert_To_String ( FI : Float ) return String is 
Temp^Str : String ( 1 6 + Float'Digits ); 

package Flt_IO is new Text_IO.Float_IO (Float); 
begin 

Flt_IO.Put ( Temp_Str. FI ); 
return Teap_Str; 
end Convert_To_String; 


function Convert_To_String_No_Text_IO( FI : Float ) return String is 
begin 

return Float'Extend6d_Iinage ( FI ); 
end Convert_To_String_No_Text_IO; 


with Text_IO, Convert_To__String, Convert_To_String__No_Text_IO; 
procedure Show Different Conversions is 
Value : Float 10.03376; 
begin 

Text__I0. Put_Line ( "Using the Convert_To__String, the value of 
the variable is : " & Convert__^To^String ( Value ) ); 

Text_I0.Put_Llne ( "Using the Convert_To_String_No_Text_IO, 
the value is : " & Convert_To_String_No_Text_IO ( Value ) ); 
end Show Different Conversions; 


UG-2109N-V1.1 (SPARC J960) 17DEC92 


3-17 






Integer attributes 


TeleGen2 for SPARCxi960 


3.10.2.5.1. Integer attributes 
’Extendedjmage 

X'Extended_lmage(Item.Width,Base.Based,Space_If_Positive) 

Returns the image associated with Item as defined in Text_IO.Integer_IO. 
The Text_IO definition states that the value of Item is an integer literal with 
no underlines, no exponent, no leading zeros (but a single zero for the zero 
value), and a minus sign if negative. If the resulting sequence of characters 
to be output has fewer than Width characters, leading spaces are first 
output to make up the difference. (LRM 14.3.7:10,14.3.7:11) 

For a prefix X that is a discrete type or subtype, this attribute is a function 
that may have more than one parameter. The parameter Item must be an 
integer value. The resulting string is without underlines, leading zeros, or 
trailing spaces. 


Parameters 

Item The item for which you want the image; it is passed to the 
function. Required. 

Width The minimum number of characters to be in the string 

that is returned. If no width is specified, the default (0) is 
assumed. Optional. 

Base The base in which the image is to be displayed. If no base 
is specified, the default (10) is assumed. Optional. 

Based An indication of whether you want the string returned to 
be in base notation or not. If no preference is specified, 
the default (false) is assumed. Optional. 


Space_If_Pos itive An indication of whether or not a positive integer should 

be prefixed with a space in the string returned. If no 
preference is specified, the default (false) is assumed. 
Optional. 


Examples 

subtype X Is Integer Range -10..16; 


Values yielded for selected parameters: 


X'Extended_Image(5) - "5" 

X'Extended_Image(5,0) - "5" 

X'Eztended_Image(5,2) <■ " 5" 

X'Extended“lmage(5.0.2) - "101" 


3-18 


UG.2109N-V1.1 (SPARC J960) 17DEC92 







LRM Annotations 


Integer attributes 


X'Extended_Iniage(5,4,2) 
X'Extended_Image(5,0,2.True) 
X'Extended_Iiiiage(5,0,10, False) 

X'Extended_Iaage(5,0,10,False,True) 

X'Extended_Image(-1,0,10,False.False) 
X'Extended_Iiiiage(-l, 0,10, False .True) 

X'Extended_Image(-1,1,10,False,True) 
X'Extende d_Image(-1,0,2,True,True) 

X'Extended_Iiiiage(-1,10,2 .True ,True) 


- " 101 " 

- "inour 

- "5" 

- " 5" 

. "- 1 " 

- "- 1 " 

- "-I" 

- ''-unr 

- " -Zi.iU 


UG-2109N-V1.1 (SPARC J960) 17DEC92 


3-19 






integer attributes 


TeleGen2 for SPARCxiSeo 


’Extended_Value 

X'Exten<led_Value(Item) 

Returns the value associated with Item as defined in Text IO,lnteger_IO 
The Text_IO definition states that given a string, it reads an integer value 
from the beginning of the string. The value returned corresponds tc the 
sequence input. (LRM 14.3.7:14) 

For a prefix X that is a discrete type or subtype, this attribute is a function 
with a single parameter. The actual parameter Item must be of predefined 
type string. Any leading or trailing spaces in the string X are ignored. In 
the case where an illegal string is passed, a Constraint_Error is raised. 

Parameter 

Item A parameter of the predefined type string; it is passed to 
the function. The type of the returned value is the base 
type X. Required. 

Examples 

subtype X is Integer Range -10..16; 

Values yielded for selected parameters: 


X'Extended Value("5") - 5 

X'Extended”Value(" 5") - 5 

X'Extended”Value("2#10U'/") - 5 

X'Extended“Value("-l") -1 

X'Extended~Value(" -1") - -1 


3-20 


UG-2109N.VL1(SPARC.I960) 17DEC92 






LRM Annotations 


Integer attributes 


’Extended_Wldth 

X'Exten<ied_Wldth(Base , Based, Space_If_Pos It ive) 

Returns the width for subtype of X. For a prefix X that is a discrete 
subtype, this attribute is a function that may have multiple parameters This 
attribute yields the maximum image length over all values of the type or 
subtype X. 

Parameters 

Base The base for which the width will be calculated If no base 
is specified, the default (10) is assumed. Optional 

Based An indication of whether the subtype is stated in based 
notation. If no value for based is specified, the default 
(false) is assumed. Optional. 

Space_If_Positive An indication of whether or not the sign bit of a positive 

integer is included in the string returned If no preference 
is specified, the default (false) is assumed. Optional 

Examples 

subtype X is Integer Range -10.16; 

Values yielded for selected parameters; 

X'Extended_Width - 3 -"-70 

X'Extended Width(10) -3 - "-70' 

X'Extended“width(2) -5 -”70000" 

X'Extended_Width(10.True) -7 _'.70#70#' 

X’Extended Width(2,True) -8 -'2#70000# 

X'Extended~Width(10,False,True) -3 -"76' 

X'Extended”width (10, True. False) -7 _"-70#70#' 

X' Ext ended~Width( 10, True, True) -7 -■'70#76#’ 

X'Extended“width(2.True.True) - 9 -”2# 70000#' 

X'Extended“width(2.False,True) - 6 -"70000" 


UG-2109N-V1.1(SPARCJ960) 17DEC92 


3-21 






Enumeration type attributes 


TeleGen2 for SPARCxi960 


3.10.2.5.2. Enumeration type attributes 


'Extendedjmage 

X'Extended_Iiaage(Item, Width .uppercase) 


Returns the image associated with Item as defined in 
Text_IO.Enumeration_IO. The Text_IO definition states that given an 
enumeration literad, it will output the value of the enumeration Literal (either 
an identifier or a character literal). The character case parameter is 
ignored for character literals. (LRM 14.3.9:9) 


For a prefix X that is a discrete type or subtype; this attribute is a function 
that may have more that one parameter. The pajameter Item must be an 
enumeration value. The image of an enumeration value is the 
corresponding identifier, which may have character case and return string 
width specified. 


Parameters 


Item The item for which you want the image; it is passed to the 
function. Required. 

Width The minimum number of characters to be in the string 
that is returned. If no width is specified, the default (0) is 
assumed. If the Width specified is larger than the image 
of Item, the return string is padded with trailing spaces. If 
the Width specified is smaller than the image of Item, the 
default is assumed and the image of the enumeration value 
is output completely. Optional. 


Uppercase An indication of whether the returned string is in upper 

case characters. In the case of an enumeration type where 
the enumeration literals are character literals. Uppercase 
is ignored and the case specified by the type definition is 
taken. If no preference is specified, the default (true) is 
assumed Optional. 


3-22 


UG-2109N.Vl.l(SPARCj960) 17DEC92 






LRM Annotations 


Enumeration type attributes 


Examples 

t3rpe X is (red, green, blue, purple); 
type Y is ('a', 'B'. 'c', 'P'); 


Values yielded for selected parameters: 


X'Extended_Image(red) 

- 

"RED" 

X'Extended_Image(red, 4) 


"RED " 

Z' Eztended_Iiaage (red, 2 ) 

- 

"RED" 

Z'Extended_Image(red,0,false) 

- 

"red" 

X'Extended_Image(red,10,false) 

- 

"red 

Y'Extended_Iaage('a') 

- 

" ' a' " 

Y' Eztended_Iaiage (' B') 

- 

tf f ^ # tt 

Y'Extended_Image('a',6) 

- 

” ' a' " 

Y' Extended__Image (' a', 0, true) 

m 

" ' a ' " 


UG-2109N-V1.1 (SPARC JSHSO) 17DEC92 


3-23 





Enumeration type attributes 


TeleGen2 for SPARCxi960 


’Extended_\^lue 

X'Extended_Value(Item) 

Returns the image associated with Item as defined in 
Te)Ct_IO.Enumeration_IO. The Text_IO definition states that it reads an 
enumeration value from the beginning of the given string and returns the 
value of the enumeration literal that corresponds to the sequence input. 
(LRM 14.3.9:11) 

For a prefix X that is a discrete type or subtype, this attribute is a function 
with a single parameter. The actual parameter Item must be of predefined 
type string. Any leading or trailing spaces in the string X are ignored. In 
the case where an illegal string is passed, a Constraint_Error is raised. 

Parameter 

Item A parameter of the predefined type string; it is passed to 
the function. The type of the returned value is the base 
type of X. Required. 

Examples 

type X is (red, green, blue, purple); 

Values yielded for selected parameters: 

X'Extended_Value(”red") - red 

X'Extended^Value(" green") - green 

X'Extended_Value(" Purple") - purple 
X'Extended Value(" GreEn ") - green 


3-24 


UG-2109N-Vl.l(SPAilC.i960) 17DEC92 





LRM Annotations 


Enumeration type attributes 


’Extended^Wldth 

X'Extended_Width 
Returns the width for subtype of X. 

For a prefix X that is a discrete type or subtype; this attribute is a function. 
This attribute yields the maximum image length over all values of the 
enumeration type or subtype X. 

Parameters 

There are no parameters to this function. This ftmction returns the width of 
the largest (width) enumeration literal in the enumeration type specified by 
X. 

Examples 

type X is (red, green, blue, purple); 
type Z is (XI, X12. X123, X1234); 

Values yielded; 

X'Extended_Width • 6 -"purple" 

Z'Extended Width • 5 -"X1234" 


UG-2109N.V1.1(SPARC4960) 17DEC92 


3-25 





Floating point attributes 


TeleGen2 for SPARCxi960 


3.10.2.5.3. Floating point attributes 
’Extended Jmage 

X'Extended__I]aage(Item.Fore,Aft,Exp, Base , Based) 

Returns the image asscxiated with Item as defined in Text IO.Float_IO. 

The Text_IO definition states that it outputs the value of the parameter Item 
as a decimal literal with the format defined by the other parameters. If the 
value is negative, a minus sign is included in the integer part of the value of 
Item. If Exp is 0, the integer part of the output has as many digits as are 
needed to represent the integer part of the value of Item or is zero if the 
value of Item has no integer part (LRM 14.3.8:13,14.3.8:15) 

Item must be a Real value. The resulting string is without underlines or 
trailing spaces. 

Parameters 

Item The item for which you want the image; it is passed to the 
function. Required. 

Fore The minimum number of characters for the integer part of 
the decimal representation in the return string. This 
includes a minus sign if the value is negative and the base 
with the ’#’ if based notation is specified. If the integer 
part to be output has fewer characters than specified by 
Fore, leading spaces are output first to make up the 
difference. If no Fore is specified, the default value (2) is 
assumed. Optional. 

Aft The minimum number of decimal digits after the decimal 
point to accommodate the precision desired. If the delta 
of the type or subtype is greater than 0.1, then Aft is 1. If 
no Aft is specified, the default (X’Digits-1) is assumed. If 
based notation is specified, the trailing ’#’ is included in 
Aft. Optional. 

Exp The minimum number of digits in the exponent. The 

exponent consists of a sign and the exponent, possibly with 
leading zeros. If no Exp is specified, the default (3 ) is 
assumed. If Exp is 0, no exponent is used. Optional. 

Base The base that the image is to be displayed in. If no base is 
specified, the default (10) is assumed. Optional. 

Based An indication of whether you want the string returned to 
be in based notation or not. If no preference is specified, 
the default (false) is assumed. Optional. 


3-26 


UG-2109N.Vl.l(SPAJlC.i960) 17DEC92 





LRM Annotations 


Floating point attributes 


Examples 


type X is digits 5 range -10.0 .. 16.0; 

Values yielded for selected parameters; 

X'Eztended_Iinage(5.0) 
X'£ztended_Image(5.0,1) 

Z'Eztended_Image(-5.0,1) 
Z'£xtended_Ifflage(5.0,2,0) 
Z'Extended_Image(5.0,2,0,0) 
Z'£ztended_liziage(S . 0,2,0,0,2) 

X'Extended_Image(5.0,2,0,0,2,True) 

X'Extended'lmage(5.0,2,2.3,2,True) 


- " 5 . OOOOE-fOO" 

- "5.OOOOE+00" 

- ’’-5 .OOOOE+00" 

- " 5.0E+00" 

- " 5.0” 

. " 101 . 0 " 

- "unoi.oir’ 

- "201.1//E+02" 


UG-2109N-V1.1 (SPARC J960) 17DEC92 


3-27 





Floating point attributes 


TeleGen2 for SPARCxi960 


’Extended_Value 

X' Extcnded__Value (Item) 

Returns the value associated with Item as defined in TexT_IO.Float_10 
The Text_IO definition slates that it skips any leading zeros, then reads a 
plus or minus sign if present then reads the string according to the syntax of 
a real literal. The return value is that which corresponds to the sequence 
input. (LRM 14.3.8:9, 14.3.8:10) 

For a prefix X that is a discrete type or subtype; this attribute is a function 
with a single parameter. The acttial parameter Item must be of predefined 
type string. Any leading or trailing spaces in the string X are ignored. In 
the case where an illegal string is passed, a Constraint_Error is raised. 

Parameter 

Item A parameter of the predefined type string; it is passed to 
the function. The type of the returned value is the base 
type of the input string. Required. 

Examples 

type X is digits 5 range -10.0 .. 16.0; 

Values yielded for selected parameters; 

X'Extended Value("5.0") - 5.0 

X'Extended“'Value("0.5El") - 5.0 

X'Extended“Value("2f/1.01f/E2") - 5.0 


3-28 


UG-2109N.Vl.l(SP/yiC.i960) 17DEC9: 







LRM Annotations 


Floating point attributes 


’Extencled_Digits 

X'Extended_Dlglcs(Base) 

Returns the number of digits using base in the mantissa of model numbers 
of the subtype X. 

Parameter 

Base TTie base that the subtype is defined in. If no base is 
specified, the default (10) is assumed. Optional. 

Examples 

type X is digits 5 range -10.0 .. 16.0; 

Values yielded: 

X'Eactended_Digics ■ 5 


UG-2109N.V1.1(SPARCJ960) 17DEC92 


3-29 






Fixed point attributes 


TeieGen2 for SPARCxi960 


3.10.2.5.4. Fixed point attributes 
’Extended Image 

X'£xtended_I]nage(Item,Fore.t.Exp.Base .Based) 

Returns the image associated with Item as defined in Text_IO.Fixed_IO. 
The Text_IO definition states that it outputs the value of the parameter Item 
as a decimal literal with the format defined by the other parameters. If the 
value is negative, a minus sign is included in the integer part of the value of 
Item. If Exp is 0, the integer part of the output has as many digits as are 
needed to represent the integer part of the value of Item or is zero if the 
value of Item has no integer part. (LRM 14.3.8:13, 14.3.8:15) 

For a prefix X that is a discrete type or subtype; this attribute is a function 
that may have more than one parameter. The parameter Item must be a 
Real value. The resulting string is without underlines or trailing spaces. 

Parameters 

Item The item for which you want the image; it is passed to the 
function. Required. 

Fore The minimum number of characters for the integer part of 
the decimal representation in the return string. This 
includes a minus sign if the value is negative and the base 
with the ’#’ if based notation is specified. If the integer 
part to be output has fewer characters than specified by 
Fore, leading spaces are output first to make up the 
difference. If no Fore is specified, the default value (2) is 
assumed. Optional. 

Aft The minimum number of decimal digits after the decimal 
point to accommodate the precision desired. If the delta 
of the type or subtype is greater than 0.1, then Aft is 1. If 
no Aft is specified, the default (X’Digits-1) is assumed. If 
based notation is ^jecified, the trailing ’#’ is included in 
AftC" Optional. 

Exp The minimum number of digits in the exponent; the 

exponent consists of a sign and the exponent, possibly with 
leading zeros. If no Exp is specified, the default (3 ) is 
assumed. If Exp is 0, no exponent is used. Optional. 

Base The base in which the image is to be displayed. If nobv.se 
is specified, the default (10) is assumed. Optional. 


3-30 


UG-2109N-Vl.l(SPARC.i960) 17DEC92 







LRM Annotations 


Fixed point attributes 


Based An indication of whether you want the string returned to 
be in based notation or not. If no preference is specified, 
the default (false) is assumed. Optional. 


Examples 


type X is delta 0.1 range -10.0 .. 17.0; 


Values 3 delded for selected parameters: 

X'Extended_Iaage(5.0) 

X'Extende d_Iaage(5.0,1) 

X' Extended_Iniage (-5.0,1) 
X'Extended“ls ge(5.0,2,0) 
X'Extended“l5 'e(5.0.2.0,0) 

X'Extended'lmage(5.0,2,0,0,2) 

X' Extended_Ijnage (5.0,2,0,0,2, True ) 
X'Extended”lmage(5.0,2,2.3,2,True) 


- " 5.00E+00" 

- "S.OOE+OO" 

- "-S.OOE+OO” 

- " 5.0E+00" 

- " 5.0" 

- " 101 . 0 " 

« "znoi-Oir 

- "2#l.lf/E+02" 


UG-2109N-V1,1(SPARCJ960) 17DEC92 


3-31 







Fixed point attributes 


TeleGen2 for SPARCxi960 


’Extended_Vaiue 

X'Extended_Value(Image) 

Returns the value associated with Item as defined in Text IO.Fixed_IO. The 
Text__IO definition states that it skips any leading zeros, reads a plus or 
minus sign if present, then reads the string according to the syntax of a real 
literal. The return value is that which corresponds to the sequence input. 
(LRM 14.3.8:9, 14.3.8:10) 

For a prefix X that is a discrete type or subtype; this attribute is a function 
with a sin^e parameter. The actual parameter Item must be of predefined 
type string. Any leading or trailing spaces in the string X are ignored. In 
the case where an illegal string is passed, a Constraint__Error is raised. 

Parameter 

Image Parameter of the predefined type string. The type of the 
returned value is the base type of the input string. 
Required. 

Examples 

type X is delta 0.1 range -10.0 .. 17.0; 

Values yielded for selected parameters: 

X'Extended ValueC’5.0") 

X'Extended'’Value<"0.5E1") 

X'Extended”Value("2#l. 01#E2’’) 


- 5.0 

- 5.0 

- 5.0 


3-32 


UG-2109N-V1.1(SPARC.1960) 17DEC92 




LRM Annotations 


Fixed point attributes 


’Extended__Fore 

X'£xtended_Fore(Base.Based) 

Returns the minimum number of characters required for the integer part of 
the based representation of X. 

Parameters 

Base The base in which the subtype is to be displayed. If no 
base is specified, the default (10) is assumed. Optional. 

Based An indication of whether you want the string returned to 
be in based notation or not. If no preference is specified, 
the default (false) is assumed. Optional. 

Examples 

tjpe X is delta 0.1 range -10.0 17.1; 

Values yielded for selected parameters: 

X'Extended^Fore - 3 -- "-10" 

X'Extended“Fore(2) - 6 " 10001" 


UG-2109N-V1.1 (SPARC j960) 17DEC92 


3-33 







Fixed point attributes 


TeleGen2 for SPARCxi960 


’Extended_Att 

X'Extended_Aft(Base.Based) 

Returns the minimum number of characters required for the fractional part 

of the based representation of X. 

Parameters 

Base The base in which the subtype is to be displayed. If no 
base is specified, the default (10) is assumed. Optional. 

Based An indication of whether you want the string returned to 

be in based notation or not. If no preference is specified, 
the default (false) is assumed. Optional. 

Examples 

type X is delta 0.1 range -10.0 .. 17.1; 

Values yielded for selected parameters; 

X'Extended Aft -> 1 -"1"from 0.1 

X'Extended”Aft(2) - 4 - “0001"from 2*0.0001 


3-34 


UG-2109N.Vl.l(SPARCi960) 17DEC92 








LRM Annotations 


Package System 


3,10,3. (3) Package System 

The protected and extended architecture versions of the compiler have difiereni 
versions of package System. The main differences are in the implementation of 
address types for the different memory models. 

with Unchecked__Converslon; 

package System Is 

-- pragma shareability (system); 


-- CUSTOMIZABLE VALDES 


type Name is (TeleGenZ); 

System_Name : constant name TeleGen2; 

Memory^^Size ; constant (2 ** 31) -1; --Available memory, in storage units 

Tick ~ : constant 1.0 / 100.0; --Basic clock rate, in seconds 

type Task_Data is 

record -- Adaptation-specific customization information 

Name ; String(1..8) ; -- for task objects. 

-- The MP makes up Name 

end record; 


-- NON-CUSTOMIZABLE, IMPLEMENTATION-DEPENDENT VALDES 


Storage_Dnit : constant 8; 

Min_Int : consta^ -(2 ** 31); 

Max_Int : constant (2 ** 31) - 1; 

Max__Digits : constant 18; 

Max_Mantissa : constant :« 31; 

Fine Delta ; constant 1.0 / (2 ** Max_Mantissa); 


subtype Priority is Integer Range 0 .. 31; 



UG-2109N-V1.1 (SPARC J960) 17DEC92 


3-35 








Package System 


TeleGen2 for SPARCxi960 


type Memory is private; 

type Address is access Memory; 

pragma Access_Address (Address, Virtxial); 

type Virtual_Address is access Memory; 

pragma Access_^Address (Virtual__Address, Virtual); 

type Linear_Address is access Memory; 

pragma Access_Address (Llnear__Address, Linear); 

type AD_Address is access Memory; 
pragma Access^Address (AD_Address, AD); 

-- Ensures compatibility between addresses and access types 
-- Also provides implicit NULL initial value. 


-- The following type, Mixed_Word, must be be implemented as an 
-- access descriptor (AD) 

type Mixed^Word is new AD_Address; 


Null__Address: constant Address Null; 

-- Initial value for any Address object; Null__Add ss - 0. 
Null_Linear__Address; constant Linear_Address Null; 

-- Initial value for any Address object; Null_Linear_Address - 0. 

type Address_Value is range -(2**31)..(2**31)-1; 

-‘A numeric representation of logical addresses for use in address clauses 


function Location is new Unchecked^Converslon (Address_Value, Address); 
function Location is new DncJiecked_Converslon (Address_Value, Linear_Address) 

-- May be used in address clauses: 

Object: Some_Type; 

for Object use at Location (16#4000#); 


-- Note: in extended mode of execution only the offset into the target 
-- address will be effected. If the target of this function jioes not 
-- have a valid AD, then this operation could result in an invalid 
-- address being generated. 


3-36 


UG-2109N-Vl.l{SPARC.i960) 17DEC92 





LRM Annotations 


Package System 


function Label (Name: String) return Address; 
pragma Interface (META, Label); 

-- The LABEL meta-function allows a link name to be specified as address 
-- for an imported object in an address clause; 

Object: Some_T 7 pe; 

-- for Object use at Label("OBJECT$$LINK_NAME"); 

-- System.Label returns Null Address for non-literal parameters. 


-- Ordinal types are unsigned. They use the 80960 ordinal 

instructions, which do not fault on an overflow. Ordinal types are 
provided in a separate package along with their arithmetic and 
relational operators. Addition, subtraction, and relational operations 
are supported. Some conversion between integer and ordinal 
types is supported. A user shall be able to specify a positive 
-- numeric literal for every ordinal value. Ordinal numbers are not 
valid for loop bounds, array indices, and so on. The comp5.1er 
-- allocates the minimum storage size supported by the architecture for 
these types. The following ordinal types are supported: 
o SHORT SHORT ORDINAL, An 8 bit ordinal type (0..2**8-l) 
o SH0 Rt“0RDINAL, a 16 bit ordinal type (0..2**16-1) 
o ORDINAL, A 32 bit ordinal type (0..2**32-l) 
o LONG ORDINAL, A 64 bit ordinal type (0..2**64-l) 


type Short_Short_Ordinal is range 0 .. 2**8-l; 

type Short^Ordinal is range 0 .. 2**16-1; 

type Ordinal is range -2**31 .. 2**31-1; 

type Long_Ordinal is 
record 

LSB_Fart ; Ordinal; 

MSB_Part : Ordinal; 
end record; 


--To keep checks around ordinal operations from causing problems with 
-- ordinal math, all pertinent checks are explicitly suppressed. 


pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 


(Overflow_Check, Short_Short_Ordinal); 
(Overflow__Check, Short_0rdinal) ; 

(Overflow_Check, Ordinal); 
(Range_Check, Short_Short__Ordinal) ; 
(Range^Check, Short_Ordinal); 
(Range_Check, Ordinal); 


UG-2109N.V1.1(SPARCJ960) 17DEC92 


3-37 





Package System 


TeieGen2 for SPARCxi960 


-- Note, all the following routines that have a name starting with the 
-- characters "cgs__" are specially recognized routines. The i960 code 
-- generator will automatically (and very efficiently) inline these 
-- routines into the target program. 


-- Base set of functions for Short^Short Ordinal 

function Cgs__SSOrd_Add (X. Y : Short_Short_Ordinai) 
return Short_Short_Ordlnal** 
function Cgs_SSOrd_Sub (X, Y : Short_Short_Ordinal) 
return Short_Short_Ordlnal; 
fTinction Cgs_SSOrd_liul (X, Y : Short_Short__Ordinal) 
return Short_Short_Ordlnal; "" 

function Cgs_SSOrd_Div (X, Y : Short_Short__Ordinal) 
return Short_Short_^Ordinal; 

function Cgs_SSOrd_LT (X, Y i Short__Short_Ordinal) return Boolean; 

function Cgs_SSOrd_LE (X, Y : Short_Short_Ordinal) return Boolean; 

function Cgs_SSOrd_GT (X, Y : Short_Short_Ordinal) return Boolean; 

function Cgs_SSOrd_GE (X, Y : Short_Short_Ordinal) return Boolean; 

function "+” (X, Y : Short_Short_Ordinal) return Short_Short_Ordinal 
renames Cgs_SSOrd__^Add; 

function (X, Y : Short_Short_Ordinal) return Short^Short__Ordinal 
renames Cgs_SSOrd_Suh; 

function (X. Y : Short_Short_Ordinal) return Short_Short_Ordinal 
renames Cgs^SSOrd_^Hul; 

function "/" (X, Y : Short_Short_Ordinal) return Short_Short_Ordinal 
renames Cgs_SSOrd_Div; 

function "<" (X, Y : Short__Short_Ordinal) return Boolean renames Cgs_SSOrd_LT 

function "<«"(X, Y ; Short_Short_Ordinal) return Boolean renames Cgs_SSOrd_LE 

function ">" (X, Y : Short__Short_Ordinal) return Boolean renames Cgs_SSOrd_GT 

function ">—"(X, Y : Short_Short_Ordinal) return Boolean renames Cgs_SSOrd_GE 


-- Base set of functions for Short__Ordinal 

function Cgs_SOrd__Add (X, Y : Short_Ordinal) return Short_Ordinal; 
function Cgs_SOrd_Sub (X, Y Short_^Ordlnal) return Short_Ordinal; 
function Cgs_SOrd_Mul (X, YShort_Ordlnal) return Short_Ordinal; 
function Cgs_SOrd_Div (X, Y : Short__Ordinal) return Short_Ordinal; 

function Cgs__SOrd_LT (X, Y : Short_Ordlnal) return Boolean; 

function Cgs_SOrd_LE (X, Y : Short_Ordinal) return Booleaa; 

function Cgs_SOrd_^GT (X, Y : Short_Ordinal) return Boolean; 

function Cgs__SOrd_GE (X, Y : Short_Ordinal) return Boolean; 

function "+" (X, Y : Short_Ordlnal) return Short_Ordinal renames Cgs_SOrd_Add 

function (X, Y : Short_Ordlnal) return Short_Ordinal renames Cgs_SOrd_Sub 

function (X, Y : Short_Ordlnal) return Short_Ordinal renames Cgs SOrd_Mul 

function "/" (X. Y : Short_Ordinal) return Short_Ordinal renames Cgs SOrd_Div 

function "<" (X, Y : Short_Ordinal) return Boolean renames Cgs_SOrd_LT; 
function "<-"(X, Y : Short_Ordinal) return Boolean renames Cgs_SOrd LE; 


3-38 


UG.2109N-Vl.l(SPARCj960) 17DEC92 










LRM Annotations 


Package System 


function ">" (X, Y : Short^Ordinal) return Boolean renames Cgs S0rd_GT; 
function Y : Short^^Ordinal) return Boolean renames Cgs SOrd GE; 


Base set of functions for Ordinal 


function 

Cgs_Ord__Add 

(X. Y : 

Ordinal) 

return 

Ordinal 



function 

Cgs_Ord^Sub 

(X. Y : 

Ordinal) 

return 

Ordinal 



function 

Cgs Ord Mul 

(X, Y : 

Ordinal) 

return 

Ordinal 



function 

Cgs Ord 

_Dlv 

(X. Y : 

Ordinal) 

return 

Ordinal 



function 

Cgs_Ord_LT 

(X. Y : 

Ordinal) 

return 

Boolean 



function 

Cgs_Ord_LE 

(X. Y : 

Ordinal) 

return 

Boolean 



function 

Cgs_Ord_GT 

(X, Y : 

Ordinal) 

return 

Boolean 



f\snction 

Cgs_Ord_GE 

(X. Y : 

Ordinal) 

return 

Boolean 



function 

"+" (X. 

Y ; 

Ordinal) 

return 

Ordinal 

rename s 

Cgs_Ord_ 

_Add 

function 

<x. 

Y : 

Ordinal) 

return 

Ordinal 

renames 

Cgs_Ord 

[Sub 

function 

(X. 

Y : 

Ordinal) 

return 

Ordinal 

renames 

Cgs_Ord 

‘MuI 

function 

V" (X. 

Y : 

Ordinal) 

return 

Ordinal 

renames 

Cgs_^Ord 

'Div 

function 

"<" (X, 

Y : 

Ordinal) 

return 

Boolean 

renames 

Cgs__Ord 

'lT; 

f^lnction 

"<-"(X. 

Y : 

Ordinal) 

return 

Boolean 

renames 

Cgs_Ord 

[lE; 

function 

">" (X. 

Y : 

Ordinal) 

return 

Boolean 

renames 

Cgs Ord 

GT; 

f\]nctlon 

">-"(X, 

Y : 

Ordinal) 

return 

Boolean 

renames 

Cgs_^Ord_^GE; 


>> Base set of fiinctlons for Long_Ordlnal 


function Cgs__LOrd__Add (X, Y : Long__Ordinal) 
function Cgs LOrd Sub (X, Y : Long Ordinal) 


function Cgs__LOrd_LT 
function Cgs_LOrd_LE 
function Cgs_LOrd_GT 
function Cgs_LOrd_GE 


(X, Y : Long_Ordinal) 
(X, Y : Long_Ordinal) 
(X, Y : Long^Ordlnal) 
(X, Y : Long^^Ordinal) 


return Long__Ordinal, 
return Long__Ordinal; 
return Boolean; 
return Boolean; 
return Boolean; 
return Boolean; 


function (X, Y 
function (X, Y 
function "<" (X. Y 
function "<-"(X, Y 
function ">" (X, Y 
function ">-"(X. Y 


Long_Ordinal) retxim Long_Ordinal renames Cgs_LOrd_Add; 
Long_Ordinal) return Long_Ordinal renames Cgs_LOrd_Sub; 
Long__Ordinal) return Boolean renames Cgs_LOrd_LT; 
Long_Ordinal) return Boolean renames Cgs_LOrd_LE; 
Long_Ordinai) return Boolean renames Cgs_LOrd_GT; 
L6ng_0rdinal) return Boolean renames Cgs_LOrd_GE; 


-- Conversion functions for Ordinal types 

function Cgs_SSOrd_LOrd ( X : Short_Short_Ordinal ) retxim Long_Ordinal; 
function Cgs_SOrd_LOrd ( X : Short_Ordinal ) return Long__Ordinal; 
function Cgs_Ord_LOrd ( X : Ordinal ) return Long_Ordinal; 
function Cgs_^LOrd_SSOrd ( X : Long_Ordlnal ) return Short_Short_Ordinal; 
function Cgs__LOrd__SOrd < X : Long_Ordinal ) return Short_Drdinal; 
function Cgs__LOrd__Ord ( X : Long_Ordlnal ) return Ordinal; 

function Convert ( X : Short_Short_Ordinal ) return Long_Ordinal 
renames Cgs_SSOrd_^LOrd; 


UG-2109N-V1.1(SPARCJ960) 17DEC92 


3-39 











Package System 


TeteGen2 for SPARCxi960 


function Convert 
renaaes 
function Convert 
function Convert 
renames 
function Convert 
renames 
function Convert 


( X : Short_^Ordinal ) return Long__Ordinal 
Cgs_SOrd_LOrd; 

( X : Ordinal ) rettim Long_Ordinal renames Cgs_Ord_LOrd; 
( X : Long_Ordinal ) return Short_Short_Ordinal 
Cgs_LOrd_SSOrd; 

( X : Long_Ordinal ) return Short_Ordinal 
Cgs_LOrd_SOrd; 

( X : Long_Ordinal ) return Ordinal renames Cgs_LOrd_Ord; 


function Cgs__Str_Ord ( X : String ) return Ordinal: 
function Cgs_Str^LOrd ( X ; String ) return Long_Ordinal; 


function Convert ( X : String ) return Ordinal renames Cgs_Str_Ord; 
function Convert ( X : String ) return Long__Ordinal renames Cgs__Str__LOrd; 

-- NOTE: If the strings in these convert calls are not manifest 

constants, a runtime call will be generated to calculate 
the value associated with the string. 


-- The following set of functions are exported to simplify conversion 
-- between the different address types and conversions between address 
-- types and scalar t 3 rpes. 


.. Simple CAST operation of an ordinal to a linear address 

function CGS_Ord_LA (X : Ordinal) return Linear__Address; 
function CGS_Int_^LA (X : Integer) return Linear_^Address; 

function Convert (X : Ordinal) return Linear^Address renames CGS_Ord_LA; 
function Convert (X : Integer) return Llnear_Address renames CGS_Int_LA; 


-- Performs a CVTADR in extended mode and a simple MOV in protected mode. 

function CGS_Ord^Addr (X : Ordinal) return Address; 
function CGS_Int_Addr (X : Integer) return Address; 

function Convert (X : Ordinal) return Address renames CGS_Ord_Addr; 
function Convert (X ; Integer) return Address renames CGS_Int_Addr; 


Simple CAST operation of a linear address to an ordinal 


function CGS__lA^Ord (X : Linear_Address) return Ordinal; 
function CGS_LA^Int (X : Linear_Address) return Integer; 


function Convert (X 
function Convert (X 


Linear^Address) return Ordinal renames CGS__LA_Ord; 
Llnear^Address) return Integer renames CGS_LA_Int; 


3-40 


UG-2109N.Vl.l(SPARC.i960) 17DEC92 




LRM Annotations 


Package System 


-- Retxums the offset field of a vitual address in extended mode and the 
linear address passed In protected mode. 

fimction CGS_Addr_Ord <X : Address) return Ordinal; 
function CGS_Addr_Int (X : Address) return Integer; 

ftmctlon Convert (X : Address) return Ordinal renames CGS_Addr_Ord; 
function Convert (X : Address) return Integer renames CGS__Addr_Int; 


-- Address conversion routines to perform all legal address conversions 

allowed In extended mode. These functions are simple move operations 
in protected mode. 

function CGS_LA__Addr (X ; Linear_Address) return Address; 
function CGS_AD_^Addr (X ; AD_Address) return Address; 
fimction CGS_Addr_AD (X ; Address) return AD_Address; 

function Convert (X : Linear_Address) return Address renames CGS__LA_Addr; 

.. CVTAOR in extended mode, simple MOV in protected mode, 
function Convert (X : AD_Address) return Address renames CGS__AI)_^Addr; 

-• Returns a VIRTUAL address with the passed in AD and a zero offset, 
function Convert (X : Address) return AD_Address renames CGS_Addr_AD; 

-- Returns the AD part of the passed in VIRTUAL address. 


-• Add Y to offset field in X in extended mode and ADDO in protected mode. 

f\mctlon CGS_^Addr_Plus_Ord (X: Address; Y: Ordinal) return Address; 
function CGS_Addr_Plus_Int (X: Address; Y; Integer) return Address; 

function "+" (X : Address; Y : Ordinal) return Address 
renames CGS_Addr_Plus_Ord; 

function "+" (X : Address; Y : Integer) return Address 
renames CGS Addr Plus Int; 


-- Subtract Y from the offset in X in extended mode and SUBO in protected 

function CGS_Addr_Subtract_Ord (X : Address; Y : Ordinal) return Address; 
function CGS_Addr_Subtract__Int (X : Address; Y : Integer) return Address; 

function (X : Address; Y : Ordinal) return Address 
renames CGS_^Addr__Subtract__Ord; 
fTxnctlon (X ; Address; Y : Integer) return Address 
renames CGS Addr Subtract Int; 


-- Add Y to X and return the result; ADDO Y,X,X. 

function CGS_LA_Plus_Ord (X : Linear_Address; Y ; Ordinal) 
return Linear Address; 


UG-2109N-Vl.l(SPARCa960) 17DEC92 


3-41 




Package System 


TeieGen2 for SPARCxi960 


function CGS_LA__Plus_Int (X : Lln8ar_Address, Y : Integer) 
return Llnear_Address; 

function "+" (X : Llnear^Address; Y : Ordinal) return Llnear_Address 
renames CGS_LA_Plus__Ord; 

function "+" (X : Llnear_Address; Y ; Integer) return Linear_Address 
renames CGS LA Plus Int; 


Subtract Y from X and return the result; SUBO Y.X,X. 

function CGS__LA_Subcract_Ord (X : Linear^Address; Y : Ordinal) 
return Llnear_Address; 

function CGS__LA_Subcract_Int (X : Linear_Addres$; Y ; Integer) 
return Llnear_Address; 

function (X : Linear_Address; Y ; Ordinal) return Linear_Address 
renames CGS_LA_Subtract_Ord; 

function (X : Linear_Address; Y : Integer) return Linear_Address 
renames CGS LA Subtract Int; 


-- Relational operations on address types needs to be supported. 

-- Note, unordered comparisons are supported by default. 

function CGS_Addr_LT <X, Y : Address) retxim Boolean; 
function CGS__Addr__LE (X, Y : Address) return Boolean; 
function CGS__Addr_GT (X, Y : Address) return Boolean; 
function CGS_Addr_GE (X, Y : Address) return Boolean; 

function "<" (X, Y : Address) return Boolean renames CGS_Addr_LT; 
function "<“"(X, Y ; Address) return Boolean renames CGS_^Addr__LE; 
function ">" (X, Y : Address) return Boolean renames CGS_Addr_GT; 
function ">""CX, Y : Address) return Boolean renames CGS_Addr_GE; 

function CGS_^LA_LT (X, Y : Linear_Address) return Boolean; 
function CGS_^LA_LE (X, Y : Llnear__Address) return Boolean; 
function CGS_LA_GT (X, Y : Linear_Address) return Boolean; 
function CGS_LA_GE <X, Y : Linear_Address) return Boolean; 

function "<" (X, Y : Linear_Address) return Boolean renames CGS_LA_LT 
function "<-"(X, Y : Linear_Address) return Boolean renames CGS_LA_LE 
function ">" (X, Y : Llnear_Address) return Boolean renames CGS_LA_GT 
function ">-"(X, Y : Llnear_Address) return Boolean renames CGS_LA_GE 

function CGS_AD_LT (X, Y : AD__Address) return Boolean; 
function CGS_AD_LE (X, Y : AD_Address) return Boolean; 
function CGS_A3_GT (X, Y : AD__Address) return Boolean; 
function CGS__AD”ge (X, Y : AD^Address) return Boolean; 

function "<" (X, Y : AD__Address) return Boolean renames CGS_AD_LT: 
function "<-"(X, Y : AD__Address) return Boolean renames CGS_AD_LE: 
function ">" (X, Y : AD Address) retxim Boolean renames CGS_AD_GT; 


3<42 


UG-2109N-Vl.l(SPARC.i960) 17DEC92 








LRM Annotations 


Package System 


function Y : AD_Address) return Boolean renames CGS_AD GE; 


-- CALL SUPPORT 


type Subprograin_Entry Is 

-- Value returned by the implementation-defined 'Subprogram_Entry 

-- attribute. 

record 

OFFSET : Ordinal; 

DOMAIN_AD : Mixed_Word; 

end record; 

type Subprogram_Value is 

-- Value returned by the implementation-defined 'Subprogram_Value 
-- attribute. The attribute is not defined for subprograms with 
-- parameters, or functions, 
record 

Proc_addr : Address; 

Parent_frame : Address; 
end record; 


private 

type Memory is 
record 
null; 

end record; 


end System; 


System.Label 

The System.Label meta-function is provided to allow you to address objects by a 
linker-recognized label name. This fiinction takes a single string literal as a 
parameter and returns a value of System Address. The function simply returns 
the run-time address of the appropriate resolved link name, the primary purpose 
being to address objects creat^ and referenced from other languages. 

• When used in an address clause, System.Label indicates.that the Ada 
object or subprogram is to be referenced by a label name. The actual 
object must be created in some other unit (normally by another 
language), and this capability simply allows you to import that object and 
reference it in Ada. Any explicit or default initialization will be applied 
to the object. For example, if the object is declared to be of an access 


UG-2109N-Vl,l(SPARCi960) 17DEC92 


3-43 






TeleGen2 characteristics 


TeleGen2 for SPARCxi960 


type, it will be initialized to NULL 

• When used in an expression, System-Label provides the link time 
address of any name, such as a name for an object or a subprogram. 

3.10.4. (4) Restrictions on representation clauses 

Representation clauses are fully supported with the following exceptions: 

• Enumeration representation clauses are supported for all enumeration types 
excqjt Boolean types. 

• Record representation clauses are supported except for records with 
dynamically-sized components. 

• Pragma Pack is supported except for dynamically-sized components. 

3.10.5. (5) lmplementation*generated names 

TeleGen2 has no implementation-generated names. 

3.10.6. (6) Address clause expression interpretation 

An expression that appears in an object address clause is interpreted as the 
address of the first storage unit of the object. 

3.10.7. (7) Restrictions on unchecked conversions 

Unchecked programming is supported except for unchecked type conversions 
where the destination type is an unconstrained record or array type. 

3.10.8. (8) Implementation-dependent characteristics of the I/O 
packages 

Text_IO has the following implementation-dependent characteristics; 
type Count Is range 0.,(2 ** 31)-2; 

subtype Field Is Integer range 0..1000: 

The standard run-time sublibrary contains preinstantiated versions of 
Text_IO.Integer_IO for types Short_Short_^Integer, Shon_Integer, and Integer, 
and of Text_IO.Float_IO for types Float, Long_Float, an^Long Long Float. Use 
the following packages to eliminate multiple instantiations of Text_IO packages: 

Short_Short_Integer_Text_IO 
Short_Integer_Text_ro 
Integer_Text_To 
Float lO 


3-44 


UG-2109N-VL1(SPARC4960) 17DEC92 





LRM Annotations 


TeleGen2 characteristics 


Long_^noat__Toct_IO 

Long_Long_Float_Text_IO 


UG-2109N-Vl.l(SPARCi9«0) 17DEC92 


3-45 





SCN-4/I960 PREVALIDifflON 


ATIACHMENTF 


ATTACHMENT F: PACKAGE STANDARD INFORMATION 

For this target system the numeric types and their properties are as follows; 

INTEGER: 


size 

= 32 

first 

= -2147483648 

last 

= +2147483647 


SHORT_INTEGER: 


size = 16 

first = -32768 

last = +32767 


SHORT_SHORT_INTEGER: 

size = 8 

first = -128 

last = +127 


FLOAT: 

size 

digits 

’first 

last 

machine_radix 

machine_mantissa 

machine_emin 

machine_emax 

LONG_^FLOAT: 

size 

digits 

’first 

last 

machinejradix 

machinejnantissa 

machine_emin 

machine_emax 


*32 

*6 

=-3.40282E+38 
* +3.40282E+38 
= 2 
= 24 
= -125 
= +128 


= 64 
= 15 

= -1.79769313486232E+308 
= +1.79769313486232E+308 
= 2 
= 53 
= -1021 
= +1024 


30NOV92 


Page 18 





SUN-4/i960 PREVALIDiOlON 


AmCHMENTF 


LONG_LONG_FLOAT: 

96 
18 

-1.18973149535723177E +4932 
+ 1.18973149535723177E +4932 
2 
64 

-16381 
+16384 

DURATION: 


size 

digits 

’first 

last 

machiQe_radix 
mach ine_mantissa 
machine^emin 
machise emax 


size = 32 

delta = 6.10351562500000E-005 

first = -86400 

last = +86400 


30NOV92 


Page 19 








SUN-4/iS60 PREVALIDmON 


ATTACHMENT G 


Compiler Option Information 
B TESTS; 

ada -«-O D -q -L <test_name> 


Option 

Descriptioa 

■da 

invoke Ada compiler 

-u 

update library after each aource 

-OD 

perform optimizadona 

-q 

suppreaa information measagea 

-L 

generate interspersed source-error listing 

<l«t_niune> 

Mtna of Ada source file to be compiled 


Non-B Non-FamUy TESTS: 

ada -u -O D -q -m <main_unit> -P ^rograin_desc_file > <test_name> 
apre -c <config_fiIe > <xcf_file > 


Option 

Description 

ada 

invoke Ada compiler 

-u 

update library ai^ each source 

-OD 

perform optimizations 

-q 

siqrpreas information messages 

-m 

produce executable code for <main_unit> 

<niain unit> 

name of main Ada compilation unit 

-P 

specify program desciipticm file 

<progTam_deac fUe> 

name of program deaciiption file 

<te8t name> 

name of Ada source file to be compiled 

apre 

invoke preloader 

-c 

specify configuratioa file 

<con£g_file> 

name of configuradoo file 

<xcf_fle> 

XCoff formatted file used u input 


30NOV52 










SnN-4/t9«0 PREVAUDAnON 


ATTACHMENTG 


Compiler Option loformation continued 

Non-BFamUy TESTS: 

ada -u -O D -q <test_name> 

ald-P <prograin_desc_file> <main_uiiit> 

apre -c <confij;_file > <xcf_fae > 


OpdoQ 

DeacriptiaD 

ada 

invoke Ada onnpiler 

-u 

gpdata library after each aouzce 

-OD 

perform optimuatioos 

-q 

•uppreaa infonnatioo meaaagea 

<taat naiDe> 

name of Ada aourca file to be cxnnpiled 

aid 

tnV^Ce 

-P 

^jecify program deacriptioa file 

< program^deac^file > 

name of program deacriptioD file 

<Q)jin unit> 

name of main Ada compilatioo unit 

apre 

invoke preloader 

-c 

apecify coofiguratioo file 

<ocnfig_file> 

name of configuiatioo file 

<xcf_fle> 

XCoff formatted file need aa input 


LINK: 

ald-P <4)rogram_.desc_fiIe> <main_unit> 


Option 

Deacription 

aid 

-P 

< program_deac_file > 
<main_unit> 

invoke T itilmr 

apecify program deacripdoa file 
name of program deacripdoa file 
name of main Ada compilatioo mut 


30NOV92 


Fkge22 






SCN-4/i960 PREVALID/fflON 


ATTACHMENTG 


Optimization Level D: 

The optimizer switch *-0 D* turns on full optimization within the compiler. The 
following list is a set of optimizations performed: 

Removal of imnecessaiy temponries 

Efficient catenation operatioiis 

Null anrny comparison 

Optimized compatibility check 

In^jioved record layout 

Variant record sizes in arrays 

Aggregate literal initializatioa for composites 

Out parameter transformations 

Initialization ten^lates for special record variants 

Optimai basic block ordering 

Optimized usage of expression intermediates 

Direct utilization of scalar targets 

Calculate sizes in storage units 

Optimize overlap setting 

Parameter reordering 

Arithmetic strength reduction 

Optimized composite operations 

Case statement generation 

Object code emission 

Full use of addressing modes 

Reach reduction 

Small conqxKite values 

Boolean expression reduction 

Optimal subprogram ordering 

Semi-open inlinin g 

Interprocedural analysis 

Subprogram inlining 

Collection optimization 

Value propagation 

Range analysis and substitution 

Check removal 

Test Pushing 

Control flow and unreachable code elimination 
Check test pushing 
Dead code eUmination 
Constant folding 

Common subexpressitj^ recognition 

Register allocation 

Reach reduction 

Lifetime minimization 

Loop invariant code motion 

Strength reduction of loop mduction variables 

Loop counter reduction 

Tail recursion elimination 

Instruction scheduling 


30NOV92 


Phge23 







SUN-4ri960 PREVALIDAnON 


ATTACHMENTG 


Program Description Fik 

The program description file is used as input to the Linker using the -P switch. 
Following is an example of the program description file: 

use Receiver_Main; 
program <> is 

— Symbol Definitions 

Program_Start_Address = 16# 40000000# ; 

_TSOS_Program_Start_Address := Program_Surt_Addrcss; 
Ada$unhandled_exception 0; 

— Temporary definitions 

env_ram_disk_area ;= 0; 

begin 

stack (16# 8000#); 
domain Main_Program is 
entry; 
begin 

heap (16# 40000#); 
region 0 at 16# 1000# is 
begin 
null; 

end region; 
region 1 is 
begin 

include (ofin/numwg_sup); 

- Common bag of stuff that has to go in every domain containing Ada code 

include (ofin/env96p_MC); 
include (sec/ENV) 
include (ofin/ordinalasm); 
include (offn/cgs960); 
include (sec/cgs); 

include (offn/dummies); 

end region; 
end; 
end; 


30NOV92 


Page 24 








SDN-4/i9«0 FREVALID/fflON 


AmCHMENfTG 


Configuration 

The configuration file is used as input to the Preloader using the -c switch. Following is 
an example of the configuration file: 

Define Memory (Name = > ■*, 

"Address = > 16# 10200000#. Length = > 16# 00200000#); 

Assign_Object (Name => TnainjirogramJlEGIONO", Index =>4); 

Assign_Object (Name => toain_programJlEGIONr, Index => 5); 

Assign^Object (Name => TROGRAM", Index => 3^; 

A$sign_Object (Name => ^ainjirogramDOMAIN", Index => 37); 


30NOV92 








APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACvc. 
The meaning and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_LEN--also listed here. These values are expressed 
here as Ada string aggregates, where "V" represents the maximum input-line 
length. 


Macro Parameter 


Macro Value 


$MAX IN LEN 200 -- Value of V 


$B1G_ID1 

(1. 

•V-l «> 'A', 

V 

= > ' 1' ) 

$BIG_ID2 

(1. 

.V-1 => ’A' , 

V 

'2' ) 

$BIG_ID3 

(1. 

.V/2 => 'A') 

& 

'3' & 



(1..V-l-V/2 

<s> 

'A' ) 

$B1G_1D4 

(1. 

.V/2 => 'A') 

& 

' 4 ' & 



(1..V-l-V/2 

*> 

'A' ) 

$BIG_INT_LIT 

(1. 

.V-3 => '0') 

& 

"298" 

$BIG_REAL_LIT 

(1. 

.V-5 -> ' 0' ) 

& 

"690.0" 

$BIG_STRING1 

/ I* / 

& (1..V/2 =5 

• ' A' ) & ' 

$BIG_STRING2 

tut 

& (1..V-l-V/2 

*> 'A') 

$BLANKS 

(1. 

.V-20 ) 




$MAX_LEN_INT_BASED_IiITERAL 

”2:" & (1. .V-5 -> '0' ) & "11; " 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 -> '0') & "F.E;" 

$MAX_STRING_LITERAL "CCCCCCC10CCCCCCCC20CCCCCCCC30CCCCCCCC40 

CCCCCCCC5 0CCCCCCCC6 0CCCCCCCC7 0CCCCCCCC8 0 
CCCCCCCC90CCCCCCC100CCCCCCC110CCCCCCC120 
CCCCCCC130CCCCCCC140CCCCCCC1SOCCCCCCC160 
CCCCCCCl7 OCCCCCCCl8 OCCCCCCCl90CCCCCC19 9" 


A-1 






MACRO PARAMETERS 


The following taQjle lists all of the other macro parameters and their 
respective values. 

Macro Parameter Macro Value 

$ACC_SI2E 32 

$ALIGNMENT 4 

$COUNT_LAST 2_147_483_646 

$DEFAULT_MEM_SIZE 2147483647 

$DEFAULT_STOR_UNIT 8 

$DEFAULT_SYS_NAME TELEGEN2 

$DELTA_DOC 2#1.0#E-31 

$ENTRY_ADDRESS INTERRUPTl 

$ENTRY_ADDRESS1 INTERRUPT2 

$ENTRY_ADDRESS2 INTERRUPT3 

$FIELD_IAST 1000 

$FILE_TERMINATOR ASCII.EOT 

$FIXED_NAME KO_SUCH_TYPE 

$FLOAT_NAME LONG_LONG_FLOAT 

$FORM_STRING 

$FORM_STRING2 "CANNOT_RESTRICT_FILE_CAPACITY" 

$ GREATER_THAN_DURATION 

100 _ 000.0 

$ GREATER_THAN_DURATION_BASE_XAST 

131 073.0 

$GREATER THAN_FLOAT_BASE_LAST 

3.9E+35 

$GREATER_THAN_FLOAT_SAFE_LARGE 

l.OE+38 

$GR£ATER_THAN_SHORT_FLOAT_SAFE_lARGE 

0.0 ~ 

$HIGH_PRIORITY 31 

$ILLEGAL_EXTERNAL_FILE_NAME1 

BADCHAR*'/% 


A-2 





MACRO PARAMETERS 


$ILLEGAL_EXTERNAL_FILE_NAME2 

/NONAME/DIRECTORY 

$INAPPROPRIATE_LINE_LENGTH 

-X 

$ INAPPROPRIATE_PAGE_L.ENGTH 

-1 

$INCLUDE_PRAGMA1 PRAGMA INCLUDE ("A28006D1.ADA") 

$INCLUDE_PRAGMA2 PRAGMA INCLUDE (■’B28006E1. ADA" ) 

$INTEGER_FIRST -2147483648 

$INTEGER_LAST 2147483647 

$INTEGER_LAST_PLUS_1 2147483648 

$INTERFACE_LANGUAGE C 

SLESS_TRAN_DURATION -100_000.0 

$LESS_THAN_DURATION_BASE_FIRST 

-131_P73.0 

$LINE_TERMINATOR ASCII.CR 

$LOW_PRIORITY 0 

$MACHINE_CODE_STATEMENT 

raci'(addi,rO,rO,rO); 

$MACHINE_CODE_TVPE mci 

$MANTISSA_DOC 31 

$MAX_DIGITS 15 

$MAX_INT 2147483647 

$MAX_INT_PLUS_1 2_147_483_64e 

$MIN_INT -2147483648 

$NAME ' SHORT_SHORT_INTEGER 

$NAME_LIST TELEGEN2 

$NAME_SPECIFICATI0N1 /tmp/X2120A 

$NAME_SPECIFICATI0N2 /tn5}/X2120B 

$NAME_SPEC1FICATI0N3 /trnp/X3119A 

$NEG_BASED_INT 16#FFFFFFFE# 

$NEW_MEM_SIZE 2147483647 

$NEW SYS NAME TELEGEN2 


A-3 






MACRO PARAMETERS 


$ PAGE_TERMINATOR 

ASCII.FF 

$RECORX3_DEFINITION 

RECORD NULL; 

$RECORD_NAME 

INSTRUCTION 

$TASK_SIZE 

32 

$TASK_STORAGE_SIZE 

4096 

STICK 

0.01 

$VARIABLE_ADDRESS 

ADDRESSI 

$VARIABLE_ADDRESS1 

ADDRESS2 

$VARIABLE_ADDRESS2 

ADDRESS3 







APPENDIX B 


COMPILATION SYSTEM AND LINKER OPTIONS 


The compiler and linker options of this Ada implementation, as described in 
this Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and not 
this report. 


to 


B-1 





TELESOFT 


TeleGen2 Ada Development System 
for SPARC Systems to 
Embedded i960 Targets 


Compiler Command Options 


OPT-2130N-V1.1 (SPARC,960) 27JAN93 
TeleGen2 Version 4.1.1 


Copyright e 1993, TeleSoft. 
Ail rights reserved. 




TeleSoft is a registered trademark of TeleSoft 
RJSCA^™ and TeleGeii2^ are trademarks of TeleSoft. 

SPARC* is a re^tered trademark of SPARC 

International, Inc Products bearing SPARC trademarks are based on an 


archit^^e developed by Sun Miaosystems, Inc 

UNIX is a registered trademark of UNIX System Laboratories, Inc 


RESTRICTED RIGHTS LEGEND 

Use, duplication, or disclosure by the Government is subject to restrictions as set forth in subparagraph 
(c) (1) Qi) of the rights in Technical Data and Computer Software clause at DEAR 252227-7013, or 
FAR S2.^-14, ALT IH and/or FAR 52227-19 as set forth in the applicable Government Contract. 


TeleSoft 

5959 Cornerstone Court West , 
San Diego, CA 92121-9819 
(619) 457-2700 
(Contractor) 




aid (Ada Linker) 


TeleGen2 for SPARCx68K 


1.1 ada (Ada Compfler). 2 

1.2 aid (Ada Linker) . 








Compiler Command Options 


This document descrflies the options available for invoking the TeleGen2 compiler (via the 
ada command) and the TeleGen2 linker (via the aid command). 


OPr-2l30N-Vl.l(SPARC560) 27JAN93 


1 






ada (Ada Compiler) 


TeleGen2 for SPARCx68K 


1.1. ada (Ada Compiler) 

The ada command invoices the TeIeGen2 Ada Compiler. Unless you specify 
otherwise, the compiler’s front end, middle pass, and code generator are executed 
each time the compiler is invoked. You may, however, invoke the front end only, 
to check for syntax and semantic errors. 

The syntax of the ada command is shown below. 


ada I<option>. .. ] <iiiput> 


<optlon> One of the cations available with the command Compiler options 
fall into four categories. 


Library search ^(ibfile, -t(emplib 

Execution/ouqjut Enable debugging: Hd(ebug 

Abort after errors: -E(rror_abort 

Run front end only: -<(rTors_only 

Suppress checks: ^(nhibit 

Keep source: •K(e^_source 

Keqj intermediates: -k(eep_intermediates 

Compfle, then link: •m(ain 

Optimize code: -0(ptimize, -G(raph, -I(nline 

Update library for multiple files: •u(pdate_invoke 

Include execution profile: -x(ecution_profile 


listing Output source plus errors: -l^ist 

Output errors: -F(ile_only_errs, -j(oin 

Error context: -C(ontatt 

Output assembly: -S(“asm_listing" 

Other >q(uiet, -V(space_size, -v(erbosc 


<input> The Ada sotirce file(s) to be compfled It may be: 


• One or more Ada source files, for example: 

/ua «r/J ohn/axaatpl • 

Prog^A.taxt 
closrc/calc^mea.ada 
calcio.ada ayprog.ada 

*.ada 


If more than one file is ^)ecified the names must be separated 
by a space. 


2 


OFr-2130N-Vl.l(SPARC.960) 27JAN93 









Command Options 


(Ada Compiler) ada 


• A file containing names of files to be compfled Such a file 
must have the extension “.ilfeach name in the CJe must be on 
a separate line. It is generally wise to limit the number of files 
in the input list to 10 — 20 if all files contain specifications and 
to no more than 5 if all contain bodies (assuming one unit per 
file). You can find more information on using input-list files in 
the TeleGtnl User Guide. 

• A combination of the above. 


Compiler deffaults. Compiler defaults arc set for your convenience. In most 
cases you will not need to use additional options; a simple “ada < input > ’’ is 
sufficient However, options are included to provide added flexibility You can, 
for example, have the compiler quickly check the source for syntax and semantic 
errors but not produce object code {-^rrors_only] or you can compDe, bind, and 
lirtk a main program with a single compiler invocation [-m(ain]. Other options are 
provided for other purposes. 

The options available with ada appear below in alphabetical order. 


>C(ontext 

When an error message is sent to stderr, it is helpful to see the lines of the 
source program that surround the line containing the error. These lines 
provide a context for the error in the source program and help to clarify the 
nature of the error. The -C option controls the number of source lines that 
surround the error. The format of the option is 

-C <n> 

where <n> is the number of source context lines output for each error. The 
default for <n> is 1. This parameter spiecifies the total number of lines 
ouqjut for each error (including the source line that contains the error). The 
first context line is the one immediately before the line in error; other context 
lines are distributed before and after the line in error. 


-<](ebug 

To use the d^ugger, you must compile and link with the -d(ebug eption. 

This is to make sure that a link map and debugging information are put in the 
Ada library for use by the debugger. Using -d(ebug ensures that the 
intermediate forms and debugging information required for debugging are 
not deleted. 

Performamce note: 

While the compflation time overhead generated by the use of -d(ebug is 
minimal, retaining this optional information in the Ada Ubrary increases 
the space overhead. To sec if a unit has been compiled with the -d(ebug 
option, use the als command with the -X(tended option. Debugger 


OPT-2130N-VL1(SPARC.%0) 27JAN93 


3 





ada (Ada Compiler) 


TeieGen2 for SPARCx68K 


information odsts for the unit if the “dbg_info” attribute appears in the 
listing for that unit. 

-E(iTor_abort 

The -E(rror_abort cation allows you to set the maximum number of errors 
(syntax errors and semantic errors) that the compiler can encounter before it 
alxDrts. This option can be used with all other compiler options. 

The format of the option is 
-E <n> 

where <n> is the maximum number of errors allowed (combined counts of 
syntax errors and semantic errors). The default is 999; the minimum is 1. If 
the number of errors becomes too great during a compilation, you may want 
to abort the compilation by typing <ctrl>-C. 

-e(rrors__only 

The'^rTors_only option instructs the compfler toperform syntactic and 
semantic analysis of the source program without generating Low Form and 
object code. TTiat is, it the front end only, not the middle pass and code 
generator. TTiis means that only front end errors are detected and that only 
the High Form intermediates are generated Unless you use the 
*k(eep_intermediates option along with -e, the High Form intermediates are 
deleted at the end of compilation; in other words, the Ubrary is not updated 

The -e(rTors_oniy option is typically used during early code development 
where execution is not required and speed of compilation is important Since 
orvly the front end of the compiler is invoked when -e is used -f is 
incompatS}le with ada options that require processing beyond the front end 
phase of compilation. Such options indude, for example, >0(ptimize and 
-d(ebug. If •« is not used (the default situation), the source is compiled to 
object code (providing no errors are found). Object code is generated for the 
^jecification and body and inserted into the working sublibrary. 


-F(lle_only_eiTS 

The -f option is used to produce a listing containing only the errors 
generated during compOation; source is not induded The ouput is sent to 
<£ile> J, where <£ile> is the base name of the input file. If iiput to the ada 
command is an input-list file (<file> .21), a separate listing file is generated 
for each source file listed in the input f2e. Each resulting listing file has the 
same name as the parent file, except that the extension “ J” is appended ~F 
is incompatible with -L. 


4 


OPT-2130N-V1.1(SPARC,960) 27JAN93 





Command Options 


(Ada Compiler) ada 


•G(raph 

The -G(raph option is valid only with -©(ptimize. 

This option generates a call graph for the unit being optimized The graph is 
a file containing a textual representation of the call graph for the unit being 
t^timized For each subprogram, a list is generated that shows every 
subprogram called by that subprogram. By default, no graph is generated 

The graph is output to a file named <unit>.grt where <unit> is the name of 
the unit being optimized The structure and interpretation of call graphs is 
addressed in the Global Optimizer chapter of the TeleCen2 User Guide. 


-I(nlinejist 

The -I(niine_list option is valid only with •0(ptimize. 

This option allows you to inline subprograms selectively, The format of the 
option is 

-I <£lle> 

where <file> is a file that contains subprogram names. The file must contain 
subprogram names in a specific form as noted below. 

— A list of subprograms to be inlined each separated by a comma or 
line feed then 

— A semicolon or a blank line dien 

— A list of subprograms that are not to be inlined each separated by a 
comma or line feed 

Tabs and comments are not allowed If there is no semicolon or blank line, 
the subprograms are considered to be visible. If you have no visible units to 
inline, use a semicolon to mark the beginning of the hidden-subprogram list 
Inline lists are commonly set up with one name per line. 

Each subprogram name in the list is in the form shown below. 

[<unlt>.]<subprograa> 

The unit name indicates the location of the subprogram declaration, not the 
location of its body. If a unit name is not supplied any matching subprogram 
name (regardless of the location of its declaration) w^ be affected For 
example, the list 

test; testing.test 

indicates that all subprograms named Test should be marked for inlining 
excq)t for those declared in either the specification or the body of the 
compilation unit Testing. 

The first list of subprograms will be processed as if there had been a pragma 


OPT-2130N.V1.1(SPARC,960) 27JAN93 


5 






ada (Ada Compiler) 


TeleGen2 for SPARCx68K 


Inline in the source for them. The second list of subprograms will negate any 
Inline pragmas (including those applied by the first list) and will also prevent 
any listed subprograms from being automatically inlin^ (see A/a suboption 
pair, in the di^ussion of -0(ptimize). 

The ability to exempt otherwise qualified subprograms from automatic 
inlining gives you greater control over optimization. For example, a large 
{H’ocedure called from only one place within a case statement might overfbw 
the branch ofiEset limitation if it were inlined automatically. Including that 
subprogram’s name in the second list in the list file prevents the problem and 
still allows other subprograms to be inlined 

Since the Low Form contains no generic templates, pragma Inline must 
appear in the source in order to afreet all instantiations. However, specific 
instantiations can be afrected by the inline lists. The processing of the names 
is case insensitive. 

If you do not use •/, the optimizer automatically inlines any subprogram that 
is: (1) called from only one pl^ (2) considered small by the optimizer, or 
(3) tail recursive. Such optimizations are explained in detail in the Global 
Optimizer chapter of the TeUGenl User Guide. 


•i(nhibit 

The -i(nhibit cation allows you to suppress, within the generated object code, 
certain run-time checks, source line references, and subprogram name 
information. The -i(nhibit option is equivalent to adding pragma 
SuppressjAll to the beginning of the declarative part of each compilation u it 
in a file. 

The format of the option is 
-1 <suboption>[...] 

where < suboption > is one or more of the single-letter suboptions listed 
bdow. When more than one suboption is used the suboptions appear 
together with no separators; for example, “-i In”. 

1 [line_info}.' Suppress source line information in object code. 

By default, the compiler stores source line information in the 
object code. However, this introduces an overhead of 6 bytes for 
ea^ line of source that causes code to be generated Thus, a 
1000-line package with no instatiations or inlining may have up to 
6000 bytes of source line information. 

When source line information is suppressed exception tracebacks 
indicate the ofEset of the object code at which the exception occurs 
instead of the source line number. 


6 


OPT.2130N-VL1(SPARC,960) 27JAN93 







Command Options 


(Ada Compiler) ada 


n [naine_info] Sufpress subprogram name information in objea 
code. 

By default, the compiler stores subprogram name information in 
object code. For one compflation unit, the extra overhead (in 
bytes) for subprogram name information is the total length of ail 
subprogram names in the unit (including middle pass-generated 
subprograms), plus the length of the compilation unit name. For 
space-criticai a^^lkations, this extra space may be unaccqjtabie. 

When subprogram name information is suppressed, the traceback 
indicates the o&ets of the subprogram calls in the calling chain 
instead of the subprogram names. 

c [checks] Suppress run-time checks — elaboration, overflow, 
storage access, discriminant, division, index, length, and range 
checks. 

While run-time checks are vital during development and are an 
important asset of the language, they introduce a substantial 
overhead This overhead may be prohibitive in time-critical 
applications. 

a [all] Suppress source line information, subprogram name 

information, and run-time checks. In other words, a (=inhibit all) 
is equivalent to Inc. 

Below is a command that tells the compiler to inhibit the generation of 
source line information and run-time checks in the object code of the units in 
sampU.ada. 

ada -▼ -i Ic sample.ada 


4(oln 

The -j(oin option writes errors, warning messages, and information messages 
that are generated during compilation back into the source file. Such errors 
and messages'appear in the file as Ada comments. The comments thus 
generated can help facilitate debugging and commenting your code. UnlOce 
the other listing options (-L, -5, and -F), the -/ option docs not produce a 
separate listing, since the information generated is written into the source 
file. 

-K(eep_source 

This option tells the compiler to take the source file and store it in the Ada 
library. When you need to retrieve your source file later, use the axt 
command 


OPT-2130N-V1.1(SPAJICJ60) 27JAN93 


7 





ada (Ada Compiler) 


TeieGen2 for SPARCx68K 


-k(eepJnteiTnediate$ 

The -k(eep_^intenneciiate$ option allows you to retain certain intermediate 
code forms that the compiler otherwise discards. 

By default, the compiler deletes the Hi^ Form and Low Form intermediate 
representations of all compiled secondary units from the working sublibraiy. 
Deletion of these interme^te forms can significantly decrease the size of 
sublibraries — typically 50% to 80% for multi-unit programs. 

Some of the information within the intermediate forms may be required later, 
which is the reason -k(eep_intermediates is available with ada. For example. 
High Form is required if the unit is to be referenced by the Ada cross- 
referencer (<nr). In additiort, both the debugger and optimizer require 
information that is saved within intermediate forms. 

To verify that a unit has been compiled with the -k(eep_intermediates option, 
use the als command with the -X( tended option. If the unit has been 
compiled with -k, the listing will show the attributes high_form and low_form 
for the unit 

-L(iSt 

The -L(ist option instructs the compiler to output a listing of the source being 
compiled, interspersed with error information (if any). The listing is output 
to <file> .1, where <file> is the name of the source ffle (minus the 
extension). If <file>.l already exists, it is overwritten. 

If input to the ada command is an input-list file (< file > .ilf), a separate listing 
file is generated for each source file listed in the input file. Each resulting 
listing file has the same name as the parent file, except that the extension “.1” 
is appended Errors are interspersed with the listing. If you do not use -L 
(the default situation), errors are sent to stderr only, no listing is produced. - 
L is incompatible with -F. 

•AQtstWe 

The -l(ibfile (q)tion is one of the two library-search options; the other is 
-t(emplib. Both of these options allow you to specify the name of a library 
file other than the default, Ublstalb. The two options are mutually exclusive. 

The format of the •l(ibfile option is 
-1 <£il»> 

where <file> is the name of a library file, which contains a list of 
sublibraries and optional comments. The file must have the extension “.alb”. 
The first sublibrary is always the working subUbrary, the last subUb’rary is 
generally the basic run-time sublibrary. Note that comments may be included 
in a library file and that each sublibrary listed must have the extension “.sub”. 


S 


OPT-2130N-V1.1(SPARC.960) 27JANW 





Command Options 


(Ada Compiler) ada 


Hfn(ain 

This qjtion tells the compiler that the unit specified with the option is to be 
used as a main program. After ail files named in the input specification have 
been compiled, the compiler invokes the the Ada linker to bind and link the 
program with its extended family. By default an “execute form” (EF) load 
mo^e named < unit > .ef is left in the current directory. 

The format of the option is 
-m <unit> 

where <unit> is the name of the main unit for the program. If the main unit 
has already been compiled, make sure that the body of the main unit is in the 
current working sublibrary. 

Note: You may specify options that are sj>ecific to the binder/linker on the 
ada corrunand line if you use the -m(ain option. In other words, if 
you use -m, you may also use -o, -a, or any of the other aid options 
except -Z(“iink only”. For example, the command 

ada -▼ -B valcoBa -o nev.af -a .opt sasplc.ada 

instructs the compiler to compfle the Ada source file sample.ada, 
which contains the main program unit Welcome. After the file has 
been compiled, the compiler calls the Ada linker, passing to it the o 
and -a options with their respective arguments. The -a option tells 
the liiiker to use the commands specified in the cation file .opt to 
direct the linking process; an option file is requir^ for linking. The 
linker produces an “execute form” load module of of the unit, 
placing it in file new.ef as requested by the linker’s -o option. 

If you use an option with -m(ain that is common to both ada and aid, 
the (^tion serves for both compiling and linking. For example, using 
-S with “ada -m” produces two assembly listings-onc from 
compflation, one from elaboration. 


-0(ptimize 

The optimize^ operates on Low Form, the intermediate code representation 
that is outpu^by the middle pass of the compiler. 

When used on the ada corrunand line, -CXptiiTuze causes the compiler to 
invoke the global optimizer during compilation; this optimizes the Low Form 
generated by the middle pass for the unit being compOedL The code 
generator takes the optimized Low Form as input and produces more 
^cient object code. 

Note: We recommend that you do not attempt to compile with qptimization 
untO the code being compOed has been fully debugged and tested, 
because using the optimizer iivcreases compflation time. Please refer 
to the TeleGtn2 User Guide for information on optimizing strategies. 


OPT-2130N-V1.1(SPARC560) 27JAN93 


9 








ada (Ada Compiler) 


TeleGen2 for SPARCx68K 


The format of the option is 
-0 <suboptions> 

where < suboptions > is a string composed of one or more of the 
single-letter subc^tions listed below. < suboptions > is required 

The suboptions may appear in any order (later suboptions supersede 
earlier suboptions). The subc^tion string must not contain any 
characters (including spaces or tabs) that are not valid suboptions. 
Examples of valid subeptions are: 

-0 pRlA 
-0 pa 


10 


OFr-2130N-Vl.l(SPAJlC.960) 27JAN93 




Command Options 


(Ada Compiler) ada 


Tible of optimizer suboptioas 


p 

[c^timize with parallel tasks] Guarantees that none of subprograms 
being optimaed will be called from parallel tasks. P allows data 
mafi^ing (^timizations to be made that could not be made if multiple 
instances of a sut^rogram were active at the same time. 

p 

[optimize without parallel tasks] Indicates that one or more of the 
subprograms being optimized might be called from parallel tasks. 

This is a “safe" suboption. DEFAULT 

R“ 

[optimize with external recursion] Guarantees that no interior 
subprogram will be called recursively by a subprogram exterior to the 
unit/coUection being optimized Sui^rograms may call themselves or 
be called recursively by other subprograms interior to the 
unit/collection being optimized 

r 

[optimize without external recursion] Indicates that one or more of 
the subprograms interior to the unit/collection being optimized could 
be called recursively by an exterior subprogram. This is a “safe” 
suboption. DEFAULT 

I 

[enable inline expansion of subprograms] Enables inline expansion of 
those subprograms marked with an Inline pragma or introduced by 
thecompfler. DEFAULT 

i 

[disable inline aqpanston] Disables all inlining. 


[enable automatic inline etpansion] If the I subopiion is also in eflfea 
(I is the default), A enables automatic inline expansion of any 
subprogram not marked for inlining, that is, any subprogram that is 
(1) called from only one place, (2) considered to be small by the 
optimizer, or (3) tail recursive. If t is used as well, inlining is 
prohibited and A has no effect DEFAULT 

• 

[disable automatic inline expansion] Disables automatic inlining. Ifi 
is used as well, inlining is prohibited and a has no effect 

"ivT 

[perform maximum optimization] Specifies the maximum level of 
optimization; it is equivalem to “PRIA”. This suboption assumes that 
the program has no subprograms that are called recursively or by 
parcel tasks. 


[perform safe c^timizations] Specifies the default “safe” level of 
optimization; it is equivalent to “prlA”. It rq)resents a combination of 
optimizations that is safe for all compilation units, including those with 
subprograms that are called recursivety or by parallel tasks. 


OPT.2130N-V1.1(SPARC5«0) 27JAN93 


11 



ada (Ada Compiler) 


TeieGen2 for SPARCx68K 


>q(uiet 

By default, information messages are output even if the -v(erbose option is 
not used The -q(uiet option allows you to suppress such messages. Using 
-v(erbose alone gives error messages, banners, and information messages. 
Using -v(erbose with -q(uiet gives error messages and banners, but 
suppresses information messages. The option is particularly useful during 
optimization, when large numbers of information messages are likely to be 
output 

-S(“asmjlsting” 

The -5 option instructs the compiler to generate an assembly listing. The 
listings are generated in the working directory. If more than one unit is in the 
file, separate listings are generated for each unit The format of the cption is 

-S <subopclon> 

where < suboption > is either “a” or “e”. 

a [assembly] Generate a listing that can later be used as input to an 
assembler. The assembly file is named < unit > .s if it is a body or 
< unit>_.s if it is a specification. 

e [ejrtended] Generate a paginated extended assembly listing that 
includes code ofiEsets and object code. The assembly file is named 
<unit>.eif itisabodyor <unit>_.eifitisa^)ecificaiion. 

The listing generated consists of assembly code intermixed with 
source code as comments. If input to the ada command is an 
input-list file (<file> .HI), a separate assembly listing file is 
generated for each unit contained in each source file Listed in the 
input file. Since -5 is also an aid option, if you use -5 along with 
•m(ain, an assembly listing is also output during the binding 
process. 

•t(efnpiib 

The •t(emplLb option js one of the two libraiy-search options; the other is 
•l(ibfile. Both of these options allow you to select a set of sublA>raries for use 
di^g the time in which the command is being executed The two options 
are mutually exclusive. 

The format of the •t(eniplib option is 

>c <sublib>[,...] 

where <subl3)> is the name of a sublibrary. The name must be prefaced by 
a path name if the sublibrary is in a directory other than the current 
directory. The first sublibrary listed is the working sublibrary by definition. 

If more than one sublibrary is listed the names must be sqiarated by a 
comma Single or double quotes may be used as delimiters. 


12 


OPT.2130N.V1.1(SPARC.960) 27J/VN93 





Command Options 


(Ada Compiler) ada 


The argument string of the -t(empUb option is logically equivalent to the 
names of the sublibraries listed in a library file. So instead of using 

-I vorkllb.alb 

you could use •t(emplib and specify the names of the sublibraries listed in 
worklib.alb (separated by commas) as the argument string. 


-u(pdateJnvoke 

The -u(pdate_invoke (short for “-u(pdate_after_invocation”) option tells the 
compiler to i^^te the working sublibrary only after all files submined in that 
invocation of ada have compfled successhiUy. The option is therefore useful 
only when compiling multiple source files. 

If the compfler encounters an error while is in effect, the library is not 
updated, even for files that compile successfully. Furthermore, all source 
files that follow the file in error are compiled for syntactic and semantic 
errors only. 

If you do not use the -u(pdate_lib option, the library is updated each time one 
of the files submitted has compiled successfully. In other words, if the 
compOer encounters an error in any unit within a single source file, all 
changes to the working sublibrary for the erroneous unit and for all other 
units in that file are discarded. However, Ubrary updates for units in previous 
or remaining source files are unaffected 

Since using -u means that the library is updated only once, a successful 
compilation is faster with -u than without it On the other hand if the 
compiler finds an error when you’ve used -u, the library is not updated even 
when the other source files compile successfully. The implication is that it is 
better to avoid using -u unless your files are likely to be error free. 

•V(space_size 

The •V(space_size option allows you to q>ecify the size of the working space 
for TeleGen2 components that q>erate on library contents. The format of 
the option is 

-V <v«ltte> 

where the option parameter is specified in 1-Kb^e blocks; it must be an 
integer value. The default value is 4000. The upper limit is 2,097,152. 

Larger values generalfy inwove performance but increase physical memory 
requiremoits. Please read the section on actuating the size of the virtual 
i^}ace in Ch^ter 2 of TeleCerQ Propammefs Reference Manual for more 
information. 


OPT-2130N-V1.1(SPARC960) 27JAN93 


13 




ada (Ada Compiler) 


TeleGen2 for SPARCx68K 


•v(erbosa 

The -v(erbose option is used to di^lay messages that inform you of the 
progress of the command’s execution. Such messages are prefaced by a 
banner that identifies the component being executed If -v is not used, the 
banner and progress messages are not output However, information 
messages such as those output by the optimizer may still be output whether 
-v(erbose is used or not 

-x(ecution_profiie 

The •x(ecutionj)rofile option is used to obtain a profile of how a program 
executes. Tbe option is availabie with ada, aid, and aopt. Using -x with ada 
or aopt causes the code generator to insert special run>time code into the 
generated object Using -x with old causes the binder to link in the run-time 
support routines that will be needed during execution. 

Important: If you have compiled any code in a program with the 

-x(ecution_profile option, you must also use -x when you bind 
and link the program. Refer to the Profiler chapter of the 
TeleG€n2 User Guide for more information on profiling. 


14 


OPT-2130N-VU(SPARC.960) 27JAN93 





Command Summary 


(Ada Linker) aid 


1.2. aid (Ada Linker) 

The Ada Linker is a component of the TeleGen2 system that allows you to link 
compiled Ada programs in prq>aration for target execution. The linker resolves 
references within the Ada program, the bare target run-time support Ubrary, and 
any imported non-Ada object code. To support the development of embedded 
aii^lications, the liidcer is designed to operate in a variety of modes and to handle 
many types of output format 

The linker is invoked by the aid command; it can also be invoked with the -m(ain 
option of the ada conunand. In the latter case the compiler passes appropriate 
options to the linker to direct its operation. The syntax of the aid command is 
shown below. 


mid [<opcion>...] unit 


<opt ion> One of the options available with the command. 

<unlt> The name of the main unit of the Ada program to be linked. 

Important: When using the aid command, the body of the main 
unit to be linked must be in the working sublibrary. 

The options available with the command, and the relationships among them, are 
shown in the figure below. 

The options available with aid appear below in alphabetical order. 


•A(rray_size 

IhiToption ^>ecifies the amount of internal buffer space, in Kbytes, to be 
allocated for the linker. The format of the option is 

-A <vmlue> 

where <vaiu^ is a value between 1 and 10. The default is 2. Use this 
option only as recommended by Customer Support. 

•B(indjist 

This option is used to generate a listing of the program description file, 
inter^ersed with errors (if any). 

■b(lnd_only 

The -b{ind_only option instructs the linker to not invoke the link phase—in 
otho' words, to generate daboration code only. This option is particularly 
useful when you have adapted your own linker and want to use it in place of 


OPT.2130N-V1.1(SPARC560) rjAN93 


15 






aid (Ada Linker) 


TeleGen2 for SPARCx68K 


the TdeGen2 linker. The option is incompatible with -Z(“link_only.” 

-d(ebug 

This option controls the generation of debug symbol information for use with 
the debugger. A program that is to be nin with the debugger must be linked 
with the -d(ebug option. If supported by the chosen load module format, 
-d(ebug may also cause symbol information to be output in the load module. 
In the standard configuration of the TeleGen2 system, none of the outputs 
support symbol information in the load module. 

-l(ibflle 

The -l(ibfile option is one of the two library-search options; the other is 
-t(empiib. Both of these options allow you to specify the name of a library 
file other than the default, liblstalb. The two options are mutually exclusive. 

The format of the -l(3)file option is 
-1 <file> 

where < file > is the name of a library file, which contains a list of 
sublibraries and optional comments. The file must have the extension “.alb”. 
The first sublibrary is always the working sublibraxy; the last sublibrary is 
generally the basic run-time sublibrary. Note that comments may be included 
in a library file and that each sublibrary listed must have the extension “.sub”. 

•M(ap 

This option is used to request and control a link map listing. The link map 
listing is sent to 

<unlt>.map 

where <unit> is the name of the main program unit (if present), the name 
^)ecifled as the command line parameter, or the name specified as the first 
INPUT option, modified as necessary to form a valid UNIX file 
specification. The format of the link map listing file is described in the 
Linker chapter of the TeleGen2 User Guide. The format of the option is 

-M [<»uboptloh>[... ] ] 

where <sub<^tion> is one or more of the following; 

e [excluded] Insert a list of excluded subprograms into the link map 
listing. 

1 [image] Generate a memory image listing in addition to the map 
listing. The linker writes the image listing to the same file as the 
E’'k map listing. 


1 [locals] Include local symbols in the link map ^bol listing. 


16 


OPT-2130N V1.1(SPARC.960) 27JAN93 








Command Summary 


(Ada Linker) aid 


n [narrow] Limit the width of the link map to 80 characters (the 
default is 132). 

If more than one of the above suboptions is used, they must appear together, 
with no spaces. For example: 

-M ell 

A -M(ap option specified on the command line supercedes a MAP command 
in an option file. 


*o(utput 

T^e -o(utput option is used primarily to specify the file name for the COFF 
file creat^ by the linker. The format is 

-o <file> 

where <file> is the specification for the output file. If <file> does not 
include an extension, the linker will append an extension of “ Jtef’. 


“P(rogram_desc 

This option specifies the name of the program description file. The formal 
of the option is 

-P <file> 

where <£ile> is the name of the file. 

-SC'asmJIstIng” 

The -S option is used to output an assembly Listing from the elaboration 
process. The format of the option is 

-S <auboptlon> 

where < suboption > is either “a” or "e”. 

a [assembly] Generate a listing that can later be used as input to an 
assembler. The assembly file is named < unit > M.s. 

e [extended] Generate a paginated, extended assembly listing that 
includes <x)de offsets and object code. The assembly file is named 
<unit> M.c. 


OPT-2130N.V1.1(SP.\RC360) 27JAN93 


17 






aid (Ada Linker) 


TelrfGen2 for SPARCx68K 


•T(raceback 

The -T(raceback option allows you to specify the callback level for tracing a 
run>time exception that is not handled by an exception handler. The format 
of the option is 

•T <n> 

where <n> is the number of levels in the traceback call chain. The default is 
15. The -T(raceback option is useful only if you receive an Unexpeaed Error 
Condition message. This information may help you diagnose the problem. 


•t(emplib 

The -t(emplib option is one of the two library-search options; the other is 
-l(ibfiie. Both of these options allow you to select a set of sublibraries for use 
during the time in which the command is being executed. Tlie two options 
are mutually exclusive. 

The format of the -t(empUb option is 
-t <subllb>(.... 1 

where <sublib> is the name of a subiibrary. The name must be prefaced by 
a path name if the sublibrary is in a directory other than the current 
direaory. The first sublibrary listed is the working sublibrary by definition. 

If more than one sublibrary is listed, the names must be separated by a 
comma. Single or double quotes may be used as delimiters. 

The argument string of the -t(empUb option is logically equivalent to the 
names of the sublibraries listed in a library file. So instead of using 

-1 vorkllb.alb 

you could use -t(emplib and specify the names of the sublibraries listed in 
worklib.alb (separated by commas) as the argument string. 


-V(space_si2e 

The -V(space_size option allows you to specify the size of the working space 
for TdeGen2 components that operate on library contents. The format of 
the option is ' 

-V <valu*> 

where the option parameter is specified in 1-Kbyte blocks; it must be an 
integer value. The default value is 4000. The upper limit is 2,097,152. 
Larger values generally improve performance but increase physical memory 
requirements. Please read the section on adjusting the size of the virtual 
iqjace in Chapter 2 of TeleCtnl Progrummer’s Reference Manual for more 
information. 


18 


OPT-2130N.Vl.l(SPARCi>60) 27JAN93 





Command Summary 


(Ada Linker) aid 


-v(ert)Ose 

The •v(erbose option is used to display messages that inform you of the 
progress of the command’s execution. Such messages are prefaced by a 
banner that identifies the component being executed. If -v is not used, the 
banner and progress messages are not output. 

•X(ception_show 

By default, unhandled exceptions that occur in tasks are not reported; 
instead, the task terminates sflently. The -X option allows you to specify that 
such exceptions are to be reported The output is similar to that displayed 
when an unhandled exception occurs in a main program. 


•x(ecution_profile 

The •x(ecution_profile option is used to obtain a profile of how a program 
executes. The option is available with ada, aid, and aopt. Using -x with ada 
or aopt causes the code generator to insert special run-time code into the 
generated object Using -x with aid causes the binder to link in the run-time 
support routines that will be needed during execution. These run-time 
support routines record the profiling data in memory during program 
execution and then write the data to two host files,our indprofile.dic, 
via the download line as part of program termination. The files can then be 
used to produce a listing that shows how the program executes. 

Important; If you have compiled any code in a program with the 

•x(ecutionjprofile option, you must also use -x when you bind 
and link the program. Refer to the Profiler chapter of the 
TeleCtn2 User Guide for more information on profiling. 


-Y(“task_8tack" 

The -Y option allows you to alter the size of the task stack. In the absence of 
a represenution specification for task storage_si 2 e, the run time will allocate 
40% bytes of storage for each executing task. -Y specifies the size of the 
basic task stack. The format of the option is 

-Y <v«lrue> 

where < value > is the size of the task stack in S-bit bytes. The default is 
40%. A representation specification for task storage size overrides a value 
supplied with this option. 

-Z(“llnk only” 

Ihis option teUs the linker to skip the binding phase and go directly to the 
link step. It is useful for generating phantom links where the main proram 
may not yet exist Note; unlike other link options, the -Z option cannot be 
p>a«ed with “ada -m”. The option is incompatible with -b(ind_only. 


OPT-2DON.V1.1(SPARC.960) 27JAN93 


19 





aid (Ada Linker) 


TeleGen2 for SPARCx68K 


20 


OPT-2130N.V1.1{SPARC.960) 27JAN93 




APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this Appendix are to compiler documentation and not to this 
report. Implementation-specific portions of the package STANDARD, which 
are not a part of Appendix F, are given on the next two pages. 


C-1 



