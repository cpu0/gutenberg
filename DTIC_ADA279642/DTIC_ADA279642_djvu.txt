ENTATION PAGE 


Poffn Appiwwd 
OPMNo. 


^ C. Jk f ^ *»» ttf im^Bnat. InOkiaing Itw linw to i »w»ii(ing inltuelioni. ftwhi ng wriWing d«u »omo«» gahiit^ 

Mmk 1 J —* inlgniMtien. Sand aanawan U wgiding Uta kutdan aatimaa ar any olhar aapaa o* Ihia ookaoban ol Marmaian, indudi>« 

' a S atviea. DiraJawaa Id» I nt on n alio n Oaat al iani and n apoda. 121» JaWataen Qawa U ghapay. >u>a iao«, Artayen. VA 

11 . OWiaa a Ma n ada m a ra and j udga. Waabingtan. DC 10803. ^ 





940325S1.11348, AVF-: 94ddc500_3 

DDC-I, DACS Sun SPARC/Solaris to 80386 PM Bare Ada Cross Comp .ler 
System, Version 4.6.4 


r.«HiJ>kdiTirdL-1 


National Institute of Standards and Technology 
Gaithersburg, Maryland 





BSfi8fS5 5Sl!*5SSl5 Techrology 

Gaithersburg, Maryland 20899 

USA 



ra'TTT^alrTTWrr.yaTTnra'IfTl 


ING AGENCY NAME(S) AN 

Ada Joint Program Office 
The Pentagon. Rm 3E118 
Washington, DC 20301-3080 


lOrSPONSORING/MONITORING 
AGENCY 



IBUTION/AVAILABIL 


Approved for Public Release; cdistribution unlimited 


(Maximum 

Host: Sun SPARColassic (under Solaris, Release 2.1) 
Target: Intel ISBC 386/116 (bare machine) 



OTIC 

ELECTE I 
MAY2f> 1*1041 


\\W94-15726 


KTiy*::'*' 






17. 

CLASSIFICATnN 

UNCLASSIFED 


EMUSiLiiSZ] 


UNCLASSIFED 


UNCLASSIFED 


S4 5 25 




pTMGflMdbyANSISId. 


ALITY IUo?jSUTiSD I 











































AVF Control Number: NIST94DDC500_3_l.il 
DATE COMPLETED 

BEFORE ON-SITE; 94-03-18 
AFTER ON-SITE: 94-03-28 
REVISIONS: 94-04-11 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 940325S1.11348 
' DDC-I 

DACS Sun SPARC/Solaris to 80386 PM Bare Ada 
Cross Compiler System, Version 4.6.4 
Sun SPARCclassic => Intel iSBC 3B^J/116 (Bare Machine) 


Prepared By: 

Software Standards Validation Group 
Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 





AVF Control Nuaber: NIST94DDC500 3 1.11 


Certiflcato Information 


Th« following Ada implamantation was tested and determined to pass ACVC 
1.11. Testing was completed on March 25, 1994. 


Compiler Name and Version: DACS Sim SPARC/Solaris to 80386 PM Bare 

Ada Cross Compiler System, Version 4.6.4 

Rost Computer System: Sun SPARCclassic running imder Solaris, 

Release 2.1 

Target Computer System: Intel iSBC 386/116 (Bare Machine) 

See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
940325S1.11348 is awarded to DDC-I. This certificate expires 2 years 
after ANSI/MIL-STD-1815B is approved by ANSI. 


This report has been reviewed and is approved. 




Ada Validation Facj 
m Nr. L. Arnold JohpNbn 

Chief, Information Systems Manager, Software Standards 

Engineering Division (ISED) Validation Group 

Computer Systems Laboratory (CSL) 

National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 



Ada V^idMClon Organization 
DirectoxvA^puter 8 Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 


U.S.A. 


AdiiTjoint ProgreuB Office* 

David R. Basel 
Deputy Director, 

Ada Joint Program Office 
Defense Information Systems Agency, 
Center for Information Management 
Washington DC 20301 











N1ST94DDC500_3_1.11 
DECLARATION OF CONFORMANCE 

The following declaration of conformance was supplied by the customer. 
Customer: DDC-I 

Certificate Awardee: DDC-Z 

Ada Validation Facility: National Institute of Standards and 

Technology 

CoK^uter Systems Laboratory (CSL) 

Software Standards Validation Group 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 

ACVC Version: 1.11 


Ada Inclementation: 


Conpiler Name and Version: 


DACS Sun SPARC/Solaris to 80386 PM Bare Ada Cross 
Conpiler System, Version 4.6.4 


Host Con^uter System: 


Sun SPARCclassic running under Solaris, Release 2.1 


Target Computer System: 


Intel iSBC 386/116 (Bare Machine) 


Declaration: 

Z the undersigned, declare that Z have no knowledge of deliberate deviations from the 
Ada Language Standard ANSZ/MZL-STD-1815A ISO 8652-1987 in the implementation listed 
above. 









ificate Awardee Signature 
Conpany DDC-Z 
Title 


Date 









TABLE OF CONTENTS 


CHAPTER 1.1-1 

INTRODUCTION.1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES.2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST MODIFICATIONS.2-3 

CHAPTER 3.3-1 

PROCESSING INFORMATION.3-1 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 


APPENDIX A.A-1 

MACRO PARAMETERS.A-1 

APPENDIX B.B-1 

COMPILATION SYSTEM OPTIONS.B-1 

LINKER OPTIONS.B-2 

APPENDIX C.C-1 

APPENDIX F OF THE Ada STANDARD.C-1 
































CHAPTER 1 


INTRODUCTION 


The Ada Implementation described above was tested according to the 
Ada Validation Procedures [Pro92] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC) . This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to [Pro92]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552). The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield, Virginia 22161 
U.S.A. 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 


Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria, Virginia 22311-1772 

U.S.A. 


1-1 









1.2 REFERENCES 


[A<ia83] _ Manual for the Ada Proaranunina Language . 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

CPro92] Ada Compiler Validation Procedures . Version 3.1, Ada Joint 
Program Office, August 1992. 

[UG89] Ada Compiler Validation Ca pability User's Guide . 21 June 
1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The^CVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units ^re not 
operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is 
compiled and the resulting compilation listing is exzunined to 
verify that all violations of the Ada Standard are detected. Some 
of the class B tests contain legal Ada code which must not be 
flagged illegal by the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values—for example, the 


1-2 








r 


largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 
the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [UG89]). 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


I 

Ada Compiler 


Ada Compiler 
Validation 
Capability (ACVC) 


Ada Implementation 


Ada Joint Program 
Office (AJPO) 


Ada Validation 
Facility (AVF) 


Ada Validation 
Organization (AVO) 

Compliance of an 
Ada Implementation 


The software and any needed hardware that 
have to be added to a given host and target 
computer system to allow transformation of 
Ada programs into executable form and 
execution thereof. 

The means for testing compliance of Ada 
implementations. Validation consisting of 
the test suite, the support programs, the 
ACVC Capability User's Guide and the 
template for the validation summary (ACVC) 
report. 

An Ada compiler with its host computer 
system and its target computer system. 

The part of the certification body which 
provides policy and guidance for the Ada 
certification Office system. 

The part of the certification body which 
carries out the procedures required to 
establish the compliance of an Ada 
implementation. 

The part of the certification body that 
provides technical guidance for operations 
of the Ada certification system. 

The ability of the implementation to pass an 
ACVC version. 


1-3 









Computer System 


Conformity 

Customer 

Declaration of 
Conformance 

Host Computer 
System 

Inapplicable Test 

ISO 

LRM 

Operating System 

Target Computer 
System 


A functional unit, consisting of one or more 
computers and associated software, that uses 
common storage for all or part of a program 
and also for all or part of the data 
necessary for the execution of the program; 
executes user- written or user-designated 
programs; performs user-designated data 
manipulation, including arithmetic 
operations and logic operations; and that 
can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 

Fulfillment by a product, process, or 
service of all requirements specified. 

An individual or corporate entity who enters 
into an agreement with an AVF which 
specifies the terms and conditions for AVF 
services.(of any kind) to be performed. 

A formal statement from a customer assuring 
that conformity is realized or attainable on 
the Ada Implementation for which validation 
status is realized. 

A computer system where Ada source programs 
are transformed into executable form. 

A test that contains one or more test 
objectives found to be irrelevant for the 
given Ada implementation. 

International Organization for 
Standardization. 

The Ada standard, or Language Reference 
Manual, published as ANSI/HIL-STD-1815A 
-1983 and ISO 8652-1987. Citations from the 
LRM take the form ''<section>.<subsection>; 
<paragraph>." 

Software that controls the execution of 
programs and that provides services such as 
resource allocation, scheduling, 
input/output control, and data management. 
Usually, operating systems are predominantly 
software, but partial or complete hardware 
implementations are possible. 

A computer system where the executable form 
of Ada programs are executed. 









a 


validated 


Ada 


Validated Ada 
Compiler 

Validated Ada 
Imp1ementation 

Validation 


Withdrawn Test 


The compiler of 
implementation. 

An Ada implementation that has been 
validated successfully either by AVF testing 
or by registration [Pro92]. 

The process of checking the conformity of an 
Ada compiler to the Ada programming language 
and of issuing a certificate for this 
implementation. 

A test found to be incorrect and not used in 
conformity testing. A test may be incorrect 
because it has an invalid test objective, 
fails to meet its test objective, or 
contains erroneous or illegal use of the Ada 
programming language. 


1-5 






CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 104 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 93-ll>22. 


B27005A 

E28005C 

B28006C 

C32203A 

C34006D 

C35507K 

C35507L 

C35507N 

C355070 

C35507P 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

C37310A 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A54B02A 

C55B06A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

B04008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 






2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Commentaries and commonly referenced in 
the format Al-ddddd. For this implementation, the following tests 
were determined to be inapplicable for the reasons indicated; 
references to Ada Commentaries are included as appropriate. 

The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAXDIGITS: 

C24113L..Y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 


2-1 






C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 

C24113I..K (3 tests) use a line 
exceeds 126 characters. 


C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 

C45621L..Z (15 tests) 

C46012L..Z (15 tests) 

length in the input file which 


C35404D, C45231D, B86001X, C86006E, and CD7101G check for a 
predefined integer type with a name other than INTEGER, 
LONG_INTEGER, or SHORT_INTEGER; for this implementation, there is 
no such type. 

C35713B, C45423B, B86001T, and C86006H check for the predefined 
type SHORT_FLOAT; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with 
a name other than FLOAT, LONG_FLOAT, or SHORT_FLOAT; for this 
implementation, there is no such type. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for 
this implementation, MAX_MANTISSA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLOWS is FALSE for floating point types and the results 
of various floating-point operations lie outside the range of the 
base type; for this implementation, MACHINE_OVERFLOWS is TRUE. 

C4A013B contains a static universal real expression that exceeds 
the range of this implementation's largest floating-point type; 
this expression is rejected by the compiler. 

D56001B uses 65 levels of block nesting; this level of block 
nesting exceeds the capacity of the compiler. 

B86001Y uses the name of a predefined fixed-point type other than 
type DURATION; for this implementation, there is no such type. 

C96005B uses values of type DURATION'S base type that are outside 
the range of type DURATION; for this implementation, the ranges are 
the same. 

CA2009C and CA2009F check whether a generic unit can be 
instantiated before its body (and any of its subunits) is compiled; 
this implementation creates a dependence on generic units as 
allowed by AI-00408 and AI-00506 such that the compilation of the 
generic unit bodies makes the instantiating units obsolete. (See 
section 2.3.) 


2-2 







Cpi009C checks whether a length clause can specify a non-default 
size for a floating-point type; this implementation does not 
support such sizes. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length 
Clauses to specify non-default sizes for access types; this 
implementation does not support such sizes. 


The following 264 tests check operations on sequential, text, and 
direct access files; this implementation does not support external 
files: 


CE2102A..C 

(3) 

CE2102G..H 

(2) 

CE2102K 


CE2102N..Y 1 

(12) 

CE2103C..D 

(2) 

CE2104A..D 

(4) 

CE2105A..B 

(2) 

CE2106A..B 

(2) 

CE2107A..H 

(8) 

CE2107L 


CE2108A..H 

(8) 

CE2109A..C 

(3) 

CE2110A..D 

(4) 

CE2111A..1 

(9) 

CE2115A..B 

(2) 

CE2120A..B 

(2) 

CE2201A..C 

(3) 

EE2201D..E 

(2) 

CE2201F. .N 

(9) 

CE2203A 


CE2204A..0 

(4) 

CE2205A 


CE2206A 


CE2208B 


CE2401A..C 

(3) 

EE2401D 


CE2401E..F 

(2) 

EE2401G 


CE2401H..L 

(5) 

CE2403A 


CE2404A..B 

(2) 

CE2405B 


CE2406A 


CE2407A..B 

(2) 

CE2408A..B 

(2) 

CE2409A..B 

(2) 

CE2410A..B 

(2) 

CE2411A 


CE3102A..C 

(3) 

CE3102F..H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A..C 

(3) 

CE3106A..B 

(2) 

CE3107B 


CE3108A..B 

(2) 

CE3109A 


CE3110A 


CE3111A..B 

(2) 

CE3111D..E 

(2) 

CE3112A..D 

(4) 

CE3114A..B 

(2) 

CE3115A 


CE3119A 


EE3203A 


EE3204A 


CE3207A 


CE3208A 


CE3301A 


EE3301B 


CE3302A 


CE3304A 


CE3305A 


CE3401A 


CE3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A..C 

(3) 

CE3403E..F 

(2) 

CE3404B..D 

(3) 

CE3405A 


EE3405B 


CE3405C..D 

(2) 

CE3406A..D 

(4) 

CE3407A..C 

(3) 

CE3408A..C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE3410C..E 

(3) 

EE3410F 


CE3411A 


CE3411C 


CE3412A 


EE3412C 


CE3413A..C 

(3) 

CE3414A 


CE3602A..D 

(4) 

CE3603A 


CE3604A..B 

(2) 

CE3605A..E 

(5) 

CE3606A..B 

(2) 

CE3704A..F 

(6) 

CE3704M..0 

(3) 

CE3705A..E 

(5) 

CE3706D 


CE37C6F,.G 

(2) 

CE3804A. .P 

(16) 

CE3805A..B 

(2) 

CE3806A..B 

(2) 

CE3806D..E 

(2) 

CE3806G..H 

(2) 

CE3904A. .B 

(2) 

CE3905A..C 

(3) 

CE3905L 


CE3906A..C 

(3) 

CE3906E..F 

(2) 


CE2103A, CE21C3B, and CE3107A use an illegal file name in an 
attempt to create a file and expect NAME_ERROR to be raised; this 
implementation does not support external files and so raises 
USE_£RROR. (See section 2.3.) 

2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 71 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in 


2-3 










the way expected by the original tests. 


B22003A 

B35101A 

B38009B 

B61001R 

B83E01D 

B91002C 

B91002J 

B95077A 

BC1109D 


B26001A 

B37106A 

B55A01A 

B61001W 

B83E01E 

B91002D 

B91002K 

B97103E 

BC1202A 


B26002A 

B37301B 

B61001C 

B67001H 

B850010 

B91002E 

B91002L 

B97104G 

BC1202F 


B26005A 

B37302A 

B61001F 

B83A07A 

B85008D 

B91002F 

B95030A 

BAIOOIA 

BC1202G 


B28003A 

B38003A 

B61001H 

B83A07B 

B91001A 

B91002G 

B95061A 

BAllOlB 

BE2210A 


B29001A 

B38003B 

B61001I 

B83A07C 

B91002A 

B91002H 

B95061F 

BC1109A 

BE2413A 


B33301B 

B38009A 

B61001M 

B83E01C 

B91002B 

B91002I 

B95061G 

BC1109C 


C83030C and C86007A were graded passed by Test Modification as 
directed by the AVO. These tests were modified by inserting 
"PRAGMA ELABORATE (REPORT)before the package declarations at 
lines 13 and 11, respectively. Without the pragma, the packages 
may be elaborated prior to package Report's body, and thus the 
packages' calls to function REPORT.IDENT_INT at lines 14 and 13, 
respectively, will raise PROGRAM_ERROR. 

CA2009C and CA2009F were graded inapplicable by Evaluation 
Modification as directed by the AVO. These tests contain 
instantiations of a generic unit prior to the compilation of that 
unit's body; as allowed by AI-00408 and AI~00506, the compilation 
of the generic unit bodies makes the compilation unit that contains 
the instantiations obsolete. 

BC3204C and BC3205D Were graded passed by Processing Modification 
as directed by the AVO. These tests check that instantiations of 
generic units with unconstrained types as generic actual parameters 
are illegal if the generic bodies contain uses of the types that 
require a constraint. However, the generic bodies are compiled 
after the units that contain the instantiations, and this 
implementation creates a dependence of the instantiating units on 
the generic units as allowed by AI-00408 and AI-00506 such that the 
compilation of the generic bodies makes the instantiating units 
obsolete—no errors are detected. The processing of these tests 
was modified by re-compiling the obsolete units; all intended 
errors were then detected by the compiler. 

CE2103A, CE2103B, and CE3107A were graded inapplicable by 
Evaluation Modification as directed by the AVO. The tests abort 
with an unhandled exception when USE ERROR is raised on the attempt 
to create an external file. This Ts acceptable behavior because 
this implementation does not support external files (cf. AI-00332}. 


2-4 









CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is 
described adequately by the information given in the initial pages 
of this report. 

For technical information about this Ada implementation, contact: 

Forrest Holemon 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 

Telefax: 602-275-7502 

For sales information about this Ada implementation, contact: 

Mike Halpin 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 
Telefax: 602-275-7502 

Testing of this Ada implementation was conducted at the customer's 
site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is appliceJsle or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro92]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were 
withdrawn because of test errors (item b; see section 2.1), those 
that require a floating-point precision that exceeds the 
implementation's maximum precision (item e; see section 2.2), and 
those that depend on the support of a file system—if none is 
supported (item d). All tests passed, except those that are listed 
in sections 2.1 and 2.2 (counted in items b and f, below). 


3-1 







a) 

Total Number of Applicable Tests 

3562 


b) 

Total Number of Withdrawn Tests 

104 


c) 

Processed Inapplicable Tests 

504 


i 

Non-Processed I/O Tests 

0 


e) 

Non-Processed Floating-Point 



i 

Precision Tests 

0 


f) 

Total Number of Inapplicable Tests 

504 

(c+d+e) 

g) 

Total Number of Tests for ACVC 1.11 

4170 

(a+b+f) 

3.3 

TEST EXECUTION 




A magnetic tape containing the customized test suite (see section 
1.3) was taken on>site by the validation team for processing. The 
contents of the magnetic tape were loaded directly onto the host 
computer. 

After the test files were loaded onto the host computer, the full 
set of tests was processed by the Ada implementation. The DDC-I 
Ada downloader runs on the Sun SPARCclassic and is used for 
downloading the executable Images to the target Intel iSBC 386/116 
(Bare Machine). The DDC-I Debug Monitor runs on the target Intel 
iSBC 386/116 (Bare Machine) and provides communi'^'^tion interface 
between the host downloader and the executing rr get Intel iSBC 
386/116 (Bare Machine). The two processes communicate via 
ethernet. 

The tests were compiled and linked on the host computer system, as 
appropriate. The executable images were transferred to the target 
computer system by the communications link described above, and 
run. The results were captured on the host computer system. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B for 
a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this test 
were: 

-list 

Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. The listings 
examined on-site by the validation team were also archived. 


3-2 




APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing 
the ACVC. The meaning and purpose of these parameters are 
explained in [UG89]. The parameter values are presented in two 
tables. The first table lists the values that are defined in terms 
of the maximum input-line length, which is the value for 
$MAX_IN LEN—also listed here. These values are expressed here as 
Ada strrng aggregates, where "V represents the maximum input-l rne 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 126 — Value of V 

$BIG_ID1 (1..V-1 «> ‘A*, V *> '1') 

$BIG_ID2 (1..V-1 => ‘A*, V => '2') 

$BIG_ID3 (1..V/2 => ‘A') & '3' & (1..V-1-V/2 «> 'A') 

$BIG_ID4 (1..V/2 *> 'A') & '4' & (1..V-1-V/2 => 'A') 

$BIG_INT_LIT (1..V-3 => *0') & ••298" 

$BIG__REAL_LIT (1. .V-5 => •O^) & "690.0" 

$BIG_STRING1 •""• & (1..V/2 => •A^) & •""• 

$BIG_STRING2 •""• & (1..V-1-V/2 => •A^) & •!• & •""• 

$BLANKS (1..V-20 => • •) 

$MAX_LEN_INT_BASED_LITERAL 

"2:" & (1..V-5 => •O^) & "11:" 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => •O^) & "F.E:" 

$MAX_STRING_LITERAL •""• & (1..V-2 *> •A^) & •"••• 


A-1 








The following table contains the values for the remaining 
macro parameters. 

Macro Parameter Macro Value 


ACC_SIZE 

ALIGNMENT 

COUNT_LAST 

DEFAULT_MEM_SIZE 

DEFAULT_STOR_UNIT 

DEFAULT_SyS_NAME 

DELTA_DOC 

ENTRY_ADDRESS 

ENTRY_ADDRESS1 

ENTRY_ADDRESS2 

FIELD_LAST 

FILE_TERMINATOR 

FIXED_NAME 

FLOAT_NAME 

FORM_STRING 

FORM STRING2 


48 

2 

2_147_483_647 

16#1_0000_0000# 

16 

IAPX386_PM 

2#1.0«E-31 

(140,0) 

(141,0) 

(142,0) 

35 

ASCII.SUB 

NO_SUCH_FIXED_TYPE 

SHORT_SHORT_FLOAT 

H N 


•• CANNOT_RESTRICT_FILE_CAPACITY •• 
GREATER_THAN_DURATION : 75_000.0 

GREATER_THAN_DURATION_BASE_LAST : 131_073.0 

GREATER_THAN_FLOAT_BASE_LAST : 16#1.0#E+32 

GREATER_THAN_FLOAT_SAFE_LARGE : 16 # 5. FFFF_F0 #E+ 31 

GREATER_THAN_SHORT_FLOAT_SAFE_LARGE: 1.0E3 08 
HIGH_PRIORITY : 31 

ILLEGAL_EXTERNAL_FII.E_NAME1 : \NODIRECTORY\FILENAME 

ILLEGAL_EXTERNAL_FILE_NAME2 : 

THIS-FILE-NAME-IS-TOO-LONG-FOR-MY-SYSTEM 
INAPPROPRIATE_LINE_LENGTH : -1 

INAPPROPRIATE_PAGE_LENGTH : -1 

INCLUDE PRAGMAl : 


PRAGMA INCLUDE ('•A28006D1.ADA'') 


INCLUDE_PRAGMA2 

INTEGER_FIRST 

INTEGER_LAST 

INTEGER_LAST_PLUS_1 

INTERFACE_LANGUAGE 

LESS_THAN_DURATION 

LESS_THAN_DURATION_BASE_FIRST 

LINE_TERMINATOR 

L0W_PRI0RITY 

MACHINE_CODE_STATEMENT 

MACHINE_CODE_TYPE 
MANTISSA DOC 


PRAGMA INCLUDE ("B28006E1.ADA'’) 

: -2147483648 
: 2147483647 

: 2_147_483_648 
: ASM86 
: -75_000.0 
: -131_073.0 
: ASCII.CR 
: 0 

MACHINE_INSTRUCTION•(NONE,m_NOP); 
: REGISTERTYPE 
: 31 


A-2 














MAX_DIGITS 

MAX_IKT 

MAX_INT_PLUS_1 

MIN_INT 

NAME 

NAME_LIST 

NAME_SPECIFICATI0N1 

DISK$AWC_2: 
NAME_SPECIFICATI0N2 

DISK$AWC_2; 
NAME_SPECIFICATI0N3 

DISK$AWC_2: 
NEG_BASED_INT 
NEW_NEM_SIZE 
NEW_STOR_UNIT 
MEW SYS NAME 


9223372036854775807 
9223372036854775808 
-9223372036854775808 
SHORT_SHORT_INTEGER 
IAPX386 PM 


:_2:[ CROCKETTL. ACVCl 1. DEVELOPMENT ] X212 OA 

:_2; [CROCKETTL.ACVCl 1.DEVELOPMENT]X2120B 

• 

:_2: [CR0CKETTL.ACVC11.DEVEL0PMENT]X3119A 

: 16#FFFF_FFFF_FFFF_FFFF# 
: 16#1_0000_0000# 

: 16 

: IAPX386 PM 


PA6E_TERMINAT0R 
RECORD_DEFINITION 
RECORD_NAME 
TASK SIZE 


ASCII.FF 

RECORD MULL;END RECORD; 

NO_SUCH_MACHINE_CODE_TYPE 

32 


TASK_STORAGE_SIZE 
TICK 

VARIABLE_ADDRESS 
VARIABLE_ADDRESS1 
VARIABLE_ADDRESS2 
YOUR PRAGMA 


1024 

0.000_000_062_5 
(16#0#,16#44#) 
(16#4«,16«44«) 
(16«8«,16«44«) 
EXPORT OBJECT 


A-3 














APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 






5 THE ADA COMPILER 


The Ada Compiler compiles all prognm units within the specified source file and inserts the 
generated objects into the currem program library. Compiler options are provided to allow the 
user control of optimization, run-time checks, and compiler input and output options such as list 
files, configuration files, the program library used. etc. 

The input to the compiler consists of the source file, the configuration file (which controls the 
format of the list file), and the compiler options. Section S.l provides a list of all compiler 
options, and Section 52 describes the source and configuration files. 

If any diagnostic messages are produced during the comfnlation. they are output on the diagrx^c 
file and on the currem output file. The diagnostic file and the diagnostic messages are described 
in Section S.3.2. 

Output consists of an objea {daced in the program library, diagnostic messages, and optional 
listings. The configuration file and the compiler options specify the format and contents of the 
list information. Ou^t is described in Section 5.3. 

The compiler uses a program library during the compilation. The compilation unit may refer to 
units from the program library, and an internal representation of the compilation unit will be 
included in the program library as a result of a successful compilatiott The program library is 
described in Oupter 3. Section 5.4 briery describes how the Ada compiler uses the library. 


5.1 Invoking the Ada Compiler 

invoke the Ada compiler with thr following command to the SunOS shell: 

S ada {<option>} <source-file-naine> 
where the options and parameters are: 


35 



DACS*80x86 User's Guide 
Ada Compiler 


OPTION DESCRIPTION REFERENCE 


•(no)auto_iiiUiie 

Specifies whether local subprograms should be 
inline expanded. 

5.1.1 

•check 

Controb nm-iime checks. 

5.1.2 

•conflfuration.nic 

Specifies the configuration file used by the 
compiler. 

5.1.3 

•[noldcbog 

Includes symbolic debugging infonnuion in 
program Library. Does not include symbolic 
infonnation. 

5.1.4 

•[no]flxpoint_rounding 

Generates fixed point rounding code. Avoids fixed 
point rounding code. 

5.1.5 

•{nolfloat, allowed 

Flags generation of float instructions as 
error if selected. 

5.1.6 

•(iw]Iibrary 

Specifies program litnry used. 

5.1.7 

•[nojlist 

Writes a source listing on the list file. 

5.1.8 

•{nojoptlmize 

Specifies compiler optimization. 

5.1.9 

•(nojprogess 

Displays comber i»ogress. 

5.1.10 

•[noheref 

Creates a cross referenre listing. 

5.1.11 

•[nojsave source 

Copies source to program library. 

5.1.12 

•(no]target_debug 

Includes Intel debug information. Does not include 
Intel debug infoimatiott 

5.1.13 

•unit 

Assigns a specific unit number to the compilation 
(must be free and in a sublibraty). 

5.1.14 

•recompile 

Interpret the file name as a compibdon unit body 



that must be recompiled from library. 

5.1.15 

•specification 

With •recompile interpret file name as a 



compilation unit specification rather than body. 

5.1.16 


Examples: 

$ ada 'liat tastprog 

This example compiles the source file testprogJida and generates a list file with the name 
tcstprogJis. 

$ ada •lihraxy ^p_lil>xaxy tast 

This example compiles the source Hie tcstada into the library myjibrary. 

Defnilt values exist for most options as indicmed in the following sections. Option names may 
be abbreviated (characters omitted from the ri^) as long as no ambiguity arises. 


36 









OACS*80x86 User’s Guide 
Ada OMnpiler 


<aottrce>nieHuiiie> 

The Ada compQer has one mandatory parameter that should specify the Ada source file. 

This parameter specifies the text file containing the source text to be compiled. If the file type 
is omitted in the source file specificatiotu the file type ‘’.ada* is assumed by default 

The allowed format of the source text is described in Section 52.1. 


Below follows a description of each of the available optitms to the invocation of the Ada 
compiler. 


5.1.1 •(tMlauto_inline 

•autojnline local | global 
•iioaitfo_iiilinc (default) 

This option specifies whether subprograms should be inline expanded. The inline expansion only 
occurs if the subprogram has less than 4 object declarations and less than 6 statements, and if the 
subprogram fulfills the requirements defin^ for pragma INLINE (see Section C2.3). LOCAL 
specifies that only inline expansion of locally defined subprograms should be done, while 
(jLOBAL will cause inline expansion of all subprograms, including subprograms from other units. 


5.12 -check 


-check [ <keyword> * ON | OFF { ,<kerword> « ON | OFF } } 
-check ALLaON (default) 


•check specifies which run-time checks should be performed. Setting ' run-dme check to ON 
enaUes the check, while setting it to OFF disaUes the check. All nm-tuue checks are enabled by 
default The following explicit checks will be disabled/enabled by using the name as <keywonl>: 


ACCESS 

ALL 

DISCRIMINANT 

ELABORATION 

INDEX 

LENGTH 

OVERFLOW 

RANGE 

STORAGE 


Check for access values being non NULL. 
All checks. 

Checks for discriminated fields. 

Checks for subprograms being elaborated. 
Index check. 

Array length check. 

Explicit overflow checks. 

Checks for values being in range. 

Checks for sufficient storage available. 


37 




DACS*8(}x86 User’s Guide 
Ada Compiler 


S.U <cQnngiintion_file 


•conflguration_fllc <fUe-spcc» 

•configuration-flie config (default) 

This option specifies the configuration file to be used by the compiler in the current compilation. 
The configuration file aUows the user to fonnat compiler listings, set error limits, etc. If the 
option is omitted the configuration file conflg located in the same directory as the Ada compiler 
is used by default Section 52.2 contains a description of the configuration file. 


5.1.4 •(noldebug 
•debug 

•nodebug (default) 

Generate debug infoimation for the compilation and store the information in the program library. 
This is necessary if the unit is to be debugged with the DDC-I Ada Symbolic Cross Debugger. 
Note that the program must also be linked with the •debug option, if the program is to be 
debugged with the DDC-I Ada Symbolic Cross Debugger. See Section 6.S.11. 


5.1.5 •{nojfixpoint^rounding 

•flxpoint^rounding (default) 

•nofixpoint_rounding 

Normally all inline generated code for fixed point MULTIPLY and DIVIDE is rounded, but this 
may be avoided with •iroflxpoint_rounding. Inline code is generated for all 16 bit fixed poim 
typ« and for 32 bit fixed point types, when the target is 80386PM or 80486PM. 


5.1.6 •[no]float_allowed 

•float^allowed (default) 

•nofltwt^allowcd 

Boat instruction generation may be flagged as errors, if •nofloat is selected. This is for use in 
systems, where no floating point processor (nor emulator) is available. Notice that TEXTJO uses 
floats in connection with FLOATJO and FDCEDJO. 


38 





OACS-8Qx86 User’s Guide 
Ada Cornier 


S.1.7 •Ubrary 

•library <fllc^SDco 

•library SadaJIbrary (default) 

This option specifies die cunem subiibrary that will be used in the compilation and will receive 
the objea when the compilation is complete. By specifying a cunent sublibrary, the current 
program library {current subiibrary aid aicesiors iqi u root) is also implicitly specified. 

If this option is omitted, the sublibtaiy designated by die environmental variable aria-library is 
used as the cunent sublibraiy. Section S.4 describes how the Ada compiler uses the library. 


5.1.8 -[noniat 


•Ust 

•nolist (default) 

•list sprafies that a source listing will be produced. The source listing is written to the list file, 
which has the name of the source file with the extension Jis. Section 5.3.1.1 contains a description 
of the source listing. 

If •nolist is acdve. no source listing is produced, regardless of LIST pragmas in the program or 
diagnostic messages produced. 


5.1J9 -optiniae 

•optimize ( <keyword> s on | off { ,<keywor<l> s on | off} ] 

•optimize ailsolT 

This option specifies which opdmizations will be performed during code generation. The possible 
keywords are: (casing is inelevant) 


all 

All possible optimizations are invoiced. 

check 

Eliminates superfluous checks. 

cse 

Performs common subexpression elimination including commem 
address expressions. 

fctlproc 

Change function calls returning objects of constrained array types 
or objects of record types to procedure calls. 

reordering 

Transforms named aggregates to positional aggregates and named 
parameter associations to positional associations. 

stack-hei^t 

Perforats stack height reductions (also called Aho Ullman 
reordering). 

block 

Optimize block and call frames. 


Setting an optimization to on enables the optimization, while setting an optimizatirm to off disables 
the optimizatioa All optimizations are disabled by deSnilt In addition to die optional 
t^ximizations. the compiler always performs the following optimizations: constant folding, dead 
code elimination, and selection of optimal jumps. 


39 






DACS-80xS6 User’s Guide 
Ada Compiler 


5.1.10 -(nolprogress 


•progress 

•noprogrcss (default) 

When this option is given, the compiler will output dau about which pass the compiler is 
currently tunning. 


5.1.11 -[nobtrcf 
-xref 

•noxref (default) 

A cross-reference listing can be requested by the user by means of the option -xref. If the -xref 
option is given and no severe or fatal errors are found during the compilation, the cross-reference 
listing is written to the list file. The ooss-refetence Usting is described in Section ?. 


5.1.12 -(nolsave-source 

•save_,source (default) 

•nosave^source 

When -sive-source is specified, a copy of the compiled source code is placed in the program 
library. If •nosive_sourcc is used, source code will not be retained in the program library. 

Using -nosave_Jource. while lelping to keep library sizes smaller, does affect the operation of 
the tecompiler, see Chapter * for mote details. Also, it will not be possible to do symbolic 
debugging at the Ada source code level with the DACS-80x86 Symbolic Ada Debugger, if the 
source code is not saved in the library. 


5.1.13 -(noltarget-debug 

•targetjdebug 
-nourgk_debug (default) 

Spedftes whether symbolic debug information on standard OMF is included in the objea file. 
Currently the linker does not support the OMF debug infonnation. 

This option may be used when debugging with standard OMF tools (i.e., PICE). 


40 






DACS-80x86 User’s Guide 
Ada OMnpiler 


S.1.14 •unit 


•unit s <unit_nunaber> 

The specified unit number will be assigned lo the compilation unit if it is free and it is a legal 
unit number for the liluaiy. 


5.1.15 •recompile 
•recompile 

The file name (source) is interpreted as a compilation unit name which has its source saved horn 
a previous compilation. If •spe^flcation is not spedfied. it is assumed to be body which must be 
recompiled. 


5.1.16 •specification 
•specification 

Woilcs only together with •recompile, see Section S.1.15. 

5.2 Compiler Input 

Input to the compiler consists of the command line options, a source text file and. optionally, a 
configuration file. 


5.2.1 Source Text 

The user submits one file containing a source text in each compilation. The source text may 
consist of one or more compilation units (see ARM Section 10.1). 

The foimai of the source text must be in ISO-FORMAT ASCII. This fonnai requires that the 
source text is a sequence of ISO characteis GSO standard 646), where each line is tenninated by 
either one of the following teimination sequences (CR means carriage return, VT means vertical 
tabulation. LF means line feed, and FF means forai feed): 

• A sequence of one or more CRs, where the sequence is neither immediately preceded nor 
immediately followed by any of the characters VT. LF, or FF. 

• Any of the characteis VT, LF, or FF, immediately preceded and followed by a sequence of zero 
or more CRs. 

In general, ISO control characters are not p .mitted in the source text with the following 
exceptions: 






DACS-80x86 User’s Gui<te 
Ada Conptler 


• The horizontal tabulation (HT) character may be used as a separator between lexical units. 

• LF. VT. FF, and Gl may be used to tenninate lines, as described above. 

The maximum number of characters in an input line is determined by the contents of 
configuration file (see section 5.1.3). The control charaaers CR, VT. LF, and FF are 
considered a pan of the line. Lines containing more than the maximum number of charaaers 
truncated and an error message is issued. 


5uL2 Configuration File 

Certain processing characteristics of the compiler, such as format of input and output, and error 
limit, may be modified by the user. ‘Riese characteristics ate passed to the compiler by means 
of a cottfiguration file, which is a standard SPAROSunOS text file. The coiuents of the 
configuration file must be an Ada positional aggregate, written on one line, of the type 
CONFICURATION.RECORD, which is described below. 

The configuration file (config) is not accepted by the compiler in the following cases: 

• The syntax does not confonn with the syntax for poritional Ada aggregates. 

• A value is outside the ranges specified. 

• A value is not specified as a literal. 

• UNES.PER.PAGE is not greater than TOP_MARGIN + BOTTOM.MARGIN. 

• The aggregate occupies more than one line. 

If the compiler is unable to accept the configuration file, an error message is written on the 
current output file and the compilation is terminated. 

This is the record whose values must appear in aggregate fonn within the configuration file. The 
record declaration makes use of some other types (given below) for the sake of clarity. 


42 










DACS-80x 86 User’s Guide 
Ada CmnpUer 


type CONFZGURATXON^RECORD is 
recQsd 

IH^FORMAT: INFORMATTING; 

OUT FORMAT: OUTFORMATTING; 
ERROR^tlMIT: INTEGER; 

•nd recocd; 


typ« INFUT_FORMATS is (ASCII); 

type INFORMATTING is 
record 

INPUT FORMAT; INPOT_FORMATS; 

INPUT~LINELEMGTH: INTEGER ranQe '70..2S0; 
end recordT 


type OUTFORMATTING is 
record 

L1NES_PER PAGE : 
TOP_MARGIN 
BOTTOM MARGIN 
OUT_LINELENGTH 
SUPPRESS_ERRORNO : 
end record; 


INTEGER range 30..100, 
INTEGER range 4.. 90 
INTEGER range 0.. 90 
INTEGER range 80..132 
BOOLEAN; 


The outfonnaaing parameteis have the following meaning: 

1) LINES.PER.PAGE: specifies the maximum number of lines written on each page 
(including top and bottom margin). 

2) TOP.MARGIN: specifies the number of lines on 'op of each page used for a standard 
heading and blank lines. The heading is placed in middle lines of the top margia 

3) BOTTOM.MARGIN: specifies the minimum number of lines left blank in the bottom of 
the page. The number of lines available for the listing of the program is LINES 
PER_PAGE - TOP.MARGIN - BOTTOM.MARGIN. 

4) OUT.LINELENGTH: specifies die maximum number of characters written on each line. 
Lines' longer than OUT.LINELENGTH are separated into two lines. 

5) SUPPRESS.ERRORNO: specifies the format of error messages (see Section 5.3.5.1). 

The name of a user-supplied configuration file can be passed to the compiler through the 
configuration.file option. DEX:-I supplies a default configuration file (config) with the following 
contem: 


43 











DACS>80x86 User's Guide 
Ada Compiler 


((ASCn. 126). (48.3.3.10aFALSE). 200) 


Top 

Mryln 




Lta«a 

pag* 


Bettoii 

■axgln 




Outjine.kngth 


Figure 5-1. Page Layout 


5J ConqiUer Output 

The compiler may produce output in the list Ole. the diagnostic file, and the current output ftle. 
It also updates the program Ub^ if the compilation is successfiiL The pteseru section describes 
the text output in the three files mentioned above. The updating of the program library is 
described in Section 5.4. 

The compiler may produce the following text output: 

1) A listing of the source text with embedded diagnostic messages is written on the list fDe, 
if the option olist is active. 


2) A compilation summary is written on the list file, if -list is active. 

3) A cross-reference listing is written on the list file, if -xref is active and no severe or fatal 
errois have been detected during the compilatiotL 

4) If there are any diagnostic messages, a diagnostic file containing the di9^tx>stic messages 
is written. 

5) Diagnostic messages other than warnings are written on the cutrem output file. 


44 








DACS-80x86 User’s Guide 
Ada Cnnpiler 


5J.1 The List me 

The name of the list flle is identical to the name of the source file except that it has the file type 
".Us”. The file is located in the current (default) directory. If any such fde exists prior to the 
compilation, the newest version of the Tile is deleted. If the user requests any Ustings by 
specifying the options 'list or 'XTef. a new Ust file is citated. 

The list file may include one or more of the foUowing parts: a source listing, a cross-reference 
Usting. and a compilation summary. 

The parts of the Ust file are separated by page ejects. The contents of each part are described in 
the foUowing sections. 

The format of the output on the list file is omtroUed by the configuration file (see Section 522) 
and may therefore be controlled by the user. 


5J.1.1 Source Usting 

A source listing is an unmodified copy of the source text The Usting is divided into pages and 
each line is suppUed with a Une number. 

The number of Unes output in the source Usting is governed by the occurrence of UST pragmas 
and the number of objectionable Unes. 

• Parts of the Usting can be suppressed by the use of the LIST pragma. 

• A Utm containing a construct that caused a diagnostic message to be produced is printed even 
if it occurs at a poim where listing has been suppressed by a LIST pragma. 

S2.\2 Compilation Summary 

At the end of a compilation, the compUer produces a summary that is output on the Ust file if the 
option -Ust is active. 

The summary contains information about: 

1) The type and name of the compilation unit, and whether it has been compiled successfiiUy 
or not 

2) The number cf diagnostic messages produced for each dass of severity (see Section 
5.32.1). 

3) Which optitms were active. 

4) The fuU name of the source file. 

5) The fuU name of the currem suUibrary. 

6) The mimber of source text Unes. 


45 












DACS*80x 86 User's Guide 
Ada Cmnpiler 


7) The siK of the code produced (specified in bytes). 

8) Elapsed real tune and elapsed CPU time. 

9) A "Compilation tenninated" message if the oxnpilation unit was the last in the compilation 
or "Compilation of next unit initiated" otherwise. 


5J.1J Crosi>Rei!ercnce listing 

A cross-reference listing is an alphabetically sorted list of the identiiiefs. operators, and character 
literals of a compilation unit Tte list has an entry for each entity declared and/or used in the 
unit, with a few exceptions stated below. Overloading is evidenced by the occurrence of multiple 
entries for the same identilier. 

For instantiations of generic units, the visible declarations of the generic unit are included in the 
cross-reference listing as declared immediately after the instantiatioa The visible declarations are 
the subprogram parameten for a genetic su b progra m and the declarations of the visible part of tire 
package declaration for a generic package. 

For type declarations, all implicitly declared operations are included in the cross-reference listing. 

Cross-reference information will be produced for every consdniem character literal for string 
literals. 

The following are not included in the cross reference listing: 

• Pragma ideniifien and pragma argument identiftets. 

• Numeric literals. 

• Record cmnpotrem identifiers and discriminatu idemifiers. For a selected name whose selector 
denotes a record componem or a discriminant, only the prefix generates cross-reference 
information. 

• A parent unit name (following the keyword SEPARATE). 


Each entry in the cross-reference listing contains: 

• The identifier with, at most. IS characters. If the identifier exceeds IS characters, a bar ("P) 
is written in the 16th position and the rest of the characten are not primed. 

• The place of the definition. i.e.. a Uire number if the entity is declared in the currem 
comfrilation unit, otherwise the name of the compilation unit in which the entity is declared 
and the line number of the declaration. 

• The numbers of the litres in which the entity is used. An asterisk C*”) after a litre number 
indicrees an assignmem to a variable, initialization of a constant, assignmems to fttnctions. or 
user-defined operators by means of RETURN statements. Please refer lo Appendix B.3 for 
examples. 


46 










DACS-80x86 User’s Guide 
Ada Compiler 


5 The Diagnostic File 

The name of the diagnostic file is identical to the name of the source file except that it has the 
file type ".err". It is located in the cuirem (default) directory. If any such hie exists prior to the 
compilation, the newest version of the file is deleted. If any diagnostic messages are produced 
during the compilation a new diagnostic file is created. 

The diagnostic file is a text file containing a list of diagnosdc messages, each followed by a line 
showing the number of the line in the source text causing the message, and a blank line. There 
is no separation into p^es and no headings. The file may be used by an iiueractive editor to 
show the diagnonic messages together with the entmeous source text. 


5JJ.1 Diagnostic Messages 

The Ada compiler issires diagnostic messages on the diagnostic file. Diagnostics other than 
warnings also appear on the current output file. If a source text listing is required, the diagnostics 
are also found embedded in the list file (see Section S.3.1). 

In a source listing, a diagnostic message is placed immediately after the source line causing the 
message. Messages not related to any particular line are jdac^ at the top of the listing. Every 
diagnostic message in the diagnostic f^ is followed by a line sating the line number of the 
objectional line. The lines are ordered by increasing source line numbers. Line number 0 is 
assigned to messages not related to any particular line. On the cunem output file the messages 
appear in the order in which they are generated by the compiler. 

The diagnostic messages are classified according to their severity and the cmnpiler action taken: 


Warning: Reports a questionable ctmsmia or an error that does not influence the meaning of the 
program. Warnings do not hinder the generation of object code. 

Example: A warning will be issued for constructs for which the compiler detects will 
raise CONSTRAlNT_ERROR at tun time. 


Error Reports an illegal construct in the source program. Compilation continues, but no objea 
code will be generated. 

Examples: most syntax errors; most static semantic errors. 


Severe Reports »i error which causes the compilation to be terminaied immediately, 
error. No objea code is generated. 

Example: A severe error message will be issued if a library unit mentioned by a 
WITH dause is not p resent in the currem program library. 


47 



DACS-80X86 User's Guide 
Ada Compiler 


Fatal Reports an error in the compiler system itself. Compilation is lenninated immediately 

error and no objea code is produ^. The user may be aUe to circumvem a fatal error by 

correcting the program or by rej^ng program constnicts with alternatives. Please 
inforni DDC-1 about the occurrence of fatal errors. 


The detection of more errors than allowed by the number specified by the ERROR.UMTT 
parameter of the configuration file (see section 5.2.2) is considered a severe error. 


5 Format and Content of Dia^iostic Messages 

For certain syntactically incorrea constructs, the diagnostic message consists of a pointer line and 
a text line. In other cases a diagnostic message consistt of a text line only. 

The pointer line contains a pointer (a carat symbol to the offending symbol or to an illegal 
character. 

The text line contains the following infonnation: 

• the diagnostic message ideniificaticm "• * ***” 

• the message code XY-Z where 

X is the message number 

Y is the severity code, a letter showing the severity of the error. 

W; warning 
E: error 
S: severe error 
F: fatal error 

Z is an integer which, together with the message number X, uniquely identifies the compiler 
location that generated the diagnostic message; Z is of importance mainly to the compiler 
maintenance team - it does not contain information of interest to the compiler user. 

The message code (with the exception of the severity code) will be suppressed if the 
parameter SUPPRESS_ERROR_NO in the configuration file has the value TRUE (see 
section 52.2). 

• the messa^ text: the text may include one context dqrendem field that contains the name of 
the offending symbol: if the name of the offending symbol is longer than 16 characters only 
the first 16 characters ate shown. 

Examples of diagnostic messages: 

*** 18n> 3: Naming: Exeuption CONSTItAZllT_CiUtOR will b« raised here 

*** 320E-2: Nam OBJ does not denote a type 

*** 535E-0: Expression in return stateswnt adssing 


48 



DACS-80x86 User's Guide 
Ada Compiler 


• •• 1S08S-0: Specification Cor this pacicag* body not present in the library 


5.4 The Program Library 

This section briefly describes how the Ada compiler changes the program library. For a mote 
general description of the program library, the user is referred to Chapter 3. 

The compiler is allowed to read fiom all sublibcaries constituting the current program library, but 
only the currem suidibrary may be changed. 


5.4.1 Correct Compilations 

In the following examples it is assumed that the compilation units are conectly com{Hled. i.e.. that 
no erron are detected by the compiler. 


Compilation of a library unit which is a declaration 

If a declaration unit of the smne name exists in the current sublibrary, it is deleted together with 
its body unit and possible subunits. A new declaration unit is inserted in the suldibrary. together 
with an empty body unit 

Compilation of a library unit which is a subprogram body 

A subprogram body in a compilation unit is treated as a secondary unit if the current subiilMary 
contains a subprogram declaration or a generic subprogram declaration of the same name and this 
declaration unit is not invalid. In all ocher cases it will be treated as a library unit, i.e.: 

• when there is no library unit of that name 

• when there is an invalid declaration unit of that name 

• when there is a package declaration, generic package declaration, an instantiated package, cr 
subprogram of that name 


Compilation of a library unit which is an instantiation 

A possiUe existing declaration unit of that name in the current sublibtary is deleted together with 
its body unit and possible subunits. A new declarmkm unit is insetted. 


Compilation of a secondary unit which is a library unit borfy 

The existing body is ddeted from the suUibrary together with its possible subunits. A new body 
unit is inserted. 


49 




DACS-80X86 User’s Guide 
Ada C(Mnpiler 


Compibitioii of a secondary unit which b a subunit 

If the subunit exists in the sublibrary it b deleted together with its possible subuniu. A new 
subunit is inserted. 


SA2 Incorrect Compilations 

If the compiler detects an error in a compilation unit, the program lituary will remain unchanged. 

Note that if a file consists of several compilation units and an error is detected in any of these 
compilation units, the program library will not be updated for any of the compilation units. 


5 J Instantiation of Generic Units 

This section describes the rules after which generic instantiation b performed. 


5 J.l Order of Compilation 

When instantiating a generic unit, it is required that the entire unit, including body and possible 
subunits, be compiled before the first instantiation. Thb b in accordance with the ARM Chapter 
10.3 (1). 


5J2 Generic Formal Private Types 

The present section describes the treatment of a generic unit with a generic fonnal private type, 
where there b some construa in the generic unit that requires that the corresponding actual type 
must be constrained if it b an array type or a type with discriminants, and there exists 
instantiations with such an unconstrained type (see ARM. Section 12.3.2(4)). This b considered 
an illegal combination. In some cases the error ' detected when the instantiation is compiled, in 
other cases when a constraint'iequiring construa of the genetic unit b compiled: 

1) If the instantiation appears in a later compilation unit than the first constraint-requiring 
construa of the generic unit, the error b assodated with the instantiation which is rejected 
by the compiler. 

2) If the instantiaiion appears in the same cmnpilation unit as the first constraint-requiting 
construction of the gmric unit, there are two possibilities: 

a) If there b a constraim-requiting construction of the generic unit after the instantiation, 
an error message appears with the instatsiation. 

b) If the instantiation appean after all constraim requiting constructs of the genetic unit 
in that compilation unit, an error message appears with the constraint-requiring 
construct, but will refer to the illegal instandatioa 







DACS>80x86 User’s Guide 
Ada GMQpiler 


3) The insuntiation appean in an earlier compilation unit than the hist ctmstraint-requiiing 
consmictiQn of the geiwric unit, which in that case will appear in the generic body or a 
subunit If the instantiatian has been accepted, the instantiation will correspond to the 
genetic declaration only, and not include the body. Nevertheless, if the generic unit and 
the instantiation are located in the same sublibrary, then the compiler will consider it an 
error. An error message will be issued with the constraint-requiring construa and will refer 
to the illegal instaniiatiaa The unit containing the instantiation is not changed, however, 
and will not be marked as invalid. 


5.6 Uninitialiaed Variables 

Use of uninitiaiized variables is not flagged by the compiler. The effect of a program that refers 
to the value of an uninitialized variable is undefined. A cross-reference listing may help to find 
uninitialized variables. 


5.7 Program Structure and Compilation Issues 

The following limitations apply to the DACS-80x86 Ada Compiler Systems for the Real Address 

Mode and 286 protected mode only: 

• The Ada compiler supports a ".’neJified large” memory model for data references. The 
"modified large" memory model associates one dau segmem for each hierarchical suUibrary in 
the Ada program library. All package dau declared within a suUibrary is efficiently referenced 
from Ada code compiled into the same sublibtary. A slight increase in code size results from 
referencing package dau compiled into a different hierarchical level. Intel's medium memory 
model can thus be obtained by utilizing only mie level of Ada program library, the root 
sublibrary. 

« The Ada compiler supports a large memory model for executable code. Although the size of 
a single compilation unit is restricted to 32K words, the total size of the code portion of a 
program is not restricted. 

• The space available for the static data of a compilation unit is 64K - 20 bytes. 

• The space available for the code generated for a compilation unit is limited to 32K words. 

• Any single object cannot exceed 64K - 20 bytes. 

The following limitations apply to all DACS-80x86 laoducts: 

• Each source file can contain, at most, 32,767 lines of code. 

• The name of compilation units and identifiers may not exceed the number of characters given 
in the INPUT.LINELENGTH parameter of the coifiguration file. 

• An integer literal may not exceed the range of LONG.INTECER, a teal literal may not exceed 
the range of LONG_FLOAT. 


51 





DACS*80x86 User's Guide 
Ada 03mpiler 


• The number of formal parameters penniaed in a procedure is limited to 127 per parameter 
spedficadon. There is no limit on the number of procedure specificaiions. For example, the 
dedaradon: 

procedure OVER LIMIT (ZNTEGEROl, 

~ INTEGER02, 

ZNTEGER166: in INTEGER); 

exceeds the limit, but the procedure can be accomiHished with the following: 

procedure UNDER LIMIT (INTEGEROl : in INTEGER; 

~ INTEGER02 : in INTEGER; 

INTEGER166 : in INTEGER); 

The above limitadons are diagnosed by the compiler. In pracdce these limitadons are seldom 
restricdve and may easily be drcumvent^ by using suburuts. separate compilation, or creating new 
sublibraiies. 


5.8 Compiler Code Optimizadons 

ODC*r$ Ada compiler for the iAPX 80x86 microprocessor family generates compacL eflidem 
code. This efiidency is achieved, in pan, by the compiler’s global optimizer. Optimizations 
performed indude: 

• Common sub-expression eiiminadon 

• Eiiminadon of redundam constraim checks 

• Biminadon of redundam elaboration checks 

• Constam folding 

• Dead code eiiminadon 

• Optimal register allocation 

• Selection of optimal jumps 

• Optional nm-time dieck suppression 


52 






LINKER OPTIONS 

The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation and 
not to this repoz^. 









6 THE ADA LINKER 


The DACS linker must be executed to create an executable program in the target environment 
Linking is a two stage process that includes an Ada link using the compilation units in the Ada 
program library, and a target link to integrate the application code, ran-time code, and any 
additional configuration code developed by the user. The linker performs these two suges with a 
single command, providing options for controlling both the Ada and target link processes. 

This chapter describes the link process, except for those options that configure the Run-Time 
System, which is described in detail in Chapter 7. 


6.1 Invoking the Linker 

Emer the following command at the shell to invoke the linker 
S adaJink {<option>} <unit-name> 
where the optitxis and parameters ate: 

Ada Linker Options 


OPTION 

DESCRIPTION 

REFERENCE 

•[noldebug 

Links an plication for use with the 

DACS-80x86 Symbolic Cross Debugger. 

6.5.11 

•enable_task_trace 

Enables trace when a task terminates in 
unhandled exception. 

6.5.28 

•exception_space 

Defines area for exception handling in task stadt. 

6.529 

•[no]extract 

Extracts Ada Objea modules 

6.5.14 

•interTupt_entry_table 

Range of interrupt eiuries. 

6.5.27 

-library 

The library used in the link. 

6.5.7 

•[no]log 

Specifies creation of a log file. 

6.5.9 

•it_seginent_size 

Library task default segmem size. 

6.523 

•lt~stack_siK 

Library task default stadt size. 

6.5.22 

•nip^segnwnt^size 

Main program segmem size. 

6J.25 

•inp~stack_size 

Main p; jgiam stack size. 

6J24 

•[noTnpx 

Use of the 80x87 numeric coprocessor. 

6.5.16 

•options 

Spedfies target link options. 

6.5.6 

•priority 

Default task priority. 

6.5.18 

•reserve_stack 

Size of reserve stack. 

6.521 

-rms 

Sdect Rate Monotonic Scheduling Run-Tune 

Kemd (optional). 

6J.13 

•[no]root_extract 

Using non-DDC-I units in die root library. 

6.5.10 


53 






DACS-80x86 User's Guide 
The Ada Linker 


•[nolrts 

Includes or excludes the run-time system. 

6.5.12 

•searchlib 

Target libraries or objea modules to include 
in target link. 

6.5.4 

•selective Jink 

Removes uncalled code frirni final program. 

6.5.8 

•sign^on 

Produce sign on and sign off messages. 

6.5.30 

•stopJieforeJink 

Perfonns Ada link only. 

6.5.5 

•tasks 

Maximum number of tasks or non-tasking 
application. 

6.5.17 

•task_storage_size 

Tasks default storage size. 

6.5.26 

•template 

Specifies template file. 

6.5.15 

•timer 

Tuner resolution. 

6.5.20 

•tinie_slice 

Task time slicing. 

6.5.19 


All options may be abbreviated (characters omitted from the right) as long as no ambiguity arises. 
Casing is significant for options but not for options keywords. 

Note: Several simultaneous links of the same program should not be performed in the same 
direaory. 


6.1.1 Diagnostic Messages 

Diagnostic messages fmm the Ada Linker are output on the cunem output file and on the optional 
log file. The messages are output in the order they are generated by the linker. 

The linker may issue two kinds of diagnostic messages; warnings and severe etrois. 

A warning reports something which does not prevent a successful linking, but which might be an 
error. A warning is issued if there is something wrong with the body unit of a program unit 
which formally does not need a body unit, e.g. if the body unit is invalid or if there is no objea 
code container for the body unit. Warnings are only output on the log file, not on the current 
output file. The linking summary on the log file will contain the total number of warnings issued, 
even if the issued warnings have not been output. 

A severe error message repotis an error which preverus a successful linking. Any inconsistency 
detected by the linker wilL for instance, cause a severe error message, e.g. if some required unit 
does not exist in the library or if some time stamps do not agree. If the linker is used for 
consequence examination. aU iiKonsistencies introduced by the hypothetical recompilations are 
reported as errors. 

A unit not marked as invalid in the program library may be reported as being invalid by the 
linker if there is something wrong with the unit itself or with some of the units it depends oa 


6JZ The Linking Process 

The linking process can be viewed as two consecutive processes. Both are automatically carried 
out when issuing the link command ada Jink. 


54 











DACS-80x86 User’s Guide 
The Ada Linker 


The first process constitutes the Ada link process and the second constitutes the target link 
process. 

The Ada link process 

• retrieves the required Ada objea modules from the program library. 

• detennines an elaboration order for all Ada units. 

• creates a module containing the User Configurable Data (UCD) from the specified configuration 
options to the linker and 

• creates a shell script that carries out the target link process (i.e.. dlnkbldx86). 'The locate/build 
phase is an integral pan of the target link. 


If the option •stopJicfore-Iink is NOT specified (default), the above script is executed 
automatically. Otherwise the linking process is halted at this point 

When •stop-beforeJink is specified, all temporary files are retrieved for inspection or 
modification. The target linker is invoked by executing the shell script. 


6.2.1 Temporary Files 

The following temporary files are in use during the link phase: 

<mainjprogram>.link.com The shell script which invokes the target linker. 

<main_ptogram>_elabcode.o The objea code for the calling sequence of the elaboration 

code. 


<main_program>_ucd.o The objea code generated from the R'TS configuration 

options (see Section 12). 

<main_program>_uxxxxx.o The Ada objea modules which have been extracted from the 

program library, xxxxx is the unit number of the Ada unit 


55 



DACS-80x86 User's Guide 
Hie Ada Linker 



The following components make up the run-time system: 

1) User configurate portion of the RTS 

a) User configurable data (UCD) and 

b) User configurable code (UCQ 

2) Permanent pan of the RTS 

a) Non-tasking RTS (rllJib) or 

b) Tasking RTS (rl2Jib) 

c) RMS Tasking RTS (rlSJib) 

The User Configurable Code defined by the environmental variable ada_ucc_lib is included in the 
link. If no tasking has been specified, then the RTS non-tasking libraiy~(rll7ub) will be included. 
If tasking has been qiedfied, then suppon for tasking will be included (rl2Jib or, when -rms, 
rl3.1ib). 












DACS-80X86 User's Guide 
The Ada Linker 


The output of the linker step is an absoluie executable object file with the extension ".dat” and 
a map file with the extension "jnpS". 


6^ Environmental Variables 

When a link is executed, a number of files are referred to and most are accessed through 
environmental variables. The loaue/build phase uses the control file Sada_ucc_dir/tonrig.bld_ddci, 
the remaining variables are: 


VARUBLE 

PURPOSE 

ada_system.library 

Identifies the root library where the system compilation units reside. 

ada.iibrary 

Identifies the default library used by all DACS-80x86 tools. It is the 
lowest level sublibtary in the program library hierarchy. 

ada_toot_lib 

Identifies the OMF library where the system library uniu have been 
extracted from the system library. By having a separate Library for the 
toot compilation units, the link process is much faster than otherwise 
having to extract each unit from the system library for each link. 

ada_rl l_lib 

Identifies the OMF library for the Pennanem Part of the non-tasking 
version of the Run-Time System. 

ada_rI2Jib 

Identifies the OMF library for the Permanent Pan of the tasking version 
of the Run-Tune System. 

ada_rl3_Iib 

Identifies the OMF library for the Permanent Pan of the optional Rate 
Monotonic scheduling Run-Tune System. 

ada.uccjib 

Identifies the OMF library for the User Configurable COde portion of 
the Run-Time System. 

ada-iemplate 

Idemifies the template file for the Linker. 

ada-ucc-dir 

Identifies the direaory of the currem UCC. 


With each of these environmental variables, the name will differ depending on how the system 
was installed (ada86. adal86 etc). Throughout this documem ada is assumed. For example, the 
environmental variables for the toot library for the 80186 version of the compiler would be 
adal86_root_lib, and the RTS UCC library environmental variaUes for the 8086 version would 
be adal6_ucc_lib. 


57 







DACS*80x86 User's Guide 
The Ada Linker 


Riui'Tiine System Overview 

The Run-Tune System for DACS-80x86 is defined as all code and data, other than the code and 
data produced by the code generator, required to make an embedded system application operate 
property on a specific hardware system. 

In general, there are two major components that make up the Run-Tune System. 

1) Code and data assumed to exist by the code generator. This is hardware independem and 
known as the RTS Permanem Part 

2) Code and dau tailoring the application with reqrea to the characteristics of the hardware 
and other requirements of the embedded systems developer. This code is called the RTS 
User Configuratde Paa 

Both of the above components consist of modular OMF libraries. The modules are only included 
in the user program if they are needed, i.e.. if a call or reference is made to the module. This 
ensures a compaa RTS (t]^cal apjriications are 4 KB to 10 KB). 

The RTS Permanent Part does not make any assumptitms about the hardware other than an 80x86 
and some amount of memory available. 

There are several versions of the RTS User Configur^le Pan available for dirteiera development 
targets. Also, the smirce code is provided to allow the modification of the User Configurable 
Code (UCQ to operate on other targets. Refer to the RTS Configuration Guide for complete 
information on modifying the UCC. 

DDC-I has carefully analy^ and selected the parts of the Run-Time System that must be 
configurable for hartware independence, freeing the user from major rewrites whenever the 
Run-Time System is retargeted wltile, sdll allowing for almost unlimited adaptability. 

Four important features of the run-time system are: 

• It is small 

• It is completely ROMabte 

• It is configurable 

• It is efficiem 


Conceptually, an Ada run-time system can be viewed as consisting of the following components. 

• Executive. i.e.. the start-up mechanism 

• Storage Managemem 

• Tasking Management 
■ Irgxit/Output 

• Exception Handling 


58 







DACS*80x86 User's Guide 
The Ada Linker 


• Run>Tune Library Routines 

• Package CALENDAR support loutines 


The nin-time system (RTS) can be configured by the user through Ada Linker command options. 
The Ada Linker will generate appropriate dau structures to tepiesem the configured characteristics 
(UCD). 

Two verskNis of the RTS are supplied, one including tasking and one excluding tasking. The 
linker selects the RTS version including tasking only if the option 'tasks is presem or >183115 n 
is present and n > 0. Otherwise, the linker selects the RTS version excluding tasking. 


6.4 Linker Elaboration Order 

The elaboration order is primarily given by the unit depoKtendes. but this leaves some freedom 
here and there to arbitrarily choose between two or more alternatives. This arbitrary is in the 
DACS>80x86 linker controlled by the gelling of the involved library units, in order for "free” 
units to become alphabetically sotted. 

Recompiling from scratch, an entire system may thus affea the allocation of unit numbers, but the 
elaboration order remains the same. 

It is also attempted to elaborate "body after body", so that a body havittg a with to a specification, 
will be attempted elaborated ^er the body of this specification. 

Also elaboration of units fimn differem library levels is attempted to complete elaboration of a 
father>level prior to the son-leveL 

This strategy should in many cases reduce the need for resetting pragma ELABORATE. 


Ada Linker Options 

This section describes in detail the Ada linker option and parameters. 


63.1 The Parameter <unit«name> 

<ttnit>natne> 

The <unit_nmne> must be a library unit in the current program library, but not necessarily of the 
currem sublibrary. 

Nbte that a main program must be a procedure without parameters, and dm <unit>name> is the 
identifier of the proredute. not a ^ spedficatioa. The main procedure is not diecked for 
parameters, but the execution of a program with a main procedure with parameters is undefined. 


59 







DACS-80X86 User’s Guide 
The Ada Linker 


6J2 The Paraimtcr <rcconipilaUon«spcc> 

The syntax of <recoiiipUation-spco is: 

<iiiiit_speo{<4MKty|-apcdffcatfoB](^] 

This paiameier idls the ladcer to perform a consisiency check of the entire program using the 
hypotetical recompilation oi all mils designated in the <ieco m pi l at i o n -speo. The link process 
in this instance is not actually p erferaied. 

The <unit_spee> is a list of unit-names (wildcards are allowed), sepa r ated by comma (.) or |dus 
(*). Each unit-name should include an option to indicate if the body or specification is to be 
hypothetically compiled (-spec is the default). 


d.5J Required Recompilations 

If the consistency chedt found that recompilations are required, a list of required recompilations 
is written to the cunem owput file or » a text file if the <4^ option is sp^fied (the name of 
the text file is indicated in the log file, line 8). The list will include any inconsistencies detected 
in the library and recompilations required by the hj^tothetical recompilations specified with the 
options -declaration and -body. 


The entries in the list contain: 


1) The unit name. 

2) Indication of what type of unit (declaiation unU. body unit, or subunit). 

3) If the unit is specified as recompiled with the -declaration or -body option, it is maiked 
with "-R-". 

4) The environmeiaal variable of the subUbrary containing the unit 

In the recompilation list the units are listed in a rectanmended recompilation order, consisiem with 
the dependencies among the units. 


&5.4 -searchlib 


-se a rt h lib <lllc_naine> {,<fileJiamo) 

The -searchUb option directs the Ada Linker to search the specified 80x86 target libraries for 
ot^ modules in order to resolve symbol refe ren ce s . Tbe 80x86 target libraries for olgea files 
will be searched before the DAGS Run-Time Systtm (RTS) library normally searches for run-time 
routines; in this wi^ one can replace the standard DACS RTS roudnes with custom routines. 

The -sear chlib option is also intended to specify Ubraries of modules referenced fiom Ada via 
pragma INTERFACE 


60 





DACS-80k 86 User's Guide 
The Ada Liidcer 


Examples; 

S ada .llwk •saarchifli intcrf!acc_lib p 

Links the subprogr a m p, resolving referenced symbols first with the target library imerface.lib 
and then with the standard RTS target library. 


<b5J •stop JMlbreJiak 
•reop_lwfbre_liiik 

The •stop^bcftircjink option allows the user to introduce assemblers and linkers from third 
parties or~io othvwise configure the link to suit the application. The link is halted with the 
following conditions: 

• The user configurable dau file. <mait»_ucd.o. is produced with the defeult or user specified 
linker option values included. 

• The daboration code is contained in the <main>,eldxode.o file. 

• The shell script file that contains the link command is preseru and has not been executed. The 
file’s name is <main> Jink.com. 

• The temporary Ada objea fik(s) used by the target linker are produced. These objects are 
linked and deleted when <main> Jinkxom is executed. 

• With •seieclivcjink the objea files comprise all Ada uruts indiiding those fiom the root 
library. At this poim it is possible to disassemble the "cut” objea files using <obiea with the 
disassembler. 

To complete the link, the <main>_link.com script must be executed. To use third party u>ols, this 
file may have to be modified. 


6J.6 •options 
•options <paranietcr> 

•options allow the user to pass options onto the targa iinka. 






DACS-80x86 User's Guide 
Run-Time System 


<J.7 -libnry 

•Bbrvy <lllc-aaiiie> 

•ttbrary SadnJibrary (deftult) 

The -Ubrary option spedlles the current sublibniy. fiom which the linking of the main unit will 
tike place. If this option is not specified, the suUibrary specified by the enviitmmental variable 
adaJibnry is used. 


6,5,8 iel ec ti ve_link 
•sekctiveJink 

This extracts aU required objea modules from the Ada library Oncluding the root library) and cuts 
out exactly those pans that are actually called, in order to make the resulting target program 
considerably smaller. If a progma uses e.g. PUT_LINE as the only routine from TEXTJO, the 
contribution ftom the TEXTJO objea module will only contain PUT_LINE (and whatever that 
needs). Note that disassemblies of units used in a selective link normally will not match what is 
linked, because of the cutting. Such disassemblies may though be obtained by disassembling 
directly those uttiu that made up the selective link, by stopping the linking before the targa link 
phase (-stop^beforcjink). making disassemUies using -objea and then resuming the link. 

Note also that unused constatus and permanem variables are not removed. 

Only "level 1" subprograms may be removed. Nested sub p rogra m s (that are not called) are to be 
removed during compilation using the -optiroixe option. Nested subprograms are only removed, 
if the routine in whiA the nesting occurs is removed. 


6J.9 -(nollog 

-log [<(I]c-speo] 

•nolog (default) 

The option speofies if a log file wiQ be produced from the from end linker. As default, no log 
file is produ^ If <file-speo is not entered with -log the default file name for the log file will 
be linkJog in the currem directory. 

The log file contains extensive information on the results of the link. The file includes: 

• An elabotatioo order list with an enry for each unit included, showing the order in which the 
unitt will be elaborated. For each unit, the unh type, the time stamp, and the dependencies are 
shown. Funhennore, any elaboration inconsistencies will be report^ 

• A linkiiv summary with the following infimnadon: 


• Parameters and active options. 

• The fliO name of the program library (the currem sublibrary and its ancestor sublibraries). 


62 







DACS-8Qg(86 User's Cukk 
^ The Ada linker 


• The number of each type of diagnostic message. 

• A tennination message, suting if the linking was temtinaied successfully or unsuccessfully or 
if a consequence examination was teiminaied. 

• Diagnostic messages and warnings are written on the log file. 


If recompilations are required (as a result of the consistency check) a text file is produced 
containing excerpts of the log file. The name of this leu file is written in the log file, line 8. 


The log file consists of: 

• Header consisting of the linker name, the linker version number, and the link time. 

• The elaboration order of the compilation units. The units are displayed in the order elaborated 
vnth the unit number, compilation time, unit type, dependencies, and any linking errors. 

• If recompilations are required, the units that must be recompiled are listed along with its unit 
type and suUibrary level 

• The linking summary that includes the main unit name, the program library, any recompilations 
that are required, arid if any errors or warnings occurred. 


6.5.10 •(nolroot-extract 
•rooU.extract 

•norootjextract (default) 

The units cotuained in the Ada system library supplied by DDC-1 have been extracted and inserted 
into the $ada_rootjib OMF Library, thus eliminating extractions from the system library at link 
time and improving link performance. 

The user should normally not modify or compile into the Ada system library supplied by DDC-1. 
If however, a unit is compiled iruo the Ada system library, the $ada_rooijib will no longer 
match the Ada system library and -rootjextract must be specified in order to Unk fiom the Ada 
system library. 


63.11 -[noldebug 
•debug 

•nodebug (default) 

The -debug option specifies that debug infotmmion is generated. The debug infonnation is 
required to enable s^bolic debugging. If 'nodebug is qtecified, the Ada linker will skip the 
gemration of debug information, thus savit^ link time, and will not insert the ddxig information 


63 








DACS-80x86 User's Guide 
The Ada Linker 


into the chosen suUibraiy. thus saving disk space. Note that any unit which should be 
symbolically debugged with the DOC-I Ada Symbolic Cross Debugger must also be compiled with 
the •debug option. 


6J.12 •{no]rts 

•rts (default) 

•norts 

The •Its option directs the Ada Linker to include the appropriate Run-Time System (RTS) in the 
link, •norts directs the Ada Linker to exclude the RTS in the link. 

The ability to exclude the Run-Time System firom the link allows the user to do an additional link 
with a private copy of a custom RTS. The Ada Linker may repon unresolved references to RTS 
routines, but will still produce a relocatable objea file. 


6J.13 -rms 


•rms 

This option selects the Rate Monotonic Scheduling Tasking Kernel (if tasking is selected). The 
default is to use the Standard Tasking Kernel. This feature is supplied as an opdon. 


6,5.14 -(nolextract 

•extract (default) 

•noextract 

This option to the linker allows the user to specify that program unit objects should not be 
extracted from the Ada program library. This option would be used if the user knows that many 
objects have not changed since the last link and (kies not wata the linker to waste time extracting 
them. 

To use this feature, the user should modify the temfrfate to not delete unit object files after a 
target link is performed. This way the objea ftles remain in tte currem directory (or whereever 
the user decides to put them). On subsequem links the user can extraa objea modules of 
modified units from the Ada library using the standalone DACS extraa tooL A new target link 
can then be performed using a combmadon of newly extracted objects and the objea files from 
previous links that have gone unchanged. This could significantly improve linker speed when 
linking programs that share common and rarely modifkd libraries and when relinking programs 
that have had only a few units modified. 


64 





OACS-80x86 User's Guide 
The Ada Linker 


6J.15 -template 

-template <iile-naine> 

-template Sada.template (default) 

The template file is known to the linker via the environmental variable adajemplate. DDC-I 
supplies a default template file as part of the standard release system. Please refer to appendix H 
for detailed infonnation. 


6J.16 -npx 

•l^lx (default) 

-nonpx 

The -npx option specifies that the 80x87 (8087, 80287. or 80387) numeric coprocessor is used 
by the Ada program. When -npx is specified, the 80x87 is initialized by the task initialization 
routine, the floating poim stack is reset during exception conditions, and the 80x87 context is 
saved during a task switch. 


Configurable Data 

A 16 bit boolean constant is generated by the Ada Linker 


CD NPX USED 


boolean 


0 

1 


- 80x87 is not used 
• 80x87 is used 


6J.17 -tasks 


-tasks [n] 

(deCnilt is no tasking) 

This option specifies the maximum number of tadts allowed by the R'TS. If specified, n must be 
greater than zero. If -tasks is specified without a value for n, n defaults to 10. If -tasks is not 
specified, the RTS used will not include suppon for tasking. If -tasks is specified, the RTS used 
will include suppon for tasking. 

Ada Interrupt tasks identified with pragma INTERRUFT_HANIX,ER need not be included in the 
count of maximum number of tasks. Tte main program must be counted in the maximum number 
of tasks. Note that the main program, which may implicitly be considered a task, will not nm 
under control of the tasking kernel when -notasks is spectfied. See also -nns option. 


Configurable Data 

For -tasks, the linker generates the following configurable data: 


6S 





DACS*80x86 User’s Guicte 
The Ada Linker 


CD mx tkjxs 


necKont - w 


CO teas 


N TMk 

Conerel 

■lack« 

(TCM) 

If -apK la 
actlva, R 
niaMcle co- 
pracMsac 
M—» 


Example: 

$ adaJlink ‘tasks 3 p 

• Link the program P. which has at most 3 tasks, including the main program. 


6J.18 -priority 
•priority n 

•priority 15 (default) 

The -priority option specifies the default priority for task execution. The main program will run 
at this priority, as well as tasks which have had no priority level defined via pragma PRIORITY. 
The range of priorities is from 0 to 31. 

Priorities can be set on a per task basis dynamically at tun time. See section El (Package 
RTS.EntryPtnnts) for mote details. 


Configurable Dau 

The Ada Linker generates the foUowii^ constam data: 


CD nUOKZTT 


Constant - W 


ExanqHe: 

$ adaJink -tasks -priori^ 8 p 

• Link the subprogra m P whidi has the main program and tasks ninning at 
default priority 8. 


66 







DACS>80x 86 User's Guide 
The Ada Linker 


6J.19 •dine-attce 

•dme.slice (r] (default no dme slicing is active) 

The 'dme^slice options specifles whether or not time slicing will be used for tasks. If specified. 
R is a dental number of seconds representing the defuilt time slice to be used. If R is not 
specified, the default time slice will be 1/32 of a second. R must be in the range Duration'Small 
$ R S 10 and must be greater than or equal to the •dmer linker opdon value. Time slicing only 
applies to tasks ninning at equal priority. Because the RTS is a preemptive priority scheduler, the 
highest priority task will always nm before any lower priority task. Only when two or more tasks 
are rurming tt the same priority is time slicing applied to each tadt. 

Tune slicing can be ^jecilied on a per task basis dynamically at nm*iime. See Section El 
(Package RTS.EnoyPoints) for more details. 

Time dicing is not applicable unless tasking is being used. This means that the 'tasks option 
must be used for -diiw slice to be effective. 


Configurable Data 

The Ada Linker generates the following data: 


_co_Tna:_awcE_os*D 

0 <■ Me tiam tllelnff 

1 • Tlae allelaf 


CO TIME SLICC 


BOOIXAM 


•baelute Integer 


• representing the number Y that saiisries Y * DURATION'SMALL » R 


Example: 

S adaJink •dine_slice 0.125 -tasks p 

• Specifies tasks of equal priority to be time sliced each eighth of a second. 


6JJ0 -dirKr 
•dmer R 

•dmer 0.001 (default) 

The -dmer option specifies the resolution of calls to the Run-lime System routine TIMER (see 
the Run-Tme System Ctmtiguration Guide for DACS-80x86 for more information). The number, 
R, specifies a decimal number of seconds which have elapsed for every call to TIMER. The 
default TIMER resolution is one millisecond. R must be in the range DURATION’SMALL< R 
< ? 


67 





DACS-80x86 User’s Guide 
The Ada Linker 


Ctmflgurable Data 


The Ada Linker generates the following 16 bit constant 


CD TUCK 


Ab»eluf InfoT 


• representing the number Y that satisfies Y * DURATION'SMALLsR 


•reserve-stack 
•reserve stack [n] 


The •rcserve_stack option designates how many words are reserved on each task stack. This 
space is reserved for use by the RTS. which does no checking for stack overflow. This reserved 
space also allows the RTS to fimction in situations such as handling a storage error exception 
arising- firom stack overflow. 

The •reserve_stack opdon also reserves part of the main program stack size, specified by the 
linker option ~nip_stack_size. 


Configurable Data 


The Ada Linker generates the foUovinng integer constant: 


CD KESXXVe STACK 


tllTZGm 


Examples: 

S ada-link •reserve_stack 200 •tasks p 

• Reserve 200 words from each stack for use by the RTS. 


6J22 •It-stack-size 

•tt_stack_size n 
•Itlstacklsize 500(default) 

The •lt_stack_siic option designates the library task default size in words. A library task is 
formed "when'a task objea is declared at the outermost level of a package. Library tsaks ate 
created and activated during the initial main program elaboration. (See the Ada Reference Manual 
for more details). 


68 








DACS*80x86 User’s Guide 
The Ada Linker 


For each library task, the reptesentadon spec: 

FOR Task_objecfSTORAGE_Sl2E USE N; 

can be used to specify the library task suck size. However, if the representation spec is not used, 
the default library task size specified by 'It^sUck^size will be used. 

For efficiency reasons. aU tasks created within library tasks will have stacks allocated within 
same segmem as the library task stack. Normally, the segmem which contains the library 
stack is allocated just large enough to hold the default liteairy task stack. Therefore, me must 
the option •It-stadc-option or the pragma LT.SEGMENT.SIZE to reserve more space withir 
s^ment that may be used for nested tasks’ stacks. (See the implementation dependera pragma 
LT.SEGMENT.SIZE in Section F.l for more information). 


The range of this parameter is limited by physical memory size, task stack size allocated during 
the build phase of the link, and the maximum segmem size (64K for all except the 386/486 
protected mode, which is 4 GB). 

Configurable Data 


The Ada Linker generates the following integer constant: 


CS LZ STACK SIZE 


IM T EGEK 


Example: 

S adaJink •lt_stack_size 2048 -tasks p 

• Link the subprogram P using a 2K words defiiult library stack size. 


6S23 -It.stack-size 
•lt_seginent_size n 

•lt_segment_size Qt-stack-size 20 exception-.stack_space) (default) 

This parameter defines in words the size of a Utvary task segment. The library task segmem 
contains the task stack and the stacks of all its nested tasks. 

The default value is only large enough to hold one default task stadt. If •lt_stack_size is used and 
specifies a value other than the default value. -It_seginent_size should also be sp^fied to be the 
size of <taskjstack.size> + 

<total.of_nested_tasks_sizes> 

<20_words_overhead> + 
excepdon.stackjspace. 

Note that the task stack size specified by the ’STORAGE.size can be representation spec or by 
the option -It-stack-size. 

Dynamically allocated tasks receive their own segmem equal in size to the mp_segment_size. 


69 









DACS-80xS6 User’s Guide 
The Ada Linker 


The mge of this panmeter is limited by phyacal memory size, task stack size allocated during 
the build phase, »d the maximum segmem size (64K for all except the 386/486 protected mode, 
which is 4 GB). 


Configurable Data 


The Ada Linker generates the following data structure: 


CO_LT 


SZZB 



Example: 

S ada-Iink •lt_segment_size 2048 -tasks p 

• Link the program P using a library task segmem size of 2K words. 


6JJ4 •mp.staclu.aize 


•nip_stack_sizc n 
-mpZstack_sizc 8000 (default) 

The -mp^stack^size option specifies the main program stack size in words. 

The range of dus parameter is limited by physical memory aze, task stack size allocated during 
the build phase (in tasking programs only), the maximum segmem size (64K for all except the 
386/486 protected mode, which is 4 GB). and the size of mp.segmem_size. 


Configurable Data 

The Ada Linker generates the following data structures for nontasking programs: 


CD MI STACK SZZX 


rWTMER 


_a»_»_STACK 


W STACK SZU 
words 

storsoo_ 


jajnjnxcKjmKt 


ai^host adds, 
of ttr icscfc 


For tasking programs, the Ada Linker generates the same structures but limits the size to 1024 
words. This stack is only used for the execution of the sysmra sunup code and elaboration. 
At main program activation, a segmem for the main program equal to the size specified by • 
•mp_segnient_size will be allocated from the dynamic memory pool and a stack for the main 
ptoffm equtJ to the size specified by •inp_sUick_sitt will be allocated fiom the memory 
pool. 


70 




DACS-80x86 User’s Guide 
Tbe Ada Linker 


Example: 

$ adaJink •mp.stack^sixe 1000 p 

• Link the subprogram P with a stack of 1000 words. 


6JJ25 •mp.segment-size 


•mp^segment^sixe n 
•mp-jegmenCaitt 8100 (Default) 

The •inp_seginent_size option specifies the size, in words, of the segment in which the main 
program sack is aUocated. The default setting can be calculated horn the fonnula: 

mp.segmetu_size s mp_stack_size + 

overhead * (tasks - 1) * 

(overhead task_storage_size) 

Normally, the main program segment size can be set to the size of the main program sta 
However, when the main program contains nested tasks, the stacks for the nested tasks will 
allocated from the data segment which contains the main program stack. Therefore, when 
main program contains nested tasks, the main program stack segmem must be extended via 
•nip_segnient_size option. 

The range of this parameter is limited by physical memory size, task stack size allocated during 
the build phase (in tasking programs only), and the maximum segment size (64K for aU except 
the 386M86 protected mode, which is 4 GB). 

Note: Dynamically allocated tasks receive their own segment equal in size to mp_segment_size. 


Configurable Data 

The Ada Linker allocates the _CD_MP_STACK (see tbe •mpjstack^size option) within a data 
segment called _CD_MP_STACK_SEGMENT: 


.CD Mr_sT»cx_sca4Eirr 


Iw STACK 


T T T 

to STACK START tO STACK SIZE W.SCCMaiT SIZE 


Example: 

$ ada-link 'tasks -inp_seginent_size 32000 program_a 

Links the sut^gram PROGRAM_A, which contains tasks nested in the main program 
allocating 32,000 words for the main program stack segment. 


71 









DACS*80x86 User’s Gui(te 
Tbe Ada Linker 


6JJ6 »taak-atora|e-sfate 

•task_stonice_size n 
•tasklstoragCsiie 1024 (default) 

*11)1$ option sets tbe default storage size in words for stacks of tasks that are not library tasks. 
This value can be overridden with a representation clause. 

*1116 mge is limited by the size of the lt.segmem_size Qf it is a subtask to a library task), or by 
mp_segmem.si 2 e Gf it is a subtask to the main program). 


Conflgurabie Data 


The Ada Linker generates the following data structure: 


,cs_TasK_STORMe_szze 


niTESEK 


6J^7 •interrupt_entry_tablc 
•interrupt_entry_tabie L4I 

The •intcmipt_entry^tablc option specifies the range of interrupt vector numbers used by the 
Ada program in intertupt tasks. 

The number. L. specifies the lowest numbered interrupt handler. The number. H. specifies the 
highest numbered interrupt handier. The range for low and high interrupts is 0 to 255. 


Configurable Data 

If -interrupt_enti 7 _!abic is specified, the Ada Linker will generate the following daa structure: 


CD LOW n n nu BWT 


COWSTJUtt 


(L) 


CO aZSB IKTBiaiOPT 


OOW3TJUIT 


(H) 


CO IMIBlUarT VBCtOK 


(g-L^D^S 
werda cwawcvad 
tot Intwrrvpc 
Vactor 


If the user ever detects umesolved references to the symbols: 

.CD_LOW_INTHWUPT 

_CD_H1GH_INTERRUPT 

CD^INTERRUPT.VECTOR 


72 








DACS-80x86 User’s Guide 
The Ada Linker 


the Ada program ctmtains standard imemipt tasks for which the RTS requires the above data 
structure. You must relink the Ada progr a m specifying the •inteiTupt_cntry_table option. 

Example: 

$ adaJink 'tasks •intemipt_cntry_table 5^ p 

• Links the subprogram P. which has standard Ada interrupt entries numbered 5 
through 20. 


6 JJ8 »{nolenable-task -trace 

•«fiable_task_trace 
•nociuUc_taisk_trace (default) 

This option instructs the exception handler cd produce a stack trace when a task terminates because 
of an unhandled exception. 


Configurable Data 

CD TRACE ENABLED 




> 0 - tMk crAca dlsablad 
• 1 - task traea anablad 


6J.29 -cxception^space 

•exception_space n 
•exception-space OaOh (default) 

Each stack will have set its top area aside for exception space. When an exception occurs, the 
exception handler may switch stack to this area to avoid accidental overwrite below the stack 
bottom (which may lead to protection exceptions) if the size of the remaining part of the stack 
is smaller than the N value. Specifying a value >0 will never cause stack switching. Otherwise an 
N value below the default value is not recommended. 


Configurable Data 

CD EXCEPTZOII STACK SPACE SIZE 


I N T EBER 


Note that this value is added to aU requests for task stack space, thus requiring an increase in the 
requirements of the appropriate «gmM's size 


73 









DACS-80X86 User’s Guide 
The Ada Linker 


&5J0 •aign^on 
•dgnjon [<atrhi^] 

When dus option is qxcified the linker will genenie code lo output a sign on message, before 
the Ada elaboration is initiated and a sign off message when the target program has tenninated 
succettftiUy. If the program leiminaies with an uncaugtu exception, the sign off message is not 
printed. 

The sign on message oonsisis of: 

START (<snin|^] <program narno 
and the sign off message 
STOP (<stiin^] <profiam narno 
The <»iing^ may contain spaces. e.g. 

•sign-on Test 3" (lemember the quotes). 

This facility is very useAil to separate output ftom several tatget programs run after each other, 
and to verify that a program that produces little or no output has actually been loaded and tun 
successfully. 


74 






APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type SHORT_INTEGER is range -32_768 .. 32_767; 

type INTEGER is range -2_147_483_648 .. 2_147_483_647; 

type L0N6_INTEG£R is 

range -16#8000_0000_OOOQ_0000# .. 16#7PFF_FFFF_FFFF_FFFF#; 

type FLOAT is digits 6 

range -16#0.FFFF_FF#E32 .. 16#0.FFFF_FF#E32; 

type LONG_FLOAT is digits 15 

range -16#0.FFFF_FFFF_FFFF_F8#E256 .. 16#0.FFFF_FFFF_FFFF_F8#E256; 
type DURATION is delta 2#1.0#E-14 range -131_072.0 .. 131_071.0; 
end STANDARD; 


C-1 












APPENDIX F - IMPLEMENTATION-DEPENDL^ CHARACTERISTICS 


This appendix describes the impletnentation-dependent characteristics of DACS-80X86™ as required 
in App^ix F of the Ada Reference Manual (ANSI/MIL-STD-181SA). 


F.l Iinpienientation*Depcndent Pragmas 

This section describes all implementation defined pragmas. 


F.1.1 Pragma INTERFACE^PELUNG 

This pragma allows an Ada program to call a non-Ada program whose name contains characters 
that are invalid in Ada subprogram identifters. This pragma must be used in conjunction with 
pragma INTERFACE. i. e.. pra gma INTERFACE must be specified for the Ada subprogram name 
prior to using pragma INTERFACE.SPELLING. 

The pragma has the format: 

pragma INTERFACE.SPELUNC (subprogram name, string literal): 

where the subprogram name is that of one previously given in pragma INTERFACE and the string 
literal is the exaa spelling of the interfaced sut^rogram in its native language. This pragma is 
only required when the subprogram name contains invalid characters for Ada identifiers. 

Example: 

function RTS^GetOataScqment return Integer; 
pragnta INTERFACE (ASM86, RTS_GctOataSegnient); 

pragma INTERFACE_S9ELLING (RTS_G«tOataSeginent, '’RlSMGS?GetDataSegment”); 

The string literal may be appended ’NEAR (or ’FAR) to specify a particular method of call The 
default is ’FAR. This sufflx should only be used, when the called routines require a near call 
(writing ’FAR is however harmless). If ’NEAR is added, the routine must be in the same segmetu 
as the caller. 


F.1 J Pragma LT^EGMENT_SIZE 

This pragma sets the size of a library task stack segment. 

The pragma has the format: 

pragma LT_SEGMENT_SIZE (T, N); 

where T denotes either a task object or task type and N designates the size of the library task 


193 










DACS-80x86 User's Cuide 
Impiemeimtion-Dependem Ouractehstics 


stack segment in words. 


The library task’s stack segment defaults to the size of the library task stack. The size of the 
library task stack is normally specified via the tepresemation clause (note that T must be a task 

type) 


for T’STORAGE_SIZE use N; 

The size of the library task stack segment determines how many tasks can be created which are 
nested within the litnary task. All ta^ created within a library task will have their stacks 
allocated from the same segment as the library task stack. Thus, pragma LT.SEGMENT.SIZE 
must be ^recified to reserve space within the library task stack segmem so that nested tasks’ 
stacks may be allocated (see section 7.1). 

The following restrictions are places on the use of LT.SEGMENT.SIZE: 

1) It must be used only for library tasks. 

2) It must be placed iitunediaiely after the task obj«t or type name declaration. 

3) The library task stack segmem size (N) must be greater than or equal to the library task 
stack size. 


F.1 J Pragma EXTERNALJ4AME 


F.1J.1 Function 

The pragma EXTERNAL.NAME is designed to make permanem Ada objects and subprograms 
externally available using names supplied by the user. 


F.UJ Format 

'The format of the pragma is: 

pragma EXTERNAL.NAME(<ada_entity>,<exteniai nanie>) 
where <ada_eniity> should be the name of: 

• a permanem object, i.e. an objea placed in the permanem pool of the compilation unit • such 
objects originate from package specifications and bodies only, 

• a constant object, i.e. an objea placed in the constam pool of the compilation unit • {Hease 
note that scalar constants ate embedded in the code, and composite constants are not always 
placed in the constant pool, because the constam is not consideted constam by the compiler. 


194 




DACS-80x86 User’s Guide 
Impiemematioo-Oependem Characteristics 


• a subprogram name, i.e. a name of a subprogram defined in this compilation uitit • please 
notice that separate subprogram specifications cannot be used, the code for the subprogram 
must be presm in the compilation unit code, and where the <exteinal name> is a string 
specifying the external name associated the <ada_entity>. The <extetnal nanres> should be 
unique. Specifying idetuical spellings for differetu <ada.eniities> will generate errors at compile 
and/or lirik time, and the responsibility for this is left to the user. Also the user should avoid 
spellings similar to the spellings generated by the compiler, e.g. E_xxxxx_yyyyy. P.xxxxx. 
C.xxxxx and other iruemal identifications. The target debug type information associated with 
such external names is the null type. 


F.IJJ Restrictions 

Objects that are local variables to subprograms or blocks canrx>t have external names associated. 
The entity being made external (’’public") must be defined in the compilation unit itself. Attempts 
to name entities hom other compilation units will be rejected with a warning. 

When an entity is an object the value associated with the symbol will be the relocatable address 
of the first byte assigned to the object 


F.l J.4 Example 

Consider the following package body fragment: 

paclcag* body exanple is 

subtype stringlO is string(1..10); 

type s is 
record 

len : integer; 
val : stringlO; 
end record; 

global_s : a; 

con3t_s : constant stringlO "12345678J0"; 

pragma EXTERNAL_NAME(global_s, "GLOBAL_S_OBJECT"); 
pragma EXTERNAL“NAME<const_3, "CONST_S"); 

procedure handle (...) is 

end handle; 

pragma EXTERNiU._HAME(handle, "HANDLE PROC"); 


end example; 

The objects GLOBAL.S and CONST.S will have associated the names "GLOBAL_S_OBJE(rT" 
and "CONST.S". The procedure HANDLE is now also kr»wn as "HANDLE_FROC". It is 


195 






DACS*80x86 User's Guide 
lin(riememaiion>Dependeiu Quractehstics 

allowable to assign more than one external name to an Ada entity. 


F.U3 Object Layouts 

Scalar objects are laid out as described in Ou^r 9. FOr arrays the objea is described by the 
address of the Hrst element: the array constraint(s) ate NOT passed, and therefore it is 
recommended only to use arrays with known constraints. Non- discriminated records take a 
consecutive numb^ of bytes, whereas discriminated lecortls may contain pointers to the heap. Such 
complex objects should be made externally visible, ottly if the user has thorough knowledge about 
the layout 


F.UiS Parameter Passing 

The following section describes briefly the fundamentals regarding parameter passing in connection 
with Ada subprograms. For more detail, refer to Chapter 9. 

Scalar objects ate always passed by value. For OUT or IN OUT scalars, code is generated to 
move the modified scalar to its destination. In this case the stack space for parameters is not 
removed by the procedure itself, but by the caller. 

Composite objects are passed by reference. Records ate passed via the address of the first byte 
of the record. Constrained arrays are passed via the address of the first byte (plus a biioffset when 
a packed array). Unconstrained arrays are passed as constrained arrays plus a pointer to the 
constraints for each index in the array. These constraints consist of lower and upper bounds, plus 
the size in words or bits of each element depending if the value is positive or negative 
respectively. The user should study an appropriate disassembler listing to thoroughly understand 
the compiler calling conventions. 

A function (which can only have IN parameters) returns its result in registerfs). Scalar results are 
registers/floai registers only; composite results leave an address in some registen and the rest, if 
any. are placed on the stack top. The stack still commits the parameters in this case (since the 
function result is likely to be on the stack), so the caller must restore the stack pointer to a 
suitable value, when the function call is dealt with. Again, disassemblies may guide the user to 
see how a particular function call is to be handled. 


F.1.4 Pragma INTERRUPT-HANDLER 

This pragma will cause the compiler to generate fast interrupt handler entries instead of the normal 
task calls for the entries in the task in which it is specified. It has the fbnnat: 

pragma INTCRRUPT_HANDLER; 

The pragma must appear as the first thing in the specificaiion of the task object The task must 
be specified in a package and not a procedure. See Section F.6.2.3 for more details and restrictions 
on specifying address clauses for task entries. 


196 






OACS-80x86 User’s Guide 
Ifflplememauon-Oependera Chancteristics 


F.1J Pragma MONITOR.TaSK 


F.U.1 Function 

The pragma MONTTOR.TASK is used to specify that a task with a cenain structure can be 
handled in a special way by the Run-Tune System, enabling a very eflicient context switch 
operation. 


F.UJ Format 
The foimai of the pragma is 
pragma MONTrORJTASK: 

The pragma must be given in a task specification before any entry declarations. 


F.IJJ Restrictions 


The following restrictions apply on tasks containing a pragma MONTTORJTASK : 

• Only single anonymous tasks can be "monitor tasks". 

• Entries in "monitor tasks" must be single entries (i-e. not family entries). 

• The taA and entry attributes are not aUowed for "monitor tasks” and "monitor task” entries. 

• The <declarative parc> shouTld only contain declaration of objects; no types or nested sturcmies 
must be used. 

• The structure of the task body must be one of the following: 

1 . 

tMk body MOM_XMX ia 
<U«elaraei^ p«rt> 
bagln 

<at«taaMiic llat> 
loop 

aalaet 

aeeapt EimT l<p«raaMC«r_llsc> [do 
•ndj; ~ 

or 

•ceape BmY_2<paraawtac_llse> [do 
<at«ca«Mit3ilst> ~ 

•«d]; ” 

or 

tosaUnato 
and aalaet'.- 
and loop; 
and; 


where each entry declared in the specification must be accepted unconditionally exactly once. 


197 





DACS*80x86 User’s Guide 
Implementation-Dependeiu Chanctetistics 


2 . 

CMk body HOM.TMX la 
<doel«r«civo poro 
bogia 

<at«caaoac llst> 
loop 

aceopt MON_EiiTKy<paraMCot_llat>(do 
<scaeaMnt_liat> ~ 

•ndl; 

•nd loop; 
ond; 

where the task <»ily has one entry. 

In both cases the declarative pans, the staiemem lists and the parameter lists may be empty. 
The statemem list can be arbitrarily complex, but no nested selea or accept statements are 
allowed. 

No exception handier in the monitor task body can be given. 

The user must guararuee that no exceptions are propagated out of the accepts. 


F.13.4 Example 

The following tasks can be defined 

taak US7 BMlOLn la 

pcagma MONITOR TASK; 

•fttsy ZMSXRT(tUM:ElXM TTPS) ; 

•fiery RCMOVecEUMiOUt Ium TTVE); 

•fiery IS msENT<IXIM:SUH TT»E; 

RXsin.T;eue~aooLeAM) : 

•fid LZST_BAIIOUR; 

eaak body LIST BAMDUX la 
*da£lti« llae* 

bagin 

’Ifiieiallza llae* 
a«laee 

aeeape INSERT<ELEM:EUM_TYVEIdo 
’Ifiaare In Use* ~ 

•nd INSERT; 
or 

aeeope remove<EUM: one eLXM_TTVEIdO 
'find In llae and r«aov« ?roa llae* 
•nd REMOVE 
or 

•eaape IS present (EUMiELEM ttpe 

~ RES: oue ioOLEAHIdO 

*aean llae* 

•nd ZS_PRESENT; 
or ~ 
eomlnae*. 

•nd aoloee 

•nd MON TASK; 


The task can be used 

eaak eyp« LZST_oseR la 

and UST.OSER; 

eaak body LZST_aSER la 





DACS-80x86 User's Guide 
Implementation-Dependent Characteristics 


b««ln 

■•iMt 

Lin BMIDLE]l.n)S»T(riRn SLSM); 

•X** 

r«la« niS£XT_aU(oa; 
and saXaet; ~ 
loop 

LIST^UHDLER. INSEKT (NEX7_EIXM) ; 
and loop; ~ 

and Ltn OSDt; 


F.l^ Pragma TASK.STORAGE.SIZE (T, N) 

This pragma may be used as an alternative to the attribute 'TASK_STORAGE_SIZE to designate 
the storage size (N) of a particular task object (T) (see section 7.1). 


FJ Implementation-Dependent Attributes 
No implemenution-dependem attributes are defuied. 


FJ Package SYSTEM 

The specirications of package SYSTEM for all DACS-80x86 in Real Address Mode and 
DACS-80286PM systems are identical except that type Name and constam Sysiem.Name vary: 


Compiler System 




DACS-8086 iAPX86 

DACS-80186 iAPX186 

DACS-80286 Real Mode iAPX286 

DACS-80286 Protected Mode iAPX286 PM 


Below is package system for DACS-8086. 


packagn Systam Is 

typ« Word Xs n«« Intagar; 

typa DNerd Is naw Long_Xntagas; 

typa OnalgnadHord la ranga 0..6S53S; 

for OnslgnadNotd'SIZE usa 1C; 

typa byta Is canga 0..2SS; 

Sor byta' size usa 8; 

subtypa Sa gs w n tid la OnalgnadHord; 

typa Addzaas la 

raeord 

offsat : Onalgnadlord; 
sagaant ; SagsMntld; 
and raeord; 

subtypa Priority Is Intagar ranga 0 .31; 


199 






DACS*80x86 User’s Guide 
Imidementttion-Dependera Charactehstics 


typ« Mmm Is (lAPXtC); 

STStXKJKMa ; eonstsat NasM :• UfXtC; 

STOMOC OMIt : constant ;> 1C; 

HD«my_SXZX : constant 1 04C SIC; 

MXM m : constant •? 147 413 S47-1: 

MUC'lMT : constant 2 l47 4C3 447; 

MJUC~D1GITS : Constant l5; 

lttX~HMRISSA : constant :« 31; 

rzn.DELTX : Constant ;> 2C1.0CC>31; 

TICK : constant :• 0.000_000_12S; 

typo XntocSaea language la 

(ASMS. PLMS, CSC. CSC RZVEMX, 

ASM ACT. SLNJkCr, C ACT, C UVDtSE ACT, 
ASM.MOACr, SLM.WACr, C~IIQACr. C^SCVnSEJIQACr) ; 

typo Cxeaptlenld is caeoed 

unlt^nuaboc : OnalgnodHocd; 
unlguo_nuaibos : OnalgnodMord; 
and roeord; 

typo TaakValua is now Xntogoc; 

typo AccTaskValuo Is aceoss Taskvaluo; 
typo SosisphoroValuo Is now Xntogoc; 

typo Sanaphoco la cocoed 

counter 
ftest 
last 
SQMoxt 

and cocord; 

XnltSsaMphoco : constant saauiphoro :• SoMphoco'(1.0,0,0); 
and System; 


The package SYSTEM specification for DACS*80386PM package system is: 

package System Is 

typo Word Is now Shect^Xntogoc; 

typo OHosd Is now Integer; 

typo QMoed Is now Long_Xntogoc; 

typo OnslgnodMocd Is range 0..CSS3S; 

for OnalgnodMord'SXZK use IC; 

typo OnslgnodOWord Is range 0.. IScnrrjmTC; 

for OnslgnadONord'SXU use ?2; ~ 

typo Byte Is range 0..2SS; 

for Syto'SXZS use 8; 

subtype Sagowntid Is OnalgnodNord; 

typo Address Is 

record 

offset : OnslgnodDHord; 
segment : SagsMntXd; 
and rocord; 


for Addraas use 
roeord 

offset at 0 range 0..31; 
sogsMnt at 2 range 0..1S; 
end record; 


subtype Priority la integer range 0..31; 


: Xntegac; 

; TaakValue; 

: TaakValua; 

: Semaplierevaluo; 

only used In BOS. 


200 










DACS-80x86 User’s Guide 
Implemenution<Dependem Quuacteristics 


typ« MaM la (lMX3tS_PM); 

STSTCN_tMME : ceoatant Naaa :> lAPX 3 ac_nt; 

STOXAeS^OMIT : eonatant :• 1C; ~ 

MD(0»r_?I2Z : eenataiit ;• 1SI1_0000 0000*; 

: eonatant :• -IStSOOO 0000 0000 0000*; 

l«X_IlTt : eonatant :• 16*7nT frfT FTTT mT»; 

MMC DIGITS : eonatant 13; 

MAXJMIiTZSSA : eonatant 31; 

FZMS_0eLZX ; eonatant :• 2tl.0*E-31; 

TICK ; eonatant :• 0.000 000 0S2 5; 


typa Intarfaea^lanGuaGo la 

(ASKSC, tlMt, esc, CSS KEVniSE, 

ASM_ACr, PUt_ACr, C ACT, C SEVtUSE ACT, 

ASM~MaACr, PuTtnACF, C^NOACF, c2UVEMe~NOACr) 

typo Exeoptlonld la raeord 

unlt^nimboe : OnalonadONord; 
unlqtta_nuabar : OnalgnadONord; 
and caeoed; 

typa XaakValua la now Intadae; 

typa AceTaakvalua la aeeaaa TaakValua; 

typa SaaaphoraValua la naw Inta«ar; 

typa SaaMphora la raeord 

eeuntar 
flrat. laat 
SCMaxt 

and raeord; 

InltSaauiphora : eonatant Sanutphora :> Saauiphora'(l.O.O.O.- 
and Syataa; 


F.4 Representation Cbuses 

The DACS-80x86™ fully supports the 'SIZE representation for derived types. The represeruation 
clauses that are accepted for non-derived types are described in the following subsections. 


F.4.1 Length Clause 

Some remarks on imfriementation dependent behavior of length clauses are necessary: 

• When using the SIZE attribute for discrete types, the maximum value that can be specified is 
16 bits. For DACS-80386PM/80486PM the maximum is 32 bits. 

• SIZE is only obeyed for discrete types when the type is a part of a composite object, e.g. 
arrays or records, for example: 

type byte is range 0..2S5; 
for byte'size use 8; 

sixteen_bits_allocated : byte; — one word allocated 


: Intnenr; 

: TAJkVnlun; 

: SnoaphocnVnlun; 

only uand In HOS. 










DACS-80x86 User’s Guide 
Iinplemeiiuiion>Dependem Chuacterisdcs 


•ight_bit_p«r_«l«ment : array(0..7) of byte; — four words allocated 
type rec is 
record 

cl,c2 ; byte; — eight bits per component 

end record; 


• Using the STORAGE.SIZE attribute for a collection will set an upper limit on the total size 
of objects allocated in this collecdoa If further allocation is attempted, the exception 
STORAGE_ERROR is raised. 

• When STORAGE.SIZE is specified in a length clause for a task type, the process stack area 
will be of the specified size. Hie process stack area will be allocated inside die "standaid" stack 
segment Note that STORAGE.SIZE may not be specified for a task object 


F.4J Enumeration Representation Clauses 

Enumeration representation clauses may specify representations in the range of •32767..-f32766 (or 
-16#7FFF..16#7FFE). 


F.4J Record Representation Clauses 

When representation clauses ate applied to records the following restrictions are imposed: 

• if the componera is a record or an unpacked array, it must stan on a storage unit boundary 
(16 bits) 

• a record occupies an integral number of storage units (words) (even though a record may have 
fields that only define an odd number of bytes) 

• a record nuy uke up a maximum of 32K bits 

• a comptmem must be specified with its proper size (in bits), regardless of whether the 
componem is an array or not (Please note rHat record and unpacked array components take up 
a number of bits divisible by 16 (sword size)) 

• if a non-array conponeru has a size which equals or exceeds one storage unit (16 bits) the 
component must start on a storage unit boundary. i.e. the componem must be specified as: 

component at N range 0..16 * M • I; 

where N specifies the relative storage unit number (0.1....) from the beginning of the record, and 

M the requited munber of storage units (1.2....) 

• the elements in an array componem should always be wholly contained in one storage unit 

• if a componem has a size which is less than one storage unit it must be wholly contained 
within a single storage unit: 


202 




DACS-80x86 User’s Guide 
Imptemencation-Dependeiu Chantcteristics 


component at N range X .. Y; 

where N is as in previous paragraph, aiul O <« X <s Y <s 15. Note that for this restriction 
a component is not required to start in an integral number of storage units from the beginning 
of the record. 

If the record type contains components which are not covered by a componem clause, they are 
allocated consecutively after the componem with the value. Allocation of a record component 
without a componem clause is always aligned on a storage unit boundary. Holes created because 
of componem clauses are not othenvise utilized by the compiler. 

Pragma pack on a record type win attempt to pack the components not already covered by a 
tepresemadon clause (perhaps none). This packing will begin with the small scalar components and 
larger components will follow in the order specified in the record. The packing begins at the first 
storage unit after the components with representation clauses. 


F.4J.1 Alignment Clauses 

Alignment clauses for records are implemented with the following characteristics: 

• If the declaration of the record type is done at the outermost level in a library package, any 
alignmem is accepted. 

• If the record declaration is done at a given static level higher than the outermost library level. 
i.e., the permanem area), only word alignments are accepted. 

• Any record object declared at the outermost level in a library package will be aligned according 
to the alignment clause specified for the type. Record objects declared elsewhere can only be 
aligned on a word boundary. If the record type is associated with a differem alignment, an 
error message will be issued. 

• If a record type with an associated alignment clause is used in a composite type, the alignment 
is required to be one word; an error message is issued if this is not the case. 


FJ5 Impletnentation*Dependent Names for Implementation Dependent Components 
None defined by the compiler. 

F.6 Address Clauses 

This section describes the implementation of address clauses and what types of entities may have 
their address specified by the user. 


203 






DACS*80x86 User's Guide 
linpiemenuiion'Oependera Quracteristics 


F^l Objects 

Address clauses are supponed for scalar and composite objects whose size can be detennined at 
crenpile time. The address clause may denote a dynamic value. 


Task Entries 

The imfdememaiion suppons two methods to equate a task entry to a hardware inieirupt through 
an address clause: 

1) Direa transfer of control to a task accept statement when an intemipt occurs. This form 
requires the use of pragma INTERRUPT.HANEX^. 

2) Mapping of an iruenupt onto a normal conditional entry call. This fonn allows the intemipt 
entry to be called from other tasks (without special actions), as well as being called when 
an intemipt occur. 


F.6J.1 Fast Interrupt Tasks 

Directly transferring control to an accept statemem when an iiuemipt occur requires the 
implementation dependent pragma iNTERRUPT_HANIH.ER to tell the compiler that the task is 
an interrapt handler. 


F.6JJ Features 

Fast interrupt tasks provide the following features: 

• Provide the fastest possible response time to an intemipL 

• Allow entry call ; to other tasks during interrupt servicing. 

• Allow procedure and function calls during interrupt rervidng. 

• Does not require its own stack to be allocated. 

• Can be coded in packages with other declarations so that desired visiblity to appropriate parts 
of the program can be achieved. 

• May have multiple accept statements in a single fast intemipt task, each mapped to a different 
interrupt If more than one intemipt is to be serviced by a single fast interrupt task, the accept 
statements should simply be coded consecutively. See example 2 how this is done. Note that 
no code outside the accept statemems will ever be executed. 


2(M 





DACS-80x86 User's Guide 
Imptememaiion-Oependent Qianctenstics 


F.6JJ Limitations 

By using the fast interrupt feature, the user is agreeing to place cenain restrictions on the task in 

order to speed up the software response to the intermpc Consequently, use of this method to 

capture interrupts is much faster than the normal method. 

The following limitations are placed on a fast interrupt task: 

• It must be a task object, not a task type. 

• The pragma must appear first in the qxcification of the task object. 

• All entries of the task objea must be single entries (no families) with no parameters. 

• The entries must not be called frtMn any task. 

• The body of the task must not contain any statements outside the accept statement(s). A loop 
statemem may be used to enclose the accept(s). but this is meaningless because no code outside 
the accept statements will be executed. 

• The task may make one entry call to another task for every handled interrupt, but the call must 
be single and parameterless and must be made to a normal tasks, not another fast imerrupt 
task. 

• Tte task may only reference global variables; no data local to the task may be defined. 

• The task must be declared in a library package. i.e., at the outermost level of some package. 

• Explicit saving of NPX state must be performed by the user within the accept statemem if such 
state saving is required. 


F.6.2.4 .Making Entry Calls to Other Tasks 

Fast imerrupt tasks can make entry calls to other normal tasks as long as the entries are single (no 
indexes) and parametetless. 

If such an emry call is made and there u ssibiUty of the normal task not being ready to 
accept the call, the entry call can be queued u ihe normal task’s entry queue. This can be forced 
by using the normal Ada condidonal entry call construa shown below; 

accept E do 
selea 
T.E; 
else 

null; 

end select; 
end E; 

Normally, this code sequence means make the call and if the task is not waiting to accept it 
immediately, cancel the call and continue. In the context of a to interrupt task, however, the 
semantics of this construa are modified slightly to force the queuing of the entry call. 


20S 







DACS*80x86 User's Guide 
Implemenution-Depemtem Chancteiistics 


If an unconditional entry caU is made and the called task is not waiting at the corresponding 
accept statement, then the imerrupt task will wait at the entry call. Alternatively, if a timed entry 
call is made and the called task does not accept the call before the delay ei^ires. then the call 
will be dropped. The conditional entry call is the preferred method of making task entry calls 
from fast interrupt handlers because it allows the imerrupt service routine to complete straight 
thiDUgh and it guarantees queueing of the entry call if the called task is not waiting. 

When using this method, make sure that the imerrupt is included in the -interrupt_entry_table 
specified at link time. See Section 7.2.15 for more dettuls. 


F.6J.5 Implcmentadon of Fast Interrupts 

Fast imerrupt tasks are not actually implememed as true Ada tasks. Rather, they can be viewed 
as procedures that consist of code simply waiting to be executed when an interrupt occurs. They 
do not have a state, priority, or a task control block associated with them, and ate not scheduled 
to "tun" by the run-dme system. 

SitKe a fast interrupt handler is not really a task, to code it in a loop of somekind is meaningless 
because the task will never loop; it will simply execute the body of the accept statemem whenever 
the imerrupt occurs. However, a loop construct could make the source code mote easily understood 
and has no side effects except for the generation of the executable code to implemem to loop 
construct 


F.6J2.6 Flow of Control 

When an interrupt occurs, control of the CPU is transferred directly to the accept statemem of the 
task. This means that the appropriate slot in the interrupt vector nble is modified to contain the 
address of the corresponding fast iruerrupt accept suuemenL 

Associated with the code for the accept statemem is 

at the very begiruiing; 

code that saves registers and sets (E)BP to look like a frame where the iruerrupt return 
address works as leium address. 

at the very end: 

code that restores registers followed by an IRET instruction. 

Note that if the interrupt handler makes an entry call to another task, the imerrupt handler is 
completed through the IRET before the rendezvous is actually completed. After the rendezvous 
completes, normal Ada task priority niles will be obeyed, and a task context switch may occur. 

NormaOy. the imerrupiing device must be reenabled by receiving End-OMmerrupt messages. These 
can be sem ftom machine code insertion statements as demonstrated in Example 7. 


206 



DACS-80X86 User’s Guide 
Implementadon-DqKndeitt Chancterisdcs 


F^7 Saving NPX Stale 

If the intemipt handler will perfonn floanng point calculations and the state of the NPX must be 
saved because other tasks also use the numeric coprocessor, calls to the appropriate save/restore 
routines must be made in the statement list of the accept statement. These routines are located 
in package RTS.EntryPoints and are called RTS_Stoie_NPX_State and RTS_Restoie_NPX_State. 
See example 6 for more information. 


FS2Jt Storage Used 

Tliis section details the storage requirements of fast inrerrupt handlers. 


F.6J.9 Stack Space 

A fast interrupt handler executes off the stack of the task executing at the time of the iruerrupt 
Since a fast imermpt handler is not a task it does not have its own stack. 

SiiKe no local data or parameters are permitted, use of stack space is limited to procedure attd 
function calls from within the interrupt handler. 


F.6J.10 Run<Titne System Data 

No task control block (TCB) is created for a fast interrupt handler. 

If the fast interrupt handler makes a task entry call, an et^ in the .OD.INTERRUPT.VECTOR 
must be made to allocate storage for the queuing mechanism. This table is a run-time system data 
structure used for queuing interrupts to normal tasks. Each entry is only 10 words for 8(^86/80486 
protected mode compilers and S words for all other compiler systems. This table is created by 
the linker and is constrained by the user through the linker option >intciTupt_entry_tabie. For 
more information, see Section R6.2.1 on linking an application with fast internipts. 

If the state of the NPX is saved by user code (see Section F.62.7), it is done so in the NPX save 
area of the TCB of the task executing at the time of the interrupL This is appropriate because it 
is that task whose NPX state is being saved. 


F.6J Building an Application with Fast Interrupt Tasks 

This section describes certain steps that must be followed to build an application using one or 
more fast imerrupt handlers. 


207 






DACS-80X86 User's Guide 
Impleiiienution-Dependent Characteristics 


F4J.1 Source Code 

The pngma INTERRUFT.HANDLER which indicses that the imenupt handler is the fast foim 
of imenupt handling and not the nonnal type, must be placed in the task specification as the fim 
statemem. 

When specifying an address clause for a fast intemipt handler, the offset should be the imerrupt 
number, not the offset of the imemipt in the intmntpt vector. The segment is not applicable 
(althou^ a zero value must be specified) as it is not u sed by the compiler for imenupt addresses. 
The compiler wai place the imenupt vector into the INTERRUFTVECTORTABLE segment FOr 
teal address mode piograms, the imenupt vector must always be in segmem 0 at execution time. 
For protected mode programs, the user specifies the imemipt vector location at build time. 

Calls to RTS_Store_NPX_State and RTS_Restore_NPX_State must be included if the state of the 
numeric coprocessor must be saved when the fast interrupt occrus. These routines are located in 
package RTS_EntryPoirus in the toot library. See example 6 for more information. 


F.6JJ*Compiiing the Program 
No special compilation options are required. 


F.6JJ Linking the Program 

Since fast imenupt tasks are not real tasks, they do not have to be accounted for when using the 
•tasks optitm at link time. In fact, if there are no normal tasks in the application, the program 
can be linked without •tasks. 

This also means that the linker options -It^stack.sizc. •It^scgment^size. •nip_scgmcnt_size. and 
•task_storage_sizc do not apply to fast intemipt tasks, exnpt to note that a fan imerTupT task will 
execuK off the stack of the task nmning at the time of the imenupL 

If an entry call is made by a fast iiuenupt handler the imerrupt number must be included in the 
•intemipt_entry_tablc option at link time. This option builds a tairie in the run-time system daa 
segment uT handle entry calls of interrupt handlers. The taUe is indexed by the imerru^ number, 
which is bounded by the low arxl high imenupt numbers specified at link time. 


F.6J.4 Locatin^uilding the Program 

For real-address mode programs, no qiecial actions need be perforated at link time; the compiler 
creates the appropriate entry in the INTERRUPTVECrORTABLE segment This segmem must be 
at segmem 0 before the first interrupt can occur. 

For protected mode programs no special actions need be performed. The Ada Link automatically 
recognizes Ada imenupt handlers and adds them to the IDT. 


208 








DACS*80x86 User's Guide 
Imptemenuikm-Dqjefident Characteristics 


F.6.4 Examples 

These examples illustrate how to write fast interrupt and then how to build the application 
using the fast ineriupt tasks. 


F.6.4.1 Example 1 

This example shows how to code a fast imenupt handler that does not make any task entry calls, 
but simply performs some interrupt handling code in the accept body. 

Ada source: 

with System; 
package P is 

<potentially other declaianons> 

task Fast_Int etrupt _Handler is 
pragma INTERRUPT_HANDLER; 
entry E; 

for E use at (segmem «> 0. offset s> 10): 
end; 


<potentially other declarations> 


end P; 

package body P is 

<potentially other declarations> 

task body Fast.Interrupt.Handler is 
begin 

accept E do 

<handle interrupc* 
end E; 
end; 


<potentially other declarations> 


end P; 


with P: 

procedure Example.! is 
begin 

<main ptogtam> 
end Example.!; 


Compilation and Linking: 


209 






DACS-80x86 User's Guide 
Implcmcnmioo-Dependent Chanctenstics 


S ada Exainpk_l 

S adaJink Exan^_l ! Note: no otiicr tasks in the system in this exanqtk. 


F.6.4J Example 2 

This example shows how to write a fast inienupt handler that services more than one interrupt. 


Ada source: 

with System: 
package P is 

task Fast_Intemipt_HandIer is 
pragma INTERRUPT.HANDLER: 

entry El; 
entry E2: 
entry E3: 

for El use at (segmem s> 0, offset «> S); 

for E2 use at (segment >> 0, ofCret «> 9): 

for E3 use at (segment »> 0, offset »> 11): 

end; 

end P; 

package body P is 

task body Fast_Intenupt_Handler is 
begin 

accept El do 

<service interrupt 5> 
end El; 

accept E2 do 

<seTvice interrupt 9> 
end E2; 

accept E3 do 

<service interrupt 11> 
end E3; 
end; 

end P; 


Compilation and Linking: 


210 





DACS*80x86 User’s Guide 
Implememarion-Dgwident Chancteristics 


S ada Exainpie_2 

S ada-Jink 'tasks • Exainpic_2 * assumes application also has normal casks (not shown) 


F.d.4J Exaiiq>le 3 

This example shows how to access global dau and make a procedure call from within a fast 
interrupt handler. 


Ada source: 

with System; 
package P is 

A : Iiueger, 

task Fast_Intetnipt_Handler is 

pragma INTERRUPT_HANDLER: 
entry E; 

for E use at (segmem «> 0, offset s> 16#127#): 

end: 
end P; 

package body P is 
B : Integer. 

procedure P (X : in out Integer) is 
begin 

X X + 1; 
end; 

task body Fast_Inierrupt_Handler is 
begin 

accept E do 
A ;= A + B; 

P (A); 
end E; 

end; 
end P; 


Compilation and Linking: 

S ada Exampie_3 
$ ada-link Exani^e_3 


211 






DACS-80X86 User's Guide 
Inidementttioii-Dependent CSiaractehstics 


F.6.4.4 Example 4 

This example shows how to make a task entry call arxl force it to be tpieued if the called task 
is not wailing at the accept at the time of the call. 

Note that the application is linked with -taskssl. where the tasks are T and the main program. 
Since the fast imemipi handler is making an entry call to T. the techniques used guarantee that 
it will be queued, if necessary. This is accomplished by using the conditional call construa in 
the accept body of the fast interrupt handler and by including the imenupt in the - 
inteiTupt_entry_tablc at link time. 


Ada source: 

with System: 
package P is 

task FastJntenupt.Handler is 

pragma INTERRUPT_HANDLJER: 
entry E; 

for E use at (seg..ient *> 0. offset 8): 
end: 

task T is 
entry E 
end: 

end P: 

package body P is 

task body Fast_Imenupt_Handler is 
begin 

accept E do 
selea 
T.E: 
else 

null: 

end select; 
end E 
end: 

task body T is 
begin 
loop 
selea 
accept E 
or 

delay 3.0; 
end select; 
end loop; 
end: 

end P: 


212 




DACS-80x86 User’s Guide 
Implementation-Dependent Characteiistics 


Compilation and Linking: 

S ada Example_4 

$ ada-Jink -tasks 2 -interrupt_enti 7 _table M Example_4 


F.6.4J Example 5 

This example shows how to build an application for 80386/80486 proceaed mode programs using 
fast interrupt handlers. 


Ada source: 


with System; 
package P is 


task Fast_InterTupt„Handler is 

pragma INTERRUPT_HANDLER: 
entry E; 

for E use at (segment => 0, offset => 17): 
end: 


end P: 

package body P is 

task body Fast.Intertupt.Handler is 
begin 

accept E do 
null: 
end E: 
end: 

end P; 


Compilation and Linking: 

S ada Exampie_5 
S ada-link -tasks • Example_5 





DACS*80x86 User’s Guide 
Implememation*Dependem Charaoehstics 


F.6.4Ui Example 6 

This example shows how to save and restore the state of the numeric coproc’^sor from within a 
fast imemipt handler. This would be required if other tasks are using the copiocessor to perfonn 
floating poim calculations and the fast intemipt handler also will use the coprocessor. 

Note that the state of the NPX is saved in the task control block of the task executing at the time 
of the intemipL 

Ada source: 

with System; 
package P is 

task FastJntenupt.Handler is 

pragma INTERRUPT.HANDLER; 
entry E; 

for E use at (segment s> 0. offset 3> 25): 
end: 

end P: 

with RTS_EntryPoints: 
package body P is 

task body Fast_lntemipt_Handler is 
begin 

accept E do 

RTS_EntryPoints.Siore_NPX_State: 

<user code> 

RTS_EruryPoints.Restore_NPX_State: 
end E: 
end: 

end P; 

Compilation and Linking: 

S ada Example_6 

S ada-link ^npx •tasks • Examplej6 


F.6.4.7 Example 7 

TIus example shows how to send an End-Of-Iniemipt message as the last step in servicing the 
interrupL 


Ada source: 


214 






DACS-80x 86 User’s Guide 
Implemenuiion-Dependem Characteristics 


with System: 
package P is 

task Fast_InterTupt_Handler is 

pragma INTERRUPT_HANDLER: 
entry E: 

for E use at (segment » 0. offset s> S); 
end: 

end P; 

with Machine.Code; use Machine.Code: 
package body P is 

procedure Send.EOI is 
begin 

machinejnstruction' 

(registerjmmediatc, m_MOV. AL. 16#66#): 
machinejnstruction* 

(.immediate.register. m_OUT. I6#0e0#. AL); 
end; 

pragma inline (Send.EOI); 

task body Fast.lntenupt.Handler is 
begin 

accept E do 
<user code> 

Send.EOI; 
end E; 
end; 

end P; 

Compilation and Linking: 

S ada Example_7 
S adaJink 'tasks • Example.? 


F.6J Normal Interrupt Tasks 

"Noimal" interrupt tasks are the standard method of servicing interrupts. In this case the intemipt 
causes a conditional entry call to be made to a normal task. 


F.6J.1 Features 

Normal interrupt tasks provide the following features: 

1) Local data may be defined and used by the mterrupt task. 


215 






DACS-80x86 User’s Guide 
Implemenution-Dqjeiidem Characteiisdcs 


2) May be called by other tasks with no restrictions. 

3) Can call other normal tasks with no restrictions. 

4) May be declared anywhere in the Ada program where a normal task declaration is allowed. 


F.6JJ LimitaUons 

Mapping of an interrupt onto a normal conditional entry call puts the following consoaints on the 
involved entries and tasks: 

1) The affected entries must be defined in a task objea only, not a task type. 

2) The entries must be single and parameteriess. 


F.6.5J Implementation of Normal Interrupt Tasks 

Normal intemipt tasks are standard Ada tasks. The task is given a priority and tuns as any other 
task, obeying the normal priority roles and any dme-slice as configured by the user. 


F.6J.4 Flow of Control 

When an interrupt occurs, control of the CPU is transferred to an intemipt service routine 
generated by the specification of the iruerropt task. This routine preserves the registers and calls 
the run-time system, where the appropriate interrupt task and entry are determined from the 
information in the .CD.INTERRUPT^VECTOR table and a conditional entry caU is made. 

If the interrupt task is waiting at the accept statement that corresponds to the interrupt, then the 
interrupt task is scheduled for execudem upon return from the imerrupt service roudne and the call 
to the run-dme system is completed. The interrupt service roudne will execute an IRET. which 
reenables interrupts, and execudon will condrme with the interrupt task. 

If the interrupt task is not waidng at the accept sutemera that corresponds to the interrupt, and 
the interrupt task is not in the body of the accept sutenrem that corresironds to the interru^ then 
the entry call is automadcally queued to the task, and the call to the lutMime system is 
completed. 

If the interrupt task is not waidng at the accept statement that corresponds to the interrupt, and 
the interrupt task is executing in the body of the accept statement that corresponds to the interrupt, 
then the imerrupt service roudne will NOT complete until the interrupt task has exited the body 
of the accept statement During this period, the imerrupt will not be serviced, and execudon in 
the accept body will oondiuie with interrupts disabled. Users are caudoned that if fimn within 
the body of the accept statemem corresponding to an interrupt, an uncondidonal entry call is made, 
a delay statement is executed, or some other mxHleterminisdc acdon is invoked, the result will 
be erradc and will cause non-determinisdc imerrupt respmise. 

Example 4 shows how End-OMmerrupt messages may be sem to the interrupting device. 


216 






OACS*80x86 User’s Guide 
Implememaiion-Dependem Characteristics 


F.6JJ Saving NPX SUte 

Because nonnal intenrupt tasks are standard tasks, the state of the NPX numeric coprocessor is 
saved automatically by the nin-time system when the task executes. Therefore, no special actions 
ate necessary by the user to save the state. 


F.6,.5,6 Storage Used 

This section describes the storage lequiremerus of standard interrupt tasks. 

F.6J.7 Stack Space 

A normal interrupt task is allocated its own stack and executes off that stack while servicing an 
interrupt. See the appropriate sections of this User’s Guide on how to set task stack sizes. 


F.&5,8 Run*Tiine System Data 

A task control block is allocated for each normal iruerrupt task via the 'tasks option at link time. 

During task elaboration, an entry is made in the nsi'dme system _CD JNTERRUPT.VECTOR 
table to "define'* the standard interrupt This mechanism is used by the nm<time system to make 
the conditional entry call when the interrupt occur. This means that the user is responsible to 
include all intetru{Ks serviced by interrupt tasks in the •interrupt_entry_table option at link time. 


F.6.6 Building an Application with Nomui Interrupt Tasks 

This section describes how to build an application that uses standard Ada tasks to service 
interrupts. 


F.6.6.1 Source Code 

No special pragmas or other such directives are required to specify that a task is a normal interrupt 
task. If it contains interrupt eraries, then it is a normal interrupt task by default 

When specifying an address clause for a normal imerrupi handler, the offset should be the 
interrupt number, not the offset t.' the interrupt in the interrupt vector. The segment is not 
applicable (althou^ some value must be specified) because it is not used by the compiler for 
in terrup t addresses. The compiler will place the intemqx vector into the 
INTERRUFTVECTORTABLE segmeriL For real address mode programs, the interrupt vector 
must always be in segmem 0 at execution time. 'This piacemem can be accomplished by specifying 


217 





DACS-80X86 User’s Guide 
Impieniemaiion-Dependem Gtaracteristics 


the address to locate the INTERRUPTVECTORTABLE segment with the loc86 command, or at 
run time, by having the startup code routine of the UCC copy down the 
INTERRUPTVECTORTABLE segment to segment 0 and the compiler will put it there 
automatically. For protected mode programs, the user specifies the interrupt vector location at 
build time. 


F.6.^ Compiling the Program 
No special compilation options are required. 


F.6.6J Linking the Program 

The interrupt task must be included in the •tasks option. The link options •lt_stack_size. — 
lt_scgment_size. •mp_segment_siae, and •task_storage_size apply to normal interrupt ueks and 
mlist be sef to appropriate vaiuK for your appOcation. 

Every interrupt task must be accourued for in the •iiitetTupt_entry_table option. This option 
causes a table to be built in the tun*tinie system dau segmem to han^e interrupt entries. In the 
case of standard interrupt tasks, this table is used to map the interrupt onto a normal conditional 
entry call to another ta^ 


F.6.7 Examples 

These examples illustrate how to write normal interrupt tasks arxl then how to build the application 
using them. 


F.6.7.1 Example 1 

This example shows how to code a simple normal iruenupt handler. 

Ada source: 

with System; 
package P is 

task Notmal_Ituemipt_Handler is 
entry E; 

for E use at (segment 0, offset s> lO); 

end; 
end P; 

package body P is 

task body Nomnal.Intenupt.Handler is 


218 







DACS*80x86 User's Guide 
bnpiementatioii'Dependeiu Characteristics 


begin 

accept E do 

<handle inteiiupt> 
end E; 
end; 

end P; 

with P; 

procedure Example. 1 is 
begin 

<inain program> 
end Example.l; 


Compilation and Linking: 

$ ada Example_l 

S ada_link -tasks 2 •intefTupt_entry_table 10,10 Example^l 


F.6.7^ Example 2 

TTus example shows how to write a noimal interrupt handler that services more than one interrupt 
and has other standard task entries. 

Ada source: 

with System: 
package P is 

task Normal.Task is 

entry El; 

entry E2; - standard entry 

entry E3; 

for El use at (segmem »> 0, offset ■> 7); 
for E3 use at (segmem «> 0, offset »> 9); 

end; 

end P; 

package body P is 

task body Nbrmal.Task is 
begin 
loop 
selea 

accept El do 

<serrice imemipt 7> 


219 










DACS-80x86 User’s Guide 
Imptemenuckin-Depefvtera Chanoehstics 


end El: 
or 

accept E2 do 

<standanl rendezvous> 
end E2: 
or 

accept E3 do 

<service iniemipt 9> 
end E3 ; 
end s ele ct: 
end loop: 

end Nonnal.Task: 
end P. 

Compilation and Unking: 

S ada Exaniple_2 ^ 

> $ adaJink -tasks -intemipt^entry^table IS Exanipie_2 


F.6.7J Example 3 

This example shows how to build an application for 80386 protected mode programs using nomtal 
interrupt handlers. 


Ada source: 

with System: 
package P is 

task Nonnal_InterTupt_Handler is 
entry & 

for E use at (segmem »> 0. offset «> 20): 
end: 

end P 

package body P is 

task body Normal.Interrupt.Handler is 
begin 

accept E do 
null: 
end E; 
end; 

end P 


220 




DACS-80X86 User’s Guide 
Imptementadon-Dependem Quiactenstics 


Compilation and Unking: 

S ada Exanipic_3 

S adaJink 'tasks •internipt_enti 7 _Table 2040 Exanipic_3 


F.6.7.4 Example 4 

This example shows how an End-Of-Iiuenupc message may be sent to the inienupting device. 

Ada source: 

with System; 
package P is 

task Nortnal^Xntecrupt_Handler is 
entry e7 

for E use at (segment *> 0, offset *> 7); 

end; 


end P ; 

with Machine_Code; use Machine_Code; 
package body P is 

procedure Send_,EOI is 
begin ~ 

machine^i nst ruction' 

'’(register_inBnediate, m_MOV, AL, 16*66#) ; 
machine^instruction' 

”(it(inediate_regiater, m_OOT, 16#0e0#, AL) ; 
end; ” ” 

pragma inline (Send_EOI); 

task body Normal_Interrupt_Handler is 
begin 

accept E do 
<user code> 

Send_EOI; 
end E;~ 

end; 


end P; 


Compilation and Unking: 

S ada Example_4 

$ adaUink -tasks -intcmipt^entry^tablc 7,7 Exanqile_4 


221 





OACS-80X86 User’s Guide 
Impiementacion-Dependem Ounciehstics 


F.6J Interrupt Queuing 

DDC-I provides a useful feature that allows task entry calls made by internipi handlers (fast and 
normal variant) to be queued if the called task is not waiting to accept the call, enabling the 
interrupt handler to complete to the OtET. What may not be clear is that the same interrupt may 
be queued only once at any given time in DDC-I's implementation. We have made this choice 
for two reasons: 

a) Queuing does not come for free, and queuing an itueirupt more than once is considerably 
more expensive than queuing just oik. DOC-I feels that most customers prefer their 
interrupt handlers u> be as fast as possible and that we have chosen an implemetuation that 
balances perlbnnance with functionality. 

b) In most applications, if the servicing of an interrupt is not performed in a relatively short 
period of time, there is an unacceptable and poKntiaUy dangerous situation, (^euing the 
same interrupt more than oiKe represents this situation. 

Note that this note refers to queuing of the saiiK inttirupt more than once at the sairw time. 
Different interrupts may be queued at the same time as well as the same interrupt may be queued 
in a sequential maniKr as long as there is never a situation where the queuing overlaps in time. 

If it is acceptable for your application to queue the same interrupt more than once, it is a 
relatively simple procedure to implement the mechanism yourself. Simply implement a high 
priority agent task that is called from the interrupt handler. The agent task accepts calls from the 
interrupt task and makes the call on behalf of the imerrupt handler to the originaUy called task. 
By careful design, the agent task can be made to accept all calls from the interrupt task when they 
are made, but at the very least, must guarantee that at most one will be queued at a time. 


F.6.9 Recurrence of Interrupts 

DDC'I recommends the following techniques to ensure that an imerrupt is complerely handled 
before the same interrupt recurs. There are two cases to consider, i.e. the case of fast interrupt 
handlers and the case of normal interrupt handlers. 


F.6,9.1 Fast Interrupt Handler 

If the fast imerrupt handler makes an emry call to a normal task, then place the code that 
reenables the interrupt at the end of the accept body of the called task. When this is done, the 
interrupt will not be reenabled before the rendezvous is actually completed between the fast 
imerrupt handler and the called task even if the call was queued Note that the imerrupt task 
executes all the way through the IRET before the rendezvous is completed if the entry call was 
queued. 

Normally, eixi-of-interrupi code using Low.LevelJO will be presem in the accept body of the fast 
interrupt handler. This implies that the end-of-interrupt code will be executed before the 
rendezvous is completed, possibly allowing the interrupt to come in again before the application 
is ready to handle it 

If the fast interrupt handler does not make an entry call to another task, then placing the 


222 



DACS*80x86 User’s Guide 
Imptemenufioa-Dependera Cheractenstics 


end-of'iiuemipt code in the accept body of the fast iniemipt task will guarantee that the interrupt 
is completely serviced before another interrupt happens. 


F.6^J Normal Interrupt Handler 

Place the code that reenables the iruenupt at the end of the accept body of the normal interrupt 
task. When this is done, the iruerrupt will not be reenabled before the rendezvous is actually 
completed between the normal iruerrupt handler and the called task even if the call was queued. 
Even though the interrupt "completes” in the sense that the BRET is executed, the interrupt is not 
yet reenabled because the rendezvous with the normal task’s interrupt entry has not been irude. 

If these techniques are used for either variant of iruerrupt handlers, caution must be taken that 
other tasks do not call the task erury which reenables iruerrupts if this can cause adverse side 
effects. 


F.7 Unchecked Conversion 

Unchecked conversion is only allowed between objects of the same "size". However, if scalar type 
has different sizes (packed unpacked), unchecked conversion between such a type and another 
type is accepted if either the packed or the unpacked size fits the other type. 


F.8 Input/Output Packages 

In many embedded systems, there is no need for a traditional I/O system, but in order to sui^rt 
testing and validation. DDC<I has developed a small terminal oriented I/O system. This I/O system 
consists esseruially of 'TEXTJO adapted with respea to handling only a terminal and not file I/O 
(Hie I/O will cause a USE error to be raised) and a low level package called 
TERMINAL.DRIVER. A BASICJO package has been provided for convenience purposes, 
forming an interface between 'TEXTJO and 'TERMINAL.DRrVER as illustrated in the following 
figure. 



The 'TERMINAL.DRIVER package is the only package that is target dependent, i.e.. it is the only 

223 







DACS-80x86 User’s Guide 
Imfriememation'Dependent Chaiaaeristics 


package that need be changed when changing communications controllers. The actual body of the 
TERMINAL.ORIVER is written in assembly lai^uage and is pan of the UCC modules DlIPUT 
and DIIGET. The user can also call the terminal driver routines directly, i.e. from an assembly 
language routine. TEXTJO and BASICJO are wiioen completely in Ada and need not be 
changed. 

BASICJO provides a mapping between TEXTJO coiurol characters and ASCII as follows: 
TEXTJO ASCII Character 


UNE.TERMINATOR 

ASQLCR 

PAGE^TERMINATOR 

ASaLFF 

FILE.TERMINATOR 

ASGLSUB (CTRL/Z) 

NEW LINE 

Asaiu 


The services provided by the terminal driver are: 

1) Reading a character from the conununications port, Get.Character. 

2) Writing a character to the communicadons port, Put.Character. 


F,8.1 Package TEXTJO 

The specification of package TEXTJO: 

pCMgam p«V«: 

Htth BASIC.XO; 

Mith 10 EXCZPTIOHS; 
paekaga'TCXT.IO la 

cyp« riU.TYPE la llailtaU private; 

type ritE_M00t la (ni_riIX. OOT_rHX); 

type COONT If ran^e 0 .. IMTESEP'LAST; 

aubtypa POSXTXVE_COa(rt la COOMT ranpa 1 .. COOMT'LAST; 

ONBOOMDCO: eonatant COOMT:* 0; •• line and papa laapth 

— sax. Sica of an Intapat output field _.P 

aubtypa rXELO la XMTC6ER ranpa 0 .. 35; 

aubtypa MOMBOI.BASC la XHTE6EK ranpa 2 .. IC; 

typa TYrC_sn la (LOim_CASt, OPPER.CASC); 

prapaM PAOC; 

— File ManapaaMnt 


procedure CMCATE 

(FILE 

: in out 

FXLE TTFE; 


MODE 

: in 

FXLE NODE 


MME 

: in 

STRXMe 


FORM 

1; 

: in 

STRZMQ 

preeadura OPEN 

(FXLE 

: in out 

FXLE TtPE; 


MQOE 

: in 

FXLE MODE; 


NAME 

: in 

STXXMG; 


224 






DACS-80x86 User's Guide 
Implemenution'Dependem Chancteristics 


rom ; in STUMG 

); 


preeadur* ClOSC iriu 
ptecadur* OEXXTE (FILE : 
pcoeadura RESET (rXIX 
MODE 

procadura RESET (FILE 

function MODE (FXXX 
function NMC (FXU 
function FORM (FXIX : 

function XS_OPEM(FXLE 

praqaa FASE; 

— control of default la 


In out FXU TTPE); 

In out FXU~TrPE); 

In out FXU*'TYPEi 
la FXU MOOC); 

In out FXU_rTPEI; 

la FXU TYPE) tatutn FXU MODE; 
In FXU'tYPE) catuiB STRXWS; 

In rxU~TYPE) ratutn STRIRG; 

in FXU TYPE ratuen ROOUJUI; 


and output fllaa 


procadura SET_IliFOT (FXU : In FXU TYPEi ; 
procadura SET~OaTPOT (FXU : In FXU~TYPE) ; 


function STANDARD XMPOT ratum FXU TYPE; 
function STAMOARD'oOTPn return FXU'typE; 


function CORRENT_IIIPOT ratum FXU^TYPE; 
function an(REMT~OOTPOT ratum EXU^TYPE; 


pragma PA3E; 

— spaclfleatlon of line and page langtha 


procadura 

procadura 

procedure 

procedure 

function 

function 


SET_LINE_UNGTH 
SET LXMB LENGTH 


(FXU : la FXU TYPE; 

TO : la CQONT); 

(TO : in COONT); 


SET_PASE_LEMaTH 
SET PAGE LENGTH 


(FXU : In FXU TYPE; 

TO : In COONT); 

(TO ! In COONT); 


LXME.LQIGTH 

LXNB.LEMGTH 


(FXU ! in FXU.TYPE) 
return coont; 
ratum count; 


function page.lengtb 
function PAGELQIGTB 


(FXU ; In FXU.TYPE) 
ratum count; 
return COUNT; 


pragma PA6E; 

-- Column, Lina, and Page Control 


procadura 

NEH LINE (FXU : In 

FXU TTPE; 



SPACING ; 

In POSITIVE COUNT :* 

1); 

procedure 

NEN_LXME (SPACING : 

In POSITIVE~COONT :• 

1); 

procedure 

SKIP LINE (FXU : In FXU TTPE; 



SPACING 

: in POSITIVE COUNT :• 1); 

precadura 

SXXP_LZNE (SPACING : 

; In POSITIVE~COONT 1); 

function 

END OF LINE (FXU : 

In FXU_TTPE) ratum 

BOOLEAN; 

function 

EMO~OF~LXNE 

~ ratum 

aOOLEAH; 

procadura 

NEN.PASE (FXU : 

In FXU.TTPE); 


procadura 

NEN_PAGE; 



procadura 

procedure 

SKIP PACE (FXU : 

SKXP^PAGE; 

la FXU.TYPB); 


function 

EMD.OF PAU (FXU ; 

lo FXU_rTPE) ratum 

E90LEAM; 

function 

EMDJCV^PAGE 

~ return 

BOOLEAN; 

function 

END OF FXU (FXU : 

In PXUJTYPE) return 

BOOLEAN; 

function 

ENO.OF^FXU 

“ ratum 

BOOLEAN; 


225 





DACS-80x 86 User's Guide 
Implememaiion-Dependent Chancteristics 


ptoeoduro 

SET_COI. 

(FILE 

in FILE TYPE; 





TO 

In POSITIVE COOMT) 

; 

proeoduco 

SET_COt 

(TO : In POSITIVE_COOHT); 


pcocoduso 

SET.LZME 

(FILE 

In FILE TYPE; 





TO ; In POSITIVE COOHT); 


proeoduro 

SET.LZME 

(TO : In POSITIVe'cOOIIT) ; 


function 

COL 

(FILE 

In FILE TYPE) 





r«cum 

POSITIVE~COOMT; 



function 

COL 

r«tum 

positive'coomt; 



function 

LIME 

(FXXX 

la FILE TYPE) 






POSlTZVE~COOMT; 



function 

LIME 

return 

POSITIVE^COORT; 



function 

PAGE 

(FZXX 

In FILE TYPE) 





return 

positive'coomt; 



function 

PAGE 

return 

POSITIVE~COO«; 



praqsw PAGE; 






" Chocoetoc Input-Output 




pcocoduso 

GET (FILE 

: In FILE TYPE; ITEM : 

out 

CSARACTER); 

pcocoduco 

GET < 


ITEM ; 

out 

CSARACTER); 

pcocoduso 

POT <riLE 

: In FILE TYPE; ITEM ; 

in 

CSARACTER); 

pcocoduso 

POT ( 


ITEM : 

In 

CSARACTER); 

— StclnG 

Input-Output 




pcocoduso 

GET (FILE 

; In FILE TYPE; ITEM ; 

out 

CHARACTER); 

pcocoduco 

GET ( 


ITEM : 

out 

CSARACTER); 

pcocoduso 

POT (FILE 

: In FILE TYPE; ITEM ; 

in 

CSARACTER) ; 

pcocoduco 

POT ( 


ITEM ; 

In 

CSARACTER); 

pcocoduco 

GET.LIME 

(FILE : 

in FILE TYPE; 





ITEM : 

out STaInG; 





LAST : 

out HATOAAL); 



pcocoduco 

GET_LHiE 

(ITEM : 

out sniMG; 





LAST : 

out MATOAAL); 



pcocoduco 

POT^LINE 

(FILE : 

in FILE TYPE; 





ITEM : 

In STRING); 



pcocoduco 

POT_LIHE 

(ITEM : 

In STRING). 




pr«9m» PAGE; 

" G«n«rle FaekAg* for Inpue-Output of Iiit« 9 «r Typos 


9 «n«rlc 

typo HDM Is coa 9 o o; 


poc]co9a INTEGER_IO 

Is 


DEFAOLT MIDT8 : 

FIELD 

:• NOM'WIDTB; 

OEFAOLT^BASE 

NOMBER.BASE :• 10; 

pcocoduco GET 

(FILE 

ITEM 

non 

In FILE TYPE; 
out homT 

In FIELD 0); 

pcocoduco GET 

(ITEM 

HIOTS 

out NON; 
in FIELD 0); 

pcocoduco POT 

<mz 

ITEM 

NIOTS 

BASE 

In FILE_TYPE; 

In NOmT 

In FIELD DEFAOLT NIDTB; 

In NOMBER.SASE :• D&AOLT_BASE) ; 

pcocoduco POT 

(ITEM 

NIOTS 

BASE 

la NON; “ ” 

la FIELD ;• KFAOLT NIDTB; 
in NOMBER.SASE DEFAOLI.BASE); 

pcocoduco GET 

(FROM 

ITEM 

in STRING; 
out HOM; 


226 








DACS’SOxSe User’s Guide 
Implemenuiion-Depentem Characteristics 


LAST : out rOSITIVC); 

prssoduro NT (TO : out STIU«6; 

XTtM : tn MOM; 

BASS ; In ROMUR.aME OerAOtT.SASE) ; 

«nd zmeasii lO; 


pragaut FME; 

— Qonorlc Packagoa for Input-Output of Poal Typoa 
gonorle 

typo RDM la dlglta o; 
paekago nOAT^IO la 

OSrAin.T Fom : risu> :> 2; 

OtrkOI.T ~hTT : FZXLB NDM'DXSrrS - 1; 

OEFAOLT**EXF : FXZLO :> 3; 


preeaduro OBT 

(FILE 

: In FILE TYPE; 


ITEM 

: out HOmT 


WXBTE 

: In FIELD 0); 

preeodttco SET 

(ITEM 

: out MOM: 


MXOTB 

: In FIELD 0); 

ptoeoduro FOT 

(FILE 

In FILE TYPE; 


ITEM 

In HDM:~ 


FORE 

In FIELD :> DEFAOLT FORE; 


AFT 

In FIELD ;> OEFAOLT~AFT; 


EXF 

In FIELD ;> DEFAOLT~EXF); 

proeoduro FOT 

(ITEM 

In MOM; 


FME 

In FIELD !• DEFAOLT FME; 


AFT 

In FIELD DEFAOLT'~Arr; 


EXF 

in FIELD :« DCFAOLT~EXF); 

ptoeoduro SET 

(FRCN 

In STRSMS; 


ITEM 

out HOH; 


LAST 

OUt POSITIVE); 

ptoeoduro FOT 

(TO 

out SmiMS; 


ITEM 

In ROM; 


AFT 

in FIELD DEFAOLTJIFT; 


EXF 

In FIELD DEFAOLT_EXP>; 

ond FlOAT_XO: 



pragBM FA6E: 



gonorle 



typo IRM la dolta o; 


paekago TTXtojlo 

la 


DEFAOLT FORE 

FIELD 

ROM'rOIE; 

DErAOLT"AFT 

FIELD 

:• ROM'AFT; 

defaolt'exf 

FIELD 

0; 

proeoduro SET 

(FILE 

: la FILE.TTFE; 


ITEM 

: out ROM? 


NZDTI 

: In FIELD 0); 

ptoeoduro SET 

(ITBt 

: out ROM; 


Mion 

: la FIELD 0); 

proeoduro FOT 

(FXLX 

: in FILE.TYFE; 


ITEM 

: la MOM; 


FORE 

: la FIELD :■ OEFAULT.FORE; 


APT 

: la FIELD :> DEFAOLT AFT; 


EXF 

: la FIELD OEFAOLTJEXFI; 

ptoeoduro FOT 

(ITEM 

: la ROM; 


FORE 

: la FIELD DEFAOLT FORE; 


AFT 

: la FIELD DEFAOLT AFT; 


227 











DACS-80X86 User’s Guide 
Inplemenuiion-Dependent Quracteristics 


va 

ptoeadux* SR (FIOl 
RIM 
USX 

preeadur* VOT (TO 

ITIM 

jurr 

DO 

•ad rzns.ZO; 


la rZBU :■ DirMX.T_D(»l; 

la StimiG; 
out MOM; 
out rOSXTZVE); 

out STKZMQ; 
la MOM; 

la rZCLO ;<• OCnkOlT AR; 
la risu OBrAOLT*DO); 


pcaSM tASK; 

— Ooaorle laejiasu for Zaput•Output of lauaMcatloa Typoa 
goaotlc 

typo DDM Is (o); 
pae)ca«o anMDUlTZOM_ZO la 

ORAOLT NZOn : FZBLO 0; 

OCrAOlT SRTZR6 : TTK SR :• mOl CASE; 


procoduro SET 

(rZLE : 

la rZlE_TTPE; 

ZTEM : out EROM); 

proeodura SET 

( 


ZTEM : out EROM); 

peoeodueo VOT 

(PZXX 

: Pll* TTPE; 



ZTEM 

: la EROM; 



wzon 

: la PZEIO 

:• OETAOLT WZOTS; 


SET 

; la TTPE SET 

•»ErAOtT_SETTZMS) ; 

proeodura POT 

(ZTEM 

; la EMOmT 



non 

: la rZEU 

;• DEFAULT MZDTB; 


SET 

: la TTfE_SET 

DEFAOLT_SETTZMO); 

proeadura SET 

(FROM : 

la STRZM6; 



ZTEM : 

out EHOM; 



lAST : 

out POSZTZVE) 

•• 

proeoduc* POT 

(TO 

out STRZRG; 



ZTEM 

la EROM; 



SET 

la TTPE SET 

:« OEFAULT^SETTZRS); 


•ad EHOMEMTZON^ZO; 
ptapaa PA6B; 


RATOS EMUK 

MQoe xSkm 

tlAME~El«0R 
OSE DOOR 
DEVZCE ERMOR 
END ERROR 
DATA ERROl 
LAYOOr.ERROR 

prassM poso; 
prlvoto 

typo nuJRVE la 
roeord 

rx : ZMTBSER •!; 
•ad roeord; 


■ 


•xeoptloa ro n aawa 
•xeoptloa toaaaws 
•xeoptloa toaoMs 
•xeoptloa roaaaMs 
•xeoptloa roaosMa 
•xeoptloa roaosMS 
•xeoptloa ronoaMS 
•xeoptloa roaaaos 


lO EECERZCHS.SZAZOS ERROR; 
ZO~EXCERZOHS.MOOE ERROR; 
ZO~ESCERZOHS. VAME~ERROR; 
ZO^EXCEmOMS-OSE DOOR; 
Zo'eXCERZOHS.OEVZCE ERROR; 
Zo'eXCEPTZONS.IMD ERROR; 
ZO~EXCERZOHS.DAZA ERROR; 
ZO~EXCERZORS.IATOOt ERROR; 


•Od rtxxjto; 


228 










DACS-SOxSd User’s Guide 
Iin|riemeiuation>Dependent Characteristics 


FA2 Package lO^XCEPTIONS 

The specification of the package lO.EXCEPTIONS: 


pacluig* lO.CXCartZOHS !• 


STATOS outm 
MODE EMOE 
IIAHE'*E]W0K 
OSE mOA 
DEVICE EMiaE 
EMO EHiOR 
OAU Emaa 
LAIOOt EMtm 


axeaptlon; 

axeaptlen; 

•xeaptlen; 

•xeaptten; 

•xeaptlon; 

•xeaptlon; 

•xeaptlon; 

•aeaptlen; 


•Ad ZO EXCSPTZOIIS; 


Package BASIC JO 
The specification of package BASICJO: 


with ZO_EXCEVTZONS.- 
packac* lASZC.ZO la 

typ* eeont la ranp* 0 .. lnt« 9 «r'laat; 

autotyp* poaltlv«_eettnt la count s*nqm 1 .. count'Inat; 


function ««t_lnt*««t rotucn atclnv; 

— Sklpa any laadlng blanka, lino t«a«laatoca or pay* 

•- toraUnatora. Than roada a plua or a ainua algn if 
•• pr«a«nt, than roada according to th« ayntax of an 

— intogor lltaral. uhlch awy b« baaod. Storoa in Item 

— a atrlng containing an optional aign and an Intogor 

— litoral. 

" Zh« oxcaptlon OAZA_CAROR la ralaod If th« aaquonc* 

" of charactara doaa~not corraapond to tha ayntax 
-- daacrlbad abova. 

— Tha axcaptlon EMO_EMOR la ralaad if tha flla tazalnator 
" la road. Thla aaana that tha atartlng aaquanca of an 

-- Intagar haa not boon owt. 

" Hota that tha charactar tanalnatlng tha oparatlon auat 

— ba avallabla for tha naxt gat oparatlon. 

function gat_raal ratum atrlng; 

— Corraaponda to gat^lntagar axcapt that It roada according 
•• to tha ayntax of a~raal lltaral, which aay ba baaad. 


function gat_anuaMratlon ratum atrlng; 

— Corraaponda to gat_latagar axcapt that It raada according 
to tha ayntax of an Idantlflar, whara uppar and lewar 
" caaa lattara ara agulvalant to a charactar lltaral 
-- Including tha apeatrophaa. 


229 









DACS-80x86 User’s Guide 
Iinplenieniaiioii*Dependent Oiaracieiistics 


fiinetlen (laayeh : In tnt«g«t) Mtucn attlav; 

-• IlMds • atrtnv froa eha currant liaa and atoraa it la 
itani. Zf thn maalnlaq aunbar at charaetara ea tha 

— currant liaa la laaa than lanyth than only thaaa 
charaetara ara ratumad. Tha llna taaalnator la net 

— aklppad. 

prccadura put_ltaai (Itan : in atrlag): 

— If tha longth of tha atrlag la grantor than tha currant 

— narliw llna (Uaalaagthi, tha aaeaptlon lATOOT tmoR 

— la ralaad. 

— Zf tha atrlng doaa not fit an tha currant llna a llna 
taainator la output, than tha itan la output. 

Llna and paga langtha • um 14.3.3. 

procadura aat_llna_langth (to : la countt; 

precadura aat_paga_laagth <to ; la countt: 

function llna_langth return count: 
function paga_langth ratum count: 

— Oparatlona on calunaa, llnoa and pagaa * JUm 14.3.4. 

precadura naw^llna: 

precadura aklp_llna: 

function aad_of.llao ratum booloaa: 

precadura nawjpaga: 

precadura aklp,.paga; 

function and_of^aga ratum beelaan: 

functlen and_af_fllo ratum beelaan: 

precadura aat_eel (to : In paaltlva_eeunt): 

precadura ■at_llna (to : in pjsltlva_couat): 

function cel ratum pealtlva^ceunt: 

function llna ratum pa8ltlva_eeunt; 

function paga ratum pa8ltloa_eount: 

— Charactar and atrlag procaduraa. 

— Carraapanda to the procaduraa daflnad in AM 14.3.4. 


procadura gat_eharaetar (Itan 

out ebacaet< 

precadura gat^atriag (Itaai : 

out atrlag); 

procadura gat llna (itan : 

out atrlag: 

laat : 

out natural); 

procadura put_eharactar (Itan 

: la cluraetar): 

precadum put_8trlng (Itan : 

In atrlag): 


230 








DACS-80x86 User’s Guide 
Implementatton-Dependem Chiracteiistics 


proeadttt* put_lln« (itM ; in atring) ; 

•- Mcaptlona: 

oss^smOR : axeapeion cananwa IO_KXCSPTZaiiS.Ose_CRROR; 

DBVXex.CRROR : axcapClon ranaawa lo'nCBPnaMS. OCVTCt ERROR; 

EIID_ERROR : axcapClon canaaaa IO~EXCCPTXaMS.EMO ERROR; 

OAXA ERROR : axcaptloa ranaana XO^tXOnXCms.OAlS ERROR; 

UYOOt_ERROR : axcaptloa canaXMa XO^EXCXPTXOMS. LRTOn^ERROR; 

and BASZC_ZO; 

F^.4 Package TERMINAL.DRIVER 

The qjecification of package TERMINAL.DRTVER: 

paekaga TSRMZIIA1._0RZVER la 

proeodura put_charaetar (eh : in eharaetar); 
preeadura gat_eharaetar (eh : out ehacaetart; 
ptlvata 

pragma Intarfaeo (ASM8C, pue_eharaeear); 

pragma intarfaea^ipaXllag(put_eharaetar,’DlZPOTTputjeharaetar*); 
pragma latarfaea (ASmc, gac_ehacaetar); 

pragma lntacfaea_apalling(gat_eharaetar,*01zeBT?gatjeharaetar*); 
and ZKRKZMRL^DRZVBR; 

Packages SEQUENTULJO and DIRECT-IO 

The ^ciflcations of SEQUENTIAL.IO and OIRECTJO are specified in the ARM: 

Since files are not supported the subprograms in these units reaise USE ERROR 
STATUS_ERROR. 







DACS-80X86 User’s Guide 
Implcniemrtop-Dependent Chancieristics 


¥JL6 PMkafe L0W_LEVEL-10 

TIk spedficttion of LOW.LEVELJO (16 biu) is: 


Kith syscMi,- 

p«eka«« UN_tXVll,_lo is 

subtyp* part_«edsMs Is Systw.OnslgnsdHerd; 


cyp* ll_la_S 
typ* Il^le^l* 


Is n«M lat««*c ESfip* -12t..l27; 
Is IMK lne* 9 «c; 


psoeadur* saad^eanctel(davlea : 

^ data 

~ uaslgnad • bit aatlty 

procadura saad^eontsol(davtea : 

data 

— ttaalpnad 1< bit antlty 

procadura aand_,eentrel (davica ; 

data 

* — slgnad • bit antlty 

procadura sand^controKdavlca : 

data 

— slpaad 1< bit antlty 

procadura racalva_eentrol(daviea 
~ data 

•• unalpnad • bit antlty 


procadura racalva_eantrel(davlca 
" data 

— unalfnad 1< bit antlty 

procadura racalva_control(daviea 

data 

slpnad • bit antlty 

procadura racalva_centrol(daviea 
~ data 

— slpnad 1C bit antlty 


la pert_addraaa: 
In SyatM.byta); 


in port_addtaas; 

In syatM.OnalpnadMord); 


In pert addrasa; 
in 11 10 •): 


In pert address; 
in 11 lo IS); 


In pert_addreaa; 
eut Systaai.Byta); 


in pert_addraas; 

out Sys?a«.OnalgnadMerd) ; 


In pace_addrass; 
cut llJIe_S>; 


in port^addrass; 
out ll_lo_lC»; 


private 

prapiw lnllna(sand_eentrel, raealva_eentrol); 
and LON LEVtL 10; 


The spaeiricatlen of LOH_LCVSL_ZO (32 bits) Is: 

with STSTIM; 

paeliada LOW_LCVEL_IO is 

subtype pert^addraas la Systaa.OnslpaadHord; 

type ll_le_t Is new shert_lnta 9 ar ranpa -I2t..l27; 

type ll3le~lS la new short~lntagac; 

type 112 io~32 Is new intapar; 

preeadura aaad_eeatrel(daviea : la port_addraas; 

~ data : In SysCM.byta); 

— unalpnad • bit antlty 

procadura aand_eentrel(daviea : In pert_addraaa; 

^ data : la SystM.analgaadHerd); 


232 




DACS>80x86 User's Guide 
Impie meru iiion-Depenclent Chancteristics 


— 1C bit mtlty 

preeaduc* ••ad^epaerol(davte* : In 
dncn : in 

— ttttalgnnd 32 bit nntlty 

preenducn snnd_eontrol(dnvlcn : in 
~ data ; In 

— algnad t bit ancity 

pteeadusa aaad_eanttal(davlea : In 
~ data : In 

— algnad IS bit antlty 

praeadura aaad_eaatzaX(davlea : la 
~ data : la 

— algnad 32 bit antlty 

praeadura raealva^eantral(davlea : 

** data 

— unalgnad ■ bit antlty 

praeadura raealva_eentrel(davlea : 

~ data 

— unalgnad IS bit antlty 

praeadura raealva_eentral(davlea : 

~ data 

unalgnad 32 bit antlty 

praeadura raealva_eantrel(davlea : 

~ data 

" algnad • bit antlty 

praeadura raealva^eentrel(davlea ; 

~ data 

— algnad IS bit antlty 

praeadura raealva_eentral(davlea : 

~ data 

— algnad 32 bit antlty 


part_addmaa; 
SyatM.OnalgnadDMacd) ; 


part addraaa; 
11 le_il; 


part addraaa; 
11 la IS); 


part addraaa; 
11 la 32); 


In part_addraaa: 
aut Syataat.byta) ; 


In part_addraaa: 

aut Syataai.OnalgnadMard) ; 


la part_addraaa; 

aut Syataai.OnalgnadONard) ; 


In part_addraaa; 
aut 11 Ta S) ; 


In part^addraaa; 
nut llJta_lS); 


la part addraaa; 
aut ll_Ia_32); 


prlvata 

pragaw lallaa(aand_eantral, raealva_eentral); 
and LCm LSVei lO; 


F.9 Machine Code Insertions 

The reader should be familiar with the code generation strategy and the 80x86 instruction set to 
fully benefit from this section. 

As described in chapter 13.8 of the ARM (DoD 83] it is possible to write procedures containing 
only code statements using the predefined package MACHINE.CODE The package 
MACHINE_CODE defines the type MACHINE_WS^UCnON which, used as a record aggregate, 
defines a machiiK code insertion. The following sections list the type MACHINE_INSTRUC7nON 
and types on which it depends, give the restrictions, and show an example of how to use the 
package MACHINE.CODE 


233 



DACS-80x86 User’s Guide 
Implemenution-Dqpendem Qiaiacterisdcs 


F.9 J Predefined Types for Machine Code Insertions 

The following types are defined for use when making machine code insertions (their type 
declaiaiions are given on the following pages): 

type opcode.type 
tyjx operand.:^ 
type register.tj^ 
type segment.register 
t]^ machine_instnicti(»i 

The type RECISTER_TYPE defines regisrers. The registers STi describe registers on the floating 
stack. (ST is the top of the floating stack). 

The ty^ MACHINE.INSTRUCTION is a discriminant record type with which every kind of 
instruction can be described. Symbolic names may be used in the form 

name‘ADDRESS 


Restrictions as to symbolic names can be found in section F.9.2. 

It should be mentioned that addresses are ^cified as 80386/80486 addresses. In case of other 
targets, the scale factor should be set to "scale.r. 


typ« opeed«_typ« is < 

— SdaC lastruetlens; 


a AAA, 

a_AAO, 

a_AAM. 

aJlAS, 

ajkoc, a_AOD, ■_AMD, 

a_CALL, 


caLlm, 







‘a CBM, 

a CIC, 

a CIO, 

a CLX, 

a CMC, a CMP, a CMPS, 

a CMD, 

l(PA 

a~DAS, 

a DEC, 

a“"oiv. 

a^BlS, 

a~lDXV, a”lMOl, a“xil, 

a'XMC, 

aBC 

a“xiltO, 

a IBET, 

a~JA, 

a.JAE. 

a OB, a iJBE* a OC, 

m’xxz. 

ajSl 

a”jCi, 

a_JCE, 

a~A. 

a AE. 

a JHA. a JBAE, a JMB, 

a JMBE, 

ape 

a JME. 

a jm, 

a Mat. 

a JKL. 

a^OMlE. a~OMO, a~jm. 

a OMS, 

■.A 

a M, 

a JP. 

rnjm. 

a"jfO. 

a A. a A, a JIV, 

a.LABF, 

aim 

a IBS. 

a LEA, 

a_LOCX, 

a_iaos. 

a^LOOP. a^LOOPE, 



.idwME, 

a LOOPMZ, 






a lOOFX, 

, " a MOV, 

a Novs, 

a MOL. 

a_ME6, a MW, a NOT, 

a M, 

•tp*- 

■“top. 

a~POPF. 

a~POSB. 

a POSBF, 

a RCL, a~RCB, ~ 

a NOl, m'not. 


a~REP, 

a~REPE, 

a~AEPME, 

a"l«ET, 

a~RETP, a"RETM, 

a~l(ETMP, " 


a~SAl, 

a~SAR, 

a~siL, 

a'SHR, 

a~SB8, a~SCAS, a STC, 

a STO, 


a~STOS, 

a“sOB. 

a~TEST, 

a'NAXS. 

a~SCBS, a~SLAT, a~XOR, 




tOSI/SOlST/eoat? riMClng Pelnc PcecMsot inscrnetleos: 


SI FMS, 

■~nicixx. 

sTroiv, 

si~rxMO, 

•'riozvD, 

sTriNOLO, 

■~rXSTtL. 

■TrLDCN, 

■Trios. 

■'rSORT. 

■ rSTSN, 

■Trsomr, 

■Tmaapi, 


■ rwo. 

■~rcoii, 

■“roivD. 

a rXMOO, 

a”rxoiVR. 

m~nncm, 

a^nsOB, 

a nOEMV, 

a^noi, 

a~rviAM. 

a rST, 

a~rSTSHUC, 

a'rrsT, 

a~r2»a. 


a raooD. 

a'rooM). 

a~n»xv», 

a'rxcoM, 

a'rxoxvn, 

a~nixiixT, 

a~rxsa80, 

a'riDiea, 

a nm. 

a mexitT. 

a rsss, 

a rsoB, 

a'maxT, 


a FADOr. a FBLO, a FBSTP, a FCBS, 
a'rcow. a~FCaiWO. alrcONPF, a'rOBCSTF, 
a'rOXVB. a~rDXVIID, a FDIVRF, a~rniSS, 
a"FXCa®,~ a^FXWW. a_FIC 3 WD’. a_FXOXV, 

a^rxio. a rXLDD.a FXtOl, a FXMDl, 
a“FX«, rnZrzm.rnjnm, a^rxsiFo, 
m’rzsmt. a^FXSOlSOr a_FtO, m~noo. 

a'noiia, a nous. a riOUT, a FIDFI, 

wTnmo.mjnm. m_n6e, a FFazu.' 
a FMTQK. a rMAVt,m Fsaux. a FSBIfM, 
a"F»tC».a_FSH«V, a_rSTF. a“FST» 0 . 
a'rsoBo. a.Fso ar, a_F 30 B », a_rsom, 
a raui. a_rxca, a_Fxxiucx, a^max. 


— SOlSC/SOaSC/MSSS mstsuetlons: 

— Noeiea that sesn laaadlata varslons oC tha SOSC 
~ instnietlens only axlst on thoao tacgocs 

— (shlfts.rotatas.pvsh.lsMl....) 

a MaMD, a CITS, a M T SK , a XMS. a IM, a^LEAVE, a MOT, 

a~LSOT, a“LSl, aJXJTS, a'FOVA. a_POSHA, a_SGOT, a_SXDt, 


234 




DACS-80x86 User's Guide 
Implenienution-Depefidem Chanaeristics 


mjam. mJUMT, mJJtMtl, mj.n, 

— 1C bit alMay*..■ 

«_SUT, ■_SNSH, ■_STIl, ■jrciw, rnjmm, 

—■ tb* coses tpaelfle Inattuetlena: 


n seza, 

a_SCTAS, 

a StZ8. 

a^SSTB£. 

a SRC. 

a SETS. 

■'SRQ, 

a SROK. 

B"stTl. 

a.SZTLE. 

a~SRlU. 

a^SRMAE. 

■~snaB, 

a SSXMU. 

a'sKTHC. 

a_SET«. 

a'sRMC. 


■"SRHOE. 

a'sem. 

a'sBZMU. 

a 3SZM0. 

a~SRm. 

a SRHS. 

a'’sSTIK, 

a sen. 

a'scCT. 

a SBCTE. 

a~SRVO. 

a~SRS. 

rr~Stn. 

a~BSF. 

a~BSIl. 

•Ik. 

“ a RC, 

a BT», 

rrata. 

a"urs. 

a~I.3S. 

a_US. 

a Movn, 

a MOVSX, 

a seven. 

a^HOVSB, 

a^MOvn, 

a SUO, 

a~saw. 



— tha C03C7 apacifie iaatrnetlona: 


a rocoM. 

a racONP. 

a.rocoMPP. 

a_rPBEia. a_rsXM. 1 

a'rszvcos. 





~ byta/w 

ord/dword variants (to ba 

usad. whan 


— not dadaetlbla frea eontaxt): 



a ABCB. 

a AOew. 

a ABCS. 

a AOOB. 

a ADOM. a AODO. 

a~MBa. 

a~MBN. 

a~AIIDD. 

a_BT1l. 

a“BTO. a'BTCM. 

a~BTCO. 

a~aTIM. 

a~STPD. 

a BTSW. 

a~BTSD. a~CBMM. 

a'CMDE. 

a'CNDN. 

a^coQ. 

a'CMPB. 

a~CMPN. a~CMPD. 

a'cSSSB. 

a~CMPSW, 

a CMPSO. 

a OECB. 

a~OECW. a~OECB. 

a“0IVB. 

a-orvM, 

a“oiVD. 

a ZSIVB. a xsivw. a lolVD. 

a~IMaU. 

a~IMOLW. 

a~IMDU. 

a niCB. 

a ncM. a IBCD. 

a*SMSC. 

a'lNSN. 

a'lMSO. 

a_lC=SB. a UOSM, a LODSD. 

a~M0VB. 

a^MOVN. 

a~MOVD. 

a~MCVSB. a'‘MOVSN, a~HOVSD. 

a~HOVS». 

a'MOVSXH, 

a^MOVEXS, 

a~H0V2XN. ~ a MDU. ~ a MDLN, 

a^MOU. 

a'lieca. 

a~ME<ai, 

a NEO). 

a MOTB. a MOTN. 

a'lWTO. 

a OM. 

iTomi, 

mjMio. 

a~oor5B,a OOTSN, 

a OOTSO. 

a”fOPM, 

a^poro. 

a_POsaw, a POSBO, a KCU. 

a'ltCLW. 

a'ltCtB. 

a''Acm. 

a.RCMI. 

a KCBO, a nou. 

a'pOUl, 

a COLO. 

a~l«om. 

a ROIW. 

a nmo. a SAU. 

m~SKiM, 

a SAID. 

a'SAM. 

a^SABM. 

a_SAKD. a_sau. 

a SUN. 

a snow, 

a'SBM. 

a_saiiN. 

a SBBON. a_SBBB. 

a'sBBN. 

a SBCO. 

a^SCASB. 

a.SCASN. a SCASO. a snsB. 

a snsH. 

a^snso. 

a^SOBB, 

a.SOBH. 

a SOBO. a TESTB, 

a“lESTW. 

a.TESTD, 

a'xOBB. 

a_xoiai. 

a_XOW, a_OAZAB, 

a.OATAH. 

a^OAXAD. 




— Spaelal 

'inatruetlons': 

a.labal. 

a_rosot. 


— S0C7 taap raal load/scara_an4_pap: ■_rU3T. ■jrSTVT); 


pragaM papa; 

typa oparand_typa la ( nona, — no oparanda 


laMdlata, 

caglatar, 

addraaa. 
ayaeaai_addxaaa , 
aaaM,~ 

raglatar_ ta wadl i ta, 


raglatar_ra 9 iatar, 
raglatar.addraaa, 


addraaa_raglatar. 


~ ona laaadlata eparand 
ona raglatar oparand 

— ona addraaa oparand 

— ona 'addraaa oparand 

— CbU. naaa 

two oparanda : 

— daatlnatlon la 

— raglatar 

— aoorea la laawdiata 

— two raglatar oparanda 
~ two oparanda : 

— daatlnatlon la 
—* raglatar 

~ aourea la addraaa 

— two oparanda : 


23S 





DACS-80X86 User’s Guide 
Impkmemation-Dependent Characteristics 


r«glst*t_syst«i_addrMa, 

aystM_addrMS_t*«t«t«t, 

addraaa_faiail 1 af, 

ayataa_aUdr*aa_tMBadtac«, 

l i» a f<l ata_wglat>r. 

laaMdl«ta_laaMdl«ta, 

ragiaf r_ra9iatT_1 aaartlaf, 

r«9latar_addlr«aa_laMdlae*. 
raqlata ^ayataa^^Udraaa^lnaaadlata, 
«ddxaaa_Mglata^laMdlat«, 

ayataai_addzMa_c«4iac«r_laaMdlac* 

) ; 


— daatlMClon la 

— iiddraaa 

— aouco* la raqlatar 

— two oparanda : 

— daatlaatlon la 

— cagiatat 

— aoucea la 'addtaaa 

— two oparanda : 

— daatlaatlon la 

— ‘addraaa 

— aotttea la raglatar 

— two oparanda : 

— daatlnatlen la 

— addraaa 

— aourea la luillata 

— two oparanda : 

— daatlnation la 
-* ‘addraaa 

— aourea la laaMdlata 

— only allowad for OOT 

— port la laMdlata 

— aourea la raglator 

— only allowad for 

— mm 

— allowad for IMDX>la«, 

— SlPOlaai. SlUlaM 

— allowad for DaLlaai 
'• allowod for xmLlaai 

— allowad for SINDlaM, 

— SILOImi 

" allowad for SlPDlaa, 

— SILOlna 


typo raglator typa la (JUC. CX, OX, BX. St, Mt, SI, oi, -- word raga 
AL, a, OL, lb, M, CB, oa, aa, byta raga 
iAX,xcx,isx,xax,ESV,xa*,esx.eoi.— dword raga 
U, es, as, OS, FS, os. — aalaetora 

ax_sx, ax oi, aa^sz, av_oi, — aots/toias/aosts eoaoinationa 
ST7 STl. ST2, ST3, — floating roglatara (ataek) 

ST4, STS, ST«, ST7, 

nil) ; 

•• tha axtandad roglatara (CM .. CDI) plus rs and SS ara only 
allowad In SOSiC targats 

typa seala_typa la (seala^l, seala_2, aeala_4, seala_ai; 
aubtypa aMehlna_stslag la strlngd. .100); 
pragaw paga. 

typa a«ehlaa_lnstruetlon (oporand_)clnd : eparaad_typa) la 
raeerd “ ~ 

opeoda : opeeda_typa; 

easa aparaad_)Und la 
whan laaMdlata •> 

laaadiatal : latagar; — iMtadlata 

whan raglstar » 

r^ragtatar : raglstar_typa; — aourea and/or dastlnatlee 
whan addraaa » 

a_sagaMnt : roglator^typa; — aourea and/or dostinatlon 
a_addirasa_baso ; roglator_typa; 

a~addrass~ladax ; toglatar_typa; 

a^addrasa^aeala : aealo_typa; 

a'addraas~offaat : latagar; 

whan aystaai_addrass ■> 

aa_addrass : systaa.addraaa; — daatlaatlon 


236 





1 


OACS*80x86 User's Guide 
linpleinenuttion*DepeQdeiu Charectenstics 


ohM amm «> 

n_,«trtii 9 ; Mehtn«_serln«; — CAU dattlMClon 


whwi rf Isf r_1 ■■■iliAf •> 

: r« 9 l*c«r typ«; 


whan r««tstar_ra«l*t«r •> 
r_t_c* 9 l*tIr_to 


t«gl*t*t_typa; 

t« 9 lat«c~typ«; 


Hhaa ra«lst*c_adSx«as 
t_a_ea 9 tatIt_to 
r^a_a«9Miic “ 
r_a_addr*aa_b«a« 
r^a^addraaa^lndax 
r_a_addr«aa_ac*l« 
r_a_aUdr*aa~effaae 


: ca«tatat_typa; 
: ragiatar'cypa; 
: ra«iatar~typa.- 
: cagtatac^typa; 
: aeada^ty^; 

: incagar; 


whan a«ldraaa_ra 9 tatar 
a_r_aa9aMnt 
a_r_addraaa_baaa 
a_r_ad(traaa2lndax 
a_r_a«lelraaa2aeala 
a^r_a4draaa2offaat 
a_r_raglatar_£toai 


: ra 9 tatat_eypa; 
: ra«iatac~cypa; 
: ra 9 taear~eypa; 
: aeala_ty^; 

: inta^ar; 

: ca91atac_eypa; 


Hhan ra9laear_ayacaai_a<idraaa » 

r«**_'«eiatar_to ~ : raqiatar typa; 

<>**_*Udraaa : ayataa.addraaa; 


whan ayacaai_addraaa_ra 9 latar »> 

aa_r_ad£aaa ~ ; ayataa.addraaa: 
••_r_f«9„rroai : ra9iatat_typa; 


whan ad4faaa_iaBMdlata «> 
a^l^aa^aant 
a_l_aderaaaj»aaa 
a_l_aedtaaa~ln(lax 
a_l_ad4raaa3aeala 
a_l_aeeraaa effaat 
a^i.laMMdiata 


taqtatat^typa; 

ragiatac'*typa; 

raqtatas'typa; 

•e*l«_typa; 

Ineavaa; 

intayar; 


Whan ayacaai_addraaa_laBMKtlata ••> 

aa.l.adUraaa : ayataa.addraaa; 

aa^i^ ri— adlata : incagar; 


whan l ia aadlaea^raglatar •> 

l_r_laaaadiata : intagar; 

: ta 9 iatar_typa; 

whan laaMdlata_lii»arl 1 ata -> 

l_l_iaHM 41 acal : lotagar; 
l_l_liMM 41 ata 2 : intagac; 

whan taglatat_raglatar^ 1 iarBadlata » 

Atari : raqlatar typa; 
t.t-t^tAglAtara : raglatar^'typa; 
g_g^i_ tia aadlata : Intagar; ~ 

whan raglatar_addraaa_titBadiata » 

g_A_t_g« 9 latar “ : ca 9 lBtar_typa; 

g-*_ 0 * 9 »*«t : caglatM.typa; 

g_*_t_*edraaaj»aaa : raglatw typa: 
g_»_i_«edraaa_indax : caglatar^typa; 
i_a_l_addraaa_acala : ae«la_cy^; 
t.A.l.Mdraaa^oCfaat: Intagar; 
g_a_l _t» adlata : incagar: 

whan ra 9 latar_Byacaai_addraaa iMadlata » 

*'-.A*_l'_t««t»tar T ragiatar.typa; 
•^MrlO ; ayatam.addraaa: 

a aiadiata : incagar; 


daaelnacion 

anurea 


daaclnacion 
*** aourca 


>'■ daaclnaclon 
“■* aourca 


— daaclnaclon 


•“ aourca 


— daaclnacton 
aourca 


-* daaclnaclon 
aourca 


daaclnaclon 


— aourca 


O'- daaclnaclon 
~ aourca 


— daaclnaclon 

— aourca 


— laaaadlatal 
-- l i a aadlata2 


~ daaclnaclon 

— aourcal 

— aourcaS 


— daaclnaclon 
aourcal 


~ aoureaS 


daaclnaclon 
~ aourcal 
aourca2 


237 




OACS*80x86 User’s Guide 
Impleinemaiion*Dependem Ouractenstics 


whaa addcaas^caflatar^laMdlat* •> 

nt ~ : r*«t«t«r_typ«; — daatlMClon 

a_^l_addr«aa_baaa ; raglata^typa; 
a~c~l3addcaaa~iadax ; caftatar^typa; 
a~c~l~addraaa~seala : aeala ^ty^; 
a^r^lZaUdraas^offsac: intagar: 

a~t2iZ**e^*®** = ragiatat_typa; -- souteal 

ajt33—= inta^ar: ~ -- aoucea2 

ahan systaai_addraaa_ra9latar_laaia41aea •> 

aa_^t^addxMa T syataa.addraaa; 

a^^i^ragtatar : ra 9 latar_typa: 
aajr_ 0—S lata ; latagar: ~ 

Mbaa ethara •> 
aull; 

aad eaaa; 

aad raeard; 

aad Bwehtaa coda: 


F.9J Restrictions 

Only procedures, and not functions, may contain machine code insertions. 

Symbolic names in the form x'AODRESS can only be used in the foUowing cases: 

1) X is an objea of scalar type or access type declared as an objea, a formal parameter, or 
by static renaming. 

2) X is an array with static constraints declared as an object (not as a formal parameter or by 
renaming). 

3) X is a record declared as an objea (not a formal parameter or by renaming). 


The m.CALL can be used with "name" to call (for) a routine. 

Two opcodes to handle labels have been defitred: 

mjabel: defines a label. The label number must be in the range 1 <s x <* 999 and is put 

in the offset Held in the first operand of the MACTHINE.INSTRUCnON. 

m.tesec used to enable use of more than 999 labels. The label number after a m_R£SET 
must be in the range lo x <s 999. To avoid errors you must make sure that all 
used labels have been defined before a reset, since the reset operation clears all used 
labels. 

All floating instructions have at most one operand which can be any of the following: 

• a memory address 

• a register or an immediate value 

• an entry in the floating stack 


" daatlnatlon 

— aoureal 

— aourea2 


238 





OACS-80X86 User's Guide 
Imfdememation-Dependem Chaiacteiistics 


FJJ Examples 

The following section contains examples of how to use the machine code insertions and lists the 
generated code. 


F.9.4 Example Using Labels 

The following assembler code can be described by machine code insertions as shown: 

NOV AX.t 
NOV CX.4 
CNF JUC.aC 
J8 1 
JS 2 
NOV CX.AX 
1: ADD AX.CX 
2; NOV SS: [BP-^OX], AX 

p«ek« 9 « •xaaipl«_MC la 

preeaduxa t«at_lab«la; 
pragau lalln* Ttaat^laitoala) ; 

and axaB 9 la_MC; 

with MACHINS_COOe: uaa MACBIllZ_CaDE; 
paekaya body~axa«pla_MC la ~ 


proeaduxa taBC_latoala 
ba9in 

MACaXNt XnSTKCCTIOM' 
HAcame' rasTKOcTiOH* 
MACXXHX'ztlSTaOCriOH' 
HACBZMC ZXSTmCTIOM' 
MACaiNE~IHSTKOCTION' 
MACBINe'lMSTROCXIOH' 
NACBINE IllSTIKJCnOH' 
MACBItlE IMSTBOCTIOH' 
MACaXNE~INS7R0CTZ0N' 
MACBIliE~ IHSTB0C7Z0N' 


la 


(xaglatag^ la ia dU ata, 
(gaglatag^l—adi ata, 
(ga9iatag3ra9lstag, 
(liaillata. 
(iBMdlata, 

(ga«laeag_ga9iatag, 
(Imaiaillaca, 
(gaqlacag^ga^latag, 
(la i adlata, ai_labal, 
(addgaaa_ga9lacag. 


■ NOV, 

AX. 

■»; 

■“hov. 

cx. 

4); 

•"CMP, 

AX. 

CX); 


I); 


ai JE. 

2); 


m NOV, 

cx. 

AX); 

■ labal, 1) ; 

ai ADO, 

AX, 

CX); 

27; 



a NOV, 

SS. 

BP. 

DX. aeala_l. 0, AX); 


and taat_labala; 
and axaH9la_HC; 


F.93 Advanced Topics 

This section describes some of the mote intricate details of the workings of the madiine 
code insertitm facility. Special attention is paid to the way the Ada objects ate referenced in 
the machine code body, and various alternatives ate shown. 


239 







DACS-80x86 User's Guide 
Implemenution-Dependem Characteristics 


F^J.l Address Spcdncatkms 

Package MACHINE.CODE provides two alternative ways of specifying an address for an 
instruction. The first way is refened to as SYSTEM.ADDRESS and the parameter associated 
this one must be specified via OBJECT'ADDRESS in the actual MACHINE.CODE insertion. The 
second way closely relates to the addressing which the 80x86 machines employ: an address has 
the general form 

segment:[base-t-index*scale-K)ffset] 

The ADDRESS type expects the machine insertion to contain values for ALL these fields. The 
default value NIL for segment, base, and index may be selected (however, if base is NIL. so 
should irxlex be). Scale MUST always be specified as scale.l. scale.2. scale_4. or scale_8. For 
16 bit targets, scale 1 is the only legal scale choice. The offset value must be in the range of 
-32768 .. 32767. 


F.9JJI Referencing Procedure Parameters 

The parameters of the procedure that consists of machine code insertions may be 
referenced by the machine insertions using the SYSTEM.ADDRESS or ADDRESS fonnats 
explained above. However, there is a great difference in the way in which they may be specified: 
whether the procedure is specified as INLINE or not 

INLINE machine insertions can deal with the (»rameters (and other visible variables) using the 
SYSTEM.ADDRESS form. This will be dealt with correctly even if the actual values ate 
constants.'Using the ADDRESS form in this context will be the user's responsibility since the 
user obviously anempu to address using register values obtained via other machine insertions. It 
is in general not possiUe to load the address of a parameter because an ‘address’ is a two 
componem structure (selector and offset), and the only instruction to load an immediate address 
is the LEA, which will only give the offset. If coding requites access to addresses like this, one 
cannot INLINE expand the machine insertions. Care should be taken with references to objects 
outside the cutrem block since the code generator in order to calculate the proper frame value 
(using the dis{day in each frame) will apply extra registers. The parameter addresses will, 
however, be calculated at the entry to the INLINE expanded routine to minimize this problem. 
INLINE expanded routines should NOT employ any RET instructions. 

Pure procedure machine insertions need to know the layout of the parameters presented to, in this 
case, the called procedure. In particular, careful know^ge about the way parameters are passed 
is required to achieve a succesfiil machine procedure. When not INLINE a block is created around 
the call which allows addressing of patameiets, and code for exitii^ the procedure is also 
automatic. 

The user takes over the responsibility for conea parameter addressing. The rules of Ada 
procedure calls must be followed. The calling conventions are summarized below. 


240 



DACS-80x86 User's Guide 
Imptanemadoa-Oepenteiu Charaoerisdcs 


Paraineter Transfer 

It may be a problem to figure out the conea mimber of words which the parameters take up on 
the stack (the x value). The following is a short description of the transfer method: 

INTEGER types take up at least 1 storage umt 32 bit itveger types take up 2 words, and 64 bit 
integer types take up 4 words. In 32 bit tari^ts, 16 bit integer types take up 2 words the low 
word being the value and the high word being an alignmem word. TASKs are transferred as 
INTEGER. 

ENUMERATION types take up as 16 bit INTEGER types (see above). 

FLOAT types take up 2 words for 32 bit floats and 4 words for 64 bit floats. 

ACCESS types are considered scalar values and consist of a 16 bit segmem value and a 16 or 
32 bit offset value. When 32 bit offset value, the segment value takes up 2 words the high word 
being the aligment word. The offset wotd(s) are the lowest, and the segmem wotd(s) are the 
highest 

RECORD types are always transferred by address. A record is never a tcalar value (so no 
post-procedure action is carried out when the record parameter is OUT or IN OUT). The 
representation is as for ACCESS types. 

ARRAY values are transferred as one or two ACCESS values. If the array is constrained, only 
the array dau address is transferred in the same marurer as an ACCESS value. If the array is 
unconstrained below, the data address will be pushed by the address of the constraint. In this 
case, the two ACCESS values will NOT have any alignmem words in 32 bit targets. 

Packed ARRAY values (e.g. STRING types) are transferred as ARRAY values with the addition 
of an INTEGER bit offset as the highest word(s): 

+H: BIT.OFFSET 
+L: DATA_ADDRESS 

•fO: CONSTRAINT.ADDRESS - may be missing 

The values L and H depend on the presence/absence of the constiaim address and the sizes of 
constraint and dau addresses. 

In the two latter cases, the form parameter’address will always yield the address of the data. If 
access is required to constiaim or bit offset, the instnictions must use the ADDRESS form. 


F.9J.4 Example 

A small example is shown below (16 bit target): 
procedure unsigned.add 


(Opl 

: in 

integer. 

op2 

: in 

integer. 

res 

: out 

integer); 


241 









DACS*80x86 User's Guide 
Impiemenudon-Dependeitt Qtancieiistics 


Notice that machine subpiognnis cannot be hinctions. 
The parameters take up: 


opi 

: integer 

I word 

op2 

: integer 

1 word 

res 

: integer 

1 word 


Total 3 words 


The body of the procedure mi^ then be the following assuming that the procedure is 
defined at outermost package level: 


pree«dar« uaat7iMdi_«dd 

(e^ : In lnt«««c: 

ap2 In Incnpnc: 

na oat Intoyotl la 

bavin 

ptagaM abatraet_aeoda_lnaartlana(tcua>; 
aa_lnatr'(aa_Ctoaca_aioek. 3.1,0,a.0); ~ x • 3, y - 1 

aa~lnatr' <aa3tnd_ot~daelpart, 0 , 0 , 0 , 0 , 01 : 
pra^u abatraec_aea^_laaattlona (falaa) ; 


■aehlna_lnatcuetlaa' (ra 9 latar^ayaeaB_addraaa. 

~ JUcT opl'addraaal; 

■aehlna Inattuetlon'(ragiatar^ayataa.aUdraaa. 

~ AX, opS'addraaa); 

■aeblna^lnatruetlon'(iMaadlaea, 
■aeblna^lnatnietion' ( la aad l ata, 
■aehlaa'lnatruetloa' (iMadlata, 
•aeblaa^laattuetloa' (ayataai^aUdrata^taglacac, 
" can' addraaa, AX) .* 


B.ADO, 

m MC, 1); 
aTniZ, S); 
■~labal,l); 
■_MOV, 


pragoM abatxaet_aea<ia^laaaetlona(trua); 
aa_laatr' <aA_bat.attbpev««. 0 , 0 , 0 ,all_arg.all_ax 9 );— (2) 
aa^loatr'(aa_SaeJ>lae](_laval,0,0,0,0,0); — yl > 0 

pcai^ abatcaet_aceda_laaartleaa({aXaa); 
and uaal 9 nad_add; ~ 


A roudne of this complexity is a candidate for INLINE expansioa In this case, no changes to the 
above 'madunejnstruction' statements ate requited. Please notice that there is a difference between 
addressing record fields when the routine is INLINE and when it is not: 


type tec is 


record 


low 

: imegen 

high 

end record: 

: integer. 

procedure add_32 is 


(opl 

: in iiueger. 

op2 

: in integer. 

res 

: out tec); 


The parameters take up 1 1 2 words « 4 words. The RES parameter will be 

addrnsed directly when INLINE expanded, i.e. it is possible to write: 


242 




DACS-80x86 User's Guide 
Implemenudoii-Dependefu Characteristics 


tnachiiie.instiuction'(systetn_additss.register. m.MOV, 

les’address, AX); 

This would, in the not INUNED veision, be the same as updating that place on the stack where 
the address of RES is placed. In this case, the insertion must read: 

machineJnstiuction'(register_system_address, m.LES, 

SI. res'addiess): 

- LES SI.(BP+...] 

machineJnstniction'(addtess_register. m.MOV. 

ES. SI, nil. scale.l, 0. AX): 

~ MOV ES:[SI+0],AX 


As may be seen, great care must be taken to ensure correa machine code insertions. A help 
could be to first write the routine in Ada, then disassemMe to see the involved addressings, and 
finally write the machine procedure using the collected knowledge. 

Please notice that INUNED machine insertions also generate code for the procedure itself. This 
code will be removed when the •nocheck option is applied to the compilation. Also not 
INLINED procedures using the AA.INSTR insertion, which is explained above, will automatically 
get a storage.check call (as do all Ada subprograms). On top of that, 8 bytes are set aside in the 
created frame, which may freely be used by the routine as temporary space. The 8 bytes are 
located just below the disfday vector of the frame (from SP and up). The storage.check call will 
not be generated when the compiler is invoked with 'nocheck. 

The user also has the option NOT to create any blocks at all. but then he should be certain that 
the return ftom the routine is made in the proper way (use the RETP instruction (return and pop) 
or the RET). Again it will help first to do an Ada version and see what the compiler expects to 
be done. 

Symbolic fixups are possible in certain instructions. With these you may build ’symbolic’ 
instructions byte for byte. The instructions involved all require the operand type NAME Oike used 
with CALL), and the interpretation is the following; 

(name, m.DATAO, "MYNAME") a full viitual address (offset and selector) of the 

symbol MYNAME (no additional offret is possible). 

(name. m_DATAW, ’’MYNAME") the offstt part of the symbtrt MYNAME (no additional 

offset is possible). 

(name, ffi_DATAB, "MYNAME’O the selector value of symbtd MYNAME 

In inlined machine instructions it may be a proUem to obtain the address of a parameter (rather 
than the value). The LEA instruction may be used to get the offset part, but now the following 
form allows a way to load a selector value as well: 

(system.address, LES. param’address) ES is loaded with the selector of PARAM. If this 

selecior was e.g. SS. it would be pushed and popped 
into ES. LES may be substituted fbr LFS arid LGS 
for 80386. 


243 







DACS*80x86 User’s Guide 
bnpleniemation-Dependem Guncteristics 


F.IO Padufe Tasktypcs 

TT>e Task’Types packages defines the TadtCorarolBlock type. This structure could be useful 
? program. The following package Taskiypes is for all DaCS-80x 86 excqx 

for DACS-80386PM/DACS-80486PM. 

with Syataa; 
paekag* TukTypM i* 

•vbcyp* Offaat la Syacaai.aaalgaaUHerd; 
aubtypa BloekZd ta SyataB.OaalgnMHerd; 

tjpa TaakBatxy la aao Syacaai-Onalonaaietd; 

tjpa Satxyladax la imm Syataa.OnalgaadNatd; 

SltarMtlvaZd la na« tyaTiai TTnalanarlMortl. 

Tleka la naw syaeaa.DMetd; 

CTP* Bool la aaw Boelaaa; 

for Bool'alxa uaa B; 

typa OZtttg la a«« Syataa.OnalgnadMerd; 

typa TaakStata la (Initial, 

—■ Tha eaak la eraatad. but activation 
. — haa not atartad yat. 

Kngagad, 

" Tha taak haa eallad an ontxy, and tha 
~~ eall la now aecaptad. la. tha randaavoua 
la In ptograaa. 

Bunnlng, 

— Covaca all othar atataa. 

Oalayad, 

'» Tha taak awalta a tlaMout to aicplra. 

BntxyCalllngTlaMd, 

•• Tha taak haa eallad an antey which 
•• la not yat aceaptad. 

BntxyCalllngUneondltlonal. 

— Tha taak haa eallad an antey unconditionally, 

— which la net yat aecaptad. 

SalaetlngTlaad, 

*- Tha taak la waiting In a aalact atataaant 
~ with an opan dalay altacnatlva. 

SalaetingOneondltlonal. 

— Tha taak waita in a aalact atataaant 
** antlraly with accept atataaanta. 

SalaetlagXaxBlnabla, 

— Tha taak waita la a aalact atataaant 
with an opan taxalnata altacnatlva. 

Becaptlng, 

Tha taak waita la an accept atataaant. 

SynchcanlXing, 

— The taak waita la an accapt atataawat 

— with no atataaant Hat. 

Ccaplatad, 

Tha taak haa ccaplatad the axaeutlcn of 
~ Ita atataaant Uat, b«t not all dapandant 
•• taaka aca taxalaatad. 

Tocalaatod I; 

Tha taak and all Ita daacandaata 
*"* arc taxalaatad. 


244 





DACS>80x86 User’s Guide 
Impiemenution-Dependeiu Qunctefisdcs 


for TmakJtat* as* (Xnltisl » i(*00« . 

Cn««««d » ICM** , 

Ruimlnf •> 1S«10* , 

Oslayod » X«*1S* . 

CncxyCalllagXlaMd •> 1C4204 , 
KnctyCkilliifaneoadltloMl •> 1C*2S« , 
S«laetlii«TlMd » 1C*31* . 
S«l«etla«aiieen41tlaMl •> l(t39« , 
S«laettii«T*asiMbl« » , 

Ace«ptln« >> 1M4A* . 

Synehsonltliiv ■> 1<*S3* , 
coavlacad ■> 1<«SC« . 

T*zalMt*d » 1MC4*): 

for TsakStaca'sis* uaa •; 

typ* Taaksypaoaaetlptot ta 
raeosU 

priority ; Syataa.trlorlty: 

antry count : Olntg; 

bXoek~ld : tloekld; 

firstjam^addrass : Systaa.Addraaa; 

aMdttXa_ausitoar : OXntg; 

antryjmwbar : OZatg; 

codajaddraaa : Systoa.Mdraas; 

ataek_slsa : Systaa.ONord; 

dUEsqp~ : Xntayar; 

staek_*a 9 nMnt__aisa: DXntf; 
and raeord; 

typa AeeTaakTypaOaaeriptor is aeeass TaskTypaOaaeriptor; 

typa MPXSavaAraa is array(X..4*) of Syatan.OnaiqaadMord; 

typa rXapsTypa is 
raeord 

mrxa« : soox,- 

Xnt*rruptrXa« : 1001 ; 

and raeord; 

prapaa paekCrXaeaTypa); 

typ* stataaTyp* is 
raeord 

state : TaskStata; 

is^abnocaal : ■oeX; 

is^activatad : BoeX; 

falXura : Bool; 

and raeord; 

praqBM paek(atat*sTypa) ; 

typa aer_typ* is 
record 

bp : Offset; 

addr : Systoa.Address; 

and raeord; 

pradna paek(Aer_typ*); 

Of AQBft SA0#a 

typ* TaakControXBXoek is 
raeord 

saa : Bystaa. taaapliera; 

isHottitor : intagar; 

— OaXay quou* handXing 

dnaat : Bystaa.TaakVaXu* ; 

dprov : Bystaa. TaakVaXu* ; 

ddaXay : Tleks ; 

— Bavad raglstars 

BS ; Bystaa.Onsignatflesd ; 


245 











DACS-80x86 User's Guide 
Impieraenitfion-DqKndenc QunathsUcs 


St : Offa«c ; 

RMUy q[iw<M hMdllnf 

nMt : Syataa.tukVAlu* ; 

1—sphoca haiuUlng 

••■Mxt ; Syataa.TMkValtt* ; 

Priority flolda 

priority : Syataa.Priority: 

a«voe_prlorlty : syatoa.Priority: 

Mlaeolloonoiia flolda 

tlao^alleo : Syataai.OnalpnodMord: 

flopa : riopatypo: 

SoadyCooat : Syata«.Nord: 

Stack spoeifleatloa 

ataek_atart ; Offact; 

ataekjaod : Offaot: 

State flolda 

atatoa : StataaTypo: 

Activation haadllap flolda 

activator : Syataat.TaakValuo: 

aet_ehaln : Syataai.TaakValtto: 

aon_ekala : Syatoc.TaakValuo: 

no_iiot_aet : Syatac.Mord; 

act_bl«ek ; SlockZd: 

Aeeopt 40 OUO flolda 

partner : Syatoa.taakvaluo: 

naxt^^artnor : Syatoa.SaakValuo: 

Entry qiiooo flolda 

noxt_eallor : Syatoc.TaakValuo: 

' Rondoaveoo flolda 

eallod_taak ■. Syatoc.TaakValuo: 

laAaynciT : intopor: 

taakjoatry s TaakEntry: 

atttry_indox : EntryXadox: 

oatry^aaaoc : Syatoa.Addroaa: 

eall^paraw : Syataa.Addroaa: 

alt^ld : AltomatlvoXd: 

oxC 9 _ld : Syatoc.ExcoptlonXd: 

- Do p o n do n cy flolda 

paront^taak : Syatoa.taakValva: 

paraat|1»loek : Sloekid: 

ehlldJtMk : SyatoM.TaakValno: 

next Alld : Syataa.TaakValtto; 

flrs?_cblld : SyatoH.TaakValuo: 

prov eUld : Syataa.SaakValna; 

ehll3_act : Syatoai.iiocd: 

bloek~aet : Systoai.*Dad.' 

toaalaatod.taak: Syatop.TaaKValao; 


Abortion handllnp fields 






DACS-80X86 User's Guide 
Irapkmemaiion'Oependeiu Qiaraoeristics 


— AuxiXlAsy Clvlda 

ctd : *eeTaakTyp«0««erlptoe; 

nratCallar : SyatM.TMkVAlu*; 

~ Run-TlaM SyatM ftaida 

ACT : kCrjZYP*: -- Q«ar*s guld* •.4.2 

SOrtrst : Xnt* 9 *c; *■* Only u««d in RMS 

Samritst : Xnt««*r; — Only nnad In RMS 

TBloeklnftnak : Systaa.TnakValun; — Only usnd In RMS 

raioeklnpTuk : Syataa.TMkvnliM; -- Only uaad la RMS 

eollnetloa : Syscnn.AddrMs; 
putltlon : Xncnqnr; 

TMkeiMekl,iaat : Offset; —• to ssaucs lalins stoESfs ehsek 

isatCxespcion : Systsat.OMotd; •• 2 * IS bits 

SsvsdMskdds : Offasc; — to lapco** roodssveas's 


-- KPX savo sxM 

— Mioa thn appllestlon la llnkod with n y, a apaelal 

— aava asaa for tba RfX la alloeatad at tha vary and 
-- of awoty TC». 

— la: 

— eaaa MtX^rroaant la 

— whan TMK •> HPXaava : Ntxsavakraa: 

— whoa rUM •> null; 

— aad eaaa; 

and raeord; 

— Tha following la to aaaura that tha TCI haa tha axpaetad also: 

Tes_slsa : constant XHTtSUl :> XaakCoatrolBloek*also / •; 

aubtypa TCS_okj*altta la nmoCR raaoa 13S .. ISf; 

TeS_ok : CMataat TCB_ok_valua :> TaakCantrolSloek'also / •; 

and TaakTypaa; 


F.11 RMS TasMng (OPTIONAL) 

The DACS-80x86 systems may run tasking ap(dications by means of Rate Monoionic Scheduling 
(RMS). RMS capability is purchased optionally, and is thus not included by default Please contaa 
DDC-I for more infoimation regarding RMS and ymir system. RMS allows the programmer to 
guarantee properties of a tasking system, le. that tasks will meet their hard deadlines. The RMS 
tasking is selected by specifying •mis to the Ada link command. 


247 








248 







