NAVAL POSTGRADUATE SCHOOL 
Monterey, California 


AD-A246 338 




s 


PTi, 

,~LECTK 
[^^ 26193 ^ 

8 



THESIS 


ON PROGRAMMING TRANSPUTERS TO CAPTURE 
ADA MULTITASKING FOR THE 
NPS AUTONOMOUS UNDERWATER VEHICLE 

by 

Clay Richmond 
December, 1991 

Thesis Advisor: Shridhar B. Shukla 

Second Reader: Roberto Cristi 

Approved for public release; distribution is unlimited. 


• 2 2 24 009 


92-04678 





Unclassified 

Security Classification of this page 


REPORT DOCUMENTATION PAGE 

la. Report Security Classification 

UNCLASSIFIED 

li 

estrictive Markings 



6c. Address (City, State, and ZIP Code) 

Monterey, CA 93943-5000 


8a. Name of Funding/Sponsoring 
Organisation 


6b. Omce Symbol 
(if Applicable) 

Code 33 


8b. Office Symbol 
(if applicable) 


Approved for public release; 
distribution is unlimited. 


onitormg Organization Report Number(s 



7a. T>Iame of Monitoring Organization 

Naval Postgraduate School 


7b. Address (City, State, and ZIP Code) 

Monterey, CA 93943-5000 


9. Procurement Instrument Identification Number 


Sc. Address (City, State, t 



10. Source of Fundine Numbers 



Work Unit 
Accessioo No. 


11. Title (include Security Classification 


ON PROGRAMMING TRANSPUTERS TO CAPTURE ADA 
MULTITASKSING FOR THE NPS AUTONOMOUS UNDERWATER VEHICLE 


12. Personal Author(8) 

Richmond, Clay A. 


13b. Time Covered I 14. Date of Report (Year, Month, Day) I 15. Page Count 

FVom _ To _. ~ 


16. upp ementary otation views expressed in this thesis are those of the author and do not reflect the 

official policy or position of the Department of Defense or the United States Government. 






17, Cosati Codos I 18- Subject Terms (Continue on reverse if necessary and identify by block number) 

Group I Subgroup | ADA, Channels in ADA, Multitasking, Processor Communication, Task, 

Transputer. 


19. Abstract (Continue on reverse if necessary and identify by block number) 

This thesis is in support of the on-going Autonomous Underwater Vehicle (AUV) project at the Naval 
Postgraduate School in Monterey California. This work investigates the development of a transputer-based 
multiprocessor and how to program it using Ada. 

The objective is to create a software layer that enables intertask communication over a network of trans¬ 
puters to be location invariant and to make the communication process treinsparent to the user. Ada, being 
a concurrent language, was chosen as the language in which this software layer is to be written. 

The method of intertask communication developed here captures the Ada rendezvous semantics, provides 
reliable and efficient delivery of messages between tasks regardless of their locations, and uses a common 
message format for all communicating tiisks. The location invariant property makes the software layer par¬ 
ticularly suitable for developing higher level allocation zdgorithms. The communication is handled by generic 
tasks common to each transputer and a common mapping function that has the locations of all the tasks. 


20. Di»tribution/AvaiIability of Abstract 21. Abstract Security Clauification -- 

[H] unclassified/imlimited I I same as report □ DTIC users I UNCLASSIFIED 


22a. Name of Responsible Individual 22b. Telephone (Include Area Code) 22c. Office Symbol 

_Shridhar B. Shukla _ (408) 646-2764 EC/Sh 


DD FORM 1473, 84 MAR 83 APR edition may be used until exhausted security classification of this page 

All other editions are obsolete , 

Unclassified 


1 





















UNCLASSIFIED 


19. [Item 19] Continued: 

The programmer needs only to conform to a common format of communication when sending messages 
between tasks and not be concerned with the actual delivery of the message. The software developed 
was successfully tested and its performance analyzed for a five transputer ring network using the AUV-II 
data-flow diagram. 


11 


SECURITY CLASSIFICATION OF TH 

UNCLASSIFIED 










Approved for public release; distribution is unlimited. 


On Programming Transputers to Capture 
Ada Multitasking for the 
NFS Autonomous Underwater Vehicle 


Clay A. Richmond 
Lieutenant, United States Navy 
B.S./ United States Naval Academy, Annapolis 1984 


Submitted in partial fulfillment 
of the requirements for the degree of 

MASTER OF SQENCE IN ELECTRICAL ENGINEERING 

from the 



AccessIon Fcr 


NTIS GRA4I 
OTIC TAB 
Unannounced 
Justification. 


sa^ 


□ 

□ 


By— 

Dlstr llytlon/ 


Avallabl llt7 Codes 
'Avail and7or~^ 
Special 


Diet 




Author: 


Approved by: 


NAVAL POSTGRADUATE SCHOOL 
December 1991 



Roberto Cristi, Second Reader 


Michael A. Morgan, Crairman 
Department of Electrical and Computer Engineering 


iii 



ABSTRACT 


This thesis is in support of the on-going Autonomous Underwater Vehicle (AUV) 
project at the Naval Postgraduate School in Monterey, California. This work investigates 
the development of a transputer-based multiprocessor and how to program it using Ada. 

The objective is to create a software layer that enables intertask communication over 
a network of transputers to be location invariant and to make the conununication process 
transparent to the user. Ada, being a concurrent high level language, was chosen as the 
language in which this software layer is to be written. 

The method of intertask cotiunimication developed here captures the Ada 
rendezvous semantics, provides reliable and efficient deliveiy of messages between tasks 
regardless of their locations, and uses a conunon message format for all communicating 
tasks. The location invariant property makes the software layer particxilarly suitable for 
developing higher level allocation algorithms. The conmnmication is handled by generic 
tasks common to each transputer and a common mapping function that has the locatioi\s 
of all the tasks. The programmer needs only to conform to a common format of 
communication when sending messages between tasks and not be concerned with the 
actual delivery of the message. The software developed was successfully tested and its 
performance analyzed for a five transputer ring network using the AUV-II data-flow 
diagram. 





TABLE OF CONTENTS 


I. INTRODUCTION. 1 

A. BACKGROUND. 1 

B. PROCESSOR AND COMPUTATIONAL REQUIREMENTS. 1 

1. Timing Requirements. 3 

2, Proposed Architecture. 3 

C. OBJECTIVES . 4 

D. ORGANIZATION . 6 

II. PROPOSED AUV-II ON-BOARD MULTIPROCESSOR . 7 

A. TASK RELATIONSHIPS FOR THE AUV-II. 7 

B. TRANSPUTERS. 11 

1. Overview. 11 

2. Transputer Links. 11 

3. Network Architecture . 12 

4. Transputer Memory. 13 

C. PROGRAMMING TRANSPUTERS. 14 

1. OCCAM. 14 

2. Interfacing Ada with Transputers . 14 


V 






















III. ADA PROGRAMMING OF A TRANSPUTER NETWORK 


16 


A. PRIMITIVES OF ADA AND THEIR USE. 16 

1. Entry/Accept Calls . 16 

2. Select Statements. 17 

3. Reading and Writing to Channels . 18 

4. Delay Statements. 19 

5. Read_Or_Fail / Write_Or_Fail Statements. 19 

B. ADA AND ITS USE WITH TRANSPUTERS . 19 

1. Design Considerations for Ada . 20 

2. Coiitmvmications Primitives Available in Ada . 20 

3. Ada as a DoD Standard. 21 

C INTERFACING ADA TO TRANSPUTERS USING OCCAM . 21 

1. The OCCAM Harness . 21 

2. Static Allocation. 23 

rV. BUILDING A COMMUNICATIONS PACKAGE . 25 

A. OBJECTIVES AND DESIRED BEHAVIOR. 25 

1. Design Criteria. 26 

2. Goals. 26 

B. SOFTWARE COMMUNICATION LAYER. 27 

1. Concept. 27 

2. Message Format. 31 

3. Communication Architecture. 32 

C CAPTURING THE RENDEZVOUS SEMANTICS. 33 

vi 

























V. PERFORMANCE ANALYSIS 


35 


A. SIMULATION ARCHITECTURE. 35 

B. RESULTS. 37 

C LIMITS ON PERFORMANCE . 40 

VI. CONCLUSIONS AND FUTURE WORK. 42 

A. CONCLUSIONS. 42 

B. FUTURE WORK . 42 

1. Higher Level Program. 42 

2. Difficulties. 43 

3. Parallelism. 44 

APPENDIX A; OCCAM SOURCE CODE . 45 

APPENDIX B; ADA SOURCE CODE . 53 

APPENDIX C: INVOKE AND LINKING FILES . 85 

LIST OF REFERENCES. 90 


INITIAL DISTRIBUTION LIST 


92 




















LIST OF TABLES 


Table I Description by file extension 23 

Table 11 Task locations 38 

Table 111 Average iteration times versus task allocations 39 

Table IV Average iteration time versus queue size 40 

Table V Measured iteration times when TIMER frequency is controlled 40 




LIST OF FIGURES 


Figure 1 AUV-II layout 2 

Figure 2 Block diagram of the T800 transputer [TRANS 89] 4 

Figure 3 Block diagram of the GESPPU-1 [G64 90] 5 

Figure 4 Transputer network interface with the host 6 

Figure 5 Data-flow diagram for the AUV [FLOYD 91] 8 

Figure 6 Four node transputer network 13 

Figure 7 Relationship between files for Ada on transputers 22 

Figure 8 : Overall functionality of software layer 25 

Figure 9 Communication layer structure 27 

Figure 10 : Communication topology 32 

Figure 11 ; Message flow at a transputer 35 

Figure 12 : Simulation data-flow 36 


ix 




ACKNOWLEDGEMENTS 


Though this thesis bears my name, there are a number of others who, without whose 
expertise, effort, and understanding, I could not have completed it. First, 1 am grateful to 
John Locke for getting me started on the transputers, answering my endless questions, and 
making available to me all his previous work. I am also indebted to Uno Kodres for his 
support and granting me free use of the transputer laboratory. 1 am extremely thankful 
to my advisor, Shridhar Shukla, for his patient guidance, insightful ideas, and constant 
availability. I would like to thank my friend and school partner, Dionysios Makris, who 
had the unerring ability to point out hidden facts that make engineering, and life, make 
more sense. He is a true engineer, and his friendship will be with me always. 

Lastly, I would like to give my heart felt gratitude to my wife, Kathy, for her love 
and uncomplaining support, which she gave towards the completion of this thesis, while 
at the same time coping with problems common to newly expecting mothers. Without her 
sacrifices, this thesis would not only have been impossible, but also pointless. 


X 





I. INTRODUCTION 


A. BACKGROUND 

The Naval Postgraduate School (NPS) is currently involved in a multi-year project 
to develop a prototype Autonomous Underwater Vehicle (AUV). This is an 
interdepartmental project involving the Computer Science, Electrical & Computer 
Engineering, and Mechanical Engineering departments. 

The research for this project was started in 1987 under the sponsorship of the Naval 
Surface Warfare Center (NSWC) at White Oak, Maryland. Since then, there have been two 
generations of AUV's. AUV-1 was a small vehicle, which could be carried by hand and 
relied on a radio link for control signals. It was also connected to an umbilical cord for 
conveying sensor data to the computer and for receiving power. The more recent AUV-11 
IS over four feet long, weighs over 350 pounds and is totally self contained [GOOD 89]. 
Figure 1 shows the current layout of the AUV-II supplied by the Department of Computer 
Science. 

B. PROCESSOR AND COMPUTATIONAL REQUIREMENTS 

The AUV-II uses a GESPAC computer cardcage with a 68030 CPU as its processor. 
In future models, a parallel processor based on transputers will be used to increase the 
performance adequately to meet the growing computational requirements. Furthermore, 
the use of a transputer-based parallel processor is planned to simplify the complex task of 
the software engineer by being able to modularize the many processes needed for its 
autonomous behavior. 


1 




Figure 1: AUV-II layout 


2 















1. Timing Requirements 


The AUV-II operates in a real-time environment that requires certain time 
deadlines to be met [CLOUTIER 90]. When using a single processor, meeting deadlines 
imposed by the application for both periodic and aperiodic processes is a critical problem. 
Allocation of processor time so that all the timing requirements are met is of the utmost 
importance [MAKRIS 91]. As the onboard computer is burdened with carrying out more 
and more processing to support the intelligent behavior of the vehicle, a single processor 
is unlikely to be able to meet all the timing requirements. By using multiple processors, 
the throughput can be increased to meet all the requirements. 

The desired frequency of execution of each process for running the AUV-Il is 
10 hz (with the exception of the sonar, in which case it is likely to be higher). As the 
vehicle becomes more intelligent, the amount of processing to be done at this frequency 
will increase. 

2. Proposed Architecture 

A transputer is a microcomputer that is especially designed to commimicate via 
links to other transputers. It has its own local memory and provides the interfaces for each 
of the commimication links [INMOS REF 86]. Figure 2 shows the block diagram of the 
T800 transputer. 

A possible interface to incorporate transputers is the GESPPU-1/GESPPU-2 
combination [G64 90]. Advantages of these cards are that they may be used with a 68030 
or IBM PC as hosts, and that any future additions of processors would require only the 
plugging in of another GESPPU-2 card [GESPAC 90]. 

The GESPPU-1 (see Figure 3) has one transputer (T800) and provides the 
interface between a transputer network and the host. One or more GESPPU-2 cards, each 


3 






Figure 2 : Block diagram of the T800 transputer (TRANS 89] 

containing two transputers (TSOO's), can be added to construct a network of the desired 
size [GESPAC 90]. Figure 4 shows the block diagram of the network interface with the 
host. 


C OBJECTIVES 

The objective of this thesis is to use a concurrent programming language on a set of 
processors. In particular, the goal is to create a software layer to enable the programmer 
to write a single program and run it on a network of transputers. This would keep the 
rigorous details of interprocessor commimication, such as message passing protocols and 
synchronization, away from the programmer and give the illusion of a single program 


4 



















GESPPU-1 



Figure 3 : Block diagram of the GESPPU-1 [G64 90] 


nmning on multiple processors. 

The premise of this software layer is to be able to handle all the communication 
necessary between all the tasks that are running on the network. This would make it 
possible for a software designer to construct a task oriented program and be able to run 
that program on one or more processors without regard to the location of the individual 
tasks and the inherent communicatioirs needed. Thus, this commimication layer makes the 
network transparent to the programmer so that he/she need not worry about where the 
tasks are to be allocated. This, of course, would make parallelism easy to implement with 
already existing programs as well as new ones. 


5 















Host 


GESPPU-1 




GESPPU-2 


GESPPU-2 1 



i 

I 

20 Mb/s 
Links 



1 

1 



j 

( 

I 

1 

( 

i 

i 






j 

r 1_ 

" I 1 _ 




__irri_ 

n TT" ” 

G-64/G-96 Backplane 

Transputer Link Backplane H 


Figure 4 : Transputer network interface with the host 
D. ORGANIZATION 

In the second chapter, brief descriptions of the tasks used for the AUV~II are given, 
as well as how they interrelate. This chapter also covers the basics of transputers and 
transputer networks. Chapter III describes some of the special constructs of Ada that are 
of interest for this thesis and describes how Ada is interfaced with the transputers. The 
fourth chapter then describes the construction of the communication layer and the thought 
behind its desired behavior. The results and performance of the developed layer are 
presented in Chapter V. Finally, Chapter VI contains conclusions and recommendations 
for future work and development. 


6 






II. PROPOSED AUV-II ON-BOARD MULTIPROCESSOR 


A. TASK RELATIONSHIPS FOR THE AUV-II 

The AUV-II executes many programs for successful completion of its mission. The 
inter-relationship of these programs, which from now on will be referred to as tasks, is 
shown in Figure 5. For the purpose of this thesis, the exact nature of these tasks is not 
relevant, but the communication scheme is the point of interest. It is important to note that 
not all the tasks execute at the same rate or in the same order. As previously mentioned, 
the sonar can be expected to execute at a higher rate and, in addition, there are tasks that 
execute on an aperiodic basis. Periodic tasks execute at a known frequency of 10 Hz and 
must finish execution before specific deadlines. Aperiodic tasks on the other hand, execute 
at random times, as dictated by external events, and provisions must be made to handle 
the resulting coitvmunication from these tasks. For the sake of clarity, a brief description 
of the all tasks is provided below. 

1. Operator 

This is an input from the operator prior to the start of a mission. Normally, 
after the commencement of a mission, the operator no longer has any input. 

2. Environmental Database 

This is a database maintained in the memory of the vehicle for mapping 
obstacles that can be, or have been, encountered by the external sensors. It is pre-loaded 
with known obstacles and then updated by the vehicle's sensor data. Its maintenance is 
the responsibility of the sonar data processing task. Also, the Plan/Replan Mission task 


7 





has access to all mapped obstacles for the purposes of creating the best route to the 
vehicle's destination. 

3. Sonars 

These are the external sensors that obtain the raw data for processing. The 
control signals for the sonar are sent via the Vehicle Systems task. 

4. Vehicle Systems 

This represents all the external systems that control depth, speed, heading, etc. 
The control signals for these systems come from the Develop Control Signals (Autopilot) 
task. In turn, the Vehicle Systems returns current status and updates to Autopilot, Sonar, 
Navigate, and Monitor Systems Status tasks. 


8 


















5. Mission Log 

This is a database for keeping all the desired information of a mission. Post 
inission recoitstruction is achieved through this data. 

6. Plan/Replan Mission 

This is an ap)eriodic task that lays out the initial route for the vehicle and 
generates the waypoints [CLOUTIER 90]. This path is sent to Execute Mission and is then 
idle until Execute Mission decides that the route needs to be changed, at which time it 
sends back a request and the mission is replanned. 

7. Execute Mission 

This process receives the array of waypoints generated by Plan/Replan mission 
and sends the next single waypoint to Guidance. Execute Mission is also always updated 
with status reports from Monitor Systems Status and the Avoid Obstacles tasks. 

8. Guidance 

Guidance receives its instructions from Execute Mission as to the next 
destination for the vehicle. It is the job of this task to generate the desired values for 
heading and velocity. These values are then sent to Autopilot. Information from 
Navigation is also received and compared to the current values in case a correction needs 
to be made. Finally, input is received from Avoid Obstacles on an aperiodic basis for 
emergency posture changes. 

9. Develop Control Signals (Autopilot) 

After receiving the desired heading and speed values from Guidance, the 
Autopilot generates the necessary control signals for the control surfaces on the vehicle and 
sends them to Vehicle Systems. In return. Vehicle Systems provides feedback by returning 
the control positions to Autopilot. 


9 






10. Monitor Systems Status 

This task receives reports from Vehicle Systems on a periodic basis and, from 
these signals, it determines operating and casualty posture. Its output is sent to Execute 
Mission. 

11. Navigate 

The Navigate task has the responsibility of determining the current position of 
the vehicle. It also determines actual heading, velocity, and acceleration [CLOUTIER 90]. 
It sends its output to Guidance and to Mission Log for recording. The input and inertial 
data it uses to determine position and vehicle parameters is provided by Sonar and Vehicle 
Systems. 

12. Process Sonar Data 

The Sonars send rav^r signals to this task for processing. This is where objects 
are physically located and iruipped. Any previously unknown obstacle is sent to the data 
base for cataloging. Also, if a possible danger exists, the data is sent to Avoid Obstacle for 
emergency posture changes if needed. Finally, the data is also sent to Navigate fo. - 
position update. 

13. Avoid Obstacle 

This is an aperiodic task that is activated only in the case of a possible 
emergency. Input from the Process Sonar Data task is received if a possible obstacle is 
detected. It is the job of this task to generate an emergency posture for the vehicle to 
assume and send it to Guidance and Execute Mission. 


10 








B. TRANSPUTERS 


Each of the tasks, outlined in the previous section, has the potential of presenting a 
complex set of computational requirements. These requirements continue to gro^v with 
each new software design as the intelligence of the vehicle grows. To keep the on-board 
architecture scalable, a transputer based multiprocessor is to be implemented. 

1. Overview 

The transputer represents a family of microcomputers that have their own local 
memory and an array of communication links. They operate as a stand alone machine, or 
as a node in a network interconnected via links [INMOS 89]. When in a network, each 
transputer operates on its own using only on-chip memory and programs. Communication 
from one processor to another occurs over the links each of which has a dedicated link 
interface. The communication interface is implemented in hardware and does not need the 
processor for its control. 

2. Transputer Links 

The point to point serial links have several advantages over a common 
communication bus. Among these is the fact that there is never any contention for use of 
the line of coirununication regardless of the number of processors (as system size increases 
the total bandwidth increases). The second major advantage is that, as the number of 
processors increases, there is no capacitive load penalty. Finally, regardless of the number 
of processors, the connection between a subset of processors can be short and local 
[INMOS REF 87]. 

The links provide for direct communication between processes on neighboring 
transputers. Each link consists of two imidirectional signal lines (one going in each 
direction) and, thus, provides for two communication channels between processors. 


11 





Commimication across the link uses a link protocol and is accomplished as a sequence of 
single byte transmissions. This requires only a one byte buffer in the receiving transputer 
and allows for the same protocol to be used regardless of word size. In each byte, there 
is a start bit, a stop bit, and a control bit that signifies if the message contains data or an 
acknowledgement message. If the message contains data, then the control bit is followed 
by eight data bits [INMOS REF 87]. 

After each data message is transferred, the next one cannot be sent imtil an 
acknowledgement is received from the receiving transputer. Since an acknowledge 
message can be sent when the start bit of the data message is received, there is no actual 
delay at the sending end and transmission is continuous. 

3. Network Architecture 

The transputers to be used for the AUV project (and most other transputers 
found on the market) have four communication links each. This nreans that they can be 
connected in a variety of topologies. One possible network is shown in Figure 6. The 
network architecture chosen, of course, depends on the implementation as well as the 
number of nodes in the network. It also, at least partially, determines the complexity of 
the necessary commimication protocol used. Therefore, the communication software 
consideration should impact the choice of the topology. For this project, the software was 
developed and tested in the lab on an INMOS B(X)03 board with four T800 transputers 
hardwired in a ring is used. A fifth transputer, a T8(X) with 4 Mbyte external memory, is 
used as the host for communication with the ring. The configuration used in the lab is 
nearly identical to a system that incorporates one GESPAC GESPPU-1 and two GESPPU-2 
boards with an IBM PC host. For the sake of simplicity, the ring architecture was chosen 
for this thesis, ignoring the other available links of the transputers. 


12 






Figure 6 : Four node transputer network 


4. Transputer Memory 

Transputers are not designed to share memory; instead, each has its own 
dedicated memory. The transputer is also provided a small amount of on-chip memory 
for fast access. For the T414, there is 2 Kbytes of static RAM, and, for the T800, this is 
doubled so that there is 4 Kbytes of static RAM. Also, there is 4 Gbytes of addressable 
external memory possible [DATABCXDK 89]. 


13 










C PROGRAMMING TRANSPUTERS 

1. OCCAM 

The high level language designed for expressing concurrent processes and 
implementing them on a network of transputers is OCCAM [HOARE 88]. It is rapidly 
becoming the standard for programming concurrent systems, and in the case of 
transputers, it is actually executed more or less directly [FOUNTAIN 86]. For this reason, 
OCCAM is often considered the "assembly language of transputers". To execute a program 
written in any other language, the executable code must be linked together by a framework 
of channels. This is called a "harness" and is always written in OCCAM. 

The harness contains the configuration information to specify the channels and 
the transputer configuration. It also assigns the separately compiled code to the different 
processors. When the program is running, it is treated as a single OCCAM process, and 
as such, can commimicate with other OCCAM processes or pseudo-OCCAM processes, 
such as other programs on separate transputers [ALSYS 90]. 

2. Interfacing Ada with Transputers 

The compiler used for this thesis is the Alsys Ada Compilation System for the 
Transputer, version 4.4. The process of program development is given in the User's 
manual as: 

1. Create a program library family (groups all rebted program libraries. There are 
application bmilies and insbUation families). 

2. Create a program library. 

3. Write the source code for the program compibtion imits. 

4. Compile each source unit with the Ada compiler to produce a corresponding object 
tmit. 


14 





5. Bind the object units together with the Run-Time Executive using the Ada Binder to 
produce an object module. 

6. Link the object module to any required external modules, including the occam 
harness, to produce an executable program. 

7. Run and test the program [ALSYS 90]. 

The interrelationship of all the different files, both user written as well as 
system generated, is discussed later. The code used for this thesis is given in the Appendbc 
A. Interfacing of Ada with OCCAM is currently a cumbersome task, but many of the 
above steps can be accomplished in a Makefile, and thus, become more or less transparent 
to the programmer. 


15 






III. ADA PROGRAMMING OF A TRANSPUTER NETWORK 


A. PRIMITIVES OF ADA AND THEIR USE 

One of the principal advantages of Ada is the concurrency constructs that are built 
into the language. The structure of an Ada program, designed to run in parallel, consists 
of several tasks that function as programs in their own right and can commimicate with 
other tasks and the main program via entry calls. Inside a program that contains tasks, the 
separate tasks do not truly run concurrently. Instead, they run in a multitasked mode, 
since they still reside on a single processor. Processes on a single transputer are time-sliced 
into approximately 1 ms intervals and it runs its tasks and main program by multitasking 
[ALSYS 90]. Ada allows for tasks to be given different priorities in which case tasks are 
executed with highest priority going first. All tasks of the same priority are executed in 
a round robin fashion [ALSYS 90]. 

Some of the primitives used in Ada for commimication and parallel prograixuning 
are described below. 

1. Entiy/Accept Calls 

When a task is declared, all the legal entry calls that are accepted by that task 
are declared along with the specifications of the calls. When another task wishes to send 
a message to this task, an appropriate entry call must be used. The receiving task does not 
know the origin of the call, but the sending task must know the destination. 

Inside the receiving task, when a point is reached where outside input is 
desired, an accept statement is used. The task blocks at this point and waits for the proper 
incoming entry call. The same block occurs at the sending task if the destination task is 


16 



not yet ready to receive. When both tasks are ready for conununication, a rendezvous 
occvirs and the data is transferred. Both tasks then proceed from that point. If more than 
one task is attempting to communicate with a single destination then the calls are queued 
and handled on a first come first served basis. 

2. Select Statements 

A very powerful construct of Ada is the select statement. This construct allows 
for alternatives in the execution of the program. The select statement has several uses 
among which are some that are helpful in building a conununications package. The two 
most commonly used types of this construct are the timed entry calls and the selective 
waits. 

a. Timed Entry Calls 

This use of the select statement simply allows for an alternative between 
an entry call or a delay statement. If the rendezvous occurs before the specified delay, 
then the entry call is used. Otherwise, if the delay time expires, the task is eligible to 
continue execution from that point. This type of select statement is the basis of the rotating 
queue used in this thesis. The most common delay used is zero delay, which means no 
delay; thus, if the destination is rot ready at the time the call is made, the call is aborted 
and a different one is tried. 

b. Selective Waits 

This type of select statement offers two or more alternatives that may or 
may not have conditions associated with them present for their selection. They are of great 
use when receiving input to a task when the order of arrival of the different messages is 
not knov^ or the timing is not known. With this type of select, an input can be received 
if offered, but if there is none forthcoming at the time, the program can continue without 


17 




delay; or if desired, it can wait at this point until an entry call is made that fulfills one of 
the possible selections. 

c. Select Limitations 

A notable limitation to the select statement, that can be programmed 
around but only with some difficulty, is that READING and WRI TING to the CHANNELS 
is not a legal alternative. This can lead to a serious problem since the program will stop 
and wait at any normal read or write statements until they can be processed. This leads 
to the necessity of devoting additional tasks that were dedicated only to the reading and 
writing of the channels. 

3. Reading and Writing to Channels 

In the ALSYS Ada for transputers, there in a generic package called 
CHANNELS that facilitates the use of the transputer channels. The program treats I/O to 
a channel as if it were a file. The channels must be declared, and when reading or writing 
to a channel, the statement must include the channel name. There are no queues of writers 
for the channels unlike the rendezvous model used in task entry calls; so, when attempting 
to read or write, the program suspends until the data is available or accepted respectively. 
This can lead to the serious problem of deadlock. 

Deadlock occurs if some or all processes are suspended while waiting for an 
event that will not occur. A simple example could be if Task A wishes to SEND to Task 
B, then it will suspend until Task B is ready to receive. But then, if Task B decides it needs 
to SEND to Task A, it will suspend until Task A is ready to receive. Both tasks are 
suspended waiting for the other and deadlock has occurred. With any non-trivial 
communication network, special steps must be taken to avoid deadlock, and to be able to 
recover the program, should a deadlock situation occur. 


18 






Unlike the model used in task entry calls, when vising channels, the receiver 
must know the identity of the channel the data is from; thvis, it knows the identity of the 
sender [ALSYS 90]. 

4. Delay Statements 

This statement is a simple way of delaying a program for any reason or, in the 
case of the select statement, to declare the amount of time the program will wait for an 
alternative to occur. Since the actual executable code in the tasks of the AUV-11 is not 
relevant to the testing of the communication software developed here, "dummy" tasks were 
created that simulated the communication scheme. Delay statements have been used in 
place of code in the dummy tasks to simulate processing time of the various tasks. They 
were also used, of course, as mentioned, in the select statements. 

5. Read_Or_Fail / Write_Or_Fail Statements 

These two statements are constructs that partially compensate for the deficiency 
mentioned above under the select statements. With these, the programmer can designate 
a particular time, as read from the on-chip clock, that the process will wait for xmtil it 
declares the read or write attempt a failure. After the statement is executed, a variable can 
be checked to find out if the attempt was successful or not. These statements can be used 
to insure that deadlock cannot occur, but increases the size of the code necessary since an 
entire new library is needed to implement them. 

B. ADA AND ITS USE WITH TRANSPUTERS 

From the start, one of the goals of this thesis was to use Ada on transputers. The 
first reason for this goal is that Ada has been specifically designed as a concurrent 
language, making it a logical choice for use on concurrent processors. Another important 


19 





point is that Ada, is the currently the adopted DoD standard and all software development 
for the DoD is encouraged to use it. Finally, Ada has the communication primitives 
necessary to utilize the transputer links efficiently. The use of any pragmas to other 
languages is not required. 

1. Design Considerations for Ada 

Each transputer is required to have an Ada program that can be compiled and 
run as a "stand alone" program. This means that the tasks in Ada actually only run in a 
multitasked fashion since all the tasks in the program must run on the same processor. 
On the transputers, this is handled normally by time-slicing the processor into 
approximately 1ms intervals. This can be modified with a priority system inside the 
program if desired. The real concurrency is the actual programs that run in parallel on the 
different transputers. 

2. Communications Primitives Available in Ada 

For the Alsys system used for this thesis, there is a package called CHANNELS 
that provides the necessary routines for the channels declared in the OCCAM harnesses 
to be used inside the Ada program. The procedure calls are simple READ and WRITE 
statements with the designated channel (declared in the program) as one of the argiunents. 
These statements may be used anywhere in the program any number of times. 

A problem arises when there is imrestrained use of these statements, resulting 
in deadlocking the program. The compiler does not notify the programmer if, due to 
communications on a channel not being synchronized, a deadlock will occur and no error 
message is generated if it does occur during run-time. This limitation leaves the problem 
of insuring that all commimications take place in such a manner that the deadlock situation 


20 





where a sender is waiting to send but the wrong receiver is waiting to receive, never arises, 
as the responsibility of the prograiiuner.. 

The basic task communication is accomplished through a rendezvous and 
multiple task calls are queued [ALSYS 90]. If the protocol used in the task calls could be 
simulated and used in the program communications, then the problem of deadlock could 
easily be solved. 

3. Ada as a DoD Standard 

Ada was created as the result of the United Sates Department of Defense's 
attempt to standardize software used in the DoD. In the late 70's, and the early 80's, Ada 
was accepted as the standard in the USA, and in 1987, it was accepted as an international 
ISO standard [SKANSHOLM 89]. Ada is still currently the DoD standard. This, in 
addition to the already mentioned advantages, made it an ideal choice for this project. 

C INTERFACING ADA TO TRANSPUTERS USING OCCAM 

The process of binding, linking, and loading a system of Ada programs for a 
transputer network is currently rather arduous. OCCAM is a programming language that 
has the capability of total concurrency and has a special relationship with the transputer. 
As mentioned earlier, transputers can simply be thought of as the hardware 
implementation of OCCAM [TRANS 89]. As a result, all higher level languages used on 
transputers are invoked through OCCAM harnesses. 

1. The OCCAM Harness 

There are a variety of programs that are provided for the Alsys compilation 
system in the Occam! Toolset which is a set of tools written by INMOS [ALSYS SYS 90]. 


21 




















































Table I: Description by file extension 


Extension 

Contents User Written 

•.ADA 

— Ada source code (text) 

YES 

•.occ 

— CXICAM source code (text) 

YES 

•.PGM 

— CXCAM source hardware 



configuration (text) 

YES 

•.o 

— Compiled Ada 

NO 

•.TAX 

OCCAM compiled in T800 (TA) 



UNIVERSAL mode (X) 

NO 

•.DSC 

— Configured code descriptor 



file (text) 

NO 

•.BTL 

- OCCAM module, bootable by iserver 

NO 

•.x8S 

— OCCAM compiled in T8(X) STOP mode 

NO 

•.Cxx 

- Linked OCCAM code (not bootable) 

NO 

•.Mxx 

— CXCAM configuration map (text) 

NO 

•.Txx 

— Compiled (X^CAM 

NO 


Since the actual mechanics of binding, linking, and loading are not of interest for the 
purpose of this paper, only the interrelationship of all the files, both written and generated, 
is provided in Figure 7. Table 1 provides a key to the different file extensions and also 
shows which of the files must be written by the programmer and which are generated. 

What is important to know is that the assignment of the hardware channels to 
the transputer links, as well as the processors to the programs, occurs in the harness. This 
also applies to the assignments of the allowed memory to use for the work space. A copy 
of all the harnesses and text files used for this thesis are provided in the Appendices. 

2. Static Allocation 

An important as well as limiting factor is the fact that the OCCAM source 
hardware configuration given in the *.PGM file of the harness is static. The consequences 
of this are that it is not currently p>ossible to write a program that will allocate tasks to an 


23 





appropriate processor (i.e. this must be done by hand). Since this is implementation 
dependent, it may be a future improvement needed in the system. 


24 





IV. BUILDING A COMMUNICATIONS PACKAGE 


A. OBJECnVES AND DESIRED BEHAVIOR 

The long term goals of this project are to make it possible for a programmer to write 
a single task oriented program, and run it on a network of transputers without knowing 


Network topology 



Ada application distributed 
over the network 


Figure 8 : Overall functionality of software layer 


anything about the network or its conunimications. As mentioned earlier, hiding the 
network from the programmer in this manner requires an intermediate software layer. The 


25 







conceptualized application development procedure using this software layer is shown in 
Figure 8. The first step in this is creating a communication scheme for a network that will 
enable the intertask communication to be location invariant since the programmer will not 
know the final locations of the tasks when writing the program. 

1. Design Criteria 

Important factors that went into the design of this layer included reliability, 
deadlock avoidance, and speed of message delivery. In any network communication, 
reliability is a major criterion. For the purpose of this thesis, the level of reliability desired 
is directed towards guaranteeing that a message will be delivered even at the cost of 
extended time delays. No provisions are made to recover from messages lost or damaged 
due to hardware failures. 

The structure of the software conununications layer is designed in an attempt 
to minimize the possibility of a deadlock situation. Even so, timers are used in the 
program to insure that the processes respoi^ible for commimication will not hang up at 
any one event, thus insuring a recovery from a deadlock situation should one occur. This 
design to prevent deadlock aids speed of message delivery also since commimication lines 
are not allowed to stay dormant for extended time periods when there are messages that 
require delivery. 

2. Goals 

The goals of the program and its behavior are closely related to the design 
criteria but are more specific. They are: 

• Intertask communication is location invariant (reliability or operability not are not 
affected by where the task is located). 


26 





• Conununication between local and non-local tasks vises the same syntax; this is 
required to attain the previous goal. 

• Messages are delivered in a timely and reliable feishion. 

• Ada senumtics of blocking rendezvous mechanism is preserved. 

B. SOFTWARE COMMUNICATION LAYER 
1. Concept 

The block diagram in Figure 9 shows the structure of the software tasks used 



Figure 9 : Communication layer structure 


to create the communications package. Ideally, this structure could handle any nvimber 


27 
















of input and output channels. Since each channel handler represents a dedicated task for 
the transputer, the task load on a transputer could be prohibitive for trai^puters with more 
than the normal four links. A description of the various blocks is provided below. 
a. Channel Handler 

This is the simplest of the communication tasks. Its sole function is to read 
data from a single channel. When a Channel Handler receives a message it simply passes 
it to Traffic Controller. If Traffic Controller is busy, in order to keep the incoming chaimel 
open for further messages, the message is placed in Overflow Traffic Storage. Once a 
Channel Handler hands off its message, it returns to a wait state for more data from the 
channel. 

The reason this function is required to be accomplished in a dedicated task 
is that the select statement in Ada does not allow a READ statement to be an alternative. 
This means that the program cannot check a channel to see if there is data there without 
actually doing a READ. If a READ is executed, the program will go into an indefinite wait 
period until data is available, thus precluding the execution of any statements further on 
in the program. By putting the Read statement in a task by itself, the frequency of input 
does not control the frequency of any other task execution. 

As mentioned in Chapter III, Ada does provide a READ_OR_FAIL 
statement that enables the programmer to set a limit to which the READ will be attempted, 
after which it will be aborted. The inefficiencies and the additional algorithms needed to 
use this statement often precluded its use. It was decided that the additional task load is 
a better alternative in the case of reading from a channel. 


28 




b. Traffic Controller 


The purpose of this task is to direct all messages in the proper direction. 
It is here that the location of the tasks must be known. For the communication architecture 
xised for this thesis, the only determination to be made is if the destination is local or not. 
In other architectiues, if the destination is not local then Traffic Controller may need to 
decide to which output channel to send the message. Since a ring conununication scheme 
is used, there is only one output channel for each transputer allowed. The one exception 
to this is in the program MARS in which output is also sent to the program EARTH for 
I/O to the screen. These programs are described later. 

If messages are determined to be destined to local tasks, then Traffic 
Controller directs the message to Local Mailman. If Local Mailman is full, then the 
message is automatically sent back to the loop with the intention of catching it the next 
time around. Again, this is done so that Traffic Controller will never be stuck with a 
message. The drawback to this is that, in heavy traffic, it is possible that a message passes 
arotmd the loop several times before being delivered. 

Messages are received by Traffic Controller from all local sources including 
the application tasks. Local Mailman, all Channel Handlers, and Overflow Traffic Storage. 
Therefore, for this concept to be successful, it is critical that the channels remain open (i.e. 
a message cannot get stuck on a channel, and thus, prevent the Traffic Controller from 
writing to it) so that Traffic Controller can process messages without delay. 

As mentioned before, the task will wait at the write statement until it is 
able to execute it regardless of the delay involved. This is why Channel Handlers will not 
hold a message for any amount of time, but rather, attempt to send the message to Traffic 
Controller. If that fails, the message is immediately put in the Overflow Traffic Storage. 


29 






In this way, we are assured that Traffic Controller will incur no time delay when 
attempting to write to a channel and a deadlock situation will be avoided. 

A further safeguard for keeping the channels free is that Traffic Controller 
will always prefer to accept input from Chaimel Handlers. If, and only if, no other input 
is offered from these tasks will input be accepted from the other local routines. 

c. Overflow Traffic Storage 

This is a simple task that stores messages and sends them to Traffic 
Controller on a first-in-first-out basis. The storage facility in this task is a static array, and 
therefore, it has a maximum size. At this point in the development, the maximiun size 
needed can only be determined by the application. During the testing performed for this 
thesis, it was found that this task was rarely even used; therefore, a very small maximiim 
size was found to be sufficient. 

An item of interest that is a result of the priority system of Traffic Handler 
is that a message coming in from a channel into a Channel Handler has a higher priority 
to be accepted into Traffic Handler. If it fails to be accepted, then it is passed to Overflow 
Traffic Storage and its priority is then lowered. This means that it is possible that two 
messages passing through a transputer may actually be reordered if the first of the two 
were placed in overflow and second passed on through unhindered. The possible 
reordering of messages was not seen to be a problem since the beginning order was 
random in the first place. 

d. Local Mailman 

The purpose of this task is to provide a rotating queue that sends messages 
to their final destinations when they are ready to be received. The task receives a message 
and stores it in a static array. It then rotates through the array looking in each slot to see 


30 





if it has a message to send. If the slot is full, then a quick attempt is made to send it. If 
the receiving task is not ready, then the attempt fails and Local Mailman skips the slot and 
looks for another. If the receiving task is ready to accept, then the message is sent, the slot 
is emptied, and an acknowledgment message is sent back to the sending task via Traffic 
Controller. 

As is the case with Overflow Traffic Storage, the array for the queue is 
static; so again, there is a maximum number of messages that can be stored. In contrast 
to Overflow Traffic Storage, the maximum size chosen did have a measurable affect on the 
average message delivery time. This will be discussed in the next chapter. 

Local mailman has access to all the necessary entry calls for the application 
tasks on its transputer. For this thesis, this was handled in the form of a separate 
procedure called by Local Mailnran which is tailored for individual transputers. In later 
developments, this procedure will be generated by a higher level program. 
e. Application Tasks 

These are all the tasks written by the programmer for the application 
program. All tasks receive messages from Local Mailman and send outgoing messages to 
Traffic Controller (even if the destination task is local). This leads to the necessity of 
standardizing the message format used by all tasks. 

2. Message Format 

The message format used could vary from application to application with only 
a few common requirements. The items that must always be present in the message are 
the destination task, the sending task, and the entry call to be used. The reason for the 
destination task and the entry call to be included is obvious. The reason for the sending 
task to be included is that Local Mailman of the receiving transputer should know who to 


31 







Figure 10 : Communication topology 

send the returning acknowledgement message. As described later in this chapter, this 
acknowledgement message is required to capture the Ada rendezvous semantics. The 
remainder of the message is application dependent. 

For this thesis, the message was in the form of a record with entries mentioned 
above along with a time entry for timing message delivery times, as well as two arrays for 
data (these arrays were initialized but not actually used for any purpose). 

3. Communication Architecture 

The topology used for commimication for this thesis was a simple ring. It was 
chosen for its simplicity and the intention that, if the software layer can be n\ade to work 


32 

















with a ring, then in later developments, more complex topologies can be easily 
incorporated. Figure 10 shows the topology and the programs resident on the different 
transputers. 

C. CAPTURING THE RENDEZVOUS SEMANTICS 

In Ada, communication between tasks within a program is accomplished through 
accept and entry calls. A task wishing to receive a message has an accept statement; and 
when such a statement is reached, the task blocks until a message with the proper entry 
call is received (regardless of sender identity). A task wishing to send a message names 
the destination task and the entry call with the message as the argument. If the receiving 
task is not yet ready to accept the message, the sender blocks imtil the message can be 
sent. The sane holds when the receiver reaches the accept statement first. When both 
communicating tasks are at their respective statements, a rendezvous occtus. At this point, 
the message is transferred, and both tasks continue their execution from that point. 

For the communication software developed here, it is desired to preserve this 
mechanisnt Since, in the case of location invariant commimication, the commimicating 
tasks cannot be assumed to be co-located on a processor, an actual rendezvous as discussed 
above cannot occur. To simulate it, an acknowledgment message is used. 

When a message is known to hav ached its destination, an acknowledgment 
message is generated and sent to the originating task. The originating task, as part of the 
communication protocol, has an accept statement immediately following any entry call 
made to another task. This prevents the sending task from continuing in its processing 
vmtil it is assured that its message has been received. This captures the rendezvous 
mechanism completely except for the fact that the receiving task will commence its 


33 




execution slightly before the sender since some amount of time is required for the delivery 
of the acknowledgement message. 

The acknowledgment message in the software developed for this thesis is generated 
in the task Local Mailman since it is there that it is first known if a message has been 
successfully delivered. It is generated using a generic message with the originating task 
used as the destination, and an entry call common to all tasks for receiving 
acknowledgments. Local Mailman will not send an acknowledgment if the message 
delivered, was itself an acknowledgment. 


34 





V. PERFORMANCE ANALYSIS 


A. SIMULATION ARCHITECTURE 



To test the tasks written for the communication software layer, a set of tasks similar 
to the one seen in the AUV-II data-flow diagram is used. Figure 11 shows the 
interrelationships of the tasks that handle the communications and are common to all 
transputers and Figure 12 shows the task interrelationships as set up for the testing of the 
communications. The entry calls are shown between the two tasks and the transputer that 
the task is running on is shown below the task name. 


35 




The components of Figure 11 relate to the software layer structure previously shown 
in Figure 9 as follows: the Main Program shown serves as the Channel Handler with the 
task WAITING serving as the Overflow Traffic Storage; the function of Traffic Controller 
is handled by the task INOUT; and Local Mailman is QUE. 



A task added to control the frequency of execution is also shown in the Figure 12 
called TIMER. This task simply outputs a GO to VEHICLE_SYS at a predesignated rate 
and the execution of the latter task cannot proceed until it is received. The main program 
in Ada functions much as does one of the program's tasks, so it can be used for one of the 
commimication layer tasks. Here it is used for the Channel Handler since for this topology 
only one is needed. Finally, the task SCREEN in the earth program is simply an I/O 


36 








routine that will decode a message and print it out regardless of the origin. This was 
found to be the best way to troubleshoot the programs and output performance 
measurements since only the host transputer has the capability to output information to 
the screen. 

B. RESULTS 

In testing the software developed for this thesis, a series of runs were made, each 
with one hundred iterations. A single iteration consists of all eight AUV-II simulation 
tasks executing once, and all thirteen messages involved sent and acknowledged (the task 
TIMER is not included in this, although it controls the frequency). The nurhber of one 
hundred was arbitrarily chosen and was considered to be high enough to approximate 
continuous program execution. The first significant resxilt is that deadlock did not occur 
for any number of program iterations. This was tested by varying the maximum queue 
size and running the program for one hundred iteratioivs at maximum frequency. Even 
when the queue size was dropped to a maximum of only two, the one hundred iterations 
ran to completion without deadlock. This showed that even when the queue was 
overloaded, messages were still reliably delivered. 

The second major achievement is that the location invariant communication was 
achieved. Table 2 shows the original location and the final locations of the tasks in relation 
to the programs on the transputers. The final locations are considered to be more optimal 
than the beginning positions because as many commvmicating tasks as possible are 
collocated. In both cases the communication was conducted without deadlock or lost 
messages. It is important to note that the average time per iteration was significantly 
higher for the first task placement. 


37 






Table II: Task locations 


Task 

Beginning Location 

End Location 

AUTO PILOT 

MARS 

MARS 

AVOIDANCE 

PLUTO 

SATURN 

EXE_MISSION 

SATURN 

PLUTO 

GUIDANCE 

VENUS 

SATURN 

MONITOR 

PLUTO 

PLUTO 

NAVIGATION 

SATURN 

VENUS 

SONAR 

MARS 

VENUS 

VEHICLE SYS 

VENUS 

MARS 


The reason that the second placement is more advantageous than the first is that 
tasks which commtmicate with each other were placed on the same transputer. In the first 
placement, the two tasks on each transputer never communicated with each other, only 
with the tasks on the other transputers. In the ring topology, it turns out that whether the 
destination transputer is one hop away or three, the total number of hops needed for 
communication is four. This is due to the fact that all communications need the 
acknowledgement to be completed, so one full trip arotmd the ring is required to deliver 
both the message and the acknowledgement. Therefore, the time of message delivery is 
made faster is only if the destination is on the same transputer as that of the point of 
origin. 

The final results are the different iteration times for one full run, in which each task 
is executed once and all communications occur once. Although these times were not what 
was hoped for, they do provide some interesting results. Table 3 shows the average times 
measured for a single iteration (averaged over one hundred iterations) with the two 
different task allocations. For this measurement, a queue size of fifteen was used. The 
decrease in time per iteration shows expected results. Table 4 shows the times measured 


38 







for the optimal task allocation with varying queue size. As can be easily seen, the optimal 
queue size for this particular communication scheme is quite small. This is due to the fact 
that, at any one time, there are actually only a few messages en route. When the queue 
size is too large, then there is time wasted in checking the empty slots looking for messages 
to deliver. If the queue is too small, then time is wasted when a message is sent aroimd 
the loop again due to the queue being full. The minimum queue size that the software is 
designed to handle is two. 

Table III: Average iteration times versus task allocations 


First Allocation . 332 ms 

Second Allocation . 235 ms 


Table 5 shows the timing results when the time between loop iterations is controlled 
by the task TIMER. The times shown in the table represent the average time for the 
completion of a complete iteration. What is of interest is that when the delay between 
iterations becomes less than the execution time (thus, making the TIMER task the 
controlling factor instead of the iteration completion), then the reported time is 17.5 ms. 
This time does not represent a full iteration, but instead, represents the time for the task 
VEHICLE_SYS to send and receive the acknowledgements for four messages (three of 
which are not local). This represents one third of the communications necessary for a 
single iteration. Intuitively, this would seem to mean that one iteration should be able to 
occur in about 55 ms or less; this brings into question why, instead, it takes over two 
hundred ms. 


39 







Table IV : Average iteration time versus queue size 


Queue Size 


Time (ms) 


25 
20 
15 
10 
5 . 
2 . 


253 

239 

235 

229 

224 

225 


Table V : Measured iteration times when TIMER frequency is controlled 


Delay between Iterations (ms) Time (ms) 

0 . 224 

100 . 223 

200 . 219 

250 . 17.5 

300 . 17.5 


C LIMITS ON PERFORMANCE 

The undesirable aspects of the software layer handling the communications between 
tasks is that it takes up a lot of memory and time. As an example, for the ring architecture 
used for this thesis, let us examine the number of tasks needed for one message to be 
delivered to a non-local destination. It is handled by a Traffic Controller six times (this 
includes the acknowledgement message), a Channel Handler four times, and a Local 
Mailman twice. This adds twelve to the number of tasks that handle a single message for 
delivery to a single destination. If direct routing were used, this could be reduced to eight 
tasks. Reducing this number could be one place for further optimization. 

Taking these calculations a step further and comparing them to the measured results, 
the difference direct routing could make becomes apjparent. In a single iteration, there are 


40 




















thirteen messages sent and acknowledged. This means that, in case of the sub-optimal 
allocation above, there were at least 156 tasks that were executed for message delivery and 
at least 52 links were crossed. In the optimal allocation, there were 116 tasks executed and 
32 links crossed with a resvdting improvement of about 100 ms. If direct routing were 
used, only 84 tasks would be executed, in the optimal case, and 16 links would be crossed. 

It was foimd that the task load on the transputers, when reduced, had only a slight 
effect on the iteration time. Also, the length of the formatted message even when reduced 
by over fifty percent, had no measvirable affect on iteration times. Lastly, a reduction in 
message traffic was accomplished by reducing the frequency of reporting the iteration 
times. This also had negligible effect on the average delivery time. 

Our results indicate that the communication layer only supports an execution rate 
of about four hertz. However, this does not indicate the potential of the approach as being 
limited. In the simulation tasks, no output is allowed to be sent until the proper inputs 
were received. This means that only one iteration can be in progress at a time, and the 
concurrent nature of the transputers is not being used to its fullest extent. If the data-flow 
were pipelined, it will be possible to reach the required frequency easily. 


41 



VI. CONCLUSIONS AND FUTURE WORK 


A. CONCLUSIONS 

The results of this work show that intertask communications can be reliably handled 
by a software layer. The commimication can be made to be location invariant with the 
software architecture presented. Due to the large number of tasks needed to implement 
the communication, there appears to be an excess amount of time spent in message 
delivery. Therefore, any modifications that can reduce the number of tasks that handle a 
message is desirable. The most obvious way to reduce this number is by employing direct 
routing. However, the real limitation is in the intertask conununication which allows only 
one iteration to be in progress at a time. 

Finally, the results show that although the communication may be location invariant, 
the average time for message delivery is not. This means that finding the optimal 
placement of tasks on the transputer network is important. 

B. FUTURE WORK 

1. Higher Level Program 

The next step in the development of the conciurent programming package is 
to create a program that will allocate the tasks to transputers to optimize a suitable 
criterion and then write the mapping routines for the individual transputers. The 
generation of the task calling procedure, used in Local Mailman, on each transputer would 
also be the responsibility of this program. This program should also be able to decide 
upon the common message format and then change all accept and entry statements to 


42 




conform to the standard. This could be accomplished by a filter that changes the 
entry/accept statements to the appropriate Ada procedure calls that use the message 
routing supported by the communications layer. 

The items in this thesis that will have to be rewritten or handled by such a program 
are as follows: 

• The procedure SEND_IT must be generated (This is the procedure that contains all 
the entry calls to the local tasks). 

• The procedure IS_IT_HERE must be rewritten (This is the procedure that is in the 
common package and determines if a task is local on not. If a different topology is 
used, an equivalent algorithm to determine path of message propagation must be 
written). 

• All tasks must be allocated to a set of independent programs. 

• The record MESSAGE_FORM must be written to accommodate all requirements for 
task communication on the network. 

• The task SCREEN mvist be written to handle all desired I/O to the screen. 

• All entry and accept statements must be made compatible with the record 
MESSAGE.FORM. 

2. Difficulties 

One of the conclusions from this thesis is that Ada may not be the best 
environment to implement a tcisk communication layer. Ada was not designed to act as 
a vehicle to implement an operating system; but in this software layer, there are many 
operaFj\g system like functions programmed using it. Also, the lack of dynamic memory 
allocation in Ada nuikes the writing of a queue cumbersome and inefficient. The other 
major drawback of Ada encountered in this thesis was the fact that using a READ or 
WRITE statement was not a legal alternative in a SELECT statement. These factors lead 
to a substantial message fussing overhead. 


43 



The final drawback encountered was the compiler itself. Compilation of the 
programs is excessively time consuming. The creation of joint invoke files would reduce 
total time of compilation when the programs for several transputers are to be compiled. 
As the number of transputers in a network rises, this will become more and more 
desirable. 

3. Parallelism 

Finally, in order to take advantage of a network of processors, there must be 
more than one possible concurrent sequence of events. The smaller the interaction between 
concurrent processes, the higher will be the speed up and the greater will be the use of the 
capabilities of a multiprocessor. This will be accomplished only through careful 
programming practices and experimentation that exploit parallelism. 

The software architecture presented successfully accomplished the goal of making 
tasks on a network location invariant which is vital in making parallel programming easy 
to implement. Another mandatory requirement met was the successful avoidance of the 
severe problem of deadlock. 


44 





APPENDIX A: OCCAM SOURCE CODE 


A. OCCAM HARNESS FILES 

These files are the OCCAM source files for the harness used on the transputers. 
They are all quite sinular with the exception of the main harness used on the root 
transputer which also incorporates the needed system communications. These harnesses 
were derived from the examples given in the Alsys Ada User Manuals. 

1. Main Harness 

For the main harness, unlike the other harnesses, the are two occam files 
combined to make the harness. These two files are the EARTHH.OCC (which represents 
the normal one found on the other transputers) and MERGER.CXIC which enables the host 
functions. The combination of these files make up the main harness. 
a. Main 


~ File: mainh.occ 

tOPTlON "AGNVW" 
flNCLUDE "hostio.inc" 

~ These are the declarations used for the occam channels. ToFiler 

— and FromFiler are the channels used for the system control 

— functions. 

PROC main.hamess (CHAN OF SP FromFiler, ToFiler, 

CHAN OF INT MarsZEarth, EarthZMars, 

[]1NT FreeMemory) 

#USE "hostio.Ub" 

#USE "earthh.t8s" 

#USE "merger.tSs" 

[IICHAN OF ANY Debug: 


45 



121CHAN OF SP FromAda, ToAda: 

CHAN OF BOOL StopDebug, StopMvdtiplexor 
SEQ 

PAR 

— A mviltiplexor to combine the debug and normal output. 
so.multiplexor (FromFiler, ToFiler, FromAda, ToAda, StopMultiplexor) 

— A debug channel merger. 

debug.merger (ToAda[0], FromAda[0j, Debug, StopDebug) 

— A process to invoke the earth program, 
ws IS FreeMemory; 

SEQ 

earth.hamess (FromAdall], ToAda[ll, DebugtO], Mars2Earth, Earth2Mars, ws) 
StopDebug ! FALSE 
StopMultiplexor ! FALSE 

so.exit (FromFiler, ToFiler, sps.success) 


b. Merger 

The following file is part of the main harness and is used for multiplexing 
the control functions over a single channel. It was taken directly from the Alsys Ada User 
Manual and included without change in the programs for this thesis. 


— File: meiger.occ 

#OPTION "AGNVW" 

#INCLUDE "hostio.inc" 

PRCXI debug.merger (CHAN OF SP FromFiler, ToFiler, 
[]CHAN OF ANY Debug, 

CHAN OF BOOL Stop) 

#USE "hostio.lib" 

— A debug channel merger and blocker. 

VAL max.debug IS 20: 

VAL number.of.debug IS SIZE Debug: 


46 






INT line.index: 

[2561BYTE line.buffer: 

BYTE value, r: 

BOOL running, reset, s: 

[max.debuglBOOL mask: 

VAL BYTE linefeed IS 10 (BYTE): 

SEQ 

SEQ i = 0 FOR nuniber.of.debug 
inask[i] := TRUE 
running := TRUE 
reset := FALSE 
line.index := 0 
WHILE running 
PRI ALT 

ALT i = 0 FOR number.of.debug 
mask[i] & Debug[i] ? value 
SEQ 
IF 

value = Iine.feed 
SEQ 

— Send the complete line, 
so.puts (FromFiler, ToFiler, spid.stdout, 
[line.buffer FROM 0 FOR line.index], r) 
line.index := 0 
mask [i] := FALSE 
reset := TRUE 
TRUE 
SEQ 

~ Add character to line. 
line.buffer[line.index] := value 
line.index := line.index + 1 
reset & SKIP 
SEQ 

reset := FALSE 

SEQ i = 0 FOR number.of.debug 
mask[i] := TRUE 
Stop ? s 

running := FALSE 


c. Earth 

This OCCAM source file is nearly identical to that found on the remaining 
transputers. It is here that the (X^CAM channels are specified and loaded into the 
program. 


47 






— File: efurthh.occ 


#OPTION "AGNVW" 

#INCLUDE "hostio.inc" 

PROC earth.hamess (CHAN OF SP FromAda, ToAda, 

CHAN OF ANY Debug, 

CHAN OF INT Mars2Earth, Earth2Mars, 

[JINT FreeMemory) 

#IMPORT "earthh2.tax” 

[IIINT dummy.ws: 
wsl IS FreeMemory: 

[3]INT in.program: 

[3] INT outprogram: 

SEQ 

- Set up vector of pointers to channels. 
in.programlO] := MOSTNEG INT — not used 
LOAD.INPUT.CHANNEL (in.programtH, ToAda) 
LOAD.INPUT.CHANNEL (in.programll], Mars2Earth) 
LOAD.OUTPUT.CHANNEL (out.program[01. Debug) 
LOAD.OUTPUT.CHANNEL (out.program[l], FromAda) 
LOAD.OUTPUT.CHANNEL (out.programUl, Earth2Mars) 

- Invoke the Ada program. 

- Assumes the entry point name has been changed to "earth.program". 
earth.program (wsl, in.program, out.program, dummy .ws) 


This last file is required for each of the transputer due to current limitations 
imposed by the compiler [ALSYS 90]. The purpose of this short file is only to specify the 
entry point for the Ada program. This extra needed procedure is described in the Release 
Notes for the Alsys Ada Compilation System. 


- File: earthh2.occ 


#OPTION "AEV” 

PROC earth.program (HINT wsl, in, out, ws2) 
[lOOOjlNT d: 

SEQ 

SKIP 


48 




2. Loop Harnesses 


The remaining OCCAM source files for the transputers in the main loop are 
very close to the last two files shown in the previous section. 
a. Mars 


— File: marsh.occ 

#0PT10N "AGNVW" 

#1NCLUDE "hostio.inc" 

PROC mars.hamess (CHAN OF INT Mars2Earth, Earth2Mars, Venus2Mars, Mars2Pluto, 
[]1NT FreeMemory) 

#lMPORT "marsh2.tax" 

[1]INT dummy.ws: 
wsl IS FreeMemory: 

I4J1NT in.program: 

[7ilNT outprogram: 

SEQ 

- Set up vector of pointers to channels. 
in.program[0] := MOSTNEG INT — not used 
in.programilj := MOSTNEG INT — standard i/o not used 
LOAD.INPUT.CHANNEL (in.program[2], Earth2Mars) 

LOAD.INPUT.CHANNEL (in.program[3l, Venus2Mars) 
out.program[0] := MOSTNEG INT — standard i/o not used 
out.programil] := MOSTNEG INT — standard i/o not used 
LOAD.OUTPUT.CHANNEL (out.program[2], Mars2Earth) 
out.program[3] := MOSTNEG INT — not used 
out.program[4] := MOSTNEG INT - not used 
out.program[5] := MOSTNEG INT — not used 
LOAD.OUTPUT.CHANNEL (out.program[6], Mars2Pluto) 

- Invoke the Ada program. 

- Assumes the entry point name has been changed to "mars.program". 
mars.program (wsl, in.program, out.program, dummy.ws) 


- File: marsh2.occ 
#OPTION "AEV" 

PRCXI mars.program (HINT wsl, in, out, ws2) 


49 







[lOOOlINT d: 
SEQ 
SKIP 


b. Venus 


— File: venush.occ 

#OPTION "AGNVW" 

#INCLUDE ”hostio.inc" 

PROC venvis.hamess (CHAN OF INT Sattim2Venus, Venus2Mars, 
[]INT FreeMemory) 

#IMPORT "venushltax" 


[IJINT dummy, ws: 
wsl IS FreeMemory: 
[5JINT in.program: 
151INT out.program: 
SEQ 


— Set up vector of pointers to channels. 
in.program[0] := MOSTNEG INT — not used 
in.programil] := MOSTNEG INT — standard i/o not used 
in.programizi := MOSTNEG INT — not used 
in.programl31 := MOSTNEG INT - not used 
LOAD.INPUT.CHANNEL (in.program(4l, SatumZVenus) 
out.program[0] := MOSTNEG INT — standard i/o not used 
out.program[li := MOSTNEG INT — standard i/o not used 
out.program[2] := MOSTNEG INT — not xised 
LOAD.OUTPUT.CHANNEL (out.program[3], VenusZMars) 
out.program[4] := MOSTNEG INT — not used 

~ Invoke the Ada program. 

— Assumes the entry point name has been changed to "venus.program". 
venus.program (wsl, in.program, out.program, dummy.ws) 


- File: venush2.occ 
#OPTION "AEV" 

PROC venus.program ([JINT wsl, in, out, ws2) 
[lOOOlINT d: 

SEQ 

SKIP 


50 



c. Saturn 


— File: satumh.occ 

#OPTION "AGNVW" 

# INCLUDE "hostio.inc" 

PRCXI satun\.hamess (CHAN OF INT Pluto2Satum, Satum2Venus, 

HINT FreeMemory) 

#IMPORT "satumh2.tax" 

[HINT dummy .ws: 

wsl IS FreeMemory: 

[6JINT in.program: 

[51INT out.program: 

SEQ 

— Set up vector of pointers to channels. 
in.program[0] := MOSTNEG INT - not \ised 
in.programtl] := MOSTNEG INT - standard i/o not used 
in.program[2] := MOSTNEG INT - not used 
in.programIS]:« MOSTNEG INT - not used 
in.program[4l :* MOSTNEG INT - not used 
LOAD.INPUT.CHANNEL (in.program[51, Pluto2Satum) 
out.program[0] := MOSTNEG INT ~ standard i/o not used 
out.programill := MOSTNEG INT - standard i/o not used 
out.program[2j:® MOSTNEG INT - not used 
out.program[3j := MOSTNEG INT - not used 
LOAD.OUTPUT.CHANNEL (out.prog;ram[4], SatumZVenus) 

~ Invoke the Ada program. 

— Assumes the entry point name has been changed to "satum.program". 
satum.program (wsl, in.program, out.program, dummy.ws) 


- File: satumh2.occ 
#OPTION AEV" 

PROC satum.program ([JINT wsl, in, out, ws2) 
[lOOOlINT d: 

SEQ 


d. Pluto 


— File: plutoh.occ 

#OPTION "AGNVW” 

#INCLUDE "hostio.iiic" 

PROC pluto.hamess (CHAN OF INT Mars2Pluto, PlutoZSatum, 
niNT FreeMemory) 

#IMPORT "plutoh2.tax*’ 

[HINT dununy.ws: 
wsl IS FreeMemory: 

I7]INT in.program; 

[7]INT outprogram; 

SEQ 

- Set up vector of pointers to channels. 
in.program[0] := MOSTNEG INT — not used 
in.programil] := MOSTNEG INT — standard i/o not used 
in.program[2] := MOSTNEG INT — not used 
in.program[3] := MOSTNEG INT — not used 
in.program[4] := MOSTNEG INT — not used 
in.program[5] := MOSTNEG INT — not used 
LOAD.INPUT.CHANNEL (in.program[6I, Mars2PIuto) 
out.program[Ol:« MOSTNEG INT — standard i/o not used 
out.programlH := MOSTNEG INT — standard i/o not used 
out.program[2] := MOSTNEG INT — not used 
out.program[3] := MOSTNEG INT - not used 
out.program[4] := MOSTNEG INT — not used 
LOAD.OUTPUT.CHANNEL (out.program[5], Pluto2Satum) 
out.program[6] := MOSTNEG INT — not used 

- Invoke the Ada program. 

- Assumes the entry point name has been changed to "pluto.program". 
pluto.program (wsl, in.program, outprogram, dummy.ws) 


- File: plutoh2.occ 
#OPTION ”AEV" 

PROC pluto.program ([]INT wsl, in, out, ws2) 
[lOOOlINTd: 

SEQ 

SKIP 


52 



APPENDIX B: ADA SOURCE CODE 


These files eure the Ada source code for the simulation tasks used for this thesis. The 
file COMMON contains the queue size in the variable MAX_STORAGE. The Tasks QUE 
and WAITING are identical in all programs. The task INOUT is the same in most of the 
programs except for the outgoing channel name, this channel name could actually be made 
to be some generic name used in aU programs. The one program INOUT is different is in 
the Mars program since it has two possible outgoing channels. 


A. COMMON.ADA 


— File: common.ada 

— This is a common package included into all programs. Data types 

— and Channel I/O are declared here. The location procedure is 

— also included in this package. 

with CHANNELS; 
with CALENDAR; 

package COMMON is 

— Declarations of the statistics of the network and the common 

— data types that will be used in the communication scheme. 

NUM_PROGS : constant INTEGER := 5 ; 

NUM_PATHS : constant INTEGER := 13; 

NUM.TASKS : constant INTEGER := 19; 

NUM_ENTRYS : constant INTEGER ;= 19; 

MAX_STORAGE : constant INTEGER := 5; 


53 



type INT 16 is range -2**15 .. 2**15-1; 
type TASKS is range l..NUM_TASKS ; 
type ENTRYS is range l..NUM_ENTRYS ; 

type PROG_ARRAY is array (1..NUM_PRCX:JS) of INTEGER; 
type PATH_ARRAY is array (l..NUM_PATHS) of INTEGER; 

type PRCXJRAMS is (EARTH, MARS, VENUS, SATURN, PLUTO) 

— These constants defined for passing task names in coded form 

— mside the message. Enumeration types were used successfully 

— but increase the size of the message. This was later foimd not 

— to be very important. 


SHUTDOWN 

HOST_TASK 

TASK_SCREEN 

EARTH_MAIN 

MARS.MAIN 

VENUS.MAIN 

SATURN.MAIN 

PLUTO_MAIN 


: constant TASKS := 1; 

: constant TASKS := 2; 

: constant TASKS ;= 3; 

: constant TASKS := 4 ; 

: constant TASKS := 5 ; 

: constant TASKS := 6 ; 

; constant TASKS := 7; 
: constant TASKS := 8; 


TASK_AUTO_PILOT : constant TASKS := 9 ; 
TASK.AVOIDANCE : constant TASKS := 10; 
TASK.EXE MISSION : constant TASKS := 11; 
TASK_GUIDANCE : constant TASKS := 12; 
TASK.MONITOR : constant TASKS := 13; 
TASK NAVIGATION : constant TASKS := 14; 
TASK.SONAR : constant TASKS := 15; 
TASK_'nMER : constant TASKS := 16; 
TASK_VEHICLE_SYS : constant TASKS := 17; 
LOOP_TASK : constant TASKS := 18; 
NO.TASK : constant TASKS := 19; 


— As for the task names, the entry calls below are also assigned 

— codes for easy passing. Again an enumeration type can be used 

— here. 


OUTPUT : constant ENTRYS := 1 ; 

UPDATE.SONAR : constant ENTRYS := 2 ; 
VS_ORDERS : constant ENTRYS := 3 ; 
SYS.STATUS : constant ENTRYS := 4 ; 
AP_ORDERS : constant ENTRYS := 5 ; 
UPDATE NAV : constant ENTRYS := 6 ; 
UPDATE.ORDERS : constant ENTRYS := 7 ; 
AVOID_REC : constant ENTRYS := 8 ; 
SONAR.OBSTACLE : constant ENTRYS := 9; 


54 





OBJECT ALERT : constant ENTRYS ;= 10; 

EXE.UPDATE : constant ENTRYS ;= 11; 

OB.AVOID : constant ENTRYS := 12; 

MONITOR.UPDATE ; constant ENTRYS := 13; 

TO.MONITOR : constant ENTRYS := 14; 

PILOT.UPDATE : constant ENTRYS := 15; 

ACKNOWLEDGE : constant ENTRYS := 16; 

NO_ENT : constant ENTRYS := 17; 

RETURNING : constant ENTRYS := 18; 

TEST_TIME : constant ENTRYS := 19; 

type MESSAGE_FORM is 
record 

ORIGIN : TASKS := NO_TASK; 

DESTIN : TASKS := NO_TASK; 

ENT.CALL : ENTRYS := NO ENT; 

TIME_STAMP : DURATION := 0.0; 

CODE_l ; INT_16 := 0; 

CODE_2 : INT_16 := 0; 

MESSAGE_CODE : INT_16 ;= 0; 

PROG : PROG_ARRAY := (others =>0); 

PATH : PATH.ARRAY ;= (others =>0); 
end record; 

— These are generic messages used in the program, shutdown is used 

— to terminate all programs. 

SHUTDOWN_MESSAGE: MESSAGE.FORM := (SHUTDOWN, SHUTDOWN, NO_ENT, 
0.0, 0, 0, 0, (others => 0), (others => 9)); 

ACK_MESSAGE : MESSAGE.FORM := (NO.TASK, NO.TASK, 

ACKNOWLEDGE, 0.0, 0, 0, 0, (others -> 0), (others => 7)); 

HOST : constant PROGRAMS := EARTH; 

~ These are defined delays used during the testing of the program. 

— These are arbitrarily picked. The value of INOUTJNT and 

— QUE_INT are the only values that appear to affect message 

— delivery time. The given value seemed to provide the optimum 

— times, but bears further investigation. 

READ.INT : constant DURATION := 5.0; 

SENDJNT : constant DURATION := 0.3; 

INOUTJNT : constant DURATION := 0.003; 

QUE_INT : constant DURATION := 0.003; 

AVOIDANCEJNT : constant DURATION := 0.08; 

PILOT_INT : constant DURATION ;= 0.04; 

SONAR JNT : constant DURATION := 0.02; 


55 






VEHICLEJNT : constant DURATION := 0.08; 

MONITOR_INT : constant DURATION := 0.03; 

EXE.INT : constant DURATION := 0.06; 

GUIDANCE.INT : constant DURATION := 0.07; 

NAVIGATIONJNT : constant DURATION := 0.05; 

— Instantiations of the generic channel i/o package. 

package MESSAGEJO is new CHANNELS.CHANNEL_IO (MESSAGE_FORM) 

function IF_ITS_HERE (FROM.PROGRAM : in PROGRAMS; TO_TASK : in 
TASKS) 

return BOOLEAN; 
end COMMON; 


package body COMMON is 

function IF ITS_HERE (FROM_PROGRAM : in PROGRAMS; TO_TASK : in 
TASi«) 

return BOOLEAN is 


ANSWER : BOOLEAN := FALSE; 
begin 

case FROM_PROGRAM is 

when EARTH => 

if (TO.TASK = HOST.TASK) or 
(TO_TASK = TASK.SCREEN) then ANSWER := TRUE; 

end if; 

when MARS => 

if (TO_TASK = TASK_AUTO PILOT) or 
aO.TASK = TASK_VEHIC:lE_SVS) or 
(TO_TASK = TASK.TIMER) then ANSWER := TRUE; 

end if; 

when VENUS => 

if (TO_TASK = TASK_NAVIGATION) or 
(TO_TASK = TASK_SONAR) then ANSWER := TRUE; 

end if; 

when SATURN => 

if (TO.TASK = TASK.AVOIDANCE) or 
(TO.TASK = TASK_GUIDANCE) then ANSWER := TRUE; 

end if; 

when PLUTO => 

if (TO.TASK = LOOP_TASK) or 
aO.TASK = TASK_EXE_MISSION) or 


56 





then ANSWER := TRUE; 


(TO.TASK = TASK_MONITOR) 
end if; 

when others => 

ANSWER ;= FALSE; 
end case; 

return ANSWER; 

end IF_ITS_HERE; 

end COMMON; 


B. PRINTOUT.ADA 

This package was used simply for formatted output when it was desired to print out 
the entire message. This Tie was only included in the EARTH program. 


— File: printout.ada 

with COMMON; 
with TEXT.IO; 
package PRINTOUT is 

use COMMON; 

package PRINT.TASK is new TEXTJO.INTEGERJO (TASKS) ; 
package PRINT_PRCX3 is new TEXT_I0.ENUMERAT10N_10 (PROGRAMS); 
package INT_IO is new TEXT_10.1NTEGERJ0(INT_16) ; 

procedure PRINT.MESSAGE (MESSAGE : in MESSAGE_FORM); 

end PRINTOUT; 


package body PRINTOUT is 

procedure PRINT.MESSAGE (MESSAGE : in MESSAGE_FORM) is 

TO.TASK NAME : TASKS ; 

FROM_TASK_NAME : TASKS ; 

I : INTEGER; 


57 





begin 


FROM_TASK_NAME ;= MESSAGE.ORIGIN ; 

TEXT_IO.NEW_LINE; 

TEXT_IO.PUT_LINE 

TEXT_IO.PUT_LINE 

("• Message Report *"); 

TEXT_IO.PUT_LINE 

*»y 

TEXTJO.PUT ("• From : 
PRINT_TASK.PUT (FROM_TASK_NAME,30); 
TEXTJO.PUT LINE (" *"); 

TEXTJO.PUT_LINE 

("* Path Array: *"); 

TEXTJO.PUT ("• "); 


for I in l..NUM_PATHS loop 
TEXTJO.PUT (" "); 

INT_IO.PUT (INT_16 (MESSAGE.PATH(I))^); 
end loop; 

TEXTJO.PUT.LINE (" *"); 

TEXTJO.PUT.LINE 

("* Program Array: *”); 

TEXTJO.PUT ("* "); 

for I in l..NUM_PROGS loop 
TEXTJO.PUT (" "); 

INT.IO.PUT (INTJ6 (MESSAGE.PROG(I))3) 
TEXTJO.PUT (" "); 
end loop; 

TEXTJO.PUT_LINE (" *"); 

TEXTJO.PUT ("• CODE_l : ”); 

INT.IO.PUT (MESSAGE.CODE_l,3); 
TEXTJO.PUT (" CODE_2 : "); 

INT.IO.PUT (MESSAGE.CODE_2,3); 
TEXTJO.PUT (" Message Code : "); 
INT_IO.PUT (MESSAGE.MESSAGE.CODE); 
TEXTJO.PUT_LINE (" •"); 

TEXTJO.PUT_LINE 


end PRINT.MESSAGE; 
end PRINTOUT; 


58 



C. EARTHADA 


- File: earth.ada 

- Author: Clay Richmond 


- Tasks included in this program: Entry calls 

QUE TO_QUE 

SCREEN OUTPUT 


with COMMON; 
with PRINTOUT; 
with TEXT_10; 
with CHANNELS; 
with CALENDAR; 

procedure EARTH is 

use COMMON; 
use PRINTOUT; 
use CALENDAR; 

package TIME lO is new TEXT lO.FIXEDJO (DURATION); 
package FLTJO is new TEXTJO.FLOATJO (FLOAT); 

IN_MESSAGE : MESSAGE.FORM ; 

MAIN_TALK : MESSAGE_FORM ; 

LOCATION : constant PROGRAMS := EARTH; 

TIME_OUT : TIME; 

QUIT_T1ME : TIME; 

ABORTED : BOOLEAN; 

FAILED : INT_16 := 0; 

MESS_COUNT : INT 16 := 0; 

QUIT.INT : DURAf ION := 50.0; 

task QUE is 

entry TO_QUE (QUE. MESSAGE : in MESSAGE.FORM) ; 
end; 

task SCREEN is 

entry OUTPUT (SCREEN_MESSAGE : in MESSAGE_FORM); 
end; 


InFromMars : CHANNELS.CHANNEL.REF := CHANNELS.IN_PARAMETERS (2); 


59 




OutToMars : CHANNELS.CHANNEL.REF ;= CHANNELS.OUT_PARAMETERS(2); 
task body QUE is 


SENT.MESSAGE : BOOLEAN := FALSE; 

SENT.ACK : BOOLEAN := FALSE; 

ALL_FULL : BOOLEAN := FALSE; 

FULL : constant BOOLEAN := TRUE; 

EMPTY : constant BOOLEAN := FALSE; 

NUMBER : INTEGER := 0; 

MESSAGES_IN_MAIL : INTEGER := 0; 

SLOT : array(0 .. (MAX_STORAGE-l)) of BOOLEAN := 

(othere => FALSE); 

STORAGE : arrayfO .. (MAX_STORAGE-l)) of 

MESSAGE_FORM; 


TEMP_MESSAGE : MESSAGE.FORM; 
TALK ; MESSAGE_FORM; 


procedure SEND_IT (MESSAGE : in MESSAGE.FORM; 
ACK : out BOOLEAN; 

MESS : out BOOLEAN) is 


MESSAGE SENT : BOOLEAN := FALSE; 

ACK.SENT : BOOLEAN := FALSE; 

begin 

select 

SCREEN.OUTPUT (STORAGE (NUMBER)); 
MESSAGE.SENT := TRUE; 
or 

delay 0.01; 
end select; 

ACK :=ACK_SENT; 

MESS := MESSAGE_SENT; 
return; 

end SEND_n'; 
begin 

MAIN: loop 
select 

accept TO.QUE (QUE_MESSAGE : in MESSAGE.FORM) do 
TEMP_MESSAGE := QUE_MESSAGE; 
end TO_QUE; 

STORAGE (NUMBER) ;= TEMP.MESSAGE; 


60 






MESSAGESJN MAIL := MESSAGES_IN_MAIL + 1; 

SLOT (NUMBER) := FULL; 

SEND: loop 

if ALL_FULL = FALSE then 
select 

accept TO_QUE (QUE_MESSAGE : in MESSAGE_FORM) 
do 

TEMP.MESSAGE := QUE.MESSAGE; 
end TO.QUE; 

if MESSAGES_IN_MAIL < MAX_STORAGE then 
STORE: loop 

if SLOT (NUMBER) = EMPTY then 
STORAGE (NUMBER) := TEMP_MESSAGE; 
MESSAGES_IN_MAIL:=MESSAGES_IN_MAIL+1; 
SLOT (NUMBER) := FULL; 
exit; 
end if; 

Add 1 to NUMBER so that next mail slot can be checked. 

NUMBER := (NUMBER + 1) MOD MAX_STORAGE; 
end loop STORE; 

Add 1 to NUMBER so that last in will not be first out if there 
are other messages in the queue. 

NUMBER := (NUMBER + 1) MOD MAX_STORAGE; 

This is a flag that says that are incoming messages not yet 
stored in the queue, and no others should be read until it is. 

else 

ALL_FULL := TRUE; 
end if; 
or 

delay 0.0; 
end select; 
end if; 

Priority is given to any messages waiting to be mailed, so 
another ACCEPT statement is needed before attempting to deliver 
a message. 

if SLOT (NUMBER) = FULL then 
SEND.IT (STORAGE (NUMBER), SENT_ACK, 


end if; 


SENT_MESSAGE); 


if SENT.MESSAGE then 
SENT_MESSAGE := FALSE; 

SLOT (NUMBER) := EMPTY; 

MESSAGES_IN_MAIL := MESSAGES_IN_MAIL - 1; 
if ALL.FULL then 

STORAGE (NUMBER) := TEMP_MESSAGE; 

SLOT (NUMBER) := FULL; 

MESSAGES_IN_MAIL := MESSAGES_IN_MAIL + 1; 
ALL.FULL := FALSE; 
end if; 
end if; 


NUMBER ;= (NUMBER + 1) MOD MAX.STORAGE; 


To save processor time the loop is exited when there are no 
pending mail deliveries. 


exit when MESSAGES_1N_MAIL = 0; 
end loop SEND; 
or 

terminate; 
end select; 
end loop MAIN; 

end QUE; 

task body SCREEN is 

OUT2SCREEN : MESSAGE_FORM; 

LOCALS : array (TASKS) of 1NT_16 := (others => 0); 

COUNT : INTEGER := 0; 

N : INTEGER ;= 0; 

AVE_TIME : FLOAT; 

START_STAMP: CALENDAR.TIME; 

TIMER : DURATION := 0.0; 

TOT_TIME : DURATION := 0.0; 

OUT.TIME : DURATION := 0.0; 

begin 

MAIN: loop 

accept OUTPUT (SCREEN_MESSAGE : in MESSAGE.FORM) do 
OUT2SCREEN := SCREEN.MESSAGE; 
end OUTPUT; 


62 





This case statement lists all the message codes with the 
associated messages. This of course can be expanded to include 
any necessary correspondence with the screen. 

case OUT2SCREEN.MESSAGE_CODE is 
when 11 => 

TEXT_10.PUT_L1NE 

("Main Earth program finished."); 
PRINT_MESSAGE(OUT2SCREEN); 
exit; 

when 20 => 

LCXZALS (OUT2SCREEN.OR1G1N) := 

LCXZALS (OUT2SCREEN.OR1G1N) + 1; 

TOT_TlME ;= TOT_TlME + OUT2SCREEN.TlME_STAMP; 
N := N + 1; 
when 21 => 

LOCALS (OUT2SCREEN.OR1G1N) := 

LOCALS (OUT2SCREEN.ORIG1N) + 1; 
when 30 => 

START_STAMP := CLOCK; 
when 31 => 

TIMER := CLOCK - START.STAMP; 

OUT.TIME := OUT2SCREEN.TIME_STAMP; 
when 99 => 

TEXT_IO.PUT_LINE ("Shutdown Received."); 
when others => 

TEXT_IO.PUT_LINE ("Bad MESSAGE.CODE."); 
PRINT_MESSAGE(OUT2SCREEN); 
end case; 
end loop MAIN; 

TEXTJO.PUT ("EARTH_MAIN = "); 

INT_IO.PUT (LCX:ALS(EARTH_MAIN)); 

TEXT_IO.NEW_LINE; 

TEXTJO.PUT ("TASK_VEHICLE_SYS = "); 

INT_I0.PUT(L(X:ALS(TASK_VEHICLE_SYS)); 

TEXTJO.NEW_LINE; 

TEXTJO.PUT ("Total time from SCREEN was : "); 

TIME_IO.PUT (TIMER); 

TEXTJO.NEW_LINE; 

TEXTJO.PUT ('Total time from VEHICLE_SYS was :"); 
TIME_IO.PUT (OUT.TIME); 

TEXTJO.NEW LINE; 


63 





TEXTJO.PUT ("Ave Time calculated from VEHICLE SYS was :"); 
AVE_TIME ;= FLOAT(TOT_TIME) / FLOAT(N); 

FLTJO.PUT (AVE.TIME); 

TEXT_IO.NEW_LINE; 

end SCREEN; 

begin 

QUrr.TIME := CLCXZK + QUITJNT; 

MAIN_TALK.DESTIN := TASK_SCREEN; 

MAlN_TALK.ORIGIN ;= EARTH_MAIN; 

MAIN_TALK.MESSAGE_CODE := 21; 

QUE.TO_QUE (MAIN_TALK); 

loop 

TIME_OUT := CLOCK + READ.INT; 

MESSAGE_IO.READ_OR_FAIL (InFromMars, IN.MESSAGE, TIME_OUT, 
ABORTED); 

if ABORTED then 
FAILED := FAILED + 1; 
else 

MESS_COUNT := MESS.COUNT + 1; 

IN_MESSAGE.PROG(l) := IN.MESSAGE.PROGd) + 1; 

QUETO.QUE (IN.MESSAGE); 
end if; 


exit when CLOCK > QUIT_TIME; 
end loop; 


delay 0.5; 


MAIN_TALK := IN.MESSAGE; 
MAIN_TALK.DESTIN := TASK SCREEN; 
MAIN_TALK.MESSAGE_CODE := fl; 
MAIN_TALK.CODE_l := FAILED; 
MAIN_TALK.CODE_2 := MESS.COUNT; 
QUE.TO_QUE (MAIN.TALK); 


end EARTH; 


64 




D. MARS.ADA 


— File: mars.ada 

- Author: Clay Richmond 


- Tasks included in this program: Entry calls 

INOUT 
QUE 

AUTO.PILOT 
TIMER 

VEHICLE_SVS 


with COMMON; 
with CHANNELS; 
with CALENDAR; 

procedure MARS is 

use COMMON; 
use CALENDAR; 

IN_MESSAGE : MESSAGE.FORM; 

LOCATION : constant PROGRAMS := MARS; 

STOPPER : constant INTEGER := 100; 

task INOUT is 

entry INCOMING (INOUT_MESSAGE : in MESSAGE.FORM); 
entry SEND (INOUT_MESSAGE : in MESSAGE_FORM); 
end; 

task WAITING is 

entry LIMBO (WAIT_MESSAGE : in MESSAGE_FORM); 
end; 


INCOMING, SEND 
TO_QUE 

AP_ORDERS, PILOT_UPDATE, ACK 
TEST.TIME, ACK 

VS_ORDERS,GO, FIN, ACK 


task QUE is 

entry TO_QUE (QUE_MESSAGE : in MESSAGE_FORM); 
end; 

task AUTO_PILOT is 

entry AP.ORDERS (PILOT_MESSAGE : in MESSAGE_FORM); 
entry PILOT.UPDATE (PILOT_MESSAGE : in MESSAGE.FORM); 
entry ACK; 
end; 


65 



task TIMER is 
entry TEST_TIME; 
entry ACK; 
end; 

task VEHICLE.SYS is 

entry VS.ORDERS (VS.MESSAGE : in MESSAGE.FORM) ; 
entry GO ; 

entry FIN ; 

entry ACK ; 

end; 

OutToEarth : CHANNELS.CHANNEL_REF:= CHANNELSOUT_PARAMETERS(2); 
InFromEarth : CHANNELS.CHANNEL_REF:= CHANNELS.IN.PARAMETERS (2); 
InFromVenus : CHANNELS.CHANNEL_REF;= CHANNELS.IN_PARAMETERS (3); 
OutToPluto : CHANNELS.CHANNEL_REF:= CHANNELS.OUT_PARAMETERS(6); 

procedure SEND_IT (MESSAGE : in MESSAGE.FORM; 

ACK: out BOOLEAN; 

MESS : out BOOLEAN) is 

MESSAGE_SENT : BOOLEAN := FALSE; 

ACK.SENT : BOOLEAN := FALSE; 

begin 

case MESSAGE.DESTIN is 
when TASK_AUTO_PILOT => 
case MESSAGE.ENT_CALL is 
when AP_ORDERS => 
select 

AUTO_PILOTAP_ORDERS (MESSAGE); 

MESSAGE_SENT := TRUE; 
or 

delay 0.0; 
end select; 

when PILOT_UPDATE => 
select 

AUTO_PILOT.PILOT_UPDATE (MESSAGE); 

MESSAGE.SENT := TRUE; 
or 

delay 0.0; 
end select; 

when ACKNOWLEDGE => 
select 

AUTO_PILOT.ACK; 

ACK_SENT ;= TRUE; 
or 


66 




delay 0.0; 
end select; 

when others => null; — Not a valid call 
end case; 

when TASK_T1MER => 
case MESSAGE.ENT_CALL is 

when TEST_T1ME => 
select 

T1MER.TEST_T1ME; 

MESSAGE_SENT := TRUE; 
or 

delay 0.0; 
end select; 

when ACKNOWLEDGE => 
select 

TIMER.ACK; 

ACK_SENT := TRUE; 
or 

delay 0.0; 
end select; 

when others => null; — Not a valid call 
end case; 

when TASK_VEH1CLE_SYS => 
case MESSAGE.ENT.CALL is 

when VS.ORDERS => 
select 

VEHICLE SYS.VS_ORDERS (MESSAGE); 

MESSAGE.SENT := TRUE; 
or 

delay 0.0; 
end select; 

when ACKNOWLEDGE => 
select 

VEH1CLE_SYS.ACK; 

ACK.SENT := TRUE; 
or 

delay 0.0; 
end select; 

when others => null; — Not a valid call 
end case; 

when others => null; — not a valid task 
end case; 

ACK :=ACK_SENT; 

MESS := MESSAGE.SENT; 
return; 

end SEND_1T; 


67 


task body INOUT is 

COUNT : INTEGER := 0; 

HERE : BOOLEAN; 

ON_HOST : BOOLEAN; 

ABORTED : BOOLEAN; 

STORE_MESSAGE : MESSAGE.FORM; 
TIME_OUT : CALENDAR.TIME; 

begin 


loop 

select 

accept INCOMING (INOUT.MESSAGE : in MESSAGE_FORM) do 
STORE.MESSAGE := INOUT_MESSAGE; 
end INCOMING; 
or 

accept SEND (INOUT_MESSAGE : in MESSAGE_FORM) do 
STORE.MESSAGE := INOUT_MESSAGE; 
end SEND; 
or 

terminate; 
end select; 

ON_HOST := IF_IT5 HERE (HOST, STORE.MESSAGE.DESTIN); 
HERE := IF_ITS_HER£ (LOCATION, STORE_MESSAGE.DESTIN); 

TIME.OUT := CLOCK + INOUT.INT; 

if ON.HOST then 

MESSAGE_IO.WRITE_OR_FAIL (OutToEarth, STORE_MESSAGE, 
TIME_OUT, ABORTED); 
if ABORTED then 

MESSAGE_IO.WRITE (OutToPIuto, STORE_MESSAGE); 
end if; 

elsif HERE then 
select 

QUE.TO_QUE (STORE_MESSAGE); 
or 

delay INOUT_INT; 
end select; 
else 

MESSAGE_IO.WRITE (OutToPIuto, STORE.MESSAGE); 
end if; 


end loop; 
end INOUT; 


68 




task body WAITING is 

MAX.STORAGE : INTEGER := 5; 

BOTTOM : INTEGER := 0; 

TOP : INTEGER := 0; 

LIST : array (0..(MAX_STORAGE-1)) of MESSAGE_FORM; 

begin 

loop 

select 

accept LIMBO (WAIT_MESSAGE : in MESSAGE_FORM) do 
LIST (TOP) := WAIT_MESSAGE; 
end LIMBO; 

TOP := (TOP + 1) MOD MAX_STORAGE; 


loop 

select 

accept LIMBO (WAIT_MESSAGE : in MESSAGE_FORM) do 
LIST aOP) := WAIT_MESSAGE; 
end LIMBO; 

TOP := (TOP + 1) MOD MAX_STORAGE; 
else 
select 

INOUT.SEND (LIST (BOTTOM)); 

BOTTOM := (BOTTOM + 1) MOD MAX.STORAGE; 
exit when BOTTOM = TOP; 
or 

delay 0.02; 
end select; 
end select; 
end loop; 
or 

terminate; 
end select; 
end loop; 
end WAITING; 


task body QUE is 


SENT.MESSAGE : BOOLEAN := FALSE; 

SENT_ACK : BOOLEAN := FALSE; 

ALL_FULL : BOOLEAN := FALSE; 

FULL : constant BOOLEAN := TRUE; 

EMPTY : constant BOOLEAN := FALSE; 

NUMBER : INTEGER := 0; 

MESSAGES_IN_MAIL : INTEGER := 0; 

SLOT : array(0 .. (MAX_STORAGE-l)) of BOOLEAN := 


69 







(others => FALSE); 

STORAGE : array(0 .. (MAX_STORAGE-l)) of 

MESSAGE_FORM; 

TEMP_MESSAGE : MESSAGE_FORM; 
begin 

MAIN: loop 
select 

accept TO_QUE (QUE.MESSAGE : in MESSAGE_FORM) do 
TEMP_MESSAGE := QUE.MESSAGE; 
end TO_QUE; 

STORAGE (NUMBER) := TEMP.MESSAGE; 
MESSAGES_IN_MAIL := MESSAGES_IN_MAIL + 1; 

SLOT (NUMBER) := FULL; 

Priority is given to any messages waiting to be mailed, so 
another ACCEPT statement is needed before attempting to deliver 
a message. 

SEND: loop 

if ALL_FULL = FALSE then 
select 

accept TO.QUE (QUE_MESSAGE : in MESSAGE.FORM) 
do 

TEMP MESSAGE := QUE_MESSAGE; 
end ToJqUE; 

if MESSAGESJN_MAIL < MAX.STORAGE then 
STORE: loop 

if SLOT (NUMBER) = EMPTY then 
STORAGE (NUMBER) := TEMP_MESSAGE; 
MESSAGES.IN MAIL:=MESSAGES_IN_MAIL+1; 
SLOT (NUMBER) := FULL; 
exit; 
end if; 

Add 1 to NUMBER so that next mail slot can be checked. 

NUMBER := (NUMBER + 1) MOD MAX_STORAGE; 
end loop STORE; 

Add 1 to NUMBER so that in the SEND loop the last mail slot 
filled will not be the first to be checked for sending. 

NUMBER := (NUMBER + 1) MOD MAX_STORAGE; 


70 





This is a flag that says that are incoming messages not yet 
stored in the queue, and no others should be read until it is. 

else 

ALL_FULL := TRUE; 
end if; 
or 

delay 0.0; 
end select; 
end if; 


if SLOT (NUMBER) = FULL then 
SEND_IT (STORAGE (NUMBER), SENT_ACK, 
SENT.MESSAGE); 


end if; 


if SENT_MESSAGE then 
SENT_MESSAGE := FALSE; 

ACK_MESSAGE.DESTIN := STORAGE (NUMBER).ORIGIN; 
ACK_MESSAGE.ORIGIN := STORAGE (NUMBER).DESTIN; 
SLOT (NUMBER) := EMPTY; 

MESSAGES_IN_MAIL ;= MESSAGES_IN_MA1L - 1; 
if ALL.FULL then 

STORAGE (NUMBER) := TEMP.MESSAGE: 

SLOT (NUMBER) := FULL; 

MESSAGES_IN_MAIL := MESSAGES.IN MAIL + 1; 
ALL.FULL ;= FALSE; 
end if; 


Now the acknowledgement message is sent, but if INOUT is trying 
to mail a message deauiock will occur. So again incoming 
messages is given priority. 


SEND_ACK; loop 
if ALL_FULL = FALSE then 
select 

accept TO_QUE (QUE_MESSAGE : in 
MESSAGE_FORM) do 

TEMP_MESSAGE := QUE.MESSAGE; 
end TO_QUE; 

if MESSAGES_IN_MAIL < MAX_STORAGE then 
NEXT_ST0RE: loop 
if SLOT (NUMBER) = EMPTY then 
STORAGE (NUMBER):=TEMP_MESSAGE; 
MESSAGES_IN_MAIL:= 

MESSAGES_IN_MAIL + 1; 


71 






SLOT (NUMBER) := FULL; 
exit; 
end if; 

NUMBER ;= 

(NUMBER + 1) MOD MAX_STORAGE; 
end loop NEXT_STORE; 

NUMBER := 

(NUMBER + 1) MOD MAX_STORAGE; 

else 

ALL_FULL := TRUE; 
end if; 
or 

delay 0.0; 
end select; 
end if; 

select 

INOUT.SEND (ACK_MESSAGE); 
exit; 
or 

delay QUEJNT; 
end select; 

end loop SEND_ACK; 
elsif SENT.ACK then 
SENT.ACK := FALSE; 

MESSAGES IN_MAIL := MESSAGES_1N_MA1L - 1 
SLOT (NUMBER) := EMPTY; 

if ALL FULL then 

SToL\GE (NUMBER) := TEMP_MESSAGE; 

SLOT (NUMBER) := FULL; 

MESSAGES_1N_MA1L := MESSAGES_1N_MA1L + 1; 
ALL_FULL := FALSE; 
end if; 
end if; 

If a message was not sent and neither was an acknowledgement, 
then the receiving task was not ready. So 1 is added to NUMBER 
and the next message found will get its chance at being 
delivered. 

NUMBER := (NUMBER + 1) MOD MAX.STORAGE; 

To save processor time the loop is exited when there are no 
pending mail deliveries. 

exit when MESSAGES_IN_MAIL = 0; 
end loop SEND; 


72 





or 

terminate; 
end select; 
end loop MAIN; 

end QUE; 

task body AUTO_PILOT is 

-- This task receives its input from GUIDANCE, it then waits for an 
-- update from VEHICLE_SYS before then sending its signals back to 
-- VEHICLE_SVS. For the purposes of this dummy task, no decisions 
— are made here. 

IN_TASK, NEW_SYS : MESSAGE.FORM; 

begin 

loop 

select 

accept PILOT_UPDATE (PILOT.MESSAGE : in MESSAGE_FORM) 
NEW_SYS ;= PILOT.MESSAGE; 
end PILOT.UPDATE; 

accept AP.ORDERS (PILOT MESSAGE : in MESSAGE.FORM) do 
IN_TASK := PILOT MESSAGE; 
end AP_ORDERS; 

delay PILOT.INT; 

IN_TASK.ORIGIN := TASK_AUTO_PILOT; 

IN_TASK.DESTIN := TASK_VEHICLE_SYS; 
IN_TASK.ENT_CALL := VS_ORDERS; 

INOUT.SEND (IN.TASK); 

accept ACK; 
or 

terminate; 
end select; 
end loop; 

end AUTO.PILOT; 

task body TIMER is 

COUNT : INTEGER ;= 0 ; 

TALK : MESSAGE_FORM; 


do 


73 




begin 

delay 0.3; 

- this delay allows initialization to complete. 

loop 

VEHiCLE_SYS.GO; 

COUNT := COUNT + 1; 
delay 0.25; 

- this is the delay that controls frequency. 

exit when COUNT = STOPPER; 
end loop; 

delay 3.0; 

- this delay enables all tasks to come to completion 

- Shutdown message is sent to the last program in the loop 

-- and then returns to EARTH. On its way to earth all programs 

- terminate as it passes. 

TALK := SHUTDOWN_MESSAGE; 

TALK.DESTIN := LOOP.TASK; 

TALK.MESSAGE_CODE := 99; 

INOUT.SEND (TALK); 
end TIMER; 

task body VEHICLE.SYS is 

~ This task receives from AUTO_PILOT and interfaces with the 
~ external vehicle systems which are not shown in this duntuny task. 

- Output is sent to SONAR and NAVIGATION. The first four messages 

- sent is the initialization. It was found that arranging the 

~ placement of the accept statements for the acknowledgment 

- message had an impact on timing. 

IN.TASK, TALK : MESSAGE.FORM; 

NEXT_TIME : CALENDAR.TIME := CLOCK + VEHICLE_INT; 
PRE.STAMP : CALENDAR.TIME; 

START.STAMP : CALENDAR.TIME; 

TIMER : DURATION := 0.0; 

FINAL : DURATION ;= 0.0; 

COUNT : INTEGER := 0; 

begin 

PRE_STAMP := CLOCK; 


74 



All messages in this task sent to SCREEN were for data 
collection purposes only. 


TALK.OR1GIN ;= TASK_VEH1CLE_SYS; 

TALK.DESTIN := TASK_SCREEN ; 

TALK.ENT_CALL ;= OUTPUT ; 

TALK.MESSAGE_CODE := 30 ; 

INOUT.SEND (TALK); 

IN_TASK.ORIGIN := TASK_VEHICLE_SYS; 

IN_TASK.DESTIN := TASK.NAVIGATION; 

IN_TASK.ENT_CALL := SYS.STATUS ; 

INOUT.SEND (IN.TASK); 

IN_TASK.ORIGIN := TASK_VEH1CLE_SYS; 

IN_TASK.DESTIN := TASK_SONAR ; 

IN_TASK.ENT_CALL := UPDATE_SONAR ; 

INOUT.SEND (IN.TASK); 

IN_TASK.ORIGIN := TASK_VEHICLE_SYS; 

IN_TASK.DESTIN := TASK.MONITOR ; 

IN_TASK.ENT_CALL := TO.MONITOR ; 

INOUT.SEND (IN.TASK); 

IN_TASK.ORIGIN := TASK_VEHICLE_SYS; 

IN_TASK.DEST1N := TASK_AUTO_PILOT; 

1N_TASK.ENT_CALL := PILOT_UPDATE ; 

INOUT.SEND (IN_TASK); 
accept ACK; 
accept ACK; 
accept ACK; 
accept ACK; 

loop 
select 
accept GO; 

START.STAMP := CLCXIK; 

accept VS_ORDERS (VS_MESSAGE : in MESSAGE_FORM) do 
IN_TASK := VS_MESSAGE; 
end VS_ORDERS; 


75 





delay VEHICLE.INT; 


IN.TASK-ORIGIN := TASK_VEHICLE_SYS; 
IN_TASK.DESTIN := TASK_NAVIGATION; 
IN_TASK.ENT_CALL ;= SYS_STATUS ; 

INOUT.SEND (IN.TASK); 

IN TASK.ORIGIN := TASK_VEHICLE_SYS; 
IN_TASK.DESTIN := TASK_SONAR ; 
IN_TASK.ENT_CALL := UPDATE_SONAR ; 

INOUT.SEND (IN.TASK); 
accept ACK; 
accept ACK; 

IN_TASK.ORIGIN ;= TASK_VEHICLE_SVS; 
IN_TASICDESTIN := TASK.MONITOR ; 
IN_TASK.ENT_CALL := TO_MONITOR ; 

INOUT.SEND (IN_TASK); 

IN_TASK.ORIGIN := TASK_VEHICLE_SYS; 
IN TASK.DESTIN := TASK_AUTO_PILOT ; 
IN_TASK.ENT_CALL := PILOT.UPDATE ; 

INOUT.SEND (IN.TASK); 
accept ACK; 
accept ACK; 


TIMER is the loop iteration time, it does not time interval 
between iterations. 

TIMER ;= CLOCK - START_STAMP; 

TALK.ORIGIN := TASK_VEHICLE_SYS; 

TALK.DESTIN := TASK SCREEN ; 

TALK.ENT_CALL := OUfPUT ; 
TALK.TIME_STAMP := TIMER ; 

TALK.MESSAGE_CODE := 20 ; 

INOUT.SEND (TALK); 

COUNT := COUNT + 1; 

exit when COUNT = STOPPER; 
or 

accept FIN; 


76 






exit; 

end select; 
end loop; 


accept VS.ORDERS (VS_MESSAGE : in MESSAGE_FORM) do 
1N_TASK := VS.MESSAGE; 
end VS_ORDERS; 

HNAL := CLOCK - PRE_STAMP; 

TALK.ORIG1N := TASK_VEHICLE_SYS; 

TALK.DEST1N ;= TASK_SCREEN ; 

TALK.ENT_CALL := OUTPUT ; 

TALK.T1ME_STAMP := FINAL ; 

TALK.MESSAGE_CODE := 31 ; 

1NOUT.SEND aALK); 

end VEH1CLE_SYS; 


begin 


loop 

MESSAGE.IO.READ (InFromVenus, 1N_MESSAGE); 

1N_MESSAGE.PR0G(2) := lN_MESSAGE.PROG(2) + 1; 

if 1N_MESSAGE.0R1G1N = SHUTDOWN and IN MESSAGE.DESTIN 
HOST.TASK then 

lN_MESSAGE.PROG(2) := -1 * IN_MESSAGE.PROG(2); 
delay 1.0; 

INOUT.INCOMING (1N_MESSAGE); 
exit; 
end if; 

select 

INOUT.INCOMING (IN_MESSAGE); 
or 

de! 7 SEND.INT; 

WAITING.LIMBO (IN_MESSAGE); 
end select; 
end loop; 

end MARS; 


77 






E. TASKS 


The remaining programs include VENUS.ADA, SATURN.ADA, and PLUTO.ADA. 
These programs are all simple variations to the above programs, and therefore, are not 
included here. All time measurements were taken with the task delays set at zero rather 
than the arbitrary numbers given above. The simulation tasks, not provided above, are as 
follows: 


task NAVIGATION is 

entry SONAR.OBSTACLE (NAV_MES&AGE : in MESSAGE_FORM); 
entry SYS_STATUS (NAV_MESSAGE : in MESSAGE_FORM); 
entry ACK; 
end; 

task body NAVIGATION is 

" This task takes the output from either SONAR or it will accept an update from 
— external systems (VEH1CLE_SYS). Output is then sent to GUIDANCE in either 
-- case. 


IN.TASK : MESSAGE.FORM; 


begin 


select 

accept SYS_STATUS (NAV.MESSAGE : in MESSAGE.FORM) do 
IN_TASK := NAV.MESSAGE; 
end SYS.STATUS; 

accept SONAR_OBSTACLE (NAV_MESSAGE ; in MESSAGE_FORM) do 
IN TASK := NAV_MESSAGE; 
end ^NAR.OBSTACLE; 

delay NAVIGATIONJNT; 

IN_TASK.ORIGlN := TASK.NAVIGATION; 

IN_TASK.DESTIN := TASK.GUIDANCE; 

IN_TASK.ENT_CALL := UPDATE_NAV; 

INOUT.SEND (1N_TASK); 
accept ACK; 


78 


or 

termmate; 
end select; 
end loop; 

end NAVIGATION; 
task SONAR is 

entry UPDATE_SONAR (SONAR.MESSAGE : in MESSAGE_FORM); 
entry ACK ; 

end; 

task body SONAR is 

This task receives from VEHICLE_SYS and raw sonar data from the external 
sensors. It then sends processes data to NAVIGATION. If an object is 
detected in a danger area then the information is sent to AVOIDANCE. In 
this dummy task, a message was always sent. 

IN_TASK : MESSAGE_FORM; 

EMERG_MESSAGE : MESSAGE_FORM ; 

begin 

loop 

select 

Awaits data from VEHICLE_SYS task. 

accept UPDATE_SONAR (SONAR.MESSAGE : in MESSAGE_FORM) do 
IN.TASK := SONAR_MESSAGE; 
end UPDATE_SONAR; 

EMERG.MESSAGE.ORIGIN := TASK_SONAR ; 
EMERG_MESSAGE.DESTIN := TASK_AVOIDANCE; 
EMERG_MESSAGE.ENT_CALL ;= OB_AVOID ; 

INOUT.SEND (EMERG.MESSAGE) ; 

accept ACK; 

IN_TASK.ORIGIN := TASK_SONAR ; 

IN_TASK.DESTIN := TASK_NAVIGATlON; 

IN_TASK.ENT_CALL := SONAR.OBSTACLE; 

INOUT.SEND (IN_TASK); 
accept ACK; 

delay SONARJNT; 
or 


79 


terminate; 
end select; 
end loop; 

end SONAR; 

task AVOIDANCE is 

entry 0B_AV01D (AVOID.MESSAGE : in MESSAGE.FORM); 
entry ACK; 
end; 


task body AVOIDANCE is 

~ This task receives only from SONAR and at irregular intervals. When input 
- is received, output is sent to both EXE_MISS10N and GUIDANCE. 

1N_TASK: MESSAGE.FORM; 


begin 


select 

accept OB.AVOID (AVOID MESSAGE : in MESSAGE_FORM) do 
IN_TASK := AVOID.ME^AGE; 
end OB_AVOID; 

IN_TASK.ORIGlN := TASK AVOIDANCE ; 

IN.TASICDESTIN := TASK.GUIDANCE ; 
IN_TASK.ENT_CALL := AVOID REC ; 

INOUT.SEND (IN_TASK); 
accept ACK; 

delay AVOIDANCEJNT; 

IN_TASK.ORIGIN ;= TASK.AVOIDANCE ; 

IN_TASK.DESTIN := TASK_EXE_MISSION; 
IN_TASK.ENT_CALL := OBJECT_ALERT ; 

INOUT.SEND (IN.TASK); 
accept ACK; 
or 

terminate; 
end select; 
end loop; 

end AVOIDANCE; 
task GUIDANCE is 


80 




entry UPDATE_NAV (GUIDE_MESSAGE ; in MESSAGE_FORM); 
entry UPDATE_ORDERS {GUIDE_MESSAGE : in MESSAGE_FORM); 
entry AVOID_REC (GUIDE_MESSAGE : in MESSAGE_FORM); 
entry ACK; 
end; 

task body GUIDANCE is 

This task receives input regularly from NAVIGATION and EXE_MISSION. Plus 
it receives input from AVOIDANCE irregularly. Output is always sent 
to AUTO.PILOT. 

EMERG, IN.TASK, GO_TO, WE_ARE : MESSAGE_FORM; 

begin 

loop 

select 

accept UPDATE_NAV (GUIDE.MESSAGE : in MESSAGE_FORM) do 
WE_ARE := GUIDE.MESSAGE; 
end UPDATE.NAV; 

accept AVOID.REC (GUIDE.MESSAGE : in MESSAGE_FORM) do 
EMERG := GUIDE_MESSAGE; 
end AVOID_REC; 

accept UPDATE.ORDERS (GUIDE.MESSAGE ; in MESSAGE_FORM) do 
GO_TO := GUIDE_MESSAGE; 
end UPDATE_ORDE~RS; 

delay GUIDANCE_INT; 

IN_TASK.ORIGIN := TASK_GUIDANCE ; 

IN_TASK.DESTIN ;= TASK_AUTO_PILOT; 

IN_TASK.ENT_CALL := AP.ORDERS ; 

INOUT.SEND (IN_TASK); 
accept ACK; 
or 

terminate; 
end select; 
end loop; 

end GUIDANCE; 

task EXE_MISSION is 

entry OBJECT_ALERT (EXE_MESSAGE : in MESSAGE_FORM); 


81 






entry MONITOR.UPDATE (EXE_MESSAGE : in MESSAGE_FORM); 
entry ACK; 
end; 

task body EXE_MISSION is 

— Input is taken from MONITOR regularly anj from AVOIDANCE in the case of 

- an obstacle problem (for the testing of this thesis^ an obstacle 

“ problem was assumed to always exist). Output is always sent to 
~ GUIDANCE. 

IN.TASK: MESSAGE_FORM; 

begin 

loop 

select 

accept MONITOR.UPDATE (EXE.MESSAGE : in MESSAGE.FORM) do 
IN.TASK ;= EXE_MESSAGE; 
end MONITOR.UPDATE; 

accept OBJECT ALERT (EXE_MESSAGE : in MESSAGE FORM) do 
IN.TASK EXE.MESSAGE; 
end OBJECT_ALERT; 

delay EXEJNT; 

IN.TASKORIGIN := TASK_EXE MISSION; 

IN_TASK.DESTIN := TASK GUIDANCE; 

IN_TASK.ENT_CALL := UPDATE.ORDERS; 

INOUT.SEND (IN.TASK); 

accept ACK; 
or 

terminate; 
end select; 
end loop; 

accept MONITOR_UPDATE (EXE_MESSAGE : in MESSAGE_FORM) do 
IN_TASK := EXE.MESSAGE; 
end MONITOR_UPDATE; 

end EXE_MISSION; 

task MONITOR is 

entry TO_MONITOR (MON_MESSAGE : in MESSAGE_FORM); 
entry ACK; 


82 





end; 


task body MONITOR is 

— This duininy task simply gets input from VEHICLE_SYS and sends it on to 

- EXE.MISSION. 

IN_TASK : MESSAGE_FORM; 

begin 

loop 

select 

accept TO_MONITOR (MON_MESSAGE : in MESSAGE_FORM) do 
IN_TASK := MON_MESSAGE; 
end TO_MONITOR; 

delay MONITOR_INT; 

IN_TASK.DESTIN ;= TASK_EXE_MISSION; 

IN_TASK.ORIGIN := TASK_MONITOR; 

IN_TASK.ENT_CALL := MONITOR_UPDATE; 

INOUT.SEND (IN.TASK); 
accept ACK; 
or 

terminate; 
end select; 
end loop; 

end MONITOR; 


begin 

loop 

MESSAGE.IO.READ (InFromMars, IN.MESSAGE); 

IN_MESSAGE.PROG(5) ;= IN_MESSAGE.PROG(3) + 1; 

if IN_MESSAGE.ORIGIN = SHUTDOWN then 
IN_MESSAGE.DESTIN := HOST_TASK; 
IN_MESSAGE.PROG(5) := -1 * IN_MESSAGE.PROG(5); 
INOUT.INCOMING (IN.MESSAGE); 
exit; 
end if; 


select 


83 




INOUT.INCOMING (IN_MESSAGE); 


delay SEND_INT; 
WAITING.LIMBO (IN_MESSAGE); 
end select; 
end loop; 
end PLUTO; 


84 






APPENDIX C: INVOKE AND LINKING FILES 


A. MAKEFILE 

This is the file used to create the necessary OCCAM libraries and generate all the 
fUes used in the harnesses. By simply invoking MAKE, all compilation and file generation 
was accomplished. 


# File: makefile 

# "make help" to print option list 

# 

# Complete development cycle: 

# make family - makes Ada family and library directories 

# make — compiles, links, configures source 

# make run - run bootable code 

MODE = s 

PROC = 8 

OPTS = /$(MODE) /t$(PROC) 

# make the executable code 

main.btl: mainh.c$(PROC)$(MODE) marsh.c$(PROC)$(MODE) venush.c$(PROC)$(MODE) 

satumh.c$(PROC)$(MODE) plutoh.c$(PROC)$(MODE) main.pgm 

@ echo EXPECT 1 WARNlNG...Then cross your fingers and PRAY for the best!! 
iconf /s main.pgm 
@ f:\util\bell 

mainh.c$(PROC)$(MODE): earth.o earthh.t$(PROC)$(MODE) merger.t$(PROC)$(MODE) 

mainh.t$(PROC)$(MODE) 
ilink /f main.Ink 

earth.o: common.ada printout.ada earth.ada 
ada invoke earth.inv,yes 

earthh.t$(PROC)$(MODE): earthh2.tax earthh.occ 
Occam $(OPTS) earthh.occ 

earthh2.tax: earthh2.occ 
Occam /ta /x earthh2.occ 


85 





merger.t$(PROC)$(MODE); merger.occ 
Occam $(OPTS) merger.occ 

mainh.t$(PROC)$(MODE): mainh.occ 
Occam $(OPTS) mainh.occ 

marsh.c$(PROC)$(MODE): mars.o marsh.t$(PROC)$(MODE) 

ilink marsh.t$(PROC)$(MODE) mars.o adartsS.Iib hostio.lib occamSs.lib xlink.lib 

mars.o: common.ada mars.ada 
ada invoke mars.inv,yes 

marsh.t$(PROC)$(MODE); marsh2.tax marsh.occ 
Occam $(OPTS) marsh.occ 

marsh2.tax; marsh2.occ 
Occam /ta /x marsh2.occ 

venush.c$(PROC)$(MODE): venvis.o venush.t$(PROC)$(MODE) 

ilink venush.t$(PROC)$(MODE) venus.o adartsS.Iib hostio.lib occamSs.lib xlink.lib 

venus.o: common.ada vemis.ada 
ada invoke venus.inv,yes 

venush.t$(PRC)C)$(MODE); venush2.tax venush.occ 
Occam $(OPTS) venush.occ 

venush2.tax; venush2.occ 
Occam /ta /x venvish2.occ 

satumh.c$(PROC)$(MODE): satum.o satumh.t$(PR(X!)$(MODE) 

ilink satumh.t$(PROC)$(MODE) satum.o adartsS.Iib hostio.lib occamSs.lib xlink.lib 

satum.o: common.ada satum.ada 
ada invoke satum.inv,yes 

satumh.t$(PRC)C)$(MODE): satumh2.tax satumh.occ 
Occam $(OPTS) satumh.occ 

satumh2.tax: satumh2.occ 
Occam /ta /x satumh2.occ 

plutoh.c$(PROC)$(MODE): pluto.o plutoh.t$(PROC)$(MODE) 

ilink plutoh.t$(PRCXr)$(MODE) pluto.o adartsS.Iib hostio.lib occamSs.lib xlink.lib 

pluto.o: common .ada pluto.ada 
ada invoke pluto.inv,yes 


86 






plutoh.t$(PRC)C)$(MODE); plutoh2.tax plutoh.occ 
Occam $(OPTS) plutoh.occ 

plutoh2.tax: plutoh2.occ 
Occam /ta /x plutoh2.occ 

# 

# misc. 

# 

help: 

@ echo Make arguments: 

@ echo make 
@ echo make -n [opt] 

@ echo make *.o 
@ echo make help 
@ echo make clean 
@ echo make run 
@ echo make check 
@ echo make family 

clean: 
del *.?8? 
del *.tax 
del *.o 
del •.dsc 
del *.btl 

del test_lib\adalib.* 
rd test_lib 

del test_fam\adafam.* 
rd test_fam 

run: 

iserver /sb main.btl 

check: 
check /r 

family: 

ada invoke family.inv,yes 


B. MAIN.PGM 

The following OCCAM program is the program that assigns the compiled code to 
specific processors and sets up the hardware for the necessary link commimication. 


- make from top level down 

- display but don't execute commands 

- make Ada object 

- display this list 

- delete all files except source 

- run bootable program 

- check transputer topology 

- make Ada family and library directories 


87 






- File: main.pgm 


#INCLUDE "hostio.inc" 

#INCLUDE "linkaddr.inc" 

#USE "inamh.c8s" 

#USE "marsh.c8s" 

#USE "venush.c8s" 

#USE "satumh.c8s" 

#USE "plutoh.c8s" 

CHAN OF INT Mars2Earth, Earth2Mars, Venus2Mars, Satvim2Venus, Pluto2Satiim, 
Mars2Pluto: 

CHAN OF SP FromFiler, ToFiler: 

PLACED PAR 

PROCESSOR 0 T8 

PLACE FromFiler AT linkO.in: 

PLACE ToFUer AT linkO.out: 

PLACE Mars2Earth AT link2.in: 

PLACE Earth2Mars AT link2.out: 

1325000] INT wsl: 

main.hamess (FromFiler, ToFiler, Mars2Earth, Earth2Mars, wsl) 

PROCESSOR 1 T8 

PLACE Earth2Mars AT linkO.in: 

PLACE Mars2Earth AT linkO.out: 

PLACE Venus2Mars AT link2.in: 

PLACE Mars2Pluto AT link3.out: 

[280000] INT ws2: 

mars.hamess (Mars2Earth, Earth2Mars, Venus2Mars, Mars2Pluto, ws2) 

PRCXTESSOR 2 T8 

PLACE Satum2Venus AT link2.in: 

PLACE Venus2Mars AT linkS.out: 

[280000] INT ws2: 

venus.hamess (Satum2Venus, Venus2Mars, ws2) 

PROCESSOR 3 T8 


88 








PLACE Pluto2Satum AT link2.m: 

PLACE Satum2Venus AT linkS.out: 

[280000] INT ws2: 

satum.hamess (Pluto2Satum, Satum2Veniis, ws2) 

PROCESSOR 4 T8 

PLACE Mars2Pluto AT link2.in: 

PLACE Pluto2Satum AT linkS.out; 

[280000] INT ws2; 

pluto.hamess (Mars2Pluto, Pluto2Satum, ws2) 

C. INVOKE FILES 

These are simple files used by the MAKEFILE to generate the code. 

— File: family.inv 

family .new test_fam,overwrite=yes 
lib(family=test_fam).new test_lib,overwrite=yes 

— File: earth.inv 
default.compile library=test_lib 
compile common.ada 
compile printout.ada 
compile earth.ada 

default.bind library=test_lib,level=bind,waming=no 
bind earth,object="earth.o",entry_point=’'earth.prog;ram" 

— File: mars.inv 
default.compile library=test_lib 
compile common.ada 
compile mais.ada 

default.bind library=test_lib,level=bind,waming=no 
bind mars,object="mars.o",entry_point="mars.program" 

— The remaining invoke files are identical except for the program names. 


89 







LIST OF REFERENCES 


[ALSYS 90] 

Alsys Inc., "PC Mothered Transputer Cross Compilation System User Manuals," 
Alsys, Burlington, MA, May 1990. 

[CLOUTIER 90] 

Cloutier, M. J., Guidance and Control System for an Autonomous Vehicle, Master's thesis. 
Naval Postgraduate School, Monterey, CA, Jime 1990. 

[DATABOOK 89] 

"The Transputer Databook," second edition, INMOS, Inc., Berkeley, CA, 1989. 
[FLOYD 91] 

Floyd C. A.,Design and Implementation of a Collision Avoidance System for the NFS 
Autonomous Underwater Vehicle (AUV-II) Utilizing Ultrasonic Sensors, Master's thesis. 
Naval Postgraduate School, Monterey, CA, September 1991. 

[GESPAC 90] 

GESPPU-1 Interface, GESPAC Press release, GESPAC, Inc., Geneva, SA, 1990. 
[GOOD 89] 

Good, M., Design and Construction of the Second Generation AUV, Master's thesis. Naval 
Postgraduate School, Monterey, CA, December 1989. 

[G64 90] 

Transputer Board Set Boosts Computing Capabilities of G-64 Systems, G64 Today #8, 
GESPAC, Inc., Geneva, SA, FaU 1990. 

[HOARE 88] 

Hoare C. A. R., series editor,"OCCAM 2 Reference Manual," INMOS, Inc., 1988. 
[INMOS REF 86] 

"Transputer Reference Manual", INMOS, Inc., Berkeley, CA,October 1986. 

[MAKRIS 91] 

Makris, D., Real-time Scheduling and Synchronization for the NFS Autonomous 
Underwater Vehicle, Master's thesis, NPS, Dec 1991. 

[FOUNTAIN 86] 

Fountain D., "A Tutorial Introduction to OCCAM Programming," INMOS, Inc, 
March 1986. 


90 








[SKANSHOLM 89] 

Skansholm J., "Ada From the Begmning",Addison Wesley Co., Menlo Park, CA, 1989. 
[TRANS 89] 

"Transputer Handbook", INMOS, Inc., Berkeley, CA, September 89. 


91 







INITIAL DISTRIBUTION LIST 

No. Copies 

1. Defense Technical Information Center 2 

Cameron Station 

Alexandria, VA 22304-6145 

2. Library, Code 52 2 

Naval Postgraduate School 

Monterey, CA 93943-5002 

3. Chairman, Code EC 1 

Department of Electrical & Computer Engineering 

Naval Postgraduate School 
Monterey, CA 93943-5002 

4. Professor Shridhar Shukla, Code EC/Sh 2 

Department of Electrical & Computer Engineering 

Naval Postgraduate School 
Monterey, CA 93943-5002 

5. Professor Roberto Cristi, Code EC/Cx 1 

Department of Electrical & Computer Engineering 

Naval Postgraduate School 
Monterey, CA 93943-5002 

6. Professor Robert B. McGhee, Code CS/Mz 1 

Department of Computer Science 

Naval Postgraduate School 
Monterey, CA 93943-5002 

7. Professor Anthony Healey, Code ME/Hy 1 

Department of Mechanical Engineering 

Naval Postgraduate School 
Monterey, CA 93943-5002 

8. Professor Uno Kodres, Code CS/Kr 1 

Department of Computer Science 

Naval Postgraduate School 
Monterey, CA 93943-5002 


92 






