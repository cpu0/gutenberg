REPORT DOCUMENTATION PAGE 


Public uponing bm4«n tor thi»eoUttiow atintomMion It artnwrtd w Kf g* 1 hemp* mgenm.Mjdingihttmnki nnmiing 


PtmAfip mm d 

OPMNo. 


ting inttructen*. mreftmj anting data tourom gmnnng 
any Mb v m p ta al Ma cobaolion at mtemiMen. iwaluding 
1216 JaManan 0*4 Mghany. to*. 120*. tong*, n. V* 





5. FUNDING 



DACS Sun SPARC/SunOS to 80386 PM bare Ada Cross Compiler System, 
Version 4.6.4, Host: Sun SPARCstation 1+ running under SunC3, 
Relea se 4.1.1, Target: B are Boa rd iSBC 386/116, 931119S1.1] 331 
rs: 

National Institute of Standards and Technology 
Gaithersburg, Maryland 


RFORMING ORGANIZATION NAME(S) AN 

luffing Jgii’SBSg sy tandards and Technolo !» 

Gaithersburg, Maryland 20899 ^ 

USA _ 


T SPONSORING/MONITORING AGENCY NAM£(S, AND Bp® 0 - Sf 

Ada Joint Program Office 

The Pentagon. Rm 3E118 1 

Washington. DC 20301-3080 ' 


11. SUPPLEMENTARY 


12a. DISTRIBUTION/AVAILABILITY 

Approved for Public Release; .distribution unlimited 


13 - 

DACS Sun SPARC/SunOS to 80386 PM bare Ada Cross Compiler System, Version 
4.6.4 , Host: Sun SPARCstation 1 + running under SunOS, Release 4.1.1 

Target: Bare Board iSBC 336/116, 931119S1.11331 


c 

E 


t o. SPONSORIN&MONITORIN 
GENCY A 


AD-A276 283 



94-05747 

-.MU 111(1 (III IW 


DTIC QU/OJTY IXS'-ECTED 2 


Tl 4 


9 9 


■vi 9 ,i 


14. SUBJECT 


15. NUMBER OF 


Ada programming linguage, Ada Compler Validation Summary Report, Ac 
SR§P)A?C-??J:iS?BS pb A.W5 y Val * Testln 9» Ada Val - Office, Ada Val. (facility 

17. SECURITY.. + * 1 118. SECURITY 119. SECURITY 20. LIMITATION Of 

CLASSIFICATION c CLASSIFICATION 

UNCLASSIFIED UNCLASSJFED UNCLASSIFIED UNCLASSIFIED 










Best 

Available 

Copy 







AVF Control Number: NIST92DDI510_4_1.11 
DATE COMPLETED 

BEFORE ON-SITE: 93-11-12 
AFTER ON-SITE: 93-11-19 
REVISIONS: 93-12-10 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 931119S1.11331 
DDC-I, Inc. 

DACS Sun SPARC/SunOS to 80386 PM bare Ada 
Cross Compiler System, Version 4.6.4 
Sun SPARCstation 1+ => Bare Board iSBC 386/116 


Prepared By: 

Software Standards Validation Group 
Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 


Accesion For 


NTIS GRA&I K 

DTIC TAH r 

Undiinco ■. ::d □ 

J'JStlf'CdtlO.i 



By. 

Distribution j 


AvcRabti;*, Cocits 


,'Wot! avIfO 


Dist 


i 

I 

I 









AVF Control Number: NIST92DDI510_4_1.11 
Certificate Information 


The following Ada implementation was tested and determined to pass 
ACVC 1.11. Testing was completed on November 19, 1993. 

Compiler Name and Version: DACS Sun SPARC/SunOS to 80386 PM 

bare Ada Cross Compiler System, 
Version 4.6.4 

Host Computer System: Sun SPARCstation 1+ running under 

SunOS, Release 4.1.1 

Target Computer System: Bare Board iSBC 386/116 

See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort, Validation Certificate 
931119S1.11331 is awarded to DDC-I, Inc. This certificate expires 
2 years after ANSI/MIL-STD-1815B is approved by ANSI. 

This report has been reviewed and is approved. 




Ida Validation-^Facillty 
Dr. David K. Jerfersiln 
Chief, Information Systems 
Engineering Division (ISED) 



Ada Validation Facility 
Mr. L. Arnold Jphnson 
Manager, Software Standards 
Validation Group 


Computer Systems Laboratory (CSL) 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 



Ada VaftidakCIon Organization 
Dire^tor>/'Obmputer & Software 
Engineeeang Division 
Institute for Defense Analyses 
Alexandria VA 22311 
U.S.A. 



^>Ada Joint Program Office 
v*£-M. Dirk Rogers, Major, USAF 
' Acting Director 

Ada Joint Program Office 
Washington DC 20301 
U.S.A. 











NIST92DDI510_4_1.11 


DECLARATION OF CONFORMANCE 

The following declaration of conformance was supplied by the 
customer. 


Customer: DDC-I, Inc. 

Certificate Awardee: DDC-I, Inc. 

Ada Validation Facility: National Institute of Standards and 

Technology 

Computer Systems Laboratory (CSL) 
Software Standards Validation Group 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 

ACVC Version: 1.11 


Ada Implementation: 


Compiler Name and Version: DACS Sun SPARC/SunOS to 80386 PM 

bare Ada Cross Compiler System, 
Version 4.6.4 


Host computer System: 


Sun SPARCstation 1+ running under 
SunOS, Release 4.1.1 


Target Computer System: Bare Board iSBC 386/116 


Declaration: 


I the undersigned, declare that I have no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STD-1815A ISO 
8652-1987 in the implementation listed above. 



Customer Signature 
Company^DDC-I, Inc. 
TitleT^^^ , 

_ 

Certificate Awardee Signature 
Company^DDC-I, Inc. 

Title /■&(,<£«/ 


Date 


Date 





TABLE OF CONTENTS 


CHAPTER 1.1-1 

INTRODUCTION.1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES. 1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES.2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST MODIFICATIONS.2-3 

CHAPTER 3.3-1 

PROCESSING INFORMATION.3-1 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 


APPENDIX A.A-l 

MACRO PARAMETERS.A-l 

APPENDIX B.B-l 

COMPILATION SYSTEM OPTIONS.B-l 

LINKER OPTIONS.B-2 

APPENDIX C.C-l 

APPENDIX F OF THE Ada STANDARD.C-l 




























CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro92] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to [Pro92]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552). The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield, Virginia 22161 
U.S.A. 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 


Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria, Virginia 22311-1772 

U.S.A. 


1-1 




1.2 REFERENCES 


[Ada83] Reference Manual for the Ada Programming Language f 
ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro92] Ada Compiler Validation Procedures . Version 3.1, Ada Joint 
Program Office, August 1992. 

[UG89] Ada Compiler Validation Capability User's Guide . 21 June 
1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECKFILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is 
compiled and the resulting compilation listing is examined to 
verify that all violations of the Ada Standard are detected. Some 
of the class B tests contain legal Ada code which must not be 
flagged illegal by the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values—for example, the 


1-2 



largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 
the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [UG89]). 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler 


Ada Compiler 
Validation 
Capability (ACVC) 


Ada Implementation 


Ada Joint Program 
Office (AJPO) 


Ada Validation 
Facility (AVF) 


Ada Validation 
Organization (AVO) 

Compliance of an 
Ada Implementation 


The software and any needed hardware that 
have to be added to a given host and target 
computer system to allow transformation of 
Ada programs into executable form and 
execution thereof. 

The means for testing compliance of Ada 
implementations, Validation consisting of 
the test suite, the support programs, the 
ACVC Capability User's Guide and the 
template for the validation summary (ACVC) 
report. 

An Ada compiler with its host computer 
system and its target computer system. 

The part of the certification body which 
provides policy and guidance for the Ada 
certification Office system. 

The part of the certification body which 
carries out the procedures required to 
establish the compliance of an Ada 
implementation. 

The part of the certification body that 
provides technical guidance for operations 
of the Ada certification system. 

The ability of the implementation to pass an 
ACVC version. 


1-3 





Computer System 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable Test 

ISO 

LRM 


Operating System 


Target Computer 
System 


A functional unit, consisting of one or more 
computers and associated software, that uses 
common storage for all or part of a program 
and also for all or part of the data 
necessary for the execution of the program; 
executes user- written or user-designated 
programs; performs user-designated data 
manipulation, including arithmetic 
operations and logic operations; and that 
can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 

Fulfillment by a product, process, or 
service of all requirements specified. 

An individual or corporate entity who enters 
into an agreement with an AVF which 
specifies the terms and conditions for AVF 
services (of any kind) to be performed. 

A formal statement from a customer assuring 
that conformity is realized or attainable on 
the Ada implementation for which validation 
status is realized. 

A computer system where Ada source programs 
are transformed into executable form. 

A test that contains one or more test 
objectives found to be irrelevant for the 
given Ada implementation. 

International Organization for 
Standardization. 

The Ada standard, or Language Reference 
Manual, published as ANSI/MIL-STD-1815A 
-1983 and ISO 8652-1987. Citations from the 
LRM take the form "<section>.<subsection>; 
<paragraph>." 

Software that controls the execution of 
programs and that provides services such as 
resource allocation, scheduling, 
input/output control, and data management. 
Usually, operating systems are predominantly 
software, but partial or complete hardware 
implementations are possible. 

A computer system where the executable form 
of Ada programs are executed. 


1-4 




Validated Ada 
Compiler 

Validated Ada 
Implementation 


Validation 


Withdrawn Test 


The compiler of a validated Ada 
implementation. 

An Ada implementation that has been 
validated successfully either by AVF testing 
or by registration [Pro92]. 

The process of checking the conformity of an 
Ada compiler to the Ada programming language 
and of issuing a certificate for this 
implementation. 

A test found to be incorrect and not used in 
conformity testing. A test may be incorrect 
because it has an invalid test objective, 
fails to meet its test objective, or 
contains erroneous or illegal use of the Ada 
programming language. 


1-5 




CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 95 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 91-08-02. 

E28005C B28006C C32203A C34006D C35508I C35508J 
C35508M C35508N C35702A C35702B B41308B C43004A 
C45114A C45346A C45612A C45612B C45612C C45651A 
C46022A B49008A B49008B A74006A C74308A B83022B 
B83022H B83025B B83025D B83026B C83026A C83041A 
B85001L C86001F C94021A C97116A C98003B BA2011A 
CB7001A CB7001B CB7004A CC1223A BC1226A CC1226B 
BC3009B BD1B02B BD1B06A AD1B08A BD2A02A CD2A21E 
CD2A23E CD2A32A CD2A41A CD2A41E CD2A87A CD2B15C 
BD3006A BD4008A CD4022A CD4022D CD4024B CD4024C 
CD4024D CD4031A CD4051D CD5111A CD7004C ED7005D 
CD7005E AD7006A CD7006E AD7201A AD7201E CD7204B 
AD7206A BD8002A BD8004C CD9005A CD9005B CDA201E 
CE2107I CE2117A CE2117B CE2119B CE2205B CE2405A 
CE3111C CE3116A CE3118A CE3411B CE3412B CE3607B 
CE3607C CE3607D CE3812A CE3814A CE3902B 


2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Commentaries and commonly referenced in 
the format Al-ddddd. For this implementation, the following tests 
were determined to be inapplicable for the reasons indicated; 
references to Ada Commentaries are included as appropriate. 

The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS; 

C24113L..Y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 

C35708L..Y (14 tests) C35802L..Z (15 tests) 

2-1 





C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 

C24113I..K (3 tests) use a line 
exceeds 126 characters. 


C45321L..Y (14 tests) 

C45521L..Z (15 tests) 

C45621L..Z (15 tests) 

C46012L..Z (15 tests) 

length in the input file which 


C35404D, C45231D, B86001X, C86006E, and CD7101G check for a 
predefined integer type with a name other than INTEGER, 
LONGINTEGER, or SHORT_INTEGER; for this implementation, there is 
no such type. 

C35713B, C45423B, B86001T, and C860Q6H check for the predefined 
type SHORTFLOAT; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with 
a name other than FLOAT, LONGFLOAT, or SHORTFLOAT; for this 
implementation, there is no such type. 

C4A013B contains a static universal real expression that exceeds 
the range of this implementation's largest floating-point type; 
this expression is rejected by the compiler. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for 
this implementation, MAXMANTISSA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLOWS is FALSE for floating point types and the results 
of various floating-point operations lie outside the range of the 
base type; for this implementation, MACHINEOVERFLOWS is TRUE. 

D56001B uses 65 levels of block nesting; this level of block 
nesting exceeds the capacity of the compiler. 

B86001Y uses the name of a predefined fixed-point type other than 
type DURATION; for this implementation, there is no such type. 

C96005B uses values of type DURATION'S base type that are outside 
the range of type DURATION; for this implementation, the ranges are 
the same. 

CA2009C and CA2009F check whether a generic unit can be 
instantiated before its body (and any of its subunits) is compiled; 
this implementation creates a dependence on generic units as 
allowed by AI-00408 and AI-00506 such that the compilation of the 
generic unit bodies makes the instantiating units obsolete. (See 
section 2.3.) 

CD1009C checks whether a length clause can specify a non-default 


2-2 




size for a floating-point type; this implementation does not 
support such sizes. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length 
clauses to specify non-default sizes for access types; this 
implementation does not support such sizes. 

The following 264 tests check operations on sequential, text, and 
direct access files; this implementation does not support external 
files; 


CE2102A..C 

(3) 

CE2102G..H 

(2) 

CE2102K 


CE2102N..Y (12) 

CE2103C..D 

(2) 

CE2104A..D 

(4) 

CE2105A..B 

(2) 

CE2106A..B 

(2) 

CE2107A..H 

(8) 

CE2107L 


CE2108A..H 

(8) 

CE2109A..C 

(3) 

CE2110A..D 

(4) 

CE2111A..1 

(9) 

CE2115A..B 

(2) 

CE2120A..B 

(2) 

CE2201A..C 

(3) 

EE2201D..E 

(2) 

CE2201F..N 

(9) 

CE2203A 


CE2204A..D 

(4) 

CE2205A 


CE2206A 


CE2208B 


CE2401A..C 

(3) 

EE2401D 


CE2401E..F 

(2) 

EE2401G 


CE2401H..L 

(5) 

CE2403A 


CE2404A..B 

(2) 

CE2405B 


CE2406A 


CE2407A..B 

(2) 

CE2408A..B 

(2) 

CE2409A..B 

(2) 

CE2410A..B 

(2) 

CE2411A 


CE3102A..C 

(3) 

CE3102F..H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A..C 

(3) 

CE3106A..B 

(2) 

CE3107B 


CE3108A..B 

(2) 

CE3109A 


CE3110A 


CE3111A..B 

(2) 

CE3111D..E 

(2) 

CE3112A..D 

(4) 

CE3114A..B 

(2) 

CE3115A 


CE3119A 


EE3203A 


EE3204A 


CE3207A 


CE3208A 


CE3301A 


EE3301B 


CE3302A 


CE3304A 


CE3305A 


CE3401A 


CE3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A..C 

(3) 

CE3403E..F 

(2) 

CE3404B..D 

(3) 

CE3405A 


EE3405B 


CE3405C..D 

(2) 

CE3406A..D 

(4) 

CE3407A..C 

(3) 

CE3408A..C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE3410C..E 

(3) 

EE3410F 


CE3411A 


CE3411C 


CE3412A 


EE3412C 


CE3413A..C 

(3) 

CE3414A 


CE3602A..D 

(4) 

CE3603A 


CE3604A..B 

(2) 

CE3605A..E 

(5) 

CE3606A..B 

( 

CE3704A..F 

(6) 

CE3704M..0 

(3) 

CE3705A..E 

(5) 

CE3706D 


CE3706F..G 

(2) 

CE3804A..P 

(16) 

CE3805A..B 

(2) 

CE3806A..B 

(2) 

CE3806D..E 

(2) 

CE3806G..H 

(2) 

CE3904A..B 

(2) 

CE3905A..C 

(3) 

CE3905L 


CE3906A..C 

(3) 

CE3906E..F 

(2) 


CE2103A, CE2103B, and CE3107A use an illegal file name in an 
attempt to create a file and expect NAME_ERROR to be raised; this 
implementation does not support external files and so raises 
USEERROR. (See section 2.3.) 

2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 71 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in 
the way expected by the original tests. 


2-3 








B22003A 

B35101A 

B38009B 

B61001R 

B83E01D 

B91002C 

B91002J 

B95077A 

BC1109D 


B26001A 

B37106A 

B55A01A 

B61001W 

B83E01E 

B91002D 

B91002K 

B97103E 

BC1202A 


B26002A 

B37301B 

B61001C 

B67001H 

B85001D 

B91002E 

B91002L 

B97104G 

BC1202F 


B26005A 

B37302A 

B61001F 

B83A07A 

B85008D 

B91002F 

B95030A 

BA1001A 

BC1202G 


B28003A 

B38003A 

B61001H 

B83A07B 

B91001A 

B91002G 

B95061A 

BA1101B 

BE2210A 


B29001A 

B38003B 

B61001I 

B83A07C 

B91002A 

B91002H 

B95061F 

BC1109A 

BE2413A 


B33301B 

B38009A 

B61001M 

B83E01C 

B91002B 

B91002I 

B95061G 

BC1109C 


C83030C and C86007A were graded passed by Test Modification as 
directed by the AVO. These tests were modified by inserting 
"PRAGMA ELABORATE (REPORT);" before the package declarations at 
lines 13 and 11, respectively. Without the pragma, the packages 
may be elaborated prior to package Report's body, and thus the 
packages' calls to function REPORT.IDENT_INT at lines 14 and 13, 
respectively, will raise PROGRAM_ERROR. 

CA2009C and CA2009F were graded inapplicable by Evaluation 
Modification as directed by the AVO. These tests contain 
instantiations of a generic unit prior to the compilation of that 
unit's body; as allowed by AI-00408 and AI-00506, the compilation 
of the generic unit bodies makes the compilation unit that contains 
the instantiations obsolete. ! 

BC3204C and BC3205D were graded passed by Processing Modification 
as directed by the AVO. These tests check that instantiations of 
generic units with unconstrained types as generic actual parameters 
are illegal if the generic bodies contain uses of the types that 
require a constraint. However, the generic bodies are compiled 
after the units that contain the instantiations, and this 
implementation creates a dependence of the instantiating units on 
the generic units as allowed by AI-00408 and AI-00506 such that the 
compilation of the generic bodies makes the instantiating units 
obsolete—no errors are detected. The processing of these tests 
was modified by re-compiling the obsolete units; all intended 
errors were then detected by the compiler. 

CE2103A, CE2103B, and CE3107A were graded inapplicable by 
Evaluation Modification as directed by the AVO. The tests abort 
with an unhandled exception when USE_ERROR is raised on the attempt 
to create an external file. This is acceptable behavior because 
this implementation does not support external files (cf. AI-00332). 


2-4 







CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is 
described adequately by the information given in the initial pages 
of this report. 

For technical information about this Ada implementation, contact: 

Forrest Holemon 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 

Telefax: 602-275-7502 

For sales information about this Ada implementation, contact: 

Mike Halpin 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 
Telefax: 602-275-7502 

Testing of this Ada implementation was conducted at the customer's 
site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro92]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were 
withdrawn because of test errors (item b; see section 2.1), those 
that require a floating-point precision that exceeds the 
implementation's maximum precision (item e; see section 2.2), and 
those that depend on the support of a file system—if none is 
supported (item d). All tests passed, except those that are listed 
in sections 2.1 and 2.2 (counted in items b and f, below). 


3-1 






a) Total Number of Applicable Tests 3571 

b) Total Number of Withdrawn Tests 95 

c) Processed Inapplicable Tests 504 

d) Non-Processed I/O Tests w 0 

e) Non-Processed Floating-Point 

Precision Tests 0 


f) Total Number of Inapplicable Tests 504 (c+d+e) 

g) Total Number of Tests for ACVC 1.11 4170 (a+b+f) 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 
1.3) was taken on-site by the validation team for processing. The 
contents of the magnetic tape were loaded directly onto the host 
computer. 

The DDC-I Ada Symbolic Debugger runs on the Sun SPARCstation 1+ and 
is used for downloading the executable images to the target Bare 
Board iSBC 386/116. The DDC-I Debug Monitor runs on the target 
Bare Board iSBC 386/116 and provides communication interface 
between the host debugger and the executing target Bare Board iSBC 
386/116. The two processes communicate via ethernet. 

After the test files were loaded onto the host computer, the full 
set of tests was processed by the Ada implementation. 

The tests were compiled and linked on the host computer system, as 
appropriate. The executable images were transferred to the target 
computer system by the communications link described above, and 
run. The results were captured on the host computer system. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B for 
a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this test 
were: 

-nosave -list 

Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. The listings 
examined on-site by the validation team were also archived. 


3-2 






APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing 
the ACVC. The meaning and purpose of these parameters are 
explained in [UG89]. The parameter values are presented in two 
tables. The first table lists the values that are defined in terms 
of the maximum input-line length, which is the value for 
$MAX_IN LEN—also listed here. These values are expressed here as 
Ada string aggregates, where "V" represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 126 — Value of V 

$BIG_ID1 (1..V-1 => 'A', V => »1») 

$BIG_ID2 (1..V-1 => 'A', V => '2') 

$BIG_ID3 (1..V/2 => 'A*) & '3' & (1..V-1-V/2 => 'A') 

$BIG_ID4 (1..V/2 => 'A') & '4' & (1..V-1-V/2 => 'A') 

$BIG_INT_LIT (1..V-3 *> '0') & ”298" 

$BIG_REAL_LIT (1..V-5 => '0') & "690.0" 

$BIG_STRING1 & (1..V/2 => 'A') & 

$BIG_STRING2 """ & (1..V-1-V/2 => 'A') & *1' & 

$BLANKS (1..V-20 => ' ') 

$MAX_LEN_INT_BASED_LITERAL 

"2:" & (1..V-5 => '0') & "11:" 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => ’O') & "F.E:" 

$MAX_STRING_LITERAL 1 & (1..V-2 => ‘A’) & 


A-1 







The following table contains the values for the remaining 
macro parameters. 

Macro Parameter Macro Value 


ACCSIZE 

ALIGNMENT 

COUNT_LAST 

DE FAULT_MEM_SIZE 

DEFAULT_STOR_UNIT 

DEFAULT_SYS_NAME 

DELTA_DOC 

ENTRYADDRESS 

ENTRY_ADDRESS1 

ENTRY_ADDRESS 2 

FIELD_LAST 

FILETERMINATOR 

FIXED_NAME 

FLOAT_NAME 

FORMSTRING 

FORM STRING2 


48 

2 

2_147_483_647 

16#1_0000_0000# 

16 

IAPX3 8 6_PM 
2#1.0#E-31 
(140,0) 

(141,0) 

(142,0) 

35 

ASCII.SUB 

NOSUCHJFIXEDTYPE 

SHORT_SHORT_FLOAT 

It tl 


"CANNOT RESTRICT FILE CAPACITY" 


GREATER_THAN_DURATION 

GREATER_THAN_DURATION_BASE_LAST 

GREATER_THAN_FLOAT_BASE_LAST 

GREATER_THAN_FLOAT_SAFE_LARGE 

GREATER_THAN_SHORT_FLOAT_SAFE_LARGE 

HIGHPRIORITY 

ILLEGAL_EXTERNAL_FILEJNAME1 
ILLEGAL EXTERNAL FILE NAME2 


75000.0 

131073.0 

16#1.0#E+32 

16#5.FFFF_F0#E+31 

1.0E308 

31 

\NODIRECTORY\FILENAME 


THIS-FILE-NAME-IS-TOO-LONG-FOR-MY-SYSTEM 


INAPPROPRIATE_LINE_LENGTH 

INAPPROPRIATE_PAGE_LENGTH 

INCLUDE_PRAGMA1 

INCLUDE_PRAGMA2 

INTEGER_FIRST 

INTEGER_LAST 

INTEGER_LAST_PLU S_1 

INTERFACE_LANGUAGE 

LESS_THAN_DURATION 

LE S S_THAN_DURATION_BASE_FIRST 

LINE_TERMINATOR 

LOWPRIORITY 

MACHINE_CODE_STATEMENT 

MACHINE_CODE_TYPE 
MANTISSA DOC 


: -1 
i -1 

PRAGMA INCLUDE ("A28006D1.TST") 

PRAGMA INCLUDE ("B28006E1.TST") 

: -2147483648 
: 2147483647 

: 2_147_483_648 
: ASM86 
: -75_000.0 
: —131_073.0 
: ASCII.CR 

: 0 

• 

• 

MACHINE_INSTRUCTION'(N0NE,m_N0P) ; 
: REGISTER_TYPE 
: 31 


A-2 












MAX_DIGITS 

MAX_INT 

MAX_INT_PLUS_1 

MIN_INT 

NAME 

NAME_LIST 

NAME_SPECIFICATI0N1 
DISK$AWC 
NAME_SPECIFICATI0N2 
DISK$AWC 
NAME_SPECIFICATI0N3 
DISK$AWC 
NEG_BASED_INT 
NEW_MEM_SIZE 
NEW_STOR_UNIT 
NEW_SYS_NAME 
PAGETERMINATOR 
RECORD_DEFINITION 
RECORDNAME 
TASKSIZE 
TASK STORAGE SIZE 


9223372036854775807 
9223372036854775808 
-9223372036854775808 
SHORT_SHORT_INTEGER 
IAPX386 PM ‘ 


:_2: [ CROCKETTL. ACVC11. DEVELOPMENT] X212 OA. ;1 

:_2:[CROCKETTL.ACVC11.DEVELOPMENT]X2120B.;1 

• 

!_2:[CROCKETTL.ACVC11.DEVELOPMENT]X2120C.;1 

: 16#FFFF_FFFF_FFFF_FFFF# 

: 16#1_Q000_0000# 

: 16 

: IAPX386_PM 
: ASCII.FF 

: RECORD NULL;END RECORD; 

: NO_SUCH_MACHINE_CODE_TYPE 
: 32 
: 1024 


TICK 

VARIABLEADDRESS 
VARIABLE_ADDRESS1 
VARIABLE_ADDRESS 2 
YOUR PRAGMA 


0.0000000625 

(16#0#,16#44#) 

(16#4 #,16#44#) 
(16#8#,16#44#) 
EXPORT OBJECT 


A-3 





APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 


B-l 



DDC-I Ada Compiler System 
DACS Sun SPARC/SunOS to 80x86 Bare 
Ada Cross Compiler System 
User’s Guide 


COMPILER AND LINKER OPTIONS 






5 THE ADA COMPILER 


The Ada Compiler compiles all program units within the specified source file and inserts the 
generated objects into the current program library. Compiler options arc provided to allow the 
user control of optimization, nin-timc checks, and compiler input and output options such as list 
files, configuration files, the program library used, etc. 

The input to the compiler consists of the source file, the configuration file (which controls the 
formal of the list file), and the compiler options. Section 5.1 provides a list of all compiler 
options^ and Section 5.2 describes the source and configuration files. 

If any diagnostic messages arc produced during the compilation, they arc output on the diagnostic 
file and on the current output file. The diagnostic file and the diagnostic messages arc described 
in Section 5.3.2. 

Output consists of an object placed in the program library, diagnostic messages, and optional 
listings. The configuration file and the compiler options specify the formal and contents of the 
list information. Output is described in Section 5.3. 

The compiler uses a program library during the compilation. The compilation unit may refer to 
units from the program library, and an internal representation of the compilation unit will be 
included in the program library as a result of a successful compilation. The program library is 
described in Chapter 3. Section 5.4 briefly describes how the Ada compiler uses the library. 


5.1 Invoking the Ada Compiler 

Invoke the Ada compiler with the following command to the SunOS shell: 

$ ada {<option>} <source-file-name> 
where the options and parameters arc: 


35 




DACS-XOxXb User's Guide 
Ada Compiler 


<source-filc-namc> 

Tlv; Ad i compiler has one mandalory parameter that should specify the Ada source file, 
fin : parameter specifics the text file containing the source text to be compiled. If the file type 
>A '"■milled in die source file specification, the file type ".ada“ is assumed by default. 

The allowed formal of the source text is described in Section 5.2.1. 

Below follows a description of each of the available options to the invocation of the Ada 
compiler. 


s 1,1 -(no]autojnIinc 

-autojnlinc local j global 
-noaulojnline (default) 

■is v.j,'ion specifics whether subprograms should be inline expanded. The inline expansion only 
occurs if the subprogram has less than 4 object declarations and less than 6 statements, and if the 
subprogram fulfills the requirements defined for pragma INLINE (see Section C.2.3). LOCAL 
specifies that only inline expansion of locally defined subprograms should be done, while 
GLOBAL will cause inline expansion of all subprograms, including subprograms from other units. 


5.1,1 -check 


-check [ <key\vord> = ON | OFF { ,<key\vord> = ON | OFF } ) 
-check ALL=ON (default) 


-check specifies which run-time checks should be performed. Setting a run-time check to ON 
enables the check, while setting it to OFF disables the check. All run-time checks arc enabled by 
default. The following explicit checks will be disablcd/cnablcd by using the name as <keyword>: 


ACCESS 

Ai.L 

DISCRIMINANT 

ELABORATION 

INDEX 

LENGTH 

OVERFLOW 

RANGE 

STORAGE 


Check for access values being non NULL. 
All checks. 

Checks for discriminated fields. 

Checks for subprograms being elaborated. 
Index check. 

Array length check. 

Explicit overflow checks. 

Checks for values being in range. 

Checks for sufficient storage available. 


37 



I)ACS-X()xX6 User’s Guide 
Ada Compiler 


5.1.7 -library 

-library <filc-spec> 

-library $ada_library (default) 

This option specifics the current sublibrary that will be used in the compilation and will receive 
the object when the compilation is complete. By specifying a current sublibrary, the current 
program library (current sublibrary and ancestors up to root) is also implicitly specified. 

If this option is omitted, the sublibrary designated by the environmental variable ada_library is 
used as the current sublibrary. Section 5.4 describes how tire Ada compiler uses the library. 


5.1.8 -fnollist 
-list 

•nolist (default) 

-list specifics that a source listing will be produced. The source listing is written to the list file, 
which has the name of the source file with the extension Jis. Section 5.3.1.1 contains a description 
of the source listing. 

If -nolist is active, no source listing is produced, regardless of LIST pragmas in the program or 
diagnostic messages produced. 


5.1.9 -optimize 

-optimize [ <keyword> = on | off { ,<key\vord> = on | off } ] 

•optimize all=off 

This option specifics which optimizations will be performed during code generation. The possible 
keywords arc: (casing is irrelevant) 


all 

All possible optimizations arc invoked. 

check 

Eliminates superfluous checks. 

cse 

Performs common subexpression elimination including common 
address expressions. 

fct2proc 

Change function calls reluming objects of constrained array types 
or objects of record types to procedure calls. 

reordering 

Transforms named aggregates to positional aggregates and named 
parameter associations to positional associations. 

stack-height 

Performs stack height reductions (also called Aho Ullman 
reordering). 

block 

Optimize block and call frames. 


Setting an optimization to on enables the optimization, while setting an optimization to off disables 
the optimization. All optimizations arc disabled by default. In addition to the optional 
optimizations, the compiler always performs the following optimizations: constant folding, dead 
code elimination, and selection of optimal jumps. 


39 



l)ACS-K0xK6 User’s Guide 
Ada Compiler 


5.1.14 -unit 

•mil = cunit numhcr> 


n.r specified unit number will be assigned to the compilation unit if it is free and it is a legal 
unit number for the library. 


S.i.15 -recompile 
-i (‘compile 

The iuc name (source) is interpreted as a compilation unit name which has its source saved from 
i previous compilation. If -specification is not specified, it is assumed to be body which must be 
recompiled. 


j j.16 -specification 
•specification 

Works only together with -recompile, see Section 5.1.15. 

5.?. Compiler Input 

Input to the compiler consists of the command line options, a source text file and, optionally, a 
configuration file. 


5.2.1 Source Text 

The user submits one file containing a source text in each compilation. The source text may 
consist of one or more compilation units (see ARM Section 10.1). 

fnc format of the source text must be in ISO-FORMAT ASCII. This formal requires that the 
source text is a sequence of ISO characters (ISO standard 646), where each line is terminated by 
cithci one of the following termination sequences (CR means carriage return, VT means vertical 
tabulation, LF means line feed, and FF means form feed): 

• A sequence of one or more CRs, where the sequence is neither immediately preceded nor 
immediately followed by any of the characters VT, LF, or FF. 

• Any of the characters VT, LF, or FF, immediately preceded and followed by a sequence of zero 
or more CRs. 

in general, ISO control characters are not permitted in the source text with the following 
exceptions: 


41 


DACS-80xK6 User’s Guide 
Ada Compiler 


type CONFIGURATION_RECORD is 
record 

IN_FORMAT: INFORMATTING; 

OUT_FOftMAT; OUTFORMATTING; 

ERROR_LIMIT; INTEGER; 
end record; 

type INPUT_FORMATS is (ASCII); 

type INFORMATTING is 
record 

INPUT_FORMAT: INPUT_FOKMATS; 

INPUT_LINELENGTH: INTEGER range 70..250; 
end record; 

type OUTFORMATTING is 
record 

LINES_PER_PAGE 
TOP_MARGIN 
BOTTOM_MARGIN 
OUT_LINELENGTH 
SUPPRESS_ERRORNO 
end record; 

The outformatting parameters have the following meaning: 

1) LINES_PER_PAGE: specifics the maximum number of lines written on each page 
(including top and bottom margin). 

2) TOP_MARGIN: specifies the number of lines on top of each page used for a standard 
heading and blank lines. The heading is placed in the middle lines of the top margin. 

3) BOTTOM_MARGIN: specifies the minimum number of lines left blank in the bottom of 
the page. The number of lines available for the listing of the program is LINES 
PER.PAGE - TOP_MARGIN - BOTTOM_MARGIN. 

4) OUTJLINELENGTH: specifies the maximum number of characters written on each line. 
Lines longer than OUT_LINELENGTH arc separated into two lines. 

5) SUPPRESS_ERRORNO: specifies the formal of error messages (see Section 5.3.5.1). 

The name of a user-supplied configuration file can be passed to the compiler through the 
configuration-file option. DDC-I supplies a default configuration file (config) with the following 
content: 


INTEGER range 30..100 
INTEGER range 4.. 90 
INTEGER range 0.. 90 
INTEGER range 80..132 
BOOLEAN; 


43 






DACS-XOxXft User’s Guide 
Ada Compiler 


5.3.1 The List File 

The name of ihc list file is identical to the name of the source file except that it has the lile type 
”.lis". The file is located in tire current (default) director)'. If any such file exists prior to the 
compilation, the newest version of the file is deleted. If the user requests any listings by 
specifying the options -list or -xref, a new list file is created. 

The list file may include one or more of the following parts: a source listing, a cross-rcfcrcncc 
listing, and a compilation summary. 

The pans of the list file arc separated by page ejects. The contents of each pan arc described in 
the following sections. 

The formal of the output on the list file is controlled by the configuration file (see Section 5.2.2) 
and may therefore be controlled by the user. 


5.3.1.1 Source Listing 

A source listing is an unmodified copy of the source text. The listing is divided into pages and 
each line is supplied with a line number. 

The number of lines output in the source listing is governed by the occurrence of LIST pragmas 
and the number of objectionable lines. 

• Parts of the listing can be suppressed by the use of the LIST pragma. 

• A line containing a construct that caused a diagnostic message to be produced is printed even 
if it occurs at a point where listing has been suppressed by a LIST pragma. 

5.3.1.2 Compilation Summary 

At the end of a compilation, the compiler produces a summary that is output on the list file if the 
option -list is active. 

The summary contains information about: 

1) The type and name of the compilation unit, and whether it has been compiled successfully 
or not. 

2) The number of diagnostic messages produced for each class of severity (sec Section 
5.3.2.1). 

3) Which options were active. 

4) The full name of the source file. 

5) The full name of the current sublibrary. 

6) The number of source text lines. 


45 








DACS-XOxXO User’s Guide 
Ada Compiler 


5.3.2 The Diagnostic File 

The name of the diagnostic Tile is identical to the name of the source Hie except that it has die 
file type ".err". It is located in live current (default) directory. If any such file exists prior to the 
compilation, the newest version of the file is deleted. If any diagnostic messages arc produced 
during the compilation a new diagnostic file is created. 

The diagnostic file is a text file containing a list of diagnostic messages, each followed by a line 
showing the number of the line in die source text causing die message, and a blank line. There 
is no separation into pages and no headings. The file may be used by an interactive editor to 
show the diagnostic messages together widi the erroneous source text. 


5.3.2.1 Diagnostic Messages 

The Ada compiler issues diagnostic messages on the diagnostic file. Diagnostics other than 
warnings also appear on the current output file. If a source text listing is required, the diagnostics 
are also found embedded in the list file (see Section 5.3.1). ' 

In a source listing, a diagnostic message is placed immediately after the source line causing the 
message. Messages not related to any particular line arc placed at the top of the listing. Every 
diagnostic message in the diagnostic file is followed by a line staling the line number of the 
objcciional line. The lines arc ordered by increasing source line numbers. Line number 0 is 
assigned to messages not related to any particular line. On the current output file the messages 
appear in the order in which they are generated by the compiler. 

The diagnostic messages arc classified according to their severity and the compiler action taken: 


Warning: Repons a questionable construct or an error that docs not influence the meaning of the 
program. Warnings do not hinder the generation of object code. 

Example: A warning will be issued for constructs for which the compiler detects will 
raise CONSTRAINT_ERROR at run time. 


Error: Reports an illegal construct in the source program. Compilation continues, but no object 

code will be generated. 

Examples: most syntax errors; most static semantic errors. 


Severe Reports an error which causes the compilation to be terminated immediately, 
error: No object code is generated. 

Example: A severe error message will be issued if a library unit mentioned by a 
WITH clause is not present in the current program library. 


47 




DACS-XOxXh User's Ciuidc 
Ada Compiler 


*** 1500S-0: Specification for this package body not present in the library 


5.4 The Program Library 

This scciion briefly describes how ihc Ada compiler changes the program library. For a more 
general description of the program library, the user is referred to Chapter 3. 

The compiler is allowed to read from all sublibraricx constituting the current program library, but 
only the current sublibrary may be changed. 


5.4.1 Correct Compilations 

In the following examples it is assumed that the compilation units arc correctly compiled, i.c., that 
no errors arc detected by the compiler. 

Compilation of a library unit which is a declaration 

If a declaration unit of the same name exists in the current sublibrary, it is deleted together with 
its body unit and possible subunits. A new declaration unit is inserted in the sublibrary, together 
with an empty body unit. 

Compilation of a library unit which is a subprogram body 

A subprogram body in a compilation unit is treated as a secondary unit if the current sublibrary 
contains a subprogram declaration or a generic subprogram declaration of the same name and this 
declaration unit is not invalid. In all other cases it will be treated as a library unit, i.c.: 

• when there is no library unit of that name 

• when there is an invalid declaration unit of that name 

• when there is a package declaration, generic package declaration, an instantiated package, or 
subprogram of that name 


Compilation of a library unit which is an instantiation 

A possible existing declaration unit of that name in the current sublibrary is deleted together with 
its body unit and possible subunits. A new declaration unit is inserted. 


Compilation of a secondary unit which is a library unit body 

The existing body is deleted from the sublibrary together with its possible subunits. A new body 
unit is inserted. 


49 





UACS-K()xS6 User's Guide 
Ada Compiler 


3) The inslaniialion appears in an earlier compilation unit than the first constraint-requiring 
construction of the generic unit, which in that ease will appear in the generic tody or a 
subunit. If the instantiation has been accepted, the instantiation will correspond to the 
generic declaration only, and not include the body. Nevertheless, if the generic unit and 
the instantiation arc located in the same sublibrary, then the compiler will consider it an 
error. An error message will be issued with the constraint-requiring construct and will refer 
to the illegal instantiation. The unit containing the instantiation is not changed, however, 
and will not be marked as invalid. 


5.6 Uninitialized Variables 

Use of uninitialized variables is not flagged by the compiler. The effect of a program that refers 
to the value of an uninitialized variable is undefined. A cross-reference listing may help to find 
uninitialized variables. 


5.7 Program Structure and Compilation Issues 

The following limitations apply to the DACS-80x86 Ada Compiler Systems for the Real Address 

Mode and 286 protected mode only: 

• The Ada compiler supports a "modified large" memory model for data references. The 
"modified large" memory model associates one data segment for each hierarchical sublibrary in 
the Ada program library. All package data declared within a sublibrary is efficiently referenced 
from Ada code compiled into the same sublibrary. A slight increase in code size results from 
referencing package data compiled into a different hierarchical level. Intel’s medium memory 
model can thus be obtained by utilizing only one level of Ada program library, the root 
sublibrary. 

• The Ada compiler supports a large memory model for executable code. Although the size of 
a single compilation unit is restricted to 32K words, the total size of the code portion of a 
program is not restricted. 

• The space available for the static data of a compilation unit is 64K - 20 bytes. 

• The space available for the code generated for a compilation unit is limited to 32K words. 

• Any single object cannot exceed 64K - 20 bytes. 

The following limitations apply to all DACS-80x86 products: 

• Each source file can contain, at most, 32,767 lines of code. 

• The name of compilation units and identifiers may not exceed the number of characters given 
in the INPUT_LINELENGTH parameter of the configuration file. 

• An integer literal may not exceed the range of LONG_INTEGER, a real literal may not exceed 
the range of LONG_FLOAT. 


51 










6 THE ADA LINKER 


The DACS linker must be executed to create an executable program in the target environment. 
Linking is a two stage process that includes an Ada link using the compilation units in the Ada 
program library, and a target link to integrate the application code, run-time code, and any 
additional configuration code developed by the user. The linker performs these two stages with a 
single command, providing options for controlling both the Ada and target link processes. 

This chapter describes the link process, except for those options that configure the Run-Time 
System, which is described in detail in Chapter 7. 


6.1 Invoking the Linker 

Enter the following command at the shell to invoke the linker: 

$ ada_link (<option>) <unit-name> 
where the options and parameters arc: 

Ada Linker Options 


OPTION 

DESCRIPTION 

* 

REFERENCE 

-[nojdebug 

Links an application for use with the 

6.5.11 

-enable_task_trace 

DACS-80x86 Symbolic Cross Debugger. 

Enables tract when a task terminates in 

6.5.28 

-exception_space 

unhandled exception. 

Defines area for exception handling in task stack. 

6.5.29 

-[no]extract 

Extracts Ada Object modules 

6.5.14 

-interrupt_entry_table 

Range of interrupt entries. 

6.5.27 

-library 

The library used in the link. 

6.5.7 

-lno]log 

Specifies creation of a log file. 

6.5.9 

-lt_segment_size 

Library task default segment size. 

6.5.23 

-It_stack_size 

Library task default stack size. 

6.5.22 

-mpsegmentsize 

Main program segment size. 

6.5.25 

-mpstacksize 

Main program stack size. 

6.5.24 

-[no]npx 

Use of the 80x87 numeric coprocessor. 

6.5.16 

•options 

Specifies target link options. 

6.5.6 

-priority 

Default task priority. 

6.5.18 

-reserve_stack 

Size of reserve stack. 

6.5.21 

-rms 

Select Rate Monoionic Scheduling Run-Time 

6.5.13 

-(nojrootextract 

Kernel (optional). 

Using non-DDC-I units in the root library. 

6.5.10 


53 








DACS-K0x86 User’s Guide 
The Ada Linker 


The firsl process consliluics the Ada link process and the second constitutes the target link 
process. 

i iK ,\da link process 

• retrieves the required Ada object modules from llic program library, 

• determines an elaboration order for all Ada units, 

’ creates a module containing the User Configurable Data (UCD) from the specified configuration 
options to the linker and 

• creates a shell script dial carries out the target link process (i.c., dlnkbldx86). The locate/build 
phase is an integral part of the target link. 


If the option -stop_bcfore_link is NOT specified (default), the above script is executed 
•i 1 ! 1 ' malically. Otherwise the linking process is halted at diis point. 

whew -stop_before_link is specified, all temporary files arc retrieved for inspection or 
modification. The target linker is invoked by executing the shell script. 


6.2.1 Temporary Files 

Viv. following temporary files are in use during the link phase: 

<jiiaiii_program>_link.com The shell script which invokes the target linker. 

<main_program>_clabcodc.o The object code for the calling sequence of the elaboration 

code. 

<main_program>_ucd.o The object code generated from the RTS configuration 

options (see Section 7.2). 

<main_program>_uxxxxx.o The Ada object modules which have been extracted from the 

program library, xxxxx is the unit number of the Ada unit. 


55 







DACS-K0xX6 User’s Guide 
The Ada Linker 


The output of the linker slop is an absolute executable object file with the extension “ dal" and 
a map file with the extension ".mp5". 


6.2.2 Environmental Variables 

When a link is executed, a number of files arc referred to and most arc accessed through 
environmental variables. The locatc/build phase uses ihc control file $ada_ucc_dir/config.bld_ddci, 
the remaining variables are: 


VARIABLE 

PURPOSE 

ada_systcm_library 

Identifies the root library where the system compilation units reside. 

adajibrary 

Identifies the default library used by all DACS-80x86 tools. It is the 
lowest level sublibrary in the program library hierarchy. 

ada_root_lib 

Identifies the OMF library where the system library units have been 
extracted from the system library. By having a separate Library for the 
root compilation units, the link process is much faster than otherwise 
having to extract each unit from the system library for each link. 

ada_rll Jib 

Identifies the OMF library for the Permanent Part of the non-tasking 
version of the Run-Time System. 

ada_rl2Jib 

Identifies the OMF library for the Permanent Part of the tasking version 
of the Run-Time System. 

ada_rl3_lib 

Identifies the OMF library for the Permanent Pan of the optional Rale 
Monotonic scheduling Run-Time System. 

ada_ucc_lib 

Identifies the OMF library for the User Configurable Code ponion of 
the Run-Time System. 

ada_icmplatc 

Identifies the template file for the Linker. 

ada_ucc_dir 

Identifies the directory of the current UCC. 


With each of these environmental variables, the name will differ depending on how the system 
was installed (ada86, adal86 etc). Throughout this document ada is assumed. For example, the 
environmental variables for the root library for the 80186 version of the compiler would be 
adalS6_root_lib, and the RTS UCC library' environmental variables for the 8086 version would 
be ada86_ucc_!ib. 


57 







DACS-K0xK6 User's Guide 
The Ada Linker 


• Run-Time Library Routines 

• Package CALENDAR support routines 


The run-time system (RTS) can be configured by the user through Ada Linker command options. 
The Ada Linker will generate appropriate data structures to represent the configured characteristics 
(UCD). 

Two versions of the RTS arc supplied, one including tasking and one excluding tasking. The 
linker selects die RTS version including tasking only if the option -tasks is present or -tasks n 
is present and n > 0. Odicrwisc, the linker selects die RTS version excluding tasking. 


6.4 Linker Elaboration Order 

The elaboration order is primarily given by the unit dependencies, but this leaves some freedom 
here and there to arbitrarily choose between two or more alternatives. This arbitrary is in the 
DACS-80x86 linker controlled by the spelling of the involved library units, in order for "free" 
units to become alphabetically sorted. 

Recompiling from scratch, an entire system may thus affect the allocation of unit numbers, but the 
elaboration order remains the same. 

It is also attempted to elaborate "body after body", so that a body having a with to a specification, 
will be attempted elaborated after the body of this specification. 

Also elaboration of units from different library levels is attempted to complete elaboration of a 
father-level prior to the son-level. 

This strategy should in many cases reduce the need for resetting pragma ELABORATE. 


6.5 Ada Linker Options 

This section describes in detail the Ada linker option and parameters. 


6.5.1 The Parameter <unit-name> 

<unit-name> 

The <unit_namc> must be a library unit in the current program library, but not necessarily of the 
current sublibrary. 

Note that a main program must be a procedure without parameters, and that <unit-name> is the 
identifier of the procedure, not a file specification. TTte main procedure is not checked for 
parameters, but the execution of a program with a main procedure with parameters is undefined. 


59 



DACS-80x86 User’s Guide 
The Ada Linker 


Examples: 

$ ada-link -scarchlib interfacejib p 

Links the subprogram p, resolving referenced symbols first with tire target library interfacejib 
and then with the standard RTS target library. 


6.5.5 -stop_before_link 
-stop_bcfore_link 

The -stop_beforc_link option allows the user to introduce assemblers and linkers from third 

panics or to otherwise configure the link to suit the application. The link is halted with the 

following conditions: 

• The user configurable data file, <main>_ucd.o, is produced with the default or user specified 
linker option values included. 

• The elaboration code is contained in the <main>_clabcodc.o file. 

• The shell script file that contains the link command is present and has not been executed. The 
file's name is <main>_link.com. 

• The temporary Ada object file(s) used by the target linker are produced. These objects arc 
linked and deleted when <main>_link.com is executed. 

• With -selectivejink the object files comprise all Ada units including those from the root 
library. At this point it is possible to disassemble the "cut" object files using -object with the 
disassembler. 

To complete the link, the <main>_link.com script must be executed. To use third party tools, this 

file may have to be modified. 


6.5.6 -options 

-options <parameter> 

•options allow the user to pass options onto the target linker. 


61 






DACS-X0xX6 User's Guide 
Tlic Ada Linker 


• The number of each ly|>c of diagnostic message. 

• A termination message, staling if the linking was terminated successfully or unsuccessfully or 
if a consequence examination was terminated. 

• Diagnostic messages and warnings arc written on the log file. 


If recompilations arc required (as a result of the consistency cltcck) a text file is produced 
containing excerpts of the log file. The name of this text file is written in die log file line 8. 


The log file consists of: 

• Header consisting of die linker name, the linker version number, and the link time. 

• The elaboration order of the compilation units. The units arc displayed in the order elaborated 
with the unit number, compilation lime, unit type, dependencies, and any linking errors. 

• If recompilations arc required, the units that must be recompiled arc listed along with its unit 
type and sublibrary level. 

• The linking summary that includes the main unit name, the program library, any recompilations 
that are required, and if any errors or warnings occurred. 


6.5,10 -[no]root_extract 
-root-extract 

-noroot_extract (default) 

The units contained in the Ada system library supplied by DDC-I have been extracted and inserted 
into the $ada_root_lib OMF Library, thus eliminating extractions from the system library at link 
time and improving link performance. 

The user should normally not modify or compile into the Ada system library supplied by DDC-I. 
If however, a unit is compiled into the Ada system library, the Sada_root_lib will no longer 
match the Ada system library and -root_extract must be specified in order to link from the Ada 
system library. 


6.5.11 -[no]debug 
-debug 

-nodebug (default) 

The -debug option specifics that debug information is generated. The debug information is 
required to enable symbolic debugging. If -nodebug is specified, the Ada linker will skip the 
generation of debug information, thus saving link lime, and will not insert the debug information 


63 



DACS-X0x86 User’s Guide 
The Ada Linker 


6.5.15 -template 

-template <filc-namc> 

•template $ada_tcmplate (default) 

The template file is known to the linker via the environmental variable ada template. DDC-1 
supplies a default template file as part of the standard release system. Please refer to appendix H 
for detailed information. 


6.5.16 -npx 

-npx (default) 

•nonpx 

The -npx option specifics dial the 80x87 (8087, 80287, or 80387) numeric coprocessor is used 
by the Ada program. When -npx is specified, the 80x87 is initialized by the task initialization 
routine, the floating point stack is reset during exception conditions, and the 80x87 context is 
saved during a task switch. 


Configurable Data 


A 16 bit boolean constant is generated by the Ada Linker: 


CD NPX USED 


boolean 


= 0 - 80x87 is not used 

= 1 - 80x87 is used 


6.5.17 -tasks 
•tasks [n] 

(default is no tasking) 

This option specifics the maximum number of tasks allowed by the RTS. If specified, n must be 
greater than zero. If -tasks is specified without a value for n, n defaults to 10. If -tasks is not 
specified, the RTS used will not include support for tasking. If -tasks is specified, the RTS used 
will include support for tasking. 

Ada Interrupt tasks identified with pragma INTERRUPT_HANDLER need not be included in the 
count of maximum number of tasks. The main program must be counted in the maximum number 
of tasks. Note that the main program, which may implicitly be considered a task, will not run 
under control of the tasking kernel when -notasks is specified. See also -rms option. 


Configurable Data 

For -tasks, the linker generates the following configurable data: 


65 



DACS-KOxXfi User's Guide 
The Ada Linker 


6.5.19 -timc_slice 

-fimcjdict |r| (default no time slicing is active) 

The -timeslice options specifics whether or not time slicing will be used for tasks. If specified, 
R is a decimal number of seconds representing the default time slice to be used. If R is not 
specified, the default time s'.iwC will be 1/32 of a second. R must be in the range Duration'Small 
< R < 2.0 and must be greater than or equal to the -timer linker option value. Time slicing only 
applies to tasks running at equal priority. Because the RTS is a preemptive priority scheduler, the 
highest priority task will always run before any lower priority task. Only when two or more tasks 
arc running at the same priority is lime slicing applied to each task. 

Time slicing can be specified on a per task basis dynamically at run-time. See Section E.l 
(Package RTS_EntryPoints) for more details. 

Time slicing is not applicable unless tasking is being used. This means that the -tasks option 
must be used for -time slice to be effective. 


Configurable Data 

The Ada Linker generates the following data: 


CO_TIME_SLICE_USED 

0 - No time slicing 

1 - Time slicing 


CD TIME SLICE 



• representing the number Y that satisfies Y * DURATION’SMALL = R 


Example: 

S ada_Iink -time_slice 0.125 -tasks p 

• Specifics tasks of equal priority to be time sliced each eighth of a second. 


6.5J20 -timer 
-timer R 

-timer 0.001 (default) 

The -timer option specifics the resolution of calls to the Run-Time System routine TIMER (see 
the Run-Time System Configuration Guide for DACS-80x86 for more information). The number, 
R, specifies a decimal number of seconds which have elapsed for every call to TIMER. The 
default TIMER resolution is one millisecond. R must be in the range DURATION’SMALL< R 
< 2 . 


67 








DACS-80xK6 User’s Guide 
The Ada Linker 


For each library lask, the representation spec: 


FOR Task_objcct'STORAGE_SlZE USE N; 

can be used to specify the library lask stack size. However, if die representation spec is not used, 
the default library task size specified by -lt_sfack_si/.e will be used. 

For efficiency reasons, all tasks created within library tasks will have slacks allocated within the 
same segment as the library lask stack. Normally, the segment which contains the library task 
stack is allocated just large enough to hold the default library task stack. Therefore, one must use 
the option •lt_slack_option or the pragma LT_SEGMENT_S1ZE to reserve more space within the 
segment that may be used for nested tasks* stacks. (See the implementation dependent pragma 
LT_SEG M ENT_SIZE in Section F.l for more information). 

The range of this parameter is limited by physical memory si/e, task stack size allocated during 
the build phase of the link, and lire maximum segment size (64K for all except the 386/486 
protected mode, which is 4 GB). 


Configurable Data 


The Ada Linker generates the following integer constant: 


CD LT STACK SIZE 


INTEGER 


Example: 

S ada_link -It_stack_size 2048 -tasks p 

• Link the subprogram P using a 2K words default library stack size. 


6.5.23 -lt_stack_size 
-lt_segment_size n 

-It_segment_size (lt_stack_sizc + 20 + cxcepiion_stack_spacc) (default) 

This parameter defines in words the size of a library’ task segment. The library’ task segment 
contains the task stack and the stacks of all its nested tasks. 

The default value is only large enough to hold one default task stack. If -U stack size is used and 
specifics a value other than the default value, -H_segment_size should also be specified to be the 
size of <task_stack_sizc> + 

<total_of_ncstcd_tasks_sizcs> + 

<20_words_overhead> + 
exception_stack_space. 

Note that the task stack size specified by the ’STORAGE_sizc can be representation spec or by 
the option -!t_stack_size. 

Dynamically allocated tasks receive their own segment equal in size to the mp_segmcnt_size. 


69 




DACS-X0xX6 User's Guide 
•Hie Ada Linker 


Example: 

$ ada_link -mp slack si/e 1000 p 

• Link the subprogram P with a slack of 1000 words. 


6.5.25 -mp_.segincnt_.size 

-mp scgmcnt si/.c n 
-mp_segmcnt_size 8100 (Default) 

The -mp_.scgment_.si/.e option specifies the size, in words, of the segment in which the main 
program stack is allocated. The default setting can be calculated from the formula: 

ntp_.scgmcnl_.sizc = mp_stack_sizc + 

overhead + (tasks - 1) * 

(overhead + task_storagc_sizc) 

Normally, the main program segment size can be set to the size of the main program stack. 
However, when the main program contains nested tasks, the stacks for the nested tasks will be 
allocated from the data segment which contains the main program stack. Therefore, when the 
main program contains nested tasks, the main program stack segment must be extended via the 
-mp_segment_size option. 

The range of this parameter is limited by physical memory size, task stack size allocated during 
the build phase (in tasking programs only), and the maximum segment size (64K for all except 
the 386/486 protected mode, which is 4 GB). 

Note: Dynamically allocated tasks receive their own segment equal in size to mp_scgment_size. 


Configurable Data 

The Ada Linker allocates the _CD_MP_STACK (see the -mp_stack_size option) within a data 
segment called _CD_MP_STACK_SEGMENT: 


CD MP STACK SEGMENT 


MP STACK 


T T T 

MP STACK START KP STACK SIZE MP SEGMENT SIZE 


Example: 

$ ada.Iink -tasks -mp_segment_size 32000 program_a 

Links the subprogram PROGRAM_A, which contains tasks nested in the main program 
allocating 32,000 words for the main program stack segment 


71 



DACS-80xK6 User's Guide 
The Ada Linker 


llic Ada program contains standard interrupt tasks for which the RTS requires the above data 
structure. You must relink the Ada program specifying the -interrupt entry_t:il>lc option. 

Example: 

$ ada.link -tasks -intcrrupt_cntry_tablc 5,20 p 

• Links the subprogram P, which has standard Ada interrupt entries numbered 5 
through 20. 


6.5.28 -(no|cnable_task_trace 

-cnable_task_trace 
-nocnabic_lask_traee (default) 

This option instructs the exception handler to produce a stack trace when a task terminates because 
of an unhandlcd exception. 


Configurable Data 

CD TRACE ENABLED 


BOOLEAN 


- 0 - task trace disabled 
*■ 1 task trace enabled 


6.5.29 -exception_space 

-cxception_space n 
-exceplion_space OaOh (default) 

Each stack will have set its top area aside for exception space. When an exception occurs, the 
exception handler may switch stack to this area to avoid accidental overwrite below the stack 
bottom (which may lead to protection exceptions) if the size of the remaining part of the stack 
is smaller than the N value. Specifying a value =0 will never cause stack switching. Otherwise an 
N value below the default value is not recommended. 


Configurable Data 


CD EXCEPTION STACX SPACE SIZE 


INTEGER 


Note that this value is added to all requests for task stack space, thus requiring an increase in the 
requirements of the appropriate segment’s size 


73 












APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type SHORT_INTEGER is range -32768 .. 32767; 

type INTEGER is range -2_147_483 648 .. 2147483647; 

type LONGINTEGER is range -2**63 .. 2**63-l; 

type FLOAT is digits 6 

range -16#0.FFFF_FF#E32 .. 16#0.FFFF_FF#E32; 

type LONG_FLOAT is digits 15 

range -16#0.FFFF_FFFF_FFFF_F8#E256 .. 16#0.FFFF_FFFF_FFFF_F8#E256; 
type DURATION is delta 2#1.0#E-14 range -131_072.0 .. 131071.0; 
end STANDARD; 


C-l 





DDC-I Ada Compiler System 
DACS Sun SPARC/SunOS to 80x86 Bare 
Ada Cross Compiler System 
User’s Guide 


APPENDIX F 






APPENDIX F - IMPLEMENTATION-DEPENDENT CHARACTERISTICS 


This appendix describes the implementation-dependent characteristics of DACS-80X86™ as required 
in Appendix F of the Ada Reference Manual (ANSI/MIL-STD-1815A). 


F.l Implementation-Dependent Pragmas 

This section describes all implementation defined pragmas. 


F.1.1 Pragma INTERFACE-SPELLING 

This pragma allows an Ada program to call a non-Ada program whose name contains characters 
that are invalid in Ada subprogram identifiers. This pragma must be used in conjunction with 
pragma INTERFACE, i.c., pragma INTERFACE must be specified for the Ada subprogram name 
prior to using pragma INTERFACE_SPELLING. 

The pragma has the format: 

pragma INTERFACE_SPELLING (subprogram name, string literal); 

where the subprogram name is that of one previously given in pragma INTERFACE and the string 
literal is the exact spelling of the interfaced subprogram in its native language. This pragma is 
only required when the subprogram name contains invalid characters for Ada identifiers. 

Example: 

function R?S_GetDataSegment return Integer; 
pragma INTERFACE (ASM86, RTS_GetDataSegment); 

pragma INTERFACE_SPELLING (RTS_GetDataSegment, "RlSMGS?GetDataSegment"); 

The string literal may be appended 'NEAR (or ’FAR) to specify a particular method of call. The 
default is TAR. This suffix should only be used, when the called routines require a near call 
(writing ’FAR is however harmless). If ’NEAR is added, the routine must be in the same segment 
as the caller. 


F.1.2 Pragma LT_SEGMENT_SIZE 

This pragma sets the size of a library task stack segment. 

The pragma has the format: 

pragma LT_SEGMENT_SIZE (T. N); 

where T denotes either a task object or task type and N designates the size of the library task 


193 










DACS-80&S6 User’s Guide 
Implementation-Dependent Characteristics 


stack segment in words. 


The library task's stack segment defaults to the size of the library task stack. The size of die 
library task stack is normally specified via the representation clause (note that T must be a task 
type) 


for T’STORAGE_SIZE use N; 

The size of the library task stack segment determines how many tasks can be created which arc 
nested within the library task. All tasks created within a library task will have their stacks 
allocated from the same segment as the library task stack. Thus, pragma LT_SEGMENT_S1ZE 
must be specified to reserve space within the library task stack segment so that nested tasks' 
stacks may be allocated (see section 7.1). 

The following restrictions arc places on the use of LT_SEGMENT_SIZE: 

1) It must be used only for library tasks. 

2) It must be placed immediately after the task object or type name declaration. 

3) The library task stack segment size (N) must be greater than or equal to the library task 
stack size. 


F.1.3 Pragma EXTERNAL-NAME 


F.l.3.1 Function 

The pragma EXTERNAL_NAME is designed to make permanent Ada objects and subprograms 
externally available using names supplied by the user. 


F.l.3.2 Format 

The format of the pragma is: 

pragma EXTERNAL_NAME(<ada_entity>,<extemal name>) 
where <ada_entity> should be the name of: 

• a permanent object, i.e. an object placed in the permanent pool of the compilation unit - such 
objects originate from package specifications and bodies only, 

• a constant object, i.e. an object placed in the constant pool of the compilation unit - please 
note that scalar constants arc embedded in the code, and composite constants are not iways 
placed in the constant pool, because the constant is not considered constant by the compiler. 


194 








DACS-80xS6 User’s Guide 
Implementation-Dependent Characteristics 


• a subprogram name, i.e. a name of a subprogram defined in this compilation unit - please 
notice that separate subprogram specifications cannot be used, the code for the subprogram 
must be present in the compilation unit code, and where the <cxicmal namc> is a string 
specifying the external name associated the <ada_cntity>. The <cxtcmal namcs> should be 
unique. Specifying identical spellings for different <ada_cntitics> will generate errors at compile 
and/or link time, and the responsibility for this is left to -the user. Also the user should avoid 
spellings similar to the spellings generated by the compiler, c.g. E_xxxxx_yyyyy, P_xxxxx, 
C_xxxxx and other internal identifications. The target debug type information associated with 
such external names is the null type. 


F.1JJ Restrictions 

Objects that arc local variables to subprograms or blocks cannot have external names associated. 
The entity being made external ("public") must be defined in the compilation unit itself. Attempts 
to name entities from other compilation units will be rejected with a warning. 

When an entity is an object the value associated with the symbol will be the relocatable address 
of the first byte assigned to the object. 


F.l.3.4 Example 

Consider the following package body fragment: 

package body example is 

subtype stringlO is string(1..10); 

type s is 
record 

len : integer; 
val : stringlO; 
end record; 

global_s : s; 

const_s : constant stringlO := "1234567890"; 

pragma EXTERNAL_NAME(global_s, "GL0BAL_S_08JECT”); 
pragma EXTERNAL_NAME<const_s, "CONST_S"); 

procedure handle!...) is 

end handle; 

pragma EXTERNAL_NAME(handle, "HANDLE PROC"); 


end example; 


The objects GLOBAL_S and CONST_S will have associated the names ”GLOBAL_S_OBJECT" 
and "CONST_S". The procedure HANDLE is now also known as "HANDLE_PROC". It is 


195 








DACS-K0x86 User's Guide 
Implementation-Dependent Characteristics 


allowable to assign more than one external name to an Ada entity. 


F.l.3.5 Object Layouts 

Scalar objects arc laid out as described in Chapter 9. For arrays the object is described by the 
address of the first element; the array constraint(s) arc NOT passed, and therefore it is 
recommended only to use arrays with known constraints. Non- discriminated records take a 
consecutive number of bytes, whereas discriminated records may contain pointers to the heap. Such 
complex objects should be made externally visible, only if the user has thorough knowledge about 
the layout. 


F.l.3.6 Parameter Passing 

The following section describes briefly the fundamentals regarding parameter passing in connection 
with Ada subprograms. For mote detail, refer to Chapter 9. 

Scalar objects are always passed by value. For OUT or IN OUT scalars, code is generated to 
move the modified scalar to its destination. In this case the stack space for parameters is not 
removed by the procedure itself, but by ’he caller. 

Composite objects are passed by reference. Records are passed via the address of the first byte 
of the record. Constrained arrays are passed via the address of the first byte (plus a bitoffset when 
a packed array). Unconstrained anrays are passed as constrained arrays plus a pointer to the 
constraints for each index in the array. These constraints consist of lower and upper bounds, plus 
the size in words or bits of each element depending if the value is positive or negative 
respectively. The user should study an appropriate disassembler listing to thoroughly understand 
the compiler calling conventions. 

A function (which can only have IN parameters) returns its result in registers). Scalar results are 
registers/float registers only; composite results leave an address in some registers and the rest, if 
any, are placed on the stack top. The stack still contains the parameters in this case (since the 
function result is likely to be on the stack), so the caller must restore the stack pointer to a 
suitable value, when the function call is dealt with. Again, disassemblies may guide the user to 
see how a particular function call is to be handled. 


F.1.4 Pragma INTERRUPT-HANDLER 

This pragma will cause the compiler to generate fast interrupt handler entries instead of the normal 
task calls for the entries in the task in which it is specified. It has the format; 

pragma INTERRUPT_HANDLER; 

The pragma must appear as the first thing in the specification of the task object. The task must 
be specified in a package and not a procedure. See Section F.6.2.3 for more details and restrictions 
on specifying address clauses for task entries. 


196 






DACS-80x86 User's Guide 
Implementation-Dependent Characteristics 



F.1.5 Pragma MONITOR_TASK 


F.l.5.1 Function 

The pragma MONITOR_TASK is used to specify that a task with a certain structure can be 
handled in a special way by the Run-Time System, enabling a very efficient context switch 
operation. 


F.l.5.2 Format 
The format of the pragma is 
pragma MONITOR_TASK; 

The pragma must be given in a task specification before any entry declarations. 


F.l.5.3 Restrictions 

The following restrictions apply on tasks containing a pragma MONlTOR_TASK : 

• Only single anonymous tasks can be "monitor tasks". 

« Entries in "monitor tasks" must be single entries (i.e. not family entries). 

• The task and entry attributes are not allowed for "monitor tasks" and "monito. task" entries. 

• The declarative part> shou71d only contain declaration of objects; no types or nested snrrctures 
must be used. 

• The structure of the task body must be one of the following: 

x. 

task body KON_TASK Is 
declarative part> 
begin 

<statement llst> 
loop 
select 

accept ENTRY Kparameter_llst> [do 
end]; 
or 

accept ENTRY_2<parameter_llst> [do 
<statenent_list> 
end]; 
or 

terminate 
end select; 
end loop; 
end; 


where each entry declared in the specification must be accepted unconditionally exactly once. 


197 







DACS-80x86 User's Guide 
Implementation-Dependent Characteristics 



2. 

task body HON_TASX Is 
declarative part> 
begin 

otatement llst> 
loop 

accapt HON_ENTAY<pararoeter_llst>(do 
<stateraent_list> 

•ndl; 
and loop; 
and; 

where the task only has one entry. 

In both eases the declarative parts, the statement lists and the parameter lists may be empty. 
The statement list can be arbitrarily complex, but no nested select or accept statements are 
allowed. 

No exception handler in the monitor task body can be given. 

The user must guarantee that no exceptions arc propagated out of the accepts. 


F.l.5.4 Example 

The following tasks can be defined 

task LISTJ5ANDLER is 

pragma MONITOR_TASK; 
entry INSERT (eIem.E 1.EM TYPE); 
entry REMOVE(ELSM:out ELEMJTYFE); 
entry IS PRESENT(ELEM:ELEM_TYPE; 

RESULT:out BOOLEAN); 

end LIST_HANDLER; 

task body LIST_HANDLER Is 
"define list" 

begin 

"Initialize list" 
select 

accept INSERT(ELEM:ELEM_TYPE)do 
"Insert in list" 
end INSERT; 
or 

accept REMOVE(ELEM:out ELEM_TYPE)do 
"find in list and remove from list" 
end REMOVE 
or 

accept IS_PRESENT(ELEM:ELEM_TYPE 

RES: out BOOLEAN)do 

"scan list" 
end IS_PRESENT; 
or 

terminate, 
end select 

end MON TASK; 


The task can be used 

task type•LIST_OS£R is 

end LIST_USER; 

task body LIST_OSER Is 


198 



DAL'S-SUxSO Lscr s OuuJc 
Implementation-Dependent Characteristics 



begin 

select 

LISTJ3AHDLER . INSERT (riRST_ELEM) ; 

alaa 

raise INSERT_ERROR; 
and aalact; 
loop 

LI ST_8ANDLER. INSERT <NEXT_£LEM) ; 
and loop; 
and LIST USER; 


F.l.C Pragma TASK_STORAGE_SIZE (T, N) 

This pragma may be used as an alternative to the attribute ’TASK_ST0RAGE_S1ZE to designate 
the storage size (N) of a particular task object (T) (see section 7.1). 


F.2 Implementation-Dependent Attributes 
No implementation-dependent attributes arc defined. 


F 3 Package SYSTEM 

The specifications of package SYSTEM for all DACS-80x86 in Real Address Mode and 
DACS-80286PM systems are identical except that type Name and constant System_Name vary: 


Compiler Svstem 


System Name 


DACS-8086 
DACS-80186 
DACS-80286 Real Mode 
DACS-80286 Protected Mode 


iAPX86 

iAPX186 

iAPX286 

iAPX286_PM 


Below is package system for DACS-8086. 

package System Is 

type Word Is new integer; 

type DWord Is new Long_lnteger; 

type UnslgnedWord Is range 0..65535; 

for UnslgnedWord*SIZE use 16; 

type byte Is range 0..255; 

for byte'SIZE use 8; 

subtype SegmentId Is UnslgnedWord; 

type Address Is 

record 

offset : UnslgnedWord; 
segment : Segmentld; 
end record; 

subtype Priority Is Integer range 0..31; 


199 


DACS-80x86 User’s Guide 
Implementation-Dependent Characteristics 


type Name Is (1AFX86); 

SYSTEM_NAME : constant Name 
STORAGE OMIT : constant 
MEMORY_IlZE : constant 
M1N_INT : constant 

MAX“lNT : constant 

MAX~DIGITS : constant 
HAX~HANTISSA : constant 
FINE_DELTA : constant 
TICK : constant 

type Interface_languaga Is 

(ASM86, PLM86, C86, C86_R£VERSE, 

ASM_ACF, PLM_ACF, C_ACF, C_R£VERSE_ACF, 
ASM_N0ACF, PLM~NOACF, C~NOACF, C~REVERSE_NOACF) ; 

typ« Excaptlonld Is racord 

unit_number : OnslgnadWord; 
unlqus_number : OnslgnadWord; 
and racord; 

type Taslvalue is naw Intagar; 

type AccTaskValue Is accass TaskValua; 
type SamaphoraValua Is naw Intagar; 

type Semaphore Is racord 

counter 
first 
last 
SQNext 

end racord; 

InitSamaphore : constant Semaphore :- Semaphore'(1,0,0, 0) ; 
end System; 


The package SYSTEM specification for DACS-80386PM package system is: 

package System is 

type Word is naw Short_Integer; 

type DWord is new integer; 

type QWord is new Long_Intsger; 

type OnslgnadWord is range 0..65535; 

for OnslgnedKord' SIZE use 16; 

type OnsignedDWord is range 0..16IFFFF_FFFFI; 

for OnsignedDWord'SIZE use 32; 

type Byte is range 0..255; 

for Byte'SIZE use 8; 

subtype Segmentld is OnslgnadWord; 

type Address is 

record 

offset : OnsignedDWord; 
segment ; Segmentld; 
end record; 


for Address use 
record 

offset at 0 ranga 0..31; 
segment at 2 range 0..1S; 
end record; 


subtype Priority Is Integer range 0..31; 


: Integer; 

: TaskValue; 

: TaskValue; 

: Semaphorevalue; 

— only used in KDS. 


- 16; 

- 1_048 576; 

- -2_147_«83_647-1; 

- 2_147_483_647; 

- 15; 

- 31; 

- 2I1.0IE-31; 

- 0.000 000 125; 



200 





Implementation-Dependent Characteristics 



type Nana Is (1 APX386_PM) ; 

SYSTEMNAME : constant Nana 1APX386 PM; 

STORAGE_ONIT : constant IS; 

MEMORY_SIZE : constant 16U_0000_0000t; 

MIN INT : constant -1S#8000_0000_0000_0000»; 

HAX - INT : constant 16l7FFF_FFrF_FFFF_FFFr#; 

MAX_DIGITS ; constant 15; 

MAX~HANTISSA : constant 31; 

FINE_DELTA : constant 2I1.0IE-31; 

TICK - : constant 0.000 000 082 5; 


type Interface_languege Is 

(ASMS 6, PLM86, CSS, CSS REVERSE, 

ASM_ACF, PEM_ACF, C_ACF, C_R£VERSE_ACF, 

ASM~NOACF, PLM~NOACF, C~NOACF, C~REVERSE - NOACF) ; 

typa Excaptlonld Is racord 

unlt_numbor ; OnslgnadDWord; 
unlque_number : OnslgnadDWord; 
and record; 

type TaskValua Is naw Integer; 

typa AccTaskValue Is access Taskvalua; 

type SamaphoreValua Is naw Intagar; 

type Semaphore Is record 

counter 
first, last 
SQNext 

end record; 

InitSemaphore : constant Semaphore Semaphore'(1,0,0,0) ; 
end System; 


F.4 Representation Clauses 

The DACS-80x86™ fully supports the ’SIZE representation for derived types. The representation 
clauses that are accepted for non-derived types are described in the following subsections. 


F.4.1 Length Clause 

Some remarks on implementation dependent behavior of length clauses arc necessary: 

• When using the SIZE attribute for discrete types, the maximum value that can be specified is 
16 bits. For DACS-80386PM/80486PM the maximum is 32 bits. 

• SIZE is only obeyed for discrete types when the type is a part of a composite object, e.g. 
arrays or records, for example: 

type byte is range 0..255; 
for byte'size use 8; 

sixteen_bits_allocated : byte; — one word allocated 


: Integer; 

: TasXValue; 

; SemaphoreValue; 

— only used In HDS. 


201 




vr»V^ UVAOU U.H.I 3 VJUlUt 

Implementation-Dependent Characteristics 


eight_bit_per_element : array(0..7) of byte; -- four words allocated 
type rec is 
record 

cl,c2 : byte; -- eight bits per component 

end record; 


• Using the STORAGE_SIZE attribute for a collection will set an upper limit on the total size 
of objects allocated in this collection. If funher allocation is attempted, the exception 
STORAGE_ERROR is raised. 

• When STORAGE_SIZE is specified in a length clause for a task type, the process stack area 
will be of the specified size. The process stack area will be allocated inside the "standard" stack 
segment. Note that ST0RAGE_S1ZE may not be specified for a task object. 


F.4.2 Enumeration Representation Clauses 

Enumeration representation clauses may specify representations in the range of -32767..+32766 (or 
-16#7FFF..16#7FFE). 


F.4J Record Representation Clauses 

When representation clauses are applied to records the following restrictions are imposed: 

• if the component is a record or an unpacked array, it must start on a storage unit boundary 
(16 bits) 

• a record occupies an integral number of storage units (words) (even though a record may have 
fields that only define an odd number of bytes) 

• a record may take up a maximum of 32K bits 

• a component must be specified with its proper size (in bits), regardless of whether the 
component is an array or not (Please note that record and unpacked array components take up 
a number of bits divisible by 16 (=word size)) 

• if a non-array component has a size which equals or exceeds one storage unit (16 bits) the 
component must start on a storage unit boundary, i.e. the component must be specified as: 

component at N range 0..16 * M - 1; 

where N specifies the relative storage unit number (0,1,...) from the beginning of the record, and 

M the required number of storage units (1,2,...) 

• the elements in an array component should always be wholly contained in one storage unit 

• if a component has a size which is less than one storage unit, it must be wholly contained 
within a single storage unit: 


202 


Mtuiiuii l/\. |/vi tuv. * «» \.iiaiuvivii.'>iiwo 





componcm al N range X .. Y; 

where N is as in previous paragraph, and 0 <= X <= Y <= 15. Note that for tins restriction 
a component is not required to start in an integral number of storage units from the beginning 
of the record. 

If the record type contains components which arc not covered by a componcm clause, they arc 
allocated consecutively after the component with the value. Allocation of a record component 
without a component clause is always aligned on a storage unit boundary. Holes created because 
of component clauses arc not otherwise utilized by the compiler. 

Pragma pack on a record type will attempt to pack the components not already covered by a 
representation clause (perhaps none). This packing will begin with the small scalar components and 
larger components will follow in the order specified in the record. Tire packing begins at the first 
storage unit after the components with representation clauses. 


F.4J.1 Alignment Clauses 

Alignment clauses for records arc implemented with the following characteristics: 

• If the declaration of the record type is done at the outermost level in a library package, any 
alignment is accepted. 

• If the record declaration is done at a given static level higher than the outermost library level, 
i.e., the permanent area), only word alignments arc accepted. 

• Any record object declared at the outermost level in a library package will be aligned according 
to the alignment clause specified for the type. Record objects declared elsewhere can only be 
aligned on a word boundary. If the record type is associated with a different alignment, an 
error message will be issued. 

• If a record type with an associated alignment clause is used in a composite type, the alignment 
is required to be one word; an error message is issued if this is not the case. 


F.5 Implementation-Dependent Names for Implementation Dependent Components 
None defined by the compiler. 


F.6 Address Clauses 

This section describes the implementation of address clauses and what types of entities may have 
their address specified by the user. 


203 


DACS-80x86 User's Guide 
Implementation-Dependent Characteristics 



F.6.1 Objects 

Address clauses are supported for scalar and composite objects whose size can be determined at 
compile time. The address clause may denote a dynamic value. 


F.6.2 Task Entries 

The implementation supports two methods to equate a task entry to a hardware interrupt through 
an address clause: 

1) Direct transfer of control to a task accept statement when an interrupt occurs. This form 
requires the use of pragma INTERRUPT_HANDLER. 

2) Mapping of an interrupt onto a normal conditional entry call. This form allows the interrupt 
entry to be called from other tasks (without special actions), as well as being called when 
an interrupt occurs. 


F.6.2.1 Fast Interrupt Tasks 

Directly transferring control to an accept statement when an interrupt occurs requires the 
implementation dependent pragma INTERRUPT_HANDLER to tell the compiler that the task is 
an interrupt handler. 


F.6.2.2 Features 

Fast interrupt tasks provide the following features: 

• Provide the fastest possible response time to an interrupt. 

• Allow entry calls to other tasks during interrupt servicing. 

• Allow procedure and function calls during interrupt servicing. 

• Docs not require its own stack to be allocated. 

• Can be coded in packages with other declarations so that desired visiblity to appropriate parts 
of the program can be achieved. 

• May have multiple accept statements in a single fast interrupt task, each mapped to a different 
interrupt. If more than one interrupt is to be serviced by a single fast interrupt task, the accept 
statements should simply be coded consecutively. See example 2 how this is done. Note that 
no code outside the accept statements will ever be executed. 


204 








DACS-80x86 User's Guide 
Implementation-Dependent Characteristics 



F.6.2J Limitations 

By using the fast interrupt feature, the user is agreeing to place certain restrictions on the task in 

ondcr to speed up the software response to the interrupt. Consequently, use of this method to 

capture interrupts is much faster titan the normal method. 

The following limitations arc placed on a fast interrupt task: 

• It must be a task object, not a task type. 

• The pragma must appear first in the specification of the task object. 

• All entries of the task object must be single entries (no families) with no parameters. 

• The entries must not be called from any task. 

• The body of the task must not contain any statements outside the accept statcmcnt(s). A loop 
statement may be used to enclose the accept(s), but this is meaningless because no code outside 
the accept statements will be executed. 

• The task may make one entry call to another task for every handled interrupt, but the call must 
be single and parameterless and must be made to a normal tasks, not another fast interrupt 
task. 

• The task may only reference global variables; no data local to the task may be defined. 

• The task must be declared in a library package, i.e., at the outermost level of some package. 

• Explicit saving of NPX state must be performed by the user within the accept statement if such 
state saving is required. 


F.6.2.4 Making Entry Calls to Other Tasks 

Fast interrupt tasks can make entry calls to other normal tasks as long as the entries arc single (no 
indexes) and paramcierless. 

If such an entry call is made and there is a possibility of the normal task not being ready to 
accept the call, the entry call can be queued to the normal task’s entry queue. This can be forced 
by using the normal Ada conditional entry call construct shown below: 

accept E do 
select 
T.E; 
else 

null; 

end select; 
end E; 

Normally, this code sequence means make the call and if the task is not waiting to accept it 
immediately, cancel the call and continue. In the context of a fast interrupt task, however, the 
semantics of this construct are modified slightly to force the queuing of the entry call. 


205 







DACS-80x86 User’s Guide 
Implementation-Dependent Characicristics 


If an unconditional entry call is made and the called task is not wailing at the corresponding 
accept statement, then the intcmipl task will wail at the entry calf. Alternatively, if a timed entry 
call is made and the called task docs not accept the call before the delay expires, then tire call 
will be dropped. The conditional entry call is the preferred method of making task entry calls 
from fast interrupt handlers because it allows lire interrupt service routine to complete straight 
through and it guarantees queueing of the entry call if the called Dsk is not waiting. 

When using this method, make sure that the interrupt is included in the -intcrrupt cntry table 
specified at link time. Sec Section 7.2.15 for more details. 


F.6.2.5 Implementation of Fast Interrupts 

Fast interrupt tasks arc not actually implemented as true Ada tasks. Rather, they can be viewed 
as procedures that consist of code simply waiting to be executed when an interrupt occurs. They 
do not have a state, priority, or a task control block associated with them, and are not scheduled 
to "run" by the run-time system. 

Since a fast interrupt handler is not really a task, to code it in a loop of somckmd is meaningless 
because the task will never loop; it will simply execute the body of the accept statement whenever 
the interrupt occurs. However, a loop construct could make the source code more easily understood 
and has no side effects except for the generation of the executable code to implement to loop 
construct 


F.6.2.6 Flow of Control 

When an interrupt occurs, control of the CPU is transferred directly to the accept statement of the 
task. This means that the appropriate slot in the interrupt vector table is modified to contain the 
address of the corresponding fast interrupt accept statement. 

Associated with the code for the accept statement is 

at the very beginning: 

code that saves registers and sets (E)BP to look like a frame where the interrupt return 
address works as return address, 

at the very end: 

code that restores registers followed by an 1RET instruction. 

Note that if the interrupt handler makes an entry call to another task, the interrupt handler is 
completed through the IRET before the rendezvous is actually completed. After the rendezvous 
completes, normal Ada task priority rules will be obeyed, and a task context switch may occur. 

Normally, the interrupting device must be reenabled by receiving End-Of-lnterrupt messages. These 
can be sent from machine code insertion statements as demonstrated in Example 7. 




DACS-80x86 User's Guide 
Implementation-Dependent Characteristics 




F.6.2.7 Saving NPX State 

If the interrupt handler will perform floating point calculations and the state of the NPX must be 
saved because other tasks also use the numeric coprocessor, calls to the appropriate savc/rcstorc 
routines must be made in the statement list of the accept statement. These routines arc located 
in package RTS_EntryPoints and arc called RTS_Storc_NPX_Slatc and RTS_Rcstorc_NPX_Statc. 
See example 6 for more information. 


F.6.2.8 Storage Used 

This section details the storage requirements of fast interrupt handlers. 


F.6.2.9 Stack Space 

A fast interrupt handler executes off the stack of the task executing at the time of the interrupt. 
Since a fast interrupt handler is not a task it docs not have its own stack. 

Since no local data or parameters are permitted, use of stack space is limited to procedure and 
function calls from within the interrupt handler. 


F.6.2.10 Run-Time System Data 

No task control block (TCB) is created for a fast interrupt handler. 

If the fast interrupt handler makes a task entry call, an entry in the _CD_lNTERRUPT_VECTOR 
must be made to allocate storage for the queuing mechanism. This table is a run-time system data 
structure used for queuing interrupts to normal tasks. Each entry is only 10 words for 80386/80486 
protected mode compilers and 5 words for all other compiler systems. This table is created by 
the linker and is constrained by the user through the linker option -interrupt_entry_table. For 
more information, see Section F.6.2.1 on linking an application with fast interrupts. 

If the state of the NPX is saved by user code (see Section F.6.2.7), it is done so in the NPX save 
area of the TCB of the task executing at the lime of the interrupt. This is appropriate because it 
is that task whose NPX state is being saved. 


F.6.3 Building an Application with Fast Interrupt Tasks 

This section describes certain steps that must be followed to build an application using one or 
more fast interrupt handlers. 


207 







DACS-X()xX6 User’s Guide 
Implementation-Dependent Characteristics 



F.6.3.1 Source Code 

The pragma 1NTERRUPT_HANDLER which indicates that the interrupt handler is the fast form 
of intcmtpl handling and not the normal type, must be placed in the task specification as the first 
statement. 

When specifying an address clause for a fast interrupt handler, the offset should be die interrupt 
number, not the offset of the interrupt in die interrupt vector. The segment is not applicable 
(although a zero value must be specified) as it is not used by the compiler for interrupt addresses. 
The compiler will place the interrupt vector into the INTERRUPTVECTORTABLE segment. For 
real address mode programs, the interrupt vector must always be in segment 0 at execution time. 
For protected mode programs, the user specifics the interrupt vector location at build time. 

Calls to RTS_Storc_NPX_Slatc and RTS_Rcstorc_NPX_Staic must be included if the state of the 
numeric coprocessor must be saved when the fast interrupt occrus. These routines arc located in 
package RTS_EntryPoints in the root library. See example 6 for more information. 


F.6.3.2 Compiling the Program 
No special compilation options are required. 


F.6.3.3 Linking the Program 

Since fast interrupt tasks are not real tasks, they do not have to be accounted for when using the 
-tasks option at link time. In fact, if there are no normal tasks in the application, the program 
can be linked without -tasks. 

This also means that the linker options -lt_stack_size, -lt_segment_size, -mp_segment_size, and 
-task_storage_size do not apply to fast interrupt tasks, except to note that a fast interrupt task will 
execute off the stack of the task running at the time of the interrupt. 

If an entry call is made by a fast interrupt handler the interrupt number must be included in the 
-interrupt_entry_table option at link time. This option builds a table in the run-time system data 
segment to handle entry calls of interrupt handlers. The table is indexed by the interrupt number, 
which is bounded by the low and high interrupt numbers specified at link time. 


F.6.3.4 Locating/Building the Program 

For real-address mode programs, no special actions need be performed at link time; the compiler 
creates the appropriate entry in the INTERRUPTVECTORTABLE segment. This segment must be 
at segment 0 before the first interrupt can occur. 

For protected mode programs no special actions need be performed. The Ada Link automatically 
recognizes Aaa interrupt handlers and adds them to the IDT. 


208 










UAi_i-8Ux8b User's Guide 
Implementation-Dependent Characteristics 



F.6.4 Examples 

These examples illustrate how to write fast interrupt tasks and then how to build the application 
using the fast interrupt tasks. 


F.6.4.1 Example 1 

This example shows how to code a fast interrupt handler that docs not make any task entry calls, 
but simply performs some interrupt handling code in the accept body. 

Ada source: 

with System; - 
package P is 

<potcntially other dcclarations> 

task Fast_.Intcrrupt_Handler is 

pragma INTERRUPT_HANDLER; 
entry E; 

for E use at (segment => 0. offset => 10); 

end; 


<potentially other declarations> 

end P; 

package body P is 

<potentially other dcclarations> 

task body Fast_Interrupt_Handler is 
begin 

accept E do 

<handle interrupt 
end E; 

end; 

<potentially other declarations:? 1 


end P; 


with P; 

procedure Example_l is 
begin 

cmain program> 
end Example,!; 


Compilation and Linking: 


209 


DACS-S0x86 User’s Guide 
Implementation- Dependent Characteristics 



$ ada Examplc_l 

$ ada_link Example_l ! Note: no other tasks in the system in this exampte. 


F.6.4.2 Example 2 

This example shows how to write a fast interrupt handler that services more than one interrupt 


Ada source: 

with System; ' 

package P is 

task Fast_Intemipt_Handlcr is 

pragma INTERRUPT.HANDLER; 

entry El; 
entry E2; 
entry E3; 

for El use at (segment => 0, offset => 5); 

for E2 use at (segment => 0, offset => 9); 

for E3 use at (segment => 0, offset => 11); 

end; 

end P; 

package body P is 

task body Fast_Interrupt_Handler is 
begin 

accept El do 

<service interrupt 5> 
end El; 

accept E2 do 

<service interrupt 9> 
end E2; 

accept E3 do 

<service interrupt 11> 
end E3; 
end; 

end P; 


Compilation and Linking: 


210 




Implementation-Dependent Characteristics 



$ ada Examplc_2 

$ ada Jink -tasks - Example_2 # assumes application also has normal tasks (not shown) 


F.6.4J Example 3 

This example shows how to access global data and make a procedure call from within a tost 
interrupt handler. 


Ada source: 

with System: 
package P is 

A : Integer, 

task Fast_Intcrrupt_Handlcr is 

pragma 1NTERRUPT_HANDLER; 
entry E; 

for E use at (segment => 0, offset => 16#127#); 

end; 
end P; 

package body P is 
B : Integer, 

procedure P (X : in out Integer) is 
begin 

X := X + 1; 

end; 

task body Fast_Interrupt_Handler is 
begin 

accept E do 
A := A + B; 

P (A); 
end E; 

end; 
end P; 


Compilation and Linking: 

$ ada Example_3 
$ ada Jink E\ample_3 


211 




DACS-80x86 User’s Guide 
Implementation-Dependent Characteristics 


F.6.4.4 Example 4 

This example shows how to make a task entry call and force it to be queued if the called task 
is not waiting at the accept at the time of the call. 

Note that the application is linked with -tasks=2, where the tasks arc T and the main program. 
Since the fast interrupt handler is making an entry call to T, the techniques used guarantee that 
it will be queued, if necessary. This is accomplished by using the conditional call construct in 
the accept body of the fast interrupt handler and by including the interrupt in the - 
interrupt_entry_table at link time. 


Ada source: 

with System; 
package P is 

task Fast Intcrrupt_Handlcr is 

pragma INTERRUPT.HANDLER; 
entry E; 

for E use at (segment => 0, offset => 8); 

end; 

task T is 
entry E; 
end; 

end P; 

package body P is 

task body Fast_Intemipt_Handler is 
begin 

accept E do 
select 
T.E; 
else 

null; 

end select; 
end E; 

end; 

task body T is 
begin 
loop 
select 

accept E; 
or 

delay 3.0; 
end select; 
end loop; 
end; 

end P; 


212 


Implementation-Dependent Characteristics 




Compilation and Linking: 

$ ada Example_4 

$ adaJink -tasks 2 -interrupt_cntry_tablc 8,8 Example_4 


F.6.4.5 Example 5 

This example shows how to build an application for 80386/80486 protected mode programs using 
fast interrupt handlers. 


Ada source: 

with System; 
package P is 

task Fast_Intcnupt_Handler is 

pragma INTERRUPT_HANDLER; 
entry E; 

for E use at (segment => 0, offset => 17); 

end; 
end P; 

package body P is 

task body Fast_Interiupt_Handler is 
begin 

accept E do 
null; 
end E; 

end; 
end P; 


Compilation and Linking: 

S ada Examp!e_5 
S ada_link -tasks - Example_5 


213 





'•UP Implementation-Dependent Characteristics 


F.6.4.6 Example 6 

This example shows how to save and restore the state of the numeric coprocessor from within a 
fast interrupt handler. This would be required if other tasks arc using the coprocessor to perform 
floating point calculations and the fast interrupt handler also will use the coprocessor. 

Note that the state of the NPX is saved in the task control block of the task executing at the time 
of the interrupt. 

Ada source: 

with System: 
package P is 

task Fasi_lntcrrupt_Handlcr is 

pragma INTERRUPT.HANDLER; 
entry E; 

for E use at (segment => 0, offset => 25); 

end; 
end P; 

with RTS_EntryPoints; 
package body P is 

task body Fast_Interrupt_Handler is 
begin 

accept E do 

RTS_EntryPoints.Store_NPX_State; 
cuser code> 

RTS_EntryPoints.Restore_NPX_State; 
end E; 

end; 
end P; 

Compilation and Linking: 

$ ada Examp!e_6 

S ada_link -npx -tasks - Example_6 


F.6.4.7 Example 7 

This example shows how to send an End-Of-Interrupt message as the last step in servicing the 
interrupt. 


Ada source: 


214 






with System; 
package P is 

task Fastjnicrrupt Handler is 

pragma INTERRUPT.HANDLER; 
entry E; 

for E use at (segment => 0. offset => 5); 

end; 
end P; 

with Machinc_Codc; use Machinc_Code; 
package body P is 

procedure Scnd_EOI is 
begin 

machine Jnstruction’ 

(rcgisterjmmediale, m_MOV t AL, 16#66#); 
m achinc _i nstruction ’ 

(immcdiate_registcr, m_OUT, 16#0e0#, AL); 

end; 

pragma inline (Send_EOI); 

task body Fast_Interrupt_Handler is 
begin 

accept E do 
<user code> 

Scnd_EOI; 
end E; 

end; 
end P; 

Compilation and Linking; 

$ ada Example_7 
$ ada_link -tasks - Example_7 


F.6.5 Normal Interrupt Tasks 

"Normal" interrupt tasks are the standard method of servicing interrupts. In this case the interrupt 
causes a conditional entry call to be made to a normal task. 


F.6.5.1 Features 

Normal interrupt tasks provide the following features: 

1) Local data may be defined and used by the interrupt task. 


215 



, iui|nuin.nwuuii-iA;pciHKitt v_naracicnsucs 

2) May be called by other tasks with no restrictions. 

3) Can call other normal tasks with no restrictions. 

4) May be declared anywhere in the Ada program where a normal task declaration is allowed. 


F.6.5.2 Limitations 

Mapping of an interrupt onto a normal conditional entry call puts the following constraints on the 
involved entries and tasks: 

1) The affected entries must be defined in a task object only, not a task type. 

2) The entries must be single and parametcrlcss. 


F.6.S.3 Implementation of Normal Interrupt Tasks 

Normal interrupt tasks are standard Ada tasks. The task is given a priority and runs as any other 
task, obeying the normal priority rules and any time-slice as configured by the user. 


F.6.5.4 Flow of Control 

When an interrupt occurs, control of the CPU is transferred to an interrupt service routine 
generated by the specification of the interrupt task. This routine preserves the registers and calls 
the run-time system, where the appropriate intenupt task and entry are determined from the 
information in the _CD_INTERRUFT_VECTOR table and a conditional entry call is made. 

If the intenupt task is waiting at the accept statement that corresponds to the interrupt, then the 
intenupt task is scheduled for execution upon return from the interrupt service routine and the call 
to the run-time system is completed. The intenupt service routine will execute an ERJET, which 
reenables interrupts, and execution will continue with the intenupt task. 

If the interrupt task is not waiting at the accept statement that corresponds to the interrupt, and 
the intenupt task is not in the body of the accept statement that corresponds to the interrupt, then 
the entry call is automatically queued to the task, and the call to the run-time system is 
completed. 

If the interrupt task is not waiting at the accept statement that corresponds to the interrupt, and 
the interrupt task is executing in the body of the accept statement that corresponds to the interrupt, 
then the interrupt service routine will NOT complete until the interrupt task has exited the body 
of the accept statement. During this period, the interrupt will not be serviced, and execution in 
the accept body will continue with interrupts disabled. Users are cautioned that if from within 
the body of the accept statement corresponding to an interrupt, an unconditional entry call is made, 
a delay statement is executed, or some other non-deierministic action is invoked, the result will 
be erratic and will cause non-deterministic interrupt response. 

Example 4 shows how End-Of-Interrupt messages may be sent to the interrupting device. 


216 


F.6JJ Saving NPX State 


Because normal interrupt tasks arc standard tasks, the state of the NPX numeric coprocessor is 
saved automatically by the run-time system when the task executes. Therefore, no special actions 
are necessary by the user to save the state. 


F.6.5.6 Storage Used 

Tliis section describes the storage requirements of standard interrupt tasks. 

F.6.5.7 Stack Space 

A normal interrupt task is allocated its own stack and executes off that slack while servicing an 
interrupt. See the appropriate sections of this User’s Guide on how to set task stack sizes. 


F.6.5.S Run-Time System Data 

A task control block is allocated for each normal interrupt task via the -tasks option at link time. 

During task elaboration, an entry is made in the run-time system _CD_INTERRUPT_VECTOR 
table to "define” the standard interrupt. This mechanism is used by the run-time system to make 
the conditional entry call when the interrupt occurs. This means that the user is responsible to 
include all interrupts serviced by interrupt tasks in the -interrupt_entry_table option at link time. 


F.6.6 Building an Application with Normal Interrupt Tasks 

This section describes how to build an application that uses standard Ada tasks to service 
interrupts. 


F.6.6.1 Source Code 

No special pragmas or other such directives are required to specify that a task is a normal interrupt 
task. If it contains interrupt entries, then it is a normal interrupt task by default. 

When specifying an address clause for a normal interrupt handler, the offset should be the 
interrupt number, not the offset of the interrupt in the interrupt vector. The segment is not 
applicable (although some value must be specified) because it is not used by the compiler for 
interrupt addresses. The compiler will place the interrupt vector into the 
INTERRUPTVECTORTABLE segment. For real address mode programs, the interrupt vector 
must always be in segment 0 at execution time. This placement can be accomplished by specifying 


217 


DACS-80x86 User’s Guide 
lmplcmcniation-Dcpcndcnt Charactcrisiics 


the address to locate the 1NTERRUPTVECTORTABLE segment with the loc86 command, or at 
run time, by having the startup code routine of the UCC copy down the 
1NTERRUPTVECTORTABLE segment to segment 0 and the compiler will put it there 
automatically. For protected mode programs, the user specifies the interrupt vector location at 
build time. 


F.6.6.2 Compiling the Program 
No special compilation options arc required. 


F.6.6.3 Linking the Program 

The interrupt task must be included in the -tasks option. The link options -Itstacksize, — 
lt_scgment_size, -mp_scgment_size, and -task_storage_size apply to normal interrupt tasks and 
must be set to appropriate values for your application. 

Every interrupt task must be accounted for in the -interrupt entry table option. This option 
causes a table to be built in the run-time system data segment to handle interrupt entries. In the 
case of standard interrupt tasks, this table is used to map the interrupt onto a normal conditional 
entry call to another task. 


F.6.7 Examples 

These examples illustrate how to write normal interrupt tasks and then how to build the application 
using them. 


F.6.7.1 Example 1 

This example shows how to code a simple normal interrupt handler. 

Ada source: 

with System; 
package P is 

task Normal_Interrupt_Handler is 
entry E; 

for E use at (segment => 0, offset => 10); 

end; 
end P; 

package body P is 

task body Normal_Interrupt_Handler is 


218 



DACS-80x86 User’s Guide 
Implementation-Dependent Characteristics 



begin 

accept E do 

<handlc intermpo 
end E; 

end; 
end P; 
with P, 

procedure Example_l is 
begin 

<main program> 
end Example.. 1; 


Compilation and Unking: 

$ ada Examplel 

$ ada_link -tasks 2 -intcrrupt_cntry_tab!e 10,10 Example_l 


¥.6.12 Example 2 

This example shows how to write a normal interrupt handler that services more than one interrupt 
and has other standard task entries. 

Ada source: 

with System; 
package P is 

task Normal_Task is 

entry El; 

entry E2; -- standard entry 

entry E3; 

for El use at (segment => 0, offset => 7); 
for E3 use at (segment => 0, offset => 9); 

end; 

end P; 

package body P is 

task body Normal_Task is 
begin 
loop 
select 

accept El do 

<service interrupt 7> 


219 






DACS-80x86 User's Guide 
Implementation-Dependent Characteristics 


end El; 
or 

accept E2 do 

<standard rcndczvous> 
end E2; 
or 

accept E3 do 

<scrvicc interrupt 9> 
end E3; 
end select; 
end loop; 

end Normal_Task; 
end P; 

Compilation and Linking: 

$ ada Example_2 

$ adajink -tasks -interrupt_entry_table 7,9 Example_2 


F.6.7J Example 3 

This example shows how to build an application for 80386 protected mode programs using normal 
interrupt handlers. 


Ada source: 

with System; 
package P is 

task Normal_Interrupt_Handler is 
entry E; 

for E use at (segment => 0, offset => 20); 
end; 

end P; 

package body P is 

task body Normal_Interrupt_Handler is 
begin 

accept E do 
null; 
end E; 
end; 

end P; 


220 






i-»rt^i-ouxoo user s uuiuc 
Implcmcntaiion-Dcpcndcni Characteristics 


Compilation and Linking: 

$ ada Examplc_3 

$ ada-link -tasks -intcrrupt_cntry_Tablc 20,20 Example_3 


F.6.7.4 Example 4 

This example shows how an End-Of-Intemipt message may be sent to the interrupting device. 
Ada source: 

with System; 
package P is 

task Normal_Interrupt_Handler is 
entry E; 

for E use at (segment -> 0, offset -> 7); 

end; 


end P; 

with Machine_Code; use Machine_Code; 
package body P is 

procedure Send_EOI is 
begin 

machine_instruction' 

(register_immediate, m_MOV, AL, 16#66#); 
machine_instruction' 

(immediate_register, m_OUT, 16*0e0#, AL); 

end; 

pragma inline (Send_EOI); 

task body Normal_Interrupt_Handler is 
begin 

accept E do 
<user code> 

Send_EOI; 
end E; 

end; 


end P; 


Compilation and Linking: 

S ada Examp!e_4 

S adaJink -tasks -interrupt_entry_table 7,7 Example_4 


221 





DACS-80x86 User’s Guide 
Impicmcmation-Dcpcndcnl Characteristics 


HP 


F.6.8 Interrupt Queuing 

DDC-I provides a useful feature that allows task entry calls made by interrupt handlers (fast and 
normal variant) to be queued if the called task is not waiting to accept tire call, enabling the 
interrupt handler to complete to die IRET. What may not be clear is that the same interrupt may 
be queued only once at any given time in DDC-l's implementation. We have made this choice 
for two reasons: 

a) Queuing does not come for free, and queuing an interrupt more than once is considerably 
more expensive than queuing just one. DDC-I feels that most customers prefer their 
interrupt handlers to be as fast as possible and that we have chosen an implementation that 
balances performance with functionality. 

b) In most applications, if the servicing of an interrupt is not performed in a relatively shon 
period of time, there is an unacceptable and potentially dangerous situation. Queuing the 
same interrupt more than once represents this situation. 

Note that this note refers to queuing of the same interrupt more than once at the same time. 
Different interrupts may be queued at the same time as well as the same interrupt may be queued 
in a sequential manner as long as there is never a situation where the queuing overlaps in time. 

If it is acceptable for your application to queue the same interrupt more than once, it is a 
relatively simple procedure to implement the mechanism yourself. Simply implement a high 
priority agent task that is called from the interrupt handler. The agent task accepts calls from the 
interrupt task and makes the call on behalf of the interrupt handler to the originally called task. 
By careful design, the agent task can be made to accept all calls from the interrupt task when they 
are made, but at the very least, must guarantee that at most one will be queued at a time. 


F.6.9 Recurrence of Interrupts 

DDC-I recommends the following techniques to ensure that an imerrupt is completely handled 
before the same interrupt recurs. There are two cases to consider, i.e. the case of fast interrupt 
handlers and the case of normal imerrupt handlers. 


F.6.9.1 Fast Interrupt Handler 

If the fast interrupt handler makes an entry call to a normal task, then place the code that 
reenables the interrupt at the end of the accept body of the called task. When this is done, the 
interrupt will not be reenabled before the rendezvous is actually completed between the fast 
imerrupt handler and the called task even if the call was queued. Note that the interrupt task 
executes all the way through the IRET before the rendezvous is completed if the entry call was 
queued. 

Normally, end-of-interrupt code using Low_Level_IO will be present in the accept body of the fast 
interrupt handler. This implies that the end-of-imerrupt code will be executed before the 
rendezvous is completed, possibly allowing the imerrupt to come in again before the application 
is ready to handle it. 

If the fast interrupt handler does not make an entiy call to another task, then placing the 


222 



cnd-of-intcrrupt code in die accept body of the fast internet task will guarantee that the interrupt 
is completely serviced before another interrupt happens. 


F.6.9.2 Normal Interrupt Handler 

Place the code that reenables the interrupt at the end of the accept body of the normal interrupt 
task. When this is done, the interrupt will not be reenabled before the rendezvous is actually 
completed between the normal interrupt handler and the called task even if the call was queued. 
Even though the interrupt "completes" in the sense that the IRET is executed, the interrupt is not 
yet reenabled because the rendezvous with the normal task’s interrupt entry has not been made. 

If these techniques arc used for cither variant of interrupt handlers, caution must be taken that 
other tasks do not call the task entry which reenables interrupts if this can cause adverse side 
effects. 


F.7 Unchecked Conversion 

Unchecked conversion is only allowed between objects of the same “size". However, if scalar type 
has different sizes (packed and unpacked), unchecked conversion between such a type and another 
type is accepted if either the packed or the unpacked size fits the other type. 


F.8 Input/Output Packages 

In many embedded systems, ihere is no need for a traditional I/O system, but in order to support 
testing and validation, DDC-I has developed a small terminal oriented I/O system. This I/O system 
consists essentially of TEXTJO adapted with respect to handling only a terminal and not file I/O 
(file I/O will cause a USE error to be raised) and a low level package called 
TERMINAL_DRIVER. A BASICJO package has been provided for convenience purposes, 
forming an interface between TEXT_IO and TERMINAL_DRIVER as illustrated in the following 
figure. 




TEXT XO 



BASIC IO 

TERMINAL DRIVER 
(H/W interface) 


The TERMLNAL_DRIVER package is the only package that is target dependent, i.e., it is the only 


223 










Implementation-Dependent Characteristics 


package that need be changed when changing communications controllers. The actual body of the 
TERMINAL_DRIVER is written in assembly language and is part of the UCC modules D1IPUT 
and D11GET. The user can also call the terminal driver routines directly, i.c. from an assembly 
language routine. TEXTJO and BASIC_I0 arc written completely in Ada and need not be 
changed. 

BASICJO provides a mapping between TEXTJO control characters and ASCII as follows: 
TEXTJO ASCII Character 


LINEJTERMINATOR 

PAGEJTERMINATOR 

FILE_TERMINATOR 

NEWLINE 


ASCII.CR 

ASCII.FF 

ASCII.SUB (CTRL/Z) 
ASCII.LF 


The services provided by the terminal driver arc: 

1) Reading a character from the communications port. Get_Charactcr. 

2) Writing a character to the communications port, Put_Character. 


F.S.1 Package TEXTJO 

The specification of package TEXTJO: 

pragma page; 
with EASIC_IO; 

with IO_EXCEPTIONS; 
package TEXT_IO Is 

type FILE_TYPE Is limited private; 

type FILEJKODE Is (IN_FILE, OUT_FILE); 

type COUNT Is range 0 .. INTEGER'LAST; 

subtype POSITIVE_COUNT Is COUNT range 1 .. COUNT'LAST; 

UNBOUNDED: constant COUNT:- 0; — line and page length 

— max. size of an Integer output field 21....t 
subtype FIELD is INTEGER range 0 .. 35; 

subtype NUMBER_BASE is INTEGER range 2 .. 16; 

type TTPE_5ET Is (LOWER_CASE, UPPERCASE); 

pragma PAGE; 

-- File Management 


procedure CREATE 

(FILE 

: In out 

FILE_TYPE; 


MODE 

: in 

FILE MODE :«OUT FILE; 


NAME 

: in 

STRING :«**; 


FORM 

) ; 

: in 

STRING :-** 

procedure OPEN 

(FILE 

: in out 

FILE TYPE; 


MODE 

: in 

FILE MODE; 


NAME 

: in 

STRING; 


224 







FORM : In STRING :-** 

); 

procedure CLOSE (FILE : In out FILE TYPE); 
ptocedura DELETE (FILE : In out FILEJTYPE); 
procedura RESET (FILE : In out FILEJTYPE; 

MODE : in FILE_MOOE); 
procedura RESET (FILE : In out FILE_TYP£); 

function MODE .(FILE : In FIL£_TYPE) return FILE_MODE; 

function NAME (FILE : In FILEJTYPE) return STRING; 

function FORM (FILE : In FILE_TYPE) return STRING; 

function IS_OPEN(FILE : In FILE_TYPE return BOOLEAN; 

pragma PAGE; 

— control of default input and output flies 

procedure SET_INPUT (FILE : In FILE_TYPE); 
procedure SETjOOTPOT (FILE : In FILEJTYPE); 

function STANDARD INPUT return FILE_TYPE; 

function STANDARDJ3UTP0T return FILEJTYPE; 

function CORRENT_INPOT return FILE_TYPE; 

function CURR£NT~OUTPUT return FILEJTYPE; 


pragma PAGE; 

— specification of line and page lengths 

procedure SET_LINE LENGTH (FILE : In FILEJTYPE; 

TO : In COONT); 

procedure SET_LINE__LENGTH (TO : in COUNT); 

procedure SET_PAGE_LENGTH (FILE : In FILEJTYPE; 

TO : In COUNT); 

procedure SET_PAGE_LENGTH (TO ; in COUNT); 

function LINEJLENGTH (FILE : In FILE_TYPE) 

return COUNT; 
function LINE_LENGTH return COUNT; 

function PAGE LENGTH (FILE : In FILE_TYPE) 

return COUNT; 
function PAGE LENGTH return COUNT; 


pragma PAGE; 

— Column, Line, and Page Control 

procedure NZW_LINE (FILE : In FILE TYPE; 

SPACING : In POSITIVE_COUNT 1); 

procedure NEW_LINE (SPACING : In POSITIVE~COUNT 1); 

procedure SKIP_LINE (FILE : In FILE TYPE; 

SPACING : in POSITIVE_COUNT 1); 

procedure SKI?_LINE (SPACING : In POSITIVE_COUNT 1); 

function SND_OF_LINE (FILE : In FILE_TYPE) return BOOLEAN; 
function £ND_OF_LINE ~ return BOOLEAN; 

procedure NEW_PAGE (FILE : In FILEJTYPE); 
procedure NEW_PAGE; 

procedure SKIP_PAGE (FILE : in FILE_TYPE); 
procedure SKI?_PAGE; 

function EKD_OF_PAGE (FILE : In FILEJTYPE) return BOOLEAN; 

function END_OF_PAGE return BOOLEAN; 

function £ND_OF_FILE (FILS : In FILE_TYPE) return BOOLEAN; 

function END_OF_FILE return BOOLEAN; 


225 




Implementation-Dependent Characteristics 




procedure 

SET_COL 

(FILE 

: In FILE TYPE; 



TO 

: In POSITIVE COUNT); 

procedure 

SET_COL 

(TO : 

In POSITIVE_COONT); 

procedure 

SET_LINE 

(FILE 

: In FILE TYPE; 



TO : 

In POSITIVE COUNT); 

procedure 

SET_LINE 

(TO : 

In POSITIVE_COUNT); 

function 

COL 

(FILE 

; In FILE TYPE) 



return 

POSITIVE~COUNT; 

function 

COL 

return 

POSITIVE~COUNT; 

function 

LINE 

(FILE 

: In FILE_TYPE) 



return 

POSITIVE_COUNT; 

function 

LINE 

return 

POSITIVE_COUNT; 

function 

PAGE 

(FILE 

; In FILE_TYPE) 



return 

POSITIVE~COUNT; 

function 

PAGE 

return 

POSITIVE~COONT; 


pragma PAGE; 

— Character Input-Output 


procedure 

GET 

(FILE 

: In FILE TYPE; 

ITEM : 

out 

CHARACTER); 

procedure 

GET 

( 



ITEM ; 

out 

CHARACTER) ; 

procedure 

POT 

(FILE 

: In FILE TYPE; 

ITEM : 

in 

CHARACTER); 

procedure 

POT 

( 



ITEM : 

in 

CHARACTER); 

— String 

Input-Output 





procedure 

GET 

(FILE 

: In FILE TYPE; 

ITEM : 

out 

CHARACTER) ; 

procedure 

GET 

( 



ITEM : 

out 

CHARACTER) ; 

procedure 

POT 

(FILE 

: In FILE TYPE; 

ITEM : 

in 

CHARACTER) ; 

procedure 

POT 

( 



ITEM : 

in 

CHARACTER) ; 

procedure 

GET. 

LINE 

(FILE : 

In FILE. 

TYPE; 






ITEM : 

out STRING; 






LAST : 

out NATORAL); 



procedure 

GET 

LINE 

(ITEM : 

out STRING; 






LAST : 

out NATORAL); 



procedure 

POT_ 

LINE 

(FILE : 

In FILE 

TYPE; 






ITEM ; 

In STRING); 



procedure 

POT. 

.LINE 

(ITEM : 

In STRING); 



pragma PAGE; 









— Generic Package for Input-Output of Integer Types 
generic 

type NUM Is range <>; 
package INTEGER_IO Is 


DEFAOLT WIDTH 

FIELD 

NUM'WIDTH; 

DEFAOLT_BASE 

: NUMBER. 

BASE 10; 

procedure GET 

(FILE 

In FILE_TYPE; 


ITEM 

out NUM; 


WIDTH 

in FIELD 0); 

procedure GET 

(ITEM 

out NUM; 


WIDTH 

In FIELD 0); 

procedure POT 

(FILE 

in FILE TYPE; 


ITEM 

In NUM; 


WIDTH 

In FIELD DEFAOLT WIDTH; 


BASE 

In NUM3ER_BASE DEFAULT BASE) 

procedure POT 

(ITEM 

In NUM; 


WIDTH 

In FIELD DEFAULT_WIDTH; 


BASE 

ln NUM3ER_BASE DEFAULT_BASE) 

procedure GST 

(FROM 

In STRING; 


ITEM 

out NUM; 










LAST : out POSITIVE); 


procedure PUT (TO : out STRING; 

ITEM in NUM.- 

BASE In NUMBER_BASE DEFAULT_BASE) 

and INTECER_IO; 


pragu page,- 

— Ganaric Packages for Input-Output of Real Types 
generic 

type NOM is digits <>; 
package FLOAT_IO is 

OEFAOLT_FORE FIELD 2; 

DEFAOLT_AFT : FIELD NUM'DIGITS - 1; 

DEFAULT_EXP : FIELD 3; 

procedure GET (FILE : in FILE_TYP£; 

ITEM : out NUM; 

WIDTH : in FIELD 0) ; 
procedure GET (ITEM : out NUM.- 

WIDTH : in FIELD 0); 

procedure PUT (FILE : in FILE TYPE; 

ITEM : in NUM; - 

FORE : in FIELO DEFAULT_FOR£; 

AFT : in FIELD DEFAULT_AFT; 

EXP : in FIELD DEFAULTJEXP); 

procedure PUT (ITEM : in NUM.- 

FORE : in FIELD DEFAULT_FOR£; 

AFT : in FIELD DEFAULT_AFT; 

EXP : in FIELD DEFAULT_EXP); 

procedure GET (FROM : in STRING; 

ITEM : out NUM; 

LAST : out POSITIVE); 

procedure PUT (TO : out STRING; 

ITEM : in NUM.- 

AFT : in FIELD DEFAULT AFT; 

EXP : in FIELD DEFAULT~EXP); 

end FLOAT 10; 


pragma PAGE; 
generic 

type NUM is delta <>; 
package FIXED_IO is 

DEFAULT_FORE : FIELD NUM'FORE; 

DEFAULT AFT : FIELD NUM'AFT; 

DEFAULTJEXP : FIELD 0; 

procedure GET (FILE : in FILE_TY?E; 

ITEM : out NUM.- 
WIDTH : in FIELD 0); 
procedure GET (ITEM : out NUM.- 

WIDTH : in FIELD 0); 

procedure PUT (FILE : in FILE_TYPE; 

ITEM : in NUM.- 

FORE : in FIELD :« DEFAULT_F0R£; 

AFT : in FIELD DEFAULT_AFT; 

EXP : in FIELD DEFAULTJEXP); 

procedure PUT (ITEM : in NUM.- 

FORE ; in FIELD DEFAULT_FORE; 

AFT : in FIELD DEFAULT AFT; 


227 










EXP : In FIELD DEFAULT EXP); 


procedure GET (FROM : in STRING; 

ITEM : out NUM.- 
LAST : out POSITIVE); 

procadura POT (TO out STRING; 

. ITEM : In NUM.- 

AFT in FIELD DEFAOLT_AFT; 

EXP : in FIELD DEFAULT_EXP); 

and FIXED 10; 


pragma PAGE; 

— Ganaric Package for Input-Output of Enumeration Types 
ganarlc 

type ENUM la (<>); 
package ENUM£RATION_IO ia 

DEFAULT_WIDTH : FIELD 0; 

DEFAOLT_SETTING ; TYPE_SET UPPERCASE; 

procedure GET (FILE : in FILE_TYF£; ITEM : out ENUM); 
procedure GET ( ITEM : out ENUM); 

procedure PUT (FILE : FILE_TYPE; 

ITEM : in ENUM; 

WIDTH ; in FIELD DEFAULT_WIDTH; 

SET : in TYPE_SET DEFAULT_S£TTING); 

procedure PUT (ITEM : in ENUM; 

WIDTH : in FIELD DEFAOLT_WIDTH; 

SET ; in TYPE_SET DEFAULT_SETTING); 

procedure GET (FROM : in STRING; 

ITEM : out ENUM; 

LAST : out POSITIVE); 

procedure PUT (TO : out STRING; 

ITEM : in ENUM; 

SET : in TYPE_SET DEFAULT_SETTING); 

and ENUMERATION_IO; 
pragma PAGE; 

— Exceptions 

STATUS_ERROR : exception renames IO EXCEPTIONS.STATUS_ERR0R; 
MODE_ERROR : exception renames IO~EXCEPTIONS.M0DE_ERR0R; 
NAME_ERROR : exception renames IO~EXCEPTIONS,NAME_ERROR; 
USE_ERR0R : exception renames I0JEXCEPTI0NS.USE_ERR0R; 
DEVICE_ERROR ; exception renames IO~EXCEPTIONS.DEVICE_ERROR; 
END_ERROR : exception renames IO~EXCEPTIONS.END_ERP.OR; 
DATA_ERROR : exception renames IO~EXCEPTIONS.DATA_ERROR; 
LAYOUT_ERROR : exception renames IO~EXCEPTIONS.LAY0UT_ERR0R; 

pragma page; 
prlvate 

type FILE_T V ?E is 
record 

FT : INTEGER -1; 
end record; 

end TEXT 10; 


228 






F.8.2 Package IO_EXCEPTIONS 

The specification of the package I0_EXCEPT10NS: 


package IO_EXCEPTIO.JS la 


STATUS ERROR 
MOOE_ERROR 
NAME~ERROR 
USE ERROR 
devTce_error 
ENOJERROR 
DATA_ERROR 
LAYOUT ERROR 


exception; 
exc'eptlon; 
exception; 
exception; 
exception; 
exception; 
axceptlon; 
exception; 


and IO EXCEPTIONS; 


F.8_3 Package BASIC-10 

The specification of package BASICJO: 


with IO_EXCEPTIONS; 
package BASIC_IO Is 

type count Is range 0 .. integer'last; 

subtype positive_count is count range 1 .. count'last; 


function get_integer return string; 

-- Skips any leading blanks, line terminators or page 

— terminators. Then reads a plus or a minus sign if 

— present, then reads according to the syntax of an 
-- Integer literal, which stay be based. Stores in item 
-- a string containing an optional sign and an integer 

— literal. 

— The exception DATA_ERROR is raised if the sequence 

— of characters does not correspond to the syntax 

— described above. 

— The exception ENO_ERROR is raised if the file terminator 
-- is read. This means that the starting sequence of an 

— Integer has not been met. 

-- Note that the character terminating the operation must 
-- be available for the next get operation. 

function get_real return string; 

-- Corresponds to get_lnteger except that it reads according 

— to the syntax of a real literal, which may be based. 


function get_enumeration return string; 

— Corresponds to get_lnteger except that it reads according 

— to the syntax of an identifier, where upper and lower 

— case letters are equivalent to a character literal 

— including the apostrophes. 


229 



function get_ltem (length : in Integer) return string; 

-- Reeds a string from the current line and stores It In 
-- item. If the remaining numbor of characters on the 
-- current line Is less than length then only these 
-- characters are returned. The line terminator Is not 

— skipped. 

procedure put_ltem (Item : In string); 

— If the length of the string Is greater than the current 

— maximum line (linelength), the exception LAYOOT_ERROR 

— is raised. 

-- If the string does not fit on the current line a line 
-- terminator is output, then the item is output. 

— Line and page lengths - ARM 14.3.3. 

procedure set_llne_length (to : in count); 

procedure set_page_length (to : in count); 

function line_length return count; 
function page_length return count; 

— Operations on columns, lines and pages - ARM 14.3.4. 

procedure new_llne; 

procedure sklp_line; 

function end_of_line return boolean; 

procedure new_page; 

procedure skip_page; 

function end_of_page return boolean; 

function end_of_flle return boolean; 

procedure set_col (to : in posltlve_count); 

procedure set_llne (to : in posltlve_count); 

function col return pcsltlve_count; 

function line return posltlve_count; 

function page return positlve_count; 

— Character and string procedures. 

— Corresponds to the procedures defined In ARM 14.3.6. 

procedure get_character (Item : out character); 

procedure get_strlng (Item : out string); 

procedure get_llne (item : out string; 

last : out natural); 

procedure put_character (item : In character); 
procedure put_string (item ; in string); 


230 


procedure put_llne (itera : In string); 


exceptions: 


OSE_ERROR 
DEv7cE_ERROR 
END_ERROR 
DATA_ERROR 
LAYOUT ERROR 


exception 

exception 

exception 

exception 

exception 


renames IO_EXCEPTIONS,USE_ERROR; 
renames IO_EXCEPTIONS.DEVICE_EAROR; 
renames IO_EXCEPTIONS.END_ERROR; 
renames IO_EXCEPTIONS.DATA_ERROR; 
renames IO~EXCEPTIONS.LAYOUT ERROR; 


end BASIC XO; 


F.8.4 Package TERMINAL DRIVER 

The specification of package TERMINAL_DRIVER: 


package TERMINAL_DRIVER Is 

procedure put_character (ch : in character); 
procedure get_character (ch : out character); 
private 

pragma interface (ASM86, put_character); 

pragma interface_spelling (put_character, "DlIPOT?put_character‘); 
pragma interface (ASM86, get_character); 

pragma lnterface_spelllng(get_character, ’DlIGET?get_character“); 
end TERMINAL DRIVER; 


F.8.S Packages SEQUENTIALJO and DIRECTJO 

The specifications of SEQUENTIALJO and DIRECT_IO are specified in the ARM: 

Since files are not supported the subprograms in these units reaise USE_ERROR or 
STATUS.ERROR. 


231 




DACS-80x86 User's Guide 
Implementation-Dependent Characteristics 



F.8.6 Package L0\VJLEVEL_10 

The specification of LOW_LEVEL_IO (16 bits) is: 


with System; 

package LOW_L£VEL_LO Is 

subtype port_address is System.UnslgnedWord; 

type ll_io_8 is new Integer range -128..127; 

typo ll_lo_16 Is new Integer; 

procedure send_control(device : in port_address; 

data : in System.Byte); 

-- unsigned 8 bit entity 

procedure send_control(device : in port_address; 

data : in System.UnslgnedWord); 

— unsigned 16 bit entity 

procedure send_control(device : in port_address; 

data : in l.;_io_8); 

— signed 8 bit entity 

procedure send_control(device ; in port_address; 

data ; in ll_io_16); 

-- signed 16 bit entity 

procedure recelve_control(device : in port_address; 

data : out System.Byte); 

— unsigned 8 bit entity 

procedure recelve_control(device : in port_address; 

data ; out System.UnslgnedWord); 

— unsigned 16 bit entity 

procedure receive_control(device : in port_address; 

data ; out ll_lo_8); 

— signed 8 bit entity 

procedure recelve_control(device : in port_address; 

data : out ll_io_16); 

-- signed 16 bit entity 

private 

pragma inline(send_control, receive_control); 
end LOW LEVEL 10; 


The specification of LOW_LEVEL_IO (32 bits) is: 

with SYSTEM; 

package LCW_LEVEL_IO is 

subtype port_address is System.UnslgnedWord; 

type ll_io_8 is new short_integer range -128..127; 

type ll_lo_16 is new short_integer; 

type ll_lo_32 is new integer; 

procedure send_control(device : in port_address; 

data : in System.5yte); 

-- unsigned 8 bit entity 

procedure send_control(device : in port_address; 

data : in System.UnslgnedWord); 


232 





DACS-80x86 User’s Guide 
!mplcmcniaiion-Dcpendent Characteristics 


-- unsigned 16 bit entity 

procedure send_control(device : In port_address; 

data : In System.UnaignedDWord) ; 

— unsigned 32 bit entity 

procedure send_controt(device : in port_address; 

data : in ll_lo_8); 

— signed 8 bit -entity 

procedure send_control(device : in port_address; 

data : in ll_lo_16); 

— signed 16 bit entity 

procedure send_control(device : in port_address; 

data : in ll_lo_32); 

— signed 32 bit entity 

procedure recelve_control(device : in port_address; 

data : out System.Byte); 

— unsigned 8 bit entity 

procedure recelve_control(device : in port_address; 

data : out System.DnsignedWord); 

— unsigned 16 bit entity 

procedure recelve_control(device : in port_address; 

data : out System.OnslgnedDWord); 

— unsigned 32 bit entity 

procedure receive_control(device : in port_address; 

data : out ll_io_8); 

— signed 8 bit entity 

procedure recelve_control(device : In port_address; 

data : out ll_lo_16); 

— signed 16 bit entity 

procedure receive_control(device : in port_address; 

data : out ll_lo_32); 

— signed 32 bit entity 


private 

pragma inline(send_control, recelve_control); 
end LOW LEVZL IO; 


F.9 Machine Code Insertions 

The reader should be familiar with the code generation strategy and the 80x86 instruction set to 
fully benefit from this section. 

As described in chapter 13.8 of the ARM [DoD 83] it is possible to write procedures containing 
only code statements using the predefined package MACHINE_CODE. The package 
MACHINE_CODE defines the type MACHINE_INSTRUCTION which, used as a record aggregate, 
defines a machine code insertion. The following sections list the type MACHINE_INSTRUCT10N 
and types on which it depends, give the restrictions, and show an example of how to use the 
package MACHINE.CODE. 



233 




DACS-80x86 User's Guide 
Implementation-Dependent Characteristics 



F.9.1 Predefined Types for Machine Code Insertions 

The following types arc defined for use when making machine code insertions (their type 
declarations arc given on the following pages): 

type opcodc_typc 
type operand_typc 
type registerjype 
type segmcnt_rcgistcr 
type machinejnstruction 

The type REGISTER_TYPE defines registers. The registers STi describe registers on the floating 
stack. (ST is the top of the floating stack). 

The type MACHINEJNSTRUCTION is a discriminant record type with which every kind of 
instruction can be described. Symbolic names may be used in the form 

name’ADDRESS 

Restrictions as to symbolic names can be found in section F.9.2. 

It should be mentioned that addresses are specified as 80386/80486 addresses. In case of other 
targets, the scale factor should be set to "scaIe_I M . 


type opcode_type Is ( 

-- 8086 Instructions: 


m AAA, 

m_AAD, 

m_AAM, 

m_AAS, 

m_ADC, 

m_ADD, m AND, 

m_CALL, 


m_CALLN, 








m_C3W, 

m_CLC, 

m OLD, 

m CLI, 

m CMC. 

n CMP, m CKPS, 

m CWD, 

mDA 

m DAS, 

m DEC, 

m_DIV, 

mJHLT, 

m~IDIV, 

m_lMUL, m_IN, 

m~INC, 

mJNL 

m_INTO, 

nTlRET, 

m_JA, 

m JAE, 

m_JB, 

m_JBE, m~JC, 

m~JCXZ, 

m JE, 

m_JG, 

m~JGE, 

m_JL, 

at JLE, 

a JNA, 

m JNAE, in JNB, 

ro_JNBE, 

IB JC 

m_JNE, 

m_JNG, 

Ri JNGE, 

m JNL, 

m~JNLE, 

m_JNO, m_JNP, 

m JNS, 

ml®. 

m JO, 

m_J?, 

m JPE. 

m_JPO, 

m~JS, 

m JZ, m JMP, 

m_LAHF, 

m mi 

m~LES, 

Rl LEA, 

m_LOCK, 

m_LODS, 

ro_LOOP, 

m_LOOPE, ~ 



m_LCOPNE, 

m_LOOPNZ, 







m_LOOPZ, 

m MOV, 

m MOVS, 

m MUL, 

m_NEG, 

m_NOP, m_NOT, 

m_OR, 

mCUL 

m~POP, 

m_POPF, 

ir, PUSH, 

m~PUSHF, 

m_RCL, 

m_RCR, m_ROL, 

m_ROR, 


m~REP, 

m RE?E, 

ra_REPNE, 

m RET, 

ra~RETP, 

m RETN, m RETNP 

1 

mSir, 

m_SAl, 

m SAS, 

m~SHL, 

m~SHR, 

jn_SBB, 

m_SCAS, m__STC, 

m_STD, 

msn. 

m~STOS, 

m SUB, 

m_TESX, 

ra_WAIT, 

nTxCHG, 

n_XLAT, nTxOR, 




-- 3087/80187/80287 Floating Point Processor Instructions: 


m_FA£S, 

m_FADD, 

m FADDD, 

m FADDP,m 

FBLD, m 

FBSTP, 

m_FCHS, 

m~FNCLEX, 

m~FCCM, 

m _ FCOMD, 

m FCOMP,m FCOMPD, m 

'FCOMP?, 

m_FDECSTP, 

m~FDIV, 

m_FDIVD, 

m_FDXVP, 

m FDIVR,ra 

FDIVRD, m FDIVRP, 

ro FFREE, 

m FIADD, 

m FIADDD, 

ra~FICOM, 

m_FICOMD,* 

ra_FICOMP, 

m FICOMPD, m FIDIV, 

m~FIDXVD, 

m FIDIVR, 

m~FIDXVRD, 

m FILD, 

m FILDD, m_ 

FILDL, 

m_FXMUL, 

m~FIMULD, 

m FINCSTP, 

raJTNINIT, 

m FIST, 

m FISTD.m 

'fist?, 

m_FXSTPD, 

hTfISTPL, 

m _ FISUB, 

m~FISUBD, 

m FISUBR, 

m _ FISUBRDj 

m FLD, 

m FLDD, 

m FLDCW, 

snjFLDENV, 

m _ FLDLG2, 

ra _ FLDLN2, 

m FLDL2E, 

m FLDL2T, m FLOPI, 

m FLDZ, 

m FLD1, 

m^FMUL, 

m FMULD,ra FMULP, m 

FNOP, 

m_FPATAN, 

r> — FPREM, 

ra_FPTAN, 

mJTRNDINT, 

m FRSTOR, 

m F SAVE,m 

/SCALE, 

m~FSETPM, 

m~FSQRT, 

m FST, 

uTfstd, 

m FSTCW,m FSTENV, m 

'fstp. 

m_FSTPD, 

m rSTSW, 

m _ FSTSWAX, 

itTfSOB, 

nTYsUBD, m~FSUBP, ra’ 

"fsobr. 

m FSUBRD, 

m FSUBRP, 

m”FTST, 

m~FWAIT, 

m_FXAM, 

m_FXCH, 

m_FXTRACT, m_FYL2X, 


m_FYL2X?l, m_F2XMl, 

— 80186/80286/80386 Instructions: 

— Notice that some immediate versions of the 8086 
-- Instructions only exist on these targets 

— (shifts, rotates,push,imul,...) 

m SOUND, m CLTS, m_ENTER, m_INS, ra_LAK, m_LEAVT, ra_LGDT, 

m~LIDT, m _ LSL, m_OOTS, m_FO?A, m_PUSHA, m_SGDT, m_SIDT, 


234 


Implcmcniaiion-Dcpcndcni Characteristics 




m_ARPL, ra_LLDT, ra_LMSW, 

— IS bit always... 

m_SLBT, m_SMSW, m_STR, 

-- the 80366 specific Instructions: 

m_SETA, m_S£TA£, ra_SETB, 

mSETG, m_SETOE, m_SETL, 

m_SETNB, m~SETN8E, m_S£TNC, 
m~SETNGE, m~SETNL, m_SETNLE, 
m_SETN2, nCsETO, m~SETP, 

m_SETZ, m_BSF, m_BSR, 

m_BTS, m_LFS, m_LGS, 

m~MOVCR, m~MOVDB, nfMOVTR, 

-- the 60387 specific instructions: 

m FUCOM, m_FOCOMP, 

bTfsincos, 

— byte/w ord/dword variants (to be 
-- not deductible from context): 


m ADCB, 

m_ADCW, 

m ADCD, 

m~ANDB, 

ra_ANDW, 

m_ANOO, 

m_BTCD, 

ra_BTRW, 

m_BTRD, 

m_CWB£, 

m~CWDW, 

m CDQ, 

m CMPSB, 

m_CMPSW, 

m CMPSO, 

hTdIVB, 

m_DIVW, 

ra OIVD, 

m _ IMULB, 

m_IMULW, 

m IMOLD, 

m_INSB, 

m_INSW, 

n_INSD, 

m MOVB, 

m”KOVW, 

m MOVD, 

m_KOVSXB, 

m_MOVSXW, 

ra MOVZXB 

ra - MULD, 

m_NEGB, 

m~NEGW, 

m~NOTD, 

ra_ORB, 

m ORW, 

m OOTSD, 

m POPW, 

m POPE, 

m_RCLW, 

m_RCLD, 

m_RCRB. 

m ROLW, 

m_ROLD, 

m RORB, 

mJSALW, 

m SALD, 

m~SARB, 

m SHLW, 

m SHLDW, 

m~ SHR3, 

m SBBW, 

m_S3BD, 

m SCASB, 

m STOSW, 

m_STOSD, 

m SOBB, 

m TESTW, 

m_TESTD, 

m XORB, 

m EATAW, 

m_DATAB, 



-- special 'instructions': 

-- 8087 temp real load/store_andjpop: 


m_LTR. 


m_VERR, m VERW, 


ra_SETBE, m_SETC, *_S£TE, 

m~SETLE, m_SETNA, o_SETNA£, 

I»_SETNE, m_SETNG, 
m_SETNO,m SETNP, ®_SETNS. 

m_SETP£, m~SETPO, m_SETS, 

ra~BT, m_BTC, m_BTR, 

m~LSS, m~HOV2X, ra_MOVSX, 

ra_SHLD, m_SHRD, 


m FUCOMPP, m_FPR£Ml, m_FSIN, m_FCOS, 


used, when 


m_ADDB, 

m_AD0W, 

m ADDD, 

m_BTW, 

m_BTO, 

m_BTCW, 

m_BTSW, 

m~BTS0, 

m~CBWW, 


m_CMPB, m_CKPW, m_CMPD, 

m DECB, m_DECW, m_DECD, 


m~IDIVB, m_IBIVW, 

m_IDIVD, 

m INCB, m_lNCW, 

m_XNCD, 

m _ LODSB, m_LODSW, 

m_LODSD, 


m MOVSB,m_MOVSW, m_MOVSE, 


m MOVZXW, m_MOLB, ra_MULW, 


m HEG0, 

m _ NOTB, 

m NOTW. 

m ORE, 

m OUTSB, m_OOTSW, 

m~PUSHW, 

m PUSHD, m RCLB, 

m RCRW, 

m_RCRO, 

m ROLB, 

m~RORW, 

m_RORD, 

m SALB, 

ra~SARW, 

m SARD, 

m SHLB, 

m“sHRW, 

m SHREW,m SBBB, 

m~SCASW, 

m SCASB, m STOSB, 

m_soBW, 

m SUBD, 

m TESTB 

m_XORW, 

nTxORB, 

m_DATAB 

m_label 

, m_reset. 



m FLDT, m FSTPT); 


pragma page; 

type cperand_type is ( none, — 

Immediate, 

register, 

address, 

system_address, 

name, 

reglster_immediate. 


reglster_register, 
register_address. 


aadress_reglster. 


no operands 

— one immediate operand 

— one register operand 
-- one address operand 

— one 'address operand 
-- CALL name 

— two operands : 

— destination Is 

— register 

— source Is Immediate 

— two register operands 

— two operands : 

— destination is 

— register 

-- source is address 
-- two operands : 


235 




u»/\t.;>-ouxoo user s uuioc 
Implementation-Dependent Characteristics 


reglster_system_addre33, 

sy3tem_address_regi3ter, 

add re s3_immedlata, 

3y3t«m_addro33_lmmedlata, 

immedlate_register, 

lmmedlate_lmmedlate, 

reglster_reglster_lmmedlate, 

regi3ter_address_lmmedlate, 
regls tar_sys tem_address_lmmedia te, 
address_reglster_immediate, 

system_address_register__lmmediate 

); 


— destination Is 
-- address 

— source Is register 

— two operands : 

— destination is 
-- register 

-- source Is ‘address 
-- two operands : 

— destination is 

— 'address 

-- source Is register 

— two operands : 

-- destination Is 
-- address 

— source Is immediate 

— two operands : 

— destination Is 

— ‘address 

— source Is Immediate 

— only allowed for 00T 

— port is Immediate 

— source is register 

— only allowed for 
— ENTER 

— allowed for IMOLlmm, 

— SHRDlmm, SHLDlmm 

-- allowed for IMULimra 
— allowed for IMULlmm 

— allowed for SHRDlmm, 

— SHLDlmm 

-- allowed for SHRDlmm, 

— SHLDlmm 


type register type is (AX, 

CX, 

DX, 

BX, 

SP, 

BP, 

SI, 

DI, — word regs 

> 

CL, 

DL, 

BL, 

AH, 

CH. 

DH, 

BH, -- byte regs 

EAX, 

, ECX, 

,EDX, 

, EBX, 

ESP, 

EBP, 

ESI, 

EDI,— dword regs 

ES, 

cs. 

ss. 

DS, 

FS, 

GS, 


— selectors 


BX_SI, BX_DI. BP_SI, BP_DI, -- 8086/80186/80286 combinations 
ST, ST1, ST2, ST3, -- floating registers (stack) 

ST4, STS, ST6, ST7, 

nil); 

— the extended registers (EAX .. EDI) plus FS and GS are only 

— allowed In 80386 targets 

type scale_type Is (scale_l, scale_2, scale_4, scale_8); 
subtype machlne_strlng is stringd , . 100) ; 


pragma page; 

type machine_instructlon (operand_kind : operand_type) Is 
record 

opcode : opcode_type; 

case operand_klnd Is 
when immediate ■»> 

lmmediatel : integer; — immediate 


when register «> 

r_reglster : reglster_type; — source and/or destination 


when address ■ 
a_segment 
a_address_base 
a_address_lndex 
a_address_scale 
a address offset 


reglster_type; — source and/or destination 
: reglster_type; 

: reglster_type; 

: scale_type; 

: Integer; 


when system_address -> 

sa_address : system.address; — destination 


236 






' m \^ 


implementation-ucpcnacni i_naractcnsucs 


when name -> 

n_strlng : machlne_str lng; -- CALL destination 


when register_lmreedlate 

-> 


r_l_reglster_to 

: reglstor_type; 

— destination 

r_l_lmmedlate 

: Integer; 

— source 

when regl3ter_reglster 

-> 


r_r_reglster_to 

: register_type; 

— destination 

r_r_reglster_from 

: reglster_type; 

— source 

when register_address - 

> 


r_a_reglstor_to 

: reglster_type; 

— destination 

r_a_segment 

: reglster_type; 

— source 

r_a_address_base 

: reglster~type; 


r_a_addras s_lndex 

: register_type; 


r_a_address_scale 

: scale_type; 


r_a_addre3S_off3et 

: Integer; 


when address_regl3ter - 

■> 


a_r_segment 

: reglster_type; 

-- destination 

a_r_address_base 

: register_type; 


a_r_address_lndex 

: reglster_type; 


a_r_addres s_3cale 

; scale_type; 


a_r_addre 3 s_offset 

: integer; 


a_r_reg1s t e r_f rom 

: reglster_type; 

— source 

when register system address -> 


r_sa_reglster_to 

: reglster_type; 

— destination 

r_sa_address 

: system.address; 

— source 

when system address register -> 


s a_r_addr es s 

: system.address; 

— destination 

s a_r_r e g_f rom 

: reglster_type; 

— source 

when address_lmmediate 

-> 


a_i_segment 

: reglster_type; 

-- destination 

a_l_address_base 

: reglster_type; 


a_i_address_lndex 

: reglster_type; 


a_l_addres3_scale 

: scale_type; 


a_l_address_cffset 

: integer; 


a_l_immedlate 

: Integer; 

— source 

when system address Immediate -> 


sa_l_address 

: system.address; 

-- destination 

sa_l_lmmedlate 

: Integer; 

— source 

when Immediate register -> 


l_r_lmmedlate 

: Integer; 

-- destination 

l_r_reglster 

: reglster_type; 

— source 

when Immediate Immediate «> 


1_1_1mmedlatel 

: Integer; 

— lmmediatel 

l_l_lmmedlate2 

: Integer; 

— Immediate2 

register register Immediate -> 


r_r_i_registerl 

: register_type; 

— destination 

r_r_l_reglster2 

: reglster_type; 

— sourcel 

r_r_l_immedlate 

integer; 

— source2 

reglster_address_lmmedi 

ate «> 


r_a_l_reglster : 

register_type; 

— destination 

r_a__i_segmen t 

: reglster_type; 

— sourcel 

r_a_l_add re s s_bas e 

: reglster_type; 


r_a_i_address_lndex 

: register_type; 


r_a_l_address_scale 

: scale_type; 


r_a_i_address_o£fset 

: integer; 


r_a_l_lmmediate 

: Integer; 

— source2 

reelster_system_address 

_lmmedlate »> 


r sa 1 register 

: reglster_type; 

— destination 

addrlO~ 

: system.address; 

— sourcel 

r_sa_l_1mmed1ate 

: integer; 

-- source2 


237 







Implementation-Dependent Characteristics 




-- destination 


-- sourcel 
-- source2 


whan systera_address_reglster_lmmediate -> 

sa_r_l_address : system.address; 

sa_r_i_reglster : reglster_type; 

sa_r_i_lmmadlata : Integer; 

whan others -> 
null; 
and casa; 
and record; 

and machine code; 


F.9.2 Restrictions 

Only procedures, and not functions, may contain machine code insenions. 

Symbolic names in the form x'ADDRESS can only be used in the following cases: 

1) x is an object of scalar type or access type declared as an object, a formal parameter, or 
by static renaming. 

2) x is an array with static constraints declared as an object (not as a formal parameter or by 
renaming). 

3) x is a record declared as an object (not a formal parameter or by renaming). 


The m_CALL can be used with "name" to call (for) a routine. 

Two opcodes to handle labels have been defined: 

mjabcl: defines a label. The label number must be in the range 1 <= x <= 999 and is put 

in the offset field in the first operand of the MACHINE_1NSTRUCTI0N. 

m_resct: used to enable use of more than 999 labels. The label number after a m_RESET 

must be in the range 1<= x <= 999. To avoid errors you must make sure that all 
used labels have been defined before a reset, since the reset operation clears all used 
labels. 

All floating instructions have at most one operand which can be any of the following: 

• a memory address 

• a register or an immediate value 

• an entry in the floating stack 


-- destination 
-- sourcel 
-- source2 


when addre33_reglster_liraiedlate -> 

a_r_l_segment : register_type; 

<-_r_l_addross_base : reglster_type; 
a_r_l_address_lndex : reglster_type; 
a_r_l_address_scale : scale_type; 
a_r_l_address_offset: intogor; 
a_r_l_reglster ; reglster_type; 

a r 1 Immediate : Integer; 


238 




F.9J Examples 


The following section contains examples of how to use the machine code insertions and lists the 
generated code. 


F.9.4 Example Using Labels 

The following assembler code can be described by machine code insertions as shown: 

MOV AX,7 
MOV CX,4 
CMP AX,CX 
JG X 
JE 2 
MOV CX,AX 
1: ADO AX, CX 
2: MOV SS: IBP+DJ], AX 

package example_MC Is 

procedure test_labels; 
pragma inline <test_labels); 

and example_MC; 

with MACBIN£_CODE; use MACHINE_CODE; 
package body example_MC is 


procedure test_labels is 
begin 

MACHIN£_INSTROCTION'(register immediate, 
MACHINE_INSTRUCTICN' <reglster_lmmediate, 
MACHINE~INSTRCCTION'(register register, 
MACHINE~XNSTROCTION' (immediate, 
MACHINE_INSTRUCTION' (immediate, 
MACHINE_INSTROCTION'(register_register, 
MACHINE INSTRUCTION' (Immediate, 
MACHINE~INSTROCTION' (reglstar_reglster, 
MACHINE_INSTRUCTION'(Immediate, m_label, 
MACHINE_INSTROCTICN'(address_reglster. 


end test_labels; 
end example_MC; 


F.9.5 Advanced Topics 

This section describes some of the more intricate details of the workings of the machine 
code insertion facility. Special attention is paid to the way the Ada objects are referenced in 
the machine code body, and various alternatives are shown. 


m MOV, 

AX, 

7); 

m~MOV, 

CX, 

4); 

m_CMP, 

AX, 

CX) 

m_JC, 

1 ); 


m_JE, 

2 ); 


m_MOV, 

CX, 

AX) 


m label, 1); 


m ADD, 

AX, CX); 

2 ); 


m MOV, 

SS, BP, 

DI, scale_l, 0, AX); 


239 




F.9.5.1 Address Specifications 

Package MACH1NE_C0DE provides two alternative ways of specifying an address for an 
instruction. The first way is referred to as SYSTEM_ADDRESS and the parameter associated 
this one must be specified via OBJECT’ADDRESS in the actual MACHINE_CODE : nscnion. The 
second way closely relates to the addressing which the 80 x 86 machines employ: an address has 
the general form 

segmcni:[basc+indcx*scalc+offsci] 

The ADDRESS type expects the machine insertion to contain values for ALL these fields. Tire 
default value NIL for segment, base, and index may be selected (however, if base is NIL, so 
should index be). Seale MUST always be specified as scalc_l, scalc_2, scalc_4, or scalc_8. For 
16 bit targets, scalc_l is the only legal scale choice. l"hc offset value must he in the range of 
-32768 .. 32767. 


F.9.5.2 Referencing Procedure Parameters 

The parameters of the procedure that consists of machine code insenions may be 
referenced by the machine insertions using the SYSTEM_ADDRESS or ADDRESS formats 
explained above. However, there is a great difference in the way in which they may be specified; 
whether the procedure is specified as INLINE or not. 

INLINE machine insenions can deal with the parameters (and other visible variables) using the 
SYSTEM_ADDRESS form. This will be dealt with correctly even if the actual values arc 
constants. Using the ADDRESS form in this context will be the user's responsibility since the 
user obviously attempts to address using register values obtained via other machine insenions. It 
is in general not possible to load the address of a parameter because an ’address’ is a two 
component structure (selector and offset), and the only instruction to load an immediate address 
is the LEA, which will only give the offset. If coding requires access to addresses like this, one 
cannot INLINE expand the machine insenions. Care should be taken with references to objects 
outside the current block since the code generator in order to calculate the proper frame value 
(using the display in each frame) will apply extra registers. The parameter addresses will, 
however, be calculated at the entry to the INLINE expanded routine to minimize this problem. 
INLINE expanded routines should NOT employ any RET instructions. 

Pure procedure machine insenions need to know the layout of the parameters presented to, in this 
case, the called procedure. In panicular, careful knowledge about the way parameters arc passed 
is required to achieve a succesful machine procedure. When not INLINE a block is created around 
the call which allows addressing of parameters, and code for exiting the procedure js also 
automatic. 

The user takes over the responsibility for correct parameter addressing. The rules of Ada 
procedure calls must be followed. The calling conventions are summarized below. 


240 






F.9.5J Parameter Transfer 


It may be a problem to figure out the correct number of words which the parameters take up on 
the stack (the x value). The following is a short description of die transfer mcdiod: 

INTEGER types take up at least 1 storage unit. 32 bit integer types take up 2 words, and 64 bit 
integer types take up. 4 words. In 32 bit targets, 16 bit integer types take up 2 words the low 
word being the value and the high word being an alignment word. TASKs arc transferred as 
INTEGER. 

ENUMERATION types take up as 16 bit INTEGER types (see above). 

FLOAT types take up 2 words for 32 bit floats and 4 words for 64 bit floats. 

ACCESS types are considered scalar values and consist of a 16 bit segment value and a 16 or 
32 bit offset value. When 32 bit offset value, the segment value takes up 2 words the high word 
being the aligment word. The offset word(s) arc the lowest, and the segment word(s) are the 
highest. 

RECORD types are always transferred by address. A record is never a scalar value (so no 
post-procedure action is carried out when the record parameter is OUT or IN OUT). The 
representation is as for ACCESS types. 

ARRAY values arc transferred as one or two ACCESS values. If the array is constrained, only 
the array data address is transferred in the same manner as an ACCESS value. If the array is 
unconstrained below, the data address will be pushed by the address of the constraint. In this 
ease, the two ACCESS values will NOT have any alignment words in 32 bit targets. 

Packed ARRAY values (e.g. STRING types) are transferred as ARRAY values with the addition 
of an INTEGER bit offset as the highest word(s): 

+H: BIT_OFFSET 
+L: DATA_ADDRESS 

+0: CONSTRAINT_ADDRESS -- may be missing 

'Hie values L and H depend on the presence/absence of the constraint address and the sizes of 
constraint and data addresses. 

In the two latter eases, the form parameter'address will always yield the address of the data. If 
access is required to constraint or bit offset, the instructions must use the ADDRESS form. 


F.9.5.4 Example 

A small example is shown below (16 bit target): 
procedure unsigned_add 


(opl 

: in 

integer; 

op2 

: in 

integer; 

res 

: out 

integer); 


241 





Notice that machine subprograms cannot be functions. 
The parameters take up: 


opl 

: integer : 

1 word 

op2 

: integer : 

1 word 

res 

: integer : 

1 word 

Total 

; 

3 words 


The body of the procedure might then be the following assuming that the procedure is 
defined at outermost package level: 


procedure unslgn«d_add 

(opl : in Integer; 

op2 : In integer; 

res ; out integer) is 

begin 

pragma abstract_acode_lnsertions(true); 
aa_lnstr' (aa_Creat«_Block, 3,1,0, 0, 0); — x - 3, y - 1 

aa_instr'(aa_End_of_declpart,0,0,0,0,0); 
pragma abstract_acode_lnsertlons(false); 

machine_instructlon'(register_system_address, m_MOV, 

AX, opl'address); 

machine_instruction' (register_system_address, m_ADD, 

AX, op2'address); 

machlne_instruction*(Immediate, m_JNC, 1); 

machine_lnstructlon' (Immediate, m_INT, S) ; 

machine_lnstructlon' (Immediate, ra_label,l); 

machlne_lnstruction* (system_address_register, re_MOV, 

res'address, AX); 

pragma abstract_acode_insertlons(true) ; 
aa_instr'(aa_Exlt_subprgrm,0,0,0,nil_arg,nil_arg);-- (2) 
aa_instr' (aa_Set_block_level,0,0,0,0,0); — y-1 - 0 

pragma abstract_acode_insertlons(false); 
end unsigned_add; 

A routine of this complexity is a candidate for INLINE expansion. In this case, no changes to the 
above ’machinejnstruction’ statements are required. Please notice that there is a difference between 
addressing record fields when the routine is INLINE and when it is not: 


type rec is 
record 
low 
high 

end record; 

procedure add_32 is 

(opl : in integer 

op2 : in integer, 

res : out rec); 

The parameters take up 1 + 1 +2 words = 4 words. The RES parameter will be 

addressed directly when INLINE expanded, i.e. it is possible to write: 


: integer, 
: integer; 







machine Jnstruction’(systcm_addrcss_rcgistcr, m_MOV, 

rcs'addrcss, AX); 

This would, in the not 1NL1NED version, be the same as updating that place on the stack where 
the address of RES is placed. In this ease, the insertion must read: 

machineJnstruction’(rcgistcr_syslcm_addrcss, m_LES, 

SI, rcs’addrcss); 

- LES S1.1BP+...] 

machincJnstruction’(addrcss_rcgistcr, m_MOV, 

ES, SI, nil, sca!c_l, 0, AX); 

- MOV ES:(SI+0],AX 


As may be seen, great care must be taken to ensure corecct machine code insertions. A help 
could be to first write the routine in Ada, then disassemble to see the involved addressings, and 
finally write the machine procedure using the collected knowledge. 

Please notice that INL1NED machine insertions also generate code for the procedure itself. This 
code will be removed when the -nocheck option is applied to the compilation. Also not 
INLINED procedures using the AA_INSTR insertion, which is explained above, will automatically 
get a storagc_chcck call (as do all Ada subprograms). On top of that, 8 bytes arc set aside in the 
created frame, which may freely be used by the routine as temporary space. The 8 bytes are 
located just below the display vector of the frame (from SP and up). The sioragc_chcck call will 
not be generated when the compiler is invoked with -nocheck. 

The user also has the option NOT to create any blocks at all, but then he should be certain that 
the return from the routine is made in the proper way (use the RETP instruction (return and pop) 
or the RET). Again it will help first to do an Ada version ana sec what the compiler expects to 
be done. 

Symbolic fixups are possible in certain instructions. With these you may build ‘symbolic’ 
instructions byte for byte. The instructions involved all require the operand type NAME (like used 
with CALL), and the interpretation is the following: 

(name, m_DATAD, "MYNAME") a full virtual address (offset and selector) of the 

symbol MYNAME (no additional offset is possible). 

(name, m_DATAW, "MYNAME”) the offset part of the symbol MYNAME (no additional 

offset is possible). 

(name, m_DATAB, "MYNAME”) the selector value of symbol MYNAME 

In inlined machine instructions it may be a problem to obtain the address of a parameter (rather 
than the value). The LEA instruction may be used to get the offset part, but now the following 
form allows a way to load a selector value as well: 

(system_address, LES, param’address) ES is loaded with the selector of PARAM. If this 

selector was e.g. SS, it would be pushed and popped 
into ES. LES may be substituted for LFS and LCS 
for 80386. 


243 



F.10 Package Tasktypes 


The TaskTypcs packages defines the TaskConiroIBlock type. This data structure could be useful 
in debugging a tasking program. The following package Tasktypes is for all DACS-80x86 except 
for DACS-80386PM/DACS-80486PM. 

with Syst am; 
package TaskTypes is 

subtype Offset Is Systern.UnsignedWord; 
subtype BlocXld is System.UnsignedWord; 

type TasXEntry is new System.UnsignedWord; 

type EntryIndex is new System.UnsignedWord; 

type Alternativeld is new System.UnslgnedWord; 

type Ticks is new System.DWord; 

type Bool is new Boolean; 

for Bool'size use 8; 

type OIntg is new System.UnsignedWord; 

type TaskState is (Initial, 

— The task is created, but activation 

— has not started yet. 

Engaged, 

— The task has called an entry, and the 

— call is now accepted, le. the rendezvous 
-- is in progress. 

Running, 

-- Covers all other states. 

Delayed, 

— The task awaits a timeout to expire. 

EntryCallingTimed, 

— The task has called an entry which 

— is not yet accepted. 

EntryCalllngUncondittonal, 

-- The task has called an entry unconditionally, 

-- which is not yet accepted. 

SelectingTlmed, 

— The task is waiting in a select statement 

— with an open delay alternative. 

SelectlngUncondlttonal, 

— The task waits in a select statement 

— entirely with accept statements. 

SelectIngTermlnable, 

-- The task waits in a select statement 

— with an open terminate alternative. 

Accepting, 

— The task waits in an accept statement. 

Synchronizing, 

— The task waits in an accept statement 
-- with no statement list. 

Completed, 

— The task has conpleted the execution of 
-- its statement list, but not all dependent 

— tasks are terminated. 

Terminated ); 

— The task and all its descendants 

— are terminated. 


244 


for 


TaskState 


uae (Initial -> 161001 . 

Engaged •> 161081 , 

Running -> 16#10# , 

Delayed -> 16118# . 
EntryCalllngTlmod -> 16120# , 
EntryCalllngOnccndltlonal -> 16#28# 
SelectlngTlmed ■»> 16(31# , 
SelectlngOnconditlonal -> 16(39# , 
SelectlngTerminable -> 16(41# , 
Accepting -> 16(4A( , 

Synchronizing -> 16(S3( , 

Completed -> 16# 5C# , 

Terminated -> 16(64#); 

for TaskState'size use 8; 

type TaskTypeDeacriptor la 
record 

priority : System.Priority; 

entry_count : OIntg; 

block_ld : Blockld; 

flrat_own_addreas : System.Address; 

module_number : OIntg; 

entry_number ; OIntg; 

code_addresa : System.Address; 

stack_slze : System.DWord; 

dummy : Integer; 

stack_segment_slze: OIntg; 
end record; 

type AccTaskTypeDescrlptor is access TaskTypeDescrlptor; 

type NPXSaveArea Is array(1..48) of System.OnslgnedWord; 

type FlagsType is 
record 

NPXFlag : Bool; 

InterruptFlag : Bool; 

end record; 

pragma pack(FlagsType); 

type StatesType is 
record 

state : TaskState; 

ls_abnormal : Bool; 

ls_actlvated : Bool; 

failure : Bool; 

end record; 

pragma pack(StatesType) ; 

type ACF_type Is 
record 

bp ; Offset; 

addr : System.Address; 

end record; 

pragma pack(ACF_type); 
pragma page; 

type TaskControlBlock Is 
record 

sera ; System.Semaphore; 

IsMonitor : Integer; 

-- Delay queue handling 

dnext : System.TaskValue ; 

dprev : System.TaskValue ; 

ddelay ; Ticks ; 

-- Saved registers 

SS : System.UnsignedWord ; 


245 




DACS-S0x86 User’s Guide 
Implementation-Dependent Characteristics 


— Auxiliary fields 

ttd : AccTaskTypeDescrlptoc; 

TirsCCallor : System.TaskValue; 

— Run-Time System fields 

ACF : ACF_typo; — cf. User's guide 9.4.2 

SQFlrst : Integer; -- Only used in RMS 

SemFirst : Integer; — Only used in RMS 

TBlockingTask : System.TaskValue; — Only used in RMS 

PBlocklngTask : System.TaskValue; — Only used in RMS 

collection : System.Address; 

partition : Integer; 

TaskCheckLimit : Offset; — to assure inline storage check 

LastException : System.DWord; --2*16 bits 

SavedAdaAddr : Offset; -- to Improve rendezvous's 

— NPX save area 

— When the application is linked with -npx, a special 

— save area for the NPX is allocated at the very end 
-- of every TCB. 

— la: 

case NPX_Present is 

when TRUE “> NPXsave : NPXSaveArea; 
when FALSE “> null; 

— end case; 

end record; 

— The following is to assure that the TCB has the expected size: 

TCB_slze : constant integer TaskControlBlock'size / 8; 

subtype TC3_ok_value is INTEGER range 136 . . 136; 

TCB_ok constant TCB_ok_value :« TaskControlBlock'size / 8; 

end TaskTypes; 


F.ll RMS Tasking (OPTIONAL) 

The DACS-80x86 systems may run tasking applications by means of Rate Monotonic Scheduling 
(RMS). RMS capability is purchased optionally, and is thus not included by default. Please contact 
DDC-I for more information regarding RMS and your system. RMS allows the programmer to 
guarantee properties of a tasking system, i.e. that tasks will meet their hard deadlines. The RMS 
tasking is selected by specifying -rms to the Ada link command. 


247 








