RE AD""A242 283 page 

9 tmrn } iiiiiii iiii mil liiii mil mi, ,1,1. 


Public rapofting burdtn for tf 
n—d o d. and ftuttuHng tt>» o 
HMdquvtM Strvio*. Olr«c 
Managtffwnt and Budgat Washington. OC 20S03. 


Fom Approved 
OPMNo. 0704-01B3 




1. AGENCY USE ONLY (Leave Blank) 2. REPORT DATE 3. REPORT TYPE AND DATES COVERED 

Rnal: 09 Aug 1991 to 01 Jun 1993 


h* Dim lor rtvtMing Iratiiictlm HiRMig (iMtig daa nutcM gMtwing and inainaMng iha daa 
■raapactotltiiicoltctlonCMannaion, Including tuggtulont (or rtducing diia burdan, to Washington 
u 1204. Aflingun. VA 22202-4302. and to dw Odica o( totoimalion and Ragulaloty Affaiis. Offios c( 


3. REPORT TYPE AND DATES COVERED 


4. TITLE AND SUBTITUE 

Alsys, Inc., AlsyCOMP_024, Version 5.3, IBM RISC System 6000, Model 520 under 
IBM AIX V3.1 (Host & Target), 910809W1.11195 , 


5. RJNDING NUMBERS 


6. AUTHOR(S) 

Wright-Patterson AFB, Dayton, OH 
USA 


, f r-T •: 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS<ES) 

Ada Validation Facility, Language Control Facility ASO/SCEL 
BkJg. 676, Rm 135 

Wright-Patterson AFB, Dayton, OH 45433 


S^nBUPDRMING ORGANIZATION 
REPORT NUMBER 

AVF-VSR-499-0891 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESSEES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm 3E114 
Washington, D.C. 20301-3081 


11. SUPPLEMENTARY NOTES ^ , 

j\y y lj i~’'j / lLCC L y c/c y ,>-i v' ^ ^ ^ • L. , 

L- , J /)It, k c {< 11 / y Af / ^ '■‘■j ^^ 


10. SPONSORINGAHONITORING AGENCY 
REPORT NUMBER 


12a DISTRIBUTION/AVAILABIUTY STATEMENT 

Approved for public release; distribution unlimited. 


12b. DISTRIBUTION CODE 


13 ABSTRACT (Maximum 200 words) 

Alsys, Inc., AlsyCOMP_024, Version 5.3, Wright-Patterson AFB, OH, IBM RISC System 6000, Model 520 under IBM AIX 
V3.1 (Host & Target), ACVC 1.11. 


91-15063 




14 SUBJECT TERMS 


Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17 SECURITY CLASSIFICATION 
OF REPORT 

UNCLASSIFIED 


NSN 7540-01-280-550 


18 SECURITY CLASSIFICATION 


UNCLASSIFED 


19. SECURITY CLASSIFICATION 
OF ABSTRACT 
UNCLASSIFIED 


! I 04 1^4 


15. NUMBER OF PAGES 


16. PRICE CODE 


20. LIMITATION OF ABSTRACT 


Standard Form 298, (Rev. 2-89) 
Prescribed by ANSI Std. 239-128 




























AVF Control Number: AVF-VSR-499-0091 

26 August 1991 
91-04-22-ALS 


Ada CCaiPILER 
VALIDATIC»I SUMMARY REPORT: 

Certificate Number; 910809W1.11195 
Alsys, Inc. 

AlsyCOMP_024, version 5.3 

IBM RISC System 6000, Model 520 under IBM AIX v3.1 ■> 
IBM RISC System 6000, Model 520 under IBM AIX v3.1 


Prepared By; 

Ada Validation Facility 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 




) tr^’i ' r., 

i 




■ ■ *7 \ . 







Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was conpleted on 9 August 1991. 

Conpiler Name and Version: AlsyCCaip_024, version 5.3 

Host Ccmoputer System: IBM RISC System 6000, Model 520 

under IBM AIX v3.1 

Target Computer System: IBM RISC System 6000, Model 520 

under IBM AIX v3.1 

Customer Agreement Number: 91-04-22-ALS 


See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
910809W1.11195 is awarded to Alsys, Inc. This certificate expires on 1 
June 1993. 


This report has been reviewed and is approved. 



Steven P. Wilson 
Technical Director 
ASD/SCEL 


Wright-Patterson AFB OH 45433-6503 





Director 

Institute 



Alexemdria VA 22311 


Organization 

ter and Software Engineering Division 
r Defense Analyses 



Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 





DECLARATION OF CONFORMANCE 


CUSTOMER; 

ADA VALIDATION FACILITY: 


Alsys, Inc. 

Ada Validation Facility (ASD/SCEL) 
Computer Operations Division 
Information Systems and Technology Center 
Wright-Patterson AFB OH 45433-6503 


ACVC VERSION: 


ADA IMPLEMENTATION: 

COMPILER NAME AND VERSION: 
HOST COMPUTER SYSTEM: 

TARGET COMPUTER SYSTEM: 


ALSYCOMP_024, version 5.3 

IBM RISC System 6000, model 520 
under IBM AIX v3.1 

IBM RISC System 6000, model 520 
under IBM AIX v3.1 


CUSTOMER’S DECLARATION 


I the undersigned, representing Alsys, Inc., declare that Alsys, Inc. has no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STD-1815A in the implementation listed in this 


declaration. 








George Romanski 

Vice President, Engineering 

Alsys, Inc. 

67 South Bedford Street 
Burlington, MA 01803-5152 


1 



TABLE OF CC»JTENTS 


C3iAPTER 1 INTFODUCTIOJ 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS .2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COIPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 













CHAPTER 1 


INTRODUCTIC»J 


The Ada inplementation described above was tested according to the Ada 
Validation Procedures [Pro90] against the Ada Standard [Ada83] using the 
current Ada Coitpiler Validation Capedaility (ACVC). This Validation Summary 
Report (VSR) gives an account of the testing of this Ada inplementation. 

For any technical terms used in this report, the reader is referred to 
[Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATICXa SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the counters, operating systems, and compiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warreuit that all statements set forth in this report are 
accurate 2 uid con?)lete, or that the subject inplementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results should be 
directed to the AVF vrtiich performed this validation or to: 

Ada Validation Organization 

Conputer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1-1 



INTRODUCTION 


1.2 REFERENCES 

Reference Meinvial for the Ada Progrannning Language, [Ada83} 
ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

Ada Conpiler Validation Procedures, Version 2.1, tPro90] 

Ada Joint Program Office, August 1990. 

Ada Compiler Validation Capability User's Guide, [UG89] 21 June 1989. 


1.3 ACVC TEST CLASSES 

Conpliance of Ada inplementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: A, 
B, C, D, E, and L. The first letter of a test name identifies the class to 
vrtiich it belongs. Class A, C, D, and E tests are executable. Class B and 
class L tests are expected to produce errors at conpile time and link time, 
respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the restilt vdten they 
are executed. Three Ada library tuiits, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat some conpiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a conpiler detects illegal Icinguage usage. Class 
B tests are not executeible. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Steuidard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the conpiler. This behavior is 
also verified. 

Class L tests check that ein Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in ^pendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 


1-2 


INTRODUCTIW 


For each Ada implementation, a customized test suite is produced by the 
AVF. Hiis customization consists of making the modifications described in 
the preceding paragraph, removing withdravm tests (see section 2.1), and 
possibly removing some inapplice±)le tests (see section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 

Ada Compiler The software cind any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compiler The means for testing complieince of Ada implementations. 
Validation consisting of the test suite, the support programs, the ACVC 

Capability user's guide and the template for the validation sumnary 

(ACVC) report. 

Ada An Ada compiler with its host computer system and its 

Implementation target computer system. 

Ada Joint The part of the certification body v^ich provides policy and 
Program guidance for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification body which carries out the 

Validation procedures required to establish the complieuice of an Ada 
Facility (AVF) implementation. 

Ada The part of the certification body that provides technical 

Validation guidimce for operations of the Ada certification system. 

Organization 
(AVO) 

Complicuice of The ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer A functional unit, consisting of one or more computers and 

System associated software, that uses common storage for all or 

part of a program auid also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 


INTRODUCTION 


Confonnity 


Customer 


Declaration of 
Conformance 


Host Con^juter 
System 

Inapplicable 

test 

ISO 

LRM 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Conpiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


Fulfillment by a product, process, or service of all 
requirements specified. 

An individual or corporate entity vrtio enters into an 
agreement with an AVF vdiich specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainedale on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

International Organization for Standardization. 

The Ada standard, or Language Reference Manual, published as 
ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRM take the form ”<section>.<subsection>:<paragraph>." 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
conplete hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The conpiler of a validated Ada inplementation. 


An Ada inplementation that has been validated successfully 
either by AVF testing or by registration [Pro90]. 

The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 



CHAPTER 2 


implementatioi dependencies 


2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is availeJale from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 2 August 1991. 


E28005C 

B28006C 

C32203A 

C34006D 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

C83026A 

B83026B 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 



2.2 INAPPLICABLE TESTS 

A test is inappliccible if it contains test objectives which are irrelevant 
for a given Ada implementation. Reasons for a test's inapplicability may 
be supported by documents issued by the ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 



IMPLEMENTATiai DEPENDENCIES 


The following 201 tests have floating-point type declarations 
requiring more digits them SYSTEM.MAX_DIGITS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..2 (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L,.Z (15 tests) 


The following 20 tests checlc for the predefined type LQMG_INTEGER; for 
this implementation, there is no such type: 


C35404C 

C45502C 

C45613C 

C55B07A 


C45231C 

C45503C 

C45614C 

B55B09C 


C45304C 

C45504C 

C45631C 

B86001W 


C45411C 

C45504F 

C45632C 

C86006C 


C45412C 

C45611C 

B52004D 

CD7101F 


C35713D and B86001Z checlc for a predefined floating-point type with a 
name other than FLOAT, LONG_FLQAT, or SHORT_FLQAT; for this 
inplementation, there is no such type. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations for 
types that require a SYSTEM.MAX MANTISSA of 47 or greater; for this 
implementation, MAX_MANTISSA is less than 47. 

C45536A, C46013B, C46031B, C46033B, and C46034B contain length clauses 
that specify values for 'SMALL that are not powers of two or ten; this 
in^jlementation does not support such values for 'SMALL. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLCWS is FALSE for floating point types emd the results of 
various floating-point operations lie outside the range of the laase 
type; for this implementation, MACHINE_OVERFLOWS is TRUE. 

B86001Y uses the name of a predefined fixed-point type other than type 
DURATIC»I; for this inpleraentation, there is no such type. 

C96005B uses values of type DURATlCX^'s base type that are outside the 
remge of type DURATIOTJ; for this implementation, the ranges are the 
same. 


CD1009C checks whether a length clause can specify a non-default size 
for a floating-point type; this implementation does not support such 
sizes. 

CD2A53A checks operations of a fixed-point type for v^ich a length 
clause specifies a power-of-ten TYPE'SMALL; this implementation does 
not support decimal 'SMALLs. (See section 2.3.) 


2-2 




IMPLEMENTATICW DEPENDENCIES 


CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length clauses 
to specify non-default sizes for access types; this inplementation 
does not support such sizes. 

BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code 
insertions; this inplementation provides no package MACHINE_CODE. 

CE2401H, EE2401D, and EE2401G use instantiations of DIRECT_IO with 
unconstrained array and record types; this implementation raises 
USE_ERROR on the attempt to create a file of such types. 

The tests listed in the following table check that USE_ERROR is raised 
if the given file operations are not supported for the given 
combination of mode auid access method; this implementation supports 
these operations. 


Test 

File Operation Mode 

File Access Method 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL 10 

CE2102F 

CREATE 

INOUT FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

0UT_FILE 

DIRECT 10 

CE3102F 

RESET 

Any Mode 

TEXT 10 

CE3102G 

DELETE 


TEXT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT 10 

CE3102J 

OPEN 

IN FILE 

TEXT 10 

CE3102K 

• OPEN 

OUT FILE 

TEXT 10 


The tests listed in the following table check the given file 
operations for the given combination of mode and access method; this 
implementation does not support these operations. 


Test File Operation Mode File Access Method 


CE2105A CREATE 
CE2105B CREATE 
CE3109A CREATE 


IN_FILE SEQUENTIAL_IO 

IN_FILE DIRECT_IO 

IN FILE TEXT 10 


2-3 



IMPLEMENTATK^ DEPENDEaSFCIES 


CE2203A checks that WRITE raises USE_ERROR if the capacity of an 
external sequential file is exceeded; this inplementation cannot 
restrict file capacity. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of an 
external direct file is exceeded; this inplementation cannot restrict 
file capacity. 

CE3304A checks that SET_LINE^LENGTH and SET_PAGE_LENGTH raise 
USE_ERROR if they specify an Tnappropriate value for the external 
file; there are no inappropriate values for this implementation. 

CE3413B checks that PAGE raises LAYOUT ERROR when the value of the 
page number exceeds COUNT'LAST; for this Implementation, the value of 
COUNT'LAST is greater than 150000, making the checking of this 
objective impractical. 

CE3202A expects that function NAME can be applied to the standard 
input and output files; in this inplementation these files have no 
names, and USE ERROR is raised. (See section 2.3.) 


2.3 TEST MODIFICATICWS 

Modifications (see section 1.3) were required for 20 tests. 

The following tests were split into two or more tests because this 
inplementation did not report the violations of the Ada Standard in the 
way expected by the original tests. 

B23004A B24007A B24009A B28003A B32202A B32202B 

B32202C B37004A B61012A B91004A B95069A B95069B 

B97103E BAllOlB BC2001D BC3009C 


BA2001E was graded passed by Evaluation Modification as directed by the 
AVO. The test expects that duplicate names of subunits with a common 
ancestor will be detected as compilation errors; this implementation 
detects the errors at link time, and the AVO ruled that this behavior is 
accepteJale. 

EA3004D was graded passed by Evaluation and Processing Modification as 
directed by the AVO. The test requires that either pragma INLINE is 
obeyed for a function call in each of three contexts and that thus three 
library units are made obsolete by the re-compilation of the inlined 
function's body, or else the pragma is ignored coitpletely. This 
implementation obeys the pragma except v^en the call is within the package 
specification. When the test's files are processed in the given order, 
only two units are made obsolete; thus, the expected error at line 27 of 
file EA3004D6M is not valid eind is not flagged. To confirm that indeed 
the pragma is not obeyed in this one case, the test was also processed 
with the files re-ordered so that the re-compilation follows only the 


2-4 



implementatioi dependencies 


package declaration (and thus the other library units will not be made 
obsolete, as they are compiled later); a "NOT APPLICABLE" result was 
produced, as expected. The revised order of files was 0-1-4-5-2-3-6. 

When run as is, the implementation fails to detect an error on line 27 of 
test file EA3004D6M. This is because the pragma INLINE has no effect vrtien 
its object is within a package specification. However, the results of 
running the test as-is do not confirm that the pragma had no effect, only 
that the package was not made obsolete. By re-ordering the compilations 
so that the two subprograms are compiled after file D5 (the re-conpilation 
of the "with"ed package that makes the various earlier units obsolete), we 
create a test that shows that indeed pragma INLINE has no effect when 
applied to a subprogram that is called within a package specification. 

The test must execute and produce the expected NOT_APPLICABLE result (as 
though INLINE were not supported at all). The recommended re-ordering of 
EA3004D test files is: 0-1-4-5-2-3-6. 

CD2A53A was graded inapplicable by Evaluation Modification as directed by 
the AVO. The test contains a specification of a power-of-10 value as 
'SMALL for a fixed-point type. The AVO ruled that, under ACVC 1.11, 
support of decimal 'SMALLs may be omitted. 

CE3202A was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test applies fimction NAME to the standard input file, 
which in this inplementation has no name; USE_ERROR is raised but not 
handled, so the test is eiborted. The AVO ruled that this behavior is 
acceptable pending any resolution of the issue by the ARC. 


2-5 



CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIROIMENT 

The Ada iinjlementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For technical ^uld sales information about this Ada inplementation, contact; 

George Romanski, Vice-President, Engineering 
Alsys, Inc. 

67 South Bedford Street 
Burlington, MA 01803-5152 
(617) 270-0030 

Testing of this Ada implementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Inplementation passes a given ACVC version if it processes each test 
of the customized test suite in accordcince with the Ada Programming 
Language Standard, v^ether the test is applicable or inapplicable; 
otherwise, the Ada Inplementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable euid applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


3-1 




PRCXiJESSING INFORMATiai 


The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were withdrawn 
because of test errors (item b; see section 2.1), those that require a 
floating-point precision that exceeds the iiqplementation's maximum 
precision (item e; see section 2.2), and those that depend on the support 
of a file system — if none is supported (item d). All tests passed, 
except those that are listed in sections 2.1 and 2.2 (counted in items b 
and f, below). 


a) Total Number of Applicable Tests 3794 

b) Total Number of Withdrawn Tests 95 

c) Processed Inapplicaible Tests 80 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 201 

f) Total Number of Inapplicable Tests 281 


g) Total Number of Tests for ACVC 1.11 4170 


3.3 TEST EXECUTiai 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the validation team for processing. The contents of the 
magnetic tape were loaded directly onto a VAX system (from a standard 1/2 
inch, 9-track VMS BACKUP tape) and then transferred to the IBM RISC System 
6000 via ethernet. 

After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada implementation. 

The tests were compiled, linked, and executed on the host computer system, 
as appropriate. The results were captured on the computer system. 

Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a complete listing of 
the processing options for this implementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were: 


Compiler Options: 


TEXT -> 

NO 

Do not show source code in listing 
(used for all but the B tests) 

TEXT => 

YES 

Show source code in listing 
(used for the B tests) 


3-2 




prcx:essing informatics 


SHCW ®> NO Do not show header nor error summary in 

listing. 

WARNING -> NO Do not include warning messages. 

ERRORS “> 999 M 2 ucimum number of compilation errors 

permitted before terminating the compilation. 

CALLS => INLINED This option allows insertion of code for 

siibprograms inline and must be set for the 
pragma INLINE to be operative. 

GENERICS “> STUB This option places code of generic 

instantiations in separate subunits. 


The default options were used for all binds. 

Test output, compiler and linker listings, etfid job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 


3-3 



APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
Hie meaming and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tallies. The first taible lists the 
values that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string aggregates, where "V" represents the maucimum input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 

255 


$BIG_ID1 

(1..254 -> 'A', 255 -> '1') 


$BIG_ID2 

(1..254 *> 'A', 255 -> '2') 


$BIG_ID3 

{1..127 => 'A') & '3' & (1..127 -> 

'A') 

$BIG_ID4 

(1..127 -> 'A') & '4' & (1..127 -> 

'A') 

$BIG_INT_LIT 

(1..252 -> '0') & "298" 


$BIG_REAL_LIT 

(1..250 => '0') & "690.0" 


$BIG_STRING1 

& (1..127 -> 'A') & 


$BIG_STRING2 

& (1..127 -> 'A') & '1' & 


$BLANKS 

(1..235 


$MAX LEN INT BASED 

LITERAL 



"2:" & (1..250 => '0') & "11:" 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..248 »> '0') & "F.E:" 

$MAX_STRING_LITERAL & (1..253 => 'A') & 


A-1 




MACRO PARAMETERS 


The following tedale lists all of the other macro parameters and their 
respective values. 

Macro Parameter Macro Value 

$ACC_SIZE 32 

$ALI(2®1ENT 4 

$COUNT_LAST 2147483647 

$DEFAULT_MEM_SIZE 2**32 

$DEFALILT_STOR_UNIT 8 

$DEFAULT_SYS_NAME RS_6000 

$DELTA_DOC 2#1.0#E-31 

$ENTRY_ADDRESS FCNDECL.ENTRY_ADDRESS 

SENTRY_ADDRESS1 FCNDECL.ENTRY_ADDRESS1 

$ENTRY_ADDRESS2 FCNDECL.ENTRY_ADDRESS2 

$FIELD_LAST 255 

$FILE_TERMINATOR ' ' 

$FIXED_NAME NO_SUCH_FIXED_TYPE 

$FLQAT_NAME NO_SUCH_FLClAT_TYPE 

$FORM_STRING 

$FORM_STRING2 "CANNOT_RESTRICT_FILE_CAPACITY" 

$GREATER_THAN_DURATI(»J 

75_000.0 

$GREATER_THAN_DURATION BASE LAST 

I31_0T3.0 

$GREATER_THAN_FLQAT_BASE LAST 

1 .TJE+39 

$GREATER_THAN_FLCIAT_SAFE LARGE 

1 .TJe+38 


A-2 





macro parameters 


$GREATER THAN SHORT FLOAT_SAFE_LARGE 

l.OE+38 

$HIGH_PRIORITY 10 

SILLEGAL EXTERNAL FILE NAMEl 

- ~ 7this/is/a/junk/di rectory/name 

SILLEGAL EXTERNAL FILE NAME2 

~ “ THIS-FILE-NAME-IS-TOO- 

L(»JG-F0R-MY-SYSTEM 

$ INAPPROPRIATE_LINE_LENG'ni 

$inappropriate_page_length 

$INCLUDE PRAC31A1 PRAGMA INCLUDE ( "A28G06D1.TST") 

$INCLUDE PRAGMA2 PRAC31A INCLUDE ("B28006D1.TST") 

$INTEGER_FIRST -2147483648 

$INTEGER_LAST 2147483647 

$INTEGER_LAST_PLUS_1 2147483648 
$INTERFACE_LANGUAGE C 
$LESS_THAN_DURATIC»J -75__000.0 

sless than duration base first 
- “ " -lll_073.0 

$LINE_TERMINAT0R ASCII.LF 

$LOW_PRIORir/ 1 

SMACHINE CODE STATEMENT 

NULL; 

$MACHINE_CODE_TYPE NO_SUCH_TYPE 
$MANTISSA_DOC 31 

$MAX_D1GITS 15 

$MAX INT 2147483647 

$MAX_INT_PLUS_1 2_147_483_648 

$MIN INT -2147483648 


A-3 




MACRO PARAMETERS 


$NAME 

SHORT_SHORT_INTEGER 

$NAME_LIST 

S370,180X86,I80386,MC680X0,VAX 
TRANSPUTER,RS_6000,MIPS 

$NAME_SPECIFICATIONl 

/alsys/acvc/X2120A 

$NAME_SPECI FICATIC»a2 

/alsys/acvc/x2120B 

$NAME_SPECIFICATIC»I3 

/alsys/acvc/X3119A 

$NEG_BASED_INT 

16#FOOOOOOE# 

$NEW_MEM_SIZE 

2**32 

$NEW_STOR_llNIT 

16 

$NEW_SYS_NAME 

RS_6000 

$PAGE_TERMINATOR 

ASCII.LF & ASCII.FF 

$RECORD_DEFINITIC»I 

NEW_INTEGER 

$RECORD_NAME 

NO_SUCH_MACHINE_CODE_TYPE 

$TASK_SIZE 

32 

$TASK_STORAGE_SIZE 

1024 

$tic:k 

0.1 

$VARIABLE_ADDRESS 

FCNDECL.VARIABLE_ADDRESS 

$VARIABLE_ADDRESS1 

FCNDECL.VARIABLE_ADDRESS1 

$VARIABLE_ADDRESS2 

FCNDECL.VARIABLE_ADDF£SS2 

$YOUR PRAC21A 

INTERFACE 


A-4 




APPENDIX B 

COMPILATICW SYSTEM OPTIONS 


Hie conpiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 

Compiler Options: 

COMPILE (SOURCE «> SOurce_name | INSTANTIATICW, 

LIBRARY »> library_nanie, 

OPTIONS »> 

(ANNOTATE -> character string, 

ERRORS *> positive_Tnteger, 

LEVEL -> PARSE | SEMANTIC | CODE | UPDATE, 

CHECKS -> ALL | STACK 1 NC»JE, 

GENERICS -> STUBS | INLINE, 

FLOAT -> OPTIMIZED | IEEE, 

MEMORY -> niimber_of_kbytes), 

DISPLAY -> 

(OUTPUT «> SCREEN | NONE | AUTOMATIC ] file_n 2 une, 

WARNING -> YES | NO, 

TEXT *> YES I NO, 

SHOW => BANNER | RECAP | ALL | NCXJE, 

DETAIL -> YES | NO, 

ASSEMBLY »> CODE | MAP | ALL | fOJE), 

ALLOCATIC»r => 

(CONSTANT => positive_integer, 

GLOBAL *> positive_integer), 

IMPROVE -> 

(CALLS -> NORMAL | INLINED, 

REDUCTION -> NC»JE | PARTIAL | EXTENSIVE, 

EXPRESSIWS -> NCM: I PARTIAL | EXTENSIVE, 

OBJECT -> NC»IE I PARTIAL j EXTENSIVE), 

KEEP => 

(COPY -> YES 1 NO, 

DEBUG -> YES | NO, 

TREE -> YES I NO)); 


B-1 


COMPILATION SYSTEM OPTIC»4S 


OPTIOI/SWITCH 


EFFECT 

SOURCE 

-> 

source_naine | INSTANTIATION 

Name of source file. 

LIBRARY 

=> 

librai:y_naine 

Name of program library. 

ANNOTATE 

-> 

character string 

Comment string for library 
addition. 

ERRORS 

-> 

positive_integer 

Abort compilation after count 
of errors. 

LEVEL 

=> 

PARSE 1 SEMANTIC ( CODE | UPDATE Specify level of 

compilation. 

CHECKS 

=> 

ALL 1 STACK | NONE 

Specify which compilation 
checks to be done. 

GENERICS 

-> 

STUBS 1 INLINE 

Specifies vdiere expeinsion of 
generic instantiation are. 

FLOAT 

-> 

OPTIMIZED 1 IEEE 

Specify IEEE standard or 
faster, optimized sequences. 

MEMORY 

-> 

nuniber_of kbytes 

Sizes internal conpiler work 
area. 

OUTPUT 

-> 

SCREEN 1 NONE [ AUTOMATIC | 

file name Directs the output 

WARNING 

=> 

YES 1 NO 

Generate warning messages? 

TEXT 

-> 

YES 1 NO 

Include full source text in 
listing? 

SHOW 

-> 

BANNER 1 RECAP | ALL \ NONE 

Specify banner eind error 
summary display. 

DETAIL 

-> 

YES 1 NO 

Generate detailed diagnostics? 

ASSEMBLY 

-> 

CODE ( MAP f ALL ( NONE 

Controls listings of generated 
code and data layout. 

CCX^STANT 

•> 

positive_integer 

Controls runtime location of 
constants (TOC vs. Heap). 

GLOBAL 

-> 

positive_integer 

Controls runtime location of 
global data. 

CALLS 

-> 

NORMAL 1 INLINED 

Activates pragma inline. 

REDUCTIW 

»> 

NONE 1 PARTIAL | EXTENSIVE 

Controls high level optimizer. 

EXPRESSIONS 

«> 

NONE 1 PARTIAL [ EXTENSIVE 

Controls low level optimizer. 

COPY 

-> 

YES 1 NO 

Copy source text to library? 

DEBUG 

«> 

YES 1 NO 

Save debug info in library? 

TREE 

»> 

YES 1 NO 

Save intermediate program 
representation? 




COMPILATICN SYSTEM OPTIONS 


LINKER OPTIC^IS 

The linker options of this Ada implementation, as described in this 
;^pendix, are provided by the customer, unless specifically noted 
otherwise, references in this appendix are to linker documentation and not 
to this report. 


Binder Options: 

BIND (PROGRAM “> unit_name, 

LIBRARY -> library_name, 

OPTICWS => 

(LEVEL -> CHECK 1 BIND 1 LINK, 

OBJECT -> AUTOMATIC | file_name, 

UNCALLED -> REMOVE | KEEP, 

SLICE »> NO I positive_integer, 

BLOCKING => YES 1 NO I AUTOMATIC), 

STACK -> 

(MAIN => positive_integer, 

TASK => positive_integer, 

HISTORY -> MAIN | TASK | ALL | NONE), 

HEAP -> 

(SIZE ■> positive integer, 

INCREMENT -> natural_rnteger), 

INTERFACE -> 

(DIRECTIVES -> options_for_linker, 

MODULES => file_nai5es, 

SEARCH => library__names), 

DISPLAY -> 

(OUTPUT -> SCREEN | NONE | AUTOMATIC | file_name, 

DATA => BIND | LINK | ALL 1 NCNE, 

WARNING *> YES | NO), 

KEEP -> 

(DEBUG -> YES 1 lO)) ; 


B-3 



COMPILATIC»J SYSTEM OPTIONS 


OPTICN/SWITCH 

EFFECT 

PROGRAM 

-> inainjprogram_naine 

Ada name of main subprogram. 

LIBRARY 

«> library name 

Name of program library. 

LEVEL 

-> CHECK 1 BIND 1 LINK 

Specify level of bind. 

OBJECT 

-> AUTOMATIC 1 file name 

Name of object module. 

UNCALLED 

=> REMOVE 1 KEEP 

Removes or keeps uncalled 
sxibprograms. 

SLICE 

=> NO 1 positive integer 

Define time-slice. 

BLOCKING 

=> YES 1 NO i AUTOMATIC) 

Does I/O block other tasks? 

MAIN 

*> positive integer 

Size of main stack. 

TASK 

=■> positive integer 

Size of task stack. 

HISTORY 

-> YES 1 NO 

Gen^'rate stack traces for 
unhandled exceptions? 

SIZE 

-> positive integer 

Size the initial heap 
allocation. 

INCREMENT 

*> positive integer 

Size siJibsequent heap 
allocations. 

DIRECTIVES 

=> options_for_linker 

Supplies linker directives. 

MODULES 

=> file_names 

Additional object modules. 

SEARCH 

*> library names 

Additional object libraries. 

OUTPUT 

-> SCREEN T none | AUTOMATIC | 

file name Location of 

binder listing. 

DATA 

-> BIND 1 LINK 1 ALL | NONE 

Amount of data to be 
included in binder listings. 

WARNING 

-> YES 1 NO 

Generate warning messages? 

DEBUG 

-> YES 1 NO 

Generate debug information? 




APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed inplementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this Appendix are to con 5 )iler documentation and not to this 
report. Implementation-specific portions of the package STANDARD, vdiich 
are not a part of Appendix F, are: 


package STANDARD is 

type INTEGER is range -2_147_483_648..2_147_483_647; 

type FLOAT is digits 6 range 

-2#1.111_1111_1111_1111 1111 1111#E+127.. 
2#1.111_1111_1111_1111_1111_1111#E+127; 

type DURATION is delta 2#0.000_000 000 000 01# range 
-131072.00000..131071.99994; 

type SHORT_INTEGER is range -32768..32767; 

type SHORT_SHORT_INTEGER is range -128..127; 

type SHORT FLOAT is digits 6 range 

-2#1.11T_1111_1111_1111_1111_1111#E+127.. 

2#1.lll_llll_llll_llll_llll_llll#E+127; 

type LONG FLOAT is digits 15 range 

-2#l.llll_lllT_llll_llll_llli_llll_llll_llll_llll_llll_llll_llll_llll#E+1023 
2#i.iiii_iiii_iiii iiii_iiii 1111 nil nil nil nn nn nn ini#E+i023; 


end STANDARD; 







BETA DOCUMENTATION - MAY 1991 


Alsys Ada Software Development Environment 
for RS/6000 


APPENDIX F 


Version 5 



Copyright 1991 by Aisys 


All rights reserved. No part of this document may be reproduced in any form or by any 
means without permission in writing from Aisys. 


Printed: May 1991 

Aisys reserves the right to make changes in specifications and other information 
contained in this publication without prior notice. Consult Aisys to determine 
whether such changes have been made. 


Aisys, Ada World AdaProbe. AdaXref, AdaReformai, and AdaMake are registered tradetnarks of Aisys. 
L nix IS a reguiered trademark of AT&T. 

386/ix is a registered trademark of Interactive Systems Corporation. 

Microsoft is a registered trademark of Microsoft Corporation. 

IBM. PC AT and PS/2 are registered trademarks of International Business Machines Corporation. 
INTEL is a reeistered trademark of Intel Corporation. 



TABLE OF CONTENTS 


APPENDIX F 


1 Implementation-Dependent Pragmas 

1.1 INUNE 

1.2 INTERFACE 

1.3 INTERFACE_NAME 

1.4 INDENT 

1.5 Other Pragmas 

2 Implementation-Dependent Attributes 

2.1 P’IS_ ARRAY 

12 P’RECORD.DESCRIPTOR. P’ARRAY^DESCRIPTOR 

13 E’EXCEPTION.CODE 

3 Specification of the package SYSTEM 

3.1 Specification of the package SYSTEM 

4 Support for Representation Clauses 

4.1 Enumeration Types 

4.1.1 Enumeration Literal Encoding 

4.1.2 Enumeration Types and Object Sizes 

4.2 Integer Types 

4.2.1 Integer Type Representation 

4.2.2 Integer Type and Object Size 

4.3 Floating Point Types 

4.3.1 Floating Point Type Representation 

4.3.2 Floating Point Type and Object Size 

».4 Fixed Point Types 


Table of Contents 






4.4.1 Fixed Point Type Representation 
4 A2 Fixed Point Type and Object Size 

4 5 Access Types and Collections 

4.6 Task Types 

4.7 Layout and Structure and Pragma PACK 

4.7.2 Array Subtype and Object Size 

4.8 Record Types 

4.8.1 Basic Record Struaure 

4.8.2 Indirect Components 

4.8.3 Implicit Components 

4.8.4 Size of Record Types and Objects 


21 

22 

24 

24 

25 
25 
28 
29 
29 
29 
33 
37 


5 

Conventions for Implementation-Generated Names 

39 

41 

6 

Address Clauses 

41 

6.1 

Address Causes for Objects 

41 

6.2 

Address CUuses for Program Units 

42 

63 

Address Clauses for Interrupt Entries 

43 

7 

Unchecked Conversions 


8 

Input-Output Packages 

45 

45 

8.1 

Introduction 

46 

8.2 

The FORM Parameter 

47 


8.2.1 File Protection 

49 


8.2.2 File Sharing 

50 


8.2.3 File Structure 

52 


8.2.4 Buffering 

52 


8.2.5 Appending 

52 


8.2.6 Blocking 

8.2.7 Terminal Input 

53 


H 


Appendix F, Version 5 



9 Characteristics of Numeric T^pes 

9.1 Integer Types 

9.2 Floating Point Type Attributes 

9.3 Attributes of Ty^ DURATION 


10 Other Implementation-Dependent Characteristics 

10.1 Characteristics of the Heap 

10.2 Characteristics of Tasks 

10.3 Definition of a Main Subprogram 

10.4 Ordering of Compilation Units 


11 Limitations 

11.1 Compiler Limitations 

11.2 Hardware Related Limitations 


INDEX 


Table of Concents 



Appendix F, Version 5 




APPENDIX F 


Implementation - Dependent Characteristics 


This appendix summarizes the implementation-dependent characteristics of the Alsys 
Ada Software Development Environment for RS/6000. Appendix F is a required part of 
the Reference Manual for ike Ada Programming Language (called the RM in this 
appendix). 

The sections of this appendix are as follows: 

1. The form, allowed places, and effect of every implementation-dependent pragma. 

2. The name and the type of every implemenution-dependent attribute. 

3. The specification of the package SYSTEM. 

4. The description of the represenution clauses. 

5. The conventions used for any implemenution-generated name denoting im¬ 
plementation-dependent components. 

6. The interpretation of expressions that appear in address clauses, including those 
for interrupts. 

7. Any restrictions on unchecked conversions. 

8. Any implementation-dependent characteristics of the input-output packages. 

9. Characteristics of numeric types. 

10. Other implementation-dependent characteristics. 

11. Compiler limitations. 


Appendix F, Implementation-Dependent Characteristics 


1 



The ramtAlsys Runtime Executive Programs or simply Runtime Executive refers to the 
runtime library routines provided for all Ada programs. These routines implement the 
Ada heap, exceptions, tasking control, and other utility functions. 

General systems programming notes are given in another document, the Application 
Developer's Guide (for example, parameter passing conventions needed for interface with 
assembly routines). 


Appendix F, Version 5 






Section 1 


Implementation-Dependent Pragmas 

1.1 INUNE 

Pragma INLINE is fully supported; however, it is not possible to inUne a subprogram m a 
declarative pan. 

1.2 INTERFACE 

pragma INTERFACE_NAME. 

Prooma INTERFACE soccifies the name of an interfaced subprogram and the name of 

Pragma INTERFACE takes the form specified in the RM. 

pragma INTERFACE {language jtame, subprogram juune); 


where, 


■ language jiame is ASSEMBLER, ADA, or C 

. subfrotramjume is llic name «ea mthin the A<la piogiam to refer to the 
interfaced subprogram. 

The only language names accepted by pragma INTERFACE 

C. The full implementation requirements for writing pragma INTERFACE p gr 

arc described in the Application Developer’s Guide. 

The laneuaee name used in the pragma INTERFACE does not have to have any 
relationship to the language actually used to write the interfaced subpro^m. is 
onlv to tell the compiler how to generate subprogram calls; that is, what land 
^"mmemr ^Lsmg to'use. THe programmer can interface Ada programs with 


Appendix F, Implementation-Dependent Pragmas 



subroutines written in any other (compiled) language by understanding the mechanisms 
used for parameter passing by the Alsys Ada Software Development Environment for 
RS/6000 and the corresponding mechanisms of the chosen external language. 


1.3 INTERFACE^NAME 

Pragma INTERFACE_NAME associates the name of the interfaced subprogram with the 
external name of the interfaced subprogram. If pragma INTERFACE_NAME is not used, 
then the two names are assumed to be identical. This pragma takes the form: 

pragma INTERFACE_NAME (subprogramjiame, siringjiteraf); 

where, 

■ subprogram jtame is the name used within the Ada program to refer to the 
interfaced subprogram. 

■ srringjiteral is the name by which the interfaced subprogram is referred to at link 
time. 

The pragma INTERFacE.NaME is used to identify routines in other languages that are 
not named with legal Ada identifiers. Ada identiHers can only contain letters, digits, or 
underscores, whereas the UNIX Linker allows external names to contain other 
characters, for example, the dollar sign (S) or commercial at sign (@). These characters 
can be specified in the stringJiteral argument of the pragma INTERFACE_NAME. 

The pragma INTERFACE_NaME is allowed at the same places of an Ada program as the 
pragma INTERFACE. (Location restrictions can be found in seaion 13.9 of the RM.) 
However, the pragma INTERFACE_NAME must always occur after the pragma 
INTERFACE declaration for the interfaced subprogram. 

The siringjuerai o{ the pragma INTERFACE_NAME is passed through unchanged, 
including case sensitivity, to the Unix object file. There is no limit to the length of the 
name. 

The user must be aware however, that some tools from other vendors do not fully 
support the standard object file format and may restrict the length or names of symbols. 
For example, most Unix debuggers only work with alphanumeric identifier names. 

The Runtime Executive contains several external identifiers. All such identifiers begin 
with either the string "ADA_’ or the string ’ADAS_’. Accordingly, names prefixed by 
'ADA_" or "ADaS_' should be avoided by the user. 


4 


Appendix F, Version 5 



If INTERFACE_NaME is not used, the default link name for the subprogram is its Ada 
name converted to all upper case characters. 


Example 

package SAMPLE_DATA is 

function SAMPLE_DEVrCE (X: INTEGER) return INTEGER; 
function PROCESS_SAMPLE (X; INTEGER) return INTEGER; 
private 

pragma INTERFACE (ASSEMBLER, SAMPLE.DEVICE); 
pragma INTERFACE (ADA, PROCESS_SAMPL£): 

pragma INTERFACE_NAME (SAMPLE.DEVICE, ’DEVIO$GET_SAMPLE’); 
end SaMPLE.D-MA; 


1.4 

Pragma INDENT is only used 'MxihAdaReformat. AdaReformat is the Alsys reformatter 
which offers the functionalities of a pretty-printer in an Ada environment. 

The pragma is placed in the source file and interpreted by the Reformatter. The line 

pragma INDENT(OFF); 

ciMses AdaReformat not to modify the source lines after this pragma, while 
pragma INDENT(ON); 

c&Mses AdaReformat to resume its action after this pragma. 


1.5 Other Pragmas 

Pragmas IMPROVE and PACK are discussed in detail in the seaion on representation 
clauses and records (Chapter 4). 

Pragma PRIORITY on Unix systems is accepted with the range of priorities running from 
1 to 10 (see the definition of the predefined package SYSTEM in Section 3). Undefined 
priority (no pragma PRIORITY) is treated as though it were less than any defined priority 
value. 


Appendix F, Implementation-Dependent Pragmas 


5 



L”rnTrrSc« 


6 


Appendix F, Version 5 



Section 2 


Implementation-Dependent Attributes 


2.1 P’IS_ARRAY 

For a prefix P that denotes any type or subtype, this attribute yields the value TRUE if P 
is an array type or an array subtype; otherwise, it yields the value FALSE. 


2.2 P’RECORD_.DESCRIPTOR, P’ARRAY_DESCRIPTOR 

These attributes are used to control the representation of implicit components of a 
record. (See Section 4.8 for more details.) 

23 E’EXCEPTION.CODE 

For a prefix E that denotes an exception name, this attribute yields a value that 
represents the internal code of the exception. The value of this attribute is of the type 
INTEGER. 


Appendix F, Iniplemeniadon-DependeniAitribuies 


7 



Appendix F, Version 5 





Section 3 


Specification of the package SYSTEM 


The implementation does not allow the recompilation of package SYSTEM. 


3.1 Specification of the package SYSTEM 

package SYSTEM is 


-- The order of the elements of this type is not significant. 


type NAME is (S370, 
180X86, 
I80386, 
HC680X0. 
VAX, 

TRANSPUTER, 

RS_6000, 

MIPS); 


SYSTEM_NAME 

STORAGE_UNIT 

MAX_INT 

MIN_INT 

HAX_MAHTISSA 

PINE_DELTA 

MAX_0ICITS 

MeMORY_SIZE 

TICK 


: constant NAME 
: constant 
: constant 
: constant 
: constant . 

: constant 
: constant 
: constant 

: constant 


RS_6000; 

:= 8; 

;» 2«31 - 1; 
:* - (2"31); 
31; 

:* 2l»1.0«E-31; 
15; 

:• 2”32; 

:» 1 . 0 ; 


Appendix F, Specification of the package SYSTEM 


9 




subtype PRIORITY is INTEGER range 1 .. 10; 


type ADDRESS is private; 

NULL ADDRESS ; constant ADDRESS; 


-- Converts a string to an address. The syntax of the string and its 
-- meaning are target dependent. 

•• For the 8086, 80186 and 80286 the syntax is: 

•• "SSSSiOOOO” where SSSS and 0000 are a 4 digit or less hexadecimal 
•• nunber representing a segment value and an offset. 

-• The physical address corresponding to SSSS:0000 dependents 
on the execution mode. In real mode it is 16*SSSS*Q000. 

In protected mode the value SSSS represents a segment 
descriptor. 

-- Example: 

"0014:OOFO" 

-• For the 80386 the syntax is: 

*■ "00000000" where 00000000 is an 8 iigit or less hexadecimal nuiter 

-• representing an offset either in the data segment or in the 
code segment. 

-- Example: 

"00000008" 

■■ The exception C0NSTRAINT_ERR0R is raised if the string has not the 
-- proper syntax. 

function VALUE (LEFT : in STRING) return ADDRESS; 

-- Converts an address to a string. The syntax of the returned string 
-- is described in the VALUE function. 


10 


Appendix F, Version 5 



subtype ADORESS_STRING is STRING(1..8); 

function IMAGE (LEFT : in ADDRESS) return ADDRESS.STRING; 


-- The foUouing routines provide support to perform address 
•• computation. The meaning of the and operators is 
-• architecture dependent. For example on a segmented machine 
-• the OFFSET parameter is added to. or subtracted from the offset 
-- part of the address, the segment reaaining untouched. 

type OFFSET is range 0 .. 2**28 -1; 

-- On a segmented architecture the function returns trtje if the 
'• two addresses have the same segment value. On a non segmented 
-• architecture it always returns TRUE. 

function SAME_SEGMENT (LEFT, RIGHT ; in ADDRESS) return BOOLEAN; 


-• The exeception AOORESS_ERROR is raised by "<", 

-- if the two addresses do not have the same segment value. This 
•• exception is never raised on a non segmented machine. 

-- The exception CONSTRAINT_ERROR can be raised by and 

AOORESS_ERROR : exception; 

function (LEFT : in ADDRESS; RIGHT : in OFFSET) return ADDRESS; 

function (LEFT : in OFFSET; RIGHT : in ADDRESS) return ADDRESS; 

function (LEFT ; in ADDRESS; RIGHT : in OFFSET) return ADDRESS; 

■* The exception AOORESS_ERROR is raised on a segmented architecture 
-■ if the two addresses do not have the same segment value. 

function (LEFT : in ADDRESS; RIGHT : in ADDRESS) return OFFSET; 


Appendix F, Specification of the package SYSTEM 


11 



-- Perform an unsigned comparison on addresses or offset part of 
-- addresses on a segmented machine. 

function ••<>» (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 

function (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 

function (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 

function (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 

function "mod" (LEFT : in ADDRESS; RIGHT : in POSITIVE) return NATURAL; 


-- Returns the given address rounded to a specific value. 

type ROUNO_DIRECTION is (DOWN, UP); 

function ROUND (VALUE : in ADDRESS; 

DIRECTION : in ROUND.DIRECTION; 

MODULUS : in POSITIVE) return ADDRESS; 


•• These routines are provided to perform REAO/URITE operation 
-• in memory. 

-* Warning: These routines will give unexpected results if used with 
-- unconstrained types. 

generic 

type TARGET is private; 

function FETCH_FROH_ADDRESS (A : in ADDRESS) return TARGET; 
generic 

type TARGET is private; 

procedure ASSIGN_TO_ADDRESS (A : in ADDRESS; T : in TARGET); 


-• Procedure to copy LENGTH storage unit starting at the address 
-• FROM to the address TO. The source and destination may overlap. 


12 


Appendix F, Version 5 



-- OBJECT_LENGTH designates the size of an object in storage units. 

type 08JECT_LEHGrH is range 0 .. 2««31 -1; 

procedure HOVE (TO : in AOORESS; 

FRQM : in ADDRESS; 

LENGTH : in 08JECT_LENCTH); 

private 


end SYSTEM; 


Appendix F, Specification of the packai;c SYSTEM 


13 



14 


Appendix F, Version 5 







Section 4 


Support for Representation Clauses 


This section explains how objects are represented and allocated by the Alsys Ada 
Software Development Environment for RS/6000 and how it is possible to control this 
using representation clauses. Applicable restrictions on representation clauses are also 
described. 

The representation of an object is closely connected with its type. For this reason this 
section addresses successively the representation of enumeration, integer, floating point, 
flxed point, access, task, array and record types. For each class of type the representation 
of the corresponding objects is described. 

Except in the case of array and record types, the description for each class of type is 
independent of the others. To understand the representation of array and record types it 
is necessary to understand first the representation of their components. 

Apan from implementation detlned pragmas, Ada provides three means to control the 
size of objects: 

■ a (predefined) pragma PACK, applicable to array types 

■ a record representation clause 

■ a size specification 

For each class of types the effect of a size specification is described. Interactions among 
size specifications, packing and record representation clauses is described under the 
discussion of array and record types. 

Representation clauses on derived record types or derived tasks types are not supported. 

Size representation clauses on ty’pes derived from private types are not supported when 
the derived type is declared outside the private part of the defining package. 


Appendix F, Support of Representation Clauses 


IS 




4.1 Enumeration T^pes 


4.1.1 Enumeration Literal Encoding 

When no enumeration representation clause applies to an enumeration type, the 
internal code associated with an enumeration literal is the position number of the 
enumeration literal. Then, for an enumeration type with n elements, the internal codes 
are the integers 0,1,2,... n-1. 

An enumeration representation clause can be provided to specify the value of each 
internal code as described in RM 13.3. The compiler fully implements enumeration 
representation clauses. 

As internal codes must be machine integers the internal codes provided by an 
enumeration representation clause must be in the range -2^^.. 2^^ • 1. 

An enumeration value is always represented by its internal code in the program 
generated by the compiler. 


4.1.2 Enumeration lypes and Object Sizes 

Minimum size of an enumeration subtype 

The minimum possible size of an enumeration subtype is the minimum number of bits 
that is necessary for representing the internal codes of the subtype values in normal 
binary form. 

A static subtype, with a null range has a minimum size of 1. Otherwise, if m and M are 
the values of the internal codes associated with the first and last enumeration values of 
the subtype, then its minimum size L is determined as follows. For m > » 0, L is the 
smallest positive integer such that M < = 2*" -1. For m < 0, L is the smallest positive 
integer such that -2^ ^ < = m and M < = -1. For example: 

type COLOR is (GREEN, BLACK, WHITE, RED, BLUE, YELLOW); 

- The minimum size of COLOR is 3 bits. 

subtype BLACK_AND^WHITE is COLOR range BlACK.. WHITE; 

-- The minimum size of BLACK_aND_WHITE is 2 bits. 


16 


Appendix F, Version 5 



subtype BLACK.OR.WHITE is BLACK_AND_WHITE range X.. X; 

- Assuming that X is not static, the minimum size of BLACK_OR_WHlTE is 
-- 2 bits (the same as the minimum size of its type mark BLACK_AND_WHITE). 


Sac of an enumeration subtype 

When no size specification is applied to an enumeration type or first named subtype, the 
objects of that type or first named subtype are represented as signed machine integers. 
The machine provides 8,16 and 32 bit integers, and the compiler selects automatically 
the smallest signed machine integer which can hold each of the internal codes of the 
enumeration type (or subtype). The size of the enumeration type and of any of its 
subtypes is thus 8,16 or 32 bits. 

When a size specification is applied to an enumeration type, this enumeration type and 
each of its subtypes has the size specified by the length clause. The same rule applies to a 
first named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies; 

type EXTENDED is 

(•• The usual ASCII character set. 

NUU SOH, STX, ETX, EOT, ENQ, ACK, BEU 

’X’, y, ’z’. •{’. T. ■}’. DEL, 

-- Extended characters 

C_CEDILLA_CAP. U_UMLAUT. E_ACUTE, ...); 
for EXTENDED’SIZE use 8; 

- The size of type EXTENDED will be one byte. Its objects will be represented 
~ as unsigned 8 bit integers. 

The compiler fully implements size specifications. Nevertheless, as enumeration values 
are coded using integers, the specified length cannot be greater than 32 bits. 


Size of the objects of an enumeration subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of an enumeration subtype has the same size as its subtype. 


Appendix F, Support of Representation Clauses 


17 




4.2 Integer T^pes 

There are three predefined integer types in the Alsys implementation for I80386 
machines: 

type SHORT_SHORT_INTEGER is range -2**07.. 2**07-l; 

type SHORr'lNTEGER is range -2* *15 .. 2* *15-1; 

type INTEGER is range-2**31.. 2**3M; 


4.2.1 Integer Type Representation 
An integer type declared by a declaration of the form: 
type T is range L.. R; 

is implicitly derived from a predefined integer type. The compiler automatically selects 
the predefined integer type whose range is the smallest that contains the values L to R 
inclusive. 

Binary code is used to represent integer values. Negative numbers are represented using 
two's complement. 


4.2.2 Integer Type and Object Size 
Minimum size of an integer subtype 

The minimum possible size of an integer subtype is the minimum number of bits that is 
necessary for representing the internal codes of the subtype values in normal binary 
form. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M are 
the lower and upper bounds of the subtype, then its minimum size L is determined as 
follows. For m >=0, L is the smallest positive integer such that M <= 2^'^ For 
m < 0, L is the smallest positive integer that -2^'* < = m and M < = 2**'^ -1. For 
example: 

subtype S is INTEGER range 0.. 7; 

•• The minimum size of S is 3 bits. 


18 


Appendix F, Version 5 



subtype D is S range X.. Y; 

-- Assuming that X and Y are not static, the minimum size of 
-- D is 3 bits (the same as the minimum size of its type mark S). 


Size of an integer subtype 

The sizes of the predefined integer types SHORT_SHORT_INTEGER, SHORT_INTEGER 
and INTEGER are respectively 8,16 and 32 bits. 

When no size specification is applied to an integer type or to its first named subtype (if 
any), its size and the size of any of its subtypes is the size of the predefined type from 
which ii derives, directly or indirectly. For example: 

type S is range 80.. 100; 

•• S is derived from SHORT_SHORTJNTEGER, its size is 
-- 8 bits. 

type J is range 0.. 255; 

- J is derived from SHORT_INTEGER, its size is 16 bits, 
type N is new J range 80.. ICu; 

- N is indirectly derived from SHORT_INTEGER, its size is 

- 16 bits. 

When a size specification is applied to an integer type, this integer type and each of its 
subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies: 

type S is range 80.. 100; 
for S’SIZE use 32; 

- S is derived from SHORT_SHORT_INTEGER, but its size is 

- 32 bits because of the size specification. 

type J is range 0.. 255; 
forJ’SIZE use 8; 

-- J is derived from SHORT_INTEGER. but its size is 8 bits 

- because of the size specification. 


Appendix F, Support of Representation Clauses 


19 



type N is new J range 80.. 100; 

- N is indirectly derived from SHORTJNTEGER, but its 
~ size is 8 bits because N inherits the size specification 
-ofJ. 


Size of the objects of an integer subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of an integer subtype has the same size as its subtype. 


43 Floating Point Types 

There are two predefined floating point types in the Alsys implementation for 180x86 
machines: 

type FLOAT is 

digits 6 range -(2.0 - 2.0**(-23))*2.0**127.. (2.0 - 2.0**(.23))*2.0**127; 
type LONG FLOAT is 

digits 15 range -(2.0 - 2.0**(.52))*2.0**1023.. (10 -10**(-52))*10**1023; 

43.1 Floating Point Type Representation 
A floating point type declared by a declaration of the form: 
type T is digits D [range L.. R]; 

is implicitly derived from a predefined floating point type. The compiler automatically 
selects the smallest predefined floating point type whose number of digits is greater than 
or equal to D and which contains the values L to R inclusive. 

In the program generated by the compiler, floating point values are represented using 
the IEEE standard formats for single and double floats. 

The values of the predefined type FLOAT are represented using the single float format. 
The values of the predefined type LONG_FLOATare represented using the double float 
format. The values of any other floating point type are represented in the same way as 
the values of the predefined type from which it derives, direaly or indirectly. 


20 


Appendix F, Version 5 


43.2 Floating Point l^pe and Object Size 

The minimum possible size of a floating point subtype is 32 bits if its base type is FLOAT 
or a type derived from FLOAT; it is 64 bits if its base type is LONG_FLOAT or a type 
derived from LONG_FLOAT. 

The sizes of the predefined floating point types FLOAT and LONG_FLOAT are 
respectively 32 and 64 bits. 

The size of a floating point type and the size of any of its subtypes is the size of the 
predefined type from which it derives directly or indirectly. 

The only size that can be specified for a floating point type or first named subtype using a 
size specification is its usual size (32 or 64 bits). 

An object of a floating point subtype has the same size as its subtype. 


4.4 Fixed Point Types 


4.4.1 Fixed Point Type Representation 

If no specification of small applies to a fixed point type, then the value of small is 
determined by the value of delta as defined by RM 3.5.9. 

A specification of small can be used to impose a value of small. The value of small is 
required to be a power of two. 

To implement fixed point types, the compiler uses a set of anonymous predefined types 
of the form: 

type SHORT_nXED is delta D range (-2.0**7-l)*S .. 2.0**7*S; 
for SHORT_FIXED'SMALL use S; 

type FIXED is delta D range (-2.0**15-l)-S .. 2.0**15*S; 
for FIXED’SMALL use S; 

type L0NG_F1XED is delta D range (-2.0**3M)»S.. 10**31*S; 
for LONG_FIXED’SMALL use S; 

where D is any real value and S any power of two less than or equal to D. 


Appendix F, Support of Representation Clauses 


21 




A fixed point type declared by a declaration of the form: 

type T is delta D range L.. R; 
possibly with a small specification: 
for TSMALL use S; 

is implicitly derived from a predefined fixed point type. The compiler automatically 
selects the predefined fixed point type whose small and delta are the same as the small 
and delta of T and whose range is the shortest that includes the values L to R inclusive. 

In the program generated by the compiler, a safe value V of a fixed point subtype F is 
represented as the integer: 

V/FBASFSMALL 


4.4.2 Fixed Point Type and Object Size 

Minimum size of a fixed point subtype 

The minimum possible size of a fixed point subtype is the minimum number of binary 
digits that is necessary for representing the values of the range of the subtype using the 
small of the base type. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, s and S being 
the bounds of the subtype, if i and 1 are the integer representations of m and M, the 
smallest and the greatest model numbers of the base type such that s < m and M < S, 
ihen the minimum size L is determined as follows. For i > = 0, L is the smallest positive 
inteeei such that I<=2^'*. Fori<0, Lis the smallest positive integer such that - 
2^''<=iandl<=2^”^-l. 

type F is delta 2.0 range 0.0.. 500.0; 

-- The minimum size of F is 8 bits. 

subtype S is F delta 16.0 range 0.0.. 250.0; 

-- The minimum size of S is 7 bits. 

subtype D Is S range X .. Y; 

-- Assuming that X and Y are not static, the minimum size of D is 7 bits 
-- (the same as the minimum size of its type mark S). 


Appendix F, Version 5 




Size of a fixed point subtype 

The sizes of the predefined fixed point types SHORT_FIXED, FIXED and LONG_FIXED 
are respectively 8,16 and 32 bits. 

When no size specification is applied to a fixed point type or to its first named sub^e, 
its size and the size of any of its subtypes is the size of the predefined type from which it 
derives directly or indirectly. For example: 


type S is delta 0.01 range 0.8 .. 1.0; 

- S is derived from an 8 bit predefined fixed type, its size is 8 bits, 
type F is delta 0.01 range 0.0.. 2.0; 

- F is derived from a 16 bit predefined fixed type, its size is 16 bits. 

type N is new F range0.8.. 1.0; . v- 

— N is indirectly derived from a 16 bit predefined fixed type, its size is 16 bits. 

When a size specification is applied to a fixed point type, this fixed point type and Mch of 
its subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies; 


type S is delta 0.01 range 0.8.. 1.0; 
for S’SIZE use 32; 

-- S is derived from an 8 bit predefined fixed type, but its size is 32 bits 

- because of the size specification. 

type F is delta 0.01 range 0.0.. 2.0; 
for FSIZE use 8; 

- F is derived from a 16 bit predefined fixed tjpe, but its size is 8 bits 
~ because of the size specification. 

type N is new F range 0.8 .. 1.0; 

~ N is indirectly derived from a 16 bit predefined fixed type, but its size is 

- 8 bits because N inherits the size specification of F. 


Appendix F, Support of Representation Clauses 


23 



The compiler fully implements size speciHcations. Nevertheless, as fixed point objects are 
represented using machine integers, the specified length cannot be greater than 32 bits. 


Size of the objects of a fixed point subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of a fixed point type has the same size as its subtype. 


4.5 Access l^pes and Collections 

Access Types and Objects of Access Types 

The only size that can be specified for an access type using a size specification is its usual 
size (32 bits). 

An object of an access subtype has the same size as its subtype, thus an onject of an 
access subtype is always 32 bits long. 


Collection Size 

As described in RM 13.2. a specification of collection size can be provided in order to 
reserve storage space for the collection of an access type. 

When no STORAGE_SIZ£ specification applies to an access type, no storage space is 
reserved for its collection, and the value of the attribute ST0RAGE_SIZE is then 0. 

The maximum size is limited by the amount of memory available. 


4.6 Task Types 

Storage for a task activation 

As described in RM 13.2, a length clause can be used to specify the storage space (that is, 
the stack size) for the aaivation of each of the tasks of a given type. Alsys also allows the 
task suck size, for all tasks, to be esublished using a Binder option. If a length clause is 
given for a task type, the value indicated at bind time is ignored for this task type, and the 
length clause is obeyed. When no length clause is used to specify the storage space to be 


2-1 


Appendix F, Version 5 


reserved for a task activation, the storage space indicated at bind time is used for this 
activation. 

A length clause may not be applied to a derived task type. The same storage space is 
reserved for the activation of a task of a derived type as for the activation of a task of the 
parent type. 

The minimum size of a task subtype is 32 bits. 

A size specification has no effect on a task type. The only size that can be specified using 
such a length clause is its usual size (32 bits). 

An object of a task subtype has the same size as its subtype. Thus an object of a task 
subtype is always 32 bits long. 


4.7 Array T^pes 

Each array is allocated in a contiguous area of storage units. All the components have 
the same size. A gap may exist between two consecutive components (and after the last 
one). All the gaps have the same size. 


4.7.1 Array Layout and Structure and Pragma PACK 


Component Gap Conponent Cap Component Gap 


If pragma PACK is not specified for an array, the size of the components is the size of the 
subtype of the components; 

type A is array (1.. 8) of BOOLEAN; 

- The size of the components of a is the size of the type BOOLEAN: 8 bits. 


Appendix F, Suppon of Representation Clauses 


25 





type DECIMAL DIGIT is range 0.. 9; 
for DECIMAL.DIGITSIZE use 4; 
rtnaRY coded decimal Is 
array (INTEGER range < >) of DECIMAL_DIGIT; 

The size of the ivpe DECIMAL DIGIT is 4 bits. Thus in an array of 
I type BINARY CODED.DECIMAL each component will be represented o 

.. 4 bits as in the usual BCD representation. 

type A is array (1.. 8) of BOOLEAN; 

of A is,he hiinimuh, si» of .he W BOOLEAN: 

.. 1 bit. 

type DECIMAL DIGIT is range 0.. 9; 
for DECIMAL.DIGIT’SIZE use 32; 

typeBINARY_CODED.DECIMALis 

array (INTEGER range < >) of DECIMAL.DIGIT, 
pragma PACK(BINARY.CODED_DECIMAL); 

The size of the type DECIMAL DIGIT is 32 bits, but, as 

alignment of their subtypes. 


Gaps 


If the components are records or arrays, no size specification applies to the subtype of 
gap is SiSn^hM the rSv^^hs^SemV^^:i«^'Ih^«mponcnis k a multiple 


26 


Appendix F, Version 5 



type R is 
record 

K: SHORTJNTEGER; 

B; BOOLE^; 

end record; 
for R use 
record 

K at 0 range 0.. 31; 

B at 4 range 0.. 0; 
end record; 

Record type R is byte aligned. Its size is 33 bits, 
type A is array (1.. 10) of R; 

- A gap of 7 bits is inserted after each component in order to respect the 
-- alignment of type R. The size of an array of type a will be 400 bus. 



Airoy of type A: each subcomponent K has an even offset 

If a size specification applies to the subtype of the components or if the array is packed, 
no gaps are inserted: 


type R is 
record 

K: SHORT_INTEGER; 

B: BOOLEAN; 

end record; 

type A is array (1.. 10) of R; 
pragma PACK(A); 

-- There is no gap in an array of type A because A is packed. 
-- The size of an object of type A will be 330 bits. 

type NR is new R; 
for NR’SIZE use 24; 


Appendix F, Support of Representation Clauses 


27 









type B Is array (1.. 10) of NR; 

- There is no gap in an array of type B because 
~ NR has a size specification. 

- The size of an object of type B will be 240 bits: 


p 


! 





K 

B 1 


K 

B 



K 

11 




I_ 




Conponent Coirponent 

Array of type A orB 


4.7.2 Array Subtype and Object Size 

Size of an array subtype 

The size of an array subtype is obtained by multiplying the number of its components by 
the sum of the size of the components and the size of the gaps (if any). If the subtype is 
unconstrained, the maximum number of components is considered. 

The size of an array subtype cannot be computed at compile time 

■ if it has non-static constraints or is an unconstrained array type with non-static 
index subtypes (because the number of components can then only be determined at 

run time). 

• if the components are records or arrays and their constraints or the constraints of 
their subcomponents (if any) are not sutic (because the size of the components and 
the size of the gaps can then only be determined at run time). 

As has been indicated above, the effect of a pragma PACK on an array type is to suppress 
the gaps. The consequence of packing an array type is thus to reduce its size. 

If the components of an array are records or arrays and their constraints or the 
constraints of their subcomponents (if any) are not static, the compiler ignores any 
pragma PACK applied to the array type but issues a warning message. Apart from this 
limitation, array packing is fully implemented by the compiler. 


28 


Appendix F, Version 5 








A size specification applied to an array type or first named subtype has no effect The 
only size that can be specified using such a length clause is its usual size. Nevertheless, 
such a length clause can be useful to verify that the layout of an array is as expeaed by 
the application. 


Size of the objects of an array subtype 

The size of an object of an array subtype is always equal to the size of the subtype of the 
object. 


4.8 Record Types 

4.8.1 Basic Record Structure 
Layout of a record 

Each record is allocated in a contiguous area of storage units. The size of a record 
component depends on its type. 

The positions and the sizes of the components of a record type objea can be controlled 
using a record representation clause as described in RM 13.4. In the Alsys 
implemenution for 180x86 machines there is no restriaion on the position that can be 
specified for a component of a record. If a component is not a record or an array, its size 
can be any size from the minimum size to the size of its subtype. If a component is a 
record or an array, its size must be the size of its subtype. 

Pragma PACK has no effect on records. It is unnecessary because record representation 
clauses provide full control over record layout 

A record representation clause need not specify the position and the size for every 
component. If no component clause applies to a component of a record, its size is the 
size of its subtype. 


4.8.2 Indirect Components 

If the offset of a component cannot be computed at compile time, this offset is stored in 
the record objects at run time and used to access the component. Such a component is 
said to be indirect while other components are said to be direa: 


Appendix F, Support of Representation Clauses 


29 




Beginning of the record 
Coiipile tine offset 


OtRECT 


OFFSET 


Conpile tioie offset 


Run tiM offset 


tNOIRECT 


A direct and an indirect component 

If a record component is a record or an array, the size of its subtype may be evaluated at 
run time and may even depend on the discriminants of the record. We will call these 
components dynamic components: 

type DEVICE is (SCREEN. PRINTER); 

type COLOR is (GREEN. RED. BLUE); 

type SERIES is array (POSITIVE range <>) of INTEGER; 

type graph (L : NATURAL) is 
record 

X: SERIES( 1.. L); -- The size of X depends on L 
Y: SERIES( 1.. L); -- The size of Y depends on L 
end record; 

Q: POSITIVE; 


JO 


Appendix F, Version 5 


type PICTURE (N ; NATURAL; D: DEVICE) U 
record 

F: GRAPH{N); - The size of F depends on N 
S: GRAPH(Q): - The size of S depends on Q 
case D is 

when SCREEN => 

C: COLOR; 
when PRINTER = > 
null; 
end case; 
end record; 

Any component placed after a dynamic component has an of&et which cannot be 
evaluated at compile time and is thus indirea. In order to minimize the number of 
indirect components, the compiler groups the dynamic components together and places 
them at the end of the record: 

0 * SCREEN 0 « PRINTER 

N s 2 N » 1 


S OFFSET 


F OFFSET 


Besinning of the rtcord 
• Ccapilo tim offsots 


Rui time offsets 


4 


S OFFSET 


F OFFSET 




The record type PICTURE: F and S are placed at the end of the record 


Appendix F, Support of Representation Clauses 


31 






Note that Ada does not allow represenution clauses for record components with non¬ 
static bounds [RM 13.4.7], so the compiler’s grouping of dynamic components does not 
conflia with the use of representation clauses. 

Because of this approach, the only indirect components are dynamic components. But 
not all dynamic components are necessarily indirea: if there are dynamic components in 
a component list which is not followed by a variant part, then exaaly one dynamic 
component of this list is a direct component because its offset can be computed at 
compilation time (the only dynamic components that are direct components are in this 
situation); 






L 


X 


T 


Beginning of the record 
Coepile tine offset 


■ - I Conpile time offset 

Size dependent on discriminant L 
' ■ ■ ■ ' ■ Run time offset 
Size dependent on discriminant L 


The record type GRAPH: the dynamic componeruXis a direct component 


The offset of an indirect component is always expressed in storage units. 

The space reserved for the offset of an indirect component must be large enough to store 
the size of any value of the record type (the maximum potential offset). The compiler 
evaluates an upper bound MS of this size and treats an offset as a component having an 
anonymous integer type whose range is 0.. MS. 

If C is the name of an indirect component, then the of&et of this component can be 
denoted in a component clause by the implemenution generated name COFFSET. 


32 


Appendix F, Version 5 



4.83 Implicit Components 

In some circumstances, access to an object of a record type or to its components involves 
computing information which only depends on the discriminant values. To avoid 
recomputation (which would degrade performance) the compiler stores this information 
in the record objects, updates it when the values of the discriminants are modified and 
uses it when the objects or its components are accessed. This information is stored in 
special components called implicit components. 

An implicit component may contain information which is used when the record object or 
several of its components are accessed. In this case the component will be included in any 
record objea (the implicit component is considered to be declared before any variant 
part in the record type declaration). There can be two components of this kind; one is 
called RECORD_SIZE and the other VAR1ANT_INDEX. 

On the other hand an implicit component may be used to access a given record 
component. In that case the implicit component exists whenever the record component 
exists (the implicit component is considered to be declared at the same place as the 
record component). Components of this kind are called aRRAY_DESCRIPTORs or 
RECORD_DESCRIPTORs. 


RECORDJIZE 

This implicit component is created by the compiler when the record type has a variant 
part and its discriminants are defaulted. It contains the size of the storage space 
necessary to store the current value of the record object (note that the storage effectively 
allocated for the record object may be more than this). 

The value of a RECORD_SIZE component may denote a number of bits or a number of 
storage units. In general it denotes a number of storage units, but if any component 
clause specifies that a component of the record type has an offset or a size which cannot 
be expressed using storage units, then the value designates a number of bits. 

The implicit component RECORD_SIZE must be large enough to store the maximum 
size of any value of the record type. The compiler evaluates an upper bound MS of this 
size and then considers the implicit component as having an anonymous integer type 
whose range is 0.. MS. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R’RECORD_SIZE This 
allows user control over the position of the implicit component in the record. 


Appendix F, Support of Representation Clauses 


33 





VARIANTJSDEX 

This implicit component is created by the compiler when the record type has a variant 
part. It indicates the set of components that are present in a record value. It is used when 
a discriminant check is to be done. 

Component lists in variant parts that themselves do not contain a variant part are 
numbered. These numbers are the possible values of the implicit component 
VARIANT.INDEX. 

type VEHICLE is (AIRCRAFT, ROCKET. BOAT, CAR); 

type DESCRIPTION (KIND : VEHICLE := CAR) is 
record 

SPEED; INTEGER; 
case KIND is 

when AIRCRAFT 1 CAR = > 

WHEELS: INTEGER; 
case KIND is 

when AIRCRAFT = > -1 

WINGSPAN: INTEGER; 
when others = > - 2 

null; 
end case; 

when BOAT = > -- 3 
STEAM ; BOOLEAN; 
when ROCKET = > - 4 

STAGES: INTEGER; 

end case; 
end record; 

The value of the variant index indicates the set of components that are present in a 
record value: 


Variant Index 

Set 

1 

{KINO, SPEED, WHEELS, U1HGSPAH> 

2 

<KIND, SPEED, WHEELS} 

3 

(KINO, SPEED, STEAM} 


(KIND, SPEED, STAGES} 


34 


Appendix F, Version S 




A comparison between the variant index of a record value and the bounds of an interval 
is enough to check that a given component is present in the value: 


Component 

Interval 

KIND 


SPEED 

-- 

WHEELS 

1 .. 2 

WINGSPAN 

1 .. 1 

STEAK 


STAGES 



The implicit component VARIANT_INDEX must be large enough to store the number v 
of component lists that don’t contain variant parts. The compiler treats this implicit 
component as having an anonymous integer type whose range is l.. v. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R’VARIANTJNDEX. This 
allows user control over the position of the implicit component in the record. 


ARRAYJ)ESCmPTOR 

An implicit component of this kind is associated by the compiler with each record 
component whose subtype is an anonymous array subtype that depends on a discriminant 
of the record. It contains information about the component subtype. 

The struaure of an implicit component of kind ARRAY_DESCRIPTOR is not described 
in this documentation. Nevertheless, if a programmer is interested in specifying the 
location of a component of this kind using a component clause, size of the component 
may be obtained using the ASSEMBLY parameter in the COMPILE command. 

The compiler treats an implicit component of the kind ARRAY_DESCRIPTOR as having 
an anonymous array type. If C is the name of the record component whose subtype is 
described by the array descriptor, then this implicit component can be denoted in a 
component clause by the implementation generated name CARRAY_DESCRIPTOR. 

This allows user control over the position of the implicit component in the record. 


Appendix F, Support of Representation Clauses 


35 










RECORDjDESCRIPTOR 

An implicit component of this kind is associated by the compiler with each record 
component whose subtype is an anonymous record subtype that depends on a 
discriminant of the record. It contains information about the component subtype. 

The structure of an implicit component of kind RECORD_DESCRIPTOR is not described 
in this documentation. Nevertheless, if a programmer is interested in specifying the 
location of a component of this kind using a component clause, the size of the 
component may be obuined using the ASSEMBLY parameter in the COMPILE 
command. 

The compiler treats an implicit component of the kind RECORD_DESCRIPTOR as 
having an anonymous array type. If C is the name of the record component whose 
subtype is described by the record descriptor, then this implicit component can be 
denoted in a component clause by the implementation generated name 
C’RECORD_DESCRIPTOR. This allows user control over the position of the implicit 
component in the record. 


Suppression of Implicit Components 

The Alsys implementation provides the capability of suppressing the implicit 
components RECORD.SIZE and/orVARIANT_INDEX from a record type. This can be 
done using an implementation defined pragma called IMPROVE. The syntax of this 
pragma is as follows: 

pragma IMPROVE (TIME | SPACE (,ON * >] simple_name); 

The first argument specifies whether TIME or SPACE is the primary criterion for the 
choice of the represenution of the record type that is denoted by the second argument 

If TIME is specified, the compiler inserts implicit components as described above. If on 
the other hand SPACE is specified, the compiler only inserts a VARIANT_INDEX or a 
RECORD_SIZE component if this component appears in a record representation clause 
that applies to the record type. A record representation clause can thus be used to keep 
one implicit component while suppressing the other. 

A pragma IMPROVE that applies to a given record type can occur anywhere that a 
representation clause is allowed for this type. 


36 


Appendix F, Version 5 





4.8.4 Size of Record l^pes and Objects 

Size of a record subtype 

Unless a component clause specifies that a component of a record type has an of&et or a 
size which cannot be expressed using storage units, the size of a record subtype is 
rounded up to a whole number of storage units. 

The size of a constrained record subtype is obtained by adding the sizes of its 
components and the sizes of its gaps (if any). This size is not computed at compile time 

■ when the record subtype has non-static constraints, 

■ when a component is an array or a record and its size is not computed at compile 
time. 

The size of an unconstrained record subtype is obtained by adding the sizes of the 
components and the sizes of the gaps (if any) of its largest variant. If the size of a 
component or of a gap cannot be evaluated exactly at compile time an upper bound of 
this size is used by the compiler to compute the subtype size. 

A size specification applied to a record type or first named subtype has no effect. The 
only size that can be specified using such a length clause is its usual size. Nevertheless, 
such a length clause can be useful to verify that the layout of a record is as expeaed by 
the application. 


Size of an objea of n record subtype 

An object of a constrained record subtype has the same size as its subtype. 

An object of an unconstrained record subtype has the same size as its subtype if this size 
is less than or equal to 8 kb. If the size of the subtype is greater than this, the objea has 
the size necessary to store its current value; storage space is allocated and released as the 
discriminants of the record change. 


Appendix F, Support of Representation Clauses 


37 



38 


Appendix F, Version 5 




Section 5 


Conventions for Implementation-Generated Names 


The Alsys Ada Software Development Environment for RS/6000 may add fields to 
record objects and have descriptors in memory for record or array objects. These fields 
are accessible to the user through implementation-generated attributes (See Section 23). 


Appendix F, Conventions for Implementation-Generated Names 


39 




40 


Appendix F, Version 5 






Section 6 


Address Clauses 


6.1 Address Clauses for Objects 

An address clause can be used to specify an address for an objea as described in RM 13.5. 
When such a clause applies to an object the compiler does not cause storage to be 
allocated for the object. The program accesses the objea using the address specified in 
the clause. It is the responsibility of the user therefore to make sure that a valid 
allocation of storage has been done at the specified address. 

An address clause is not allowed for task objects, for unconstrained records whose size is 
greater than 8k bytes or for a constant. 

There are a number of ways to compose a legal address expression for use in an address 
clause. The most direct ways are: 

■ For the case where the memory is defined in Ada as another object, use the 
’ADDRESS attribute to obtain the argument for the address clause for the second 
object. 

■ For the case where an absolute address is known to the programmer, instantiate the 
generic function SYSTEM.REFERENCE on a 16 bit unsigned integer type (either 
from package UNSIGNED, or by use of a length clause on a derived integer type or 
subtype) and on type SYSTEM.ADORESS. Then the values of the desired segment 
and offset can be passed as the actual parameters to the instantiated function in the 
simple expression part of the address clause. See Seaion 3 for the specification of 
package SYSTEM. 

« For the case where the desired location is memory defined in assembly or another 
non-Ada language (is relocatable), an interfaced routine may be used to obtain the 
appropriate address from referenang information known to the other language. 

6.2 Address Clauses for Program Units 


Appendix F, Address Clauses 


41 





Address clauses for program units are not implemented in the cuncni version of the 
compiler. 

6.3 Address Clauses for Interrupt Entries 

Address cisuses (or entries are not itnpletnented in the current version ot the compiler. 


42 


Appendix F, Version 5 



Section 7 


Unchecked Conversions 


Unchecked conversions are allowed between any types provided the instantiation of 
UNCHECKED^CONVERSION is legal Ada. It is the programmer’s responsibility to 
determine if the desired effect is achieved. 

If the urget type has a smaller size than the source type then the target is made of the 
least significant bits of the source. 


Appendix F, Unchecked Conversions 


43 




Appendix F, Versiun 5 







Section 8 


Input-Output Packages 


In this part of the Appendix the implementation-specific aspects of the input-output 
system are described. 


8.1 Introduction 

In Ada, input-output operations (lO) are considered to be performed on objects of a 
certain file type rather than being performed directly on external files. An external file is 
anything external to the program that can produce a value to be read or receive a value to 
be written. Values transferred for a given file must be all of one type. 

Generally, in Ada documentation, the term file refers to an object of a certain file type, 
whereas a physical manifestation is known as an external file. An external file is 
charaaeiized by 

■ Its name, which is a string defining a legal path name under the current version of 
the operating system. 

a Its form, which gives implementation-dependent information on file characteristics. 

Both the name and the form appear explicitly as parameters of the Ada CREATE and 
OPEN procedures. Though a file is an object of a certain file type, ultimately the object 
has to correspond to an external file. Both CREATE and OPEN associate a NAME of 
an external file (of a certain FORM) with a program file object. 

Ada lO operations are provided by means of standard packages [14]. 

SEQUENTIAL_IO A generic package for sequential files of a single element 
type. 

DIRECT^IO A generic package for direct (random) access files. 

TEXT_IO A generic package for human readable (text. ASCII) files. 


Appendix F, Inpui-Ouiput Packages 


45 




IO_EXCEPTIONS A package which defines the exceptions needed by the 
above three packages. 

The generic package L0W_LEVEL_10 is not implemented in this version. 

The upper bound for index values in OIRECT_IO and for line, column and page numbers 
in TEXTJO is given by 

COUNTIAST * 2**31 -1 

The upper bound for field widths in TEXTJO is given by 
nELD’LAST = 255 


8.2 The FORM Parameter 

The FORM parameter of both the CREATE and OPEN procedures in Ada specifies the 
characteristics of the external file involved. 

The CREATE procedure establishes a new external file, of a given NAME and FORM, and 
associates it with a specified program file object The external file is aeated (and the file 
object set) with a specified (or default) file mode. If the external file already exists, the 
file will be erased. The exception USE_ERROR is raised if the file mode is iN_FILF- 


Example: 

CREATE (F. OUT_nLE "MY_nLE". 

FORM = > 

'WORLD => READ, OWNER => READ_WRITE’); 

The OPEN procedure associates an existing external file, of a given NAME and FORM, 
with a specified program file object The procedure also sets the current file mode. If 
there is an inadmissible change of mode, then the Ada exception USE_ERROR is raised. 

The FORM parameter is a siring, formed from a list of attributes, with attributes 
separated by commas (,). The string is not case sensitive (so that, for example, HERE and 


46 


Appendix F, Version 5 



here are treated alike). FORM attributes are distinct from Ada attributes. The attributes 
specify; 

■ File protection 

■ File sharing 

■ File structure 

■ Buffering 

■ Appending 

■ Blocking 

■ Terminal input 

The general form of each attribute is a keyword followed by = > and then a qualifier. 
The arrow and qualifier may sometimes be omitted. The format for an attribute specifier 
is thus either of 

KEYWORD 

KEYWORD => QUAUHER 
We will discuss each attribute in turn. 

8.2.1 File Protection 

These attributes are only meaningful for a call to the CREATE procedure. 

File protection involves two independent classifications. The first classification is related 
to who may access the file and is specified by the keywords: 

OWNER Only the owner of the directory may access this file. 

GROUP Only the members of a predefined group of users may access 

this file. 

WORLD Any user may access this file. 


Appendix F, Input-Output Packages 


47 



For each type of user who may access a file there are various access rights, and this forms 
the basis for the second classification. In general, there are four types of access right, 
specified by the qualifiers: 

read The user may read from the external file. 

WRITE The user may write to the external file. 

EXECUTE The user may execute programs stored in the external file. 

none The user has no access rights to the external file. (This access 

right negates any prior privileges.) 

More than one access right may be relevant for a panicular file, in which case the 
qualifiers are linked with underscores (_). 

For example, suppose that the WORLD may execute a program in an external file, but 
only the OWNER may modily the file. 

WORLD => 

EXECUTE. 

OWNER «> 

READ.WRITE .EXECUTE, 

Repetition of the same qualifier within the attributes is illegal: 

WORLD => 

EXECUTE.EXECUTE,-NOTlegal 
but repetition of the entire attribute is allowed: 

WORLD => 

EXECUTE, 

WORLD => 

EXECUTE, - Legal 


48 


Appendix F, Version 5 




8^.2 File Sharing 

An external file can be shared, which means associated simultaneously with several 
logical file objects created by the OPEN and CREATE procedures. 

The file sharing attribute may restrict or suppress this capability by specifying one of the 
following access modes; 

NOT_SHARED 

Exclusive access • no other logical file may be associated with 
the external file 

SHARED => READERS 

Only logical files opened with mode IN are allowed 

SHARED => SINGLE.WRITER 

Only logical files opened with mode IN and at most one with 
mode INOUT or OUT are allowed 


SHARED *> ANY 

No restriction 

The exception USE.ERROR is raised if, for an external file already associated with an 
Ada file object; 

• a further OPEN or CREATE specifies a file sharing attribute different from the 
current one 

- a further OPEN, CREATE or RESET violates the conditions imposed by the current 
flle sharing attribute. 

The restrictions imposed by the file sharing attribute disappear when the last logical file 
objea linked to the external file is closed. 

The file sharing attribute provides control over multiple accesses within the program to a 
given external file. 

This control does not extend to the whole system. 

The default value for the file sharing attribute is SHARED => ANY 


Appendix F, Input-Output Packages 


49 






8^3 File Structure 

Text Files 

There is no FORM parameter to define the struaure of text files. 

A text file consists of a sequence of bytes holding the ASCII codes of charaaers. 

The representation of Ada-terminators depends on the file’s mode (IN or OUT) and 
whether it is associated with a terminal device or a mass-storage file: 

- Mass-storage files 

end of line: ASCII.LF 

end of page: ASCII.LF ASCI1.FF 

end of file: ASCII.LF ASCII.EOT 

- Terminal device with mode IN 

end of line: ASCII.LF 

end of page: ASCII.LF ASCII.FF 

end of file: ASCII.LF ASCII.FF 

- Terminal device with mode OUT 

end of lin .: ASCII.LF 
end of page: ASCII.FF 
end of file: ASCII.EOT 


Binary Files 

Two FORM attributes, RECORD_SIZE and RECORD_UNIT, control the structure of 
binary files. 

A binary file can be viewed as a sequence (sequential access) or a set (direa access) of 
consecutive RECORDS. 

The structure of such a record iy. 

[ HEADER ] OBJECT ( UNUSED_PART] 


50 


Appendix F, Version 5 



and it is formed from up to three items: 

- an OBJECT with the exact binary representation of the Ada objea in the executable 
program, possibly including an object descriptor 

- a HEADER consisting of two fields (each of 32 bits): 

- the length of the object in bytes 

- the length of the descriptor in bytes 

- an UNUSED_PART of variable size to permit full control of the record’s size 

The HEADER is implemented only if the actual parameter of the instantiation of the lO 
package is unconstrained. 

The file structure attributes take the form: 

RECORD SIZE * > size in bytes 

RECORD^UNIT => sizejn_bytes 

Their meaning depends on the object’s type (constrained or not) and the file access mode 
(sequential or direct access): 

a) If the object’s type is constrained: 

- The RECORD_UNrr attribute is illegal 

* If the RECORD_SIZE attribute is omitted, no UNUSED_PART will be 
implemented: the default RECORD_SIZE is the object’s size 

- If present, the RECORD_SIZE attribute must specify a record size greater than 
or equal to the object’s size, otherwise the exception USE_ERROR will be 
raised 

b) If the object's type is unconstrained and the file access mode is direct: 

- The RECORD_UNrT attribute is illegal 

- The RECORD_SIZE attribute has no default value, and if it is not specified, a 
USE_ERROR will be raised 


Appendix F, Input-Output Packages 


51 



An attempt to input or output an object larger than the given RECORD_SIZE 
will raise the exception DATa_ERROR 

c) If the object’s type is unconstrained and the file access mode is sequential: 

- The REC0RD_SIZE attribute is illegal 

- The default value of the RECORD_UNrr attribute is 1 (byte) 

- The record size will be the smallest multiple of the specified (or default) 
RECORD UNIT that holds the object and its length. This is the only case 
where records of a file may have different sizes. 

8.2.4 Buffering 

The buffer size can be specified by the attribute 
BUFFER.SIZE = > sizejn_bytes 

The default value for BUFFFR.SIZE is 0 (which means no buffering) for terminal 
devices; it is 1 block for disk files. 

Only to be used with the procedure OPEN, the format of this attribute is simply 

append 

and it means that any output will be placed at the end of the named external file. 

In normal circumstances, when an external file is opened, an index is set which points to 
the beginning of the file. If the APPEND attribute is present for a sequential or for a text 
file, then data transfer will commence at the end of the file. For a direct access file, the 
value of the index is set to one more than the number of records in the external file. 

This attribute is not applicable to terminal devices. 

8.2.6 Blocking 

This attribute has two alternative forms: 

BLOCKING, 


52 


Appendix F, Version 5 




or 


NON_BLOCKING, 

This attribute specifies the lO system behavior desired at any moment that a request for 
data transfer cannot be fulfilled. The stoppage may be due, for example, to the 
unavailability of data, or to the unavailability of the external file device. 


NON_BLOCKlNG 

If this attribute is set, then the task that ordered the data transfer is suspended - 
meaning that other tasks can execute. The suspended task is kept in a ‘ready’ state, 
together with other tasks in a ready state at the same priority level (that is, it is 
rescheduled). 

When the suspended task is next scheduled, the data transfer request is reactivated. 
If ready, the transfer is activated, otherwise the rescheduling is repeated. Control 
returns to the user program after completion of the data transfer. 


BLOCKING 

In this case the task waits until the data transfer is complete, and all other tasks are 
suspended (or ‘blocked’). The system is busy waiting. 

The default for this attribute depends on the actual program: it is BLOCKING for 
programs without task declarations and NON_BLOCKlNG for a program containing 
tasks. 


8.2.7 Terminal Input 

This attribute takes one of two alternative forms: 

TERMINALJNPUT = > UNES, 

TERMINAL_INPUT => CHARACTERS, 

Terminal input is normally processed in units of a line at a time, where a line is delimited 
by a special character. A process attempting to read from the terminal as an external file 
will be suspended until a complete line has been typed. At that time, the outsunding 
read call (and possibly also later calls) will be satisfied. 


Appendix F, Input-Output Packages 


S3 




The first option specifies line-at-a-titne data transfer, which is the default case. 

The second option means that data transfer is character by character, and so a complete 
line does not have to be entered before the read request can be satisfied. For this option 
the BUFFER_SIZE must be zero. 

The TERMINALJNPUT attribute is only applicable to terminal devices. 


54 


AppendixF, Versions 




Section 9 


Characteristics of Numeric Types 


9.1 Integer T^pes 

The ranges of values for integer types declared in package STANDARD are as follows: 


SH0RT_SH0RT_1NTECER 

-128 127 

-- 2*«7 - 1 

SHORT,INTEGER 

-32768 .. 32767 

" 2**15 - 1 

INTEGER 

-2147483648 .. 2147483647 

-• 2**31 - 1 

For the packages DrRECT_IO and TEXTJO, the range of values for types COUNT and 
POSrnvE_COUNT are as follows: 

COUNT 

0 .. 2147483647 

-- 2*«31 • 1 

POSITIVE_COUNT 

1 .. 2147483647 

-- 2^31 • 1 

For the package TEXT_IO, the range of values for the type FIELD is as follows: 

FIELD 

0 .. 255 

-- 2«8 - 1 

9.2 Floating Point Type Attributes 



SMORT_FLOAT and 

float 

LONC_FLQAT 

DIGITS 

6 

15 

MANTISSA 

21 

51 

EMAX 

84 

204 


Appendix F, Characteristics of Numeric Types 


55 




EPSILON 

9.5367tE-07 

8.88178E-16 

LARGE 

1.93t28E*25 

2.571108*61 

SAFEJMAX 

125 

1021 

SAFE_SMALL 

1.l75t9E-38 

2.22507E-308 

SAFE_LARGE 

4.25353E+37 

2.2t712E*307 

FIRST 

-3.t0282E''-38 

-1.79769E*308 

LAST 

3.t0282E»38 

1.79769E+308 

machine.raoix 

2 

2 

machine_emax 

128 

102t 

hachine_emin 

-125 

-1021 

hachine_rouhos 

true 

true 

machine_overflous 

false 

false 

SIZE 

32 

6t 


93 Attributes of Type DURATION 


DURATION'DELTA 
DURATION'SMALL 
DURATION'FIRST 
DURATION'LAST 
DURATION'LARGE 


2.0 •• (-It) 

2.0 •• (-It) 
-131_072.0 
131_072.0 

same as DURATION'LAST 


56 


Appendix F, Version 5 



Section 10 


Other Implementation-Dependent Characteristics 


10.1 Characteristics of the Heap 

All objects created by allocators go into the heap. Also, portions of the Runtime Execu¬ 
tive representation of task objects, including the task stacks, are allocated in the heap. 

UNCHECKED_DEALLOCA'nON is implemented for all Ada access objects except access 
objects to tasks. Use of UNCHECKED_DEaLLOCATION on a task objea will lead to 
unpredictable results. 

All objects whose visibility is linked to a subprogram, task body, or block have their 
storage reclaimed at exit, whether the exit is normal or due to an exception. Effeaively 
pragma CONTROLLED is automatically applied to all access types. Moreover, all 
compiler temporaries on the heap (generated by such operations as funaion calls 
returning unconstrained arrays, or many concatenations) allocated in a scope are 
deallocated upon leaving the scope. 

Note that the programmer may force heap reclamation of temporaries associated with 
any statements by enclosing the statement in a begin.. end block. This is especially 
useful when complex concatenations or other heap-intensive operations are performed 
in loops, and can reduce or eliminate STORAGE_ERRORs that might otherwise occur. 

The maximum size of the heap is limited only by available memory. This includes the 
amount of physical memory (RAM) and the amount of virtual memory (hard disk swap 
space). 


10.2 Characteristics of Tasks 

The default task stack size is IK bytes (32K bytes for the environment task), but by using 
the Binder option STACK.TASK the size for all task sucks in a program may be set to a 
size from IK bytes to 32767 bytes. 


Appendix F, Other Implementation-Dependent Characteristics 


57 



Normal priority rules are followed for preemption, where PRIORITY values are in the 
range 1.. 10. A task with undefined priority (no pragma PRIORITY) is considered to be 
lower than priority 1. 

The minimum timeable delay is 0.01562 seconds. 

The maxinmm number of active tasks is restricted only by memory usage. 

The accepter of a rendezvous executes the accept body code in its own stack. 
Rendezvous with an empty accept body (for synchronization) does not cause a context 
switch. 

The main program waits for completion of all tasks dependent upon library packages 
before terminating. 

Abnormal completion of an aborted task takes place immediately, except when the ab¬ 
normal task is the caller of an entry that is engaged in a rendezvous, or if it is in the 
process of activating some tasks. Any such task becomes abnormally completed as soon 
as the state in question is exited. 

The message 

GLOBAL BLOCKING SITUATION DETECTED 

is printed to STANDaRD_OUTPUT when the Runtime Executive detects that no funher 
progress is possible for any task in the program. The execution of the program is then 
abandoned. 


58 


Appendix F, Version 5 



103 Definition of a Main Subprogram 

A library unit can be used as a main subprogram if and only if it is a procedure that is not 
generic and that has no formal parameters. 


10.4 Ordering of Compilation Units 

The Alsys Ada Software Development Environment for RS/6000 imposes no additional 
ordering constraints on compilations beyond those required by the language. 


Appendix F, Other Implementation-Dependent Characteristics 


59 



60 


Appendix F, Version 5 








Section 11 


Limitations 


11.1 Compiler Limitations 

■ The maximum identifier length is 255 charaaers. 

■ The maximum line length is 255 characters. 

■ The maximum number of unique identifiers per compilation unit is 2500. 
m The maximum number of compilation units in a library is 40%. 

■ The maximum number of Ada libraries in a family is 2047. 


11.2 Hardware Related Limitations 

■ The maximum amount of data in the heap is limited only by available memory. 

■ If an unconstrained record type can exceed 40% bytes, the type is not permitted 
(unless constrained) as the element type in the dehnition of an array or record type. 

■ A dynamic objea bigger than 40% bytes will be indirectly allocated. Refer to 
ALLOCATION parameter in the COMPILE command. (Seaion 4.2 of the User’s 
Guide.) 


Appendix F, Limitations 


61 





62 


Appendix F, Version 5 





INDEX 


Abnormal completion 58 
Aborted task 58 
Access types 24 
Allocaton 57 

Application Developer’s Guide 3 
Array gaps 26 
Array objects 39 
Array subtype 7 

Array subtype and object size 28 
Array type 7 

ARRAY_DESCRIPT0R 35 
Attribute 7 
ASSEMBLER 3 

Attributes of type DURATION 56 

Basic record structure 29 
Binder 57 

C 3 

Characteristics of tasks 57 
Collection size 24 
Collections 24 
Compiler limiutions 61 

maximum identifier length 61 
maximum line length 61 
maximum number of Ada libraries 
61 

maximum number of compilation 
units 61 

maximum number of unique 
identifiers 61 
COUNT 55 

DIGITS 55 
DIRECT lO 55 
DURATION’DELTA 56 
DURATION’RRST 56 


DURATION’LARGE 56 
DURATION’LAST 56 
DURATION’SMALL 56 

E’EXCEPTION_CODE 7 
EMAX 55 

Empty accept body 58 
Enumeration literal encoding 16 
Enumeration subtype size 17 
Enumeration types 16 
EPSILON 56 
EXCEPTION_CODE 
Attribute 7 

HELD 55 
FIRST 56 

Fixed point type representation 21 
Fixed point type size 22 
Floating point type attributes 55 
Boating point type representation 20 
Boating point type size 21 

GLOBAL BLOCKING SITUATION 
DETECTED 58 

Hardware limitations 

maximum data in the heap 61 
maximum size of a single array or 
record object 61 

Heap 57 

Implementation generated names 39 
Implicit component 35,36 
Implicit components 33 
INDENT 5 

Indirea record components 29 
Integer type and objea size 18 


Index 


63 




Integer type representation 18 
Integer types 55 
INTERFACE 3,4 
INTERFACE_NAME 3,4 
IS_ARRAY 
Attribute 7 

LARGE 56 
LAST 56 

Layout of a record 29 
Library unit 59 
Limitations 61 

machine EMAX 56 
MACHINE"EMIN 56 
machine mantissa 56 
MACHINEIoVERFI-OWS 56 
MACHINE RADIX 56 
MACHINE>OUNDS 56 
Main program 58 
Main subprogram 59 
MANTISSA 55 
Maximum data in the heap 61 
Maximum identifier length 61 
Maximum line length 61 
Maximum number of Ada libraries 61 
Maximum number of compilation units 
61 

Maximum number of unique identifiers 
61 

Maximum size of a single array or 
record object 61 
Minimum timeable delay 58 

Number of active tasks 58 

Ordering of compilation units 59 


P’ARRAY_DESCRIPT0R 7 
P’IS ARRAY 7 
P’RECORD DESCRIPTOR 7 
PACK 5 

Parameter passing 2 
POSITIVE_COUNT 55 
Pragma IMPROVE 5,36 
Pragma INDENT 5 
Pragma INTERFACE 3,4 
Pragma INTERFACE_NAME 4 
Pragma PACK 5,25,26,29 
Pragma PRIORITY 5,58 
Pragma SUPPRESS 6 
Predefined packages 39 
PRIORITY 5,58 

Record objects 39 
RECORD.DESCRIPTOR 36 
Attribute 7 

RECORD^SIZE 33,36 
Rendezvous 58 
Representation clauses 15 
Runtime Executive 2,4,57,58 

SAFE EMAX 56 
SAFE'laRGE 56 
SAFE’sMALL 56 
SIZE 56 

Size of record types 37 
SPACE 36 

STANDARD_OUTPUT 58 
Storage reclamation at exit 57 
STORAGE_SIZE 24 

suppress” 6 

SYSTEM 5 


64 


Appendix F, Version 5 





Task activation 24 
Task suck size 24,57 
Task sucks 57 
Task types 24 
Tasks 

characteristics of 57 
TEXT lO 55 
TIME"36 

Unchecked conversions 43 
UNCHECKED DEALLOCATION 
57 

UNIX Unker 4 

Variant part 34 
variantJNDEX 34,35,36 


Index 


65 







