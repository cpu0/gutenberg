

MION PAGE 


Form Approved 
OPM No. 0704 0188 



Public ra 
nMdad. 

HMHiqui..-- 

Managsnwnt and Budgai. Waabington. DC 30603 . 


r raaponta, Including iba tim* lot lavmnng maiiuciont, taaicbrig aieiing data tomcM ganwmg and mamummg th« dau 
in ealimala (K any ahai aapaci at tna collaclion ot Mo'mation. ndudmg auggastiont loi laducmg the tmrdan to yya&rwigian 
in Danis Higtiway, Suns 1204 , Artngton, VA 22202 ' 4302 . and to ma Oliica ol mtomtation ano flegutatofy AHant Otic* ot 


1, AGENCY USE ONLY (Leave Blar)k) 


2 REPORT DATE 


3 REPORT TYPE AND DATES COVERED 

Final. 15 Jan 93 


4. TITLE AND SUBTITLE 

Validation Summary ReportiGTE Government Systems, Alsys Ada Software 
Development Environment for 80386 UNIX, Version 5.1.2, Zenith Data Systems, 
Z-Station 433 DEh (Host & Target). 930115S1.11309 


6. AUTHOR(S) 

National Institute of Standards and Technology 

Gaithersburg, MD 

USA 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS! 

National Institute of Standards and Technology 
National Computer Systems Laboratory 
Bldg. 255, Rm A266 
Gaithersburg, MD 20899 USA 




OTIC 

ELECT S 
MAR2 6 1993i 


c 


D 


5 FUNDING NUMBERS 


8 PERFORMING ORGANIZATION 
REPORT NUMBER 

AVF-NiST93GTE515 5 1.11 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, RM 3E114 
Washington, D.C. 20301-3081 


10 SPONSORING/MONITORfNG AGENCY 
REPORT NUMBER 


11. SUPPLEMENTARY NOTES 


12a. DISTRIBUTION/AVAILABILITY STATEMENT 

Approved for public release: distribution unlimited. 


12b. DISTRIBUTION CODE 


13. ABSTRACT (Maximum 200 words) 

GTE Government Systems, Alsys Ada Software Development Environment for 80386 UNIX, Version 5.1.2, Zenith Data 
Systems, Z-Station 433 DEh under SCO Unix Version 3.2 & CMW + Ver. 2.2 w/MaxSix (Host & Target), ACVC 111. 


93-06138 

llilllllilil! 


14. SUBJECT TERMS 

Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


15. NUMBER OF PAGES 


16 PRICE CODE 


17. SECURITY CLASSIFICATION 
OF REPORT 

UNCLASSIFIED 


18. SECURITY CLASSIFICATION 

UNCLASSIFED 


19. SECURITY CLASSIFICATION 
OF ABSTRACT 

UNCLASSIFIED 


20. LIMITATION OF ABSTRACT 


L 


NSN 7540-01-ZeO-SSO 


93 3 


& 


0 . 0 


Standard Form 298, (Rev 2-89) 
Prescribed by ANSI Std 239 128 










AVF Control Number: NIST93GTE515_5_1.11 
Certificate Information 


The following Ada implementation was tested and determined to pass 
ACVC 1.11. Testing was completed on January 15, 1993. 


Compiler Name and Version: Alsys Ada Software Development 

Environment for 80386 UNIX, Version 
5.1.2 


Host Computer System; Zenith Data Systems, Z-Station 433 

DEh under SCO Unix Version 3.2 & CMW 
+ Ver. 2.2 w/MaxSix 

Target Computer System: Zenith Data Systems, Z-Station 433 

DEh under SCO Unix Version 3.2 & CMW 
+ Ver. 2.2 w/MaxSix 


See section 3.1 for any additional information about the testing 
environment. 


As a result of this validation effort, Validation Certificate 
930115S1.11309 is awarded to GTE Government Systems. This 
certificate expires 2 years after ANSI/MIL-STD-1815B is approved by 
ANSI. 


This report has been reviewed and is approved. 




j\ 

a 




a ValidatiohJ 

FaCl 

Uity 


Chief, Information Systems 
Engineering Division (ISED) 



Ada Vali^dation P^;^lity 
Mr. L. Arnold CWhnson 
Manager, Software Standards 
Validation Group 


Computer Systems Laboratory (CSL) 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 




IP 


Ada Vj 
Direfn 

>ii< 

:or 

m 

fo: 

URi 

(A Organization 
puter & Software 


tute for Defense Analyses 
ndria VA 22311 


/;-vAda Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washinaton DC 20301 


1 

i 

a 


,aJ 











AVF Control Number: NIST93GTE515_5_1.11 
DATS COMPLETED 

BEFORE ON-SITE: 1993-01-11 
AFTER ON-SITE: 1993-01-15 
REVISIONS: 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 930115S1.11309 
GTE Government Systems 

Alsys Ada Software Development Environment for 
80386 UNIX, Version 5.1.2 
Zenith Data Systems, Z-Station 433 DEh => 
Zenith Data Systems, Z-Station 433 DEh 


Prepared By: 

Software Standards Validation Group 
Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


Acceston for 


NTIS 

CRA&! 


OTIC 

TAB 

Q 

I U'ced 

□ 

Jiistif'CutiCn_ 

- --„ 

I - 

1 Bv 

D'stnbutlor./ 


Codes 


Avtilf d 

!id 1 Of 

Otst 

SOVCidl 1 

9\A 





_____— 



TABLE OF CONTENTS 


CHAPTER 1.1-1 

INTRODUCTION . 1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT .... 1-1 

1.2 REFERENCES.1-1 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES . 2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3.3-1 

PROCESSING INFORMATION . 3-1 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A.A-1 

MACRO PARAMETERS.A-1 

APPENDIX B.B-1 

COMPILATION SYSTEM OPTIONS . B-1 

LINKER OPTIONS . B-2 

APPENDIX C.C-1 

APPENDIX F OF THE Ada STANDARD.C-1 

























CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro90] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to (Pro90]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552) . The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1.2 REFERENCES 

[Adas3] Reference Manual for the Ada Programming Language . 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 


1-1 






[Pro90] Ada Compiler Validation Procedures . Version 2.1, Ada Joint 
Program Office, August 1990. 

[UG89] Ada Compiler Valida t ion Capability User's Guide . 21 June 
1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK_FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is 
compiled and the resulting compilation listing is examined to 
verify that all violations of the Ada Standard are detected. Some 
of the class B tests contain legal Ada code which must not be 
flagged illegal by the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values — for example, the 
largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 


1-2 






For each Ada implementation, a customized test suite is produced by 
the AVF, This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [UG89]). 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Jtandard. 


1.4 DEFINITION OF TERMS 


Ada Compiler The software and any needed hardware that 

have to be added to a given host and 
target computer system to allow 
transformation of Ada programs into 
executable form and execution thereof. 


Ada Compiler 
Validation 
Capability (ACVC) 


Ada Implementation 


Ada Joint Program 
Office (AJPO) 


Ada Validation 
Facility (AVF) 


Ada Validation 
Organization (AVO) 


Compliance of an 
Ada Implementation 


The means for testing compliance of Ada 
implementations. Validation consisting of 
the test suite, the support programs, the 
ACVC Capability user's guide and the 
template for the validation summary (ACVC) 
report. 

An Ada compiler with its host computer 
system and its target computer system. 

The part of the certification body which 
provides policy and guidance for the Ada 
certification Office system. 

The part of the certification body which 
carries out the procedures required to 
establish the compliance of an Ada 
implementation. 

The part of the certification body that 
provides technical guidance for operations 
of the Ada certification system. 

The ability of the implementation to pass 
an ACVC an Ada version. 


1-3 



Computer System 


Conformity 

Customer 

Declaration of 
Conformance 

Host Computer 
System 

Inapplicable Test 

ISO 

LRM 

Operating System 


A functional unit, consisting of one or 
more computers and associated software, 
that uses common storage for all or part 
of a program and also for all or part of 
the data necessary for the execution of 
the program; executes user- written or 
user-designated programs; performs 
user-designated data manipulation, 
including arithmetic operations and logic 
operations; and that can execute programs 
that modify themselves during execution, A 
computer system may be a stand-alone unit 
or may consist of several inter-connected 
units. 

Fulfillment by a product, process or 
service of all requirements specified. 

An individual or corporate entity who 
enters into an agreement with an AVF which 
specifies the terms and conditions for AVF 
services (of any kind) to be performed. 

A formal statement from a customer 
assuring that conformity is realized or 
attainable on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source 
programs are transformed into executable 
form. 

A test that contains one or more test 
objectives found to be irrelevant for the 
given Ada implementation. 

International Organization for 
Standardization. 

The Ada standard, or Language Reference 
Manual, published as 
ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. 
Citations from the LRM take the form 
”<section>.<subsection>:<paragraph>,” 

Software that controls the execution of 
programs and that provides services such 
as resource allocation, scheduling, 
input/output control, and data management. 
Usually, operating systems are 
predominantly software, but partial or 
complete hardware implementations are 
possible. 


1-4 






Target Computer 
System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 


Validation 


Withdrawn Test 


A computer system where the executable 
form of Ada programs are executed. 

The compiler of a validated Ada 
implementation. 

An Ada implementation that has been 
validated successfully either by AVF 
testing or by registration [Pro90], 

The process of checking the conformity of 
an Ada compiler to the Ada programming 
language and of issuing a certificate for 
this implementation. 

A test found to be incorrect and not used 
in conformity testing. A test may be 
incorrect because it has an invalid test 
objective, fails to meet its test 
objective, or contains erroneous or 
illegal use of the Ada programming 
language. 


1-5 


CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 95 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 91-08-02. 


E28005C 

B28006C 

C32203A 

C34006D 

C'^55081 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 



2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Commentaries and commonly referenced in 
the format Al-ddddd. For this implementation, the following tests 
were determined to be inapplicable for the reasons indicated; 
references to Ada Commentaries are included as appropriate. 

The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 


2-1 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 



C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


The following 20 tests check for the predefined type LONG_INTEGER; 
for this implementation, there is no such type: 


C35404C 

C45502C 

C45613C 

C55B07A 


C45231C 

C45503C 

C45614C 

B55B09C 


C45304C 

C45504C 

C45631C 

B86001W 


C45411C 

C45504F 

C45632C 

C86006C 


C45412C 

C45611C 

B52004D 

CD7101F 


C35713B, C45423B, B86001T, and C86006H check for the predefined 

type SH0RT_FL0AT; for this implementation, there is no such type. 


C35713D and B86001Z check for a predefined floating-point type with 
a name other than FLOAT, LONG_FLOAT, or SH0RT_FL0AT; for this 
implementation, there is no such type. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for 
this implementation, MAX_MANTISSA is less than 47. 

C45536A, C46013B, C46031B, C46033B, and C46034B contain length 
clauses that specify values for small that are not powers of two or 
ten; this implementation does not support such values for small. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLOWS is FALSE for floating point types and the results 
of various floating-point operations lie outside the range of the 
base type; for this implementation, MACHINE_OVERFLOWS is TRUE. 

B86001Y uses the name of a predefined fixed-point type other than 
type DURATION; for this implementation, there is no such type. 

C96005B checks for values of type DURATION'BASE that are outside 
the range of DURATION. There are no such values for this 
implementation. 

CD1009C checks whether a length clause can specify a non-default 
size for a floating-point type; this implementation does not 
support such sizes. 

CD2A53A checks operations of a fixed-point type for which a length 
clause specifies a power-of-ten TYPE'SMALL; this implementation 
does not support decimal 'SMALLs. (See section 2.3.) 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length 
clauses to specify non-default sizes for access types; this 
implementation does not support such sizes. 


2-2 




BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine 
code insertions; this implementation provides no package 
MACHINE CODE. 


The 18 tests listed in the following table are not applicable 
because the given file operations are supported for the given 
combination of mode and file access method. 


Test 

File Operation Mode 

File Access Method 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL 10 

CE2102F 

CREATE 

INOUT FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT lO 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT lO 

CE2102W 

RESET 

OUT FILE 

DIRECT lO 

CE3102F 

RESET 

Any Mode 

TEXT 10 

CE3102G 

DELETE 


TEXT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT 10 

CE3102J 

OPEN 

IN FILE 

TEXT 10 

CE3102K 

OPEN 

OUT FILE 

TEXT lO 

The tests listed in the 

following table check the given fill 

operations for 

the given 

combination of 

mode and access method 

this implementation does 

not support these operations. 

Test 

File Operation Mode 

File Access Method 

CE2105A 

CREATE 

IN FILE 

SEQUENTIAL 10 

CE2105B 

CREATE 

IN FILE 

DIRECT 10 

CE3109A 

CREATE 

IN FILE 

TEXT 10 


CE2203A checks that WRITE raises USE_ERROR if the capacity of the 
external file is exceeded for SEQUENTIAL_IO. This implementation 
does not restrict file capacity. 

EE2401D, EE2401G, and CE2401H use instantiations of DIRECT_IO with 
unconstrained array and record types; this implementation raises 
USE_ERROR on the attempt to create a file of such types. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of the 
external file is exceeded for DIRECT_IO. This implementation does 
not restrict file capacity. 


2-3 







CE3202A expects that function NAME can be applied to the standard 
input and output files; in this implementation these files have no 
names, and USE_ERROR is raised. (See section 2.3.) 

CE3304A checks that SET_LINE_LENGTH and SET_PAGE_LENGTH raise 
USE_ERROR if they specify an inappropriate value for the external 
file; there are no inappropriate values for this implementation. 

CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the 
page number exceeds COUNT'LAST. For this implementation, the value 
of COUNT'LAST is greater than 150000, making the checking of this 
objective impractical. 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 23 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in 
the way expected by the original tests. 


B23004A 

B24007A 

B24009A 

B25002A 

B26005A 

B28003A 

B32202A 

B32202B 

B32202C 

B37004A 

B45102A 

B61012A 

B91004A 

BC3009A 

B95069A 

BC3009C 

B95069B 

B97103E 

BAllOlB 

BC2001D 


8A2001E was graded passed by Evaluation Modification as directed by 
the AVO. The test expects that duplicate names of subunits with a 
common ancestor will be detected as compilation errors; this 
implementation detects the errors at link time, and the AVO ruled 
that this behavior is acceptable. 

EA3004D was graded passed by Evaluation and Processing Modification 
as directed by the AVO. The test requires that either pragma 
INLINE is obeyed for a function call in each of three contexts and 
that thus three library units are made obsolete by the 
re-compilation of the inlined function's body, or else the pragma 
is ignored completely. This implementation obeys the pragma except 
when the call is within the package specification. When the test's 
files are processed in the given order, only two units are made 
obsolete; thus, the expected error at line 27 of file EA3004D6M is 
not valid and is not flagged. To confirm that indeed the pragma is 
not obeyed in this one case, the test was also processed with the 
files re-ordered so that the re-compilation follows only the 
package declaration (and thus the other library units will not be 
made obsolete, as they are compiled later); a "NOT APPLICABLE" 
result was produced, as expected. The revised order of files was 
0-1-4-5-2-3-6. 


2-4 



CD2A53A was graded inapplicable by Evaluation Modification as 
directed by the AVO. The test contains a specification of a 
power-of-10 value as 'SMALL for a fixed-point type. The AVO ruled 
that, under ACVC 1.11, support of decimal 'SMALLs may be omitted. 


2-5 






CHAPTER 3 


PROCESSING INFORMATION 


3,1 TESTING ENVIRONMENT 


The Ada implementation tested in this validation effort is 
described adequately by the information given in the initial pages 
of this report. 

For technical or sales information about this Ada implementation 
system, see: 


Mr. Steven G. Senz 
GTE Government Systems 
15000 Conference Center Drive 
Chantilly, VA 22021-3808 
Phone: (703) 818-4426 
FAX: (703) 818-5484 

Testing of this Ada implementation was conducted at the customer's 
site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were 
withdrawn because of test errors (item b; see section 2.1), those 
that require a floating-point precision that exceeds the 
implementation's maximum precision (item e; see section 2.2), and 
those that depend on the support of a file system — if none is 
supported (item d). All tests passed, except those that are listed 
in sections 2.1 and 2.2 (counted in items b and f, below). 


a) Total Number of Applicable Tests 3790 

b) Total Number of Withdrawn Tests 95 

c) Processed Inapplicable Tests 84 

d) Non-Processed I/O Tests 0 


3-1 



201 


e) Non-Processed Floating-’Point 
Precision Tests 

f) Total Number of Inapplicable Tests 285 (c+d+e) 

g) Total Number of Tests for ACVC 1.11 4170 (a+b+f) 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 
1.3) was taken on-site by the validation team for processing. The 
contents of the magnetic tape were loaded directly onto the host / 
target computer. 

After the test files were loaded onto the host / target computer, 
the full set of tests was processed by the Ada implementation. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B for 
a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this test 
were: 

The options invoked by default for validation testing during this 
test were: 

Switch Effect 


CALLS => INLINED Allow insertion of code for subprograms 

inline. (Default: NORMAL). 

DETAIL => NO No extra detail. (Default: YES) The 

default includes extra detail in the 
compilation listing such as more detailed 
error messages. 

TEXT => YES Print a complete compilation listing 

including the full source text. 

(Default: NO) The default includes only 

source text for program lines containing 
errors in the compilation listing, 

WARNING => NO Do not include warning messages. 

(Default: YES) The default includes 

warning messages in the compilation listing 
as well as more serious error messages. 

For the support files, the following options were explicitly 
invoked: 


3-2 









All default options were taken. 


For the A TEST files, the following options were explicitly 
invoked: 

Default compiler options & WARNING => NO 

For the B, C (except for CA3004E/F; note that EA3004D is compiled 
again in the order of 0-1-4-5-2-3-6) , D, & E2 TEST files, the 
following options were explicitly invoked: 

Default compiler options & WARNING => NO DETAIL => NO 
TEXT => YES 

For the CA3004E/F TEST files, the following options were explicitly 
invoked: 

Default compiler options & CALLS => INLINED 

For the E3..5, EA..B, ED..E & L TEST files, the following options 
were explicitly invoked: 

Default compiler options & WARNING => NO DETAIL => NO 
TEXT => NO 

Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. The listings 
examined on-site by the validation team were also archived. 


3-3 






APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for 
customizing the ACVC. The meaning and purpose of these 
parameters are explained in [UG89]. The parameter values are 
presented in two tables. The first table lists the values 
that are defined in terms of the maximum input-line length, 
which is I the value for $MAX_IN_LEN—also listed here. 
These values are expressed here as Ada string aggregates, 
where "V" represents the maximum input-line length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 255 


$BIG_ID1 

(1..V-1 => 'A', 

V => '1' ) 

$BIG_ID2 

(1..V-1 => 'A', 

V => '2') 

$BIG_ID3 

(1..V/2 => 'A') & 

'3' & (1..V-l-V/2 => 'A'} 

$BIG_ID4 

(1..V/2 => 'A') & 

'4' & (1..V-l-V/2 => 'A') 

$BIG_INT_LIT 

(1..V-3 => '0') 

& "298'' 

$BIG_REAL_LIT 

o 

A 

II 

IT) 

1 

> 

& "690.0" 

$BIG_STRING1 

& (1..V/2 = 

> 'A') Sc 

$BIG_STRING2 

& (1..V-1-V/2 => 'A') & '1' & 

$BLANKS 

(1..V-20 => ' ' 

) 

$MAX LEN INT BASED LITERAL 

”2:" & (1••V-5 => 

$MAX LEN REAL BASED LITERAL 

"16: *' & (1. .V-7 => 

$MAX STRING LITERAL '"' & (1..V-2 

'0') & "11:" 

'0') & "F.E:" 

=> 'A') & 


A-1 






The following table contains the values for the remaining 
macro parameters. 

Macro Parameter Macro Value 


$ACC SIZE 

$ALIGNMENT 

$COUNT_LAST 

$DEFAULT_MEM_SIZ E 

$DEFAULT_STOR_UNIT 

$DEFAULT_SYS_NAME 

$DELTA_DOC 

$ENTRY_ADDRESS 

$ENTRY_ADDRESS1 

$ENTRY_ADDRESS2 

$FIELD_LAST 

$FILE_TERMINATOR 

$FIXED_NAME 

$FLOAT_NAME 

$FORM_STRING 

$F0RM_STRING2 

$GREATER THAN DURATION 


32 

4 

2147483647 

2**32 

8 

I80386 
2#1.0#E-31 
TO_ADDRES S{16 # 4 0 #) 

TO_ADDRESS(16#80#) 

TO_ADDRESS(16#100#) 

255 

/ / 

NO_SUCH_FIXED_TYPE 
NO_SUCH_FLOAT_TYPE 

IIII 

"CANNOT RESTRICT FILE CAPACITY" 


75000.00 

$GREATER_THAN_DURATION_BASE_LAST 

131073.0 

$GREATER_THAN_FLOAT_BASE_LAST 

1.80141E+38 

$GREATER_THAN_FLOAT_SAFE_LARGE 

1.0E308 


A-2 





$GREATER_THAN_SHORT_FLOAT_SAFE_LARGE 

1.0E308 

$HIGH_PRIORITY 10 

$ILLEGAL_EXTERNAL_FILE_NAME1 

/NODIRECTORY/FILENAME 

$ILLEGAL_EXTERNAL_FILE_NAME2 

THIS/FILE/NAME/IS/NOT/ON/MY/SYSTEM 

$INAPPROPRIATE_LINE_LENGTH 

-1 

$INAPPROPRIATE_PAGE_LENGTH 

-1 

$INCLUDE_PRAGMA1 PRAGMA INCLUDE ("A28006D1.TST") 

$INCLUDE_PRAGMA2 PRAGMA INCLUDE {"B28006D1.ADA") 

$INTEGER_FIRST -2147483648 

$INTEGER_LAST 2147483647 

$INTEGER_LAST_PLUS_1 2147483648 

$INTERFACE_LANGUAGE C 

$LESS_THAN_DURATION -75000.0 

$ LES S_THAN_DURATION_BASE_FIRST 

-131073.0 

$LINE_TERMINATOR ASCII.LF 

$LOW_PRIORITY 1 

$MACHINE_CODE_STATEMENT 

NULL; 

$MACHINE_CODE_TYPE NO_SUCH_TYPE 

$MANTISSA_DOC 31 

$MAX_DIGITS 15 

$MAX_INT 2147483647 

$MAX INT PLUS 1 2147483648 


A-3 



-2147483648 


$MIN_INT 

$NAME SHORT_SHORT_INTEGER 

$NAME_LIST 

S370,180X86,I80386,MC680X0,VAX,TRANSPUTER,RS_6000,MIPS 


$NAME_SPECIFICATI0N1 

/usr/initch/acvc 11/X2102A 

$NAME_SPECIFICATION2 

/usr/mitch/acvc 11/X2102B 

$NAME_SPECIFICATION3 

/usr/mitch/acvc 11/X3119A 

$NEG_BASED_INT 

16#F000000E# 

$NEW_MEM_SIZE 

2**32 

$NEW_STOR_UNIT 

16 

$NEW_SYS_NAME 

I80386 

$PAGE_TERMINATOR 

ASCII.FF 

$RECORD_DEFINITION 

NEW INTEGER 

$RECORD_NAME 

NO_SUCH_MACHIN E_COD E_TY PE 

$TASK_SIZE 

32 

$TASK_STORAGE_SIZE 

1024 

$TICK 

1.0 

$VARIABLE_ADDRESS 

FCNDECL.OBJECT_ADDRESS 

$VARIABLE_ADDRESS1 

FCNDECL.OBJECTADDRESSl 

$VARIABLE_ADDRESS2 

FCNDECL.OBJECT_ADDRESS2 

$YOUR_PRAGMA 

INTERFACE 


A-4 





APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in 
this Appendix, are provided by the customer. Unless specifically 
noted otherwise, references in this appendix are to compiler 
documentation and not to this report. 


B-l 





4.2 The COMPILE Command 


The COMPILE command is used to invoke the Ada Compiler. 


COMPILE (SOURCE =>iource_«/imc | INSTANTIATION, 

LIBRARY = > library rtame. 

OPTIONS => 

(ANNOTATE 

> character_string. 

ERRORS 

= > positive integer. 

LEVEL 

= > PARSE 1 SEMANTIC | CODE 1 UPDATE. 

CHECKS 

= > ALL 1 STACK 1 NONE, 

GENERICS 

=^> STUBS 1 INLINE. 

TASKING 

= > YES 1 NO, 

MEMORY 

= > numberjofjcbytes). 

DISPLAY => 

(OUTPUT 

= > SCREEN 1 NONE 1 AUTOMATIC 1 
file name. 

WARNING 

= > YES 1 NO, 

TEXT 

= > YES 1 NO, 

SHOW 

= > BANNER 1 RECAP | ALL | NONE. 

DETAIL 

= > YES 1 NO. 

ASSEMBLY- 

= > CODE 1 MAP 1 ALL | NONEi. 

ALLOCATION => 

(STACK 

= > positivejnieger). 

IMPROVE => 

(CALLS 

= > normal j INLII'IED, 

REDUCTION 

= > NONE i PARTIAL j EXTENSIVE 

EXPRESSIONS 

= > NONE 1 PARTIAL | EXTENSIVEV. 

KEEP => 

(COPY 

= > YES 1 NO. 

DEBUG 

= > YES 1 NO, 

TREE 

= > YES 1 NO)); 


48 


User’s Guide, Version 5 





LINKER OPTIONS 


The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation 
and not to this report. 


B-2 




5.2 The BIND Command 


The BIND command is used to invoke the Ada Binder. 


BIND (PROGRAM = > unitjiame. 

LIBRARY => 

libraryjutme. 

OPTIONS => 

(LEVEL 

= > CHECK 1 BIND | LINK. 

MATHLIB 

= > 1287 1 1382. 

OBJECT 

= > AUTOMATIC 1 file name. 

UNCALLED 

= > REMOVE 1 KEEP. 

SLICE 

= > NO 1 positive integer. 

BLOCKING 

= > YES 1 NO 1 AUTOMATIC. 

STACK => 

(MAIN 

= > positiveJnteger, 

TASK 

= > positive integer. 

HISTORY 

= > YK 1 NO), 

HEAP => 

(SIZE 

= > positive Jnteger, 

INCREMENT 

= > naturaljtumber). 

INTERFACE => 

— 

(DIRECTIVES 

= > options JorJinker, 

MODULES 

= > file names. 

SEARCH 

— > libraryjiames). 

DISPLAY => 

(OUTPUT 

= > SCREEN 1 NONE | AUTOMATIC | file name. 

DATA 

= ^ RIND ! T.INK 1 ALL 1 NONE, 

warning 

= > YES 1 NO). 

KEEP => 

(DEBUG 

= > YES 1 NO. 

TUNE 

= > YES 1 NO)). 


I 


Binding, Linking, and Execution 


63 








APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appenaix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type SHORT_SHORT_INTEGER is range -128 .. 127, 

type SHORT_INTEGER is range -32768 .. 32767; 

type INTEGER is range -2147483648 .. 2147483647; 

type FLOAT is digits 6 range 

-2#1.11111111111111111111111#E+127.. 
2#1.11111111111111111111111#E+127; 

type LONG_FLOAT is digits 15 range 
-(2.0 - 2.0**(-52)) * 2.0**1023 .. 

+(2.0 - 2.0**(-52)) * 2.0**1023; 

type DURATION is delta 2#0.00000000000001# range 
-1310772.0000. .131071.99994;' 

end STANDARD; 


C-1 



PRE-RELEASE DOCUMENTATION - NOVEMBER 1990 

Alsys Ada Development Environment 
for UNIX (32.bit mode) 

APPENDIX F 


Version 5 



Copyright 1990 by Aisys 


All rights reserved. No part of this document may be reproduced in any form or by ’ny 
means without permission in writing from Aisys. 


Printed: November 1990 

Aisys reserves the right to make changes in spcdficaiions and other information 
contained in this publication without prior notice. Consult Aisys to determine 
whether such changes have been made. 


Aisys, Aila World AdaProbe, AdaXref. AdaRefonut, sad AdsMske sic refutered irademarVu of Aisys 
Uiuz u a retisiered irademart of ATScT. 

386^t IS a retuiered trademarli of Inienciive Sysiems Corponuoo. 

Microsoft is a rcsisiered tradenark of Microaofi Corponuoa. 

IBM. PC AT and PS/2 are retisiered tradeoiarfcs of latemaiionaJ Bustness Machines Corporanon 
INTEL u a resisicred iradcmail: of Intel Corporaiioo. 






TABLE OF CONTENTS 


APPENDIX F 


1 Implementation-Dependent Pragmas 

1.1 INLINE 

1.2 INTERFACE 

IJ INTERFACE name 
1.4 INDENT 
U Other Pragmas 


2 Implementation-Dependent Attributes 

11 P’IS ARRAY 

12 PHECORD DESCRIPTOR, P'ARRAY DESCRIPTOR 

13 E-EXCEPTlbN_CODE 

3 Specification of the package SYSTEM 


3.1 Package SYSTEM for 386 Mode 


4 Support for Representation Clauses 

4.1 Enumeration Types 

4.1.1 Enumeration Literal Enoxling 

4.1.2 Enumeration Types and Object Sizes 

4.2 Integer Types 

4.11 Integer Type Representation 

4.12 Integer Type and Objen Size 
Minimum size of an integer subtype 

4J Floating Point Types 

4J,l Floating Point Type Representation 


Table of Contents 





4 J.2 Floating Point Type and Objea Size 

17 

4.4 

Fixed Point Types 

18 


4.4.1 Fixed Point Type Representation 

18 


4.4.2 Fixed Point Type and Object Size 

20 

4.5 

Access Types and Gilleaions 

22 

4.6 

Task Types 


4.7 

Array Types 

23 


4.7.1 Array Layout and Struaure and Pragma PACK 

23 


4.7.2 Array Subtype and Objea Size 

27 

4.8 

Record Types 

28 


4.8.1 Basic Record Struaure 

28 


4.8.2 Indirea Components 

28 


4.8J Implicit Components 

32 


4.8.4 Size of Record Types and Objects 

36 

5 

Conventions for Implementation*Generated Names 

37 

6 

Address Clauses 

38 

6.1 

Address Causes for Objects 

38 

6.2 

Address Causes for Program Units 

39 

6J 

Address Causes for Interrupt Entries 

39 

7 

Unchecked Conversions 

40 

8 

Input-Output Packages 

41 

8.1 

Introduction 

41 

8.2 

The FORM Parameter 

42 


8.2.1 File Protection 

43 


8.2.2 File Sharing 

44 


8.2J File Structure 

45 


8.2.4 Buffering 

48 


8.2.5 Appending 

48 


8.2.6 Blocking 

48 


8.17 Terminal Input 

49 


Appendix F, Version -i 


9 Characteristics of Numeric Types 

9.1 Integer Types 

9.2 Floating Point Type Attributes 
9J Attributes of Ty^ DURATION 


10 Other Implementation-Dependent Characteristics 

10.1 Use of the Floating-Point Coprocessor 

10.2 Characteristics of the Heap 

10.3 Characteristics of Tasks 

10.4 Definition of a Main Subprogram 

10.5 Ordering of Compilation Units 

11 Limitations 

11.1 Compiler Limitations 

11.2 Hardware Related Limitations 


INDEX 


Table of Contents 



IV 


Appendix F, Version 4 





APPENDIX F 


Implementation • Dependent Characteristics 

This appendix summarizes the imp]ementation<dependent charaaeristics of the Alsys 
UNIX Ada Compiler. Appendix F is a required part of the Reference Manual for the Ada 
Pro^amming Language (called the RM in this appendix). 

The seaions of this appendix are as follows: 

1. The form, allowed places, and effect of every implemenuiion-dependcnt pragma. 

2. The name and the ts’pe of every implemenution-dependent attribute. 

3. The specification of the package SYSTEM. 

4. The description of the represenution clauses. 

5. The conventions used for any implementation-generated name denoting im¬ 
plementation-dependent components. 

6. The interpretation of expressions that appear in address clauses, including those 
for interrupts. 

7. Any restrictions on unchecked conversions. 

8. Any implementation-dependent charaaeristics of the input-output packages. 

9. Charaaeristics of numeric types. 

10. Other implementation-dependent characteristics. 

11. Compiler limitations. 


Appendix F, Iniplemeniaiion-Dependent Characteristics 


1 







The mmeAlsys Runtime Executive Programs or simply Runtime Executive refers lo the 
runtime library routines provided for all Ada programs. These routines implement the 
Ada heap, exceptions, tasking control, and other utility functions. 

General systems programming notes are given in another document, ihc Application 
Developer’s Guide (for example, parameter passing conventions needed for interface with 
assembly routines). 


Appendix F, Version 4 



Section 1 


Implementation-Dependent Pragmas 


1.1 INLINE 

Pragma INLINE is fully supported; however, it is not possible to inline a subprogram in a 
declarative part. 


1.2 INTERFACE 

Ada programs can interface with subprograms written in Assembler and other languages 
through the use of the predefined pragma INTERFACE and the implementation-defined 
pragma INTERFACE_NAME 

Pragma INTERFACE specifies the name of an interfaced subprogram and the name of 
the programming language for which parameter passing conventions will be generated. 
Pragma INTERFACE ukes the form specified in the RM: 

pragma INTERFACE (language_name, subprogram jtame); 

where, 

• language jiame is ASSEMBLER, ADA, or C 

■ subprogram jiame is the name used within the Ada program to refer to the 
interfaced subprogram. 

The only language names accepted by pragma INTERF, iCE arc ASSEMBLER, ADA and 
C The full implementation requirements for writing pragma INTERFACE subprograms 
are described in ihe Application De\'eloper 's CuuU. 

The language name used in the pragma INTERFACE docs not have to have any 
relationship to the language aaually used to write the interfaced subprogram. It ts used 
only to tell the Compiler how to generate subprogram calls; that is, what kind of 
parameter passing techniques to use. The programmer can interface Ada programs with 
subroutines written in any other (compiled) language by understanding the mechanism.^ 


Appendix F, Implementation-Dependent Characteristics 


3 




used for parameter passing by the Alsys UNIX Ada Compiler and the corresponding 
mechanisms of the chosen external language. 


13 INTERFACE_NAME 

Pragma INTERFACE_NAME associates the name of the interfaced subprogram with the 
external name of the interfaced subprogram. If pragma INTERFaCE_NAME is not used, 
then the two names are assumed to be identical This pragma takes the form: 

pragma INTERFACE_NaME (subprogram juime, saingjiieral); 

where, 

■ subprogram_name is the name used within the Ada pro^jTam to refer to the 
interfaced subprogram. 

■ stringjiteral is the name by which the interfaced subprogram is referred to at link 
time. 

The pragma 1 NTERFaCE_SAME is used to identic rouuncs in other languages that arc 
not named with legal Ada identifiers. Ada identiners can only conuin letters, digiu, or 
underscores, whereas the UNIX Linker allows external names to conuin other 
charaaers, for example, the dollar sign (S) or commercial at sign (@). These characters 
can be specified in ihe stringJiteral argument of the pragma INTERFaCE_NaME. 

The pragma INTERFaCE^.vaME is allowed at the same places of an Ada program as the 
pragma INTERFACE. (Location restriaions can be found in section 13.9 of the RM.) 
However, the pragma INTERFACE_NAME must always occur after the pragma 
INTERFACE declaration for the interfaced subprogram. 

The stringjiteral of the pragma INTERFaCE^NAME is passed through unchanged, 
including case sensitivity, to the UNIX objea file. There is no limit to the length of the 
name. 

The user must be aware however, that some toob from other vendors do not fully 
suppon the sundard objea file format and may restria the length of symbols. For 
example, xxxx 

The Runtime Executive conuins several external identifiers. All such identifiers begin 
with either the string "ADA^* or the string *ADAS_*. Accordingly, names prefixed by 
*ADA_* or *aDas_* should be avoided by the user. 


4 


Appendix F, Version 4 



Example 


package SaMPLE_DaTA is 

function SAMPLE_DEV1CE (X; INTEGER) return INTEGER; 
function PROCESS.SaMPLE (X; INTEGER) return INTEGER; 
private 

pragma INTERFACE (ASSEMBLE ',SAMPLE_DEV1CE); 
pragma INTERFACE (ADA, PROv ^.SAMPLE); 

pragma INTERFACE_NAME (SAMPLE.DEVICE T5EVT0SGET_SAMPLE*); 
end SaMPLE_DATA; 


1.4 INDENT 

Pragma INDENT is only used '*n\h AdaReformat. AdaReformat is the AJsys reformatter 
which offers the funaionalities of a pretty*printer in an Ada environment. 

The pragma is placed in the source file and interpreted by the Reformatter. The line 

pragma INDENT(OFF); 

czvieiAdaRef(mnat not to modify the source lines after this pragma, while 
pragma INDENT{ON); 

ezMses AdaReformat to resume its action after this pragma. 


1.5 Other Pragmas 

Pragmas IMPROVE and PACK are discussed in detail in the seaion on representation 
clauses and records (Chapter 4). 

Pragma PRIORITY is accepted with the range of priorities running from 1 to 10 (see the 
definition of the predefined package SYSTEM in Section 3). Undefined priority (no 
pragma PRlORnS') is treated as though it were less than any defined priority value. 

In addition to pragma SUPPRESS. Jt is possible to suppress all checks in a given compi¬ 
lation by the use of the Compiler option CHECKS. (See Chapter 4 of the User 's Guide.) 


Appendix F, Implementation-Dependent Characteristics 


5 






Section 2 


Implementation-Dependent Attributes 


2.1 P’IS_ARRAY 

For a prefix P that denotes any type or subtype, this attribute yields the value TRUE if P 
is an array type or an array subtype; otherwise, it yields the value FALSE. 


2.2 P’RECORD^DESCRIPTOR, P’ARRAY_DESCRIPTOR 

These attributes are used to control the representation of implicit components of a 
record. (See Seaion 4.8 for more details.) 


2.3 FEXCEPnON.CODE 

For a prefix £ that denotes an exception name, this attribute yields a value that 
represents the internal code of the exception. The value of this attribute is of the type 
INTEGER. 


6 


Appendix F, Version 4 





Section 3 


Specification of the package SYSTEM 


The implementation does not allow the recompilation of package SYSTEM. 


3.1 Package SYSTEM for 386 Mode 

package S7STEM it 




• (1) Required Oefinitiont. • 


type MAKE it (S370, IKjcM, 180356, MC680*0, VAX, TRAMSPOTER); 
STSTEM.MAME : conttant NAME :■ 1B0386; 

STORACE.UNIT ; conttant :« 8; 

MEM0RY_S1ZE : conttant :» 2*-32; 

** SyttaM-Oependent Naeicd Nuibcrt: 

MIN_JNT : conttant ;■ -(2 ”31); 

MAX__lirT : conttant :■ 2”31 • 1; 

MAX_0IGtTS : conttant ;■ 15; 

MAX_MANT15SA ; conttant ;■ 31; 

PINE_^0EITA : conttant ;■ 2R1.0#E*31; 

-- For the high-retolution tie»r, the clock resolution it 1.0 
Tier : conttant ;■ 1.0; 

•• Other Systcn>Oependent Occlaratiorw: 

tubtype PRIORITY it INTEGER range 1 28; — Lyrw 


Appendix F, Impiemeniaiion-Dependeni Characteristics 




subtyp* P«IORITT It IHTeCER rtnot 1 .. 10; - Othtr UHlX tytttnt 

■■ Th« rypt ADDRESS it. in ftct, iaplatcnttd tt a 
- 3W bit offtat* 

typa ADDRESS it prtvata; 

HULL.ADORESS: coratant ADDRESS; 


8 


Appendix F, Version 4 







(2) NACMIHE TYPE COMVERSIONS 


*• tf th« word / doublc-ttord operation* batoM ar* u*ad on 
AOORESS, than MSW ylatd* th* te 9 ii*nt and LSW yiaidt th* 

•- offset. 

•• In th* oparations baiew, a ITTE_TTP£ it any tiaplt typ# 

-> iatplanantad on a-biti {for axaapia, SKO«T_SHO«T_IliT£CER). a UORO^TTPE it 
-• any tiaplt type inplaoentcd on 16*bits (for cxaaplc. 5H0«T_INTEGER), and 
•• a 0(XJai.E_WO«0_TYPE is any tiapl* type iaplcncntad on 
•• 32-bit* (for exanple. INTEGER, FLOAT, AfiORESS). 

*• Ryte «■«» Word conversion*: 

•• Get th* Post sisnificant byt*: 
gentrie 

type ITTE_TTP£ is private; 
type W0*0__TyPE is private; 
flection MSB (W: WO«0_TTPE) return «YTE_TTPE; 

•• Get the least significant byte: 
generic 

type BYTE.TTPE it private; 
type WORD_TTPE is private; 
fi*Ktion LSS (W; UOR0_TYPC) return gTTE_TTPE; 

•• Conpos* a nord fro* t>«o bytes: 
generic 

type 8TTE_TTP£ it private; 
type WO«0_TTPE it private; 

function WORD (MB, LSB; BTTE_TTPE) return W0«0_TTPE; 

-- Word Double-Word conversions: 


Appendix F, Implementation-Dependent Charactensnes 




*■ Cet the laost significant ward: 
generic 

type WO#fl_TYPE is private; 
type 0OUBL£_WO«O_TTPe is private; 
fvnction NSW <W: OOU8l.£_UORD^TYPE) return «3ftD_TYPE; 

•• Get the least significant vord: 
generic 

type WORO^TYPE is private; 
type 00U8t.£_U0«O_TYPE is private; 
fUKtion LSU(W; OOU8LE_UOSO_TYPE) rttum W0«0_TYPE; 

•• Compose a DATA double word from tvo vords. 
generic 

type W0RD_TTPE is private; 

The following type must be a data type 
-- (for exaeple. LO«C_:ntEC£«): 
type OATA_oaJ8LE_wo«0 is private; 

funeti«i OOU8L£_UORD (NSW, ISW: WORD^TYPE) return 0ATA_00U8LE_«*D; 


• (3) OPERATICNS ON ADDRESS • 


•* You can get an address via 'ADDRESS attribute or by 
-- Some addresses are used by the Coopiter. for exa^le, 

•• the display is located at the lev end of the OS segment. 
•' Mote that no operatioru are defined to get the values of 
-- the segment registers, but if it is necessary an 
•• interfaced function can be written. 

generic 

type 08JECT is private; 

fieKtion fETCH_fRON^ADORESS (fRON; ADDRESS) return OBJECT; 


JO 


Appendix F, Version -> 






santric 

type OtJECT <• privatt; 

proetdura ASSISM^TO.ASORESS (OtJ: OIJECT; TO: AOORESS); 
private 


end STSTEN; 


Appendix F, Implementation-Dependent Characteristics 


11 



Section 4 


Support for Representation Clauses 


This seaion explains how objects are represented and allocated by the Alsys UNIX Ada 
compiler and how it is possible to control this using representation clauses. Applicable 
restrictions on representation clauses are also describ^ 

The representation of an objea is closely conneaed with its type. For this reason this 
section addresses successively the representation of enumeration, integer, floating point, 
fixed point, access, task, array and record types. For each class of type the representation 
of the corresponding objects is described. 

Except in the case of array and record types, the description for each class of type is 
independent of the others. To understand the represenution of array and record types it 
is necessary to undersund first the representation of their components. 

Apan from implementation defined pragmas, Ada provides three means to control the 
size of objects: 

■ a (predefined) pragma PACK, applicable to array types 
• a record representation clause 

■ a size specification 

For each class of types the effca of a size specification is described. Interactions among 
size specifications, packing and record representation clauses is described under the 
discussion of array and record types. 

Representation clauses on derived record types or derived tasks types are not supported. 

Size representation clauses on types derived from private types arc not supported when 
the derived type is declared outside the private part of the defining package. 


12 


Appendix F, Version 4 



4.1 Enumeration Types 


4.1.1 Enumeration Literal Encoding 

When no enumeration representation clause applies to an enumeration type, the 
internal code associated with an enumeration literal is the position number of the 
enumeration literal. Then, for an enumeration type with n elements, the internal codes 
are the integers 0,1,2, _, n-1. 

An enumeration representation clause can be provided to specie the value of each 
internal code as described in RM 13J. The Alsys compiler fully implements enumeration 
representation clauses. 

As internal codes must be machine integers the internal codes provided by an 
enumeration represenution clause must be in the range -2^^.. 

An enumeration value is always represented by its internal code in the program 
generated by the compiler. 


4.1.2 Enumeration TVpes and Object Sizes 

Minimum size of an enumermion subtype 

The minimum possible size of an enumeration subtype is the minimum number of bits 
that is necessary for representing the internal codes of the subtype values in normal 
binary form. 

A static subtype, with a null range has a minimum size of 1. Otherwise, if m and M are 
the values of the internal codes associated with the first and last enumeration values of 
the subtype, then its minimum size L is determined as follows. For m > = 0. L is the 
smallest positive intecer such that M < » 2^-1. For m < 0. L is the smallest positive 
integer such that -2^‘* < = m and M < =» 2^**-l. For example: 

type COLOR is (GREEN, BLACK. WHTTE, RED. BLUE YELLOW); 

- The minimum size of COLOR is 3 bits. 

subtype BLACK^AND.WHITE is COLOR range BLACK.. WHITE 

- The minimum size of BLaCK_aND_whiTE is 2 bits. 


13 


Appendix F, Implementation-Dependent Characteristics 





subtype BLACK_OR_WHITE is BLACK-AND-WHITE nwje X - X; 

- Assuming that X is noi sutic, the minimum size of BLACK_OR_WHi 11 is 

- 2 bits (the same as the minimum size of its type mark BLACK-AND-WHITE). 


Sizje of an ammaxaion subtype 

When no size specification is applied to an enumeration type or first named subtype, the 
objects of that type or first named subtype are represented as signed machine integers. 
The machine provides 8,16 and 32 bit integers, and the compiler selects automatically 
the snullest signed machine integer which can hold each of the internal codes of the 
enumeration type (or subtype). The size of the enumeration type and of any of its 
subtypes is thus 8,16 or 32 bits. 

When a size specification is applied to an enumeration type, this enumeration type and 
each of its subtypes has the size specified by the length clause. The same rule applies to a 
first named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies: 


type EXTENDED is 

(- The usual ASCII charaaer set 

NUU SOH. STX, ETX, EOT. ENQ, ACX, BEL, 


V. y. ’z’. •{’, T. ■)'. del. 


-- Extended charaaers 

C-CEDILLA-CAP. U-UMIAUT. E-ACUTE, -); 
for EXTENDED-SIZE use 8; 

- The size of type EXTENDED will be one byte. Its objects will be represented 

- as unsigned 8 bit integers. 

The Alsys compiler fully implements size specifications. Nevenheless, as enumeration 
values are coded using integers, the specified length cannot be greater than 32 bits. 


Siu of the objects of an enumeration subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
objea of an enumeration subtype has the same size as its subtype. 


14 


Appenda F, Version 4 



4.2 Integer Types 

There are three predefined integer types in the Alsys ixnplementation for 180x86 
machines: 

type SHORT_SHORT_rNTEGER Is range -2* *07 _ 2* *07-1; 

type SHORt”inTEGER Is range -2* *15.. 2* *15-1; 

typelhriEGER Is range-2* *31.. 2* *31-1; 


4.2.1 Integer Type Representation 

An integer type declared by a declaration of the form: 
type T is range L.. R; 

is implicitly derived from a predefined integer type. The compiler automatically selects 
the predefined integer type whose range is the smallest that contains the values L to R 
inclusive. 

Binary code is used to represent integer values. Negative numbers are represented using 
two’s oomplemenL 


4.2.2 Integer Type and Object Size 

Minimum size of an integer subtype 

The minimum possible size of an integer subtype is the minimum number of bits that is 
necessary for representing the internal codes of the subtype values in normal binary 
form. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M arc 
the lower and upper bounds of the subtype, then its minimum size L is determined as 
follows. For m > a 0, L is the smallest positive integer such that M < » 2^'*. For m < 
0, L is the smallest positive integer that -2^'* < = m and M < = 2^'^-l. For example: 

subcyoe S is INTEGER range 0.. 7; 

~ The minimum size of S is 3 bits. 

subtype D Is S range X .. Y; 


Appendix F, Implementation-Dependent Charactensnes 


15 




- A^uming that X and Y are not sutic, the mmimum size of 
~ D is 3 bits (the same as the minimum size of its type mark S). 


of an integer subtype 

The sizes of the predefined integer types SHORT_SHORT_INTEGER, SHORT_INTEGER 
and INTEGER are respectively 8,16 and 32 bits. 

When no size specification is applied to an integer type or to its fini named subtype (if 
any), its size and the size of any of its subtypes is the size of the predefined type from 
which it derives, directly or indirealy. For example: 

type S is range 80.. 100: 

- S is derived from SHORTJHORT_INTEGER, its size is 

- 8 bits. 

type J is range 0.. 255; 

- J is derived from SHORT.INTEGER. its size is 16 bits, 
type N is new J range 80.. 100; 

- N is indirectly derived from SHORT INTEGER, its size is 
-16 bits. 

When a size specification is applied to an integer type, this integer type and each of its 
subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies; 

type S is range 80.. 100; 
forS’SIZE use 32; 

- S is derived from SHORT.SHORTJNTEGER, but its size is 

- 32 bits because of the size specification. 

type J is range 0.. 255; 
forJ’SIZE use 8; 

- J is derived from SHORT_rNTEGER. but its size is 8 bits 

- because of the size specification. 

type N is new J range 80.. 100; 

- N is indirectly derived from SHORT^INTEGER, but its 


]6 


Appendix F, Version 4 



~ size is 8 bits because N inherits the size specification 
-ofJ. 


SUe of the objects of an integer subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
objea of an integer subtype has the same size as its subtype. 


4J Floating Point Types 

There are nvo predefined floating point types in the Alsys implementation for 180x86 
machines: 

type FLOAT is 

digits 6 range -(10 - 10-(-23))'2.0“l27 .. (10.10**(-23))*10-i:7; 
type LONG FLOAT Is 

dlgiuis range -(10 -10**(-51))-10**1023.. (10 -10**(-51))*10-1023; 


4J.l Floating Point Type Representation 

A floating point type declared by a declaration of the form; 

type! is digits D (range L _ R]; 

is implicitly derived from a predefined floating point type. The compiler automatically 
selects the smallest predefined floating point type whose number of digits is greater than 
or equal to D and which conuins the values L to R inclusive. 

In the program generated by the compiler, floating point values are represented using 
the lE^ standard formats for single and double floats. 

The values of the predefined type FLOAT are represented using the single float format. 
The values of the predefined type LONG_FLOaT are represented using the double float 
formal. The values of any other floating point type are represented in the same way as 
the values of the predefined type from which it derives, directly or indirealy. 


4 J.2 Floating Point Type and Object Size 


Appendix F, Implementation-Dependent Characteristics 


17 




The minimum possible size of a floating point subtype is 32 bits if its base type is FLOAT 
or a type derived from FLOAT; it is 64 bits if its base type is LONG.FLOAT or a type 
derived from LONG_FLOAT. 

The sizes of the predefined floating point types FLOAT and LONG_FLOaT are 
respeaively 32 and 64 bits. 

The size of a floating point type and the size of any of its subtypes is the size of the 
predefined type from which it derives direaly or indirectly. 

The only size that can be specified for a floating point type or first named subtype using a 
size specification is its usual size (32 or 64 bits). 

An objea of a floating point subtype has the same size as its subtype. 


4.4 Fixed Point Types 


4.4.1 Fixed Point lype Representation 

If no specification of small applies to a fixed point type, then the value of small is 
determined by the value of delta as defined by RM 33.9. 

A specification of small can be used to impose a value of small. The value of small is 
required to be a power of two. 

To implement fixed point types, the Alsys compiler for I8(ht86 machines uses a set of 
anonymous predefined types of the form: 

type SHORT.FIXED is delu D range (.2.0*'7.1)-S.. 2.0**7*S; 
for SHORT^FDCED’SMaLL use S; 

type FIXED is delta D range (-2.0**15-1)-S - 2.0**15*S; 
for FDCED'SMaLL use S; 

type L0NG_F1XED is delu D range (-L0**3M)*S.. 2.0’*31*S; 
for LONG^FIXED’SMALL use S; 

where O is any real value and S any power of two less than or equal to D. 

A fixed point type declared by a declaration of the form: 


18 


Appendix F, P'emon 4 






type T is delta D range L . R: 


Appendix F, Implementation-Dependent Characteristics 


10 







possibJy wfUi a small specification: 
for TSMaLL use S; 

is impliciily derived from a predefined fixed point type. The compiler automatically 
selects the predefined fixed point type whose smaU and delu are the same as the small 
and delta of T and whose ran^e is the shortest that includes the values L to R inclusive. 

In the program generated by the compiler, a safe value v of a fixed point subtype F is 
represented as the integer. 

V/rSASE’SMALL 


4.4.2 Fixed Point T^pc and Object Size 

Minimum size of a fixed poini subtype 

The minimum possible size of a fixed point subtype is the minimum number of binary 
digits that is necessary for representing the values of the range of the subtype using the 
small of the base type. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, $ and S being 
the bounds of the subtype, if i and I are the integer representations of m and M. the 
smallest and the greatest model numbers of the base type such that s < m and M < S, 
then the minimum size L is determined as follows. For i >=* 0, L is the smallest positive 
inteeer such that I < = 2^'^ Fort < 0, Lis the smallest positive integer such that - 
iandl <= 

type F is delta ZO range 0.0.. 500.0; 

- The minimum size of F is 8 bits. 

subtype S is F delta 16.0 range 0.0.. 250.0; 

- The minimum size of S is 7 bits. 

subtype D Is S range X - Y; 

- Assuming that X and Y are not static, the minimum size of D is 7 bits 

- (the same as the minimum size of its type mark S). 


20 


Appendix F, Version 4 




Size of a fixed point subtype 

The sizes of ihe predefined Qxed point types SHORT_FIXED, FIXED and LONG_FDCED 
arc respcaively 8,16 and 32 bits. 

When no size specification is applied to a Qxed point type or to its first named subtype, 
its size and the size of any of its subtypes is the size of the predefined type from which ii 
derives direaly or indirealy. For example; 

type S is delta 0.01 range 0.8.. 1.0: 

- S is derived from an 8 bit predefined fixed type, its size is 8 bits, 
type F is delta 0.01 range 0.0.. 2.0; 

~ F is derived from a 16 bit predefined fixed type, its size is 16 bits, 
type N is new F range 0.8 .. 1.0; 

- N is indirectly derived from a 16 bit predefined fixed type, its size is 16 bits. 

When a size specification is applied to a fixed point type, this fixed point type and each of 
its subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies: 

type S is delta 0.01 range 0.8.. 1.0; 
for S’SIZE use 32; 

~ S is derived from an 8 bit predefined fixed type, but its size is 32 bits 

- because of the size specification. 

type F is delta 0.01 range 0.0.. 2.0; 
for FSIZE use 8; 

- F is derived from a 16 bit predefined fixed type, but its size is 8 bits 

- because of the size specification. 

type N is new F range 0.8.. 1.0; 

- N is indirealy derived from a 16 bit predefined fixed type, but its size is 

- 8 bits because N inherits the size specification of F. 

The Alsys compiler fully implements size specifications. Ncvenheless, as fixed point 
objects are represented using machine integers, the specified length cannot be greater 
than 32 bits. 


Appendix F, Implementarion-Dependeni Characteristics 


21 





Size of the objects of a fixed point subtype 

Provided its size is not coastrained by a record component clause or a pragma PACK, an 
objea of a fixed point type has the same size as its subtype. 


4.5 Access Types and Collections 

Access Types and Objects of Access Types 

The only size that can be specified for an access type using a size specification is its usual 
size (32 bits). 

An object of an access subtype has the same size as its subtype, thus an object of an 
access subtype is always 32 bits long. 


Collection Size 

As described in RM 13.2, a specification of colleaion size can be provided in order to 
reserve storage space for the collection of an access type. 

When no STORAOE.SIZE S{)edfication applies to an access type, no storage space is 
reserved for its colleaion, and the value of the attribute ST0 RaGE_S 12E is then 0. 

The maximum size is limited by the amount of memory available. 


4.6 Task Types 

Storage for a task activation 

As described in RM 13.2, a length clause can be used to spcafy the storage space (that is. 
the stack size) for the aaivation of each of the tasks of a given type. Alsys also allows the 
task suck size, for ail tasks, to be esublished using a Binder option. If a length clause is 
given for a task typje, the value indicated at bind time is ignored for this task typ)c, and the 
length clause is obeyed. When no length clause is used to specify the storage space to be 
reserved for a task aaivation, the storage space indicated at bind time is used for this 
aaivation. 

A length clause may not be applied to a derived task typ>e. The same storage space is 
reserved for the activation of a task of a derived typ>e as for the activation of a task of the 
parent iyp>e. 


22 


Appendix F, Version 4 





The minimum size of a task subtype is 32 bits. 

A size specification has no effea on a task type. The only size that can be specified using 
such a length clause is its usual size (32 bits). 

An object of a task subtype has the same size as its subtype. Thus an object of a task 
subtype is always 32 bits long. 


4.7 Array Types 

Each array is allocated in a contiguous area of storage units. Ail the components have 
the same size. A gap may exist between two consecutive components (and after the Iasi 
one). All the gaps have the same size. 


4.7.1 Array Layout and Structure and Pragma P.4CK 



Coaporwnt Cap Conpoewnt Cap CoMponant Cap 


If pragma PACK is not specified for an array, the size of the components is the size of the 
su^-type of the components: 

type A is array (1.. 8) of BOOLEAN; 

- The size of the components of A is the size of the type BOOLEAN: 8 bits. 

type DECIMAL_DIGrr Is range 0.. 9; 
for DEaMAL.DIOrrSIZE use 4; 
type BINARY_CODED^DECIMAL is 

■my (U?TEGER range < >) of DECIMAL_DlGrT; 

- The size of the type DEaMAL^DICIT is 4 bits. Thus tn an array of 

- type B1 NARY_CODED_DECIMaL each component will be represented on 

- 4 bits as in the usual BCD representation. 


Appendix F, Implementitnon-Dependent Characienshcs 


23 













If pragma PACK is specified for an array and its components are neither records nor 
arrays, the size of the components is the minim um size of the subtype of the components: 

type A is array (1 „ 8) of BOOLEAN; 
pragma PaCK(A); 

- The size of the components of A is the minimum size of the type BOOLEAN: 

- 1 bit. 

type D£CIMAL_DIGrr is range 0.. 9; 
for DECIMAL^ICrrsIZE use 32; 
type BINARY “cODED.DEaMAL is 

array (INTEGER range < >) of DEaMAL.DIGIT; 
pragma PACK(BINARY^CODED_DECIMAL); 

- The size of the type DECIMAL_D1GIT is 32 bits, but, as 

- BINARY_CODED_Dr ciMAL is packed, each component of an array of this 

- type will be represented 'n 4 bits as in the usual BCD representation. 

Packing the array has no effect on the size of the components when the components are 
records or arrays, since records and arrays may be assigned addresses consistent with the 
alignment of their subtypes. 


Caps 

If the components are records or arrays, no size specification applies to the subtype of 
the components and the array is not packed, then the compiler may choose a 
representation with a gap after each component; the aim of the insertion of such gaps is 
to optimize access to the array components and to their subcomponents. The size of the 
gap is chosen so that the relative displacement of consecutive components is a multiple 
of the alignment of the subtype of the components. This strategy allows each component 
and subcomponent to have an address consistent with the alignment of its subtype: 

lypeRls 

record 

K: SHORT_INTEGER; 

B ; BOOLE^; 

end record; 
for R use 
record 

K at 0 range 0.. 31; 

B at 4 range 0.. 0, 


24 


Appendix F, Version J 


end record; 

- Record type R is byte aligned. Its size is 33 bits, 
type A is ermy (1.. 10) of R; 

- A gap of 7 bits is inserted after each component in order to respea the 

- alignment of type R. The size of an array of type A will be 400 bits. 


Appendix F, Implementaiion-Dependeni Charaaeristia 


25 




■BjW 


M 


1 

n 

D 


IHH 

n 

UBI 

PI 




iffii 



C o wpontnt Sap Coaponant Sap Coapooant Sap 
Ajto^ oftyptA: each subcomponent K has an even offseL 


If a size specification applies to the subtype of the components or if the array is packed, 
no gaps are insened: 


type R is 
record 

K; SHORTJNTEGER; 

B: BOOLE^; 
end record; 

type A is array (1.. 10) of R; 
pragma PACl^A); 

- There is no gap in an array of type A because A is packed- 

- The size of an objea of type A will be 330 bits. 

type NR is new R; 
for NR'SIZE use 24; 

type B is array (1 _ 10) of NR; 

- There is no gap in an array of type B because 
~ NR has a size specification. 

- The size of an objea of type B will be 240 bits. 



Component 


Component 


Array of type A or B 


26 


Appendix F, Version J 











4.7^ Array Subtype and Object Size 

Size of an array subtype 

The size of an array subtype is obtained by multiplying the number of its components by 
the sum of the size of the components and the size of the gaps (if any). If the subtype is 
unconstrained, the maximum number of components is considered. 

The size of an array subtype cannot be computed at compile time 

« if it has non-static constraints or is an unconstrained array type with non-static 
index subtypes (because the number of components can then only be determined at 
run time). 

■ if the components are records or arrays and their constraints or the constraints of 
their subcomponents (if any) are not static (because the size of the components and 
the size of the gaps can then only be determined at run time). 

As has been indicated above, the effect of a pragma PACK on an array type is to suppress 
the gaps. The consequence of packing an array type is thus to reduce its size. 

If the components of an array are records or arrays and their constraints or the 
constraints of their subcomponents (if any) are not sutic, the compiler ignores any 
pragma PACK applied to the array type but issues a warning message. Apan from this 
limitation, array packing is fully implemented by the Alsys compiler. 

A size specification applied to an array type or first named subtype has no effect. The 
only size that can be specified using such a length clause is its usual size. Nevenheless. 
such a length clause can be useful to verify that the layout of an array is as expeaed by 
the application. 


Size of the objects of an array subtype 

The size of an object of an array subtype is always equal to the size of the subtype of the 
object 


Appendix F, Impiementaiion-Dependent Characteristics 




4.8 Record Types 


4.8.1 Basic Record Structure 
Layout of a record 

Each record is allocated in a contiguous area of storage units. The size of a record 
component depends on its type. 

The positions and the sizes of the components of a record type objea can be controlled 
using a record represenution clause as described in RM 13.4. In the Alsys 
implementation for 180x86 machines there is no restriaion on the position that can be 
specified for a component of a record. If a component is not a record or an array, its size 
can be any size from the minimum size to the size of its subtype. If a component is a 
record or an array, its size must be the size of its subtype. 

Pragma PACK has no effect on records. It is unnecessary because record representation 
clauses provide full control over record layout. 

A record representation clause need not spedfy the position and the size for every 
component If no component clause applies to a component of a record, its size is the 
size of its subtype. 


4.8.2 Indirect Components 

If the ofbet of a component cannot be computed at compile time, this offset is stored in 
the record objeos at run time and used to access the component Such a component is 
said to be indirect while other components are said to be dirca; 


28 


Appendix F, yersion 4 





I*ginn{na of th« record 
Coi^llo t1a» of foot 

Conpilc tioe offoot 


Itn tiae offiot 


A direci and an indirect component 

If a record component is a record or an array, the size of its subtype may be evaluated at 
run time and may even depend on the discriminants of the record. We will call these 
components dynamic components; 

type DEVICE is (SCREEN. PRINTER); 

type COLOR is (GREEN. RED. BLUE); 

type SERIES is array (POSITIVE range < >) of INTEGER; 

type GRAPH (L: NATURAL) Is 
record 

X : SERIES( 1 _ L); - The size of X depends on L 
Y; SERIES( 1 _ L); - The size of Y depends on L 
end record; 

Q : POSITIVE; 


Appendix F, Implementation-Dependent Charactensrics 


29 





type PICmRE CN: NATURAL; D: DEVICE) is 
record 

F: GRaPH(N); - The size of F depends on N 
S : GRAPH(Q); - The size of S depends on Q 
case D is 

when SCREEN »> 

C: COLOR; 
when PRINTER ■ > 
null: 
end case; 
end record; 

Any component placed after a dynamic component has an offset which cannot be 
evaluated at compile time and is thus indirect In order to minimize the number of 
indirect components, the compiler groups the dynamic components together and places 
them at the end of the record: 


0 ■ SOtEEM 0 • PR1MTE8 

M > 2 N > 1 



S 



The record type PICTURE: Fond S are placed at the end of the record 


30 


Apperuiu F, Version J 






Note that Ada does not allow represenutioo clauses for record components with non¬ 
static bounds [HM 13.4.7], so the compiler’s grouping of dynamic components does not 
conflict with the use of representatioa clauses. 

Because of this approach, the only indirea components are dynamic components. But 
not all dynamic components are necessarily indirea: if there are dynamic components in 
a component list which is not followed by a variant part, then exactly one dynamic 
component of this list is a direa component because its ofBet can be computed at 
compilation time (the only dynamic components that are direa components are in this 
situation); 






L 





X 


Y 


teg i mine of the record 
Coopile tiae offset 


■ ' Coopile tiae offset 

site dependent on diseriainont L 
' tiat offset 

Size dependent on discriainant t 


The record rype GRAPH: the dynamic componeru X is a direct component 


The ollset of an indirea component is always expressed in storage units. 

The space reserved for the of&et of an indirea component must be large enough to store 
the size of any value of the record type (the maximum potential offeet). The compiler 
evaluates an upper bound MS of this size and treats an ofBet as a component having an 
anonymous integer type whose range is 0 _ MS. 

If C is the name of an indirea component, then the oflset of this component can be 
denoted in a component clause by the impiemeniation generated name COFFSET. 


Appendix F, Implementation-Dependent Characteristics 


31 








4.83 Implicit Components 

In some circumsunces, access to an objea of a record type or to its components involves 
computing information which only depends on the discriminant values. To avoid 
recomputation (which would degrade performance) the compiler stores this information 
in the record objects, updates it when the values of the discriminants are modified and 
uses it when the objects or its components are accessed. This information is stored in 
special components called implicit components. 

An implicit component may contain information which is used when the record object or 
several of its components are accessed. In this case the component will be included in any 
record object (the implicit component is considered to be declared before any variant 
part in the record type declaration). There can be two components of this kind; one is 
called RECORD_SI*ZE and the other VARlA>rr_INDEX. 

On the other hand an implicit component may be used to access a given record 
component In that case the implicit component exists whenever the record compone.nt 
exists (the implicit component is considered to be declared at the same place as the 
record component). Components of this kind are called ARRAY DESCRIPTORS or 
RECORD_DESCRIPTORs. 


RECORDJIZE 

This implicit component is created by the compiler when the record type has a variant 
part and its discriminants are defaulted. It contains the size of the storage space 
necessary to store the current value of the record objen (note that the storage effectively 
allocated for the record objea may be more than this). 

The value of a RECORD_SIZE component may denote a number of bits or a number of 
storage units. Id general it denotes a number of storage units, but if any component 
clause specifies that a component of the record type has an ofiset or a size which cannot 
be expressed using storage units, then the value designates a number of bits. 

The implicit component RECORD_SIZE must be large enough to store the maximum 
size of any value of the record type. The compiler evaluates an upper bound MS of this 
size and then considers the implicit component as having an anonymous integer rvpe 
whose range is 0.. MS. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R’RECORD_SIZE This 
allows user control over the position of the implicit component in the record. 


32 


Appendix f. Version J 




VAXJANTjmDEX 

This implidt coraponent is created by the compiler wbcit the reconl type has a variant 
pan. It indicates the set of components that are present in a record value. It is used when 
a dtsaiminant check is to be done. 

Component lists in variant parts that themselves do not contain a variant pan are 
numbered. These numbers are the possible values of the implidt component 
VARIANT_INDEX. 

type VEHICLE is (AIRCRAFT, ROCKET, BOAT, CAR); 

type DESCRIPTION (KIND: VEHICLE:« CAR) is 
record 

SPEED: INTEGER; 
case KIND is 

when AIRCRAFT | CAR «> 

WHEELS: INTEGER; 
case KIND is 

when AIRCRAFT * > - 1 

wingspan : INTEGER; 

»rhen others * > — 2 

null; 
end case; 

when boat * > - 3 
STEAM : BOOLEAN; 
when ROCKET ■ > — 4 

STAGES: INTEGER; 
end case; 
end record; 

The value of the variant index indicates the set of components that arc present in a 
record value: 


Variant Inde* 

Set 

1 

(KIND, SPEED. UMEELS, UIHCSPAH> 

2 

{KINO. SPEED, UHEELS> 

3 

aiMD, SPEED, STEM) 

4 

(KIMD, SPEED. STAGES) 


Appendix F, Implementation-Dependent Charaaeristics 


33 





A comparison between the variant index of a record value and the bounds of an interval 
is enough to check that a given component is present in the value: 


Conponent 

Interval 

KINO 

• • 

SPEED 

-- 

UMEELS 

1 2 

WINGSPAN 

1 .. 1 

STEAM 


STAGES 



The implicit component vaRLAKTJNDEX must be large enough to store the number v 
of component lists that don't contain variant parts. The compiler treats this implicit 
component as having an anonymous integer type whose range is l.. V. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implemenution generated name RVaRIANT^INDEX. This 
allows user control over the position of the implicit component in the record. 


array JOESaUPTOR 

An implicit component of this kind is associated by the compiler with each record 
component whose subtype is an anonymous array subtype that depends on a discriminani 
of the record. It contains information about the component subtype. 

Thesiruaure of an implicit component of kind aRRAY_DESCRIPTOR is not desaibed 
in this documentation. Nevenheless, if a programmer is interested in specifying the 
location of a component of this kind using a component claitse, size of the component 
may be obtained using the ASSEMBLY parameter in the COMPILE command. 

The compiler treats an implicit component of the kind ARRaY_DESCRIPTOR as having 
an anonymous array type. If C is the name of the record component whose subtype is 
described by the array descriptor, then this implicit component can be denoted in a 
component clause by the implementation generated name CaRRaY^DESCRIPTOR. 

This allows user control over the position of the implicit component in the record. 


34 


Appendix F, Version 








RECORDJDESCRJPTOR 

An implicit component of this kind is associated by the compiler with each record 
component whose subtype is an anonymous record subtype that depends on a 
discriminant of the record. It contains information about the component subtype. 

The struaure of an implicit component of kind RECORD_DESCRIPTOR is not described 
in this documentation. Nevertheless, if a programmer is interested in specifying the 
location of a component of this kind using a component clause, the size of the 
component may be obtained using the ASSEMBLY parameter in the COMPILE 
command. 

The compiler treats an implicit component of the kind RECORO.DESCRIPTOR as 
having an anonymous array type. If C is the name of the record component whose 
subtype is described by the record descriptor, then this implicit component can be 
denoted in a component clause by the implemenuiion generated name 
CRECORD^DESCRIPTOR. This allows user control over the position of the implicit 
component in the record. 


Suppression of Implicit Components 

The Alsys implementation provides the capability of suppressing the implicit 
components pragma IMPROVE (TIME | SPACE. [ON - >] simple_name); 

The first argument specifics whether TIME or SPACE is the primary criterion for the 
choice of the represenution of the record type that is denoted by the second argument. 

If TIME is specified, the compiler inserts implicit components as described above. If on 
the other hand SPACE is specified, the compiler only inserts a vaRIaNT_INDEX or a 
RECORD_SIZE component if this compKrnent appears in a record representation clause 
that applies to the record type. A record representation clause can thus be used to keep 
one implicit component while suppressing the other. 

A pragma IMPROVE that applies to a given record type can occur anywhere that a 
representation clause is allowed for this type. 


Appendix F, Implementation-Dependent Characteristics 


35 


4.8.4 Size of Record T^pes and Objects 

Size of a record subtype 

Unless a component clause specifies that a component of a record type has an offset or a 
size which cannot be expressed using storage uniu, the size of a record subtype is 
rounded up ic a whole number of storage units. 

The size of a constrained record subtype is obuined by adding the sizes of its 
components and the sizes of its gaps (if any). This size is not computed at compile time 

• when the record subtype has non-static constraints, 

• when a component is an array or a record and its size is not computed at compile 
time. 

The size of an unconstrained record subtype is obtained by adding the sizes of the 
components and the sizes of the gaps (if any) of iu largest variant. If the size of a 
component or of a gap cannot be evaluated exaaly at compile time an upper bound of 
this size is used by the compiler to compute the subtype size. 

A size specification applied to a record type or lint named subtype has no efJea. The 
only size that can be specified using such a length clause is its usual size. Nevertheless, 
such a length clause can be useful to verify that the layout of a record is as expected by 
the application. 


Size of an object of a record subtype 

An object of a constrained record subtype has the same size as its subtype. 

An objea of an unconstrained record subtype has the same size as its subtype if this size 
is less than or equal to 8 kb. If the size of the subtype is greater than this, the object has 
the size necessary to store its current value; storage space is allocated and released as the 
discriminants of the record change. 


36 


Appendix F, Version J 





Section 5 


Conventions for Implementation-Generated Names 


The Alsvs UNIX Ada Compiler may add fields to record objects and have descriptors sn 
memory for record or array objects. These fields are accessible to the user through 
impiemenution-generated attributes (See Section 23). 

The following predefined packages are reserved to Alsys and cannot be recompiled in 
Version 4.2: 

mtai 

a t tyt_ada^runti a* 

alays^baate^io 

alay»_binarY_io 

calandar 

a {tyv^coanon^ {o 

a t ay«_f i I a_a»nagtM8nt 

alayt_io_traeaa 

tnix 

ay*tani_envi ronment 
ijn tintype 
insignad 


ApperdixF, Implemenmrion-DeperuUm Charaamstics 


37 







Section 6 


Address Clauses 


6.1 Address Clauses for Objects 

An address clause can be used to specify an address for an objea as described in RM 13.5. 
When such a clause applies to an objea the compiler does not cause storage to be 
allocated for the object. The program accesses the objea using the address specified in 
the clause. It is the responsibility of the user therefore to make sure that a valid 
allocation of storage has been done at the spedfted address. 

An address clause is not allowed for task objects, for unconstrained records whose size is 
greater than 8k bytes or for a constant. 

There arc a number of ways to compose a legal address expression for use in an address 
clause. The most direa ways are: 

■ For the case where the memory is defined in Ada as another object, use the 
'ADDRESS attribute to obuin the argument for the address clause for the second 
objea. 

■ For the case where an absolute address is known to the programmer, instantiate the 
generic funaion SYSTE.M.REFERENCE on a 16 bit unsigned integer type (either 
from package UNSIGNED, or by use of a length clause on a derived integer type or 
subtype) and on type SYSTEMaDDRESS. Then the values of the desired segment 
and oOki can be passed as the aaual parameters to the instantiated function in the 
simple expression pan of the address clause. Sec Seaton 3 for the specification of 
package SYSTEM. 

■ For the case where the desired location is memory defined in assembly or another 
non-Ada language (is relocatable), an interfaced routine may be used to obuin the 
appropriate address from referencing information known to the other language. 

In all cases other than the use of an address attribute, the programmer must ensure that 
the segment part of the argument is a selcaor if the program is to run in proieaed mode. 
Refer to \hc Application Developers ’ Guide, Seaion 5.5 for more information on 
proieaed mode machine oriented programming. 


38 


Appendix F, Version 4 




6J. Address Clauses for Program Units 

Address clauses for program units are not implemented in tite current version of the 
oompQer. 

6J Address Clauses for Interrupt Entries 

Address clauses for entries are supported. The address is a UNIX signal number. See 
ihtAppliauion Developer’s Guide for deuils. 


Appendix F, Implementation-Dependent Characteristics 


39 




Section 7 


Unchecked Conversions 


Uncbecked conversions are allowed between any types provided the instantiation of 
UNCHECKED^CONVERSION is legal Ada. It is Uie programmer's responsibility to 
determine if the desired effect is achieved. 

If the target type has a smaller size than the source type then the target is made of the 
least significant bits of the source. 


40 


Appendix F. Version J 



Section 8 


Input'Output Packages 


In this pan of the Appendix the tmplemenution-specific aspects of the input-output 
system are described. 


8.1 Introduction 

In Ada. input-output operations (lO) are considered to be performed on objects of a 
certain file type rather than being performed direaly on cnemal files. An external file is 
anything external to the program that can produce a value to be read or receive a value lo 
be written. Values transferred for a given file must be all of one type. 

Generally, in Ada documentation, the term file refers to an objea of a certain file type, 
whereas a physical manifesution is known as an eaemaifile. An external file is 
charaaeriaed by 

■ Its name, which is a string defining a legal path name under the current version of 
the operating system. 

■ Its form, which gives implemenution-dependent information on file charaaerisiics. 

Both the name and the form appear explicitly as parameters of the Ada CREATE and 
OPEN procedures. Though a file is an object of a certain file type, ultimately the object 
has to correspond to an external file. Both CREATE and OPEN associate a NAME of an 
external file (of a certain FORM) with a program file object. 

Ada 10 operations are provided by means of sundard packages [14j. 

SEQUENTIAL^IO A generic package for sequential files of a single element 
type. 

DIRECr_IO A generic package for direa (random) access files. 

TEXT_IO A generic package for human readable (text, ASCII) files. 


Appendix F, Implementation-Dependeni Charaaerisnes 


41 


IO_EXC£PnONS A package which defines the exceptions needed by the 
above three packages. 

The generic package LOW_LEVEL_IO is not implemented in this version. 

The upper bound for index values in DIRECT_IO and for line, column and page numbers 
in TEXTJO is given by 

COUNTLAST= 2-31 -1 

The upper bound for field widths in TEXT^IO is given by 
FTELD’LAST = 255 

8.2 The FORM Parameter 

The FORM parameter of both the CREATE and OPEN procedures in Ada specifies the 
charaaeristics of the external file involved. 

The CREATE procedure establishes a new external file, of a given NAME and FORM, and 
associates it with a specified program file object. The external file is aeated (and the file 
objea set) with a specified (or default) file mode. If the external file already exists, the 
file will be erased. The exception USE_ERROR is raised if the file mode is IN_F1L£. 


Example: 

CREATE (F, OUT.nLE, 'MY^FILE*. 

FORM *> 

•WORLD => READ. OWNER »> READ.WRnE’); 

The OPEN procedure associates an existing external file, of a given NAME and FORM, 
with a specified program file objea. The procedure also sets the current file mode. If 
there is an inadmissible change of mode, then the Ada exception USE^ERROR is raised. 

The FORM parameter is a string, formed from a list of attributes, with attributes 
separated by commas (,). The string is not case sensitive (so that, for example, HERE and 
here are treated alike). FORM attributes are distina from Ada attributes. The attributes 
specify; 


42 


Appendix F, yenion 4 




■ File protection 

■ FQe sharing 

■ File struaure 

■ BufTering 

■ Appending 

■ Bloclung 

• Terminal input 

The general form of each attribute is a keyword followed by = > and then a qualifier. 
The anow and qualifier may sometimes be omitted. The format for an attribute sjiecificr 
is thus either of 

KEYWORD 

KEYWORD «> QUALIFIER 
We will discuss each attribute in turn. 

File Protection 

These attributes are only meaningful for a call to the CREATE procedure. 

File proteaion involves two independent classifications. The first classification is related 
to who may access the file and is specified by the keywords: 

OWNER Only the owner of the direaory may access this file. 

CROUP Only the members of a predefined group of users may access 

this file. 

WORLD Any user may access this file. 

For each type of user who may access a file there are various access rights, and this form.'; 
the basis for the second classification. In general, there are four types of access right, 
specified by the qualifien: 


43 


Apperuiu F, Implemenianon-Dfptndent Charaaerisnes 



READ 


The user may read from the exremal file. 

WRITE The user may write to the external file. 

EXECUTE The user may execute programs stored in the external file. 

NONE The user has no access rights to the external file. (This access 

right negates any prior privileges.) 

More than one access right may be relevant for a particular file, in which case the 
qualifiers are linked with underscores (_ )• 

For example, suppose that the WORLD may execute a program in an external file, but 
only the OWNER may modify the file. 

WORLD 

EXECUTE. 

OWNER => 

READ^WRITE .EXECUTE, 

Repetition of the same qualifier within the attributes is illegal: 

WORLD »> 

EXECUTE.EXECUTE, - NOT legal 
but repetition of the entire attribute is allowed: 

WORLD => 

EXECUTE, 

WORLD »> 

EXECUTE, - Legal 


8,2.2 File Sharing 

An external file can be shared, which means associated simultaneously with several 
logical file objects created by the OPEN and CREATE procedures. 

The file sharing attribute may restrict or suppress this capability by specifying one of the 
following access modes; 


4 ^ 


Appendiz F, Version -i 



NOT_SHARED 

Exclusive access - do other logical file may be associated with 
the external file 

SHARED => READERS 

Only logical files opened with mode IN are allowed 

SHARED »> SINGLE.WRTTER 

O^y logical files opened with mode IN and at most one with 
mode INOUT or OUT are allowed 

SHARED »> ANY 

No rcstriaion 

The exception USE_ERROR is raised if, for an cnemal file already associated with an 
Ada file objea: 

- a further OPEN or CREATE specifies a file sharing attribute different from the 
cunent one 

- a further OPEN, CREATE or RESET violates the conditions imposed by the current 
file sharing attribute. 

The resirirtions imposed by the file sharing attribute disappear when the last logical file 
objea linked to the external file is closed. 

The file sharing attribute provides control over multiple accesses within the program to a 
given external file. 

This control does not extend to the whole system. 

The default value for the file sharing attribute is SHARED => ANY 


8.23 File Structure 
Text Files 

There is no FORM parameter to define the struaure of text files. 

A text file consists of a sequence of bytes holding the ASCII codes of charaaers. 

The representation of Ada-ierminators depends on the file’s mode (IN or OUT) and 
whether it is associated with a terminal device or a mass-storage file: 


Appendix F. Implemeniarion-Dependenx Characteristics 


45 



Mass-storage files 


end of line: ASCILLF 

end of page: ASCnXF aSCILFF 

end of file: ASClldS aSOI-EOT 

• Terminal device with mode IN 

end of line: ASCnXF 

end of page: ASCIIiF ASaLFF 

end of file: aSCD-LF ASCILFF 

- Terminal device with mode OUT 

end of line: ASCnXF 
end of page: ASCII.FF 
end of file: ASCn.EOT 


Binary Files 

Two FORM attributes. REC0RD.S12E and RECORD.UNTT. conuol the stniaure of 
binary files. 

A binary file can be viewed as a sequence (sequential access) or a set (diren access) of 
consecutive RECORDS. 

The struaure of such a record is: 

[ HEADER ] OBJECT ( UNUSED_PaRT] 

and it is formed from up to three items: 

- an OBJECT with the e»ct binary representation of the Ada objea in the executable 
program, possibly including an objea descriptor 

- a HEADER consisting of rwo fields (each of 32 bits): 

- the length of the objea in bytes 

- the length of the descriptor in bytes 

- an UNUSED^PART of variable size to permit full control of the record’s size 


46 


Appendix F, Venion -i 



Tbe HEADER is implemented onJy if tbe aaual parameter of the instantiation of the lO 
package is unconstrained. 

The file structure attributes uke the form: 

RECORD_SIZE * > si 2 e_jn_bytes 

RECORD_UNIT * > sizejn_bytes 

Their meaning depends on the object’s type (constrained or not) and the file access mode 
(sequential or direa access): 

a) If the objea’s type is constrained: 

• The RECORD_UNTr attribute is illegal 

• If the REC0RD_S1ZE attribute is omitted, no UNUSED.PaRT will be 
implemented: the default RECORD.SIZE is the objea’s size 

• If present, the RECORD_SIZE attribute must specify a record size greater than 
or equal to the objea's size, otherwise the crcepiion USE^ERROR will be 
raised 

b) If the objea’s type is unconstrained and the file access mode is direa: 

• The RECORDJJNTT attribute is illegal 

' The RECORD_SIZE attribute has no default value, and if it is not specified, a 
USE^ERROR will be raised 

- An attempt to input or output an objea larger than the given RECORD^SIZE 
will raise the exception DATA_ERROR 

c) If the objea’s type is unconstrained and the file access mode is sequential: 

> The RECORD.SIZE attribute is illegal 

- The default value of the RECORD^UNTT attribute is 1 (byte) 

• The record size will be the smallest multiple of the specified (or default) 
RECORD_UNIT that holds the objea and its length. This is the only case 
where records of a file may have different sizes. 


Appendix F, Implementation-Dependent Characteristics 


47 



8^.4 Buflering 

The buffer size can be specified by the attribute 
BUFFER^SIZE *> si 2 e_in_bytes 

The default value for BUFFER_SIZE is 0 (which means no buffering) for terminal 
devices: it is 1 block for disk files. 


8^.5 Appending 

Only to be used with the procedure OPEN, the format of this attribute is simply 
APPEND 

and it means that any output will be placed at the end of the named external file. 

In normal circumstances, when an external file is opened, an index is set which points to 
the beginning of the file. If the APPEND attribute ts present for a sequential or for a text 
file, then dau transfer will commence at the end of the file. For a direa access file, the 
value of the index is set to one more than the number of records in the external file. 

This attribute is not applicable to terminal devices. 

8.2.6 Blocking 

This attribute has two alternative forms: 

BLOCKING, 


or 


NON.BLOCKING, 

This attribute specifies the 10 system behavior desired at any moment that a request for 
data transfer cannot be fulfilled. The stoppage may be due, for example, to the 
unavailability of data, or to the unavailability of the external file device. 


48 


Appendix F, Version 4 








NON_BLOCKINC 

If Uiis attribute is set, then the task that ordered the data transfer is suspended - 
meaning that other tasks can execute. The suspended task is kept in a ready' state, 
together with other tasks in a ready state at the same priority level (that is, it is 
re^eduled). 

When the suspended task is next scheduled, the data transfer request is reaaivated. 
If ready, the transfer is activated, otherwise the rescheduling is repeated. Control 
returns to the user program after completion of the data transfer. 


BLOCKISC 

In this case the task waits until the data transfer is complete, and all other tasks are 
suspended (or ‘blocked’). The system is busy waiting. 

The default for this attribute depends on the actual program: it is BLOCKING for 
programs without task declarations and NON.BLOCHNG for a program containing 
tasks. 


8 J.7 Terminal Input 

This attribute takes one of two alternative forms: 

TERMINAL^INPUT ■ > LINES, 

TERMINAL_INPUT » > CHARACTERS, 

Terminal input is normally processed in units of a line at a time, where a line is delimited 
by a special character. A process attempting to read from the terminal as an external file 
will be suspended until a complete line has been typed. At that time, the outstanding 
read call (and possibly also later calls) will be satisfied. 

The first option specifies line-at-a-time data transfer, which is the default case. 

The second option means that data transfer is charaaer by character, and so a complete 
line does not have to be entered before the read request can be satisfied. For this option 
the BUFFER.SIZE must be zero. 

The TERMINaL_ 1NPUT attribute is only applicable to terminal devices. 


Appendix F. Jmplememation-Dependent Characteristics 


49 




Section 9 


Characteristics of Numeric T^es 
9.1 Integer T^pes 

The ranges of values for integer types declared in package STANDARD are as follows: 
SHO«T_SHO«TJIlTEC£« -128 .. 127 -- 2~7 ■ 1 

SMMT^IWTECER -32768 .. 32767 -- 2«»15 - 1 

I«TE0EB -2167483668 .. 2167683667 - 2**31 - 1 

For the packages DIRECTJO and TEXTJO, the range of values for types COUNT and 
POSrnVE.COUNT are as follows: 

CajNT 0 2167683667 -- 2**31 - 1 

POSITIVE.COIWT 1 .. 2167683667 -- 2**31 • 1 

For the package TEXT.IO, the range of values for the type FIELD is as follows: 

FtELO 0 .. 255 -- 2**8 - 1 


50 


Appendix F, yenion 






9 J Floating Point Type Attributes 

FLOAT 

LONG_FLa*.T 

DIGITS 

6 

15 

MANTISSA 

21 

51 

EMAX 

SA 

204 

EPSILON 

9.5367AE-07 

8.8617BE-16 

LARGE 

1.9342flE-25 

2.57110E-61 

SAFE.EMAX 

125 

1021 

SAFE,SMALL 

1.17549E-58 

2.2250rE-308 

SAFE_LARG£ 

A.25353E-37 

2.24712E-307 

FIRST 

-3.A0282£-3« 

-1.79769E*30a 

UST 

3.A02B2E*38 

1,79769E*306 

MACH I HE .RAO IX 

2 

2 

MACHIHE.EMAX 

126 

1024 

MACHIHE.EMIN 

-125 

-1021 

MACMIHE.ROJNOS 

true 

true 

MACNIME.OVERFLOUS 

r«i»« 

felee 

SIZE 

32 

&4 


Appendix F, Implementation-Dependent Characteristics 


SI 





93 Attributes of Type DURATION 


OUKATION'DELTA 
DURATION'SMALL 
DURATION'FIRST 
DURATION'UST 
DURATION'LARCE 


2.0 •• 

2.0 (-U) 

-131^072.0 
131.072.0 

tmm •> DURATION'UST 


52 


Appendix F, Verzion J 





Section 10 


Other Implementation-Dependent Characteristics 


10.1 Use of the Floating-Point Coprocessor 

Floating point coprocessor instruaions are used in programs that perform anihmctic on 
floating point values in some fixed point operations and when the FLOAT_IO or 
FIXED^IO packages of TEXTJO are used. The mantissa of a fixed point value may be 
obtained through a conversion to an appropriate integer type. This conversion docs not 
use floating point operations. On 386^ the Unix kernel emulates floating point 
instructions in softwre, if no coprocessor ts present On Sun 386i, a coprocessor is 
always present. On a Xenix, a coprocessor is required to execute floating point 
instructions. 

10.2 Characteristics of the Heap 

All objects created by allocaion go into the heap. Also, portions of the Runnme Execu¬ 
tive representation of task obieos, including the task stacks, arc allocated m the heap. 

UNCHECKED_DEALLOCAnON is implemented for ail Ada access objects except access 
objects to tasks. Use of UNCHECK£D_DEALL0CAT10N on a task object will lead to 
unpredictable results. 

All objects whose visibility is linked to a subprogram, task body, or block have their 
storage reclaimed at exit, whether the ant is normal or due to an exception. E/Tcctjvelv 
pragma CONTROLLED is auiomaiicaiiy applied to all access types. Moreover, ail 
compiler temporaries on the heap (generated by such operations as funaion calls 
returning unconstrained arrays, or many concatenations) allocated in a scope are 
deallocated upon leaving the scope. 

Note that the programmer may force heap reclamation of temporaries assoaated with 
any sutemcnis by enclosing the suicment in a begin _ end block. This is espeaally 
useful when complex concatenations or other heap-intensive operations arc performed 
in loops, and can reduce or eliminate STORaGE_ERRORs that might otherwise occur. 


Appendix F, Implementation-Dependent Characteristics 


53 




The maxunum size of the heap is limited only by available memory. This includes the 
amount of physical memory (RaM) and the amount of vinual memory (hard disk swap 
space). 

103 Characteristics of Tasks 

The default task stack size is IK bytes (32K bytes for the environment task), but by usin 
the Binder option STACK.TASK the size for all task sucks in a program may be set to a 
size from IK bytes to 64K bytes. 

Normal priority rules are followed for preemption, where PRIORITY values are in the 
range 1.. 10. A task with undefined priority (no pragma PRIORITY) is considered to be 
lower than priority 1. 

The minimum limeable delav is I.O seconds. This is the finest resolution provided bv 
UNIX. 

The maximum number of active tasks is restricted only by memory usage. 

The accepter of a rendezvous executes the accept body code in its own suck. 
Rendezvous with an empty accept body (for synchronization) docs not cause a context 
switch. 

The main program waits for completion of all tasks dependent upon library packages 
before terminating. 

Abnormal completion of an aborted task ukes place immcdiatch, except when the ab¬ 
normal task is the caller of an entry that is engaged in a rendezvous, or if it is in the 
process of aaivating some tasks. Any such task becomes abnormally completed as soon 
as the suie in question is exited. 

The message 

GtOBAL BLOCKING SITUATION DETECTED 

is printed to STANDaRD_OUT?LT when the Runtime Executive detects that no further 
progress is possible for any task in the program. The execution of the program is then 
abandoned. 


54 


Appendix F, Version 4 





10.4 Definition of a Main Subprogram 

A libraiy unit can be used as a main subprogram if and only if it is a procedure that is not 
generic and that has no forma] parameters. 

The Alsys UNIX Ada Compiler imposes no additional ordering constraints on 
compilations beyond those required by the language. 


Appendix F, Implementarion-Dependeni Characteristia 


55 





Section 11 


Limitations 


11.1 Compiler Limitations 

■ The maxiinum identifier length is 255 charaaers. 

■ The maximum line length is 255 charaaers. 

■ The maximum number of unique identifiers per compilation unit is 2500. 

■ The maximum number of compilation units in a library is 1000. 

• The maximum number of Ada libraries in a family is 15. 


11.2 Hardware Related Limitations 

a The maximum amount of data in the heap is limited only by available memory. 

a If an unconstrained record type can exceed 4096 bytes, the type is not permitted 
(unless constrained) as the element type in the definition of an array or record type 

a A dynamic objea bigger than 4096 bytes will be indirectly allocated. Refer to 
ALLOCATION parameter in the COMPILE command. (Section 4.2 of the User 's 
Guide.) 


56 


Appendix F, Version V 





INDEX 


Abnonnal completion 54 
Aborted task 54 
Access types 22 
Allocators 53 

Application Developer’s Guide 3 
Array gaps 24 
Array objects 37 
Array subtype 6 

Array subtype and objea size 27 
Array type 6 

ARRAY^DESCRIPTOR 34 
Attribute 6 
ASSEMBLER 3 
ASSIGN^TO_ ADDRESS 11 
Attributes of t)T>e DURATION 52 

Basic record struaure 2B 
Binder 54 

C 3 

Charaaerlstics of tasks 54 
CoIIeaionsize 22 
Colleaions 22 
Compiler limitations 56 

maximum identifier length 56 
maximum line length 56 
maximum number of Ada libraries 
56 

maximum number of compilation 
units 56 

maximum number of unique 
identifiers 56 
COUNT 50 

DIGITS 51 
DIRECT lO 50 
DURATTON’DELTA 52 


DURATION'FIRST 52 
DURATIONTARGE 52 
DURATlObTLAST 52 
DURATIONTSMALL 52 

E*EXCEPnON_CODE 6 
EMAX 51 

Empty accept body 54 
Enumeration literal encoding 13 
Enumeration subtype size 14 
Enumeration types 13 
EPSILON 51 ' 

EXCEPnON_CODE 
Attribute 6 

FETCH FROM ADDRESS 10 
FIELD 50 
FIRST 51 

Fixed point type represenution 18 
Fixed point type size 20 
Foating point coprocessor 53 
Foating point type attributes 51 
Foating point type represenution 17 
Foating point type size 18 

GLOBAL BLOCKING SITUATION 
DETECTED 54 

Hardware limiuuoas 

maximum dau in the heap 56 
maximum size of a single array or 
record objcn 56 

Heap 53 

Implemenution generated names 37 
Implicit component 34,35 
Implicit components 32 


Index 


57 







INDENT 5 

Indirea record componeots 28 
Integer type and objea size IS 
Integer type represenution 15 
Integer types 50 
INTERFACE 3,4 
INTERFACE NAME 3.4 
IS_ARRAY 
Attribute 6 

LARGE 51 
LAST 51 

Layout of a record 28 
Libraiyunit 55 
Limitations 56 

MACHINE EMAX 51 
MACHINE EMIN 51 
MACHINE MANTISSA 51 
MACHINE.OVERFLOWS 51 
MACHINE RADIX 51 
MACHINE^ROUNDS 51 
Main program 54 
Main subprogram 55 
MANTISSA 51 
Maximum dau in the heap 56 
Maximum identifier length 56 
Maximum line iength 56 
Maximum number of Ada libraries 56 
Maximum number of compilation uniu 
56 

Maximum number of unique identifiers 
56 

Maximum size of a single array or 
record objea 56 

Minimum timeable delay 54 


Number of aaive tasks 54 

Ordering of compilation units 55 

P’ARRAY DESCRIPTOR 6 
P-IS ARRAY 6 
P’RECORD DESCRIPTOR 6 
PACK 5 

Parameter passing 2 

posrnvE_couNT so 
Pragma IMPROVE 5,35 
Pragma INDENT 5 
Pragma INTERFACE 3,4 
Pragma INTERFACE_NAME 4 
Pragma PACK 5,23,24,28 
Pragma PRIORITY 5,54 
Pragma SUPPRESS 5 
Predefined packages 37 
PRIORITY 5,54 

Record objects 37 
RECORD_DESCRIPTOR 35 
Attribute 6 

RECORD_SIZE 32,35 
Rendezvous 54 
Representation clauses 12 
Runtime Executive 2,4,53,54 

SAFE EMAX 51 
SAFE LARGE 51 
SAFE'sMALL 51 
SIZE 51 

Size of record types 36 
SPACE 35 

STANDARD.OUTPLTr 54 
Storage reclamation at exit 53 
S'lORAGE^SIZE 22 


58 


Appendix F, Version 4 




SUPPRESS 5 
SYSTEM 5 

Task activation 22 
Task stack size 22,54 
Task stacks 53 
Task types 22 
Tasks 

charaaeristics of 54 
TEXT lO 50 
TIME"35 

Unchecked conversions 40 
UNCHECKED DEALLOCATION 
5? 

UNDC Linker 4 

Variant part 33 
VARIANT_INDEX 33,34,35 


fnda 






