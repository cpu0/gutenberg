AD-A223 336 


"W, FILE COPY . L 

REPORT DOCUMENTATION PAGE 


lot Mi sakeMn « MomMlon h MMitf 10 MMa 1 taw BW lapann. taMka lartOTta 

MMoiJ^oiodMiii—0M.MdriiOoiilwgtioflolMBeKd W iiw rt oi. >oiia >w iii » MiiooM r MMi> M <w>oM>nM«f»M» 
^w M i gH o Mi bwMn. ID MaNt nw I li in iigoii < wMoi. D O ww i tat Mom Mhir cEotJm mq Ropom. 1>H jSti w 
■loOIII»3>MwiMlwior<0niUul«nn «Hlil.OklaiotmrM»w«ormuOgi(.»»ih>io>w.OCaB»(a. 


; OloOIIMaiM wi M to ioriO n i U ulM n n ««oM.Oklaiot m rM»w 0 0tXtuOM<.WMMi^Mvl 
1. AGENCY USE CM.Y(LM»«a^ i 2. REPORT DATE 



S. SEPORT TYPE A» DATES COVEBED 

Final 27 Oct. 1989 to 27 Oct. 1990 


4.TniEAM)SUBTniE Ada Compiler Validation Summary Report: ddc 
INTERNATIONAL A/S, DACS for Sun-3-!i Lynwood/LynX, Version 4.4 
(1.1), SUN-3/50 Workstation (Host) to Lynwood j430 (Target), 
891027S1.10184 

t.AUTH0n(S) 

National Institute of Standards and Technology 
Gaithersburg, MD 
USA _ 

7. PERFOMymC OB6AMZATON NAlyE(9 AND AOORESS(ES) 

National Institute of Standards and Technology 
National Computer Systems Laboratory 
Bldg. 255, Rm. A266 
Gaithersburg, MD 20899 

Ji2A _ 

B. SPOMSORHQ^UOHnorUHa AGENCY NAI«(S) AND AOORESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Washington, D.C. 20301-3081 


11. SUPPIEICNTARY NOTES 


12a. OBTRSUriON^AVALABLtTY STATEICNT 

Approved for public release; distribution unlimited. 



B. PERFORMMG ORGANIZATION 
REPORT NUMBER 


10 . sponsorbjgmonttorba: agency 

REPORT NUMBER 


iZB.DtSTRBUnONCOOE 


IS. ABSTRACT (iCuimuiiiOO maidil 

DDC INTERNATIONAL A/S, DACS for Sun-3 -^Lynwood/LynX, Version 4.4 (1.1), Gaithersburg 
MD, SUN-3/50 Workstation under SunOS UNIX, Version 4.2, Release 4.0_EXPORT (Host) to 
Lynwood j430 under LynX, Version 1.4F (Target), ACVC 1.10. * 


" 


M.SWJECTTERMS Ada programming language, Ada Compiler Validation 
Summary Report, Ada Compiler Validation Capability, Validation 
Testing, Ada Validation Office, Ada Validation Facility, ANSI/MIL- 
STD-1815A. Ada Joint Program Office 

UNCLA^FIED UN8t?SI?¥¥ED UNCLASSIFIED 


OP ABSTRACT 

UNCLASSIFIED 


IB. NUMBER OF PAGES 


IB. PRICE OOOE 


20. UMITATON OF ABSTRACT 


N8N 7B4M1-28DB600 


25 11 


















AVF Control Number: NIST89DDC580_2_1.10 
DATE COMPLETED BEFORE ON-SITE: 10-02-89 
DATE COMPLETED AFTER ON-SITE: 12-04-89 


Ada Compiler Validation Summary Report: 

Compiler Name: DACS for Sun-3 -> Lynwood/LynX, Version 4.4 (1.1) 
Certificate Number: 891027S1.10184 

Host: SUN-3/50 Workstation under SunOS UNIX, Version 4.2, 

Release 4.0_EXPORT 

Target: Lynwood j430 under LynX, Version 1.4F 

Testing Completed October 27, 1989 Using ACVC 1.10 



Ada Validation Fac 
Dr. David K. Jeffersoni \) 
Chief, Information Systems 
Engineering Division 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


approved. 



Ada Validation Facility 
Mr. L. Arnold Jol-wison 
Manager, Software Standards 
Validation Group 
Engineering Division 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 



Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 













AVF Cbntrol Number: NIST89DDC580_2_1.10 
DATE VSR OCMPIETED BEFORE C»I“SITE: 10-02-89 
DATE VSR OCMPUJEED AFTER CN-SITE: 12-04-89 
EATE VSR MODIFIED PER AVO OCMMENIS: 12-15-89 
DAIE VSR MODIFIED PER AVO CCMMENTS; 04-30-90 


Ada OCMPHER 
VALIDATION StMlARir REPORT: 

Certificate Number: 891027S1.10184 
IXX: INrERNATICa®L A/S 

DACS for Sun-3 -> Lynwood/LynX^ Version 4.4 (1.1) 
SUN-3/50 workstation Host and Lynwood j430 Target 


CcDipletion of On-Site Testing: 
27 October 1989 


Pr^ared By: 

Software Standards Validation Groi^) 
National Ccmputer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Rocsn A266 
Gaithersburg, Meuyland 20899 


Prepared For: 

Ada Joint Program Office 
Uhited States Department of Defense 
Washington DC 20301-3081 



TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1-2 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.1-2 

1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-3 

1.5 ACVC TEST CLASSES.1-4 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED . 2-1 

2.2 IMPLEMENTATION CHARACTERISTICS . 2-2 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.3-1 

3.2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 WITHDRAWN TESTS.3-2 

3.5 INAPPLICABLE TESTS . . . . !.3-2 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . .3-6 

3.7 ADDITIONAL TESTING INFORMATION . 3-7 

3.7.1 Prevalidacion.3-7 

3.7.2 Test Method.3-7 

3.7.3 Test Site.3-8 

APPENDIX A CONFORMANCE STATEMENT 

APPENDIX B APPENDIX F' OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 


APPENDIX E 


COMPILER OPTIONS AS SUPPLIED BY 
DDC INTERNATIONAL A/S 



















CHAPTER 1 


INTRODUCTION 


/ ' > 

This Validation Summary Report (VSR) describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results of testing this compiler using the Ada Compiler 
Validation Capability ^(ACVC). " An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that 
is not in the Standard. 

Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between 
implementations. The Ada Standard permits some implementation 
dependencies--for example, the maximum length of identifiers or the 
maximum values of integer types. Other differences between compilers 
result from the characteristics of particular operating systems, 
hardware, or implementation strategies. All the dependencies observed 
during the process of testing this compiler are given in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. The purpose of validating is to ensure 
conformity of the compiler to the Ada Standard by testing that the 
compiler properly implements legal language constructs and chat it 
identifies and rejects illegal language constructs. The testing also 
identifies behavior that is implementation dependent, but is permitted 
by the Ada Standard. Six classes of tests are used. These tests are 
designed to perform checks at compile time, at link time, and during 
execution. 



1-1 






1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 


This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 

. To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

. To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

. To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by the AVF according to 
procedures established by the Ada Joint Program Office and administered 
by the Ada Validation Organization (AVO). On-site testing was completed 
27 October 1989 at Lyngby, Denmark. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO 
may make full and free public disclosure of this report. In the United 
States, this is provided in accordance with the "Freedom of Information 
Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do 
not represent or warrant that all statements set forth in this report 
are accurate and complete, or that the subject compiler has no 
nonconformities to the Ada Standard other than those presented. Copies 
of this report are available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 


Software Standards Validation Group 
National Computer Systems Laboratory 
National Institue of Standards and Technology 
Building 225, Room A266 
Gaithersburg, .Maryland 20899 


1-2 








Questions regarding this report or the validation test results should be 

directed to the AVF listed above or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.3 REFERENCES 

1. Reference Manual for the Ada Programming Language, 
ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide, December 1986. 

1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of .■^da 

programs that tests the conformity of an Ada compiler to 
the Ada programming language. 


Ada Commentary An Ada Commentary contains all information relevant 

to the Commentary point addressed by a comment on 
the Ada Standard. These comments are given a 
unique identification number having the form 
Al-ddddd. 


Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 
Applicant The agency requesting validation. 


AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines. 


AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and 


1-3 











technical support for Ada validations to ensure 
consistent practices. 

Compiler A processor for the Ada language. In the context of 

this report, a compiler is any language processor, 
including cross-compilers, translators, and 
interpreters. 

Failed test An ACVC test for which the compiler generates a result 
that demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 


Inapplicable An ACVC test that uses features of the language that a 
test compiler is not required to support or may legitimately 

support in a way other than the one expected by the 
test. 

Passed test An ACVC test for which a compiler generates the expected 
result. 


Target The computer which executes the code generated by the 

compiler. 

Test A program that checks a compiler's conformity regarding 

a particular feature or a combination of features to the 
Ada Standard. In the context of this report, the term 
is used to designate a single test, which may comprise 
one or more files. 


Withdrawn An ACVC test found to be incorrect and not used to check 

test conformity to the Ada Standard. A test may be 
incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains illegal or 
erroneous use of the language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name 
identifies the class to which it belongs. Class A, C, D, and E tests 
are executable, and special program units are used to report their 
results during execution. Class B tests are expected to produce 
compilation errors. Class L tests are expected to produce errors 
because of the way in which a program library is ured at link time. 

Class A tests ensure the successful compilation and execution of legal 
Ada programs with certain language constructs which cannot be verified 
at run time. There are no explicit program components in a Class A test 


1-4 






to check semantics. For example, a Class A test checks that reserved 
words of another language (other than those already reserved in the Ada 
language) are not treated as reserved words by an Ada compiler. A Class 
A test is passed if no errors are detected at compile time and the 
program executes to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 

Class B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that every 
syntax or semantic error in the test is detected. A Class B test is 
passed if every illegal construct that it contains is detected by the 
compiler. 

Class C tests check the run time system to ensure that legal Ada 
programs can be correctly compiled and executed. Each Class C test is 
self-checking and produces a PASSED, FAILED, or NOT APPLICABLE message 
indicating the result when it is executed. 

Class D tests check the compilation and execution capacities of a 
compiler. Since there are no capacity requirements placed on a compiler 
by the Ada Standard for some parameters--for example, the number of 
identifiers permitted in a compilation or the number of units in a 
library--a compiler may refuse to compile a Class D test and still be a 
conforming compiler. Therefore, if a Class D test fails to compile 
because the capacity of the compiler is exceeded, the test is classified 
as inapplicable. If a Class D test compiles successfully, it is 
self-checking and produces a PASSED or FAILED message during execution. 


Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the 
Ada Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed bv a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is 
rejected by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is 
attempted. A Class L test passes if it is rejected at link time--that 
is, ah attempt to execute the main program must generate an error 
message before any declarations in the main program or any units 
referenced by the main program are elaborated. In some cases, an 
implementation may legitimately detect errors during compilation of the 
test. 

Two library units, the package REPORT and the procedure CHECK_FILE, 
support the self-checking features of the executable tests. The package 
REPORT provides the mechanism by which executable tests report PASSED, 


i.-0 






FAILED, or NOT APPLICABLE results. It also provides a set of identity 
functions used to defeat some compiler optimizations allowed by the .-^da 
Standard that would circumvent a test objective. The procedure 
CHECK_FILE is used to check the contents of text files written by some 
of the Class C tests for Chapter 14 of the Ada Standard. The operation 
of REPORT and CHECK_FILE is checked by a set of executable tests. These 
tests produce messages chat are examined to verify that the units are 
operating correctly. If these units are not operating correctly, then 
Che validation is not attempted. 

The text of each test in the ACVC follows conventions chat are intended 
to ensure chat the tests are reasonably portable without modification. 
For example, the tests make use of only the basic set of 55 characters, 
contain lines with a maximum length of 72 characters, use small numeric 
values, and place features chat may not be supported by all 
implementations in separate tests. However, some tests contain values 
chat require Che test to be customized according to 
implementation-specific values--for example, an illegal file name. A 
list of the values used for this validation is provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable 
CO the implementation. The applicability of a test to an 
implementation is considered each time the implementation is validated. 

A test chat is inapplicable for one validation is not necessarily 
inapplicable for a subsequent validation. Any test that was determined 
to contain an illegal language construct or an erroneous language 
construct is withdrawn from the ACVC and, therefore, is not used in 
testing a compiler. The tests withdrawn at the time of this vali'^ation 
are given in Appendix D. 


1-6 






CHAPTER 2 


CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under 
the following configuration: 

Compiler: DACS for Sun-3 -> Lynwood/LynX, Version 4.4 

( 1 . 1 ) 

ACVC Version: 1.10 

Certificate Number: 891027S1.10184 

Host Computer: 

Machine: SUN-3/50 Workstation 

Operating System: SunOS UNIX, Version 4.2, Release 

4.0_EXPORT 

Memory Size: 8 MBytes 

Target Computer: 

Machine: Lynwood j430 

Operating System: LynX, Version 1.4F 
Memory Size: 8 MBytes 

Communications Network: Ethernet between Lynwood j430 and Sun- 

3/50 WORKSTATION: Ethernet between Sun- 
3/50 WORKSTATION and the VAX-8350 (using 
DNICP net software utility). 


2-1 




2.2 IMPLEMENTATION CHARACTERISTICS 


One of the purposes of validating compilers is to determine the behavior 
of a compiler in those areas of the Ada Standard that permit 
implementations to differ. Class D and E tests specifically check for 
such implementation differences. However, tests in other classes also 
characterize an implementation. The tests demonstrate the following 
characteristics; 


a. Capacities. 

(1) The compiler correctly processes a compilation containing 
723 variables in the same declarative part. (See test 
D29002K.) 

(2) The compiler correctly processes tests containing loop 
statements nested to 65 levels. (See tests D55A03A..H (8 
tests).) 

(3) The compiler accepts tests containing block statements 
nested to 65 levels. (See test D56001B.) 

(4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tests D64005E..G (3 tests).) 


b. Predefined types. 

(1) This implementation supports the additional predefined 
types SHORT_INTEGER and LONG_FLOAT in the package 
STANDARD. (See tests B86001T..Z (7 tests).) 


c. Expression evaluation. 

The order in which expressions are evaluated and the time at 
which constraints are checked are not defined by the language. 
While the ACVC tests do not specifically attempt to determine 
the order of evaluation of expressions, test results indicate 
the following: 

(1) All of the default initialization expressions for record 
components are evaluated before any value is checked for 
membership in a component's subtype. (See test C32117.A.) 

(2) Assignments for subtypes are performed with the same 
precision as the base type. (See test C35712B.) 





(3) This implementation uses no extra bits for extra precision 
and uses all extra bits for extra range. (See test 
C35903A.) 

(4) NUMERIC_ERROR is raised when an integer literal operand in 
a comparison or membership test is outside the range of the 
base type. (See test C45232A.) 

(5) NUMERIC_ERROR is raised when a literal operand in a 
fixed-point comparison or membership test is outside the 
range of the base type. (See test C45252A.) 

(6) Underflow is gradual. (See tests C45524A..K (11 tests).) 


d. Rounding. 

The method by which values are rounded in type conversions is 
not defined by the language. While the ACVC tests do not 
specifically attempt to determine the method of rounding, the 
test results indicate the following: 

(1) The method used for rounding to integer is round to even. 
(See tests C46012A..K (11 tests).) 

(2) The method used for rounding to longest integer is round to 
even. (See tests C46012A..K (11 tests).) 

(3) The method used for rounding to integer in static universal 
real expressions is round away from zero. (See test 
C4A014A.) 


e. Array types. 

An implementation is allowed to raise NUMERIC_ERROR or 
CONSTRAINT_ERROR for an array having a 'LENGTH that exceeds 
STANDARD . INTEGER'LAST and/or SYSTEM . MAX_INT . For this 
implementation: 

(1) Declaration of an array type or subtype declaration with 
more than SYSTEM.MAX_INT components raises NUMERIC_ERROR. 
(See test C36003A.) 

(2) NUMERIC_ERROR is raised when 'LENGTH is applied to an array 
type with INTEGER'LAST + 2 components. (See test C36202A.") 


(3) NUMERIC_ERROR is raised when 'LENGTH is applied to an array 
type with SYSTEM. MAX_INT + 2 components. (See test 
C36:02B.) 


2-3 









(4) A packed BOOLEAN array having a 'LENGTH exceeding 
INTEGER'LAST raises NUMERIC_ERROR when declaring two packed 
Boolean arrays with INTEGER'LAST + 3 components. (See test 
C52103X.) 

(5) A packed two-dimensional BOOLEAN array with more than 
INTEGER'LAST components raises NUMERIC_ERROR when the array 
type is declared. (See test C52104Y.) 

(6) A null array with one dimension of length greater than 
INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAlNT_ERROR 
either when declared or assigned. Alternatively, an 
implementation may accept the declaration. However, 
lengths must match in array slice assignments. This 
implementation raises NUMERIC_ERROR when the array type is 
declared. (See test E52103Y.) 

(7) In assigning one-dimensional array types, the expression is 
evaluated in its entirety before CONSTRAINT_ERROR is raised 
when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

(8) In assigning two-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 


f. Discriminated types. 

(1) In assigning record types with discriminants, the 
expression is evaluated in its entirety before 
C0NSTRAINT_ERR0R is raised when checking whether the 
expression's subtype is compatible with the target's 
subtype. (See test C52013A.) 


g. Aggregates. 

(1) In the evaluation of a multi-dimensional aggregate, the 
test results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 

(2) In the evaluation of an aggregate containing subaggregates, 
not all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 

(3) CONSTRAINT_ERROR is raised before all choices are evaluated 
when a bound in a non-null range of a non-null aggregate 
does not belong to an index subtype. (See test E43211B.) 


2-4 









h. Pragmas. 


(1) The pragma INLINE is supported for functions or procedures. 
(See tests LA3004A..B (2 tests), EA3004C..D (2 tests), and 
CA3004E..F (2 tests).) 


i. Generics. 

(1) Generic specifications and bodies cannot be compiled in 

separate compilations. (See tests CA2009C, CA2009F, 

BC3204C. and BC3205D.) 

Generic package declarations and bodies can be compiled in 
separate compilations so long as no instantiations of those 
units precede the bodies. This compiler requires that a 
generic unit's body be compiled prior to instantiation, and 
so the unit containing the instantiations is rejected. 

(2) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 

(3) Generic subprogram declarations and bodies can be compiled 
in separate compilations. (See test CA1012A.) 

(4) Generic library subprogram specifications and bodies can be 
compiled in separate compilations. (See test CA1012A.) 

(5) Generic non-library subprogram bodies cannot be compiled in 
separate compilations from their stubs. (See test 
CA2009F.) 

(6) Generic package declarations and bodies cannot be compiled 
in separate compilations. (See tests CA2009C, BC3204C, and 
BC3205D.) 

(7) Generic library package specifications and bodies cannot be 
compiled in separate compilations. (See tests BC3204C and 
BC3205D.) 

(8) Generic non-library package bodies as subunits cannot be 
compiled in separate compilations. (See test CA2009C.) 

(9) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 


j. Input and output. 

(1) The package SEQUENTIAL_IO can be instantiated with 


2-5 










unconstrained array types and record types with 
discriminants without defaults. (See tests AE2101C, 
EE2201D and EE2201E.) 

(2) The package DIRECT_IO can be instantiated with 
unconstrained array types but only if the maximum element 
size supported for DIRECT_IO is 2_147_483_647 bits; 
otherwise, USE_ERROR is raised. (See tests AE2101H and 
EE2401D.) 

(3) The package DIRECT_IO can be instantiated with record types 
with discriminants without defaults. (See test EE2401G.) 

(4) USE_ERROR is raised when Mode IN_FILE is not supported for 

the' operation of CREATE for SEQUENTIAL_IO. (See test 

CE2102D.) 

(5) USE_ERROR is raised when Mode IN_FILE is not supported for 
the operation of CREATE for DIRECT_IO. (See test CE2102I.) 

(6) USE_ERROR is raised when Mode IN_FILE is not supported for 

the operation of CREATE for text files. (See test 

CE3102E.) 

(7) Modes IN_FILE and OUT_FILE are supported for text files. 
(See test" CE3102I..K). 

(8) RESET and DELETE operations are supported for 
SEQUENTIAL_IO. (See tests CE2102G and CE2102X.) 

(9) RESET and DELETE operations are supported for DIRECT_IO. 
(See tests CE2102K and CE2102Y.) 

(10) RESET and DELETE operations are supported for text files. 

(See tests CE3102F..G (2 tests), CE3104C, CE3110A, and 

CE3114A.) 

(11) Overwriting to a sequential file truncates to the last 

element written. (See test CE2208B.) 

(12) Temporary sequential files are given names and deleted when 
closed. (See test CE2108A.) 

(13) Temporary direct files are given names and deleted when 

closed. (See test CE2108C.) 

(14) Temporary text files are given names and deleted when 

closed. (See test CE3112A.) 

(15) More than one internal file can be associated with each 

external file for sequential files when writing or reading. 
(See tests CE2107A..E (5 tests), CE2102L, CE2110B, and 


2-6 












CE2111D.) 


(16) More than one internal file can be associated with each 
external file for direct files when writing or reading. 
(See tests CE2107F..H (3 tests), CE2110D and CE2111H.) 

(17) More than one internal file can be associated with each 
external file for text files when writing or reading. (See 
tests CE3111A, CE3111D..E (2 tests), and CE3114B.) 


2-7 







CHAPTER 3 


TEST INFORMATION 

3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 457 tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing except for 
201 executable tests that use floating-point precision exceeding that 
supported by the implementation. Modifications to the code, processing, 
or grading for 73 tests were required to successfully demonstrate the 
test objective. (See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 

A 

B 

TEST 

C 

CLASS 

D 


If 

TOTAL 

Passed 

123 

1129 

1875 

17 

26 

46 

3216 

Inapplicable 

6 

9 

440 

0 

2 

0 

457 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


3-1 







3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 


3 

4 

5 

_6 

7 

CHAPTER 
8 9 

10 

;i 

12 

13 

14 

TOTAL 

Passed 

195 

572 

543 

245 

172 

99 

160 

331 

135 

36 

250 

181 

297 

3216 

Inapplicable 

17 

77 

137 

3 

0 

0 

6 

1 

2 

0 

2 

188 

24 

457 

Wdrn 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 


The following 

44 tests 

were withdrawn from ACVC Version 1.10 at the time 

of this validation; 





A39005G 

B97102E 

C97116A 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A84M 

CD2A84N 

CD2B15C 

CD2D11B 

CD5007B 

CD50110 

CD7105A 

CD7203B 

CD7204B 

CD7205C 

CD7205D 

CE2107I 

CE3111C 

CE3301A 

CE3411B 

E28005C 

ED7004B 

ED7005C 

ED7005D 

ED7006C 

ED7006D 





See Appendix 

D for the 

reason i 

Chat each 

of these 

tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of 
features that a compiler is not required by the Ada Standard to support. 
Others may depend on the result of another test that is either 
inapplicable or withdrawn. The applicability of a test to an 
implementation is considered each time a validation is attempted. A 
test that is inapplicable for one validation attempt is not necessarily 
inapplicable for a subsequent attempt. For this validation attempt, 457 
tests were inapplicable for the reasons indicated: 


a. The following 201 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAX_DIGITS; 

C24113L..Y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 


3-2 







C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


b. 


C24113I..K (3 tests) are not applicable because the line length of 
the input file must not exceed 126 characters. 


c. 


C35508I, 
AD3015H, 
CD2A24C, 
CD3015E, 
CD4051G, 


C35508J, 

AD3015K, 

CD2A24D, 

CD3015G, 

CD4051D 


implementation d 


C35508M. C35508N. 
CD1C04B, CD1C04C, 
CD2A24G, CD2A24H, 
CD30151, CD3015J, 
(30 tests) are 


AD1C04D, 

CD1C04E, 

CD3015A, 

CD3015L, 


AD3015C, 

CD2A23C, 

CD3015B, 

CD4051A, 


AD3015F, 

CD2A23D, 

CD3015D, 

CD4051B, 


not applicable because this 


oes not support the specified change in 


representation for derived types. 


d. C35702A and B86001T are not applicable because this implementation 
supports no predefined type SHORT_FLOAT. 

e. A39005E, C87B62C, CD1009L, CD1C03F. CD2D11A, CD2D13A, EDzaSBA (7 
tests) are not applicable because 'SMALL clause is not supported. 


f. The following 16 tests are not applicable because this 
implementation does not support a predefined type LONG_INTEGER: 


C45231C 

C45504F 

C45632C 

CD7101F 


C45304C 

C45611C 

B52004D 


C45502C 

C45613C 

C55B07A 


C45503C C45504C 
C45614C C45631C 
B55B09C B86001W 


g. C45231D, CD7101G, and B86001X, are not applicable because this 

implementation does not support any predefined integer type with a 
name other than INTEGER, or SHORT_INTEGER. 

h. C45531M, C45531N, C45532M, and C45532N use fine 48 bit fixed point 
base types which are not supported by this compiler. 

i. C455310, C45531P, C455320, and C45532P use coarse 48 bit fixed 

point base types which are not supported by this compiler. 

j. C4A013B is not applicable because the evaluation of an expression 
involving 'MACHINE_RADIX applied to the most precise floating-point 
type would raise an exception; since the expression must be static, 
it is rejected at compile time. 

k. B86001Y is not applicable because this implementation supports no 
predefined fixed-point type other than DURATION. 

l. B86001Z is not applicable because this implementation supports 
predefined floating-point type with a name other than FLOAT, or 
LONG FLOAT. 


3-3 






m. C96005B is not applicable because there are no values of type 

DURATION'BASE that are outside the range of DURATION. 

n. CA2009C is not applicable because this implementation does not 

permit compilation of generic non-library package bodies in 
separate files from their specifications. 

o. CA2009F is not applicable because this implementation does not 

permit compilation of generic non-library subprogram bodies in 
separate files from their specifications. 

p. BC3204C and BC3205D are not applicable because this implementation 
does not permit compilation of generic library package bodies in 
separate files from their specifications. 

q. CD1009C, CD2A41A..B, CD2A41E, CD2A42A..J (14 tests) are not 

applicable because this implementation does not support the 'SIZE 
clause for floating-point types. 

r. CD2AjlC. CD2A32A..D, CD2A52G..J, CD2A53A..E, CD2A54A..D, CD2A54G..J 
(22 tests) are not applicable because this implementation does not 
support the 'SIZE clause for a fixed-point types. 

t. CD2A61A..F, CD2A61H..L, CD2A62A..C, CD2A64A..C, CD2A65A..C, 

CD2A71A..D, CD2A72A..D, CD2A74A..B, CD2A75A..B (32 tests) are not 
applicable because this implementation does not support the 'SIZE 
clause for an array type which does not imply compression of inter¬ 
component gaps. 

u. CD2A84B..I and CD2A84K..L (10 tests) are not applicable because 
this implementation does not support the 'SIZE clause for an access 
type. 

V. CD4041A is not applicable because this implementation does not 
support the alignment clauses for alignments other than 
SYSTEM.ST0RAGE_UNIT for record representation clauses. 

w. CD5003B..I (8 TESTS) CD5011A..I (9 tests) CD5011K..N (4 tests) 

CD5011Q..S (3 tests) CD5012A..J (10 tests) CD5012L..M (2 tests) 

CD5013A..I (9 tests) CD5013K..0 (5 tests) CD5013R..S (2 tests) 

CD5014A..O (15 tests) CD5014R..Z (9 tests) are not applicable 

because this implementation does not support address clauses for a 
variable. 

X. CD5011B, CD5011D, CD5011F, CD5011H, CD5011L, CD5011N, CD5011R, 

CD5011S, CD5012C..D, CD5012G..H, CD5012L, CD5013B, CD5013D, 

CD5013F, CD5013H, CD5013L, CD5013N. CD5013R, CD5014B, CD5014D, 

CD5014F, CD5014H, CD5014J, CD5014L, CD5014N, CD5014U (28 tests) are 
not applicable because this implementation does not support address 
clauses for a constant. 


3-4 





y. CD5012J, CD5013S, CD5014S (3 tests) are not applicable because this 
implementation does not support address clauses. 

z. CE2102E is inapplicable because this implementation supports CREATE 
with OUT_FILE mode for SEQUENTIAL_IO. 

aa. CE2102F is inapplicable because this implementation supports CREATE 
with INOUT_FILE mode for DIRECT_IO. 

ab. CE2102J is inapplicable because this implementation supports CREATE 
with OUT_FILE mode for DIRECT_IO. 

ac. CE2102N is inapplicable because this implementation supports OPEN 
with IN_FILE mode for SEQUENTIAL_IO. 

ad. CE21020 is inapplicable because this implementation supports RESET 
with IN_FILE mode for SEQUENTIAL_IO. 

ae. CE2102P is inapplicable because this implementation supports OPEN 
with OUT_FILE mode for SEQUENTIAL_IO. 

af. CE2102Q is inapplicable because this implementation supports RESET 
with OUT_FILE mode for SEQUENTIAL_IO. 

ag. CE2102R is inapplicable because this implementation supports OPEN 
with INOUT_FILE mode for DIRECT_10. 

ah. CE2102S is inapplicable because this implementation supports RESET 
with INOUT_FILE mode for DIRECT_IO. 

ai. CE2102T is inapplicable because this implementation supports OPEN 

with IN_FILE mode for DIRECT_IO. 

aj. CE2102U is inapplicable because this implementation supports RESET 
with IN_FILE mode for DIRECT_IO. 

ak. CE2102V is inapplicable because this implementation supports OPEN 

with OUT_FILE mode for DIRECT_IO. 

al. CE2102W is inapplicable because this implementation supports RESET 
with OUT_FILE mode for DIRECT_IO. 

am. CE2105A is inapplicable because CREATE with IN_FILE mode is not 

supported by this implementation for SEQUENTIAL_I0. 

an. CE2105B is inapplicable because CREATE with IN_FILE mode is not 

supported by this implementation for DIRECT_10. 

ao. CE31C2F is inapplicable because text file RESET is supported by 

this implementation. 

ap. CE3102G is inapplicable because text file deletion of an external 


3-5 







file is supported by this implementation. 

aq. CE3102I is inapplicable because text file CREATE with OUr_FII£ mode 
is si^ported by this implementation. 

ar. CE3102J is inapplicable because text file OPEN with IN_FHE mode is 
sv;?3ported by this implementation. 

at. CE3102K is inapplicable because text file OPEN with 0l7r_FILE mode 
is supported by this implementation. 

au. CE3109A is inapplicable becaijse text file CREATE with IN_FILE mode 
is not supported by this implementation. 

av. CE3111B and CE3115A simultaneously associate input and output files 
with the same extemcil file, and e:>pect that output is immediately 
written to the external file and available for reading; this 
implementation buffers files, and each test's attenp t to read such 
output (at lines 87 & 101, respectively) raises END_ERROR. 

aw. EE2401D is inapplicable becaxase the maximum element size supported 
for DIRECT 10 is 2 147 483 647 bits. USE ERROR is raised. 


3.6 TEST, PROCESSING, AND EVAIIIATIC»J MODUTCATICKS 

It is ejqjected that some tests will lequire modifications of code, 
processing, or evaluation in order to conpensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases 
where legitimate implementation behavior prevents the successful 
carpletion of an (otherwise) applicable test. Examples of such 
modifications include: adding a length clause to cLLter the default size 
of a collectionr splitting a Class B test into subtests so that all 
errors are detected; and confirming that messages produced by an 
executable test demonstrabe conforming behavior that was not anticipated 
by the test (such as raising one exception instead of another). 

Modifications were required for 73 tests. 

The following 65 tests were split becaiise syntax errors at one point 
resulted in the ccnpiler not detecting other errors in the test: 


B22003A 

B26001A 

B26002A 

B26005A 

B28001D 

B28003A 

B29001A 

B2A003A 

B2A003B 

B2A003C 

B33301A 

B35101A 

B37106A 

B37301B 

B37302A 

B38003A 

B38003B 

B38009A 

B38009B 

B51001A 

B53009A 

B54A01C 

B54A01H 

B55A01A 

B61001C 

B61001D 

B61001F 

B6100IH 

B61001I 

B61001M 

B61001R 

B61001S 

B61001W 

B67001H 

B91001A 

B91002A 

B91002B 

B91002C 

B91002D 

B91002E 

B91002F 

B91002G 

B91002H 

B91002I 

B91002J 

B91002K 

B91002L 

B95030A 

B95061A 

B95061F 

B95061G 

B95077A 

B97103E 

B97104G 

BAllOlB 

BC1109A 

BC1109C 

BC1109D 

BC1202A 

BC1202B 

BC1202E 

BC1202F 

BC1202G 

BC2001D 

BC2001E 







3-6 





The following 8 tests contain modifications to their respective source 
code files: 

C34007A. C34007D, C34007G. C34007J. C34007M, C34007P, C34007S, and 
C87B62B (8 tests) The AVO accepts the implementer's argument that, 
without there being a STORAGE_SIZE length clause for an access 
type, the meaning of the attribute 'STORAGE_SIZE is undefined for 
that type. Therefore, a length clause has been added in these 
tests in order to alter the default size of a collection. 1024 was 
used for all of the above tests except for C34007D and C34007G 
which used 2048. 

3.7 ADDITIONAL TESTING INFORMATION 
3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 
produced by the DAOS for Sun-3 -> Lynwood/LynX, Version 4.4 (1.1) 
compiler was submitted to the AVF by the applicant for review. Analysis 
of these results demonstrated that the compiler successfully passed all 
applicable tests, and the compiler exhibited the expected behavior on 
all inapplicable tests. 


3.7.2 Test Method 


Testing of the DAGS for Sun-3 -> Lynwood/LynX, Version 4.4 (1.1) 
compiler using ACVC Version 1.10 was conducted on-site by a validation 
team from the AVF. The configuration in which the testing was performed 
is described by the following designations of hardware and software 
components: 


Host computer: 

Host operating system: 

Target computer: 

Target operating system: 
Compiler: 


SUN-3/50 Workstation 

SunOS UNIX, Version 4.2, Release 

4.0_EXPORT 

Lynwood j430 

LynX, Version 1.4F 

DACS for Sun-3 -> Lynwood/LynX, Version 
4.4 (1.1) 


The ACVC Test Suite was loaded onto a VAX-8350' from the magnetic tape. 
The ACVC Test Suite was then downloaded onto the SUN-3/50 Workstation 
from the VAX-8530 via Ethernet (using DNICP net software utility). Then 
Ethernet was used between Lynwood j430 and Sun-3/50 WORKSTATION. 

A magnetic tape containing all tests except for withdrawn tests was 
taken on-site by the validation team for processing. Tests that make 
use of implementation-specific values were customized on-site. Tests 
requiring modifications during the prevalidation testing were modified 
on-site. 


3-7 






TEST INFORMATION 


The contents of the magnetic tape were loaded onto a VAX-8350 and 
transferred to the host computer, SlJN-3/50 Workstation, via Ethernet 
(using DNICP net software utility). Then Ethernet was used between 
Lynwood j430 and Sun-3/50 WORKSTATION. 

After the test files were loaded to disk, the full set of tests was 
compiled and linked on the SUN-3/50 Workstation, and all executable 
tests were run on the Lynwood j430. Results were transferred from the 
Lynwood j430 to the Sun-3/50 Workstation using Ethernet and were then 
transfered to the VAX-8530 via Ethernet (using DNICP net software 
utility) from the Sun-3/50 Workstation. The results were then printed 
from the VAX-8350 computer. 

The compiler was tested using command scripts provided by DDC 
INTERNATIONAL A/S and reviewed by the validation team. The compiler was 
tested using the following option settings. See Appendix E for a 
complete listing of the compiler options for this implementation. 

-L 

-a 


Tests were compiled, linked, and executed (as appropriate) using a 
single host and target computer. Test output, compilation listings, and 
job logs were captured on magnetic tape and archived at the AVF. 
Selected listings examined on-site by the validation team were also 
archived. 


3.7.3 Test Site 

Testing was conducted at Lyngby, Denmark and was completed on 27 October 
1989. 


3-8 






APPENDIX A 


DECLARATION OF CONFORMANCE 


DDC INTERNATIONAL A/S has submiCCed the following Declaration of 
Conformance concerning the DACS for Sun-3 -> Lynwood/LynX, 
Version 4.4 (1.1). 


A-1 






OECLARATZON Of CONFORMAMCZ 


Compllar Zapleaentor: DOC International A/S 

Ol.'LundtofteveJ IB 
2800 Lyngby, Oenaark 

Ada Validation Facility 

National Coaputar Systems Laboratory (NCSL) 
National Institute of Standards and Technology 
Building 22S, Room A266 
Gaitherburg, MO 20899, U.S.A. 


Ada Compiler Validation Capability (ACVC) Version: 1.10 


Ada Validation 
Facility: 


Base Configuration 


Base Compiler Name: 

Host Architecture: 

Host OS and Version: 
Target Architecture: 
Target OS and Version: 

Implementor's Declaration 


DACS Sun-3 -» Lynwood/LynX, Version 4.4 (1.1) 
Sun-3/SO Workstation 

SunOS UNIX, Version 4.2, Release 4.0_Export 
Lynwood j 430 
LynX, Version 1.4F 


I. the undersigned, representing DOC International A/S, have implemented no 
deliberate extensions to the Ada Language Standard ANSI/MIL-STD-181SA in the 
eompiler(s) listed in this declaration. I declare that DDC International A/S is 
the owner of record of the Ada language compiler(s) listed above, and as such, 
is r( ponsible for maintaining said compiler(s) in conformance to ANSI/MIL-STD- 
1815A. All certificates and registrations for Ada language compiler(s) listed 
in this declaration shall be made only in the owner's corporate name. 


DDC International A/S 

Basse Hansson, Department Manager 

Owner's Declaration 



I, the undersigned, representing DDC International A/S, take full 
responsibility for implementation and maintenance of the Ada compiler<s) listed 
above, and agree to the public disolosure of the final Validation Summary 
Report. I declare that all of the Ada language compilers listed, and their 
host/taget performance, are in compliance with the Ada Language Standard 
ANSI/MIL-STD-181SA. 


/9 n 

DOC International A/S 

Hasse Hansson, Department Manager 



OOC International A/S Gl Lundtoftevei 1 8 

OK-2800Lyng6y 
Denmark 


’•.CL' "one Teen 

'-5 

4?R7 !• 44 


Telefax 

♦45 

49B7 77 17 


*<; B»o NO 67 705 


T77."I4 r-r. <<1 










APPENDIX B 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine - dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of the DACS for Sun-3 -> 
Lynwood/LynX, Version 4.4 (1.1) compiler, as described in this Appendix, 
are provided by DDC INTERNATIONAL A/S. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. Implementation-specific portions of the package 
STANDARD, which are not a part of Appendix F, are: 


package STANDARD is 


type SHORT_INTEGER is range -32_768 .. 32_767; 

type INTEGER is range -2_147_483_648 .. 2_147_483_647; 


type FLOAT is digits 6 range 

-16#7.FFFF_C#E31 .. 16#7.FFFF_C#E31; 
type L0NG_FL0AT is digits 15 range 

-16#F.FFFF_FFFF_FFFF#E255 .. 16#F.FFFF_FFFF_FFFF#E255; 

type DURATION is delta 2**(-14) range 
-131 072.00000 .. 131 071.00000 ; 


end STANDARD; 


B-1 








Appenai.: i:‘ 

Sun-3/SunOS - User's Guide 


F_ Appendix F of 'the Ada Reference Manual 


F-0 Introduction 


This appendix describes the implementation-dependent charac¬ 
teristics of the DDC-I Sun-3/SunCS V Ada Compiler, as required 
in the Appendix F frame of the Ada Reference Manual (ANSI/MIL- 
STD 1815A). 


F«1 Implementation-Dependent Pragmas 

There is one implementation-defined pragma: Interface_spelling, 
see section 5.6.6.2. 

F.2 Implementation-Dependent Attributes 
No implementation-dependent attributes are defined. 


F-1 


OOC lni«maliona( A/S 









Sun-3/SunOS - User’s Guide 


F.3 Package SYSTEM 


pragma page; 
package SYSTEM is 


type ADDRESS 
subtype PRIORITY 
type NAME 
SYSTEM_NAME: 
STORAGE_UNIT: 
MEMORY_SIZE: 

MIN INT; 

MAX“lNT; 

max“digits: 
max“mantissa: 

FINE_DELTA: 

TICK: 


is new INTEGER; 
is INTEGER range 
is ( SUN ); 
constant NAME ;» 
constant :» 

constant :» 

constant :» 

constant : = 

consrant : * 

constant : = 

constant :* 

constant := 


type interface_language is (C,AS); 
Compiler system dependent types: 


SUBTYPE Integer_16 IS short_integer; 
SUBTYPE Natural_16 IS Intager__16 RANGE 
SUBTYPE Positive 16 IS Integer 16 RANGE 


SUBTYPE Integer_32 IS integer; 

SUBTYPE Natural_32 IS Integer_32 RANGE 
SUBTYPE Positive 32 IS Integer_32 RANGE 


end SYSTEM; 


F-2 


.. 32 ; 

SUN; 

8 * 

2048 * 1024; 
-2_147_4a3_648; 
2_147_4a3_647; . 
15; 

31; 

2#1.0#E-31; 

1 . 0 ; 


0..Integer_l6’LAST; 
1.. Integer__16 ’ LAST; 


0.. Integer_32' L.\S 
1..Integer_32'LAS 


OOC International A/S 









Appendix F 

Sun-3/SunOS - User's Guide 


F.4 Representation Clauses 


F.4.1 Lenq-th Clause 

A size attribute for a type T is accepted in the following cases: 

- If T is a discrete type then the specified size must be greater 
than an equal to the number of bits needed to represent a value 
of the type, and less than or equal to 32. 

If T is a fixed point type, a floating point type, an access 
type or a task type the specified size must be equal to the num¬ 
ber of bits used to represent values of the type. 

If T is a record type that is not derived then the specified size 
must be greater than or equal to the number of bits used to rep¬ 
resent value of the type. 

If T is an array type that is not derived, and has a sire known 
at compile time then the specified size must be equal to the num¬ 
ber of bits used to represent values of the type. In all other 
cases the size attribute is not accepted. 

Furthermore, the size attribute has only effect if the type is part 
of a composite type. 


Using the STORAGE^SIZE attribute for a collection will set an up¬ 
per limit on the total size of objects allocated in this collec¬ 
tion. If further allocation is attempted, the exception 
STORAGE_ERROR is raised. 

When STORAGE_SIZE is specified in a length clause for a task, the 
process stack area will be of the specified size. The process 
stack airea will be allocated inside the "standard" stack segment. 


F.4.2 Enumeration Representation Clause 

Enumeration representation clauses may specify representations in 
the range of INTEGER’FIRST + 1..INTEGER'LAST - 1. 

Enumeration representation clauses are not supported for derived 
types. 


F-3 


OOC International A/S 




Sun-3/SunOS - User's Guide 


F.4.3 Record Representa-tlon Clauses 

When representation clauses are applied to records the following 
restrictions are imposed: 

- the component type is a discrete type different from 

LONG_INTEGER, 

- the component type is an array with a discrete element type dif¬ 
ferent from LONG_INTEGER, 

- if the component is a record or an unpacked array, it must start 

on a storage unit boundary, a storage unit being 16 bits, 

- a record occupies an integral number of storage units, 

- a record must be specified with its proper size (in bits), 

regardless of whether the component is an array or not, 

- if a non-array component has a size which equals or exceeds one 
storage unit (16 bits), the component must start on a storage 
\init boundary, i.e. the component must be specified as: 

component at N range 0..16 * M - 1; 

where N specifies the relative storage unit number (0,1,...) from 
the beginning of the record, and M the required number of storage 
units (1,2,...) 

- the elements in an array component should always be wholly con¬ 
tained in one storage unit, 

- if a component has a size which is less than one storage unit, it 
must be wholly contained within a single storage unit: 

component at N range X .. Y; 

where N is as in the previous paragraph, and 0<sX<»Y<*15 

If the record type contains components which are not covered by a 
component clause, they are allocated consecutively after the com¬ 
ponent with the value. Allocation of a record component without a 
component clause is always aligned on a storage unit boundazy. Holes 
created because of component clauses are not otherwise utilized by 
the compiler. 


F-4 


OOC International A/S 




»wr 


Appenaj.x r 

Sun-3/SunOS - User's Guide 


F.4.3.1 Alignment Clauses 


Alignment clauses for records are Implemented with the following 
characteristics: 

- If the declaration of the record type is done at the outermost 
level in a library package, any alignment is accepted. 

- If the record declaration is done at a given static level 
(higher than the outermost library level, i.e. the permanent 
area), only word alignments are accepted. 

- Any record object declared at the outermost level in a library 
package will be aligned according to the alignment clause 
specified for the type. Record objects declared elsewhere can 
only be aligned on a word boundary. If the record type has been 
associated a different alignment, an error message will be 
issued. 

- If a record type with an associated alignment clause is used in 
a composite type, the alignment is required to be one word: an 
error message is issued if this is not the case. 


F.5 Implementation-Dependent Names for Implementation-Dependent 
Components 

None defined by the compiler. 


F.6 Address Clauses 


Not supported by the compiler. 


F.7 Unchecked Conversion 


Unchecked conversion is only allowed between objects of the same 
"size". In this context the "size" of an array is equal to that of 
two access values and the "size" of a packed array is equal to two 
access values and an integer. This is the only restriction imposed 
on unchecked conversion. 


F-5 'I 

I 


OOC Incemationai A/S 





Sun-3/SunCS - User's Guide 




F.8 Input-Ou'tpu't Packages 

The implementation supports all requirements of the Ada lan¬ 
guage. It is an effective interface to the UNIX file system, and in 
the case of text input-output also an effective interface to the 
UNIX standard input, standard output and standard error streams. 

This section describes the functional aspects of the interface to 
the UNIX file system, including the means by which the various file 
control facilities are made available to the Ada programmer. 

The Ada input-output concept as defined in Chapter 14 of the ARM 
does not constitute a complete functional specification of the 
input-output packages. Soma aspects are not discussed at all, while 
others are deliberately left open to an implementation. These gaps 
are filled by this section. 

The reader should be familiar with 

[DoD 83] - The Ada Language definition 

and some sections require that the reader is familiar with 

[UNIX 3] - UNIX Programmer Reference Manual 


F. 8.1 External Files 


External files can be on disc, tape, or be a character device (a 
line printer, terminal etc.). 

Files on disc exist after the execution of the program unless given 
an empty NAME parameter. 

The implementation will raise USE_ERROR when an operation is inap¬ 
propriate for the physical device. In particular the concept of a 
page or end-of-file or file size are not considered to be applicable 
to terminal devices and attempted use of operations involving these 
concepts will raise USE_ERROR. 

Deletion is not allowed on non-disc devices and requires write ac¬ 
cess . 

Creation of files with mode IN FILE will raise USE ERORR. 


F-6 


OOC International A/S 



Appenc^x t 


Sun-3/SunOS - User's Guide 


■ 2 File Management 

is subsection contains information regarding file management: 

- restriction on sequential and direct input-output, 

- the NAME parameter, 

> the FORM parameter, 

- file access. 


F.8.2.1 Restrictions on Sequential and Direct Incut-Output 

The only restriction is that placed on the element size, i.e. the 
number of bytes occupied by the ELEMENT_TYPE: the maximum size al¬ 
lowed is 2_147_lia3_647 bits; and if the size of the type is 
variable, the maximum size must be determinable at the point of in¬ 
stantiation from the value of the SIZE attribute for the element 
type. 


F.8.2.2 The NimE Parameter 

The NAME parameter when non-empty must be valid UNIX path name. 
Access denial to any directory in the path name will raise 
USE_ERROR. 

The UNIX names "stdin", "stdout", and "stderr" can be used in con¬ 
junction with TEXT^IO.open. No physical opening of the external 
file is performed and the Ada file will be associated with the al¬ 
ready open external file. 

Temporary files (NAME » "") are created using tmpname (3) and will 
be deleted on closure. Abnormal program termination may leave tem¬ 
porary files in existence. 

Default naming conventions and version numbers ar^ not applicable to 
UNIX. 


F. 8.2.3 The FORM Parameter 


The FORM parameter has the following facilities; 

a) Opening a FIFO special file using open(2) system call. This is 
achieved by the string ’•FIFO". If this facility is used with 
CREATE, the exception USE_ERROR will be raised. This facility is 
not available for direct io or text io and raises USE ERROR. 


F-7 


OOC Intemncional A> S 


Gaide 


Sun-3/Sur.- i 


The default for this facility is indicated by the "ORDINARY" 
string designaring the creation of an ordinary file. If this 
string is used with OPEN and the external file is of type FIFO 
special, the operation raises USE_ERROR. 


The 0 NDELAY flag associated with FIFO specials (see open(2)) can 
be modified using an additional string after the "FIFO" string. 
The strings "0__NDELAYaON" and "0_NDELAY=OFF" set the flag on and 
off respectively. The default is "0_NDELAY=0FF". Thus "FIFO 
0 NDELAY=ON" opens a FIFO Special file ^d set the 0_ND£LAY flag 
on. 


b) The use of 
emptying of 
"APPEND" in 
its use in 
signifies the 


the string "APPEND" with text-files prevents the 
the file for the OPEN operation- The presence of 
the form paramieter is only applicable tc OPEN, and 
CREATE will raise USE_ERROR. The string "NQAPPENB" 
default. 


The opened file will be treated by the routines delate as if 
empty. 


Opening direct and sequential files with the "APPEND" or 
"NOAPPEND" raises USE ERROR. 


c) The changing of default access rights by specifying the mode 
parameter used in the open(2) system call used to implement the 
Ada CREATE procedure. This is achieved by use of the string 
"MODE»<mode>" where <mode> is an octal, decimal or hexadecimal 
integer in the standard UNIX format. Only the nine least sig¬ 
nificant bits of the creation mask are used. This facility is 
also used by OPEN to change the access permissions by means of 
the chmod(2) system call. 


F-8 


OOC Internationai A/S 




Appendix F 

Sun-3/SunOS - User's Guide 


a default 'for mode is 0644, allowing the owner to read and 
ite, and the group and others to read. The bits mean (as in 
landard UNIX): 

rv- r— r— 

% 

L Other privileges 
L Group privileges 
- Owner privileges 

NOTES: 

The options are delimited by commas. 

If more than one of the three option types is included, the 
rightmost option is selected. 

Blanks are not significant in any part of the string. 

The FORM parameter provides all default options as required in the 
ARM. 


F-9 


OOC Intefnaiionai A/S 









Sun-3/SunOS - User’s Guide 

?.8.2.3.1 Syntax of the Fora Parameter 
<forni_parameter> :» C<option> C,<opt±on> [,<aption>] ] ] 
<option> :» <access_rights> | <£ifo_op-tion> ] <append_opticn> 
<access_rights> :■ MODE* <mode> 

<fifo__option> :* <fifo_special> | ORDINARY 
<append_option> :» APPEND ( NOAPPEND 

<mode> := <hex_number> | <octal_number> 1 <decimal_number> 
<fifo__special> := FIFO [ <o_ndelay_paraineter> ] 
<o_ndelay_paraineter> := 0_NDELAY=0N | 0_NDELAY=0FF 


< deciinal_niimber > 

< hex_nuniber > 
<octal__nuinber> 
<hex_suffix> 
<octal_suffix> 
<hex_digit> 
<decimal__digit> 

< oc-tal__digi t > 


:= <decimal_digit> {<decimal_digit>} 

: = 0 X <hex_suffix> 

:= 0 <octal_suffix> 

:» <hex__digit> C<hex__digit>} 

:= <octal__digit> {<octal_digit>} 

:= 0 I 1 ...| 9 I A I ... I F 1 a I ...| 
;= 0 1 1 ...1 9 
;» 0 I 1 ...] 7 


f 


F.8.2-4 File Access 


Any number of files in an Ada program may be associated with 
any external file at any time. Each end of a FIFO special file 
must be accessed from two UNIX processes which will have to 
correspond to two Ada programs. 

It is the responsibility of the programmer to consider th-' ef¬ 
fects of file sharing between programs. 

The RESET and OPEN operations to OUT FILE mode empty the file 
in SEQUENTIAL 10 and TEXT 10. 


F-10 


OOC International A/S 





Appenaix t 


Sun-3/SunOS - User's Guide 


erchanging between SEQUENTIAL_IO and DIRECT_IO for files of 
same object types can be achieved without taking special 
isures. 

The state of the external file at any moment is in general un¬ 
defined. Closing and resetting a file will, however, flush any 
buffering in the input-output packages. Unpredictable results 
may occur if the program is terminated without calling CLOSE. 


F.8.3 Sequential Input-Output 

The implementation omits type checking for DATA_ERROR, in case 
the element type is of an unconstrained type, ARM 14.2.2(4), 
i.e.: 


... f : FILE_TYPE 
type at is 1..100; 

type eat is array( et range <> ) of integer; 

X : eat( 1..2 ); 

Y : eat( 1..4 ); 

— write X, Y: 

write( f, X); write( f, Y); reset( f, IN_FILE); 

— read X into Y and Y into X: 
read( f, Y); read( f, X); 

This will give undefined values in the last 2 elements of Y, 
and not DATA ERROR. 


F-11 


DOC International A/S 




Sun-3/SunOS - User’s Guide 

F ^.3.1 Specifica-tion of the Package Sequential_IO 
V th 8ASIC_I0_TYPES; 
w-th IO_EXCEPTIONS; 
generic 

type ELEMENT_TYPE is private; 
package SEQUENTIAL_IO is 

type FILE_TYPE is limited private; 
type FILE_MODE is (IN_FILE, OUT_FILE); 

— File management 

procedxire CREATE (FILE : in out FILE_TYPE; 

MODE ; in FILE_MODE := OUT FILE; 

NAME : in STRING :* 

FORM : in STRING :* ""); 

procedure OPEN (FILE ; in out FILE TYPE; 

MODE : in FILE^MODE; 

NAME : in STRING; 

FORM ; in STRING ;» ""); 

procedure CLOSE (FILE : in out FILE_TYPE); 

procedure DELETE(FILE : in out FILE_TYPE); 

procedure RESET (FILE : in out FILE_TYPE; 

MODE : in FILE_MODE); 

procediure RESET (FILE : in out FILE__TYPE); 

function MODE (FILE : in FILE__TYPE) return FILE_MODE; 

function NAME (FILE : in FILE_TYPE) return STRING; 

function FORM (FILE ; in FILE_TYPE) retrim STRING; 

function IS_OPEN( FILE ; in FILE_TYPE) relnim BOOLEAN; 

— input and output operations 

procedure READ (FILE : in FILE TYPE; 

ITEM : out ELEMENT_TYPE); 

procedure WRITE (FILE : in FILE_TYPE; 

ITEM ; in ELEMENT_TYPE); 

F-12 


OOC International A/S 






Appendix F 

Sun-3/SunOS - User's Guide 


function END_0F_F1LE( FILE : in FILE_TYPE) return BOOLEAN; 
exceptions 

STATUS__ERROR : exception renames IO_EXCSPTIONS .STATUS_ERROR; 
MODE_ERROR : exception renames IO_EXCSPTIONS .MODE_ERROR; 

NAME_ERROR : exception renames IO_EXCEPTIONS.NAME_ERROR; 

USE_ERROR : exception renames IO_EXCEPTIONS .USE_ERROR; 

DEVICE_ERROR : exception renames 10“EXCEPTI0NS .DEVICE_ERROR; 
END_ERROR : exception renames 10 EXCEPT IONS. END_ERR0R; 

DATA_ERROR : exception renames I0“EXCEPTI0NS . DATA_ERROR, 

private 

type FILE_TYPE is new BASIC_IO_TYPES. FILE_TYPE; 
end SEQUENTIAL 10; 


F. 8.4 Direct Input-Output 


The implementation omits type checking for DATA_ERROR, in case 
the element type is of an xinconstrained t^e, [Dod 83] 
14.2.4(4), see F.8.3. 


F-13 


OOC Intvmationai A/S 









••fc*** 


Sun-S/SunOS - User's Guide 

F.8.4.1 Specifica-tion of the Package Dlrect-IO 

with BASIC_IO_TYPES; 
with IO_EXCEPTIONS; 

generic 

type ELEMENT_TyPE is private; 
package DIRECT_^IO is 

type FILE__TYPE is limited private; 

type FILE_MODE is (IN_FILE, INOUT_FILE, OUT_FILE); 

type COUNT is range 0. .INTEGER'LAST; 

subtype POSITIVE_COUNT is COUNT range 1..COUNT'LAST; 

— File management 


procedure 

CREATE(FILE 

• 

in 

out 

FILE TYPE; 




MODE 

« 

• 

in 


FILE MODE : = 

INOUT FILE; 



NAME 

• 

• 

in 


STRING := 

f 



FORM 

• 

• 

in 


STRING :» 


procedure 

OPEN 

(FILE 


in 

out 

FILE TYPE; 




MODE 

• 

• 

in 


file“mode; 




NAME 

• 

• 

in 


STRING; 




FORM 

• 

• 

in 


STRING := " 


procedure 

CLOSE 

(FILE 

• 

« 

in 

out 

FILE_TYPE); 


procedure 

DELETE(FILE 

• 

• 

in 

out 

FILE__TYPE) ; 


procedure 

RESET 

(FILE 

• 

• 

in 

out 

FILE TYPE; 




MODE 

• 

• 

in 


FILE_MODE); 


procediire 

RESET 

(FILE 

• 

• 

in 

out 

FILE_TYPE); 


function 

MODE 

(FILE 

• 

• 

in 

FILE_TYPE) return 

FILE__MODE; 

fxinction 

NAME 

(FILE 

• 

• 

in 

FILE_TYPE) return 

STRING; 

fxinction 

FORM 

(FILE 

• 

• 

in 

FILE_TYPE) return 

STRING; 

fimction 

IS_OPEN(FILE 

• 

in 

FILE^TYPE) return 

BOOLEAN; 


— input and output operations 


F-14 


OOC lnt«mationai A/S 








Appendix F 

Sun-3/SunOS - User's Guide 




procedure READ (FILE : In FILE_TYPE; 

ITEM : out ELEMENT TYPE; 

FROM ; in POSITIVE_COUNT); 

procedure READ (FILE ; in FILE_TYPE; 

ITEM : out ELEMENT_TYPE); 

procedure WRITE (FILE : in FILE_TYPE; 

ITEM : in ELEMENT_TYPE; 

TO ; in POSITIVE_COUNT); 
procedure WRITE (FILE : in FILE_TYPE; 

ITEM : in ELEMENT_TYPE); 

procedure SET_INDEX( FILE : in FILE_TYPE; 

TO : in POSITIVE_COUNT); 

function INDEX(FILE ; in FILE^TYPE) return POSITIVE_COUNT; 
function SIZE (FILE : in FILE_TYPE) return COUNT; 
ftmction END OF FILE(FILE : in FILE TYPE) return BOOLEAN; 


— exceptions 

STATUS_ERROR : exception renames lO EXCEPTIONS.STATUS ERROR; 
MODE^ERROR ; exception renames IO'exCEPTIONS .MODE_ERROR; 
NAME'errOR : exception renames lO^EXCEPTIONS.NAME ERROR; 
USE_ERROR : exception renames lO-RXCEPTIONS .USE_ERROR; 
DEVICE ERROR : exception renames IO~EXCEPTIONS.DEVICE ERROR; 
END__ERROR : exception renames IO~EXCEPTIONS . END_ERROR; 
DATA_ERROR : exception renames IO~EXCEPTIONS.DATA_ERROR; 

private 

type FILE_TYPE is new BASIC_IO_TYPES,FILE_TYPE; 
end DIRECT 10; 


F-15 


OOC Intemafional A/S 








Surx-3/SunOS - User's Guide 


4^ 


F.8.5 Specification of the Package Text_IO 

with BASIC_IO TfPES; 
with IO_EXCEPTIONS; 
package TEXT^IO is 

type FILE_^TY?E is lioited private; 

type F1LE_M0DE is (IN_FILE, 0UT_F1LE); 

type COUNT is range 0 .. INTEGER' LAST; 

subtype POSITIVE_COUNT is COUNT range 1 .. COUNT'LAST; 

UNBOUNDED: constant COUNT;* 0; — line and page length 

subtype FIELD is INTEGER range 0 .. 35; 

subtype NUMBER_BASE is INTEGER range 2 .. 16; 

type TYPE_SET is (LOWER_CASE, UPPER_CASE); 


— File Management 


procedure 

CREATE 

(FILE 

• 

« 

in 

out 

FILE TYPE; 




MODE 

• 

in 


FILE MODE ;» OUT FILE; 



NAME 

• 

• 

in 


STRING ;» " 

•• • 



FORM 

• 

• 

in 


STRING ;« " 


procedure 

OPEN 

(FILE 

« 

• 

in 

out 

FILE TYPE; 




MODE 

« 

• 

in 


FILE MODE; 




NAME 

• 

• 

in 


STRING; 




FORM 

• 

• 

in 


STRING ;» " 


procediire 

CLOSE 

(FILE 

m 

in 

out 

FILE TYPE); 


procedure 

DELETE 

(FILE 

• 

in 

out 

FILE TYPE); 


procedure 

RESET 

(FILE 

• 

• 

in 

out 

FILE TYPE; 




MODE 

• 

• 

in 


FILE MODE); 


procedure 

RESET 

(FILE 

w 

9 

in 

out 

FILE TYPE); 


function 

MODE 

( FILE 

# 

• 

in 

FILE TYPE) return 

FILE MODE 

function 

NAME 

(FILE 

« 

in 

FILE~TYPE) return 

STRING; 

function 

FORM 

(FILE 

m 

0 

in 

FILE_TYPE) return 

STRING; 

function 

IS OPEN(FILE 

9 

9 

in 

FILE TYPE) return 

BOOLEAN; 


Control of default input and output files 


procedure SET__INPUT (FILE ; in FILE_TYPE); 
procedure SST_OUTPUT (FILE : in FILE_TYPE); 


function STANDARD INPUT return FILE TYPE; 
function STANDARD^OUTPUT return FILE^TYPE; 


F-16 


OOC lnt*rnaltonai A/S 









Sun-3/SunOS - User's Guide 


function CURRENT_INPUT return FILE TYPE; 
fxmctlon CURRENT OUTPUT return F1 LE”tYPE; 


— Specification of line and page lengths 

procedure SET LINE LENGTH (FILE : In FILE TYPE; 

“ “ TO : In COUNT); 

procedure SET_LINE_LENGTH (TO ; In COUNT); 

procedure SET_PAGE_LENGTH (FILE ; In F1LE_TYPE; 

TO ; In COUNT); 

procedure SET_PAGE_LENGTH (TO : In COUNT); 

fxmctlon LINE_LENGTH (FILS ; In FILE_TYPE) return 

COUNT; 

fxmctlon L1NE_LENGTH return 

COUNT; 

fxmctlon PAGE_LENGTH (FILE ; In FILE_TYPE) return 

COUNT; 

fxmctlon PAGE_LENGTH retxim 

COUNT; 

— Colxunn, Line, and Page Control 

procedxire NEW_LINE (FILE : In FILE TYPE; 

SPACING : in POSITIVE COUNT :* 1); 
procedxjre NEWSLINE (SPACING : in P0SITIVE”C0UNT :* 1); 

procedure SKIP_LINE (FILE : in FILE TYPE; 

SPACING : in POSITIVE_COUNT :* 1); 

procedxire SKIP_LINE (SPACING ; in POSITIVE_COUNT ;» 1); 

fxmctlon END__OF_LINE (FILE ; in FILE_TYPE) retxim 

BOOLEAN; 

fxmctlon END_OF_LINE retxim 

BOOLEAN; 

procedure NEW_PAGE (FILE ; in FILE_TYPE); 
procedure NEW_PAGE ; 

procedure SKIP^PAGE (FILE ; in FILE_TYPE); 

procedure SKIP^^PAGE ; 

fxmctlon END_OF PAGE (FILE : In FILE TYPE) retxim 

” “ BOOLEAN; 

fxmctlon END_OF_PAGE retxim 

BOOLEAN; 

function END_OF_FILE (FILE : in FILE_TYPE) return 

BOOLEAN; 


F-17 


OOC International A/S 



Sun-3/SunOS - User’s Guide 


function 

END__OF_FILE 




return 






BOOLEAN; 

procedure 

SET_COL 

(FILE 

• 

• 

in 

FILS TYPE; 



TO 

• 

in 

POSITIVE COUNT); 

procedure 

SET_COL 

(TO 

• 

• 

in 

POSITIVE_COUNT); 

procedure 

SET_LINE 

(FILE 

• 

• 

in 

FILE TYPE; 



TO 

• 

• 

in 

POSITIVE COUNT); 

procedure 

SET_LINE 

(TO 

• 

• 

in 

POSITIVE^COUNT); 

function 

COL 

(FILE 

* 

• 

in 

FILE TYPE) return 






POSITIVE_COUNT; 

fxmction 

COL 




return 






POSITIVE_COUNT; 

function 

LINE 

(FILE 

• 

• 

in 

FILE TYPE) return 






POSITIVE_COUNT; 

function 

LINE 




return 






POSITIVE_COUNT; 

fxmction 

PAGE 

(FILE 

• 

• 

in 

FILE TYPE) return 






POSITIVE_COUNT; 

function 

PAGE 




return 


POSITIVE_COUNT; 

— Character Input-Output 

procedure GST (FILE : in FILE_TYPE; 

ITEM : out CHARACTER); 

procedure GET (ITEM : out CHARACTER); 

procedure PUT (FILE : in FILE_TYPE; 

ITEM ; in CHARACTER); 
procedure PUT (ITEM : in CHARACTER); 

— String Input-Output 

procedure GST (FILE ; in FILE_TYPE; 

ITEM ; our STRING); 

procedure GST (ITEM : out STRING); 

procedure PUT (FILE : in FILE_TYPE; 

ITEM : in STRING); 

procedure PUT (ITEM : in STRING); 

procedxare GET_LINE (FILE ; in FILE_TYPE; 

ITEM ; out STRING; 

LAST ; out NATURAL); 

procedure GET_LINE (ITEM ; out STRING; 

LAST : out NATURAL); 

procedure PUT_LINE (FILE ; in FILE TYPE; 

ITEM : in STRING); 

procedure PUT_LINE (ITEM ; in STRING); 


F-18 


ODC Intvmational A/S 







Sun-3/SunOS - User's Guide 


Generic Package for Input-Output of Integer Types 


generic 

type MUM is range <>; 
package INTEGER_IO Is 


DEFAULT_WIDTH : FIELD :• MUM'WIDTH ; 

DEFAULT BASE : NUMBER BASE ;» 10; 


procedure 

GET 

(FILE 


in 

FILE TYPE; 



ITEM 


out 

NUM; 



WIDTH 


in 

FIELD := 0); 

procediire 

GET 

( ITEM 


out 

NUM; 



WIDTH 


in 

FIELD := 0); 


procedure 

PUT 

(FILE 




ITEM 




WIDTH 




BASE 


procedure 

PUT 

( ITEM 




WIDTH 




BASE 


procedxire 

GET 

(FROM 




ITEM 




LAST 


procediire 

PUT 

(TO 




ITEM 




BASS 



end INTEGER 10; 


in FILE TYPE; 
in NUM;" 

in FIELD := DEFAULT_WIDTH; 
in NUMBER__BASE :» DE?AULT_BASE) 
in NUM; 

in FIELD := DEFAULT_WIDTH; 
in NUMBER_BASE :» DEFAULT_BASS) 

in STRING; 
out NUM; 
out POSITIVE); 
out STRING; 
in NUM; 
in NUMBER_BASS 

DEFAULT BASE) 


F-19 


DOC Intamational A/S 







Sun-3/SunOS - User's Guide 


— Generic Packages for Input-Output of Real Types 
generic 

type MUM is digits <>; 
package FLOAT^IO la 

DEFAULT FORE ; FIELD :« 2; 

DEFAULT'aFT : FIELD :» MUM'digits - 1; 
DEFAULT'exp : FIELD 3; 


procedure 

GET 

(FILE 

: in 

FILE^TYPE; 



ITEM 


out NUM;~ 



WIDTH 

: in 

FIELD :* 0); 

procedure 

GET 

(ITEM 


out NUM; 



WIDTH 

: in 

FIELD ;» 0); 

procedure 

PUT 

(FILE 

in 

FILE TYPE; 



ITEM 

in 

MUM;- 



FORE 

in 

FIELD := DEFAULT FORE; 



AFT 

in 

FIELD :a DEFAULT^AFT; 



EXP 

in 

FIELD ;» DEFAULT~EXP); 

procedure 

PUT 

(ITEM 

in 

MUM; “ 



FORE 

in 

FIELD :« DEFAULT FORE; 



AFT 

in 

FIELD ;= DEFAULT^AFT; 



EXP 

in 

FIELD :» DEFAULT^EXP); 

prQced\are 

GET 

(FROM 

in 

STRING; 



ITEM 


out NUM; 



LAST 


out POSITIVE); 

procedxire 


(TO 


out STRING; 



ITEM 

in 

NUM; 



AFT 

in 

FIELD :» DEFAULT AFT; 



EXP 

in 

FIELD ;» DEFAULT~EXP) 


end FLOAT 10; 


F-20 


DOC lnt*fna(iona< A/S 






Apper.aix F 

Sun-3/SunOS - User’s Guide 


generic 

•type NUM is delta <>; 
package FIXED_IO is 

DEFAULT_FORE ; FIELD :« NUM*FORE; 
DEFAULT_AFT : FIELD NUM'AFT; 
DEFAULT EXP : FIELD :» 0; 


procedure 

GET 

(FILE 

: in 

FILE_TYPE; 



ITEM 


out NUM; 



WIDTH 

: in 

FIELD := 0); 

procedure 

GET 

(ITEM 


out NUM; 



WIDTH 

: in 

FIELD := 0); 

procedure 

PUT 

(FILE 

: in 

FILE TYPE; 



ITEM 

: in 

NUM; 



FORE 

: in 

FIELD :» DEFAULT FORE; 



AFT 

: in 

FIELD :» DEFAULT AFT; 



EXP 

: in 

FIELD :* DEFAULT_EXP); 

procedure 

PUT 

(ITEM 

: in 

NUM; 



FORE 

: in 

FIELD :a DEFAULT FORE; 



AFT 

: in 

FIELD ;= DEFAULT AFT; 



EXP 

: in 

FIELD ;» DEFAULT_EXP); 

procedure GET 

(FROM 

: in 

STRING; 



ITEM 

• 

• 

out NUM; 



LAST 

• 

• 

out POSITIVE); 

procedure 

PUT 

(TO 

« 

• 

out STRING; 



ITEM 

: in 

NUM; 



AFT 

: in 

FIELD ;= DEFAULT AFT; 



EXP 

: in 

FIELD :» DEFAULT EXP); 


end FIXED_I0; 

— Generic Package for Input-Output cf Snusieration Types 


F-21 


OOC lni«mationa< A/S 





Sun-3/SunOS - User’s Guide 


generic 

type ENUM Is (<> ) ; 
package ENUMERATION__^IO is 

DEFAULT WIDTH : FIELD :» 0; 

DEFAULT“SETTING : TYPE_SET UPPER_CASE; 

procedure GET (FILE : in FILE TYPE; 

ITEM ; out enumT; 

procedure GET (ITEM : out ENUM); 

procedure PUT (FILE ; in FILE_TYPE; 

ITEM : in ENUM; 

WIDTH : in FIELD ;» DEFAULT_WIDTH; 

SET : in TYPE_SET :* DErAULT_SETTING); 

procedxire PUT (ITEM : in ENUM; 

WIDTH : in FIELD :» DEFAULT_WIDTK; 

SET : in TYPE_SET := DEFAULT_SETTING); 

procedure GET (FROM : in STRING; 

ITEM : out ENUM; 

LAST : out POSITIVE); 

procedure PUT (TO ; out STRING; 

ITEM : in ENUM; 

SET : in TYPE_SET ;= DEFAULT_SETTING); 

end ENUMERATI0N_I0; 

— Exceptions 

STATUS_ERROR : exception renames IO_EXCEPTIONS.STATUS_ERROR 
MODE_ERROR : exception renames IO_EXCEPTIONS.MODE_ERROR; 
NAME_ERROR : exception renames IO_EXCEPTIONS.NAME_ERROR; 
USE_ERROR : exception renames I0_EXCEPTI0NS.USE_ERROR; 
DEVICE_ERROR : exception renames IO_EXCEPTIONS.DEVICE_ERROR 
END ERROR : exception renames IO_EXCEPTIONS.END_ERROR; 
DATA_ERRCR : exception renames IO_EXCEPTIONS.DATA_ERROR; 
LAY0UT_ERR0R : exception renames IO_EXCEPTIONS.LAYOUT_ERROR 

private 

type FILE_TYPE is new BASIC_IO_TYPES.FILE_TYPE; 
end TEXT 10; 


F.8.6 Low Level Input-Output 


The package L0W_LEVEL_I0 is empty. 


F-22 


OOC International A/S 




APPENDIX C 


TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, 
such as the maximum length of an input line and invalid file names. A 
test that makes use of such values is identified by the extension .TST 
in its file name. Actual values to be substituted are represented by 
names that begin with a dollar sign. A value must be substituted for 
each of these names before the test is run. The values used for this 
validation are given below. 

$ACC_SIZE 32 

An integer literal whose value 
is the number of bits sufficient 
to hold any value of an access 
type. 

$BIG_ID1 1..125 -> 'A', 126 -> '1' 

Identifier the size of the 

maximum input line length with 
varying last character. 

$BIG_ID2 1..125 -> 'A', 126 -> ’2' 

Identifier the size of the 

maximum input line length with 

varying last character. 

$BIG_ID3 

Identifier the size of the 

maximum input line length with 

varying middle character. 

$BIG_ID4 

Identifier the size of the 

maximum input line length with 

varying middle character. 

$BIG_INT_LIT 1..123 -> 0, 124..126 -> 298 

An integer literal of value 298' 
with enough leading zeroes so 
that it is the size of the 
maximum line length. 

$BIG_REAL_LIT 1..121 -> 0, 122..126 -> 690.0 

A universal real literal of 
value 690.0 with enough leading 
zeroes to be the size of the 


1.. 63 -> 'A', 64 -> '4'. 

65.. 126 -> 'A' 


1.. 63 -> , 64 -> '3', 

65.. 126 -> 'A' 


C-1 







maximum line length. 


$BIG_STRING1 1..63 -> 'A' 

A string literal which when 
catenated with BIG_STRING2 
yields the image of BIG_ID1. 

$BIG_STRING2 1..62 -> 'A', 

A String literal which when 
catenated to the end of 
BIG_STRING1 yields the image of 
BIG IDl. 


$BLANKS 1..106 -> 

A sequence of blanks twenty 
characters less chan the size 
of the maximum line length. 


$COUNT_LAST 

A universal integer 

literal whose value is 
TEXT_IO.COUNT'LAST. 

$DEFAULT_MEM_SIZE 

An integer literal whose value 
is SYSTEM.MEMORY_SIZE. 

$DEFAULT_STOR_UNIT 

An integer literal whose value 
is SYSTEM.STORAGE_UNIT. 

$DEFAULT_SYS_NAME 

The value of the constant 
SYSTEM.SYSTEM NAME. 


2 147 483 647 


2 097 152 


16 


SUN 


$DELTA_D0C 2#1.0#E-31 

A real literal whose value is 
SYSTEM.FINE DELTA. 


$FIELD_LAST 

A universal integer 
literal whose value is 
TEXT 10.FIELD'LAST. 


35 


$FIXED_NAME 



The name 

of a 

predefined 

fixed-point 

DURATION. 

type 

ocher than 


NO SUCH TYPE 


$FL0AT_NAME 

The name of a 
floating-point type 


N0_SUCH_TYPE 

predefined 
other than 


C-2 


63 -> '1' 






FLOAT. SHORT_FLOAT, or 

LONG_FLOAT. 

$GREArER_THAN_DLTlATION 100000.0 

A universal real literal that 
lies between DURATION'BASE'LAST 
and DURATION'LAST or any value 
in the range of DURATION. 

$GREATER_THAN_DURATION_BASE_LAST 200000.0 

A universal real literal that is 
greater than DURATION'BASE'LAST. 

$HIGH_PRIORITY 31 

An integer literal whose value 
is the upper bound of the range 
for the subtype SYSTEM.PRIORITY. 

$ILLEGAL_EXTERNAL_FILE_NAME1 ILLEGAL!@#$%"/ILLEGAL 

An external file name which 
contains invalid characters. 

$ILLEGAL_EXTERNAL_FILE_NAME2 ILLEGAL&()+“/ILLEGAL 

An external file name which 
is too long. 

$INTEGER_FIRST -2147483648 

A universal integer literal 
whose -value is INTEGER'FIRST. 

$INTEGER_LAST 2147483647 

A universal integer literal 
whose value is INTEGER'LAST. 

$INTEGER_LAST_PLUS_1 2_147_483_648 

A universal integer literal 
whose value is INTEGER'LAST + 1. 

$LESS_THAN_DURATI0N -100000.0 

A universal real literal that 
lies between DURATION'BASE'FIRST 
and DURATION'FIRST or any value 
in the range of DURATION. 

$LESS_THAN_DURATION_BASE_FIRST -200000.0 

A universal real literal that is 
less than DURATION'BASE'FIRST. 

$L0W_PRI0RITY 1 

An integer literal whose value 
is the lower bound of the range 
for the subtype SYSTEM.PRIORITY. 

C-3 









31 


$MANTISSA_DOC 

An integer literal whose value 
is SYSTEM.MAX_MANTISSA. 

$MAX_DIGITS 15 

Maximvim digits supported for 
floating-point types. 

$MAX_IN_LEN 126 

Maximum input line length 
permitted by the implementation. 

$MAX_INT 2147483647 

A universal integer literal 
whose value is SYSTEM.MAX:_INT. 

$MAX_INT_PLUS_1 2147483648 

A universal integer literal 
whose value is SYSTEM.MAX_INT+1. 

$MAX_LEN_INT_BASED_LITERAL 1..2 -> '2:', 3..123 -> 'O', 

A universal integer based 124..126 -> '11;' 
literal whose value is 2#11# 
with enough leading zeroes in 
the mantissa to be MAX_IN_LEN 
long. 

$MAX_LEN_REAL_BASED_LITERAL 

A universal real based literal 
whose value is 16:F.E; with 
enough leading zeroes in the 
mantissa to be MAX_IN_LEN long. 

$MAX_STRING_LITERAL 

A string literal of size 
MAX_IN_LEN, including the quote 
characters. 

$MIN_INT -2147483648 

A universal integer literal 
whose value is SYSTEM.MIN_INT. 

$MIN_TASK_SIZE 32 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
no entries, no declarations, and 
"NULL;" as the only statement in 
its body. 

$NAME NO SUCH TYPE 


1.. 3 -> '16:', 4..122 -> '0' , 

123.. 126 -> 'F.E: ' 


2..125 -> 'A', 

126 -> "" 


C-4 










A name of a predefined numeric 
type other than FLOAT, INTEGER, 
SHORT_FLOAT, SHORT_INTEGER, 
LONG_FLOAT, or LONG_INTEGER. 

$NAME_LIST 

A list of enumeration literals 
in the type SYSTEM.NAME, 
separated by commas. 

$NEG_BASED_INT 

A based integer literal whose 
highest order nonzero bit 
falls in the sign bit 
position of the representation 
for SYSTEM.MAX_INT. 

$NEW_MEM_SI2E 

An integer literal whose value 
is a permitted argument for 
pragma memory_size, other than 
$DEFAULT_MEM_SIZE. If there is 
no other value, then use 
$ DEFAULT_MEM_S12E. 

$NEW_STOR_UNIT 

An integer literal whose value 
is a permitted argument for 
pragma storage unit, other than 
$DEFAULT_STOR_UNIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGE_UNIT. 

$NEW_SYS_NAME 

A value of the type SYSTEM.NAME, 
other than $DEFAULT_SYS_NAME. If 
there is only one value of that 
type, then use that value. 

$TASK_SI2E 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 


a single entry 
parameter. 

with 

one inout 

$TICK 

A real literal 
SYSTEM.TICK. 

whose 

value is 


LYNWOOD UNIX V 


16#FFFF FFFF# 


2 097 152 


8 


IAPX386 PM 


32 


C-5 







APPENDIX D 


WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to 
the Ada Standard. The following 44 tests had been withdrawn at the time 
of validation testing for the reasons indicated. A reference of the 
form Al-ddddd is to an Ada Commentary. 

A39005G 

This test unreasonably expects a component clause to pack an array 
component into a minimum size (line 30). 

B97102E 

This test contains an unintended illegality: a select statement 
contains a null statement at the place of a selective wait alternative 
(line 31). 

C97116A 

This test contains race conditions, and it assumes that guards are 
evaluated indivisibly. A conforming implementation may use interleaved 
execution in such a way that the evaluation of the guards at lines 50 & 
54 and the execution of task CHANGING_OF_THE_GUARD results in a call to 
REPORT.FAILED at one of lines 52 or 56. 

BC3009B 

This test wrongly expects that circular instantiations will be detected 
in several compilation units even though none of the units is illegal 
with respect to the units it depends on; by AI-00256, the illegality 
need not be detected until execution is attempted (line 95). 

CD2A62D 

This test wrongly requires that an array object's size be no greater 
than 10 although its subtype's size was specified to be 40 (line 137). 

CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] 

These tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them to a 
derived subprogram (which implicitly converts them to the parent type 
(Ada standard 3.4:14)). Additionally, they use the 'SIZE length clause 
and attribute, whose interpretation is considered problematic by the WG9 
ARG. 

CD2A81G, CD2A83G, CD2A84M & N, & CD50110 

These tests assume that dependent tasks will terminate while the main 
program executes a loop that simply tests for task termination; this is 
not the case, and the main program may loop indefinitely (lines 74, 85, 
86 & 96, 86 & 96, and 58, resp.). 


D-1 









CD2B15C & CD7205C 

These tests expect that a 'ST0RAGE_S12E length clause provides precise 
control over the number of designated objects in a collection; the Ada 
standard 13.2:15 allows that such control must not be expected. 

CD2D11B 

This test gives a SMALL representation clause for a derived fixed-point 
type (at line 30) that defines a set of model numbers that are not 
necessarily represented in the parent type; by Commentary Al-00099, all 
model numbers of a derived fixed-point type must be representable values 
of the parent type. 

CD5007B 

This test wrongly expects an implicitly declared subprogram to be at the 
address that is specified for an unrelated subprogram (line 303). 

ED7004B, ED7005C & D. ED7006C & D [5 tests] 

These tests check various aspects of the use of the three SYSTEM 
pragmas; the AVO withdraws these tests as being inappropriate for 
validation. 

CD7105A 

This test requires that successive calls to CALENDAR.CLOCK change by at 
least SYSTEM.TICK; however, by Commentary AI-00201, it is only the 
expected frequency of change that must be at least SYSTEM.TICK -- 
particular instances of change may be less (line 29). 

CD7203B, & CD7204B 

These tests use the 'SIZE length clause and attribute, whose 
interpretation is considered problematic by the WG9 ARG. 

CD7205D 

This test checks an invalid test objective: it treats the specification 
of storage to be reserved for a task's activation as though it were like 
the specification of storage for a collection. 

CE2107I 

This test requires that objects of two similar scalar types be 
distinguished when read from a file--DATA_ERROR is expected to be raised 
by an attempt to read one object as of the other type. However, it is 
not clear exactly how the Ada standard 14.2.4:4 is to be interpreted; 
thus, this test objective is not considered valid. (line 90) 

CE3111C 

This test requires certain behavior, when two files are associated with 
the same external file, that is not required by the Ada standard. 

CE3301A 

This test contains several calls to END_OF_LINE & END_OF_PAGE that have 
no parameter: these calls were intended to specify a file, not to refer 
to STANDARD_INPUT (lines 103, 107, 118, 132, & 136). 


D-2 






CE3411B 

This test requires that a text file's Column number be set to COUNT'LAST 
in order to check that LAYOUT_ERROR is raised by a subsequent PUT 
operation. But the former operation will generally raise an exception 
due to a lack of available disk space, and the test would thus encumber 
validation testing. 

E28005C 

This test expects that the string TOP OF PAGE. --63" of line 204 
will appear at the top of the listing page due to a pragma PAGE in line 
203; but line 203 contains text that follows the pragma, and it is this 
that must appear at the top of the page. 


D-3 








Compiler; 

ACVC Version: 


APPENDIX E 

COMPILER OPTIONS AS SUPPLIED BY 
DDC-I, Inc 

DACS for Sun-3 -> Lynwood/LynX, Version 
4.4 (1.1) 

1.10 


OPTION 


EFFECT 




26 


Sun-3/SunOS - User's Guide 
The Ada Compiler 


5 The Ada Compiler 

The Ada Compiler is invoked by specifying a call of the program 
Ada to the shel^ The invocation command is described in 
Section 5.1. cT-tkj. 

If any diagnostic messages are produced during the compilation, 
they are output on the diagnostic file and on the standard out¬ 
put. The diagnostic file and the diagnostic messages are 
described in Sections 5.1.3 and 5.3.5. 

The user may request additional listings to be output on a list 
file by specifying options in the compiler invocation. .The 
list file and the listings are described in Sections 5.1.2 and 
5.3. 

The compiler uses a program library during the compilation. 
The compilation unit may refer to units from the program 
library, and an internal representation of the compilation unit 
will be stored in the program library as a result of a success¬ 
ful compilation. The program library is described in Chapter 
3. Section 5.4 briefly describes how the Ada compiler uses the 
library. 


5.1 The Invocation Command 


The invocation command has the following syntax: 

ada <source-flle-name> C<source-file-narae>3 


Options 


-L 

-1 


-X 


Causes the compiler to produce a formatted 
listing of the input source. The listing is 
written on the list file. Section 5.3.2 con¬ 
tains a description of the source listing. 
The default is no list file, in which case no 
source listing is produced, regardless of any 
LIST pragmas in the program or any diagnostic 
messages produced. 

Causes the compiler to produce a cross- 
reference listing. If this option is given 
and no severe or fatal errors are found during 
the compilation, the cross-reference listing 
will be written on the list file. The cross- 
reference listing la described In Section 
5.3.4. The default excludes cross-reference. 




M (0 


27 


Sun-3/SunOS - User's Guide 
The Ada Compiler 


-p Progress-report. 

-a <lib_spec> Specifies the current sublibrary, and there¬ 

fore the program library.. If this option is 
omitted the sublibrary designated by the en¬ 
vironment variable ADA_LIBRARY is used. If 
the variable does not exist the file 
ADA_LIBRARY is used. Section 5.4 describes how 
the Ada compiler uses the libraory. 

-c <file_name> Specifies the configuration file to be used by 

the compiler in the current compilation. If 
this option is omitted the configuration file 
(config) in the compiler directory is used. 

Specifies that the source text is not to be 
saved in the program library. This saves some 
space in the sublibrary. The default is to 
save source text. In this way, the user is al¬ 
ways certain what version of the source text 
was compiled. The source text may be displayed 
from the sublibrary with the PLU Type command. 

-B Build standard. Pseudo compilation of package 

standard. This option is intended for main¬ 
tenance purposes only. 

-n No check. Suppress all run-time checks. By 

default, all run-time checks are generated. 

-N <keyword> C,<keyword>} 

Toggle check. Selective suppress of run-time 
checks. If a check is suppressed, the option 
will enable the check. If a check is enabled, 
the option will suppress the check. The fol¬ 
lowing keywords are allowed: 

- access 

- index 

- discriminant 

- range 

- length 

- elaboration 

- storage 

Keywords are case-insensitive and can be ab¬ 
breviated such that the abbreviation is 
unique. 





28 


Sun-3/SunOS - User's Guide 
The Ada Compiler 


-o Optimize. Optimize the program with respect to 

execution time, which, under normal clr* 
cxiinstances, also Is optimization with respect 
to size of the executable. 

-O <keyword> C,<keyword>} 

Toggle optimization. The correspondence be¬ 
tween keywords and optimization Is as follows: 


Keyword 


Optimization 


Block 

Peep 

Cse 

Reordering 

Stackheight 

Fct2proc 


Optimize block and call frames. 
Peephole optimization. 

Common subexpressions elimination. 
Optimize aggregates and procedure 
calls. 

Minimize stack height. 

Change functions to procedures. 


The keywords are case-insensitive and can be ab¬ 
breviated such that the abbrivation is unique. 


-u <unit_number> Specifies that the compilation unit being com¬ 
piled is assigned the unit number 
<unit__number> in the current sublibrary (see 
section 3.2.2 for explanation of unit 
numbers). This option will only work for: 


- compilations containing a single compilation 
unit which is neither a subunit nor contains 
subunit stubs. 


- unit numbers which are unused and follow the 
formula <\init_n\amber> div 4096 » 

<subllbrary_level_number> where div is in¬ 
teger division and <sublibrary_level_number> 
is counted from the root to the current sub¬ 
library by assigning the root the level 
number: 0 (zero). Thus legal unit numbers 
for the root sublibrary are 0...4095, for a 
child sublibrary of the root: 4096...8191 
and so on. 


Parameters 


The <source-file-name> specifies the file containing the source 
texts to be compiled. A source file is expected to have the 
string ".ada” as the last four characters of its name. If the 
last part of the name does not contain the string ".ada" 



29 


Sun-3/SunOS - User's Guide 
The Ada Compiler 


is appended to the name. Mora than one file name must be 
specified. 


5.1.1 The List File 

The name of the list file is identical to the name of the 
source file except that the final characters ".ada" are re¬ 
placed by ".lis". The list file will be placed in the current 
directory. The contents of the list file are described in 
Section 5.3. 


5.1.2 _ The Diagnostic File 

The name of the diagnostic file is identical to the name of the 
source file except that the final characters ".ada" are re¬ 
placed by ".err". The diagnostic file will be placed in the 
invoker's current directory. 

The diagnostic file is a file containing a list of diagnostic 
messages, each followed by a line showing the number of the 
line in the source that caused the message to be generated, and 
then by a blank line. The file is not separated into pages and 
there are no headings. 


5.1.3_The Configuration File 


Certain functional characteristics of the compiler may be 
modified by the user. These characteristics are passed to the 
compiler by means of a configuration file, which is a text 
file. The contents of the configuration file must be an Ada 
positional aggregate, written on one line, of the type 
CONFIGURATION_RECORD, which is described below. The con¬ 
figuration file is not accepted by the compiler in the follow¬ 
ing cases: 

- The syntax does confoxrm with the syntax for positional Ada 
aggregates. 

- A value is outside the ranges specified below. 

- A value is not specified as a literal. 

- LINES PER PAGE is not greater than TOP_MARGIN + 
BOTTOM__MARGIN. 

- The aggregate occupies more than one line. 






