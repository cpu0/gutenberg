
TO 

FINAL REPORT 
FOR THE 

SYSTEM ENGINEERING AUTOMATION (SEA) 
FOR DISTRIBUTED SYSTEMS 

CONTRACT NO. N00014-91-C-0183 
CDRL SEQUENCE NO. A002 

AUGUST 1992 


Prepared for: 

Department of the Navy 
Office of Naval Research 
Code 1211 

Arlington, VA 22217-5000 


Thii doi''’meiit Ijos been approved 
for public icleose and sale; its 
distribution is unlimited. 


92 9 03 091 


A'' 

f . 


92-24695 







Final Report for Contract No.: N000I4-91-C-0183 


LIST OF APPENDICES 


Appendix A: 
Appendix B: 
Appendix C: 
Appendix D: 
Appendix E: 
Appendix F: 
Appendix G; 
Appendix H; 


Ada Specifications for Representing Logical Model. A1-A12 

C++ Specifications for Representing Logical Model. B1-BI3 


Ada Specifications for Representing Implementation Model.... Cl- C30 
C++ Specitications for Representing Implementation Model.... D1 - D27 
Ada Specifications for Representing System Design Factors .... El - E5 
C++ Specifications for Representing System Design Factors .... FI - F5 
Routines Supporting DESTINATION Interface Specification ... G1 - G20 
DESTINATION Interface Specification File Formats. H1-H19 


DTIC QUALITY INSPECTED 3 


Accesion Fo; 


NTIS CRA&I 

DTIC TAB 

U..jrif;ouficed 

J.jotificdtion 

. 1 

By 

Diit ibution / 


Avdikibiity Code?. 


! Avail and'or 
bpacial 

A"! 



Statement A per telecon James Smith 
ONR/Code 1267 
Arlington, VA 22217-5000 

NWW 9/16/92 


Computer Command and Control Company 












FINAL REPORT 


APPENDIX A 

ADA SPECIFICATIONS FOR REPRESENTING LOGICAL MODEL 


SYSTEM ENGINEERING AUTOMATION (SEA) 
FOR DISTRIBUTED SYSTEMS 

CONTRACT NO. N00014-91-C-0183 
CDRL SEQUENCE NO. A002 


AUGUST 1992 










with tej;t_io; 
use Text_io; 

package DIS_logical_model is 


DIS DECLARATIONS - LOGICAL MODEL. 


MaxProcesses ; INTEGER := 100; 

MaxConditions : INTEGER ;= 100; 

MAX.LENGTH : INTEGER ;= 100; 

— Should be set to the desirable number. 

subtype TBD is INTEGER; 

— (To be determined) and assigned appropriate type or value. 
— This is only for compilation purposes. 

subtype diagram_id_type is INTEGER; 

— Is used to identify the flow diagram. 

subtype tool_id_type is INTEGER; 

— Is used to identify the tool. 

subtype DIS_flow_objectJd_type is INTEGER; 

— Is used to identify the flow object. 

subtype DIS_flow_edge_id_type is INTEGER; 

— Is used to identify the flow edge. 

subtype DIS_transition_id_type is INTEGER; 

— Is used to identify the transition. 

subtype DIS_state_id_type is INTEGER; 

— Is used to identify the state. 

subtype DIS_process_id_type is INTEGER; 

— Is used to identify the process. 


A-l 














—/* LOGICAL MODEL */ 

—/* */ 
—/* As stated, the logical model describes the functional and */ 

—/* behavioral views of the system. The emphasis within this design */ 

—/* capture model is on what the system should do as opposed to how */ 

—/* it should do it. The logical model contains informations */ 

—/* representing functional decomposition of system and the */ 

—/* interactions between the decomposed functions of the system */ 

—/* through the functional view, and the dynamic operations of the */ 

—/* decomposed functions at a different Lime under the different */ 

—/* situations and conditions through the behavioral view of the *1 

—/* system. */ 


type DIS_logical_view_type; 

type DIS_logical_view_ptr is access DIS_logical_view_type; 

— This is an open declaration for DIS logical view type 

— to make a pointer to the dynamic storage location in memory. 

type DIS_functional_view_type; 

type DIS_functional_view_ptr is access DIS_functional_view_type; 

— This is an open declaration for DIS functional view type 

— to make a pointer to the dynamic storage location in memory. 

type DIS_behavioral_view; 

type DIS_behavioral_view_ptr is access DIS_behavioral_view; 

— This is an open declaration for DIS behavioral view type 

— to make a pointer to the dynamic storage location in memory. 


type DIS_logical_view_type is 








*/ 

*! 

*! 


—/* Declaration for the logical model 

_/♦- 

record 

functional_view_list : DIS_functional_view_ptr; 

— Pointer to the functional view. 

behavioral_view_list : DIS_behavioral_view_ptr; 

— Pointer to the behavioral view. 

logical_view_previous : DIS_logical_view_ptr; 

— Pointer to the previous logical view. 

logical_view_next : DIS_logical_view_ptr; 

— Pointer to the next logical view. 

end record; 


—I* */ 

—/* FUNCTIONAL VIEW *i 

—/* */ 

—/* The functional view encapsulates the information captured when */ 

—/* following the conventional structured analysis methodology for */ 

—/* systems analysis. This view describes the system structure in */ 

—/* such a way how functions in the system are decomposed and how */ 

—/* interact with each other. The representation of this view is */ 

—/* graphical and hierachical such that the system engineers can */ 

—/* analyze the functional strcuture of the system. 

—/* Additionally, this view specifies the non-functional aspects */ 

—/* of the system with System Design Factor. */ 


type DIS_flow_diagram_type; 

type DIS_flow_diagram_ptr is access DIS_flow_diagram_type; 

— This is an open declaration for DIS flow diagram type 
— to make a pointer to the dynamic storage location in memory. 


type DIS_functional_view_type is 

_/*_ --- */ 

—/* Each functional view contains a list of the flow diagram and */ 

—/* pointers of the linking relations. */ 

_/*- V 






record 

flow_diagram_list : DIS_flow_diagram_ptr; 

— Pointer to a list of the flow diagram. 

parent_logical_view : DIS_logical_view_ptr; 

— Pointer to a list of parent logical view. 

functional_view_next : DIS_functional_view_ptr; 

— Pointer to the next available functional view. 

functional_view_previous : DIS_functionai_view_ptr; 

— Pointer to the previous available functional view. 

end record; 

type DIS_flow_object_type; 

type DIS_flow_object_ptr is access DIS_flow_object_type; 

— This is an open declaration for DIS flow object type 

— to make a pointer to the dynamic storage location in memory. 

type DIS_flow_edge_type; 

type DIS_flow_edge_ptr is access DIS_flow_edge_type; 

— This is an open declaration for DIS flow edge type 

— to make a pointer to the dynamic storage location in memory. 

type DIS_flow_diagram_type is 


—I* --- *! 

— I* The flow diagram is a directed graph represented by the */ 

—/* flow objects and flow edges, where the flow object implies *! 

—/* a decomposed function of the system and the flow edges does */ 

— I* the interactive relation between the flow object. */ 

_/* - */ 


record 

diagramed : diagram_id_type; 

diagram_name ; string(l..MAX_LENGTH); 

— Identifier and name of the flow diagram 

diagram_tool_id : tool_id_type; 

— Identifier of the tools needed for this flow diagram. 

object_list : DIS_flow_object_ptr; 

— Pointer to the list of the flow objects belonging to this 

— flow diagram. 

flow_edge_list : DIS_flow_edge_ptr; 

— Pointer to the list of the flow edges belonging to this 

— flow diagram. 


A-4 



parent_functional_view : DIS_functionaI_view_ptr; 

—Pointer to the parent functional view. 
previous_flow_diagram : DIS_flow_diagram_ptr; 

— Pointer to the previous available flow diagram. 

next_flow_diagram ; DIS_flow_diagram_ptr; 

— Pointer to the next available flow diagram, 
end record; 

type DIS_object_type is 

*1 
*1 
*1 

(FunctionalBubble, 

— Functional descriotion 

Table, 

— Internal table 
Database, 

— Database system 
Note, 

— Display/report generation 

HumanOperator, 

— People 

ExtemalAgent 

— Evironment 


_/* - 

—/* Types of the flow object. 

_/* - 


type DIS_flow_object_type is 

_/* - */ 

—/* A flow object represents a decomposed function of the */ 

—/* system and contains the flow object informations as follow: */ 

—/* */ 

—/* 1. The hierachical, sibling and nesting relations between */ 

—/* flow objects. */ 

— /* 2. The nested flow object list including their flow edges. */ 

_/* - */ 


record 





objecijd ; DIS_flow_objectJd_type; 

object_name : siring(l..MAX_LENGTH); 

— Indentifier and name of flow object. 

object_type : DIS_objeci_type; 

— Type of the flow object. 


object_view_level : integer; 

— View level specifies how deep it is from the root level. 

— It implies the decomposition level of the system. 


object_flow_edge_list ; DIS_flow_edge_ptr; 

— Pointer to a list of the nested flow edges. 

object_children_list : DIS_flow_object_ptr; 

— Pointer to a list of the nested flow objects. 

parent_flow_diagram : DIS_flow_diagram_ptr; 

—Pointer to the parent flow diagram. 


object_parent : DIS_flow_object_ptr; 

— Pointer to the parent flow object. 


next_flow_object : DIS_flow_object_ptr; 

previous_flow_object : DIS_flow_object_ptr; 

— Pointers to the next and previous available flow objects. 


object_description ; TBD; 

— Description of the flow object. 

object_design_charactization_list : TBD; 

— List of the flow object characterization. 


object_design_factor_list : DIS_SDF_Template; 

— List of the flow object design factor. 


end record; 


type flow_type is 

—I* - 

—/* Types of the flow object. 

_/* - 


(Control, 

— This edge represents control flow information. 
Data, 

— this edge represents datalflow information. 


*/ 

*/ 

*! 


A-6 


Analog 

— this edge represents analog data. 


); 


type DIS_flow_edge_attributes_type; 

type DIS_flow_edge_attributes_ptr is access DIS_flow_edge_attributes_type; 
— This is an open declaration for DIS flow edge attribute type 
— to make a pointer to the dynamic storage location in memory. 

type DIS_flow_edge_type is 


—/*- 




-*/ 

—/♦ 

A 

ilow 

edge represents the relation between decomposed 

*! 

—/* 

functions 

of the system or the flow objects in the flow 

*/ 

—!* 

diagram 

and contains the following flow edge informations: 

*! 

—1* 




*/ 

—/* 

1. 

The 

hierachical, sibling relations between flow edges. 

*/ 

—/* 

2. 

The 

direction of the flow under the predefined conditions. 

*/ 

—!* 

3. 

The 

additional flow edge information including design 

*! 

—!* 


factor, such as frequency, duration, unit, acuuracy, etc. 

*1 

_/♦_ 




■*l 


record 

flow_edge_id : DIS_flow_edge_id_type; 

flow_edge_name : string(l..MAX_LENGTH); 

— Identifier and name of the flow edge. 

flow_edge_typ : flow_type; 

— Type of the flow edge. 

flow_edge_from : DIS_flow_object_ptr; 

flow_edge_to : DIS_flow_object_ptr; 

— Pointers to the flow objects from which this flow 
— edeg starts and to which this edge ends. 

flow_edge_condition : string(l..MAX_LENGTH); 

— Condition of the flow. 

flow_edge_attributes ; DIS_flow_edge_attributes_ptr; 

— Pointer ot the flow edeg attributes. 

flow_edge_design_factor_list: DIS_SDF_Template_pir 
—Pointer to a list of system design factor for flow edge. 
parent_flow_diagram : DIS_flow_diagram_ptr; 

—Pointer to parent flow_diagram. 
previous_flow_edge DIS_flow_edge_ptr: 


next_flow_edge ; DIS_flow_edge_ptr; 

—Pointers to the next and previous available flow edges. 


end record; 

type DIS_flow_edge_atiributes_type is 
record 

flow_edge_id : DIS_flow_edge_id_type; 

flow_edge_name : string(l..MAX_LENGTH); 

— Identifier and name of the floe edge attributes. 

flow_edge_frequency : TBD; 

fIow_edge_duration : TBD; 

flow_edge_unit : TBD; 

flow_edge_range : TBD; 

flow_edge_increment ; TBD; 

flow_edge_accuracy : TBD; 

flow_edge_format : TBD; 

— Attributes of the flow edge and their types will be defined 

— in the later stage of DIS development. These are only 

— compilation purpose. 

parent_flow_edge : DIS_flow_edge_ptr; 

—Pointer to the parent flow edge. 

end record; 

*/ 
*1 
*1 
*! 
*/ 
*! 
*/ 
*1 
*/ 
*1 
*1 
*( 

type DIS_state_transition_diagram; 

type DIS_state_transition_diagram_ptr is access DIS_state_transition_diagram; 

— This is an open declaration for DIS state transition type 
— to make a pointer to the dynamic storage location in memory'. 


—I* BEHAVIORAL VIEW 

_/* 

— I* The behavioral view describes the dynamic behavior of the 
—/* system under the controls. This view captures the operations 
— I* of the system at a diffrent time under the different situations 
— I* and conditions. Similar to the functional view of the system, 

—/* this behavioral view represents states of the system and their 

—/* transitions as well as the process activations in a graphical 
—/* and hierachical way, such that the system engineers can analyze 

—/* the bahavioral construction of real-time informations of the 

—/* system, such as deadline and reconfiguration. 









type DIS_process_acuvation_table; 

type DIS_process_activation_table_ptr is access DIS_process_activation_tabIe; 
— This is an open declaration for DIS process activation table type 
— to make a pointer to the dynamic storage location in memory. 


type DIS_behavioral_view is 

_/* - *! 

—Each behavioral view contains state transition diagram and */ 

— I* process activation table. */ 

_/* - */ 


record 

state_transition_diagram : DIS_state_transition_diagram_ptr; 

— Pointer to the state transition diagram. 

process_activation_table : DIS_process_activation_table_ptr; 

— Pointer to the process activation table. 

parent_logical_view ; DIS_Iogical_view_ptr; 

—Pointer to parent logical view. 

next_behavioral_view : DIS_behavioral_view_ptr; 

previous_behavioral_view 

—Pointers to the next and previous behavioral views, 
end record; 
type DIS_state_type; 

type DIS_state_ptr is access DIS_state_type; 

— This is an open declaration for DIS state type 

— to make a pointer to the dynamic storage location in memory. 

type DIS_transition_type; 

type DIS_transition_ptr is access DIS_transition_type; 

— This is an open declaration for DIS transition table type 

— to make a pointer to the dynamic storage location in memory. 


type DIS_state_transition_diagram is 

—I* -*/ 

— I* Each state transition diagram is a directed graph, in */ 

— I* which nodes represent the states of the system and edges */ 

—/* represent state transitions under the different situations */ 

—/* and conditions. */ 

—I* -*/ 




record 

statejist 

— Pointer to a list of the states. 
transition_list 

— Pointer to a list of the transitions. 


DIS_state_ptr; 

DIS_transition_ptr; 


next_state_transition_diagrani 
previous_state_transition_diagram 

— Pointer to the next and previous available state transition 

— table. 


DIS_state_Lransition_diagram_ptr; 

DIS_state_transition_diagram_ptr; 


parent_behavioral_view 
—pointer to parent behavioial view. 

end record; 

type DIS_state_type is 

_y*- 


DIS_bevioral_view_ptr; 


-/* 

-!*- 


Type of State. 


record 

statejd 

state_nanie 

— Identifier and name of the state. 


: DIS_stateJd_type; 

: string(l..MAX_LENGTH); 


outgoing_edge_list : DIS_transition_ptr; 

— Pointer to a list of the transitions which start from 

— this state. These transitions are represented as edges. 

next_state : DIS_state_ptr; 

previous_state : DIS_state_ptr; 

— Pointers to the next and previous available states. 


*/ 

*/ 

*/ 


parent_state_transition_diagram ; DIS_state_transition_diagram_ptr; 

—Pointer to parent state transition diagram. 

end record; 

type DIS_transition_type is 

_/* - 

—I* 

_/♦ - 


Type of Transition. 


*/ 

*/ 

*/ 


A-IO 






record 

transitionjd : DIS_transition_id_type; 

transition_name : string(l..MAX_LENGTH); 

— Identifier and name of the transition. 

transition_from_state : DIS_state_id_type; 

transition_to_state : DIS_state_id_type; 

— Pointers to the states from which this transition starts 

— and to which this transition ends. 

transition_enable_condition : string(l..MAX_LENGTH); 

transition_output_condition : string(l..MAX_LENGTH); 

— Each transition may be labelled with enabling condition 

— (i.e. input) and output condition, which becomes true 

— as a result of taking this transition. 

next_transition : DIS_transition_ptr: 

previous_transition : DIS_transition_ptr; 

— Pointers to the next and previous available transitions. 

parent_state : DIS_state_ptr; 

—Pointer to parent state. 

parent_state_transition_diagram : DIS_state_transition_diagram_ptr; 

— Pointer to parent stransition diagram. 

end record; 

— Process activation table needs be further elaborated. 

type activation_table_type is array(l..MaxProcesses, L.MaxConditions) 

of INTEGER; 

— Activation table type as two dimensional arrays defined by 

— the number of the processes and conditions. 

type DIS_process_name_id_pair_type; 

type DIS_process_name_id_pair_ptr is access DIS_process_name_id_pair_type; 

— This is an open declaration for DIS process name id pair type 

— to make a pointer to the dynamic storage location in memory. 

type DIS_process_activation_table is 

*/ 
*1 
*1 

record 

process_name_id_pair_list : DIS_process_name_id_pair_ptr; 

— Pointer to a list of process id pair. 


_/* - 

—/* Process Activation Table. 

_/♦ - 


A-II 




activauon_table 

— Pointer to the activation table. 

parent_behavioraI_view 
pointer to parent behavioral view. 

end record; 

type DIS_process_nanie_id_pair_type is 


activation_table_type: 


DIS_behavioral_view_ptr; 


—/*- 

—I* 

—!*- 


Process name id pair type. 


record 

process_name : string(l..MAX_LENGTH); 

processjd : DIS_process_id_type; 

— Identifier and name of the process name id pair type. 

next_process_name_id_pair ; DIS_process_name_id_p^ir_ptr; 

previous_process_name_id_pair : DIS_process_name_id_pair_ptr; 

— Pointers to the next and previous available pais. 

patent_activation_table : DIS_process_activation_table_ptr; 

—Pointer to parent process activation table. 


*! 

*1 

*1 


end record; 
end DIS_logical_model; 


A-12 







FINAL REPORT 


APPENDIX B 

C++ SPECIFICATIONS FOR REPRESENTING LOGICAL MODEL 


SYSTEM ENGINEERING AUTOMATION (SEA) 
FOR DISTRIBUTED SYSTEMS 

CONTRACT NO. N00014-91-C-0183 
CDRL SEQUENCE NO. A002 


AUGUST 1992 






#inclu(le <stdio.h> 

#include <string.h> 

#include ”DIS_system_design_factor.c” 

n DIS DECLARATION-LOGICAL MODEL 

int MaxProcesses = 100; 
int MaxConditions = 100; 
int MAX.LENGTH = 100; 

// Should be set to the desirable number. 

typedef int TBD; 

// (To be determined) and assigned appropriate type or value. 
// This is only for compilation purposes. 

typedef int diagram_id_type; 

// Is used to identify the flow diagram. 

typedef int tool_id_type; 

// Is used to identify the tool. 

typedef int DIS_flow_objectJd_type; 

// Is used to identify the flow object. 

typedef int DIS_flow_edge_id_type; 

// Is used to identify the flow edge. 

typedef int DIS_transition_id_type; 

// Is used to identify the transition. 

typedef int DIS_state_id_type; 

// Is used to identify the state. 

typedef int DIS_process_id_type; 

// Is used to identify the process. 

class String { public: String () {}; // constructor 
private: int len; char *str; 

}; //String class for naming structures 


B- l 





/* LOGICAL MODEL 

I* 

/* As stated, the logical model describes the functional and 
/* behavioral views of the system. The emphasis within this design 

/* capture model is on what the system should do as opposed to how 

/* it should do it. The logical model contains informations 

/* representing functional decomposition of system and the 
/* interactions between the decomposed functions of the system 
/* through the functional view, and the dynamic operations of the 

/* decomposed functions at a different time under the different 
/* situations and conditions through the behavioral view of the 

/* system. 

/*===================================================================== 


*/ 

*1 

*/ 

*1 

*/ 

*1 

*! 

*1 

*/ 

*/ 

*/ 

*! 

*/ 

*/ 


class DIS_functional_view; 

// This is an open declaration for DIS functional view class 
// to make a pointer to the dynamic storage location in memory. 


class DIS_behavioral_view; 

// This is an open declaration for DIS behavioral view class 
// to make a pointer to the dynamic storage location in memory. 


class DIS_logical_view { 
/*============================== 

/♦Declaration for the logical model 

/* - 

DIS_functional_view 


*functional_view_list; 

// Pointer to the functional view. 



DIS_behavioral_view 


*behavioral_view_list; 

// Pointer to the behavioral view. 


DIS_logical_view 

DIS_logical_view 


}; 


*next_logical_view; 

*previous_logical_view; 

// Pointers to the next and 
// previous available logical view. 


B- 2 








FUNCTIONAL VIEW 


I* 

I* 


I* 

/* The functional view encapsulates the information captured when 
/* following the conventional structured analysis methodology for 

/* systems analysis. This view describes the system structure in 

/* such a way how functions in the system are decomposed and 

/* interact with each other. The representation of this view is 

/* graphical and hierachical such that the system engineers can 

/* analyze the functional strcuture of the system. 

/* Additionally, this view specifies the non-functional aspects 
/* of the system with System Design Factor. 


how 


class DIS_flow_diagram; 

// This is an open declaration for DIS flow diagram class 
// to make a pointer to the dynamic storage location in memory. 


*/ 

*/ 

*/ 

*/ 

*1 

*1 

*! 

*! 

*/ 

*/ 

*/ 

*/ 

*/ 


class DIS_functional_view { 

/♦ - */ 

/* Each functional view contains a list of the flow diagram and */ 
/* pointers of the linking relations. */ 

/* - */ 


DIS_flow_diagram 


DIS_logical_view 


DIS_functional_view 

DIS_functional_view 


}; 


*flow_diagram_list; 

// Pointer to a list of the flow 
// diagram. 


*parent_logical_view; 

// Pointer to a list of parent 
// logical view. 

*next_functional_view; 

*previous_functional_view; 

// Pointers to the next and previous 
// available functional view. 


class DIS_flow_object_type; 

// This is an open declaration for DIS flow object class 

// to make a pointer to the dynamic storage location in memory. 









class DIS_flow_edge_type; 

// This is an open declaration for DIS flow edge class 

// to make a pointer to the dynamic storage location in memory. 


class DIS_flow_diagram { 

/* - */ 

/* The flow diagram is a directed graph represented by the */ 

/* flow objects and flow edges, where the flow object implies */ 

/* a decomposed function of the system and the flow edges does */ 

/* the interactive relation between the flow object. */ 

/* ----- */ 


diagram_id_type 

String 


tool_id_type 


DIS_flow_object_type 


DIS_flow_edge_type 


DIS_functional_view 


DIS_flow_diagram 

DIS_flow_diagram 


}; 


diagramjd; 

diagram_name(MAX_LENGTH); 
// Identifier and name of the 
// flow diagram 

diagram.tooljd; 

// Identifier of the tools needed 
// for this flow diagram. 

*object_list; 

H Pointer to the list of the flow 
// objects belonging to this flow 
// diagram. 

*flow_edgeJist; 

// Pointer to the list of the flow 
// edges belonging to this flow 
// diagram. 

*parent_funciional_view; 

// Pointer to the parent 
// functional view. 

*next_flo w_diagram; 
*previous_now_diagram; 

// Pointer to the previous 
// available flow diagram. 


B- 4 







Types of the flow object. 


*! 

*1 

*/ 


enuni DIS_object_type ( 

/* - 

/* 

I* - 

FunctionalBubble, 

// Functional description 

Table, 

// Internal table 
Database, 

// Database system 
Note, 

// Display/report generation 

HumanOperator, 

// People 

ExtemalAgent 
// Evironment 


*1 

*1 
*! 
*/ 
*1 
*1 
*1 

DIS_flow_objectJd_type objectjd; 

String object_name(MAX_LENGTH); 

// Indentifier and name of 
// flow object. 

DIS_object_type object_type; 

// Type of the flow object. 

int object_view_lever. 

// View level specifies how deep 
// it is from the root level. 

// It implies the decomposition 
// level of the system. 


class DIS_flow_object_type { 

/*- 

/* A flow object represents a decomposed function of the 

/* system and contains the flow object informations as follow: 

I* 

/* 1. The hierachical, sibling and nesting relations between 

/* flow objects. 

/* 2. The nested flow object list including their flow edges. 

/* - 


B- 5 





DIS_flow_edge_type 


DIS_flow_object_type 


DIS_flow_diagram 


DIS_flow_object_type 


DIS_flow_object_type 

DIS_flow_object_type 


TBD 

TBD 


DIS_SDF_Template 


}; 


*object_flow_edge_list; 

// Pointer to a list of the nested 
// flow edges. 

*children_object_list; 

// Pointer to a list of the nested 
// flow objects. 

*parent_flow_diagram; 

// Pointer to the parent flow 
// diagram. 


*parent_object; 

// Pointer to the parent flow object. 

*next_flow_object; 

*previous_flow_object; 

// Pointers to the next and previous 
// available flow objects. 

object_description; 

// Description of the flow object. 

object_design_characterization_list; 

// List of the flow object 
// characterization. 

object_design_factor_list; 

// List of the flow object design 
// factor. 


*1 
*/ 
*1 

Control, 

// This edge represents control flow information. 

Data, 

// This edge represents datalflow informatio. 

Analog 


enum flow_type ( 

/* - 

/* Types of the flow object. 

/* - 


B- 6 





// This edge represents analog data. 


); 


class DIS_flow_edge_attributes_type; 

// This is an open declaration for DIS flow edge attribute class 
// to make a pointer to the dynamic storage location in memory. 


class DIS„flow_edge_type { 

I *.—- *! 

/* A flow edge represents the relation between decomposed */ 

/* functions of the system or the flow objects in the flow */ 

/* diagram and contains the following flow edge informations; */ 

/* */ 

/* 1. The hierachical, sibling relations between flow edges. */ 

/* 2. The direction of the flow under the predefined conditions. */ 

/* 3. The additional flow edge information including design */ 

/* factor, such as frequency, duration, unit, acuuracy, etc. */ 

/* - */ 


DIS_flow_edge_id_type 

String 

flow_type 

DIS_flow_object_type 

DIS_flow_object_type 

String 

DIS_flow_edge_attributes_type 

DIS_SDF_Template 

DIS_flow_diagram 


flow_edge_id; 

flow_edge_name(MAX_LENGTH); 

// Identifier and name of the 
// flow edge, 

flow_edge_type; 

// Type of the flow edge. 

*flow_edge_from; 

*flow_edge_to; 

// Pointers to the flow objects 
// from which this flow edeg 
// starts and to which this edge ends. 

flow_edge_condition(MAX_LENGTH); 
// Condition of the flow. 

*flow_edge_attributes; 

// Pointer ot the flow edeg 
// attributes. 

*flow_edge_design_factor_list; 

// Pointer to a list of system 
// design factor for flow edge. 

*parent_flow_diagram; 

// Pointer to parent flow diagram. 


B- 7 




DIS_flow_edge_type 

DIS_flow_edge_type 


}; 

class DIS_flow_edge_attributes_type { 
DIS_flow_edge_id_type 
String 


TBD 

TBD 

TBD 

TBD 

TBD 

TBD 

TBD 


DIS_flow_edge_type 


}; 


*next_flow_edge: 

*previous_now_edge; 

// Pointers to the next and 
// previous available flow edges. 


flow_edge_id; 

flow_edge_name(MAX_LENGTH); 
// Identifier and name of the 
// flow edge attributes. 

flow_edge_frequency; 

flow_edge_duration; 

flow_edge_unit; 

flow_edge_range; 

flow_edge_increment; 

flow_edge_accuracy; 

flow_edge_format: 

// Attributes of the flow edge 
// and their types will be 
// defined in the later stage 
// of DIS development. These 
// are only compilation purpose. 

*parent_flow_edge; 

// Pointer to the parent flow 
// edge. 


/* BEHAVIORAL VIEW */ 

/* *! 
/* The behavioral view describes the dynamic behavior of the */ 

/* system under the controls. This view captures the operations *! 

/* of the system at a diffrent time under the different situations */ 

/* and conditions. Similar to the functional view of the system, */ 

/* this behavioral view represents states of the system and their */ 

/* transitions as well as the process activations in a graphical */ 

/* and hierachical way, such that the system engineers can analyze */ 

/* the bahavioral construction of real-time informations of the */ 

/* system, such as deadline and reconfiguration. */ 


B- 8 



class DIS_state_transiuon_diagram; 

// This is an open declaration for DIS state transition class 
// to make a pointer to the dynamic storage location in memory. 


class DIS_process_activation_table; 

// This is an open declaration for DIS process activation table class 
// to make a pointer to the dynamic storage location in memory. 

class DIS_behavioral_view { 

/* - 

/* Each behavioral view contains state transition diagram and 
/* process activation table. 

/* - 


DIS_state_transition_diagram 


DIS_process_activation_table 


DIS_logical_view 


DIS_behavioral_view 

DIS_behavioral_view 


}; 


*state_transition_diagram; 

// Pointer to the state 
// transition diagram. 

*process_activation_table; 

// Pointer to the process 
// activation table. 

*parent_logical_view; 

// Pointer to parent logical 
// view. 

*next_behavioral_view; 

*previous_behavioral_view; 

// Pointers to the next and previous 
// behaviora; views. 


*/ 

*! 

*1 

*/ 


class DIS_state_type; 

// This is an open declaration for DIS state class 

// to make a pointer to the dynamic storage location in memory. 

class DIS_transition_type; 

// This is an open declaration for DIS transition tablei class 
// to make a pointer to the dynamic storage location in memory. 


B- 9 




class DIS_state_transition_diagram { 

/* - */ 

/* Each state transition diagram is a directed graph, in */ 

/* which nodes represent the states of the system and edges */ 

/* represent state transitions under the different situations */ 

/* and conditions. */ 

/* - */ 


DIS_state_type 


DIS_transition_type 


DIS behavioral view 


DIS_state_transition_diagram 

DIS_state_transition_diagram 


}; 


*state_list; 

// Pointer to a list of the states. 

*transition_list; 

// Pointer to a list of the 
// transitions. 

*parent_behavioral_view; 

// Pointer to parent behavioral 
// view. 

*next_state_transition_diagram; 
*previous_state_transition_diagram; 
// Pointer to the next and previous 
// available slate transition table. 


class DIS_state_type { 

/* - 

/* Type of State. 
/*- 


*/ 

*! 


DIS_state_id_type 

String 


statejd; 

state_name(MAX_LENGTH); 

// Identifier and name of the state. 


DIS_transition_type 


*outgoing_edge_list; 

// Pointer to a list of the 
// transitions which start from 
// this state. These transitions 
// are represented as edges. 


B- 10 



DIS_state_transition_diagram 


DIS_state_type 

DIS_state_type 


}; 

class DIS_transition_type { 

/* - 

/* Type of Transition. 
/*- 

DIS_transition_id_iype 

String 


DIS_state_id_type 

DIS_state_id_type 


String 

String 


DIS_state_type 


DIS_state_transition_diagrani 


DIS_transition_type 

DIS_transition_type 


}; 


*parent_state_transition_diagrani; 

// Pointer to parent state 
// transition diagram. 

*next_state; 

*previous_state; 

// Pointers to the next and previous 
// available states. 


*/ 

*! 

*1 


transitionjd; 

transition_narae(MAX_LENGTH); 

// Identifier and name of the 
// transition. 

transition ,from_state; 

"•ansition.to.'"-. , 

// Pointers lO the states from 
n which this transition starts 
// and to which this transition ends. 

transition_enable_condition(MAX_LENGH); 
transition_output_condition(MAX_LENGTH): 
// Each transition may be labelled 
// with enabling condition (i.e. input) 

// and output condition, which becomes 
// true as a result of taking this 
// transition. 

*parent_state; 

// Pointer to the parent state. 

*parent_state_transition_diagram; 

// Pointer to parent transition diagram. 

♦next_transition; 

*previous_transition; 

// Pointers to the next and previous 
// available transitions. 


B- 11 





// Process activation table needed to be further elaborated. 


typedef int activation_table_type[MaxProcesses][MaxConditions]; 

// Activation table type as two dimensional arrays defined by 
// the number of the processes and conditions. 

class DIS_process_name_id_pair_type; 

// This is an open declaration for DIS process name id pa type 
// to make a pointer to the dynamic storage location in memory. 

class DIS_process_activation_table { 

/* - 

I* 

/* - 


Process Activation Table. 


*/ 

*/ 

*/ 


DIS_process_name_id_pair_type 


activation_table_type 


*process_name_id_pair_list; 

// Pointer to a list of process id pair. 

activation_table; 

// Pointer to the activation table. 


}; 


DISbehavioral view 


class DIS _process_name_id_pair_type { 
/* - 


*parent_behavioral_view; 

// Pointer to parent behavioral view. 


/* 

/*- 


Process name id pair type. 


*1 

*/ 

*/ 


String 

DIS_process_id_type 


DIS_process_activation_table 


process_name (M AX_LENGTH); 
process_id; 

// Identifier and name of the 
// process name id pair type. 

*parent_activation_table; 

// Pointer to parent process 
// activation table. 


B-12 




DIS_process_name_id_pair_type *next_process_name_id_pair; 

DIS_process_nameJd_pair_type *previous_process_nanie_id_pair; 

// Pointers to the next and 
// previous available pair. 

}; 


DIS_logical_model () { 

} /*end of DIS_logical_model*/ 


B-I3 



FINAL REPORT 


APPENDIX C 

ADA SPECIFICATIONS FOR REPRESENTING IMPLEMENTATION 

MODEL 


SYSTEM ENGINEERING AUTOMATION (SEA) 
FOR DISTRIBUTED SYSTEMS 

CONTRACT NO. N00014-91-C~0183 
CDRL SEQUENCE NO. A002 


AUGUST 1992 




with Textjo; 
use Text_io; 

package DIS_implementation_model is 


DIS DECLARATIONS - IMPLEMENTATION MODEL. 


MAX_LENGTH : INTEGER := 100; 

— Should be set to the desirable number. 

subtype TBD is INTEGER; 

— (To be determined) and assigned appropriate type or value. 

subtype DIS_id_type is INTEGER; 

— Is used for type of indenfication. If it is necessary to 

— modify indeniifier of type, this type can be changed as 

— to the desired type. 

subtype DIS_sw_structure_diagram_id is INTEGER; 

— Is used to identify the software structure diagram. 

subtype DIS_sw_module_id is INTEGER; 

— Is used to identify the software/ module. 

subtype DIS_sw_module_edge_id is INTEGER; 

— Is used to identify the software module edge. 

subtype DIS_sw_task_id is INTEGER; 

— Is used to identify the software module task. 

subtype DIS_sw_task_edge_id is INTEGER; 

— Is used to identify the software task edge. 

subtype DIS_hw_structure_diagram_id is INTEGER; 

— Is used to identify the hardware structrure diagram. 

subtype DIS_hw_group_node_id is INTEGER; 

— Is used to identify the hardware group node. 

subtype DIS_hw_group_link_id is INTEGER; 

— Is used to identify the hardware group link. 

subtype DIS_hw_node_id is INTEGER; 

— Is used to identify the hadware node. 

subtype DIS_hw_link_id is INTEGER; 

— Is used to identify the hardware link. 

C- 1 














is INTEGER; 


subtype DIS_mapping_view_id 

— Is used to identify the mapping view. 

subtype DIS_allocation_tool_id is INTEGER; 

— Is used to identify tool id. 

subtype DIS_preference_range is INTEGER; 

— Is used to define range of the preference value. 

subtype DIS_data_attribute_id is INTEGER; 

— Is used to identify the DIS data attribute. 

subtype DIS_data_size is INTEGER; 

— Is used to represent DIS data size. 

subtype DIS_resource_amount is INTEGER; 

— Is used to represent DIS resource amount. 

subtype DIS_user_extensible_type is INTEGER; 

— Is used to represent the type of DIS_user_extensible. 

— This type will be defined in the later stage of 

— the implementation specification development. 

subtype DIS_user_extensible_value is INTEGER; 

— Is used to represent the value of DIS_user_extensible type. 
— This type will be defined in the later stage of 

— the implementation specification development. 

subtype FIELDS is string!l..MAX_LENGTH); 

— Is used to define string type, especially names. 


IMPLEMENTATION VIEW 


type DISJmplementa(ion_view ; 

type DIS_implementation_view_ptr is access DIS_implementation_view ; 

— This is an open declaration for DIS implemenation view type 

— to make a pointer to the dynamic storage location in memory. 

type DIS_sw_structure_diagram; 

type DIS_sw_structure_diagram_pir is access DlS_sw_siructure_diagram; 

— This is an open declaration for software structure diagram type 

— to make a pointer to the dynamic storage location in memory. 

type DIS_hw_structure_diagram; 

type DIS_hw_structure_diagram_ptr is access DIS_hw_structure_diagram; 










— This is an open declaration for hardware structure diagram type 
— to make a pointer to the dynamic storage location in memory. 

type DIS_mapping_view; 

type DIS_mapping_view_ptr is access DIS_mapping_view; 

— This is an open declaration for mapping view type to make 

— a pointer to the dynamic storage location in memory. 

type DIS_implementation_view is 


_/*=================================:=======================:============ *! 

—/* Declaration for the implementation model */ 

_/* - *! 


record 

sw_structure_diagram : DIS_sw_structure_diagram_ptr; 

— Pointer to the software structure diagram 

hw_structure_diagram ; DIS_hw_structure_diagram_ptr; 

— Pointer to the hardware structure diagram 

imp_mapping_list : DIS_mapping_view_ptr; 

— Pointer to the mapping view 

implementation_view_next : DIS_unplementalion_view_ptr; 

— Pointer to the next implementation view: successor view 

implementation_view_previous : DIS_implementation_view_ptr; 

— Pointer to the previous implementation view: predecessor 

— view. 

end record; 

—implementation_view_list : DIS_implementation_view_ptr; 


C- 3 







-/*= 

-I* 

-I* 

-I* 


SOFTWARE STRUCTURE 


-/* 

-/* 


— /=• 


type DIS_sw_module ; 

type DIS_sw_mo(lule_ptr is access DIS_sw_module ; 

— This is an open declaration for software module type to make 

— a pointer to the dynamic storage location in memory. 

type DIS_sw_module_edge ; 

type DIS_sw_module_edge_ptr is access DIS_sw_module_edge ; 

— This is an open declaration for software module edge type to make 

— a pointer to the dynamic storage location in memory. 

type DIS_SDF_Template; 

type DIS_SDF_Template_ptr is access DIS_SDF_Template ; 

— This is an open declaration for system design factor template 

— type to make a pointer to the dynamic storage location in memory. 

type DIS_sw_structure_diagram is 


—/* 


*/ 

*/ 

*/ 

*/ 

*/ 


/* Each software structure diagram is represented by a list of 
/* modules and a list of edges between modules. Modules can be *f 
/* nested and each module includes its own task graph. The Task */ 
graph cannot be nested since the node of a task graph cannot */ 
be a module; however, nested relations between tasks can be */ 
/* captured using nested modules. The task represents a */ 

/* computational entity. */ 


*/ 

*/ 

*/ 

*/ 


—/* The software structure diagram is used to reference a 
—/* collection of directed graphs, drawn with respect to a 
—/* selected methodology, that captures information about a set 
—/* of components and their relations along with any hierachical */ 
—/* decomposition. For example, a tree of data flow diagrams */ 
—/* may be considered as one type of structure diagram. */ 

—/* - */ 

record 


sw_structure_diagram_id 


; DIS_sw_structure_diagram_id 
sw_structure_diagram_name ; FIELDS; 

— Identifier and name of software structure diagram 


C-4 






sw_module_Ust ; DIS_sw_moclule_pir; 

— Pointer to the double-linked list of the software modules 

— as children of this software siucture diagram 

sw_module_edge_list : DIS_sw_module_edge_ptr; 

— Pointer to the double-linked list of the software module 

— edges interconnecting the children modules of this software 

— stucture diagram 

parent_implementation_view; DIS_implementation_view_pir; 

— Pointer to the parent implementation view of this software 

— structure diagram. 

next_sw_diagram : DIS_sw_structure_diagram_ptr; 

— Pointer to the next software structure diagram: successor 

previous_sw_diagram : DIS_sw_structure_diagram_ptr; 

— Pointer to the previous software structure diagram: 

— predecessor 

end record; 

type DIS_sw_task_node; 

type DIS_sw_task_node_ptr is access DIS_sw_task_node; 

— This is an open declaration for software task node type to 

— make a pointer to the dynamic storage location in memory. 

type DIS_sw_task_edge; 

type DIS_sw_task_edge_ptr is access DIS_sw_task_edge; 

— This is an open declaration for software task edge type to 

— make a pointer to the dynamic storage location in memory. 

type DIS_user_extensible; 

type DIS_user_extensible_ptr is access DIS_user_extensible; 

— This is an open declaration for user extensible variable 

— type to make a pointer to the dynamic storage location in 

— memory. 

type DIS_sw_module is 


C- 5 



_/* - */ 

— I* A software module class contains the following information: */ 

—/* *l 

—/* 1. The hierachical, sibling and nesting relations between */ 

—/* modules. */ 

—I *2. The identity of task graphs that belong to the module. */ 
—/* */ 

—/* In addition, there are two special kind of edges (called */ 

—/* entry_super_edge and exit_super_edge). They are used to */ 

—/* identify the entry and exit points of the task graph at */ 

— I* the module level. *! 

_/* - *! 


record 


module_id : DIS_sw_module_id ; 

module_name : FIELDS; 

— Identifier and name of software module 

parent_sw_structure ; DIS_sw_structure_diagram_ptr; 

— Pointer to parent software structure diagram 

parent_module : DIS_sw_module_plr; 

— Pointer to the parent software module if any 

next_module : DIS_sw_modulc_ptr; 

previous_module : DIS_sw_moduie_ptr; 

— Pointer to previous/next software modules as 

— successor/predecesso 

submodulejist ; DIS_sw_module_ptr; 

— Pointer to the list of the children submodules 

— define links between super edges of the submodules 

module_edge_list : DIS_sw_module_edge_ptr; 

— Pointer to the list of software module edge defining links 

— between super edges of the submodules 

task_node_lis : DlS_sw_task_node_ptr; 

task_edge_list : DIS_sw_task_edge_ptr; 

— Pointers to the lists of the software task nodes belongs 

— to this module and of software task edges defining links 

— between tasks: that is, the task graph. A task graph is a 

— directed graph: each node denotes a .schedulable 

— computational entity and an edge represents a precedence 

— relation between two nodes. 


C - 6 










entry_super_eclge_lis : DIS_sw_task_edge_ptr; 

exit_super_edge_list ; DIS_sw_task_edge_ptr; 

— Two special kinds of edges, called enter_super_edge & 

— exit_super_edge, are pointers to the lists of software 

— task edges that are to be visible outside the current module. 
— A super edge to an entering to or from exiting node of 

— task_graph. Each entry_super_edge and exit_super_edge are 

— either a task edge or a entry_super_edge/exit_super_edge 

— of a submodule. 

module_sdf : DIS_SDF_Template_ptr; 

— Pointer to System Design Factor Template for this module 

user_extensible_var : DIS_user_extensible_ptr; 

— Pointer to the DIS_user_extensible type 

end record; 


type DIS_sw_module_edgf" is 

_/* - - *! 

—/* The sott,»are module edge represents the link between */ 

— I* modules, and supports the hierachical orders/relations of */ 

— I* the software module organization as well as the list of */ 

— I* super edges belonging to this software module edge. */ 

- */ 


record 

module_edge_id : DIS_sw_module_edge_id ; 

module_edge_name : FIELDS; 

— Identifier and name of the software module edge 

attributes : FIELDS; 

— Attribute of the soPware module edge 

parent_sw_structure_diagram : DIS_sw_structure_diagram; 

— Pointer to the parent software suaicture diagram 

from_module ; DIS_sw_module_ptr; 

to_module : DIS_sw_module_pU'; 

— Source and destination pointer for the software module edge 

super_edge_list : DIS_sw_task_edge_ptr; 

— Point to the list of the super edges belonging to this 
— software module edge. 


C- 7 


next_tnodule_e(lge : DIS_sw_mo(lu!e_edge_ptr; 

previous_module_edge ; DIS_sw_module_edge_ptr; 

— Pointers to the next/previous module edges: 

— successor/predecessor 

module_edge_sdf : DIS_SDF_Template_ptr; 

— Pointer to the system design factor template for software 

— module edge 

user_extensible_var : DIS_user_extensible_ptr; 

— Pointer to the DIS_user_extensible type 


end record; 

type DIS_data_attribute ; 

type DIS_data_attribute_ptr is access DIS_data_attribute ; 

— This is an open declaration for software data attribute type 

— to make a pointer to the dynamic storage location in memoiy. 

type DIS_resource ; 

type DIS_resource_ptr is access DIS_resource ; 

— This is an open declaration for software resource type to 

— make a pointer to the dynamic storage location in memory. 


type t_type is (Relative,Absolute); 

_/* - */ 

—/* This specfies the type of DIS time, such that Absolute */ 

— I* represent the clock time while Relative represents relative */ 

—/* time length from some events. */ 

_/* - *! 

type DIS_time_type is 

_/* - *! 

—/* Specifies the type of DIS time and its value */ 

_/* - *! 


record 

time_kind : t_type ; 

time_value : integer; 

end record; 

type DIS_log_operators is (log_and,log_or); 


C- 8 




—/* 

This is a flag specifying the 

conditions 

for executing of 

*/ 

—/* 

a task; whether all conditions 

(or output) 

data are needed 

*/ 

—/* 

(or generated) by the certain 

task. 


*/ 

-/*- 




— */ 


type DIS_sw_task_node is 

*/ 
*/ 
*1 
*/ 
*/ 
*/ 
*1 
*/ 
*/ 
*1 
*1 
*/ 
*1 
*/ 
*1 
*1 

record 

task_id : DIS_sw_task_id ; 

task_name ; FIELDS; 

— Identifier and name of software task node 

parent_module : DIS_sw_module; 

— Pointer to the parent software module 

task_structure : TBD; 

task_description ; TBD; 

— Structure ans description of the task node will be determined 
— in later stage of development. 

task_edge_list : DIS_sw_task_edge_ptr; 

— Task_edge’s from or to this task_node 

task_input_and_or ; DIS_log_operators; 

taskjnputjist : DIS_data_attribute_ptr; 

task_output_and_or ; DIS_log_operators; 


—/* - 

—/* The software task node class specifies DIS_sw_task_node 
—/* structure. There is an input list to identify input data 
—/* and an output list to identify output data generated by 

—/* the task. In addition, predecessor list identifies tasks 

—/* that execute before the task and successor list identifies 

—/* task that execute after the task. There is an and/or flag 

—/* associated with the above four task lists that specifies 
—/* whether all input (or output) data are needed ( or 

—/* generated) by the task. This information is required by 
—/* some optimization algorithms. Each task may include timing 

—/* information such as ready time, deadline and duration. 

—/* In addiion, it identifies resources it needs. For resource 
—/* needs, resource type identifies the resource a task needs 

—/* and amount it needs. 

_/* - 


C- 9 




task_output_list 

— Data dependencies 

task_before_and_or 

task_before_list 

task_after_and_or 

task_after_list 

— Task precedence relations 

task_ready_time 

task_deadline 

task_period 

— Timing information 

task_resource_needs 

— Resource needs 

task_buddy_task 

— The cooperating tasks 

task_max_replication 

taskjmportance 

task_execution_probabiIity 

task_communication_delay_matrix 

— These fields will be defined in 


: DIS_data_attribute_ptr; 

; DIS_log_operators; 

; DIS_sw_task_node_ptr; 
: DIS_log_operators: 

; DIS_sw_task_node_ptr; 

: DIS_time_type ; 

: DIS_time_type ; 

; DIS_time_type ; 

; DIS_resource_ptr; 

: DIS_sw_task_node_ptr; 

: integer; 

; integer; 

; TBD; 

; TBD; 
later stage. 


eiTor_cumulation : integer; 

imprecise_error_convergence : integer; 

— Univ. Illinois imprecise computation support. 

next_task : DIS_sw_task_node_ptr; 

previous_task : DIS_sw_task_node_ptr; 

— Pointer to the next/previous task edges 

task_sdf ; DIS_SDF_Template_ptr; 

— Pointer to the Task Design Factor template 

user_extensible_var ; DIS_user_extensible_ptr; 

— Pointer to the DIS_user_extensible type 


end record; 

type direction is (no_way, one_way, iwo_way); 


C- 10 









—I* - *! 

— I* The direction of data flows in the task edge */ 

—I* - *! 

type DIS_sw_task_edge is 

_/* - */ 

— I* The software task edge specifies the relations between */ 

— I* software task nodes and software module nodes. For each */ 

— I* task edge, task_data_edge identifies the data associated */ 

—/* with the edge along with the duration of availability of */ 

—/* the data. In addition, from_task_node and to_task_node *! 

— I* specifies the source and destination of the edge. */ 

—I* -*/ 


record 

task_edge_id ; DlS_sw_task_edge_id; 

task_edge_name : FIELDS; 

— Identifier and name of the software task edge 

parent_module : DIS_sw_module_ptr; 

parent_module_edge ; DIS_sw_module_edge_ptr; 

— Pointer to ther parent software module and module edge 

task_edge_data : DIS_data_attribute_ptr; 

— Pointer to the data attributes associated to thisdge 

from_task_node : DIS_sw_task_node_ptr; 

to_task_node : DIS_sw_task_node_ptr; 

— Pointer to the source and destination software task node. 

flow_direction : direction; 

— Direction of the data flow in the task edge. 

next_task_edge : DlS_sw_task_edge_ptr; 

previous_task_edge : DIS_sw_task_edge_ptr; 

— Pointer to the next/previous task node in task edge list 
— where this edge belongs to. 

task_edge_sdf : DIS_SDF_Template_ptr; 

— Pointer to the system design factor template. 

user_extensible_var : DIS_user_extensible_ptr; 

— Pointer to the DIS_user_extensible type 

end record; 


C-ii 





type d is (Msg, SharedMemory); 

_ j* _*/ 

—/* The type of data based on the paradigm of message-passing */ 

—/* or shared memory. */ 

_/♦ - *! 

type DIS_data_attribute is 

_/* - *! 

—/* The data attribute specifies the type and size of data */ 

—/* being communicated through edges between tasks. It points */ 

—/* to the list Oi sender/receiver tasks specified by the list */ 

—/* of their respective edges between them. In addtion, it */ 

—/* lists the resource needed for this data attribute as well */ 

—/* as the timing constraint of data-deadline and data */ 

—/* frequency (to be defined in the later stage of the */ 

— I* development. */ 

_/* - *! 


record 

data_attribute_id ; DIS_id_type ; 

data_attribute_name : string(l..MAX_LENGTH); 

— Identifier and name of the data attributes 

data_kind ; d ; 

data_size : integer; 

— The kind and size of the data in this data attribuets. 


task_edge_list ; DIS_sw_task_edge_ptr; 

— The list of the software task edges through which data 

— being transmitted. 


sender_kind ; DISJog_operators; 

data_sender_list ; DIS_sw_task_node_ptr; 

receiver_kind : DIS_log_operators; 

data_receiver_list : DIS_sw_task_node_ptr; 

— Kind of log-operation ("and” or "or”) for senders and 
— receivers, and lists of senders and receivers. 


data_resource_need_list : DIS_resource_ptr; 

— The list of the resources needed for this data attribute 


data_frequency : TBD; 

data_eadline : DIS_time_type ; 


C-12 





— The timing constraint of data deadline and data frequency to 

— be determined in the later stage of development. 

user_extensible_var : DIS_user_extensible_ptr; 

— Pointer to the DIS_user_extensible type 

end record; 

type DIS_resource_type is (CPU, Memory, 10, Communication); 

- 

—/* Kind of resource 

_/* - 

type DIS_resource_u is (KIPS, MIPS, Bytes, KBytes, 

MBytes, Sec, Millisec, MicroSec); 


*/ 

*/ 


_/* - */ 

— I* Unit time of each resource type: */ 

— I* KIPS, MIPS, or spec marks for CPU specification, */ 

—/* Bytes, KBytes, MBytes for memory, */ 

— I* (Bytes, KBytes, MBytes) per (Sec, MiUiSec, MicroSec) */ 

—/* for 10 and communication. */ 

_/♦ - *! 

type DIS_resource_unit is 

_/* - */ 

—I ^Resource unit and its amount */ 

_/* - */ 


record 

Resource_unit 
resource_amount 
end record; 

type DIS_hw_node ; 
type DIS_hw_node_ptr is access DIS_hw_node ; 

— This is an open declaration for hardware node type to make a 
— pointer to the dynamic storage location in memory. 

type DIS_resource is 


; DIS_resource_u ; 
: integer; 


C-13 


— I* Resource specifies its size and units and pointers to the 
—!* related nodes, edges, and data attributes. It also contains 

—/* pointers to the hardware node where it can be defined by a 

—/* hi aware configuration. 

_/* - 


record 

resourcejd 
resource name 


: DIS_id_type; 
: FIELDS; 


— Resource type and unit 

resource_kind : DIS_resource_type; 

resource_units ; DIS_resource_unit; 

task_node_list ; DIS_sw_task_node_ptr; 

task_edge_list ; DIS_sw_task_edge_ptr; 

data_attribute_list : DIS_data_attribute_ptr; 

— Pointer to the taske node, edge, and data attributes 

— related to this resource or that need this resource. 


hw node list 


DIS_hw_node_ptr; 


— Hardware node being extracted from the hardware structure 

next_resource_need : DIS_resource_ptr; 

previous_resource_need : DIS_resource_ptr; 

— Pointer to the next/previous resource available or required 

— in the list. 

user_extensible_var : DIS_user_extensible_ptr; 

— Pointer to the DIS_user_extensible type 


end record; 


C-14 








_/*========================================================== *! 

—I* HARDWARE STRUCTURE *! 

—I* *1 

—/* A hardware structure diagram defines a hardware configuration. */ 

—/* Each hardware structure diagram is represented by a */ 

—/* list of group nodes and a list of group links with their */ 

—/* communication topology bewteen group nodes. Group nodes can */ 


—/* be nested and each group node includes its own hardware node */ 

—/* graph. Unlike task graph in software structure, hardware node */ 
—/* graph can be nested. Our view is that the hardware */ 

—/* node represents a hardware component in a computer architecture, */ 

—/* such as a processor, CPU, memory, 10, etc. */ 

__y*- */ 

type DIS_hw_group_link ; 

type DIS_hw_group_link_ptr is access DIS_hw_group_link ; 

— This is an open declaration for hardware group node type to make a 

— pointer to the dynamic storage location in memory. 

type DIS_hw_group_node ; 

type DIS_hw_group_node_ptr is access DIS_hw_group_node ; 

— This is an open declaration for hardware group link class to make a 

— pointer to the dynamic storage location in memory. 

type DIS_hw_group_link_topology is ( 


—/* - */ 

—/* The various ways of physically connecting hardware group */ 

—/* nodes with communications. Here are the generally known */ 

—/* types of communication topology existing today. */ 

—/* - */ 


fully_connected, 

— All group nodes are directed linked with all other 

— group nodes. 

partially_connected, 

— Some group nodes are directly linked with some other 

— groups nodes, but not all. 

hierachical, 

— Group nodes are organied or linked as s tree, 
star, 

— One of the group nodes is connected to all other group 

— nodes. Node of the other nodes are connected to each other. 


C-15 







ring, 

— Each group node is phisically connected to exactly two other 

— group nodes. 

multi_access_bus); 

— There is a single shared hardware group links. All group 

— node in the system are directly connected to that group link. 


type DIS_hw_structure_diagram is 

_/* - */ 

—/* Each view of DIS_hardware_structure consists of */ 

—/* - a list of group node, *! 

—/* - a list of group edges and communication */ 

—/* topology between group node. */ 


—/* Similar to the software module in the hierachical view, */ 
—/* group nodes can be nested recuesively. Each group node */ 


—/* may include its own hardware node graph with its */ 

— I* specific internal communication topology. Different */ 

— I* from software task node in hierachical perspective of */ 

—/* configuration, the hardware node can be nested */ 

—/* recursively. */ 

—I* - *! 


record 

hw_structure_diagram_id ; DIS_hw_structure_diagram_id; 

hw_structure_diagram_name ; FIELDS; 

— Identifier and name of hardware structure diagram 

paretnt_implementation_view : DIS_implementation_view_ptr; 

— Pointer to parent implementation model 

hw_group_node_list ; DIS_hw__group_node_ptr; 

— Pointer to the double-linked list of hardware group nodes 

— belonging to this hardware structure diagram 

hw_group_link_list : DIS_hw_oroup_link_ptr; 

— Pointer to the double-linked list of hardware group links 

— inter connecting hardware group nodes of this hardware 

— structure diagram 

hw_group_link_topology : DIS_hw_group_link_topology; 

— Communication topology of hardware group nodes 

next_hw_diagram : DIS_hw_structure_diagram_ptr; 

previous_hw_diagram : DIS_hw_sumcture_diagram_ptr; 


C-16 



— Pointers to the next/previous hardware structure diagram: 

— successor/predecessor 

end record; 

type DIS_hw_link ; 

type DIS_hw_link_ptr is access DIS_hwJink ; 

— This is an open declaration for hardware link type to make a 


— pointer to the dynamic storage location in memory. 

subtype DIS_hwJink_topology is DIS_hw_group_link_topology; 

— Internal hardware link topology 

type DIS_hw_group_node is 

- *! 

— 1* A hardware_group_node class contains the following *! 

—/* informations: */ 

— I* 1. The hierachical, sibling and nesting relations */ 

— I* between hardware group nodes */ 

—/* 2, The identity of hardware node graphs */ 

— I* that belong tothis hardware group node. */ 

— I* For both graph, the communication topology */ 


— I* can be specified. In addition, there are two special kinds */ 
— I* of links (called entry_super_link and exit_super_link). They */ 
— I* are used to identify the entry and exit points of the node *! 
— I* graph at the group node level. */ 

_y*- *! 

record 

hw_group_node_id : DIS_hw_group_node_id; 

hw_group_node_name : FIELDS; 

— Identifier and name of hardware group node 

parent_hw_structure : DIS_hw_structure_diagram_ptr; 

— Pointer to parent hardware structure diagram 

parent_hw_group_node : DIS_hw_group_node_ptr; 

— Pointer to parent fardware group node 

next_hw_group_node : DIS_hw__group_node_pU'; 

precious_hw_group_node : DIS_hw_group_node_ptr; 

— Pointer to next/previous hardware group node: 

— successor/predecessor 

sub_hw_group_node DIS_hw_group_node_ptr; 

— Pointer to list of sub-group nodes as children of this 

— group node 


C-I7 




I 

I sub_hw_ 5 roup_link : DIS_hw_group_link_ptr; 

hw_group_link_topology ; DIS_hw_group_link_iopology; 

Pointer to list of hardware group links defining physical 

— data communication link between subgroup nodes and their 

— topology 

— NODE GRAPHS belongs to this group node 

hw_node_list : DIS_hw_node_ptr; 

hw_link_list : DIS_hw_link_ptr; 

hw_node_link_topology : DIS_hw_link_topology; 

— Hardware node graph belongs to this hardware group node; 

— nodes, links, and their link topology 

entry_super_link_list : DIS_hw_link_ptr; 

exit_super_link_list : DIS_hw_link_ptr; 

— There are two special kinds of links, called 

— enter_super_link and exit_super_link, that are to be 

— visible outside the current group. A super link to an 

— entering or from exiting node of the group_node. 

— Each entry_superjink is either a hw_link or a 

— entry_super_link of a sub group node. Each exit_super_link 

— is either a hw_link or a enter_super_link of a 

— sub_group_node. 


group_node_sdf : DIS_SDF_Template_ptr; 

— Pointer to system design factor template 


user_extensible_var : DIS_user_extensible_ptr; 

— Pointer to the DIS_user_extensible type 

end record; 


type DIS_hw_group_link is 


_/* - 

— I* The hardware group link represents the physical 
—/* communication between hardware group nodes, and support 
—/* the hierachical orders/relations of the hardware group 
—/* organization with its respective topology. It also points 
— I* to the list of the super links belonging to this 
—/* hardware group link. 

_/*- 


*/ 

*! 

*1 

*/ 

*! 

*1 

*/ 

*/ 


record 


C-18 







hw_group_lirik_i(l : DIS_hw_group_link_id; 

hw_group_link_name : FIELDS; 

— Identifier and name of hardware group link 

parent_hw_structure : DIS_hw_structure_diagram_ptr; 

— Pointer to parent hardware structure diagram 

from_hw_group_node : DIS_hw_group_node_ptr; 

to_hw_group_node : DIS_hw_group_node_ptr; 

— Pointer to the source/destination of this hardware group link 

super_link_list : DIS_hw_link_ptr; 

— Pointer to list of super links belonging to this group node 

next_hw_group_link : DIS_hw_group_link_ptr; 

previous_hw_group_link : DIS_hw_^roup_link_ptr; 

— Pointers to nest/previous hardware group links; 

— successor/predecessor 

group_link_sdf : DIS_SDF_Template_ptr; 

— Pointer to system design factor template for hardware 

— group link 


user_exiensible var 


: DIS_user_extensible_ptr; 


— Pointer to the DIS_user_extensible type 


end record; 


type DIS_hw_link_g is (Bus, LAN); 


—/* The genetic type of the hardware link 

—I* - 

type DIS_hw_link_spec is (NotKnown,Ethernet,TokenRing); 


—/* The specification of the hardware link 

—I* - 

type DIS_hw_node_g is (Processor, CPU, Memory, lOchannel, Other); 


—/* The genetic type of the hardware node 
_/*- 

type DIS_hw_node_spec is (NotKnown,Sun,RISC,Sparc); 


C-19 







_/* - *! 

—/* The specification of the hardware node */ 

_/* -- *! 

type DIS_hw_node is 

—I* - *! 

—/* A hardware node graph is a directed graph: each node */ 
—/* denotes an actual hardware component in computer */ 

—/* architecture as stated and link represents the physical */ 
—/* communication line or bus between hardware components. */ 
— I* Each hardware node identifies its type, specification *! 

—/* and available resources. Unlike task graph in software */ 
— I* structure, it can be nested recursively. Super links in */ 

— I* this level indicate hardware link to hardware node in */ 

— I* the different hardware nodes or group nodes. */ 

_/* -- *! 


record 

hw_node_id : DIS_hw_node_id ; 

hw_node_name : FIELDS; 

— Identifier and name of hardware node 

hw_node_generic_kind : DIS_hw_node_g ; 

— Node specific identifies which known hardware component 

— it is. It serves a key to database containing known 

— hardware information. 

hw_node_specific ; DIS_hw_node_spec; 

— What resources are provided by this hw_node. 

— resource_available and resource_need should be merged. 

hw_node_resource_available : DIS_resource_ptr; 

— Pointer to list of resource are provided by this hw_node. 

— resource_available and resource_need should be merged. 

hw_link_list ; DIS_hw_link_ptr; 

— Pointer to list of hardware links to which this node 

— is connected. 

next_hw_node ; DIS_hw_node_ptr; 

previous_hw_node : DIS_hw_node_ptr; 

— Pointer to next/previous hardware node in the current 

— hardware graph. 


C-20 





hw_node_interaal_node_list : DIS_hw_node_ptr: 

hw_node_intemal_edge_Iist : DIS_hw_link_ptr; 

— Pointers to sub-component nodes and links with their 

— topology, if this hardware node is built from many 

— sub-components. 

parent_hw_group_node ; DIS_hw_group_node_ptr; 

parent_hw_node : DIS_hw_node_ptr; 

— Pointers to parent hardware group node or parent 

— hardware node. 

hw_node_sdf : DIS_SDF_Template_ptr; 

— Pointer to system design factor of hardware node. 

user_extensib{e_var : DIS_user_extensible_ptr; 

— Pointer to the DIS_user_extensible type 

end record; 

type DIS_hw_link is 


record 

hw_link_id 
hw_link_name 
— Identifier and name of hardware link. 


: DIS_hw_link_id ; 
; FIELDS; 


hw_link_generic_kind : DIS_hwJmk_g ; 

hw_link_specific : DIS_hw_link_spec; 

— Generic type and specification of hardware link. 


hw_link_data_rate 

hw_link_data_latency 

hw_link_protocol 


TBD; 

TBD; 

TBD; 


— Data rate and latency of hardware link and its protocol 


parent_hw_group_node 
parent_hw_node 
parent_hw_group_link 

— Pointers to parent hardware group node or parent hardware 

— node, and parent hardware group link. 


DIS_hw _group_node_ptr; 

DIS_hw_node_ptr; 

DIS_hw_group_link_ptr; 


next_hw_link_next ; DIS_hw_link_ptr; 

previous_hw_link_next ; DIS_hw_Iink_ptr; 

— Pointers to nexi/previous hardware node in current 

— hardware link 

hw_link_sdf : DIS_SDF_Template_ptr; 

— Pointer to system design factor for hardware link 


C-21 





user_extensible_var 
— Pointer to the DIS_user_extensible type 


DIS_user_extensible_ptr; 


end record; 


MAPPING ASSIGNMENT 


—/*================== 

— /* 

—/* 

—/* The goal of the mapping assignment is to assign each task 
—/* in the software structure to the specific hardware node 
—/* in the hardware structure with some constraints imposed among 
—/* tasks or tasks and hardware node. A mapping assignment 


—/* two types of mapping constraints; timing constraint and 
—/* placement constraint. Each mapping constraint includesa preference 
—/* value that specifies the importance of meeting the mapping 
—/* constraint; the magnitude of the value. 

_/* - 

type DIS_hardw_softw_pair ; 

type DIS_hardw_softw_pair_ptr is access DIS_hardw_softw_pair ; 

— This is an open declaration for hardware and software pair type 

— to make a pointer to the dynamic storage location in memory. 

subtype DIS_hardw_id is DIS_hw_node_id; 

— renaming of DIS_hardware_id type to DIS_hardw_id in 
— MAPPING VIEW 

subtype DIS_softw_id is DIS_sw_task_id; 

— Renaming of DIS_sw_task_id type to DIS_hardw_id in 
— MAPPING VIEW 


*/ 

*/ 

*/ 

*/ 

*/ 

*/ 

*f 


—/"* consists of mapping constraints and task assignment . There are */ 


*/ 

*/ 

*/ 

*/ 

*/ 


type DIS_hardw_softw_pair is 


—/* 

—/* 


*/ 


A mapping pair of a task in software structure and */ 
—/* node in hardware structure is used to specify a task and */ 
—/* module assignment to a hardware component, and to */ 
—/* specify assignment preferences. */ 

_ /* _ */ 


record 


hardwjd 

— Hardware node identifier 


: DIS hardw id 


C-27 







softwjd 

— Software task identifier 

parent_mapping_view 

— Pointer to mapping view 

next_hardw_softw_pair 

previous_hardw_softw_pair 

— Pointers to next/previous hardw. 


; DIS_sot'tw_id ; 

: DIS_mapping_view_ptr; 

: DIS_hardw_softw_pair_ptr; 
; DIS_hardw_softw_pair_ptr; 
softw_pair 


end record; 


type DIS_softw_id_list ; 

type DIS_softw_id_list_ptr is access DIS_softw_id_list ; 

— This is an open declaration for software list type 

— to make a pointer to the dynamic storage location in memory. 

type DIS_time_constraint ; 

type DIS_time_constraint_ptr is access DIS_time_constraint ; 

— This is an open declaration for time constraint type to make a 

— pointer to the dynamic storage location in memory. 

type DIS_place_constraint ; 

type DIS_place_constraint_ptr is access DIS_place_constraint ; 

— This is an open declaration for place constraint type to make a 

— pointer to the dynamic storage location in memoiy. 

type DIS_softw_id_list is 

_/* -^- */ 

—/* List of software task identifiers with timing and placement */ 

—/* constraints to match them to the specific hardware node. */ 

—I* - */ 


record 

softwjd 

— Software task identifier. 

time_constraint 
— The timing constraint 

place_constraint 
— Placement constraint. 

next_softwJd 
place_softwJd 
— Pointer to next/previous 


: DIS_softwJd ; 

: DIS_time_constraint_ptr; 

: DIS_place_constraint_ptr; 

: DIS_softwJd_list_ptr; 

; DIS_softwJd_list_ptr; 
software task in list. 


C-23 







end record; 


type DIS_hardw_id_list ; 

type DIS_hardw_id_list_ptr is access DIS_hardw_id_list; 

— This is an open declaration for hardware list type to make a 
— pointer to the dynamic storage location in memory. 

type DIS_hardw_id_Iist is 

_/* - 

—/* List of hardware node to be matched to software tasks. 
_/*- 

record 

hardw_id ; DIS_hardw_id ; 

— Hardware node identifier 

next_hardw_id 
previous_hardw_id 

— Pointers to next/previous 
end record; 

type DIS_mapping_constraint; 

type DIS_mapping_constraint_ptr is access DIS_mapping_constraint; 

— This is an open declaration for mapping constraint type to 

— make a pointer to the dynamic storage location in memory. 

type DIS_time_constraint_kind is ( 

_/* - 

— I* The types of timing constraints 

_/* - 


; DIS_hardw_id_list_ptr; 
: DIS_hardw_id_list_ptr; 
hardware identifier in list. 




*/ 


complete_within, 

— Tasks A,B,.-,C should complete within time_value 
start_within, 

— Tasks should start within time_value 

complete_path_within, 

— Sequence of tasks, A,B,....C should complete within 

— time_value 

complete_start_within); 

— For two tasks, A and B. B should start within time_value 

— after the completion of A. 


C-24 




type DIS_time_constraint is 


_/* - */ 

—/* The timing constraint class. It consists of its constraint */ 

—/* kind, preference value specifying the importance of meeting *! 

— I* the mapping constraint, and list of software tasks in the */ 

—/* current timing contraint. It also includes hierachical */ 

— I* relations with mapping constraint. */ 

_/* - *! 


record 

time_constraint_kind : DIS_time_constraint_kind; 

— Type of timing constraint 

preference_value : DIS_preference_range ; 

— Preference of timing constraint 

time_value : DIS_time_type ; 

— Time value of constraint 

softwjdjist ; DIS_softw_idJist_ptr; 

— Pointer to list of software task in current timing 
— constraints 

parent_mapping_constrain t: DIS_mapping_constraint_ptr; 

— Pointer to parent mapping constraint 

next_time_constraint : DIS_time_constraint_ptr; 

previous_time_constraint : DIS_time_constraint_ptr; 

— Pointer to the next and previous time constraints. 

user_extensible_var : DIS_user_extensible_ptr; 

— Pointer to the DIS_user_extensible type 

end record; 

type DIS_place_constraint_kind is ( 


The type of the placement constraint. 


place_together, 

— Tasks A,B,..,C should be as.signed to the same hardware 
place_separate, 

— Tasks A,B,..,C should be assigned to different hardware 


C-25 




place_at); 

— Tasks A,B,..,C should be assigned to the particular hardware 


type DIS_place_constraint is 

_/* - */ 

— I* The placement constraint for software tasks to be placed */ 
—/* at certain hardware node. This consists types of */ 

— I* placement constraint, preference value, list of software */ 

— I* tasks and hardware node identifier. It also includes */ 

—/* pointer to parent mapping constraint. */ 

_/♦ - */ 


record 

place_constraint_kind ; DIS_place_constraint_kind; 

preference_value : DIS_preference_range ; 

— For place_at constraint, we need to specify hardw_id 

hardw_id : DIS_hardw_id ; 

— Identifier of hardware to which some tasks are assigned. 

softwjdjist : DIS_softw_id_list; 

— Pointer to the list of task identifiers which are assigned 
— to the above hardware component. 

parent_mapping_constrain t: DIS_mapping_constraint_ptr; 

— Pointer to the parent mapping constraint. 

next_place_constraint ; DIS_place_constraint_ptr; 

previous_place_constraint ; DIS_place_constraint_ptr; 

— Pointers to the next and previous placement constraint. 

user_extensible_var : DIS_user_extensible_ptr; 

— Pointer to the DIS_user_extensible type 


end record; 

type DIS_mapping_constraint is 

_/* - *! 

—/* The mapping constraint consists of timing and placement */ 
—/* constraints, including pointer to parent mapping view. *! 

_/* - *! 


record 

timing_constraint : DIS_timc_constraint_ptr; 

— Pointer to the timing constraint. 


C-26 





placemen l_con train t 

— Pointer to the placement constraint. 

parent_mapping_view 

— Pointer to the parent mapping view. 


DIS_place_constraint_ptr; 


DIS_mapping_view_ptr; 


end record; 

type DIS_user_extensible is 

—I* -*/ 

—/* This will be the extensible types or variables defined by */ 
—/* user beside the predefined fields in each type, such as */ 
—/* software module, software module edge, task node, task */ 
—/* edge, hardware node, hardware link, etc. User can define */ 
— I* the unique id, name, type, and value of this variable for */ 
— I* his/her own specification on those types. And these will */ 
—/* be linked to define multiple types or variables. */ 

—I* -*/ 

record 

id ; DIS_id_type; 

name : FIELDS; 

— Identifier and name of this user extensible type. 

ext_type : DIS_user_extensible_type; 

— Type of this user extensible type. 

value : DIS_user_extensible_value; 

— Value of this user extensible type. 

next_user_extensible : DIS_user_extensible_ptr; 

— Pointer to the next user expensible type, 
end record; 

type DIS_SDF_Quantification; 

type DIS_SDF_Quantification_ptr is access DIS_SDF_Quantification; 

— This is an open declaration for System Design Factor 
— Quantification type to make a pointer to the dynamic 

— storage location in memory. 

type DIS_SDF_Consistency_Rule; 

type DIS_SDF_Consistency_Rule_ptr is access DIS_SDF_Consistency_Rule; 

— This is an open declaration for System Design Factor 
— Consistency Rule type to make a pointer to the dynamic 

- storage location in memory. 


C-27 














type DIS_SDF_Template is 

_/* - */ 

—/* This System Design Factor(SDF) is to optimize the design */ 
—/* to meet the requiremments and desired measure of */ 

—/* effectiveness. The design goals and criteria in this SDF */ 
— I* are specified by the system designers and analysists to */ 
— I* qualify the various aspects of the design and to perform */ 


—/* the trade-offs among different design goals. Respect to */ 

—/* the type of the system, it describes the properties, */ 

—/* attributes and characteristics of the system. Each SDF */ 

— I* must have its own merit to gauge every detail of the */ 
—/* system. This merit describes the weakness and strengths */ 

—/* of a specific area in the design. In turn, the */ 

—/* correlation of the SDF characterizes the completeness and */ 

—/* robustness. */ 

_/=<■ - */ 


record 

Temp_id 

Temp_name 

Temp_type 

Temp_range 

Temp_units 

Temp_method_or_principle 
Temp_priority 
Temp_accuracy 
Temp_rational 
Temp_reiationship 
Temp_quantification 
Temp_consistency_rule 
Temp_reference 
Temp_definition 
Temp_annotation 
next_SDF_template 
end record; 

type DIS_SDF_Qnty_Formula; 

type DIS_SDF_Qnty_Formula_ptr is access 

type DIS_SDF_Quantification is 
record 

Qnty_type 

Qnty_formula 


DIS_id_type; 

STRING(1..128); 

STRING(1..20); 

STRING! 1..50); 

STRING! 1..20); 

STRING!!..240); 

STRING!!..20); 

STRING!!..20); 

STRING!!..80); 

STRING! I..60); 
D!S_SDF_Quantification_ptr; 
D!S_SDF_Consistency_Rule_ptr; 
STRING! 1..240); 

STRING!!..240); 

STRING!!..240); 
DIS_SDF_Template_ptr; 


DIS_SDF_Qnty_Formula; 


: integer; 

: DIS_SDF_Qnty_Formula_ptr; 


C-28 









end record; 


type DIS_SDF_Qnty_Formula is 
record 

Fm_aggregate 
Fm_var_list 
next_formula 
end record; 


STRING(1..10); 

STRING(1..20); 

DIS_SDF_Qnty_Fonnula_ptr; 


type DIS_SDF_Consistency_Rule is 
record 

Con_aggregate 
Con_type 
Con_design_factor 
Con_view 
Con_component 
end record; 


STRING(1..10); 

SmiNG(1..200); 

STRING(1..20); 

STRING(1..20); 

STRING(1..20); 


— THIS IS THE RESULT OF AN ALLOCATION ALGORITHM. 


type DIS_mapping_view is 

_/* - ♦/ 

—/* Mapping view mainly consists of mapping constraint and */ 

— I* assignment of hardware task to the hardware nodes. It */ 

— I* also includes allocation tool to be determined in later *! 

—/* stage of development, as well as pointer to the */ 

—/* parent implementation view and to sibling mapping views */ 

— I* in mapping list. */ 

—I* - *! 


record 

mapping_view_id : DIS_mapping_view_id; 

— Identifier of this mapping view. 

parent_implementation_view ; DIS_iraplementation_view; 

— Pointer to the parent implementation view of this mapping 
— view. 


allocation_tool_id : DIS_allocation_tool_id; 

— Identifier of allocation tool to be defined in the later 

— stage of developement. 

constraints : DlS_mapping_constraint_pir; 

— Pointer to the mapping costraint which contains the timing 

— and placement constraints. 


C-29 










assignments : DIS_hardw_softw_pair_ptr; 

— Pointer to the hardware node and software task mapping 
— pair. 

next_mapping_view : DIS_mapping_view_ptr; 

previous_mapping_view : DIS_mapping_view_ptr; 

— Pointers to the next and previous mapping views. 

end record; 

end DIS_implementation_model: 


C-30 




FINAL REPORT 


APPENDIX D 

C++ SPECIFICATIONS FOR REPRESENTING IMPLEMENTATION 

MODEL 


SYSTEM ENGINEERING AUTOMATION (SEA) 
FOR DISTRIBUTED SYSTEMS 

CONTRACT NO. N00014-91-C-0183 
CDRL SEQUENCE NO. A002 


AUGUST 1992 





#include <stclio.h> 

#iRclude <string.h> 

// SYSTEM DESIGN FACTOR HLE 

#include ”sdf_spec.cc” 

DIS DECLARATIONS-IMPLEMENTATION MODEL 
======================================================================*/ 


// SHOULD BE SET TO THE DESIRED NUMBER. 

// ini MAX_LENGTH = 100; // (To be determined) and assigned 

// appropriate type and value 

typedef int TBD; // To be determined. 

typedef int id_type; // Is used for type of identification. 

// If it is necessary to modify 
// identifier of type, this type can 
// be changed as to the desired type. 

typedef id_type DIS_sw_structure_diagram_id; // Is used to identify the 

// software structure diagram. 

typedef id_type DIS_sw_module_id; // Is used to identify the software 

// module. 

typedef id_type DIS_sw_module_edge_id; // Is used to identify the software 

//module edge. 

typedef id_type DIS_sw_task_id; // Is used to identify the software 

// module task. 

typedef id_type DIS_sw_task_edge_id; // Is used to identify the software 

// task edge. 

typedef id_type DIS_hw_structure_diagramJd; // Is used to identify the 

// hardware structure diagram. 

typedef id_type DIS_hw_group_node_id; // Is used to identify the hardware 

//group node. 

typedef id_type DIS_hw_group_link_id; // Is used to identify the hardware 

// group link. 

typedef id_type DlS_hw_node_id; 

typedef id_type DIS_hw_link_id; 


D-l 


// Is used to identify the hardware node. 
// Is used to identify the hardware 
// link. 











typedef 

id_type 

DIS_mapping_view_id; 

// 

Is used to identify the mapping view. 

typedef 

int 

DIS. 

_allocation_tool_id; 

// 

Is used to identify the software 





// 

module diagram. 

typedef 

int 

DIS_preference_range; 

// 

Is used to identify the software 





// 

module diagram. 

typedef 

id- 

type 

DIS_data_attribu te_id; 

// 

Is used to identify the DIS data 





// 

attribute. 

typedef 

int 

DIS. 

_time_value; 

// 

Is used to represent DIS time value. 

typedef 

int 

DIS. 

_data_size; 

II 

Is used to represent DIS data size. 

typedef 

int 

DIS. 

_resource_amount; 

II 

Is used to represent DIS resource 





II 

amount. 

typedef 

int 

DIS. 

_user_extensible_type 

II 

Is used to represent the type of 





n 

DIS_user_extensible. This type will be 





n 

defined in the later stage of the 





n 

implementation specification development. 

typedef 

int 

DIS. 

_user_extensible_value 

n 

Is used to represent the value of 





n 

DIS_user_extensible type. This type will 





u 

be defined in the later stage of the 

/* 




H 

implementation specification development. 

/ 

class DIS_name 

{ public: DIS_name(int); 

n 

String constructor 


private: int len;char *sir; 


}; 

*1 

IMPLEMENTATION VIEW 

=======================:========================================:======^/ 


class DIS_sw_structure_(liagram; 


class DIS_hw_structure_diagram; 


class DIS_mapping_view; 


// This is an open declaration for 
// software structure diagram class 
// to make a pointer to the dynamic 
// storage location in memory. 

// This is an open declaration for 
// hardware structure diagram class 
// to make a pointer to the dynamic 
// storage location in memory. 

// This is an open declaration for 
// mapping view class to make a pointer 


D-2 














// to the dynamic storage location in 
// memory. 


class DIS_implementation_view { 

// Class for the implementation model declaration 


DIS_sw_structure_diagram 


DIS_hw_structure_diagram 


DIS_mapping_view 


*sw_structure_diagram; 

// Pointer to the software structure 
//diagram 

*hw_siructure_diagram; 

// Pointer to the hardware structure 
// diagram 

*imp_mapping_list; 

// Pointer to the mapping view 


DIS_implementation_view *next_implementation_view; 

// Pointer to the next implementation 
// view: successor view 


DIS_implementation_view *previous_implementation_view; 

// Pointer to the previous 
// implementation view: predecessor view 


/*===================================================================*/ 

/* *! 

/* SOFTWARE STRUCTURE *! 

I* *1 


/* Each software structure diagram is represented by a list of modules */ 

/* and a list of edges between modules. Modules can be nested and each */ 

/* module includes its own task graph. The task graph cannot be nested */ 

/* since the node of a task graph cannot be a module; however, nested */ 

/* relations between tasks can be captured using ■’osted modules. */ 

/* The task represents a computational entity. */ 

/* - */ 


class DIS_sw_module; // This is an open declaration for 

// software module class to make 
// a pointer to the dynamic storage 
// location in memory. 

class DIS_sw_module_edge; // This is an open declaration for 

// software module edge class to make 


D-3 











// a pointer to the dynamic storage 
// location in memory. 


class DIS_sw_structure_diagram { 

/* - */ 

/* The software structure diagram is used to reference a *! 

I* collection of directed graphs, drawn with respect to a */ 

/* selected methodology, that captures information about a set */ 

/* of components and their relations along with any hierarchical */ 

/* decomposition. For example, a tree of data flow diagrams */ 

/* may be considered as one type of structure diagram. */ 

/* - */ 


DIS_sw_structure_diagram_id sw_structure_diagram_id; 

DIS_name sw_structure_diagram_name; 

// Identifier and name of software 
// structure diagram 

DIS_sw_module *sw_module_list; 

// Pointer to the double-linked list 
// of the software modules 
// as children of this software 
// structure diagram 


DIS_sw_moduIe_edge *sw_module_edge_list; 

// Pointer to the double-linked list 
// of the software module edges 
// interconnecting the children 
// modules of this software structure 
// diagram 

DIS_implementation_view *parent_implementation_view; 

// Pointer to the parent implementation 
// view of this software 
// structure diagram. 


}; 


DIS_sw_structure_diagram *next_sw_diagram; 

// Pointer to the next software 
// structure diagram: successor 

DIS_sw_structure_diagram *previous_sw_diagram; 

// pointer to the previous software 
// structure diagram:predecessor 


D-4 






class DIS_sw_taslc_node; 


// This is an open declaration for 
// software task node class to make 
// a pointer to the dynamic storage 
// location in memory. 

class DIS_sw_task_edge; // This is an open declaration for 

// software task edge class to make 
// a pointer to the dynamic storage 
// location in memory. 

class type DIS_user_extensible_ptr; // This is an open declaration for user 

// extensible variable type to make a 


// pointer to the dynamic storage 
// location in memory. 

class DIS_sw_module { 

/* ----- */ 

/* A software module class contains the following information: */ 

/* *! 

/* 1. The hierarchical, sibling and nesting relations between */ 

/* modules. */ 

/* 2. The identity of task graphs that belong to the module. */ 

/* *1 

/* In addition, there are two special kind of edges (called */ 

/* entry_super_edge and exit_super_edge). They are used to *f 

/* identify the entry and exit points of the task graph at the */ 

/* module level. */ 

/* - */ 

DIS_sw_module_id modulejd; 

DIS_name module_name; 


// Identifier and name of software 
// module 

DIS_sw_structure_diagram *parent_sw_structure; 

// Pointer to parent software 
// structure diagram 

DIS_sw_module *parent_module; 

// Pointer to the parent software 
// module if any 

DIS_sw_module *next_module; 

DIS_sw_module *previous_module; 

// Pointer to previous/next software 
// modules as successor/predecessor 


D-5 




DIS sw module 


DIS_sw_module_edge 


DIS_sw_task_node 

DIS_sw_task_edge 


DIS_sw_task_edge 

DIS_sw_task_edge 


DIS_SDF_Template 


DIS_user_extensible_plr 


*submodule_list; 

// Pointer to the list of the children 
// submodules 

*module_edges; 

// Pointer to the list of software 
// module edge defining links 
H between super edges of the submodules 

*task_node_list; 

*task_edge_list; 

// Pointers to the lists of the 
// software task nodes belongs to this 
// module and of software task edges 
// defining links between tasks: 

// that is, the task graph. A task 
// graph is a directed graph: each 
// node denotes a schedulable 
// computational entity and an edge 
// represents a precedence relation 
// between two nodes. 

*entry_super_edge_list; 

*exit_super_edgejist; 

// Two special kinds of edges, called 
// enter_super_edge & exit_super_edge, 

// are pointers to the lists of 
// software task edges that are to be 
// visible outside the current module. 

// A super edge to an entering to or 
// from exiting node of task_graph. 

// Each entry_super_edge and exit_super 
// _edge are either a task edge 
// or a entry_super_edge/exit_super 
// _edge of a submodule. 

*module_sdf; 

// Pointer to System Design Factor 
// Template for this module 

*user_extensible_var; 

// Pointer to the DlS_user_extensible type 


D-6 





}; 


class DIS_sw_module_edge { 

/* - */ 

/* The software module edge represents the link between *! 

/* modules, and supports the hierarchical orders/relations of *! 

/* the software module organization as well as the list of super */ 
/* edges belonging to this software module edge. */ 

/* - *! 


DIS_sw_module_edge_id 
DIS name 


DIS name 


DIS_sw_structure_diagram 


DIS_sw_module 
DIS_sw module 


DIS_sw_task_edge 


DIS_sw_module_edge 

DIS_sw_module_edge 


DlS_SDF_Template 


DIS_user_extensible_ptr 


}; 


module_edge_id; 

module_edge_name; 

// Identifier and name of the software 
// module edge 

attributes: 

// Attribute of the software module 
// edge 

*parent_sw_structure; 

// Pointer to the parent software 
// structure diagram 

*from_module; 

*to_module; 

// Source and destination pointer for 
// the software module edge 

*super_edge_list; 

// Point to the list of the super 
// edges belonging to this 
// software module edge. 

*next_module_edge; 

^previous_module_edge; 

// Pointers to the next/previous 
// module edges: successor/predecessor 

*module_edge_sdf: 

// pointer to the system design factor 
// template for software module edge 

*user_extensible_var: 

// Pointer to the DlS_user_exten,sible type 


D-7 





class DIS_data_atiribute; // This is an open declaration for 

// software data attribute class to 
// make a pointer to the dynamic 
// storage location in memory. 

class DIS_resource; // This is an open declaration for 

// software resource class to make 
// a pointer to the dynamic storage 
// location in memory. 


enum DIS_time {Relative, Absolute}; 

I* --—--*/ 

/* This specifies the type of DIS time, such that Absolute */ 

/* represent the clock time while Relative represents relative */ 

/* time length from some events. */ 

I* —-- *! 

class DIS_time_kind { 

/*_ — -- -*/ 

/* This specifies the type of DIS time and its value */ 

/* - */ 


DIS_time time_kind; 

DIS_time_value time_value; 

}; 

enum DIS_log_operators {log_and, log.or}; 


!*_ - */ 

/* This is a flag specifying the conditions for executing a */ 

/* task: whether all conditions (or output) data are needed */ 

/* (or generated) by the certain task. */ 

/* ------ *! 

class DIS_sw_task_node { 

1 *^ -—*/ 

/* The software task node class specifies DlS_sw_task_node */ 

/* structure. There is input list to identify input data and an */ 

/* output list to identify output data generated by the task. */ 

/* In addition, predecessor list identifies tasks that execute */ 

/* before the task and successor list identifies task that */ 

I* execute after the task. There is an and/or fiag associated */ 

/* with the above four task lists that specifies whether all *! 


D-S 




/* input (or output) data are needed { or generated) by the */ 

/* task. This information is required by some optimization */ 

/* algorithms. Each task may include timing information such as */ 

/* ready time, deadline and duration. In addition, it identifies */ 

I* resources it needs. For resource needs, resource type *! 

/* identifies the resource a task needs and amount it needs. *! 

/*_ - */ 


DIS_sw_task_id 

DIS_name 

taskjd; 

task_name; 

// Identifier and name of 

// software task node 

DIS_sw_module 

*parent_module; 

// Pointer to the parent software module 

TBD 

TBD 

task_structure; 

task_description; 

// Structure and description of the 
// task node( will be determined 
// in later stage of development. 

DIS_sw_task_edge 

*task_edge_list; 

// Task_edge’s from or to this task_node 

DIS_log_operators 

DIS_data_attribute 

DIS_log_operators 

DIS_data_attribute 

task_input_and_or; 

*task_input_list; 

task_out_and_or; 

*task_output_list; 

// Task data dependencies 

DIS_log_operators 

DIS_sw_task_node 

DIS_log_operators 

D IS_sw_task_node 

task_before_and_or; 

*task_before_!ist; 

task_after_and_or; 

*task_after_list; 

// Task precedence relations 

DlS_time 

DIS_time 

DIS_time 

task_ready_time; 

task_deadline; 

task_duration; 

// Timing information 

DIS_resource 

*ta'.k_resource_needs; 

// Resource needs 

DIS_sw_task_node 

*task_buddy_task; 


// The cooperating tasks 


D-9 




TBD 

TBD 

TBD 

TBD 


DIS_sw_task_node 

DIS_sw_task_nocle 


TBD 

TBD 


DIS_SDF_Template 


DIS_user_extensible_ptr 


}; 


task_max_replication; 

task_priority; 

iask_execution_probability; 

lask_communication_delay_matxix; 

// the fields will be defined in 
// laier stage. 

*next_task; 

*previous_task; 

// Next/previous task in the linked list 

task_error_cumulation; 

task_imprecise_error_convergence; 

// Univ. Illinois imprecise 
// computation support 

*task_sdf; 

// Pointer to the Task Design Factor 
// template 

*user_extensible_var; 

// Pointer to the DIS_user_extensible type 


class DIS_sw_task_edge { 


/* - */ 

/* The software task edge specifies the relations between *! 

/* software task nodes and software module nodes. For each task */ 

/* edge, task_data_edge identifies the data associated with the 

/* edge along with the duration of availability of the data. */ 

/* In addition, from_task_node and to_task_node specifies the */ 

/* source and destination of the edge. 

/* - -*/ 


DIS_sw_task_edge_id 
DIS name 


DIS_sw_module 

DIS_sw_module_edge 


task_edge_id; 

task_edge_name; 

// Identifier and name of the software 
// task edge 

*parent_module; 

*parent_module_edge; 

// Pointer to the parent software 
H module and module edge 


D-fO 






DIS_data_attribute 


DIS_sw_task_node 
DIS sw_task_node 


DIS_sw_task_edge 

DIS_sw_task_edge 


*task_edge_data; 

// Pointer to the data attributes 
// associated to this edge 

*froni_task_node; 

*to_task_node; 

// Pointer to the source and 
// destination software task node. 

*next_task_edge; 

*previous_task_edge; 

// Pointer to the next/previous task 
// node in task edge list 
// where this edge belongs to. 


DIS_SDF_Template 


}; 


*task_edge_sdf; 

// Pointer to the system design factor 
// template. 


enum DIS_d {Msg, SharedMemory}; 

I* _ —— -----*/ 

/* The type of data based on the paradigm of message-passing */ 

/* or shared memory. */ 

/* ... . */ 


class DIS_data_attribute { 

/*_- - --*/ 

/* The data attribute specifies the type and size of data being */ 

/* communicated through edges between tasks. This points to the */ 

/* list of sender/receiver tasks specified by the list of their */ 

/* respective edges between them. In addition, it lists the */ 

/* resource needed for this data attribute as well as timing */ 

/* constraint of data-deadline and data frequency (to be */ 

/* defined in the later stage of the development. */ 

I* --*/ 


DIS_data_attribute_id 

DIS_name 


DIS_d 

DIS data_size 


data_attribute_id; 

data_attribute_name; 

// Identifier and name of the data 
// attributes 

data_kind; 

data_size; 


D-11 





DIS_sw_task_edge 


DIS_log_operators 
DIS_sw_task_node 
DIS_log_operators 
DIS_sw_task node 


// The kind and size of the data in 
// this data attributes. 

*task_edge_list; 

// The list of the software task 
// edges through which data 
II being transmitted. 

sender_kind; 

*data_sender_list; 

receiver_kind; 

*data_receiver_Iist; 

// Kind of log operation (and/or) for 
// receiver/sender, and lists of 
// senders/receivers. 


DIS_resource 

DIS_time 

TBD 


DIS_user_extensible_ptr 

}; 

enum DIS_resource_type {CPU_r, Memory_r, 


*data_resource_need_list; 

// List of the resources needed for 
// this data attribute 

data_deadline; 

data_frequency; 

// The timing constraint of data 
// deadline and data frequency to be 
// determined in the later stage of 
// development. 

*user_extensible_var; 

// Pointer to the DIS_user_extensible type 
Communication}; 


!* - 

/* Kind of resource 

/* - 


*! 

*1 

*1 


enum DIS_resource_u {KIPS, MIPS, Bytes, Kbytes, Mbytes, Sec, MilliSec, 

MicroSec); 


/*- 





*1 

1* 

Unit time of each resource 

type: 


*1 

1* 

KIPS, 

MIPS, or spec 

mark 

for CPU specification. 

*1 

1* 

Bytes, 

KBytes, MBytes 

for 

memory. 

*1 

1* 

(Bytes, 

KBytes, MBytes) 

per 

(Sec. MilliSec, MicroSec) 

*1 

1* 

for 10 

and communication. 


*1 

!*- 





*1 


D-12 







*/ 

*/ 

*/ 


class DIS_resource_unit { 

/* - 

/* Resource unit and its amount 

I* - 


DIS_resource_u 

DIS_resource_amount 

}; 

class DIS_hw_node: 


resource_unit; 

resource_amount; 

// This is an open declaration for 
// hardware node class to make a 
// pointer to the dynamic storage 
// location in memory. 


class DIS_resource { 


1^- 







— ’/ 

1* 

Resource specifies its size and 

units 

and 

pointers 

to the 

*/ 

/* 

related nodes, edges, and 

data 

attributes. 

It also 

contains 

*1 

1* 

pointer to the hardware 

node 

where 

it can be 

defined by a 

*/ 

/* 

hardware configuration. 






*/ 

/*- 







— */ 


DIS_resource_type 
DIS resource unit 


DIS_sw_task_node 

DIS_sw_task_edge 

DIS_data_attribute 


DIS_hw_node 


DIS_resource 
DIS resource 


DIS_user_extensible_ptr 


}; 


resource_kind; 

resource_units; 

// Resource type and unit 

*task_node_list; 

*task_edgejist; 

*resource_data_attribute; 

// Pointer to the task node, edge, 

// and data attributes related to this 
// resource or that need this resource. 

*hw_nodeJist; 

// Hardware node being extracted from 
// the hardware structure 

*nexi_resource_need: 

*previous_resource_need; 

// Pointer to the next/previous 
// resource available or required 
// in the list. 

*user_extensible_var; 

// Pointer to the DIS_user_extensible type 


D-13 








/* HARDWARE STRUCTURE *! 

/* */ 
/* A hardware structure diagram defines a hardware configuration. Each */ 

/* hardware structure diagram is represented by a list of group nodes */ 

/* and a list of group links with their communication topology between */ 

/* group nodes. Group nodes can be nested and each group node includes */ 

/* its own hardware node graph. Unlike task graph in software structure, */ 

/* hardware node graph can be nested. Our view is that the hardware */ 

/* node represents a hardware component in a computer architecture, */ 

/* such as a processor. CPU, memory, 10, etc. */ 

/* -- — ------ */ 


class DIS_hw_group_node; // This is an open declaration for 

// hardware group node class to make a 
// pointer to the dynamic storage 
// location in memory. 

class DIS_hw_group_link; // This is an open declaration for 

// hardware group link class to make a 
// pointer to the dynamic storage 
// location in memory. 


enum DIS_h ,v_group_link_topology { 

/*_ — ---- - */ 

r The various ways of physically connecting hardware group */ 

/' nodes with communications. Here are the generally known *! 

/ types of communication topology existing today. */ 


l.'lly_connected, // All group nodes are directed linked 

// with all other group nodes. 

p u‘tially_connected, // Some group nodes are directly linked 

// with some other groups nodes, but 
// not all. 

hierarchical, // Group nodes are organized or linked 

// as s tree. 

star, // One of the group nodes is connected 

// to all other group nodes. Node of 
// the other nodes are connected to 
// each other. 


D-t4 








ring, // Each group node is physically 

// connected to exactly two other 
// group nodes. 

multi_access_bus // There a single shared hardware group 

// links. All group nodes in the system 
// are directly connected to that group 
// link. 

}; 

class DIS_hw_structure_diagram { 


!*- 






— */ 

!* 

Each view of 

DIS_hardware_structure consists of 


*/ 

!* 

- 

a list 

of group node. 



*/ 

1 * 

- 

a list 

of group edges 

and communication 

topology 

*/ 

!* 


between group node. 



*/ 

1 * 

Similar 

to the 

software module 

in the hierarchical 

view, 

*/ 

1 * 

group nodes can be nested recursively. Each group 

node may 

*/ 

/* 

include 

its own hardware node 

graph with its specific 

*1 

/* 

internal 

communication topology. 

Different with the 

software 

*/ 

/* 

task node in 

hierarchical perspective of configuration, the 

*! 

/* 

hardware 

node 

can be nested 

recursively. 


*/ 

/*- 






— */ 


DIS_name 

DIS_hw_structure_diagram_id 


DIS_implementation_view 


DIS_hw_group_node 


DIS_hw_group_link 


hw_structure_diagram_name; 
hw_siructure_diagram_id; 

// Identifier and name of hardware 
// structure diagram 

*parent_implementation_view; 

// Pointer to parent implementation 
// model 

*hw_group_node_list; 

// Pointer to the double-linked list 
// of hardware group nodes belonging 
// to this hardware structure diagram 

*hw_group_link_list; 

// Pointer to the double-linked li.st 
// of hardware group links inter- 
// connecting hardware group nodes 
// of this hardware structure diagram 















DIS_hw_group_link_topology hw 

DIS_hw_structure_diagram 

DIS_hw_struciure_diagram 

}; 

class DIS_hw_link: 

typedef DIS_hw _group_Iink_topology 


_group_link_topology; 

// Communication topology of hardware 
// group nodes 

*next_hw_diagram; 

*previous_hw_diagram; 

// Pointers to the next/previous 
// hardware structure diagram; 

// successor/predecessor 


// This is an open declaration for 
// hardware link class to make a 
// pointer to the dynamic storage 
// location in memory. 

DIS_hw_node_link_topology; 

// Internal hardware link topology 


class DIS_hw_group_node { 


/* - */ 

/* A hardware_group_node class contains the following */ 

/* informations; */ 

/* 1. The hierarchical, sibling and nesting relations */ 

/* between hardware group nodes */ 

/* 2. The identity of hardware node graphs that belong to *! 

/* this hardware group node. */ 

/* For both graph, the communication topology can be specified. */ 

/* In addition, there are two special kinds of links (called */ 

/* entry_super_link and exit_super_link). They are used to */ 

/* identify the entry and exit points of the node graph at the */ 

/* group node level. */ 

/* - */ 


DIS_hw_group_node_id 
DIS name 


DIS_hw_structure_diagram 


hw_group_node_id; 
hw_group_node_name; 

// Identifier and name of hardware 
// group node 

*parent_hw_structure; 

// Pointer to parent hardware 
// structure diagram 


D-I6 





DIS_hw_oroup_node 


DIS_hw_group_node 

DIS_hw_group_node 


DIS_hw_»roup_node 


*parent_hw_group_node; 

// Pointer to parent hardware 
II group node 

*next_hw_group_node; 

*previous_hw_group_node; 

// Pointer to next/previous 
// hardware group node; 

// successor/predecessor 

*sub_hw^roup_node; 

// Pointer to list of sub-group nodes 
// as children of this group node 


DIS_hw_group_link 

DIS_hw_group_link_topology 


*sub_hw_group_link; 
hw_group_link_topology; 

// Pointer to list of hardware group 
// links defining physical data 
// communication link between sub- 
// group nodes and their topology 


// NODE GRAPHS belongs to this group node 

DIS_hw_node *hw_node_Ust; 

DIS_hw_link *hw_link_list; 

DIS_hw_node_link_topology *hw_node_link_topology; 

// Hardware node graph belongs to 
// this hardwaie group node: nodes, 

// links, and their link topology 

DIS_hw_link *entry_super_link_list; 

DIS_hw_link *exit_super_link_list; 

// There are two special kinds of 
// links, called enter_super_link and 
// exit_super_link, that are to be 
// visible outside the current group. 

// A super link to an entering or from 
// exiting node of the group_node. 

// Each entry_super_link is either a 
// hw_link or a entry_super_link 
// of a sub group node. 

// Each exit_super_link is either a 
// hw_link or a enter_super_link 
// of a sub_group_node. 


D-17 





DIS„SDF_Template 


*group_node_sdf; 

// Pointer to system design factor 

DIS_user_extensible_ptr *user_extensibie_var; 

// Pointer to the DIS_user_extensible type 
// template 


class DIS_hw_group_link { 

/* - *! 

I* The hardware group link represents the physical *! 

/* communication between hardware group nodes, and support the */ 

/* hierarchical orders/relations of the hardware group */ 

/* organization with its respective topology. It also points to */ 

/* the list of the super links belonging to this hardware */ 

/* group link. */ 

/* - */ 


DIS_hw_group_link_id 
DIS name 


DIS_hw_structure_diagram 


DIS_hw_group_node 

DIS_hw_group_node 


DIS_hw_link 


DIS_hw_group_link 

DIS_hw_group_link 


DIS_SDF_Template 


hw_group_link_id; 

hw_group_link_name; 

// Identifier and name of hardware 
// group link 

*parent_hw_structure; 

// Pointer to parent hardware 
// structure diagram 

*from_hw_group_node; 

*to_hw_group_node; 

H Pointer to the source/destination 
// of this hardware group link 

*super_link_list; 

// Pointer to list of super links 
// belonging to this group node 

*next_hw_group_link; 

♦previous_hw_group_link; 

// Pointers to nest/previous hardware 
// group links:successor/predecessor 

*group_edge_sdf; 

// Pointer to system design factor 
// template for hardware group link 


D-18 






DIS_user_extensible_ptr 


*user_extensible_var; 

// Pointer to the DIS_user_extensible type 


enum hw_link_g {Bus, LAN}; 

/* - 

/* The genetic type of the hardware link */ 

I* -*/ 

enum hw_link_spec {NotKnownJ, Ethernet, TokenRing}; 

I* - *! 

/* The specification of the hardware link */ 

/* - */ 

enum hw_node_g (Processor, CPU_hw, Memory_hw, lOchannel, Other}; 

/* - *! 

/* The genetic type of the hardware node */ 

/* - *! 

enum hw_node_spec {NotKjiown_n, Sun, RISC, Sparc}; 

/* - */ 

/* The specification of the hardware node */ 

/* - *! 

class DIS_hw_node { 

I* -*/ 


/* A hardware node graph is a directed graph: each node denotes*/ 
/* an actual hardware component in computer architecture as */ 
/* stated and link represents the physical communication line */ 
/* or bus between hardware components. Each hardware node */ 
/* identifies its type, specification and available resources. */ 
/* Unlike task graph in software structure, it can be nested */ 
/* recursively. Super links in this level indicate hardware link*/ 
/* to hardware node in the different hardware nodes or group */ 
/* nodes. */ 

/* - */ 


DIS_name hw_node_name; 

DIS_hw_node_id hw_node_id; 

// Identifier and name of hardware 
// node 


D-19 




hw_node_g 

hw_node_spec 


DIS resource 


DIS hw_link 


DIS_hw_node 
DIS hw_node 


DIS_hw_node 

DIS_hw_link 


DIS_hw_group_node 
DIS hw_node 


hw_node_generic; 

hw_node_specific; 

// Specific identification of node 
// as known hardware component. 

// This serves a key to database 
// containing known hardware 
// information. 

*hw_node_resource_available; 

// Pointer to list of resource are 
// provided by this hw_node. 

// resource_available and 
// resource_need should be merged. 

*hw_link; 

// Pointer to list of hardware links 
// to which this node is connected. 

*next_hw_node; 

*previous_hw_node; 

// Pointer to next/previous hardware 
// node in the current hardware graph. 

*hw_node_intemal_node_list; 

*hw_node_intemal_link_list; 

// Pointers to sub-component nodes and 
// links with their topology, if this 
// hardware node is built from many 
// sub-components. 

*parent_hw_group_node; 

*parent_hw_node; 

// Pointers to parent hardware group 
// node or parent hardware node. 


D-2() 





DIS_SDF_Template 


DIS_user_extensible_ptr 

}; 

class DIS_hw_link { 

DIS_hw_link_id 

DIS_name 


hw_link_g 

hw_link_spec 


TBD 

TBD 

TBD 


DIS_hw_group_node 

DIS_hw_node 

DIS_hw_group_link 


DIS_hw_link 
DIS hwjink 


DIS_SDF_Template 


}; 


D-21 


*hw_node_sdf; 

// Pointer to system design factor 
// of hardware node. 

*user_extensible_var; 

// Pointer to the DlS_user_extensible type 


hw_link_id; 

hw_link_name; 

// Identifier and name of hardware 
// link. 

hw_link_generic_kind; 

hw_link_specific; 

// Generic type and specification 
// of hardware link. 

hw_link_data_rate; 

hw_link_data_latency; 

hw_link_protocol; 

// Data rate and latency of hardware 
// link and its protocol 

*parent_hw_group_node; 

*parent_hw_node; 

*parent_hw_group_link; 

// Pointers to 

// parent hardware group node or 
// parent hardware node, and parent 
// hardware group link. 

*next_hw_link; 

*previous_hwJink; 

// Pointers to next/previous hardware 
// node in current hardware link 

*hw_link_sdf; 

// Pointer to system design factor 
// for hardware link 





/*================================================================ 

/* MAPPING ASSIGNMENT 

/* 

/* The goal of the mapping assignment is to assign each task in the 

/* software structure to the specific hardware node in the hardware 

/* structure with some constraints imposed among tasks or tasks and 
/* and hardware node. A mapping assignment consists of mapping 
/* constraints and task assignment . There are two types of mapping 

/* constraints; timing constraint and placement constraint. Each mapping 

/* constraint includes a preference value that specifies the importance 

/* of meeting the mapping constraint; the magnitude of the value 

/* reflects its importance. And a task assignment is result of running 
/* an allocation algorithm on a pair of software structure and hardware 

/* structure within a set of timing and placement constraints. Task 

/* assignment are stored in DISmapping_result_type. 

/*- 


*/ 

*! 

*1 

*! 

*/ 

*! 

*1 

*1 

*! 

*1 

*/ 

*1 

*/ 

*/ 


typedef DIS_hw_node_id 


typedef DIS_sw_task_id 


class DIS_hardw_softw_pair { 


DIS_hardwJd; 

// Renaming of DIS_hardware id type 
// to DIS_hardw_id in MAPPING VIEW 

DIS_softw_id; 

// Renaming of DIS_sw_task_id type 
// to DIS_hardwJd in MAPPING VIEW 


/* - */ 

/* a pair of rr.apping beiwe^,i. task in software structure and */ 

/* node in hardware structure. */ 

/* - */ 


DIS_hardw_id hardw_id; 

// Hardware node identifier 

DIS_softw_id softwjd; 

// Software task identifier 


DIS_mapping_view 


DIS_hardw_softw_pair 

DIS_hardw_softw_pair 


*parent_mapping_view; 

// pointer to mapping view 

*ncxt_ha'-dw_softw_pair; 
*previous_hardw_softw_pair; 
// Pointers to next/previous 
// hardw_sol'tw_pair 


D-22 






class DIS_time_constraint; 


class DIS_place_constraint; 


// This is an open declaration for 
// time constraint class to make a 
// pointer to the dynamic storage 
// location in memory. 

// This is an open declaration for 
// place constraint class to make a 
// pointer to the dynamic storage 
// location in memory. 


class DIS_softw_id_list { 

I* - 

/* List of software task identifiers with timing and placement 
/* constraints to match them to the specific hardware node. 

/*- 


DIS softw id 


softwjd; 

// Software task identifier. 


DIS time constraint 


DIS_place_constraint 


*time_constraint; 

// The timing constraint 

*place_constraint; 

// The placement constraint. 


*/ 

*/ 

*/ 


DIS_softw_id_list 
DIS_softw_id_list 

}; 

class DIS_hardw_id_list { 

/*- 

/* List of hardware node to be matched to software tasks. 
/*- 


*next_softwJd; 

*previous_softw_id; 

// Pointer to next/previous software 
// task in list. 


*/ 

*! 

*1 


DIS_hardw_id 


hardwjd; 

// Hardware node identifier 


DIS_hardw_id_list 

DIS_hardwJd_list 


}: 


*next_hardw_id; 

*previous_hardw_id; 

// Pointers to next/previous 
// hardware identifier in li.st. 


D-23 




enum DIS_time_constraint_kind { 

*! 
*/ 
*1 


/* - 

/* The types of timing constraints 
/* - 


complete_within, 

start_within, 

compIete_path_within. 

complete_start_within 

}; 

class DIS_mapping_constraint; 


// Tasks A, should complete 

// within time_value 

H Tasks A, should start 

// within time_value 

// Sequence of tasks, A,B,...,C 
// should complete within time_value 

// For two tasks, A and B, B should 
U start within time_value after 
// the completion of A. 

// This is an open declaration for 
// mapping constraint class to make a 
// pointer to the dynamic storage 
// location in memory. 


class DIS_time_constraint { 


/♦ ----- */ 

/* The timing constraint class. This consists of its constraint */ 

/* kind, preference value specifying the importance of meeting */ 

/* the mapping constraint, and list of software tasks in the */ 

/* current timing constraint. This also includes hierarchical */ 

/* relations with mapping constraint. */ 

I* - *! 


DIS time constraint kind 


time_constraint_kind; 

// Type of timing constraint 


DIS_preference_range 
DIS time 


DIS_softw_id_list 


preference_value; 

// Preference of timing constraint 
*time_value; 

// Time value of constraint 
*softw_id_list; 

// Pointer to list of software task 
// in current timing constraints 


D-24 



DIS_mapping_constraint 


*parent_mapping_consiraini; 

// Pointer to parent mapping constraint 


DIS_time_constraint 
DIS time constraint 


DIS_user_extensible_ptr 


*next_time_constraint; 

*previous_time_constraint; 

// Pointer to next/previous timing 
// constraint. 

*user_extensible_var; 

// Pointer to the DIS_user_extensible type 


enum DIS_place_constraint_kind { 


/* The type of the placement constraint. 
/*- 


place_together. 


place_separate. 


place_at 


// Tasks A,B—,C should be assigned 
// to the same hardware 

// Tasks A,B.C should be assigned 

// to different hardware 

H Tasks A.Bv.C should be assigned 
// to the particular hardware 


class DIS_place_constraint { 


/* The placement constraint for software tasks to be placed at 

/* certain hardware node. This consists types of placement 
/* constraint, preference value, list of software tasks, and 
/* hardware node identifier. This also includes pointer to parent 

/* mapping constraint. 

/* - 


DIS_place_constraint_kind 
DIS_preference_range 
DIS hardw id 


DIS_softwJd_list 

DIS_mapping_constraint 

DIS_place_constraint 

DIS_place_constraint 


place_constraint; 

preference_value; 

hardwjd; 

// For place_at constraint, we need 

// to specify DIS_hardw_id 

*softw_id_list; 

*parent_mapping_constraiiU; 

*next_place_consu-aint; 

*previou.s_place_constraint; 


D-25 







DIS_user_extensible_ptr 


*user_extensible_var; 

// Pointer to the DIS_user_extensible type 


class DIS_niapping_constraint { 

/* - */ 

/* The mapping constraint consists of timing and placement */ 

/* constraints, including pointer to parent mapping view. */ 

/* - */ 

DIS_time_constraint *timing_constraint; 

DIS_place_constraint *placement_constraint; 

DIS_mapping_view *pareni_mapping_view; 

}; 

class DIS_user_extensible { 

/* - */ 

/* This will be the extensible types or variables defined by */ 

/* user beside the predefined fields in each type, such as */ 

/* software module, software module edge, task node, task */ 

/* edge, hardware node, hardware link, etc. User can define */ 

/* the unique id, name, type, and value of this variable for */ 

/* his/her own specification on those types. And these will */ 

/* be linked to define multiple types or variables. */ 

/* - */ 

DlS_id_type id; 

FIELDS name; 

// Identifier and name of this 
// user extensible type. 

DIS_user_extensible_typcxt_type; 

// Type of this user extensible type. 

DIS_user_extensible_value value; 

// Value of this user extensible type. 

DIS_user_extensible_ptr next_user_extensible; 

// Pointer to the next user extensible type. 

}; 


iwe 





// THIS IS THE RESULT OF AN ALLOCATION ALGORITHM. 


class DIS_mapping_view { 


/*- 





-*/ 


/* Mapping view 

mainly consists of mapping constraint and 

assign- 

*/ 

1* 

ment of hardware 

task to the hardware nodes. 

This also 

includes 

*/ 

1* 

allocation tool to 

be determined in later stage 

of development. 

*/ 

/* 

as well as pointer 

to the parent implementation 

view and 

to 

*/ 

/* 

sibling mapping views in mapping list. 



*! 

/*- 





- *! 


DIS_mapping_view_id 

DIS_implementation_view 

DIS_allocation_tool_id 

DIS_niapping_constraint 

DIS_hardw_softw_pair 

DIS_mapping_view 

DIS_mapping_view 

}; 


DIS_implementation_model () { } 


inapping_view_id; 

*parent_implementation_view; 

allocation_tool_id; 

^constraint; 

*assignment; 

*next_mapping_view; 

*previous_niapping_view; 


D-27 







FINAL REPORT 


APPENDIX E 

ADA SPECIFICATIONS FOR REPRESENTING 
SYSTEM DESIGN FACTOR 


SYSTEM ENGINEERING AUTOMATION (SEA) 
FOR DISTRIBUTED SYSTEMS 

CONTRACT NO. N00014-91-C-0183 
CDRL SEQUENCE NO. A002 


AUGUST 1992 






with Text_io; 
use Text_io; 

package DIS_system_design_factor is 


DIS DECLARATIONS - SYSTEM DESIGN FACTOR 


MAX_LENGTH ; INTEGER ;= 100; 


— Should 

be set to the desirable number. 



— To be 

determined and assigned appropriate type. 



— This is only the compilation purpose. 



subtype 

TBD 

is 

INTEGER; ; 

subtype 

DIS_Rational 

is 

TBD 


subtype 

DIS_MorP 

is 

TBD 


subtype 

DIS_Reference 

is 

TBD 


subtype 

DIS_Definition 

is 

TBD 


subtype 

DIS_Comments 

is 

TBD 


subtype 

DIS.SDF 

is 

TBD 


subtype 

DIS.Ranges 

is 

TBD 


subtype 

DIS_Units 

is 

TBD 


subtype 

DIS.Qnty 

is 

TBD 


subtype 

DIS_Aggregate 

is 

TBD 


subtype 

DIS_Variable 

is 

TBD 


subtype 

DIS_CAggregate 

is 

TBD 


subtype 

DIS.CType 

is 

TBD 


subtype 

DIS_CView 

is 

TBD 


subtype 

DIS_CDFactor 

is 

TBD 


subtype 

DIS_CComponent 

is 

TBD 


subtype 

DIS.DOF 

is 

TBD 


subtype 

DIS_RpliabilityScale 

is 

TBD 


subtype 

DIS_PerformanceScale 

is 

TBD 


subtype 

DIS_SecurityScale 

is 

TBD 


subtype 

DIS_HumanFactorScale 

is 

TBD 


subtype 

FIELDS 

is string! 1 ..MAX.LENGTH); 


E-1 















_/* - *! 

—I* SYSTEM DEIGN FACTOR TEMPLATE *! 

_/* */ 

—/* This System Design Factor(SDF) is to optimize the design *! 

— I* to meet the requiremments and desired measure of *! 

—/* effectiveness. The design goals and criteria in this SDF */ 

—/* are specified by the system designers and analysists to */ 

— I* qualify the various aspects of the design and to perform */ 

— I* the trade-offs among different design goals. Respect to */ 

—/* the type of the system, it describes the properties, */ 

—/* attributes and characteristics of the system. Each SDF */ 

— I* must have its own merit to gauge every detail of the */ 

— I* system. This merit describes the weakness and strengths */ 

— I* of a specific area in the design. In turn, the */ 

—/* correlation of the SDF characterizes the completeness and *! 

—/* robustness. */ 

_ I* _*/ 

type DIS_SDF_Template; 

type DIS_SDF_Template_ptr is access DIS_SDF_Template; 

— This is an open declaration for System Design Factor 

— Template type to make a pointer to the dynamic 

— storage location in memory. 

type DIS_Attribute; 

type DIS_Attribute_ptr is access DIS_Attribute; 

— This is an open declaration for System Design Factor 

— Attribute type to make a pointer to the dynamic 

— storage location in memory. 

type DIS_Quantification; 

type DIS_Quantification_ptr is access DIS_Quantification; 

— This is an open declaration for System Design Factor 

— Quantification type to mal:e a pointer to the dynamic 

— storage location in memory. 

type DIS_Consistency; 

type DIS_Consistency_ptr is access DlS_Consistency; 

— This is an open declaration for System Design Factor 

— Consistency type to make a pointer to the dynamic 

— storage location in memory. 

type DIS_QualityReq; 

type DIS_QualityReq_ptr is acce.ss DIS_QualityReq; 


E-2 




— This is an open declaration for System Design Factor 

— QualityReq type to make a pointer to the dynamic 

— storage location in memory. 


type DIS_SDF_Template is 
record 

Name(MAX_LENGTH) 

Attributes 

Rational 

Method_Or_Principle 
Quantification 
Consistency 
Quality Requirements 
ReferenceList 
Definitions 
Annotations 
NextTemplate 
PreviousTemplate 
end record; 


FIELDS; 

DIS_Atlribute_ptr; 

DIS_Rational; 

DIS_MorP; 

DIS_Quantify_ptr; 

DIS_Consistency_pir; 

DIS_QualityReq_ptr; 

DIS_Reference; 

DIS_Definition; 

DIS_Comments; 

DIS_SDF_Template_ptr; 

DIS_SDF_Template_ptr; 


type DIS.Properties; 

type DIS_Properties_ptr is access DIS_Properties; 

— This is an open declaration for property type of 
— SDF attribute to make a pointer to the dynamic 
— storage location in memory. 

type DIS_RelationShip is (Functional, Logical); 

— This is a relationship type for SDF attribute. 

type DIS_Attributes is 
record 

Relationship 
Properties 
NextAttribute 
end record; 

type DIS_Properties is 
record 
type 
Ranges 
Units 
end record; 

type DIS_Formula; 

type DIS_Formula_ptr is access DlS_Formula; 


DIS_RelaiionShip; 

DIS_Properties_ptr; 

DIS_Attribute_ptr; 


DIS.SDF; 

DIS_Ranges; 

DIS_Uniis; 


E-3 











— This is an open declaration for formula type of 
— SDF qualify to make a pointer to the dynamic 
— storage location in memory. 

type DIS_Quantify is 



record 

type 

DIS_Qnty; 


Formula 

DIS_Formula_ptr; 

end 

record; 


type 

DIS_Formula is 



record 

Aggregates 

DIS_Aggregate; 


VariableList 

DIS_Variable; 


NextFormula 

DIS_Formula_ptr; 


PreviousFormula 

DIS_Formula_ptr; 

end 

record; 


type 

DIS_Consistency is 



record 

Aggregates 

DIS_CAggregate; 


ByType 

DIS_CType; 


ByView 

DIS.CView; 


ByDesignFactor 

DIS_CDFactor; 


ByThisComponent 

DIS_CComponent; 

end 

record; 



type DIS_Usability; 

type DIS_Usability_ptr is access DIS_Usability; 

— This is an open declaration for usability type of 
— SDF quality requirement to make a pointer to the dynamic 
— storage location in memory. 

type DIS_QualityReq is 
record 

Degree_Of_Functionality : DIS_DOF; 

Usability : DIS_Usability_ptr; 

end record; 


E-4 







type DIS_Usability is 
record 
Reliability 
Performance 
Security 
HumanFactors 
end record; 

end DIS_system_design_factor; 


: DIS_ReliabilityScale; 

; DIS_PerformanceScale; 

: DIS_SecurityScale; 

: DIS_HumanFactorScale; 


E-5 






FINAL REPORT 


APPENDIX F 

C++ SPECIFICATIONS FOR REPRESENTING 
SYSTEM DESIGN FACTOR 


SYSTEM ENGINEERING AUTOMATION (SEA) 
FOR DISTRIBUTED SYSTEMS 

CONTRACT NO. N00014-91-C-0183 
CDRL SEQUENCE NO. A002 


AUGUST 1992 




#include <stdio.h> 
#include <string.h> 


// DIS DECLARATIONS - SYSTEM DESIGN FACTOR 


// Should be set to the desired no. 
int MAX.LENGTH = 100; 

// To be determined and assigned appropriate type. 

// This is only the compilation purpose. 

typedef int TBD; 

typedef TBD DIS_Rational; 

typedef TBD DIS_MorP: 

typedef TBD DIS_Reference: 

typedef TBD DIS_Definition; 

typedef TBD DIS_Comments; 

typedef TBD DIS_SDF; 

typedef IBD DIS_Ranges; 

typedef TBD DIS_Units; 

typedef TBD DIS_Qnty; 

typedef TBD DIS_Aggregate; 

typedef TBD DIS_Variable; 

typedef TBD DIS_CAggregate; 

typedef TBD DIS_CType; 

typedef TBD DIS_CView; 

typedef TBD DIS_CDFactor; 

typedef TBD DIS_CComponent; 

typedef TBD DIS_DOF; 

typedef TBD DIS_ReliabilityScaIe; 

typedef TBD DIS_PerformanceScale; 

typedef TBD DIS_SecurityScale; 

typedef TBD DIS_HumanFactorScale; 

// String class for names of the structures 
class String {public: StringO {}; //constructor 
private: int len; char *str; 

}; 



/* - *! 

/* SYSTEM DEIGN FACTOR TEMPLATE */ 

/* *! 

/* This System Design Factor(SDF) is to optimize the design */ 

/* to meet the requiremments and desired measure of */ 

/* effectiveness. The design goals and criteria in this SDF */ 

/* are specified by the system designers and analysists to */ 

/* qualify the various aspects of the design and to perform */ 

/* the trade-offs among different design goals. Respect to */ 

/* the type of the system, it describes the properties, */ 

/* attributes and characteristics of the system. Each SDF */ 

/* must have its own merit to gauge every detail of the */ 

/* system. This merit describes the weakness and strengths */ 

/* of a specific area in the design. In turn, the */ 

/* correlation of the SDF characterizes the completeness and */ 

/* robustness. */ 

I* - *! 


class DIS_Attribute; 

// This is an open declaration for System Design Factor 
// Attribute type to make a pointer to the dynamic 
// storage location in memory. 

class DIS_Quantify; 

// This is an open declaration for System Design Factor 
// Quantification type to make a pointer to the dynamic 
// storage location in memory. 

class DIS_Consistency; 

// This is an open declaration for System Design Factor 
// Consistency type to make a pointer to the dynamic 
// storage location in memory. 

class DIS_QualityReq; 

// This is an open declaration for System Design Factor 
// QualityReq type to make a pointer to the dynamic 
// storage location in memory. 

class DIS_SDF_Template { 

String Name(MAX_LENGTH); 

DIS_Attribute *Attributes; 

DIS_Rational Rational; 

DIS_MorP Method_Or_Principle: 


F-2 





DIS_Quantify 

DIS_Consistency 

DIS_QualityReq 

DIS_Reference 

DIS_Definition 

DIS_Comments 

DIS_SDF_Template 

}; 


♦Quantification; 

♦Consistency: 

♦QualityRequirements; 

ReferenceList; 

Definitions; 

Annotations; 

♦NextTemplate; 


class DIS_Properties; 

// This is an open declaration for pr'>peny type of 
// SDF attribute to make a pointer to the dynamic 
// storage location in memory. 


enum DIS_RelationShip {Functional, Logical}; 

// This is a relationship type for SDF attribute. 


class DIS_Attributes { 

DIS_RelationShip 
DIS_Properties 
DIS_Attribute 

}; 

class DIS_Properties { 

DIS.SDF 
DIS_Ranges 
DIS Units 


Relationship; 

♦Properties; 

♦NextAttribute; 


type; 

Ranges; 

Units; 


class DIS_Formula; 

// This is an open declaration for formula type of 
// SDF qualify to make a pointer to the dynamic 
// storage location in memory. 


class DIS_Quantify 
DIS_Qnty 
DIS_Formula 
I; 


type; 

♦Formula; 


F-3 



class DIS_Formula { 
DIS_Aggregate 
DIS_Variable 
DIS_Formula 

); 

class DIS_Consistency { 
DIS_CAggregate 
DIS_CType 
DIS_CView 
DIS_CDFactor 
DIS_CComponent 

}; 


Aggregates; 

VariableList; 

*NextFormula; 


Aggregates; 

ByType; 

ByView; 

ByDesignFactor; 

ByThisComponent; 


class DIS_Usability 

// This is an open declaration for usability type of 
H SDF quality requirement to make a pointer to the dynamic 
// storage location in memory. 


class DIS_QualityReq { 
DIS_DOF 
DIS_Usability 

}; 

class DIS_Usability { 

DIS_ReliabilityScale 

DIS_PerlormanceScale 

DIS_SecurityScale 

DIS_HumanFactorScale 


Degree_Of_Functionality; 

Usability; 


Reliability; 

Performance; 

Security; 

HumanFactors; 


F-4 





FINAL REPORT 

APPENDIX G 

ROUTINES SUPPORTING DESTINATION INTERFACE SPECIFICATION 


SYSTEM ENGINEERING AUTOMATION (SEA) 
FOR DISTRIBUTED SYSTEMS 

CONTRACT NO. N00014-91-C-0183 
CDRL SEQUENCE NO. A002 


AUGUST 1992 





A ppendix G 


This Appendix contains the following Ada packages: 

1. DIS_twk_mapper 

2. DIS_twk_ispec 

3. Write_DIS_rile 

4. DIS_resource_actions 

5. DIS_timing_constraint_actions 

6. DIS_placement_constraint_actions 

7. DIS_sdf_actions 

8. DIS_resource_support 

9. DIS_placement_constraint_support 

10. DIS_timing_constraint_support 

11. DIS_sdf_template_support 

12. DIS.files 

13. DIS_tae_patch 

14. DIS_twk_etd 

15. DIS_twk_intf 

16. DIS_twk_constraint 



Gl. DIS_twk_mapper 

with text_io; 

with DIS_twk_Intf; 

with DIS_imp_model; 

package DIS_twk_mapper is 

MAX_NO_EDGES 
DIS_SW_Root 
DIS_SW_SDiagram 
DIS_SW_Modules 
DIS RPtr 


use textjo; 

use DIS_twk_Intf; 

use DIS_imp_model; 


INTEGER ;= 200; 

DIS_sw_structure_diagram_ptr; 

DIS_sw_structure_diagram_ptr; 

DIS_sw_module_pir; 

DIS_sw_structure_diagram_ptr; 


type EdgeArray is aiTay(l..MAX_NO_EDGES) of DIS_twk_flows; 

procedure MapSWSDiagram; 
procedure MapSWModules; 
procedure LinkSubModules; 
procedure MapModuleEdges; 
procedure LinkTasks; 
procedure LinkTaskEdges; 


procedure LinkModuleEdges(PSWPtr 

in DIS_sw_slructure_diagram_ptr; 

NPtr 

in out DIS_sw_module_ptr; 

Dfdid 

in INTEGER; 

Nedges 

in EdgeArray); 

procedure GetModuleEdges(DfdId 

in INTEGER; 

Nld 

in INTEGER; 

Nedges 

in out EdgeArray); 

procedure Twk_GetParent(Index 

in INTEGER; 

Dfdindex, Nid 

in out INTEGER); 

procedure AddToTaskfMdlPu- 

in out DIS_sw_module_ptr); 

procedure MapTaskEdges(EArray 

in EdgeArray; 

PPtr 

in out DIS_sw_module_ptr); 

procedure MapEntrySEdges(EntrySEdges 

in EdgeArray; 

PPtr 

in out DIS_sw_module_ptr); 

procedure MapExitSEdges(ExitSEdges 

in EdgeArray; 

PPtr 

in out DIS_sw_module_ptr); 

procedure GetSWDMPtr(DfdId 

in INTEGER; 

RelMPtr 

out DIS_sw_module_pir); 

procedure GetSWDPtr(DfdId 

in INTEGER; 


RetSDPtr : out DIS_sw_siructure_diagram_pU'); 


G- 1 









procedure GetMEPtr(NId 


Dfdid 

RetMEPtr 


: in INTEGER; 

; in INTEGER; 

; out DIS_sw_module_pir); 


procedure GetParentNode(p_nid, dfd_id 

RetPNPtr 


: in INTEGER; 

: out DIS_sw_niodule_ptr); 


procedure 


GetNodePu-(EId 


NPtr 

RetNPtr 


: in INTEGER; 

; in DIS_sw_module_ptr; 

: Out DIS_sw_task_node_ptr); 


function EntrySuperEdge(TWKEdges 

DfdPtr 

return BOOLEAN; 

function ExitSuperEdge(TWKEdges 

DfdPtr 

return BOOLEAN; 


: in DlS_twk_f]ow_ptr; 

; in DIS_sw_module_ptr) 

; in DIS_twk_flow_pU'; 

: in DIS_sw_module_plr) 


function 


TaskEdges(TWKEdge 

PNPtr 

return BOOLEAN; 


; in DIS_twk_flow_ptr; 

; in DIS_sw_module_ptr) 


end DIS_twk_niapper; 

i 


G- 2 






G2. DIS_twk_ispec 


with 

io_exceptions; 

use 

io_exceptions; 

with 

Twk_ada_dba; 

use 

Twk_ada_dba; 

with 

Math; 

use 

Math; 

with 

DIS_twk_const; 

use 

DIS_twk_const; 

with 

DIS_twk_intf; 

use 

DIS_twk_intf; 


with Textjo; use textjo; 
package DIS_twk_ispec is 


Status 

Pi 

DDi 

procedure 

function 

function 

procedure 

procedure 

procedure 


Initialize (Path 


: Twk_status_t ; 

: twk_object_ptr_t (Twk_processJndex_type); 

— /* process index ptr for the model */ 

; twk_object_ptr_t(twk_dd_index_type); 

— /* dd index ptr for the model */ 

: String); 


Read_process_index(model_name 
return Twk_process_index_t_ptr; 


String) 


Read_latest_dfd(model_name, Dfd_name : String) 
return Twk_dfd_t_ptr; 


Get_bubbIes_in_one_dfd(Dfd 

bubble_count 

Get_bubbles_in_all_dfds(model_name 

Pi 


in Twk_dfd_t_ptr; 
in out Integer); 


in STRING; 

Twk_process_index_t_ptr); 


Get_flow_in_one_dfd(Dfd ; in Twk_dfd_t_ptr; 



data_flow_count 

: in out Integer; 


df_Index 

: in out Integer); 

procedure 

Get_flow_in_all_dfd(model_name 

; in STRING; 


Pi 

; in Twk_process_index_t_ptr); 

procedure 

get_twk_nodes(model_name 

; in String; 


conrig_name 

; in String); 

procedure 

get_twk_flows(modeLname 

; in String; 


conrig_name 

; in String); 

procedure 

clean_namc(instr 

: in out string); 

Exit_failure 


: exception; 


end DIS_twk_ispec; 




G- 3 






G3. Write_DIS_file 

with text_io; 
with DIS_files; 
with DIS_imp_model; 
with DIS_twk_const; 

package write_DIS_files is 


use textjo; 
use DIS_files; 
use DlS_imp_model; 
use DIS_twk_const; 


procedure write_DIS_resource_rile 
(resource : in out DIS_resource_ptr); 

procedure write_DIS_data_attribute_file 

(data_attribute : in out DIS_data_attribute_ptr); 

procedure write_DIS_sw_task_edge_file 

(sw_task_edge ; in out DIS_sw_task_edge_ptr); 

procedure write_DIS_sw_task_node_file 

(sw_task_node ; in out DIS_sw_task_node_ptr); 

procedure write_DIS_sw_module_edge_rile 

(sw_module_edge : in out DIS_sw_module_edge_ptr); 

procedure write_DIS_sw_module_file 

(sw_module : in out DIS_sw_module_ptr); 

procedure write_DIS_sw_structure_diagram_file 

(DIS_SW_Root; in out DIS_sw_structure_diagrani_ptr); 

procedure write_DIS_hw_link_file 
(hw_link ; in out DIS_hw_link_ptr); 

procedure write_DIS_hw_node_file 
(hw_node ; in out DIS_hw_node_ptr); 

procedure write_DIS_hw_group_link_riie 

(hw_group_Iink : in out DIS_hw_group_link_ptr); 

procedure write_DIS_hw_group_node_file 

(hw_group_node : in out I?IS_hw_group_node_ptr); 

procedure write_DIS_hw_structure_diagram_file 

(hw_struc_diag ; in out DIS_hw_structure_diagram_ptr); 

procedure set_DIS_file_pointers; 

procedure close_DIS_files; 


end write_DIS_riles; 


G- 4 






G4. DIS_resource_actions 

with text_io; 
with DlS.files; 
with Unix; 

with DIS_inip_model; 

package DIS_resource_actions is 

MAX_RECORD_LENGTH 

Resource 

FoundFlag 

procedure write_RES_file(N_Id 
procedure read_RES_file(N_Id 
procedure read_wri te_RES_files( taskj 

end DIS_resource_actions; 


use lextjo; 
use DIS_files; 
use Unix; 

use DlS_imp_model; 


; INTEGER := 1635; 
: DIS_resource_ptr; 

; Boolean; 

; in STRING); 

: in STRING); 

; in STRING); 


G- 5 





G5. 

DIS_tiiiiing_constraint_actioiis 


with 

text_io; 

use textjo; 

with 

DlS.files; 

use DIS_files; 

with 

Unix; 

use Unix; 

with 

DIS_imp_model; 

use DIS_imp_model; 

package DIS_timing_constraint_actions 

is 


Time_Constraint 

: DIS_time_consiraint_ptr: 


FoundFlag 

: BOOLEAN; 


procedure write_TC_file(N_Id : in STRING); 
procedure read_TC_file (N_Id in STRING); 

end DIS_tiniing_constraint_actions; 


G- 6 



G6. DIS_placeinent_constraint_actions 


use texi_io; 
use DIS_files; 
use Unix; 

use DiS_imp_model; 

package DIS_placement_conslraint_actions is 


with text_io;‘ 
with DIS_ftles; 
with Unix; 

with DIS_imp_model; 


Place_Constraint 

FoundFIag 


; DIS_place_consiraini_ptr; 
; BOOLEAN; 


procedure wriie_PC_rile(N_Id ; in STRING); 

procedure read_PC_file (N_Id ; in STRING); 


end DIS_placement_consiraint_actions; 





G7. DIS_sdf_actions 

with text_io; 
with DIS_files; 
with DIS_twk:_const; 
with Unix; 

package DIS_sdf_actions is 

MAX_RECORD_LENGTH 

type DIS_SDF_Template is 
record 

Nodejd 

Factor 

sUBfACTor 

Name 

Type_T 

Range_T 

Units 

Priority 

Accuracy 

MethPrin 

Defn 

Rational 

Relationship 

QuantTypel 

QuantValuel 

QuantFormulal 

QuantType2 

QuantValuel 

QuantFormulal 

QuantTypeS 

QuantValueS 

QuantFormula3 

QuantType4 

QuantValue4 

QuantFormula4 

QuantType5 

QuantValueS 

QuantFormulaS 

Con_Typel 

Con_valu 1 

Con_form 1 

Con_Typel 

Con_valul 

Con_forml 

Con_Type3 


use textjo; 
use DIS_files; 
use DIS_twk_const; 
use Unix; 


: INTEGER := 1168; 


INTEGER; 

INTEGER; 

INTEGER; 

STRING(1..80); 

STRING(1..10); 

STRING(1..10); 

STRING(1..20); 

STRING(1..20); 

STRING(1..10); 

STRING(1..100); 

STRING(1..100); 

STRING(1..50); 

STRING(1..50); 

STRING(1..1()); 

STRING(1..10); 

STRING(1..50); 

STRING(1..10); 

STRING(1..10); 

STRING! 1..50); 

STRING(1..10); 

STRING! 1.. 10); 

STRING!!..50); 

STRING!!..10); 

STRING!!..10); 

STRING!!..50); 

STRING!!.. 10); 

STRING!!..10); 

STRING!!..50); 

STRING! I..15); 

STRING!!..10); 

STRING!!..50); 

STRING!!..15); 

STRING!!..10); 

STRING!!..50); 

STRING!!..15); 


G- 8 









Con_valu3 

STRING(L.IO)- 


Con_form3 

STRING(1..50) 


Con_Type4 

STRING(1..15) 


Con_valu4 

STR1NG(1..10) 


Con_form4 

STRING(1..50) 


Con_Type5 

STRING(1..15) 


Con_valu5 

STRING(1..10) 


Con_form5 

STRING(1..50) 


Annotation 

STRING(1..50) 


end record; 


OK_Button 

BOOLEAN := 

FALSE; 

NodeNameJ 

INTEGER := 10; 

DISSDF_Template 

; DIS_SDF_Templaie; 

FoundFlag 

: BOOLEAN; 

procedure Read_SDF_File(Node_No 

: in STRING; 

Fid 

: in INTEGER; 

SFid 

: in INTEGER); 

procedure Write_SDF_File(Node_No 

: in STRING; 

Fid 

: in INTEGER; 

SFid 

; in INTEGER); 


end DIS_sdf_actions; 


G- 9 






G8. DIS_resource_support 

with tae; 
with X_Windows: 
with textjo; 

with DIS_reource_actions; 
with DIS_imp_mo(lel; 
with DIS_files; 
with DIS_twk_const; 
with COMMAND_LINE; 

package DIS_resource_support is 


package taefloatjo is new text_io.float_io (taefloat); 

* procedure initializePanels (file ; in string); — NOTE: params changed 


— BEGIN EVENT.HANDLERs 




procedure 

DIS_RES_RES_CANCEL 

(info 

; in 

tae_wpLevent_context_p;r); 

1 procedure 

DIS_RES_RES_CLOSE 

(info 

: in 

tae_wpLevent_context_ptr); 

procedure 

DIS_RES_RES_OK 

(info 

: in 

tae_wpLevent_contexi_ptr); 

procedure 

DIS_RES_RES_PREV 

(info 

: in 

tae_wpLevent_context_ptr); 

* procedure 

DIS_RES_RES_NEXT 

(info 

: in 

tae_wpLevent_context_ptr); 

1 procedure 

DIS_RES_RES_NAME 

(info 

: in 

tae_wpt.event_context_ptr); 

1 procedure 

DIS_RES_RES_UNIT_TYPE 

(info 

; in 

tae_wpLevent_context_ptr); 

procedure 

DIS_RES_RES_UNIT_AMNT 

(info 

: in 

tae_wpLevent_context_ptr); 

1 procedure 

DIS_RES_RES_TYPE 

(info 

: in 

tae_wpLevent_context_ptr); 

— END EVENT.HANDLERs 





end DIS_resource_support; 


use tae; 


use DlS_resource_actions; 
use DIS_imp_model; 
use DIS_files; 
use DIS_twk_const; 
use COMMAND_LINE; 



G- 10 




G9. 

DIS_placeinent_constraint_support 



with 

tae; 

use 1 

tae; 

with 

X_Windows; 



with 

textjo; 



with 

DIS_imp_model; 

use 

DIS_imp_model; 

with 

DIS_placement_constraint_aciions; 

use 

DIS_placenient_constraint_actions; 

with 

COMMAND_LINE; 

use 

COMMAND_LINE; 

with 

DIS_files; 

use 

DIS_files; 

with 

DIS_twk_const; 

USE 

dis_twk_consl; 


package DIS_placement_constraint_suppori is 

package taefloat_io is new iext_io.floaMo (taefloat); 

procedure initializePanels (file : in string); — NOTE: params changed 


— BEGIN EVENT.HANDLERs 

procedure DIS_PC_PC_HW 
procedure DIS_PC_PC_KiND 
procedure DIS_PC_PC_OK 
procedure DIS_PC_PC_CANCEL 
procedure DIS_PC_PC_TASK_LIST 
procedure DIS_PC_PC_PREF_VAJ. 
procedure DIS_PC_PC_HELP 

— END EVENT.HANDLERs 


(info : in tae_wpt.event_context_ptr); 
(info : in tae_wpt.event_context_ptr); 
(info ; in tae_wpt.event_context_ptr); 
(info : in iae_wpt.event_coniext_ptr); 
(info : in tae_wpt.event_coniext_ptr); 
(info : in tae_wpt.event_context_pir); 
(info : in tae_wpt.event_context_ptr); 


end DIS_placement_constraint_support; 







GlO. DIS_tining_constraint_support 


with 

tae; 

use 

tae; 

with 

X_Windows; 



with 

text_io; 



with 

DIS_imp_model; 

use 

DIS_imp_model; 

with 

TC_actions; 

use 

TC_actions; 

with 

DIS_files; 

use 

DIS_fiIes; 

with 

DIS_twk_const; 

use 

DIS_twk_const; 

with 

COMMAND_LINE; 

use 

COMMAND_LINE; 


package DIS_timing_constraint_support is 


package taefloatjo is new text_io.float_io (taefloat); 

procedure initializePanels (file : in string); — NOTE: params changed 


BEGIN EVENT_HANDLERs 
procedure DIS_TC_TC_OK (info 

DIS_TC_TC_CANCEL (info 

DIS_TC_TC_PREF_VAL (info 

DIS_TC_TC_TM_TYPE (info 


procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 


DIS_TC_TC_TM_UNIT_AMNT(info 
DIS_TC_TC_TASK_LIST (info 

DIS_TC_TC_KIND (info 

DIS_TC_TC_CLOSE (info 


in tae_wpt. 
in tae_wpt. 
in tae_wpt, 
in tae_wpi. 
in tae_wpt. 
in tae_wpt. 
in tae_wpt. 
in tae_wpt. 


event 

event 

event 

event 

event 

event 

event 

event 


.context_ptr); 

.context_ptr); 

.context_ptr); 

.context_ptr); 

.context_ptr); 

.context_ptr); 

.context_ptr); 

.coniext_ptr); 


— END EVENT^HANDLERs 


end DIS_timing_constraint_support; 


G- 12 




1 

® Gil. DIS_sdf_teinplate_support 


1 with tae; use tae; I 

P with X_Windows; 


L with text_io; I 

1 with DIS_files; 

use DIS_riles; 

r with DIS_tae_patch; 

use DIS_tae_patch; 

L with DIS_sdf_actions; 

use DIS_sdf_actions; 

1 with COMMAND.LINE; 

use COMMAND_LrNE; 

r with DIS_twk_const; 

use DIS_twk_const; 

■ package DIS_sdf_template_support is 

L package taefloat_io is new text_io.float_io (taefloat); 

1 procedure inilializePanels (file : in 

string); — NOTE: params changed 1 

1 — BEGIN EVENT_HANDLERs I 

■ procedure sdf_tp_sdf_pfni 

(info : in tae_wpt.eveni_conlext_ptr); 

F procedure sdf_tp_sdf_rtm 

(info : in tae_wpt.eveni_context_ptr); 

L procedure sdf_tp_sdf_dep 

(info : in tae_wpt.event_context_ptr); 

1 procedure sdf_tp_sdf_hmw 

(info : in tae_wpt.event_context_ptr); 

j procedure sdf_tp_sdf_phq 

(info : in tae_wpt.event_context_ptr); 

L procedure sdf_tp_sdf_sec 

(info : in tae_wpt.event_coniext_ptr); 

■ procedure sdf_tp_sdf_trq 

(info : in tae_wpt.event_context_ptr); 

1 procedure sdf_tp_sdfjcy 

(info : in tae_wpi.eveni_context_ptr); ' 

■ procedure sdf_tp_sdf_frq 

(info : in tae_wpt.event_context_ptr); 

1 procedure sdf_tp_sdf_prq 

(info : in tae_wpLevent_context_ptr); 

1 procedure sdf_tp_sdf_fnc 

(info : in tae_wpi.event_context_ptr); 

■ procedure sdf_tp_tp_ok 

(info : in tae_wpt.event_context_ptr); 

p procedure sdf_tp_tp_cl 

(info : in tae_wpt.event_coniext_ptr); 

1 procedure sdf_tp_tp_hp 

(info ; in tae_wpi.event_context_ptr); 

■ procedure sdf_pf_pf_rst 

(info ; in tae_wpi.event_contexi_ptr); 

F procedure sdf_pf_pf_cpy 

(info : in tae_wpt.event_context_ptr); 

L procedure sdf_pf_pf_spd 

(info : in tae_wpt.event_coniext_pir); 

1 procedure sdf_pf_pf_tpt 

(info ; in tae_wpt.event_context_ptr); 

[ procedure sdf_pf_pf_lcy 

(info : in tae_wpi.event_context_ptr); 

L procedure sdf_pf_pf_lbc 

(info : in tae_wpi.event_contexi_ptr); 

1 procedure sdf_pf_pf_gdg 

(info : in tae_wpt.evenl_context_ptr); 

I procedure sdf_pf_pf_pty 

(info ; in tae_wpi.event_context_ptr); 

ll procedure sdf_pf_pf_ok 

(info : in tae_wpt.event_context_ptr); 

1 procedure sdf_pf_pf_cl 

(info : in tae_wpt.event_coniext_ptr); 

r procedure sdf_pf_pf_hp 

(info : in tae_wpt.event_context_ptr); 

■ procedure sdf_rt_rt_hns 

(info : in tae_wpt.event_coniext_ptr); 

m procedure sdf_rt_rt_hdl 

(info ; in tae_wpt.eveni_context_pir); 

1 procedure sdf_rt_rt_sdl 

(info : in tae_wpi.event_context_ptr); 

■ procedure sdf_rt_rt_tdt 

(info : in tae_wpi.event_context_ptr); 

• procedure sdf_rt_rt_mdl 

(info : in tae_wpt.event_context_ptr); 

L procedure sdf rt rt tns 

(info : in tae_wpt.event_coniexi_ptr); 

r 

G-13 






procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 

procedure 


sdf_n_rt_pty 

(info 

sdf_rt_rt_gdt 

(info 

sdf_rt_rt_ok 

(info 

sdf_rt_rt_cl 

(info 

sdf_rt_rt_hp 

(info 

sdf_pr_pr_inip 

(info 

sdf_pr_pr_uns 

(info 

sdf_pr_pr_pty 

(info 

sdf_pr_pr_poy 

(info 

sdf_pr_pr_irc 

(info 

sdf_pr_pr_msp 

(info 

sdf_pr_pr_ok 

(info 

sdf_pr_pr_cl 

(info 

sdf_pr_pr_hp 

(info 

sdf_dp_dp_rty 

(info 

sdf_dp_dp_acy 

(info 

sdf_dp_dp_ftn 

(info 

sdf_dp_dp_gdt 

(info 

sdf_dp_dp_rcy 

(info 

sdf_dp_dp_aty 

(info 

sdf_dp_dp_qty 

(info 

sdf_dp_dp_ok 

(info 

sdf_dp_dp_cJ 

(info 

sdf_dp_dp_hp 

(info 

sdf_st_si_clt 

(info 

sdf_st_st_typ 

(info 

sdf_st_st_pim 

(info 

sdf_st_st_ety 

(info 

sdf_st_st_irq 

(info 

sdf_st_si_ok 

(info 

sdf_st_si_cl 

(info 

sdf_st_st_hp 

(info 

sdf_tmp_imp_cl 

(info 

sdf_tmp_imp_o 

(info 

sdf_imp_tmp_h 

(info 

sdf_unp_tm p_m d 

(info 

sdf_tmp_tmp_nd 

(info 

sdf_tmp_tmp_ty 

(info 

sdf_tmp_tmp_rg 

(info 

sdf_tmp_imp_ut 

(info 

sdf_tmp_unp_rl 

(info 

sdf_imp_tmp_rt 

(info 

sdf_tmp_tmp_ai 

(info 

sdf_tmp_tmp_pr 

(info 


in tae_wpt.event_context_ptr); 
in tae_wpLevent_context_pU'); 
in tae_wpt.event_context_ptr); 
in iae_wpt.event_context_ptr); 
in tae_wpt.event_context_ptr); 
in tae_wpt.event_context_ptr); 
in tae_wpt.event_context_pir); 
in tae_wpt.event_context_plr); 
in tae_wpt.event_context_ptr); 
in tae_wpt.event_context_plr); 
in iae_wpi.event_context_plr); 
in tae_wpt.event_context_ptr); 
in iae_wpt.event_context_pir); 
in tae_wpt.event_coniext_ptr); 
in tae_wpt.event_context_pU'); 
in tae_wpt.event_coniext_pir); 
in tae_wpt.event_coniext_ptr); 
in tae_wpt.event_context_ptr); 
in tae_wpi.event_context_ptr); 
in tae_wpt.event_context_pU‘); 
in tae_wpi.event_coniext_pU‘); 
in tae_wpt.event_context_ptr); 
in lae.wpi.evenLconiexupur); 
in tae_wpt.event_coniext_ptr); 
in tae_wpt.event_context_pir); 
in tae„wpt.event_context_plr); 
in tae_wpt.event_context_pir); 
in tae_wpt.event_context_pir); 
in tae_wpt.event_coniext_pu-); 
in tae_wpt.event_context_ptr); 
in tae_wpi.eveni_context_ptr); 
in tae_wpt.eveni_context_ptr); 
in tae_wpt.eveni_conlext_ptr); 
in tae_wpt.event_context_ptr); 
in tae_wpi.event_contexi_pir); 
in tae_wpi.eveni_context_pir); 
in iae_wpt.event_coniext_ptr); 
in iae_wpt.event_context_ptr); 
in tae_wpi.event_context_pir); 
in tae_wpt.event_context_pir); 
in tae_wpi.event_context_ptr); 
in tae_wpt.event_context_pLr); 
in tae_wpt.event_coniext_ptr); 
in tae_wpi.event_contexi_ptr); 


4 


G- 14 








procedure sdf_tmp_tmp_ac (info : in tae_wpt.event_context_ptr); 

procedure sdf_tmp_tnip_qt (info : in tae_wpl.eveni_coniext_pir); 

procedure sdf_tmp_tnip_fl (info : in tae_wpt.event_context_ptr); 

procedure sdf_tmp_tmp_vl (info : in iae_wpt.event_context_pir); 

procedure sdf_tmp_tnip_tl (info : in tae_wpLevent_context_pir); 

procedure sdf_tmp_tnip_cr (info : in tae_wpt.event_context_ptr); 

procedure sdf_tmp_tmp_fo (info : in tae_wpt.event_context_ptr); 

procedure sdf_tmp_tmp_vo (info : in tae_wpi.event_context_ptr); 

procedure sdf_tmp_NoName23 (info : in tae_wpt.event_context_ptr); 

procedure sdf_tmp_NoNanae24 (info : in tae_wpt.event_context_ptr); 

procedure sdf_tmp_tmp_ctl (info : in tae_wpi.event_context_ptr); 

procedure sdf_tmp_tmp_df (info : in tae_wpt.event_contexi_ptr); 

procedure sdf_tmp_tmp_f2 (info : in tae_wpt.event_context_pir); 

procedure sdf_tmp_tmp_f3 (info : in tae_wpi.event_coniext_ptr); 

procedure sdf_tmp_imp_f4 (info ; in iae_wpi.eveni_context_pU'); 

procedure sdf_tmp_imp_f5 (info : in tae_wpt.event_coniext_ptr); 

procedure sdf_lnip_tmp_v2 (info ; in tae_wpt.event_contexi_pir); 

procedure sdf_tmp_tmp_v3 (info ; in tae_wpLeveni_context_pir); 

procedure sdf_tmp_tmp_v4 (info ; in tae_wpi.event_coniext_ptr); 

procedure sdf_tnip_tmp_v5 (info : in tae_wpt.event_context_ptr); 

procedure sdf_tmp_tnip_t2 (info : in iae_wpt.event_context_ptr); 

procedure sdf_tmp_tmp_6 (info : in tae_wpt.eveni_context_ptr); 

procedure sdf_tmp_tmp_t4 (info : in tae_wpt.event_coniexi_ptr); 

procedure sdf_tmp_tmp_t5 (info : in tae_wpt.event_context_pir); 

procedure sdf_tmp_tmp_cl (info : in tae_wpt.event_context_ptr); 

procedure sdf_tmp_tmp_c2 (info : in tae_wpt.event_context_ptr); 

procedure sdf_tmp_tmp_c3 (info : in tae_wpt.event_context_ptr); 

procedure sdf_tmp_linP_c4 (info : in tae_wpt.event_context_ptr); 

procedure sdf_imp_tmp_c5 (info : in tae_wpi.event_context_ptr); 

procedure sdf_tmp_tmp_cvl (info ; in tae_wpt.event_coniext_pir); 

procedure sdf_tmp_tmp_cv2 (info : in lae_wpi.event_coniext_ptr); 

procedure sdf_tmp_tmp_cv3 (info : in tae_wpi.event_context_pir); 

procedure sdf_tmp_tmp_cv4 (info : in tae_wpt.event_coniext_ptr); 

procedure sdf_tmp_tmp_cv5 (info : in lae_wpi.event_contexi_pir); 

procedure sdf_tmp_tmp_ct2 (info ; in tae_wpi.event_context_ptr); 

procedure sdf_tnip_imp_ct3 (info : in tae_wpt.event_context_ptr); 

procedure sdf_tmp_imp_ct4 (info : in lae_wpi.event_coniexi_pir); 

procedure sdf_tmp_imp_ct5 (info ; in iae_wpi.eveni_coniext_ptr); 

procedure tmp_QTp_qt_ok (info ; in tae_wnt.event_coniexi_pir); 

procedure tmp_QTp_NoName01 (info : in tae_wpi.eveni_context_pir); 

procedure lmp_QTp_qtp_rd (info ; in tae_wpi.eveni_context_pir); 

procedure tmp_CTp_CTp_ok (info : in iae_wpt.event_coniext_ptr); 

procedure tmp_CTp_CTp_cl (info : in tae_wpt.eveni_context_ptr); 

procedure tmp_CTp_CTp_tp (info : in tae_wpi.eveni_coniext_pir); 

— END EVENT.HANDLERs 


G- 15 









G12. DIS flies 


with text_io; use text_io; 


package DIS_riles is 

subtype FName_Type is 

ModeLName 

Model_NLength 

Target_Dir 

Target_DLength 

Config_FName 

Config_FLength 

File_NLength 

Temp_FName 

Temp_SDF_FName 

DIS^SDF.FName 


STRING(I..100); 

: FName_Type; 

; NATURAL; 

: FNaine_Type; 

: NATURAL; 

; STRING(L.128); 

: INTEGER; 

: INTEGER; 

: FName_Type; 

: constant STRING := ”DIS_Temp_SDFile”; 
: constant STRING := ’'_sdr’; 


function Get_File_Name(Instr : in STRING) return STRING; 

function Open_File(File_Nanie; in STRING; 

FMode ; in text_io.file_mode) 
return texuio.file.type; 


end DIS_files; 





G13. DIS_tae_patch 



with tae; 


use tae; 

with DIS_actions; 


use DIS_actions; 

with text_io; 


use text_io; 

package DIS_tae_patch is 



procedure ReadWrite 

(PnlPtr 

; in out iae_wpt.event_context_ptr); 

procedure InitPnl 

(PnlPtr 

; in out tae_wpt.event_context_ptr); 

procedure DepressBtn 

(PnlPtr 

: in tae_wpLevent_context_ptr; 


Itemid 

: in string); 

end DIS_tae_patch; 




G-17 





I 


I 


G14. DIS_twk_etd 

with textjo; 

with COMMAND_LINE; 

with DIS_twk_const; 

with DIS_twk_ispec; 
with DIS_twk_mapper; 
with write_EDA_files; 


use text_io; 

use COMMAND_LINE; 
use DIS_twk_const; 

use DIS_twk_ispec; 
use DIS_twk_mapper; 
use wriie_EDA_files 


package DIS_twk_etd is 
begin 

model_name(l..argv(l).s’last) ;= argv(l).s; 
model_nlength := argv(l).s’last; 

target_dir( 1.. 17) ./exportjmport/”; 

target_Dlength := 17; 

tjength := 17; 

config_name (l..argv(2).s/last) := argv (2) .s; 

cjast := argv (2).s’last; 

get_twk_nodes(model_name, config_name); 
get_twk_flows(model_name, config_name); 

MapSWSDiagram; 

MAPSWModules’ 

LinkSubModules; 

MapModuleEdges; 

LinkTasks; 

LinkTaskEdges; 

get_EDA_file_pointers; 

write_EDA_sw_structure_diagrani_file (DIS_SW_Root); 
close_EDA_files; 

end DIS_twk_etd; 


G- 18 










G15. DIS.twkJntf 


package DIS_twk_intf is 


type DIS_twk_node; 

type DIS_twk_node_ptr is access DIS_twk_node; 


type DIS_twk_node is 
record 
nodejd 
node_name 
node_no 
node_type 
next_node 
end record; 


INTEGER; 
STRING(1..100); - 
INTEGER; 
INTEGER; 
DIS_twk_node_ptr; 


type DIS_twk_flows; 

type DIS_twk_flow_ptr is access DIS_twk_flows; 
type DIS_twk_flows is 
record 


flowjd 
flow_name 
flow_type 
flow_start 
flow_start_obj 
flow_end 
flow_end_obj 
next_flow 
end record; 


INTEGER; 

STRING(1..100); 

INTEGER; 

INTEGER; 

INTEGER; 

INTEGER; 

INTEGER; 

DIS_twk_flow_ptr; 


Instance #. 

Text bound to the node. 

Holds good only for bubbles (not stores). 
1-process, 2-store, 3-others. 


Instance #. 

Text bound to the flow. 

1 - data, 2 - Control. 

Instance # of the flow st pt 
1-process, 2-store, 3-others. 
Instance # of the flow end pL 
1-process, 2-store, 3-others. 


type twk_node_type is array(INTEGER range o) of DIS_twk_node_ptr; 
type twk_flow_type is array(INTEGER range <>) of DIS_twk_flow_ptr; 


end 

I 


twk extract variables 


type DIS_twk_dfd_nodes is array(INTEGER range <>) of DIS_twk_node_ptr; 
type DIS_twk_dfd_edges is array(INTEGER range <>) of DIS_twk_flow_ptr; 


DIS_MAX_LAYERS 

DIS_NAME_LENGTH 

DIS_twk_CLayers 

DIS_twk_CELayers 

DIS_twk_NLayers 


INTEGER 

= 50; 

INTEGER 

= 100; 

INTEGER 

= 0; 

INTEGER 

= 0; 

INTEGER 

= -1; 


twk_nodes 

twk_edges 

twk_rootnodes 

DIS_twk_layers_nd 

DIS_twk_layers_ed 

DIS_twk_LNames 

DIS_twk_intf; 


DIS_twk_node_ptr; 

DIS_twk_flow_ptr; 

DI S_twk_n ode_ptr; 

DIS_twk_dfd_nodes(0. .DIS_MAX_L AYERS); 
DIS_twk_dfd_edges(O..DIS_MAX_LAYERS); 
array(O..DIS_MAX_LAYERS) of 
STRING( 1 ..DIS_NAME_LENGTH); 


4 


G-19 













G16. DIS_twk_coiistraint 

package DIS_twk_const is 

subtype FNAME.TYPE is STRING(1..100); 
model_nanie : FNAME_TYPE; 

targel_dir ; FNAME_TYPE; 

model_nlength : NATURAL; 

t_length ; NATURAL; 

target_dlength : NATURAL; 

config_name : STRING(1..128); 

c_last ; INTEGER; 

c_default ; constant STRING := ’7home/twk401/cadre/tsa/config_file” 

end DIS_twk_const; 


G-20 












I 

I 

I 

I 

I 

I 

I 

I 

h 


FINAL REPORT 
APPENDIX H 

DESTINATION INTERFACE SPECIFICATION FILE FORMATS 

SYSTEM ENGINEERING AUTOMATION (SEA) 

FOR DISTRIBUTED SYSTEMS 

CONTRACT NO. N00014-91-C-0183 
CDRL SEQUENCE NO. A002 

AUGUST 1992 







A ppendix H 


This Appendix contains the following packages: 

1. Software_structure_diagram_file 

2. Software_module_file 

3. Software_module_edge_file 

4. Software_task_node_file 

5. Software_task_edge_file 

6. Data_atiTibute_file 

7. Hardware_structure_diagram_file 

8. Hardware_^roup_node_rile 

9. Hardware_group_link_file 

10. Hardware_node_file 

11. Hardware_link_file 

12. Resource.file 

13. Timing_constraint_f.ie 

14. F iii.-en:ient_constraint_rile 

15. Sys»'”T:)_d 2 sign_factor 'implate 

16. Syste; csign_factor_attribute 

17. System_v^esign_factor_quantification 





^^t^Hi^i^:lf^t^iif:tfifiHf^t:tf************************************************************** 

* SOFTWARE STRUCTURE DIAGRAM FILE * 

^^^l^^l^:^i^iif^i:>H|iif^fml:^:^^i^:^i^ilf:^*^l^*^l^*:D^^:7l^^t^^^Lt******************************************** 

FILE NAME: software_structure_diagram_file 

/FIELD #/FIELD NAME /DATA TYPE /FIELD SIZE 


FI 

id 

integer 

10 

F2 

name 

char 

100 

F3 

parent_implementation_view 

pointer 

16 

F4 

sw_module_list 

pointer 

16 

F5 

sw_moduIe_edge_Iist 

pointer 

16 

F6 

next_sw_diagram 

pointer 

16 

F7 

previous_sw_diagram 

pointer 

16 







* SOFTWARE MODULE FILE * 

FILe NAME; software module file 


/FIELD 

#/FIELD NAME 

/DATA TYPE 

/FIELD 

FI 

id 

integer 

10 

F2 

name 

char 

100 

F3 

parent_sw_structure 

pointer 

16 

F4 

parent_module 

pointer 

16 

F5 

next_module 

pointer 

16 

F6 

previous_module 

pointer 

16 

F7 

submodule_list 

pointer 

16 

F8 

module_edge_list 

pointer 

16 

F9 

task_nodeJist 

pointer 

16 

FIO 

task_edge_list 

pointer 

16 

Fll 

entry_super_edge_list 

pointer 

16 

F12 

exit_super_edge_list 

pointer 

16 

F13 

module_sdf 

pointer 

16 


H- 2 




if::tf************************************************^******:l^***********:^******** 


* SOFTWARE MODULE EDGE FILE * 

iHlf^i^^:tf^***ifi*:tf*if**itc:tiif^:lfif:lf:ti:ti:tiifiif:ti:^if:lfiif:^L***^il^ilf***ifi**^f}tf***************************** 

FILE NAME; software_module_edge_file 

/FIELD #/FIELD NAME /DATA TYPE /FIELD SIZE 


FI 

id 

integer 

10 

F2 

name 

char 

100 

F3 

attributes 

char 

100 

F4 

parent_sw_structure 

pointer 

16 

F5 

from_mofuIe 

pointer 

16 

F6 

to_module 

pointer 

16 

F7 

super_edge_list 

pointer 

16 

F8 

next_moduIe_edge 

pointer 

16 

F9 

previous_moduIe_edge 

pointer 

16 

FIO 

module_edge_sdf 

pointer 

16 








* SOFTWARE TASK NODE FILE * 

***#************************3|c*************************************:(c*********** 

FILE NAME; software_task_node_file 


/FIELD 

#/FIELD NAME 

/DATA TYPE 

/FIELD 

FI 

id 

integeer 

10 

F2 

name 

char 

100 

F3 

parent_module 

pointer 

16 

F4 

task_structure 

pointer 

16 

F5 

task_description 

pointer 

16 

F6 

task_edge_list 

pointer 

16 

F7 

task_input_and_and_or 

integer 

4 

F8 

task_input_list 

pointer 

16 

F9 

task_out_and_or 

integer 

4 

FIO 

task_outputJist 

pointer 

16 

FII 

task_before_and_or 

integer 

4 

F12 

task_before_Iist 

pointer 

16 

FI3 

task_after_and_or 

integer 

4 

FI4 

task_after_list 

pointer 

16 

FIS 

task_ready_time 

integer 

4 

F16 

task_deadline 

integer 

4 

F17 

task_duration 

integer 

4 

FI8 

task_resource_needs 

integer 

16 

F19 

task_buddy_list 

pointer 

16 


H-4 









F20 

task_max_re plic ation 

integer 

4 

F21 

task_priority 

integer 

4 

F22 

task_execution_probability 

integer 

4 

F23 

task_conimunication_delay_mairix 

integer 

4 

F24 

next_task 

pointer 

16 

F25 

previous_task 

pointer 

16 

F26 

ta.sk_error_cumulation 

integer 

4 

F27 

task_imprecise_eiTor_convergence 

integer 

4 

F28 

task_sdf 

pointer 

16 











* SOFTWARE TASK EDGE FILE * 

:t‘**4:*** ****** *************************************>k**iti*>fit‘**!tf*if***^*^i>i*ilf^ltli*illiif** 

FILE NAME; software_task_edge_file 


/FIELD 

#/FIELD NAME 

/DATA TYPE 

/FIELD 

FI 

id 

integer 

10 

F2 

name 

char 

100 

F3 

parent_module 

pointer 

16 

F4 

parent_module_edge 

pointer 

16 

F5 

task_edge_data 

pointer 

16 

F6 

from_task_node 

pointer 

16 

F7 

to_task_node 

pointer 

16 

F8 

next_task_edge 

pointer 

16 

F9 

previous_task_edge 

pointer 

16 

FIO 

task_edge_sdf 

pointer 

16 


[- 6 







* DATA ATTRIBUTE HLE * 

i^i|^:|^^lii^i^*^i^!ifll^*:^i^^ii|^:t^*s|^*******^*************m**********m*********l>^***************ii 

FILE NAME: data_attribute_rile 

/FIELD #/FIELD NAME DATE TYPE SIZE IN BYTES 


FI 

id 

integer 

10 

F2 

name 

char 

100 

F3 

data_kind 

integer 

4 

F4 

task_edge_list 

pointer 

16 

F5 

sender_kind 

integer 

4 

F6 

data_sender_Iist 

pointer 

16 

F7 

receiver_kind 

integer 

4 

F8 

data_receiver_list 

pointer 

16 

F9 

data_resource_need_list 

pointer 

16 

FIO 

data_deadline 

integer 

4 

Fll 

data_frequency 

integer 

4 





ilf,ii^iTtf**^i*iH>i*****^**************i** ********************* ************************* 

* HARDWARE STRUCTURE DIAGRAM RLE * 

*:^**************************************************************************** 

FILE NAME: hardware_structure_diagram_rile 

/FIELD #/FIELD NAME /DATA TYPE /SIZE IN BYTES 


FI 

id 

integer 

10 

F2 

name 

char 

100 

F3 

parent_implementation_view 

pointer 

16 

F4 

hw_group_node_list 

pointer 

16 

F5 

hw_group_link_list 

pointer 

16 

F6 

hw_group_link_iopology 

pointer 

16 

F7 

next_hw_diagram 

pointer 

16 

F8 

previous_hw_diagram 

pointer 

16 


H- 8 









* HARDWARE GROUP NODE FILE * 

FILE NAME: hardware_group_node_rile 


/FIELD 

#/FIELD NAME 

/DATA TYPE 

/SIZE IN BYTES 

FI 

id 

integer 

10 

F2 

name 

char 

100 

F3 

parent_hw_siructure 

pointer 

16 

F4 

parent_hw_group_node 

pointer 

16 

F5 

next_hw_group_node 

pointer 

16 

F6 

previous_hw^roup_node 

pointer 

16 

F7 

sub_hw_group_node_list 

pointer 

16 

F8 

sub_hw_group_link_list 

pointer 

16 

F9 

hw_group_Iink_topology 

integer 

4 

FIO 

hw_node_list 

pointer 

16 

Fll 

hw_link_list 

pointer 

16 

F12 

hw_node_link_topology 

integer 

4 

F13 

entry_super_lisk_list 

pointer 

16 

F14 

exii_super_link_Iist 

pointer 

16 

F15 

group_node_sdf 

pointer 

16 


H- 9 








* HARDWARE GROUP LINK FILE * 

**l(l**************j(C********!(C*******!(t***************>|t* + **!t!^t*!(C*:tt************=t=**** 

FILE NAME: hardware_group_link_rile 

/FIELD #/FIELD NAME /DATA TYPE /SIZE IN BYTES 


FI 

id 

integer 

10 

F2 

name 

char 

100 

F3 

parent_hw_stxucture 

pointer 

16 

F4 

from_hw_oroup_node 

pointer 

16 

F5 

to_hw^roup_node 

pointer 

16 

F6 

superjinkjist 

pointer 

16 

F7 

next_hw_group_link 

pointer 

16 

F8 

previous_hw_group_Iink 

pointer 

16 

F9 

group_link_sdf 

pointer 

16 











* HARDWARE NODE FILE * 

ilf!^l^:it::tlitc:t!:t‘***********************************************************'*********** 

FILE NAME; hardware_node_file 

/FIELD #/FIELD NAME /DATA TYPE /SIZE IN BYTES 


FI 

id 

integer 

10 

F2 

name 

char 

100 

F3 

hw_node_generic 

integer 

4 

F4 

hw_node_specific 

integer 

4 

F5 

hw_node_resource_available 

pointer 

16 

F6 

hw_Iink_list 

pointer 

16 

F7 

next_hw_node 

pointer 

16 

F8 

previous_hw_node 

pointer 

16 

F9 

intemal_hw_node_list 

pointer 

16 

FIO 

intemal_hw_link_list 

pointer 

16 

Fll 

parent_hw_group_node 

pointer 

16 

FI2 

parent_hw_node 

pointer 

16 

F13 

hw_node_sdf 

pointer 

16 


H-li 








iiy^^:t‘************************************************************************** 

* HARDWARE LINK FILE * 

**************************************** ******** 

FILE NAME: hardware_link_file 


/FIELD 

#/FIELD NAME 

/DATA TYPE 

/SIZE IN 1 

FI 

id 

integer 

10 

F2 

name 

char 

100 

F3 

generic 

integer 

4 

F4 

specific 

integer 

4 

F5 

dala_rate 

integer 

4 

F6 

data_latency 

integer 

4 

F7 

protocol 

integer 

4 

F8 

parent_hw_group_node 

pointer 

16 

F9 

parent_hw_node 

pointer 

16 

FIO 

parent_hw_group_link 

pointer 

16 

Fll 

next_hw_link 

pointer 

16 

F12 

previous_hw_link 

pointer 

16 

F13 

hwjink_sdf 

pointer 

16 


H-12 











* RESOURCE FILE * 

****Jtt****!(c**************J(t*!(t************1t**:(c****!(c:(c:(t*****:*;*****:(c**:tc^:;****:)c***:(c** 

FILE NAME: resource file 


/FIELD 

#/f:eld name 

DATA TYPE 

SIZE IN 

FI 

id 

integer 

10 

F2 

name 

char 

100 

F3 

task_node_lisi 

pointer 

16 

F4 

task_edge_Iist 

pointer 

16 

F5 

hw_node_list 

pointer 

16 

F6 

next_resource_node 

pointer 

16 

F7 

previous_resource_node 

pointer 

16 









* TIMING CONSTRAINT RLE * 

l(t***********************#***;(c*!(c*:(t*;tc#***:(c**:)c****!(c:(t*:(t*******:(c*:(c*t**:t:*=tt**!tt******* 

FILE NAME: timing_constraint_fiIe 


FIELD 

#/FILED NAME 

/DATA TYPE 

/DATA SYZE IN 

FI 

id 

integer 

10 

F2 

constraint_kind 

integer 

4 

F3 

preference_value 

integer 

4 

F4 

time_type 

integer 

4 

F5 

titne_value 

integer 

4 

F6 

software_id_list 

char 

100 

F7 

parent_mapping_constraint 

pointer 

16 

F8 

next_constraint 

pointer 

16 

F9 

previous_constraint 

pointer 

16 


H-14 












* PLACEMENT CONSTRAINT FILE * 

***!(c****:(c********!(c***!(£*****!(<*******:(c******:)c^***j(c****!|t:(c*:(c*:ic*:(c:t!*:)t********:(t:(c*!(c*** 

FILE NAME: placement_constraint_rile 


FIELD 

#/FILED NAME 

/DATA TYPE 

/DATA SYZE IN 

FI 

id 

integer 

10 

F2 

constraint_ldnd 

integer 

4 

F3 

preference_value 

integer 

1 . 

F4 

hardware_id 

char 

100 

F5 

software_id_list 

char 

100 

F6 

parent_mapping_constraint 

pointer 

16 

F7 

next_constraint 

pointer 

16 

F8 

previous_constraint 

pointer 

16 





:lt^:t‘******************************************************* ******** ************ 


* SYSTEM DESIGN FACTOR TEMPLATE * 

***********!(C****^I**********!(t4l**:tl***:(l#***j(C*********!*C*>(!**:»!*****:(t*:tt*******!tt*!tC*!t!:*t^t 

FILE NAME: sdf_template 

FIELD #/FIELD NAME /DATE TYPE SIZE IN BYTES 


FI 

id 

integer 

10 

F2 

name 

char 

128 

F3 

Attributes 

pointer 

16 

F4 

Rational 

char 

80 

F5 

Method_or_principle 

char 

240 

F6 

Quantirication_type 

integer 

4 

F7 

Quantification_formula 

pointer 

16 

F8 

Consistency_aggregat 

char 

10 

F9 

Consistency_type 

char 

200 

FIO 

Consistency_design_factor 

char 

20 

Fll 

Consistency_view 

char 

20 

F12 

Consistency_component 

char 

20 

F13 

QualityReq_type 

char 

20 

F14 

QualityReq_UsabiIity_ReIiability 

char 

20 

F15 

QuaIityReq_Usability_Performance 

char 

20 

F16 

QualityReq_Usability_Security 

char 

20 

F17 

QualityReq_Usability_HumanFactors 

char 

20 

F18 

ReferenceList 

char 

240 

F19 

Definitions 

char 

240 


H-16 









F20 


Annotations 


char 


F21 next_sdf_tem plate 


pointer 


H-17 











l(c**%****3tC!)t**!(c*j(cHc:(c*#**Kt:tCj(tJ(c*****************:(c**!(t:(t:(c*;(c*:^j)c******:tc***;tt:jt;|c:te;(c;tt*^t*:it***:t:* 


* SYSTEM DESIGN FACTOR ATTRIBUTE * 

^illfili-^itl)ififfif^:tfif:lf*iti:******************************!ili*******************^>liillL*^***:¥***** 

FILE NAME: sdf_atlribute 

FIELD #/FILED NAME /DATA TYPE /DATA SYZE IN BYTES 


FI 

id 

integer 

10 

F2 

Relationship 

integer 

4 

F3 

Properties_type 

char 

20 

F4 

Properties_range 

char 

50 

F5 

Properties_units 

char 

50 

F6 

next_attributes 

pointer 

16 









* SYSTEM DESIGN FACTOR QUANTIFICATION * 

FILE NAME: sdf_quantification 


FIELD 

#/FIELD NAME 

/DATE TYPE 

SIZE IN BYTES 

FI 

id 

integer 

10 

F2 

aggregate 

char 

10 

F3 

variable_list 

CHAR 

20 

F4 

next_formula 

pointer 

16 


end DIS_sdf_template_support; 









