NAVAL POSTGRADUATE SCHOOL 
Monterey, California 



THESIS 


SYSTEM CONTROLLER HARDWARE AND 
EMBEDDED SOFTWARE FOR THE PETITE 
AMATEUR NAVY SATELLITE (PANSAT) 

by 

James Anthony Homing 
September 1997 

Thesis Advisor: Rudolf Panholzer 

Co-Advisor: Randy L. Wight 


Approved for public release; distribution is unlimited. 


19980109 098 




REPORT DOCUMENTATION PAGE 


Form Approved OMB No. 0704-0188 


Public reporting burden for this collection of information is estimated to average 1 hour per response, including the time for reviewing instruction, searching existing data 
sources, gathering and maintaining the data needed, and completing and reviewing the collection of information. Send comments regarding this burden estimate or any other 
aspect of this collection of information, including suggestions for reducing this burden, to Washington Headquarters Services, Directorate for Information Operations and 
Reports, 1215 Jefferson Davis Highway, Suite 1204, Arlington, VA 22202-4302, and to the Office of Management and Budget, Paperwork Reduction Project (0704-0188) 
Washington DC 20503. ___ 

1. AGENCY USE ONLY (Zeov^ 2. REPORT DATE 3. REPORT TYPE AND DATES 

blank) September 1997 COVERED 


Master’s Thesis 


4. 

— — « ■ 

TITLE AND SUBTITLE System Controller Hardware and Embedded 

Software for the Petite Amateur Navy Satellite (PANSAT) 

5. 

FUNDING NUMBERS 

6. 

AUTHOR(S) Homing, James Anthony 



7. 

PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

Naval Postgraduate School 

Monterey CA 93943-5000 

8. 

PERFORMING 

ORGANIZATION 

REPORT NUMBER 

9. 

SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

10. 

SPONSORING/MONITORING 
AGENCY REPORT NUMBER 

11. 

SUPPLEMENTARY NOTES The views expressed in this thesis are those of the author and do not reflect the official 
policy or position of the Department of Defense or the U.S. Government. 

12a. 

DISTRIBUTION/AVAILABILITY STATEMENT 

Approved for public release; distribution is unlimited. 

12b. 

DISTRIBUTION CODE 


13. ABSTRACT (maximum 200 words) 

This thesis documents the design of the hardware and embedded software of a digital computer that provides 
autonomous control of the PANSAT spacecraft. The system was designed for use during a two year mission in a low 
earth orbit. The computer uses an Intel M80C186XL running at 7.3728 MHz, 512 kbytes of error-detection and 
correction RAM, 64 kbytes of ROM, and standard CMOS components to provide a general purpose microcomputer. 
The purpose of the computer is to control all subsystems of the spacecraft, perform analog-to-digital conversions, 
orchestrate duplicate hardware components to provide redundancy, and upload new software from a ground station. 
The hardware system was built on printed circuit boards which were manufactured by the Space System Academic 
Group and tested for proper operation. The embedded software was coded using 80186 Assembler and the C 
programming language, tested for proper operation, and placed into ROM as firmware. 

14. SUBJECT TERMS PANSAT, Digital Computer, Embedded System, Device Drivers, 15. NUMBER OF 

Spacecraft Control PAGES 302 

__ 16. PRICE CODE 

17. SECURITY CLASSIFI- 18. SECURITY CLASSIFI- 19. SECURITY CL AS SIFI- 20. LIMITATION OF 
CATION OF REPORT CATION OF THIS CATION OF ABSTRACT 

Unclassified PAGE ABSTRACT UL 

Unclassified Unclassified 


NSN 7540-01-280-5500 


Standard Form 298 (Rev. 2-89) 
Prescribed by ANSI Std. 239-18 298-102 



























Approved for public release; distribution is unlimited. 


SYSTEM CONTROLLER HARDWARE AND EMBEDDED SOFTWARE 
FOR THE PETITE AMATEUR NAVY SATELLITE (PANSAT) 

James Anthony Homing 
Naval Postgraduate School 

B.S.C.S., California Polytechnic - San Luis Obispo, 1989 

Submitted in partial fulfillment 
of the requirements for the degree of 

MASTER OF SCIENCE IN ELECTRICAL ENGINEERING 

firom the 


NAVAL POSTGRADUATE SCHOOL 



Department of Electrical and Computer Engineering 


iii 



ABSTRACT 


This thesis documents the design of the hardware and embedded software of a digital computer 
that provides autonomous control of the PANSAT spacecraft. The system was designed for use during a 
two year mission in a low earth orbit. The computer uses an Intel M80C186XL running at 7.3728 MHz, 
512 kbytes of error-detection and correction RAM, 64 kbytes of ROM, and standard CMOS components to 
provide a general purpose microcomputer. The purpose of the computer is to control all subsystems of the 
spacecraft, perform analog-to-digital conversions, orchestrate duplicate hardware components to provide 
redundancy, and upload new software from a ground station. The hardware system was built on printed 
circuit boards which were manufactured by the Space System Academic Group and tested for proper 
operation. The embedded software was coded using 80186 Assembler and the C programming language, 
tested for proper operation, and placed into ROM as firmware. 


V 






TABLE OF CONTENTS 


I. INTRODUCTION.1 

A. Purpose.1 

B. Scope.1 

II. BACKGROUND INFORMATION. .....3 

A. THE PANSAT PROJECT.3 

B. MISSION LIFE AND OPERATING ENVIRONMENT.4 

1. Thermal Environment.4 

2. Operational Environment.5 

3. Radiation Environment.5 

C. RADIATION EFFECTS ON ELECTRONICS.5 

1. Single Event Effects.5 

2. Single Event Effects Experienced by PANSAT.6 

D. DOCUMENTATION CONVENTIONS.6 

1. Numbering.6 

2. Signal Names.6 

3. Logic Expressions.6 

4. Software Flow Diagrams.7 

III. PANSAT ELECTRONICS AND SOFTWARE OVERVIEW...9 

A. DESIGN CONSTRAINTS AND TRADEOFFS.9 

B. PANSAT SUBSYSTEM HARDWARE GENERAL DESCRIPTION.10 

C. SYSTEM CONTROLLER ORGANIZATIONAL OVERVIEW.11 

1. Hardware Organization. 12 

2. Software Organization.14 

IV. SYSTEM CONTROLLER HARDWARE. 17 

A. MICROPROCESSOR.17 

1. Reset Circuitry and Timing.17 

2. Input Clock.17 

3. Interrupts and Direct Memory Access.18 

4. Memory and Chip Selects.19 

5. Timers.20 

B. POWER SENSING AND REGULATION.20 

1. Power On Detection.20 

2. DC-DC Conversion.22 

C. PERIPHERAL DATA BUS.23 

1. Programmable Peripheral Interface.23 

2. Peripheral Control Bus (PCB).23 

3. Modem Control Interface.24 

4. CPU Signal Isolation and Latching.25 

5. Signal Timing to Modem Board.26 

D. MEMORY.26 

1. ROM.29 

2. Error Detection and Correction.29 

a. Existing Design.29 

b. Modifications of the Write Back Control.29 


vii 
















































c. Modification of the Reset Circuitry.30 

d. Modification of the ED AC Error Acknowledge.31 

e. Modification of the Transceiver Enables. 31 

E. ANALOG-TO-DIGITAL CONVERSION. 

1. A/D Converter.. 

2. Analog Switch.. 

3. Voltage Clamping and Low-pass Filter. 33 

4. Wiring.. 

5. Connector.. 

6 . Temperature Sensing IC. 34 

F. SERIAL COMMUNICATIONS. 

1 . Serial Communications Controller. 34 

2. RS-232 Drivers and Receivers. 36 

3. Connector.. 

V. SYSTEM CONTROLLER SOFTWARE DRIVERS.37 

A. DESCRIPTION.. 

B. HIERARCHY AND MODULE RELATIONSHIPS. 38 

C. STARTUP.............38 

1 . Hardware Initialization. 39 

2. Memory Check and Clear. 40 

3. Data Relocation.. 

4. Floating Point Emulation.. 

5. C Runtime. 41 

D. CPU SUPPORT.1ZZZ”ZZ!Z”ZI!ZZZ'**ZZZ*42 

1 . Timers and Interrupts.. 

a. Timers.. 

b. Interrupt Priority Structure. 43 

2. EDAC (Setup and RAM Wash).ZZ****!Z!!Z**ZZ'Z44 

a. Initial RAM Clearing. 45 

b. RAM Wash.*...ZZ!Z”*'ZZ”Z*IZ'”****45 

c. Processing a Single Bit Error.. 

d. Processing a Dual Bit Error. 46 

E. MAIN.ZZZ!”'Z*ZZ"ZI”Z46 

F. PROGRAMMABLE PERIPHERAL INTERFACE.!Z!IZZZZZZZ!Z*48 

1 . EDAC Control.. 

2 . Peripheral Control Bus.. 

3. PPI Control Interface.. 

4. Peripherals of the Control Bus. 48 

5. Reading from the Control Bus. 49 

6 . Writing to the Control Bus. 49 

7. Software Interface. 49 

a. Application Programming Interface. 49 

b. Timing Requirements.50 

G. ELECTRICAL POWER SUBSYSTEM.ZZZi^ZZZZZZIZ^^ZZ^SO 

1. EPS Pori Organization.. 

2. EPS Cell Voltage Multiplexing. 51 

a. Low Battery Cell Voltage Selections. 51 

b. Medium Battery Cell Voltage Selections.51 

c. High Battery Cell Voltage Selections. 51 

3. EPS Cell Voltage and Current Multiplexing. 51 

H. SERIAL COMMUNICATIONS. ZZZ^Z‘ZZZZZ.52 

1. Modem Control.. 

2. RF Control. 52 


viii 

























































3. see Drivers. 53 

a. Asynchronous Services.54 

b. Synchronous Services.54 

I. TELEMETRY.54 

1. Scheduling of the LM12H458.54 

2. LM12H458 Setup and Interrupt Service Routines.55 

3. Data Gathering - Temperature Multiplexers.57 

4. Data eonversion.57 

a. Battery eurrent eonversion.57 

b. Spacecraft Bus eurrent eonversion.58 

c. Battery Voltage eonversions.58 

d. Thermistors.59 

e. Temperature Sensors (les).59 

5. Data Recording.59 

J. MASS STORAGE INTERFAGE.60 

1. Hardware Interface Via the PeB.60 

2. Software Interface.61 

a. Reading and Writing Requirements.. 62 

b. API Functions.62 

c. Timing Requirements.63 

VL SYSTEM CONTROLLER HIGH-LEVEL SOFTWARE. 65 

A. DESeRIPTION.65 

B. SERIAL eOMMUNieATIONS - Serial Test Port Interface.65 

e. BATTERY GHARGE MONITOR.67 

1. BGM Top Level.67 

2. Battery Use Eligibility And Preference.69 

3. Determine Online Battery.71 

4. Determine Target Battery.73 

5. Gharging Methods.75 

a. Overcharge. 75 

b. Recharge.76 

6. Battery Mode.77 

D. GROUND STATION GOMMAND INTERFAGE.78 

1. Gommand Packet Protocol.78 

2. Gommands.79 

a. Gonflrm. 79 

b. Gontrol. 79 

c. Execute.79 

d. Get Parameters.79 

e. Load.79 

f. Map.79 

g. Reset.80 

h. Set Parameters.80 

L Status.80 

j. Status Log Glear.80 

k. Status Log Read.80 

l. Verify.80 

m. Unknown.81 

3. Loading Sequence.81 

E. SGENARIO GHEGKS.82 

VIL RESULTS, RECOMMENDATIONS, AND CONCLUSION...83 

A. RESULTS.83 


ix 























































1. Printed Circuit Board.. 

2. Use of In-Circuit Emulator. 83 

3. Software.84 

4. Testing.85 

B. RECOMMENDATIONS. 85 

C CONCLUSION. 

APPENDIX A. HARDWARE SCHEMATICS.87 

APPENDIX B. SYSTEM CONTROLLER CONNECTOR PIN-OUTS.93 

APPENDIX C. CIRCUIT BOARD BILL OF MATERIALS.97 

APPENDIX D. PERIPHERAL CONTROL BUS PROGRAMMABLE 
PERIPHERAL INTERFACE PORT CONFIGURATION.101 

APPENDIX E. ELECTRICAL POWER SYSTEM PORT CONFIGURATION...103 

APPENDIX F. A/D ACQUISITION.107 

APPENDIX G. THERMISTOR TEMPERATURE CONVERSIONS.109 

APPENDIX H. SPACECRAFT COMMAND ENCODING.113 

APPENDIX I. SOFTWARE GENERATION FACILITIES.115 

APPENDIX J. SOFTWARE SOURCE CODE.119 

APPENDIX K. TEST PLANS.285 

LIST OF REFERENCES.289 

INITIAL DISTRIBUTION LIST.291 




















I. INTRODUCTION 


A. Purpose 

The purpose of this thesis is to document the design of a system that implements the digital 
computer of the Petite Amateur Navy Satellite (PANSAT). PANSAT is an experimental, low cost, 
lightweight, communications satellite that is currently being designed and built by officer students 
supported by the Space Systems Academic Group at the Naval Postgraduate School in Monterey, 
California. The design consists of the implementation details of the hardware as well as the low-level 
software that is embedded within the system. The computer, called the System Controller, incorporates 
error detection and correction memory for random-access memory, a read-only memory, specialized 
synchronous and asynchronous serial communications, analog-to-digital conversion, a parallel digital bus 
for subsystem control, and power detection and DC-DC conversion. 

B. Scope 

Chapter II provides backgroimd information which includes a general description of the PANSAT 
project and its operational environment, radiation effects on electronic circuits, and general conventions 
used when writing this document. The third chapter presents an overview of the organization of the 
electronics of PANSAT, and a description of the hardware and software architectures of the System 
Controller. Chapter IV discusses the hardware design in detail. The fifth chapter describes the software 
device drivers design in detail and Chapter VI examines the higher-level software routines which use the 
device drivers. Chapter VII examines the testing of the hardware and software, presents recommendations, 
and ends with the conclusion. Several appendices follow containing the hardware schematics, the bill of 
materials for the hardware, software block and flow diagrams, software source code, and software 
generation facilities. 


1 





II. BACKGROUND INFORMATION 


A. THE PANSAT PROJECT 

The PANSAT project began in 1989 as an educational program for students at the Naval 
Postgraduate School’s (NPS) Space Systems Academic Group (SSAG). The project goal is to provide 
meaningful and realistic research topics for students in the area of space systems engineering and space 
systems operations. In doing so, the Space Systems Academic Group has prepared students for space 
related tasks and has developed an infrastructure of facilities and personnel capable of developing space 
qualified systems. 

PANSAT is a small satellite for digital store-and-forward communications in the amateur 
frequency band. It features a direct sequence spread spectrum differentially coded, binary phase shift keyed 
(BPSK) communication system at an operating frequency of 436.5 MHz. The store-and-forward capability 
will allow NPS and amateur radio operators to send or receive messages during several short 
communication windows every day, each 4 to 8 minutes in duration. 

The entire satellite structure weighs approximately 150 pounds, has a diameter of about 19 inches, 
and is designed to be launched as a secondary payload from the Space Shuttle via the Hitchhiker Program. 
PANSAT is a 26-sided polyhedron, as shown in Figure 1, a configuration chosen to maximize solar panel 
area and thus power generation. PANSAT is not stabilized and will tumble freely once put into space. The 
satellite uses an omni-directional antenna system consisting of four quarter wave-length segments to 
achieve near uniform signal coverage regardless of PANSAT’s orientation while tunbling in space. 

PANSAT requirements specify a two-year mission life in a low-earth orbit (LEO) with an 
inclination between 28,5® and 90.0® [Ref, 1]. The Space Systems Academic Group has signed a 
Memorandum of Agreement with NASA Space Test Flight programming, ensuring a future flight onboard 
the Space Shuttle. Space Shuttle operational limits are altitudes between 203.7 km and 611.2 km and 
inclinations between 28.5® and 57.0® [Ref. 2]. 


3 



Aniennas {4) 


S^lar Panels (5> 


Upper _ 

E|,u| 5 m*nt 


Solar Pant^ls (S) 

Dfgltal Control 
Subsyatem (DCS) 



Solar Pans 1 b ( 4 ) 


Solar Pone 


MoffB Storage 
(9 mb] 

Ana I Dg 
Muxing 


Eiectrraol Pavwir 
5ubayet«m <EPS) 


Lower 
Equipment 
PIatform 


Radio Froguenev 
(RF) Section & Lid 


H^A Heat Sink 
Cnver 


Boeepialo 


Mioraswitch (3) 
& BrocKat 


Figure 1. PANS AT Structure, 


B. MISSION LIFE AND OPERATING ENVIRONMENT 
1. Thermal Environment 

Thermal analysis for temperatures of electronics inside PANSAT examines two situations: a hot 
case and a cold case, depending on solar flux and Sun orientation, the Earth, and internal power dissipation 
within the satellite. The cold case expects the temperature inside during operation to be between -15°C and 
-6^C, and the hot case predicts temperatures from about-4°C to 13°C [Ref 3]. While these temperatures 
are well suited for the operation of integrated circuits (IC), the batteries prefer a warmer environment; this 
will be addressed briefly in the section describing the Battery Charge Monitor, in Chapter VI. 


4 



2. Operational Environment 

PANSAT electronics are expected to provide continuous operation throughout the life of the 
satellite. Solar panels will provide sufficient energy during the sun-soak portion of an orbit to allow 
continuous operations of the satellite and to store energy into the batteries for the eclipsed portion of the 
orbit. The PANSAT System Controller design incorporates two redundant, mutually exclusive, system 
controllers which are prevented from simultaneous operation because of the switching design within the 
electrical power system (EPS). 

3. Radiation Environment 

In LEO, PANSAT will be significantly protected from cosmic radiation and the solar wind due to 
the shielding effects of the Earth’s magnetic field [Ref 4, p. 662], as well as the thickness of the structure 
itself. The primary source of radiation in LEO is low energy electrons, and low energy protons which are 
encountered mostly in the South Atlantic Anomaly (SAA) from approximately 45° latitude and 45° 
longitude centered near 20°N, 20° W [Ref 5, p. 2339; Ref 6, p. 2344]. Energetic protons, an occasional 
source of radiation, are expected with solar flares [Ref 4, p. 712]. Asa result PANSAT should experience 
an ionizing radiation dose rate of about one krad (Si) per year [Ref 4, p. 452]. 

C. RADIATION EFFECTS ON ELECTRONICS 

There are two primary effects caused by radiation on electronics: an effect from the dose rate that 
causes single event upsets (SEU), as well as a total dose effect. PANSAT will orbit in a relatively benign 
radiation environment compared to other regions of space. The selection of PANSAT electronics 
incorporate some concern for radiation exposure; however, the structure of the spacecraft including the 
boxes which contain the electronic modules provides substantial radiation shielding. As a lowest common 
denominator of electronic component selection where redundancy applies, industrial temperature grade 
integrated circuits fabricated with Complementary Metal Oxide Semiconductor (CMOS) technology using 
epitaxial layers are used. Circuitry of PANSAT that presents a source of a single point of failure uses 
radiation hardened devices. Otherwise, these radiation hardened devices are expensive, power-hungry, and 
an unnecessary choice for PANSAT. 

1. Single Event Effects 

Single event effects (SEE) are the responses of an IC to the passage of a single highly energetic 
charged particle, and include single event upsets (SEU), single event latchup (SEL), and single event 
burnout (SEE). As a particle travels through the silicon layers of an IC, it loses energy creating ionization 
or electron-hole pair generation along its path. Generally, the higher the mass and charge of the particle, 
the greater the amount of ionization produced. 


5 


SEBs are observed in power MOSFETs where high voltages and electric fields are present; and 
thus are not a real concern for PANSAT electronics of the System Controller. However SELs, the effect of 
activating a parasitic silicon controlled rectifier within a CMOS IC, has the potential to destroy a device or 
a portion of a device while it is in the latched condition. In order to reset the device it must be powered 
off. Fortunately, thoughtful device design can reduce or eliminate this effect. The SEU is the most 
common effect to upset an IC, resulting in a temporary or permanent change of state. SEUs are the result 
of the rate of individual hits on electronics, in particular an IC by high energy particles. SEUs result in 
errors within electronic systems by causing a change in the state of a logic storage element [Ref. 7], 

2. Single Event Effects Experienced by PANSAT 

PANSAT is expected to experience a variety of SEEs throughout its lifetime. At worst, these 
effects will most likely cause a particular system to reset; initiating a restart of the electronics, as if a launch 
has just occurred. The design of PANSAT allows the electronic systems to be powered down, and then 
back up. Such action clears such SELs. Fortunately, PANSAT is not expected to experience many SELs. 

D. DOCUMENTATION CONVENTIONS 

1. Numbering 

By default, all numbers in this thesis are base-10 (decimal). Base-16 numbers (hexadecimal) are 
prefixed by the following notation. Ox. Thus, the number OxOF is the hexadecimal value for 15 (decimal); 
an exception to this rule is found only within the assembly language excerpts of the software module 
startup.asm where the convention of the assembler is to append an h, e.g. OFh. Binary values are either 
evident (only one digit exists), or are pointed out within the text. 

2. Signal Names 

Signal names are chosen to best represent the function they perform. In addition, digital signals 

also include the logic assertion level. If a signal has an overbar across its name, e.g. RD, then that signal 
is considered active LOW; that is, it is considered asserted when the signal is a binary 0, corresponding to 0 
V. Otherwise, the signal is considered active HIGH; that is, it is considered asserted when the signal is a 
binary 1, corresponding to 5 V. 

3. Logic Expressions 

Logic equations for circuit diagrams and Karnaugh map analyses presented in this document use 
the + symbol for the inclusive logical OR function. The logical AND function is represented with the 
symbol *. The overbar either indicates the assertion level of a signal (as explained in the section above) 


6 


when it is the result of an equation, or indicates the negation of a logic expression. Otherwise, for 
programming languages (i.e. C), the operator rules of the language apply [Ref. 8, Ref. 9]. 

4. Software Flow Diagrams 

Software flow diagrams use blocks to depict either a subroutine or a statement. Bold blocks refer 
to subroutines. 


The project background and expected operating environment were considered in designing the 
PANSAT System Controller hardware and software. In addition, the System Controller design was 
influenced by the other electronic modules of the spacecraft. An overview of the hardware and software 
designs as well as an introduction to the spacecraft electronic modules are presented in the next chapter. 


7 



8 



III. PANSAT ELECTRONICS AND SOFTWARE 

OVERVIEW 


This chapter provides design constraints and tradeoffs that influenced the design of the System 
Controller. Furthermore, an overview of the electronic systems of PANSAT is presented as well as an 
architectural overview of the System Controller hardware and software. 

A. DESIGN CONSTRAINTS AND TRADEOFFS 

The design objective was to build a digital computer (system controller) using readily available 
components. Six major constraints influenced the design: 

• Suitability for use in a short duration low-Earth orbit radiation environment. 

• Printed circuit board area required. 

• Speed of operation. 

• Power required. 

• Cost. 

• High-level software environment support and compatibility with existing software tools. 

PANSAT will operate on a limited power budget; all power is dependent upon solar panels with 
batteries to store power. Generally, faster systems require more power. Furthermore, radiation hardened 
components usually require more power than the non-hardened counterparts. Also, radiation hardened 
parts are usually extremely expensive (averaging 20 times the cost of a comparable high reliability, non 
radiation hardened part). The cost of using radiation hardened parts within PANSAT is neither justified 
nor necessary. 

In general CMOS was chosen over other logic families because of its lower power consumption. 
Often, standard small scale integration (SSI) and medium scale integration (MSI) parts were chosen for 
logic generation because they are readily available and offer decreased susceptibility to SEUs at a 
reasonable cost. Since PANSAT System Controller operates at a relatively low clock rate, power was 
judged as less critical than size and functionality. 

Two families of CMOS logic ICs are used throughout the design of the System Controller, High¬ 
speed CMOS and Advanced CMOS [Ref, 10]. The Advanced CMOS (AC) is approximately three to five 
times faster than the equivalent High-speed (HS) devices; however, the AC devices consume about 50% 
more power. AC components are also more expensive. AC components are used in the design only where 
necessary. They are mostly found in the memory glue logic. 


9 



For many LSI and VLSI devices in this design, high reliability (not radiation hardened), military 
temperature rated components are used wherever possible. Many devices are processed to the 
MIL-STD-883 specifications. A few others are processed to industrial specifications. All circuit 
components are identified in Appendix C which contains the Bill of Materials (BOM) for the circuit board 
fabrication. 


B. PANSAT SUBSYSTEM HARDWARE GENERAL 
DESCRIPTION 


Figure 2 shows a block diagram of the entire PANSAT electronics. Redundant modules: System 
Controller (SC), Analog Temperature Multiplexers (TMUX), and Mass Storage (MS), are shown above 
and below the common electrical bus called the Peripheral Control Bus (PCB). Primary and redundant 
module designation is arbitrary since respective modules are essentially identical. Redundant modules in 
standby mode will be powered off However, because the control bus allows individual module addressing 
by the active SC, either, or both, of the modules (TMUX or MS) may be enabled. The two remaining 
modules of the PANSAT electronics are the Radio Frequency (RF) system responsible for up and down 
conversion of the communication signals, and the Electrical Power Subsystem (EPS) which is responsible 
for the distribution of power on the satellite. 


10 




Figure 2. PANSAT Block Diagram. 


The EPS controls the charging of the batteries via the solar panels and the distribution of power to 
the rest of the spacecraft. The satellite has 18 solar panels for the production of power. Power is stored in 
two banks of nine batteries each. Each battery bank has the capability of providing complete power for the 
satellite. The mass storage system provides the memory needed for storage of telemetry and data uploaded 
to the satellite by users of the satellite. It contains two redundant systems, each with 4.5 Mbytes of random 
access memory. The TMUX is an analog multiplexer which directs which temperature sensor is being read 
by a System Controller. There are temperature sensors on all major satellite components to provide a 
monitoring capability. 

C. SYSTEM CONTROLLER ORGANIZATIONAL OVERVIEW 

The System Controller of PANSAT is an embedded microprocessor-based computer system for 
the satellite. The electronics provide interface circuits to control all of the satellite’s subsystems, as well as 
create an environment capable of supporting high-level software. Firmware, embedded within ROM in the 
computer, is the software that is capable of initializing the entire satellite, maintaining the batteries, and 
conducting simple communications with Earth with the goal of uploading more sophisticated software. 


11 












1. Hardware Organization 

As mentioned above, the PCB is an 8-bit parallel control and data bus capable of uniquely 
addressing each subsystem in the spacecraft. Each subsystem has a unique power connection, switchable 
by command of the SC via the EPS. Also, each subsystem has a unique address in which it responds to 
commands issued by the active SC to perform reads and writes between the SC and the subsystem. Each 
subsystem has radiation hardened circuitry to interface the subsystem to the PCB. These components were 
chosen because this bus is not redundant and is a single point of failure. The electronic circuits of the PCB 
are always powered on when the spacecraft has bus power. These electronic circuits are responsible for 
isolating a subsystem from the bus when it is not powered on; the same circuits enable each subsystem to 
respond when powered on and addressed via a SC. 

The System Controllers differ from the other subsystems in that they are capable of controlling the 
PCB (rather than responding to the PCB). However, within the EPS is circuitry which allows only one SC 
to be powered on at a time in order to remove the possibility of two controllers manipulating 
simultaneously the PCB. A SC remains powered on unless it fails to notify the EPS within a certain time 
interval; thus a SC is subject to an external watchdog timer contained within the EPS. 

The system controllers are identical in design. However, the remaining discussions will normally 
refer to a single system controller, implying the same applies to the other SC. A SC is best understood by 
viewing its design from a top-down approach. As seen in Figure 3, at the top-most layer is a 
M80C186XL-10 microprocessor and some of its support circuitry for a clock and reset circuitry, to the 
right side are four other blocks. On the top-right is the general control input/output (I/O) module, the next 
block down on the right is the serial communications control module, next is the system memory module, 
and at the bottom is the Analog-to-Digital module. Also shown is the signal interface between the 
modules, required within a System Controller. A photo of the completed circuit board is shown following 
the block diagram. 


12 




Figure 3. System Controller Block Diagram. 


13 


title: 

PftNBOT SYSTEM CONTROLLER BLOCK DIRGRRM 














































Figure 4. System Controller Circuit Board. 


The M80C186 is available in many versions, each with a different maximum input clock rate. 
Within this document, 80186 will refer to any version of the microprocessor, and M80C186XL will refer 
specifically to the XL-10 (10 MHz) version which is used on board PANSAT. 

2. Software Organization 

The software organization of a SC resembles closely the hardware. However, since software not 
only provides control of hardware but also involves a process flow (the goal of the software is to do 
something from start to finish), further modules are useful in implementing the software for PANSAT. 

The goal of the software described within this document is to provide simple and reliable control 
of the spacecraft in order to upload high-level layers of software which are modifiable from a ground 
station. This software is known as the ROM Boot software. It is embedded on space qualified ROM, eind 
is thus a permanent product, also known as firmware. 

Looking at the ROM boot software as in Figure 5, the first software module is responsible for the 
System Controller Startup. Next is the Boot Loader software which works as a large loop, making sure all 
the other modules orchestrate together correctly. Within this boot loading process, there are modules 


14 






















responsible for the control of the batteries, responding to communications requests from a ground station, 
and dealing with scenarios which require alternate configurations of hardware. 


PANSAT ROM Boot 



Figure 5. ROM Boot Software Overview. 


Viewing from the software module perspective. Figure 6, there are device drivers for the CPU 
setup, the EDAC RAM, the PCB, the mass storage units, the serial communications, and telemetry 
gathering which includes driving the analog-to-digital circuits. This figure depicts all of the files required 
to describe the code of the entire ROM Boot software. 


This overview presented high-level descriptions of the System Conroller hardware and software in 
order to discuss in more detail the designs of these systems. The next few chapters describe in great detail 
the hardware and software designs of the System Controller, beginning with a presentation of the hardware 
that implements the satellite’s general purpose computer. 


15 







Figure 6. ROM Boot Software File Hierarchy. 


16 


CL0CK.C INT.C EDAC.C. MODEM.C RFC SPACKET.C PRINT,C TERMS.C STPl.C 

CLOCK.H. INIH EDAC.H. MODEM.H. RF.H. SPACKET.H PRINT.H. TERMS.H STPl.H. 

































IV. SYSTEM CONTROLLER HARDWARE 


A. MICROPROCESSOR 

The M80C186XL-10 microprocessor from Intel [Ref. 11, Ref 12, Ref 13] provides CPU 
functionality for the System Controller. This 10 MHz version provides well tested and high-level 
integration that is very suitable for PANS AT. Within the M80C186 package are the following integrated 
features: 


• CPU core with a CISC instruction set, compatible with 8086/8088 instruction sets. 

• Programmable memory (5) and peripheral chip (6) selects, with wait state generators. 

• A clock generator, providing three timers. 

• Programmable interrupt controller. 

• Two channel Direct Memory Access (DMA) controller. 

The M80C186XL-10 was chosen for PANSAT for many other practical reasons, such as: 

• Military version (providing high reliability at a low cost) of the popular 80186. 

• The design team has extensive experience designing Intel-based embedded systems. 

• Software development tools were already available for this CPU architecture. 

1. Reset Circuitry and Tinning 

A simple RC circuit forces the RES input of the M80C186XL low for a sufficient time so that the 
CPU assumes a Reset state. Values of R = 10 kQ and C = 1 pF create a time constant of 10 msec, assuring 
the System Controller board of stable power by the time the CPU Reset state is assumed. 


2. input Clock 

A fixed frequency source of 14.7456 MHz feeds the XI input of the M80C186XL, which in turn 
divides that signal by two to form a 7.3728 MHz processor and board level system clock for the peripheral 
devices which use clocks (serial communications controller, memory, and the A/D converter). This is well 
within the timing limits of the peripherals. Of particular concern are two peripherals. First, the 82C55A 
will operate up to 8 MHz (it does not use a clock, but rather will read and write up to a speed of 8 MHz). 
Second, the ED AC unit is designed to work with this timing, and would only allow approximately a 15% 
faster clock. Faster components would have to be incorporated in the design if the clock rate were to 
increase (this increase in speed would also cause an increase in power consumption). 


17 




3. Interrupts and Direct Memory Access 

The M80C186XL has an Interrupt Control Unit, shown in Figure 7, which synchronizes and 
prioritizes interrupt sources and provides the interrupt vector to the CPU. Hardware interrupts can 
originate from on-chip peripherals (such as the timers) and from four external interrupt pins. 


TIMER TIMER TIMER DMA DMA INT INT INT INT 



Figure 7. Interrupt Control Unit Block Diagram [from Ref. 12] 


External hardware interrupts supported with the design of the System Controller are Interrupt 
Requests (IRQ) 0-3, which are labeled INTO - INT3, and the DMA requests, which are labeled DRQO 
andDRQl. IRQO through IRQ3 map to absolute interrupt numbers 12 through 15. DRQO and DRQl 
map to absolute interrupt numbers 10 and 11. The IRQs are designated to the peripherals of the System 
Controller that require interrupt support, as shown in Table 1. The DMA interrupts are used with data 
transfers with the SCC. 


Interrupt/DMA 

Request 

Absolute 

Interrupt 

Purpose • 

INTO 

12 

SCC (85C30) 

INTI 

13 

A/D Converter (LM12H458) 

INT2 

14 

EDAC Hard Error 

INT3 

15 

EDAC Soft Error 

DMAO 

10 

SCC W / REQA (Receive request) 

DMAl 

11 

SCC DTR / REQA (Transmit request) 


Table 1. External Interrupt Requests. 


18 


























4. Memory and Chip Selects 

The M80C186XL supports many programmable memory and chip select signals which reduces 
the number of external components needed to perform the logic of address decoding to memory and 
devices. For memory chip selects, there are six select outputs for three memory address areas: upper, 
midrange, and lower memory. One signal is provided for upper, another for lower, and four for the 
midrange memory. The range and starting addresses are user-programmable. A unique configuration was 
chosen for PANSAT. The ROM select is generated using the upper memory chip select. Traditionally, 
RAM is selected using a combination of the lower chip select and midrange chip selects, depending on the 
amount of RAM. Since only 512 kbytes of RAM exist, it is possible for the midrange chip select logic to 
generate all the select signals to the RAM. Since all of the RAM is ED AC controlled, this reduces RAM 
decoding since only the midrange chip selects need examining, the lower memory chip select can be 
ignored. 

The M80C186XL supports up to seven external peripheral chip selects. However, the System 

Controller only uses five chip selects (PCS4 - PCSO), leaving the remaining chip selects as buffered 
addresses (A1 and AO) of the CPU. These chip selects access a contiguous block of I/O address space. 
Each chip select goes active for 128 bytes. The base address can begin on any 1 kbyte boundary, and is 
programmed to begin with address 0 for PANSAT. Figure 8 shows the chip-select block diagram of the 
M80C186XL. Table 2 shows chip-select allocation for PANSAT. 


INTERNAL 

ADDRESS 

BUS 


-N 


_ 






= BLOCK SIZE 


= BLOCK SIZE/4 
= BLOCK SIZE/4 
sBLXK SIZE/4 
= BLOCK SIZE/4 


‘ MCS3 

■ MC« 

- mcsT 

■ MCSO 


MEMORY/ 
I/O SELECTOR 

MS 




BASE 4128 


PCSO 

^1 

pcsi 

PCS3 


INTERNAL 
ADDRESS BIT 




A 

MUX 

A2 - 

B 

A/B 


EX 

CONTROL BIT 


Figure 8. Chip Select Block Diagram [from Ref. 12]. 


19 







t Chip Select 

Flirtation 

Add^^ Range 

ucs 

ROM chip select 

OxFOOOO - OxFFFFF 

MCS3-MCS0 

RAM chip selects 

0x00000 - 0x7FFFF 

LCS 

Unused. 

Inactive. 

peso 

see (85C30) 

I/O: 0x00 - 0x7F 

PCSl 

A/D (LM12H458) 

I/O: 0x80 - OxFF 

PCS2 

PPI (82C55A) 

I/O: 0x100-0xl7F 

PCS3 

Modem Latch 

I/O: 0x180-OxIFF 

PCS4 

PA-100 

I/O: 0x200 - Ox27F 


Table 2. Chip Selects. 


5. Timers 

The M80C186XL contains a timer control unit which has three timers, of which two have external 
inputs and outputs. The internal timer, Timer 2, is used as a system clock tick generator. The two timers 
with external outputs, also have external inputs, allowing the triggering of the timers from external sources, 
independent of the CPU clock. Except for a system clock, the only other need for a timer for the System 
Controller is a hardware-timed power on switch for the RF output. Since the RF output can be on for up to 
ten seconds, the two timers are connected in cascade. These timers are used with an external gate to force 
the RF output off when the timer output expires. 

B. POWER SENSING AND REGULATION 

Power sensing and regulation are an important part of the System Controller circuitry. The 
circuits provide signal isolation between the System Controller and the Peripheral Control Bus when the 
SC is powered off, monitor switched power from the Electrical Power Subsystem (EPS), and provide 
regulated +5 V to the System Controller when active. 

1. Power On Detection 

The MAX8212 [Ref. 14] is a programmable voltage detector used to sense the powering on of a 
System Controller by the EPS. Since only the circuitry which isolates a System Controller from the 
Peripheral Control Bus (PCB) is active at all times, this voltage detector has the responsibility of quickly 
sensing the power on, removing the signal isolation between the System Controller and the PCB and 
activating the DC-DC converter, the MAX744A. The output (OUT) of the MAX8212 controls the enabling 
of the pass gates, 54HC125s, used to isolate signals between the SC and the PCB when the SC is inactive. 
When power on is not detected, OUT is high, disabling these gates. This circuitry is shown in Figure 9. 


20 
































U23 



Figure 9. Power On Detect and Signal Isolation. 


The resistors labeled 120 are 120 Q resistors used to reduce current leakage into non-powered devices 
when the SC is not active. 

The MAX8212 uses input hysteresis to set the detect on and detect off voltage levels. These 
levels are programmed with external resistors. The selection of the resistors was determined by solving for 
the equations given in the databook (Equation 1) in conjunction with selecting resistors that are available as 
1% precision and highly reliable and reducing the source current used by the device. Three resistors are 
used, Rp, Rq, and Rg. The detect voltages are Vj,, for the high voltage in which the power on detect occurs, 
and V|, for the low voltage in which the power off detect occurs. 


21 




( 1 ) 


V< = 


RqRs 

^Rq + Rs 



r n 

+ Rp 

r 

y 



(1.15) and V,= 


' Rp+Rq] 
Rp ) 


(1.15) 


Power from the EPS to a System Controller will be between approximately 10 V to 15 V, 
depending on whether the solar panels are supplying power or the condition of the batteries, if stored 
energy is supplying power. A detect on, Vh, voltage of 9.0 V, and a detect off, VI, voltage of 8.0 V were 
selected. The resulting resistor values were determined: Rp = 21.5 kQ, = 147 kQ, and Rg = 1.0 M£2 
(all 1%). The resulting source current is 53 pA which is within the low operating range of the device. 

2. DC-DC Conversion 

The MAX744A [Ref. 15] is a current-mode pulse-width modulation DC-DC converter. This 
device awaits the EPS to provide the System Controller with switched power. The MAX744A takes an 
input voltage between 6 V and 16 V, an ideal range for the EPS, and converts it to a 5.0 V ±5% output. 
The device can support a load current of up to 750 mA. 

Operating at an input voltage of 12 V, the MAX744A is most efficient (90%) when supplying 
about 400 mA of current. The System Controller and the Modem unit powered together require about 350 
mA (87% efficient). When operating with the Modem unit powered off, a System Controller requires 
about 70 mA of current (83% efficient). In normal operations, both the SC and the Modem will be 
powered on continuously. 

The MAX744A requires some support circuitry (resistors, capacitors, inductors, and a diode). 

The resistors and capacitors mostly control the programmable soft-start to ensure an orderly power-up by 
limiting surge currents. The recommended values for the components were used with the exception of the 
capacitor. Cl, between the Soft-Start input and ground, and resistor, Rl, between the Soft-Start input and 
Shutdown output. Selecting Cl =0.1 pF and Rl = 511 kQ while expecting a typical input voltage of 12 V 
and an output current of 350 mA, a Soft-Start time of 5 msec is expected. Thus, the 10 msec Reset of the 
M80C186XL-10 is generous. On the output side, a low equivalent series resistance (ESR) capacitor was 
used to keep the output ripple less than 50 mV peak-to-peak. Additionally, an optional low-pass filter 
using an inductor and capacitor was added to further reduce the output ripple to about 5mV peak-to-peak. 
The resulting circuitiy is shown in Figure 10. 


22 



Figure 10. DC-DC Conversion. 


C. PERIPHERAL DATA BUS 

This section applies to the design of the Peripheral Data Bus which excludes the serial 
communications control (via the SCC) and the analog to digital converter. The Peripheral Data Bus 
consists of the circuitry required to implement the Peripheral Control Bus, circuitry to buffer signals that 
are passed on to peripheral devices (i.e. the 82C55 and the Modem board, and control signals for the 
EDAC and Modem board power). 

The System Controller contains circuitry to provide the driving capability of the Peripheral 
Control Bus (PCB) which links all of the subsystems of PANSAT with a common control and parallel data 
bus. This is accomplished using a programmable peripheral interface (PPI, or 82C55A) integrated circuit. 
In addition to manipulating the PCB, the PPI also controls the signaling to the memory system (the error 
acknowledge in the EDAC) and the power switch control to the Modem unit. 

1. Programmable Peripheral Interface 

The 82C55A is a CMOS version of the standard 8255A which provides a general purpose 
programmable peripheral interface (PPI) [Ref. 16]. There are 24 I/O pins which may be individually 
programmed in certain logical groups and operational modes. 

2. Peripheral Control Bus (PCB) 

During satellite startup, the Electric Power Subsystem (EPS) provides +5 V to the PCB. The EPS 
also cycles all power switches to the peripheral modules so that all are powered off except the +5 V power 
to the PCB. The PCB must be powered up prior to powering on a System Controller module. 


23 


2.2uF 





Using the 82C55A in a strobed bi-directional parallel data transfer configuration with hardware 
handshaking, a digital bus was created with 8 data lines, 6 addressing lines, and two control lines consisting 
of read and write. In this mode. Port A of the 82C55A is the bi-directional data buffer. And Port B 
provides an uni-directional address and control buffer. Port C provides the handshaking and three general 
purpose control lines which are used for controls not on the PCB, but within the System Controller, 
specifically the Modem Power control and the EDAC Error Acknowledge controls. 

Two data transceivers, 54HC245, are used to isolate the 82C55A from the PCB connector. Other 
signals potentially coming off the SC board onto the PCB are the System Controller Active (SC_A) and the 
RF Enable (RF EN) signals. These signals are isolated from the PCB using a quad digital switch, a 
54HC125. The voltage threshold detector mentioned earlier assists in the implementation of the PCB 
isolation circuitry. This circuit disables the two data transceivers and the one digital switch from the PCB 
in the event that the SC board is powered down. 

A 25-pin male D connector is used for connection to the PCB. It contains the eight bits of data, 
six bits of address, 2 bits of control, +5 V, switched +12 V, grounds, the System Controller Active (SCA) 
signal, and the RF Enable (RF_EN) signals. Appendix B shows the pin assignments. 

3. Modem Control Interface 

The Modem is tightly coupled to the System Controller microprocessor, similar to other on-board 
peripherals. However the Modem unit is physically contained on another board connected to the System 
Controller via a 37-pin female D connector. Using data transceivers on each board next to the connectors, 
buffered address, data, and control signals from the M80C186XL are passed to the Modem. Besides the 
microprocessor interface, the Modem also shares signals with a Serial Communications Controller (SCC, 
85C30) which is described later in this chapter. The signals shared between the Modem and the SCC are 
synchronous transmit and receive data, and their corresponding clocks. Also included are a signal to 
deliver the temperature of the Modem board to the System Controller and power and ground. The pin 
assignments are given in detail in Appendix B. 

The Modem operates independently of the microprocessor. However, the heart of the Modem 
board is the PA-100 demodulator [Ref 17] which requires configuration by downloading (from the CPU of 
the SC) parameters as register sets. Occasionally, this processor requires its status to be read by the 
microprocessor, to determine if a different configuration is needed. Otherwise, the Modem sends and 
receives synchronous digital data between itself and the SCC on the System Controller without constant 
supervision by the microprocessor. 

Power is distributed to the Modem board in two ways. First, because the Modem board has 
isolation buffers which disable signals when the board is supposed to be powered off (similar to the PCB 


24 




isolation circuitry), there is +5 V delivered to the board at all times via the Vcc pins. Furthermore, when 
the Modem board is switched on by the System Controller, +5 V is delivered to the board via the +5 V 
pins. The switched power is handled by a Power Distribution Switch, the TPS2013 [Ref. 18]. The 
TPS2013 is a logic controlled heavy capacitive load power distribution switch in the form of an IC. It 
handles a maximum continuous current load of 1.5 A (more than sufficient for the 250 mA load of the 
Modem when powered on). This switch is controlled by the Modem Power (MODEM PWR) signal which 
originates from Bit 0 of Port C of the 82C55A, and is active low. 


4. CPU Signal Isolation and Latching 

In order to reduce the signal loading on the CPU and to ease the timing requirements on the I/O 
digital circuitry, an address latch, a data transceiver, and control signal buffers are used as shown in Figure 
11. Since the data signals are bi-directional between the CPU and the I/O peripherals, an appropriate bi¬ 
directional data transceiver is used, the 54HC245. This device is enabled using Peripheral Chip Selects of 

the CPU, PCS4 - PCS2 , when the Data Enable (DEN ) of the CPU is active. The direction of the transfer 

is controlled by the Data Transmit/Receive ( DT / R) signal of the CPU. Address signals travel one 
direction only, from the CPU to the peripherals. Furthermore, since the peripherals themselves decode 
whether or not they are addressed using the Peripheral Chip Selects, addresses generated by the CPU are 
latched every time they are generated. The Address Latch Enable (ALE) signal qualifies the addresses. A 
simple latch, the 54HC573, is used to capture the addresses. Note, since Address 0 (AO) of the CPU is not 
used for I/O addressing this signal is not passed through the address latch. For peripherals, A1 is the least 



uia 



U1:C 



Figure 11. CPU Signal Isolation and Latching. 


25 





significant address bit. From the CPU point of view, all peripherals are even addressed. Furthermore, the 

Read ( RD ) and Write (WR ) signals from the CPU are buffered. Normally, these signals are not buffered 
since they have adequate driver power. However, these signals are delivered off board to the Modem. 

5. Signal Timing to Modem Board 

All of the peripheral ICs that integrate with the M80C186XL use an active low write signal, WR. 
The write action occurs on the rising edge of the write signal. This signal is sent through the Modem 
connector to supply the signal to the Modem board latch as well as the PA-100. The PA-100 however uses 
the falling edge of the write signal to perform a write action. Unfortunately, data from the CPU only 
becomes stable at this exact same time. This problem is worsened because the data enabling logic on the 
System Controller, which controls the enabling and direction of the bi-direction signal driver, delays the 
delivery of the data signals to the Modem board. As a solution to this problem, a higher speed device is 
used for the signal driver, the 54AC245 versus the 54HC245. In addition, the decoding logic of the 

peripheral chip selects, PCS4 - PCS2, uses a high speed device for the OR gate, the 54AC32, to more 
rapidly enable the signal driver. The slower speed gate which ANDs PCS3 with PCS2 poses no problem 

since during a write to the PA-100 these signals are high and do not change. Finally, WR from the 
microprocessor is sent through an unused AND gate with the other input held high. This provides a further 
delay of the write signal to the PA-100. 

D. MEMORY 

The M80C186XL has a 16-bit wide external data bus. The memory address space is 20-bit, 
providing up to 1 Mbyte of byte addressable memory locations in the range from 0x0 through OxFFFFF. 
The memory address space on the 16-bit data bus is physically implemented by dividing the address space 
into two banks of up to 512 kbytes, as shown in Figure 12. One bank connects to the lower half of the data 
bus and contains even addressed bytes, where AO = 0. The other bank connects to the upper half of the 
data bus and contains odd addressed bytes, where AO = 1. Address lines A19 - A1 select a specific byte 

within each bank. AO and Bus High Enable (BHE) determine whether one bank or both banks are used in 
the data transfers. 


26 


PHYSICAL IMPLEMENTATION OF THE 
ADDRESS SPACE FOR 16-BlT SYSTEMS 

512 KBYTES 512 KBYTES 



A19:1 D15:8 BHE D7:0 AO 


Figure 12. 80186 Memory Addressing [from Ref. 12]. 


The System Controller Memory includes 64 kbytes of ROM and 512 kbytes of SRAM. Both 
types of data are addressed from the 16-bit wide external data bus explained in Figure 12. The memory 
system requires special buffers to temporarily latch both addresses and data during the memory access read 
and write cycles. Data transceivers reside between the memory circuitry and the microprocessor to reduce 
the signal loading on the external CPU address and data bus. The block diagram of Figure 13 shows a 
logical structure of this memory system. On the left are signals that pass between the CPU and the memory 
system. The AND gates combine the four memory chip selects from the CPU into one signal for the entire 
512 kbytes of RAM access. The block labeled ADDR LATCHES latches a memory address during the 
beginning of a memory read or write cycle. The blocks in the middle labeled EDAC_MASTER_SM and 
EDAC SLAVE SM contain circuitry that implements the state machines to control the EDAC controller 
(the ACS630MS). The DATA XCVRS block isolates the microprocessor data bus from the memory 
devices, reducing the signal loading of the CPU external address and data bus. The block named RAM 
contains the SRAM devices as well as the EDAC controller. At the bottom right is the ROM block. 


27 




































1. ROM 

PANSAT has 64 kbytes of ROM, composed of two devices which implement the even and odd 
banks. The M27C256 is a 256 kbit (32 kbyte x 8-bit) CHMOS UV Erasable PROM. This is a 5 V only 
EPROM requiring low power (200 pA maximum standby, and 30 mA maximum active). This is a military 
temperature range device with a high degree of protection against latch-up [Ref. 19]. This device provides 
easy interfacing with the M80C186XL. For development purposes, a low-cost standard version of this 
device exists. All devices can be programmed easily using the Dataman S4 [Ref. 20]. 

2. Error Detection and Correction 

Error Detection And Correction (EDAC) circuitry provides single-bit error correction with dual¬ 
bit error detection for all of PANSAT’s CPU-addressable Static Random Access Memory (SRAM). The 
error detection and correction is accomplished using a Hamming code to generate a check word for each 
data word stored in memory. The level of ED AC protection needed determines the number of check word 
bits per data word. Providing single-bit error correction with dual-bit error detection to an eight data bit 
word requires five check bits. To provide the same level of detection to a sixteen data bit word requires six 
check bits. 

When a data word is stored in memory, the associated check word is also stored. During a 
memory read operation the data word and the corresponding check word are retrieved from memory. A 
new check word based on the data word from memory is generated and compared with the stored check 
word. If the two check words are identical, the data word is assumed correct; however, three or more bit 
errors may not be detected. Correctable errors are identified and corrected. Words that are not correctable, 
but detected as incorrect, cause the error to be flagged. 

a. Existing Design 

The original Error Detection And Correction (EDAC) circuitry was designed by Oechsel 
[Ref. 21]. This design is a memory bus controller using a commercially available EDAC IC, the 
ACS630MS [Ref. 22]. The controller implements a sequential state machine to generate the required 
control signals for the SRAM (Mosaic’s MSM-8256 [Ref. 23]), provides transceivers and latches to isolate 
the SRAM data bus from the microprocessor local bus, and coordinates the operation of the EDAC IC. 

b. Modifications of the Write Back Control 

The original design requires that every word accessed from memory be written back to 
memory, regardless if there is an error or not. This is a good design in that the memory bus controller 
automatically corrects the error in the data word that is sent to the CPU, as well as the original data word in 
the SRAM. Although this does not affect the speed performance of the System Controller, since the EDAC 


29 



write-back occurs within the memory access cycle of the CPU, it does affect the power used. Writing back 
to every accessed memory location requires substantial extra memory accesses (i.e. using extra power) as 
compared to only writing back when memory is written to, or when memory is read and an error is 
detected and corrected. As a result, the write back control logic was modified to only write to memory 
when memory is being written to by the CPU, or when an error is detected and corrected following a 
memory read access. 

The control signal that causes SRAM to write a data word is MEM_ WR . Figure 14 
shows a Karnaugh Map and the resulting equation that eliminates the write back of data during read cycles 
when the single error latch is not set. 



Figure 14. Memory Write Back Logic. 

Using unused gates from the remaining glue logic needed to implement the memory bus 
controller, Figure 15 shows the circuitry which performs this write back function. 



c. Modification of the Reset Circuitry 

The original design used an inverter to reset the master state machine. As an alternative, 
the flip-flop’s reset input is directly connected to Vcc- This is possible because by the time the 
M80C186XL has completed a reset during power up, it has asserted the reset signal during the power up, 
and the flip-flop has already reached the initial standby state (00). 


30 




d. Modification of the ED AC Error Acknowledge 

During the development of the original EDAC circuitry, for simplicity one of the 
peripheral chip selects of the M80C186XL was used to acknowledge a hard or soft error. Since all the 
peripheral chip selects have I/O addressing responsibilities for the System Controller, an alternative was 
needed. The 82C55A described above has control bits available on its Port C. Bit 2 of this port is used as 

the ERR_ ACK signal to the EDAC. 

e. Modification of the Transceiver Enables 

The original design of the EDAC circuitry connected the ROM directly to the 
microprocessor data bus. However, it is desirable to isolate the ROM from this data bus. To use the same 
transceivers that are used for the SRAM, additional logic was needed at the state machine outputs which 

control the enabling of these transceivers. Allowing a valid combination of Data Enable (DEN ) and the 

Upper Memory Chip Select (UCS) with the state machine’s output (which is valid for a SRAM access), 
the following circuitry in Figure 16 shows the modification. 



Figure 16. Memory Transceiver Enable Logic Circuit. 


E. ANALOG-TO-DIGITAL CONVERSION 

The System Controller is responsible for converting all analog signals pertaining to satellite 
telemetry (voltages, currents, and temperatures) to a digital counterpart. The SC accomplishes this using a 
dedicated analog-to-digital converter which is tightly coupled to the microprocessor bus. In addition, since 
incoming analog signals arrive whether or not the SC is active, an analog switch is used in conjunction 


31 




with the PCB isolation circuitry to automatically isolate these signals from a non-active SC. A low-pass 
filter removes the high frequency components associated with the Electrical Power Subsystem DC-DC 
conversion (and other high frequency noise generated within the satellite). 

1. A/D Converter 

National Instrument’s LM12H458 [Ref. 24, Ref. 25], a 12-bit data acquisition system, is used to 
provide analog-to-digital conversion to the System Controller. This device provides single-ended or 
differential self-calibrating conversion with its own sample-and-hold. Multiple conversions remain in a 
16-bit, 32 register FIFO buffer. An internal 8-word RAM stores the conversion sequence for a program 
that can acquire independently and convert up to eight acquisitions through the eight-input multiplexer. 

The LM12H458 runs on +5V and an input clock of up to 8 MHz. In standby mode, the device consumes a 
negligible 40 pA (maximum). Input signals can range from ground to +5.0 V. 

For PANSAT, the LM12H458 is configured to interface with the M80C186XL in a 16-bit data 
mode. The inputs of the LM12H458 can be single-ended or differentially acquired by use of 
programmable input configurations. In differential mode, the off-board analog signal with its accompanied 
ground are converted as a positive signal with reference to this accompanied ground signal. Otherwise, the 
ground of the LM12H458 can be used when converting in the single-ended mode. For the temperature 
sensor ICs, local to the SC and the Modem board, these signals are delivered single-ended, and thus 
conversion uses this mode only. 

The LM12H458 is capable of interrupting the microprocessor and uses this to signal end-of- 
calibration and end-of-sequence (acquisition finished) conditions. Although DMA is available, it is not 
used, sacrificing the M80C186XL’s two DMA channels exclusively for the Serial Communications 
Controller. 


2. Analog Switch 

Immediately after entering via the connector on the SC, analog signals pass through an analog 
switch. The DG411, a monolithic quad SPST CMOS analog switch from Harris [Ref. 26], provides this 
feature. This device has a low On-Resistance (less than 35 Q), and is a very low power device consuming 
approximately 5 pA. As mentioned earlier, incoming analog signals arrive whether or not a System 
Controller is active. Thus, this analog switch is used to isolate the incoming signals from a non-active SC. 
Three of the four channels of the DG411 are used to handle the off-board signals from the Electrical Power 
Subsystem and the two Temperature MUXing Subsystems. When the SC is powered off, this device is 
powered via the Peripheral Control Bus and the switches are forced open. Upon being powered on, the SC 
is designed to automatically close these switches, allowing the external analog signals to enter. 


32 




3. Voltage Clamping and Low-pass Filter 

Studies performed on a prototype of the Electrical Power Subsystem indicated high frequency 
components in incoming signals at frequencies around 4.5 kHz, attributed to the switching power supply’s 
DC-DC converter. Furthermore, unaddressed multiplexers from the Temperature MUX subsystems and 
the EPS create signals of about 9.5 V. After advancing through the analog switch, an analog signal is 
potentially clamped if over 5.0 Volts using a 5.1 V Zener diode, 1N751, and then enters a passive low-pass 
filter using an RC circuit where R = 1 kQ and C = 0.1 pF. The filter is shown in Figure 17. The filter 
provides a -3dB break frequency at 1.5 kHz. 


VJN 


“WV 

1 k 


m 

z 


3 

^ ; 


VOUT 


Figure 17. Voltage Clamping and Low-pass Filter 


4. Wiring 

As mentioned earlier, the acquisition of off-board analog signals can be performed differentially 
or single-endedly. Undesirable potential ground-loops may exist within the satellite electrical systems, 
causing differing ground reference points. In order to be able to compensate for this potential problem, the 
analog input system was designed to allow the following configurations. Off-board analog signals coming 
into a System Controller are sent using a twisted-pair wire set. One signal in the twisted pair is the so- 
called positive signal which carries the signal of interest for conversion. The other wire in the pair is the 
ground from the electronic circuits that are responsible for generating the signal for conversion. 

For the analog signals entering the System Controller, the board was designed to allow one of the 
following configurations. The ground signal from a twisted-pair can be ignored by using the single-ended 
mode of the LM12H458; this feature is software configurable. Additionally, a twisted pair ground signal 
can be isolated from the System Controller circuitry by not allowing the signal to pass beyond the 
connector; this is accomplished using a jumper. 

5. Connector 

A nine-pin male D connector passes incoming analog signals to the System Controller board. The 
pin-out is given in Appendix B. 


33 




6. Temperature Sensing 1C 

Although not part of the A/D conversion circuitry, a temperature sensing IC is used to provide a 
temperature sensor for the System Controller. A single-supply centigrade temperature sensor, the LM50C 
[Ref. 27], is a precision IC temperature sensor that can sense a range of -40° C to +125° C. The output 
voltage is linearly proportional to the temperature. It consumes very low power with a quiescent current of 
less than 130 pA while operating at + 5 V. This sensor delivers its signal into the Analog-to-Digital 
converter. 


F. SERIAL COMMUNICATIONS 

The System Controller contains circuitry that allows both asynchronous and synchronous serial 
communications. The asynchronous mode provides an RS-232 compatible interface suitable for 
connecting to a standard computer serial interface, such as the COM port on a personal computer. The 
asynchronous RS-232 port is used for this purpose. In the synchronous mode, the System Controller is 
able to communicate with PANSAT’s Modem. The synchronous digital data passes through the Modem as 
the interface to the RF unit to provide the BPSK and spread-spectrum communication modes (either at 
9846 bits per sec for spread-spectrum mode or at 78.125 kbits per sec for the narrow band mode). 

PANSAT will transmit and receive at a center frequency of 436.5 MHz using direct sequence 
spread spectrum (DSSS), differentially encoded phase shift keying (DPSK) modulation. The 
communications data rate will be 9842 bits per second with a chipping rate of 1.25 mega chips per second. 
The chipping sequence is a pseudo random noise sequence produced from a 7 stage linear feedback shift 
register. In addition, the satellite will have a narrow band high data rate channel with a data rate of 
78.125 kbits per second. 

1. Serial Communications Controller 

The heart of the serial communications circuitry is the AM85C30 [Ref. 28], a serial 
communications controller (SCC) which provides two serial channels that are independently configurable 
for asynchronous or synchronous transmission modes with separate transmit and receive clocks. The SCC 
functions as a serial-to-parallel and parallel-to-serial converter with the CPU. It is software configurable 
by the M80C186. The SCC interrupts the microprocessor using the M80C186’s Interrupt Request 0, 

INTO. The signal. I NT , is active low on the SCC and is thus inverted to be compatible with the active 
high INTO. A pull-up resistor keeps the output of the inverter low during the SCC initialization, thus 
producing no interrupt to the CPU. This circuitry is shown in Figure 18. 


34 




Figure 18. Serial Communications Circuitry. 


Channel A of the SCC is designated the synchronous channel for serial communications between 
the CPU of the System Controller and the Modem board. This channel is configured to send and receive 
data using external clocks (TRxCA and RTxCA) which are generated by the Modem board. While 
operating in the narrow-band mode, the modem supplies transmit and receive clocks of 78.125 kHz (1 byte 
every 102 psec). In the spread-spectrum mode, the modem supplies transmit and receive clocks of 9.842 
kHz (1 byte every 813 psec). Furthermore, the transmit and receive data signals (TxDA and RxDA) pass 
through to the Modem board. Channel A is also configured to assert the Request To Send (RTSA) signal 
which acts like a Push To Talk function found on radio transmitter equipment. This signal will be used to 
drive the RF unit when transmitting. Channel A has some additional signals used specifically with the 

CPU for DMA. The signals for a Receive Request ( W / REQA ) and for a Transmit Request 
( DTR / REQA ) are tied directly to the CPU’s DMA interrupt request inputs. The SCC uses active high 

assertion levels for its DMA requests: W / REQA for DMAO and DTR / REQA for DMAl. Inverters are 
used as in the case of the interrupt request, shown in Figure 18. This hardware configuration is capable of 
full-duplex communications. However, the hardware will only operate in a half-duplex due to the 
allocated frequency bandwidth in which PANSAT will operate. This synchronous channel is programmed 
to operate in the Synchronous Data Link Control (SDLC) mode which applies a cyclic redundancy check 
(CRC) using the CCITT CRC-16 algorithm with a CRC seed of OxFFFF. Thus, all synchronous data 
frames which fail the CRC are flagged as invalid and are ignored by software. 

Channel B of the SCC controls the asynchronous serial communication between the CPU of the 
System Controller and a separate Computer. This channel hosts the Serial Test Port Interface which is used 


35 



only for ground-based operations before launch. It is configured to send and receive data using an RS-232 
driver, describe below. This channel also drives Request To Send (RTS) and Clear To Send (CTS) signals 
which are used in the RS-232 handshake. A common clock, generated internally by the SCC as derived 

from the peripheral clock, is used to generate a data rate of 9600 bits per second. RTSB is used to drive the 
enable of the RS-232 driver discussed below. 

2. RS-232 Drivers and Receivers 

The MAX21 IE [Ref. 29] has multiple RS-232 line drivers and receivers that are suitable for 
communications in a harsh environment. Although the asynchronous communication mode will not be 
used while in flight, this mode will be used extensively during development, integration, and testing. This 
port is a main source of external physical coupling with other electronics, and a potential source of damage 
to electronics within the satellite. Thus, the justification for the device which has ±15 kV electrostatic 
discharge protection. In RS-232 terminology, the System Controller acts like a Data Communications 
Equipment (DCE) and the separate computer is a Data Terminal Equipment (DTE). The signal 
assignments, described in Appendix B, follow this convention. The MAX21 IE is enabled by using the 

RTSB output of the SCC. When disabled (when not used for development purposes), the MAX21 IE uses 
a maximum supply current of 50 pA. 

3. Connector 

A 9-pin female D connector is used to pass the signals from Channel B used for asynchronous 
communication between the System Controller board and a separate computer. The pin-out configuration 
was chosen to be compatible with a personal computer COM interface so that a null-modem interface 
(crossing of send/receive signals) is not necessary. Thus, a straight through cable is used to connect the 
two systems. The signals, shown in Appendix B, are from the point of view of the System Controller. 


This concludes the discussion of the System Controller hardware design. This hardware supports 
the development and operation of software that control the spacecraft’s electronic modules by using the 
satellite’s general purpose computer. The device drivers for the System Controller hardware and the 
electomic modules of PANSAT are described in detail in the following chapter. 


36 



V. SYSTEM CONTROLLER SOFTWARE DRIVERS 


A. DESCRIPTION 

The Spacecraft Software for PANS AT is contained within the System Controller as partially 
embedded in ROM and additionally uploaded (from Earth) at the time of system bootup and when software 
updates are desired. Within PANSAT lie two (2) System Controllers, each with identical Spacecraft 
Software ROM. 

Operation of the spacecraft software consists of the completion of the hardware initialization and 
the creation of a runtime environment suitable for higher-level layers of software. Operation then consists 
of monitoring and charging the batteries while establishing primitive communication with the PANSAT 
Ground Station at NPS to begin the upload of the main operating system kernel and the secondary loader. 
Thereafter, a higher level protocol will then upload BAX (the BekTek AX.25 protocol handler), and 
another telemetry collector. AX.25 is a data-link layer protocol designed and used by the Amateur Radio 
community to perform digital packet radio communications [Ref. 30]. Using AX.25, the File System and 
user services software are uploaded. Finally, the spacecraft is then ready for ggeneral use. 

The software is written in C with 80186 assembler for critical code and the initial Bootstrap 
software. The spacecraft software incorporates the Spacecraft Operating System [Ref. 31] (SCOS), to 
provide an Application Program Interface (API) to simplify the job of writing multi-tasking applications. 
The Spacecraft Software also incorporates BAX [Ref. 32], to provide another API to simplify the use of 
AX.25 for Spacecraft Software tasks. 

The spacecraft software involves the porting and integration of SCOS and BAX. It also consists of 
various device drivers to interface with the hardware systems of the spacecraft, the collection and saving of 
telemetry, and an interface capability with possible experiment payloads via an RS-232 interface. 
Furthermore, the spacecraft software contains a store-and-forward mail system which uses the services of 
the File Transfer Level 0 (FTLO) protocol [Ref. 33]. Administration and system software and parameter 
update capabilities are also part of the spacecraft software. 

The discussion of software development that follows concentrates mainly on the code responsible 
for the Bootup software which is embedded in ROM; this is the core of PANSAT’s device driver software. 
Therefore, when referencing the generic term software within the following text, the reference will be to 
this Bootup software which contains the core device drivers and boot loader and not SCOS, BAX, nor the 
high-level user services. 


37 



B. 


HIERARCHY AND MODULE RELATIONSHIPS 

A flow of software control from Reset to the completion of the Final Loader can be viewed below. 


Spacecriaft 
:^Mpdii(e' 

Spacecraft fi'unction .. 

■ 

1 

^Ground Station Module" 

: Grdund::Stalibri:ipj^eraii^ 

STARTUP 

• 

SC hardware 

R 

■ 

CONTACT 

• 

Send message to PANSAT, granting 



initialization and 

0 

1 



PANSAT authority to send a status 



EDAC setup. 

M 

1 



message. 


• 

Setup C Runtime 


1 


• 

Listen for the spacecraft status 



environment. 


n 



message. 

BLOADER 

• 

Check batteries and 

R 


SCLOAD 

• 

Begin by sending messages to 



charge. 

0 


CONTACT 


PANSAT, granting authority to 


• 

Listen for NPS 

M 




send a status message, and listen 



Ground Station. 





for the spacecraft status message. 


• 

Performs initial 




• 

Use SCLOAD to prepare images of 



upload of software 


.•i'-V. 



the O.S. kernel (KERNEL) and the 



from NPS Ground 



• 


secondary loader (SLOADER). 



Station: KERNEL 




• 

Use CONTACT to send binary 



and SLOADER, 





images. 



transfers control to 


nx. 






O.S. kernel 






SLOADER 

• 

Performs 

R 


SCLOADH 

• 

Use SCLOADH to prepare (and 



secondary upload 

A 

' • 



send) images of AX.25 (BAX), 



of software from 

M 

’Si"': 



Final Loader (FLOADER), and the 



NPS Ground 





Command/Telemetry (CMDTLM) 



Station: BAX, 





software tasks. 



FLOADER, 








CMDTLM. 






FLOADER 

• 

Performs AX.25- 

R 

■ 

SCLOADH 

• 

Use SCLOADH to prepare (and 



assisted uploads of 

A 

I 



send) images of the File System 



remaining software 

M 




(FS), File Transfer Level 0 (FTLO), 



from NPS Ground 


1 



the Bulletin Board Server (BBS), 



Station: FS, FTLO, 





and other tasks. 



BBS, other tasks. 







• 

Used for further 


1 






software uploads. 


1 





Table 3. Relationships Between Software Modules. 


C. STARTUP 

The name Startup refers to a software source code module. This module is software composed in 
80186 assembly language and is called startup.asm. After a System Controller receives a reset, it is the 
software contained within this module which is invoked first, containing the bootstrap code at the 
hardwired absolute memory location of OxFFFFO which is contained within the ROM, 

Startup has several goals. The first is to initialize any hardware peripheral on the System 
Controller board itself, so that the peripheral is placed in a known state (although not necessarily operable). 
This activity is called Hardware Initialization. Furthermore, Startup checks and clears all of the system 


38 


























RAM which is controlled by the ED AC. Once the system RAM has been checked, data which is used by 
code composed in C (both embedded within the ROM) is relocated to RAM. This allows read/write access 
to variables referenced by C code. In order to support high-level floating point software statements, a 
floating point emulator (software-based) is used and must be set up before use by any higher-level software 
modules. Finally, a runtime environment becomes operable for the subsequent software modules, all 
composed in C, to operate normally. 


1. Hardware Initialization 

Hardware Initialization begins by programming the M80C186XL’s [Ref 13] internal peripheral 
interface registers. These registers are grouped into a block with contiguous addresses and are by default 
referenced via an I/O reference beginning at OxOFFOO. This default reference was kept. The M80C186XL 
contains multiple Chip Selects to internalize chip select generation for ROM and RAM. After a Reset, the 
Upper Memory Chip Select (UCS) will correctly select when referencing the top-most 16 bytes of system 
memory, OxOFFFFO through OxOFFFFF. Therefore, the first initialization performed is to change the range 
of addresses that the UMCS will generate. In the case of PANSAT, where the ROM is 64 kbytes in size 
and occupying the top-most 64 kbytes of system memory, UMCS is configured to start selects at OxFOOOO 
for a block size of 64 kbytes. 

cli 


mov 

dx, 

OFFAOh 

;upper 

memory chip select 

mov 

ax, 

0F038h 

;start 

of EPROM F000:0h, 64K 

out 

dx, 

ax 



jmp 

far 

ptr START 

;START 

OFOOOOh 


The bottom-most location of the 64 kbytes of system ROM is named START. At this location 
begins the remaining startup code. This code continues the programming of the peripheral interface 
registers. For memory and peripheral chip selects (LCS, MCS, PCS) the table below describes the 
configuration of these important selects. By not programming the LCS (not performing a read or write 
operation to the configuration register), this chip select remains inactive. 


jReglster,V' 

Agister Address 

J^ister 

;:;iSietdii'I}iiscnption 

PACS 

0xFFA4 

0x0000 

Peripheral Chip Select base; PCSO = 0x0000, each block is 
0x80 in length. Bus Ready must be active to complete bus 
cycle, no wait states inserted in the bus cycle. 

LMCS 

0xFFA2 

Not Applicable, 

Lower Memory Chip Select: Unused. 

MMCS 

0xFFA6 

0x41F8 

Mid Memory Chip Selects: 0:0 to 0x7FFF:F (512K block). 

MFCS 

OxFFAS 

0x2000 

Peripheral Chip Select: Starting at 0, PCS5/6 latch A1 & 

A2, PCSx go active for I/O bus cycles, requires bus ready 
be active to complete bus cycle (applies to PCS4-6), no 
wait states inserted for PCS4-6. 


Table 4. Memory And Peripheral Chip Selects. 


39 























Before hardware peripherals of the system controller are initialized, Startup also configures the 
M80C186XL TimerO, used as a system clock, and the interrupt controller to temporarily disable all 
interrupt sources. Startup then configures the hardware peripherals. The PPI configuration ensures the 
device is setup for bi-directional data exchange with the correct handshaking (discussed in more detail 
later), and places certain control lines to their correct assertion levels. The Modem Power control bit 
(active LOW) is turned off (programmed to a 1), the EDAC reset line is set on (programmed to a 1), and 
the RF enable is turned off (programmed to a 0). After the PPI, SCC configuration follows, placing the 
device in the correct modes for synchronous communication for Port A, and asynchronous communication 
for Port B. 


2. Memory Check and Clear 

During Startup, before interrupts have been enabled and before a stack has been created and 
activated, the entire RAM is briefly checked for errors and in the same process the memory cells are 
cleared, removing the possibility of later RAM accesses causing EDAC soft or hard errors. First a write 
followed by a read of the data 0x55 and OxAA is performed in the entire RAM. The purpose of this 
alternating bit pattern test is to determine if there are data bus problems, bad devices, or chip select failures. 
However, this test only tests the ability of a device to hold data, but not that the devices are being addressed 
correctly. Thus, another test is performed which writes unique data to each location and then reads back. 
The unique data will be a 257-bit repeat test, e.g. cell 0 will get the value 0, cell 1 gets 1,.... Cell 256 gets 
256 (modulo 256 = 0), cell 257 gets 257 (modulo 256 = 1). Then the pattern repeats so that cell 258 gets 0, 
cell 259 gets 1, etc. 

In the event that memory cells fail a test, the software system will attempt to map out the bad cells 
if possible. However, if errors occur in the interrupt vector table, there is no mapping solution. The 
System Controller will force itself to fail to update the EPS watchdog timer, thus shutting itself down. 

3. Data Relocation 

Since all data (constants and variables) of any C software module are embedded within the ROM 
and may at some later point be relocated to RAM, data relocation is a necessary step for proper 
configuration of the C runtime environment. True constants (never modified data references) may remain 
in ROM. However, any variable which is not created on the C runtime stack, must be relocated and 
possibly initialized in RAM. The data relocation performed for PANSAT is based upon standard 
techniques [Ref 34]. 

As already discussed, the 80C186 hardware architecture uses the concept of segments to organize 
physical directly-addressable memory. Software also uses the word segment. Segment, in the context of 
software, can refer to a physical 64 kbytes segment of the 80C186, or also a logical grouping of data or 


40 



code. DGROUP is a group of like data segments particular to the Microsoft C Compiler for code 
generation of a memory reference model called the Small Model. Small Model programs are by definition 
fixed in data segment size to a physical segment size of 64 kbytes (directly related to the 80C186’s 
architecture) and fixed in code segment size to also 64 kbytes. However, the data and code segments 
occupy separate physical segments, and thus provide up to 128 kbytes of code and data. As a convenience 
to the compiler and linker, data groups are created to collect similar types of data references [Ref 35]. 

Data relocation begins by clearing any initialized data area in the DGROUP group. Initialized 
data is any data that is a variable, not created on the runtime stack, and is given a specific value at the time 
of code composition. Thus, it is necessary that this prior, initialized, value given to this variable must be 
preserved. As all of these initialized variables are relocated to RAM, their values are preserved. 

Data relocation continues with uninitialized data area in the DGROUP group. Uninitialized data 
is any data that is a variable, not created on the runtime stack, and is given no value at the time of code 
composition. Thus, it is assumed that any prior value given to this variable is not of importance. As a 
matter of consistency, all of these uninitialized data references are relocated to RAM and forced to the 
value of zero. 


4. Floating Point Emulation 

Although the 80C186 contains hardware and software hooks to allow a companion floating point 
coprocessor, namely the 80C187, this option was not used for various reasons. Primarily, in the style of 
attempting to make a lean system controller, floating point arithmetic is considered a luxury and 
minimizing its use is practical. Also, this coprocessor, like many floating point processors, is a heavy 
power user consuming about 50% more power than the M80C186XL alone. Furthermore, using software, 
floating point arithmetic can be emulated. This emulation occurs at a great sacrifice of CPU cycles since 
some floating point instructions can take hundreds of more CPU time when emulated. However, floating 
point arithmetic is minimized. 

The software tools used for linking and absolute address location provide a ROMable floating 
point emulation library. Within the Startup are subroutine calls to the floating point library initialization 
routines. In cooperation, the C compiler when compiling translates all floating point expressions to a series 
of calls to subroutines. 

5. C Runtime 

Prior to the transfer of control to the code of the collection of C-composed modules, appropriate 
hardware interrupts are masked on, e.g. EDAC and Timer2. Furthermore, a runtime stack is created so 
that an area of RAM is set aside for stack-related operations. The stack for the C runtime environment is 4 


41 



kb 5 ^es of ED AC-controlled RAM, located just after the interrupt vector table. The stack creation actually 
occurs just prior to the calling of the floating point emulation routine. Transfer of control is accomplished 
by calling the main C software module, named mainQ, If ever main() should terminate, the code following 
this call turns off interrupts (not allowing the clock and Watchdog support software to operate) and finishes 
with a HALT instruction. 


D. CPU SUPPORT 

1. Timers and Interrupts 

a. Timers 

The Timer/Counter Unit, integrated within the M80C186XL [Ref. 12], supports three (3) 
independent 16-bit counter/timers. These timer/counters are used to generate a system clock implemented 
by the operating system, and other time-dependent functions. Table 5 shows the use of each timer. 


;Timer 

'3Runction 

0 

Transmitter time-out (feeds clock to Timer 1) 

1 

Transmitter time-out (gates RF Enable) 

2 

System Clock (operating system) 


Table 5. Timer Allocation. 


Cascaded, Timers 0 and 1 can provide a maximum timer of 38.84 min (each timer is 
updated every 'A CPU clock which is 0.542535psec, 2'®*2'**0.542535nsec). Timer 0 is programmed to 
run continually using PCLK as a clock and given a maximum count value of 2'*, providing a 35.5 msec 
clock for Timer 1. Timer 1 uses Timer 0 as its input clock. Using the dual count mode as a one-shot timer. 
Timer 1 is programmed to stay low when enabled for 10 seconds using a Count A value of 1 and a Count B 
value of 281. The output of Timer 0 is inverted before it is gated and passed off the System Controller 
board to the RF unit, providing an active high signal. Ten seconds is a suitable length of time to enable the 
transmitter, and yet provide an automatic turn off mechanism. 

Timer 2 is programmed to interrupt the CPU at a frequency of 60 Hz, providing a tick 
counter to implement a system clock. This timer uses a maximum count of 30720 in a continuous count 
mode. The interrupt service routine counts the interrupts to maintain a second counter. Two API functions 
provide the ability for software to read and set the second counter, based on UTC from 1 January 1970. 
Thus, when PANSAT is reset, it begins with a date of 1 January 1970 until otherwise programmed by the 
NPS ground station. A 32-bit second counter allows dates until 2106. Within the clock ISR is the chaining 
to the EDAC RAM Wash subroutine which is explained in more detail later in this chapter. 


42 









Function Name ^ 


gettimeO 

Get UTC time in seconds (elapsed 
time in seconds since 1 Jan 1970). 

settimeO 

Set UTC time (elapsed time in 
seconds since 1 Jan 1970). 


Table 6. Clock API functions. 


b. Interrupt Priority Structure 

The Non-Maskable Interrupt (NMI) is the highest priority interrupt and will be disabled 
via hardware to prevent this event from occurring unless the Error Detection and Correction (EDAC) 
circuitry is enabled. Maskable interrupts are the most common way to service the external hardware 
interrupts. Globally, software can enable or disable the maskable interrupts. Maskable interrupts have 
priorities among themselves which are determined by the programming of the interrupt control unit and the 
support circuitry. Exceptions occur when an unusual condition prevents further instruction processing until 
the exception is cleared. Software interrupts are generated by software using the INT n instruction. The 
M80C186XL handles exceptions and software interrupts in the same way as hardware interrupts and are of 
lower priority than the maskable (hardware) interrupts. All unused (undefined) interrupt vectors are 
initialized to point to OxOFFFFO, the Reset vector, so that if an undefined interrupt occurs, the system will 
perform a reset. Table 7 shows the interrupt vector use. 


43 










Interrupt 

Vector 

Number 

Interrupt Function 

0 

Divide-by-zero 

1 

Single Step 

2 

NMI 

3 

Breakpoint 

4 

Overflow 

5 

Undefined 

6 

Invalid Opcode 

7 

Escape Opcode 

8 

Timer 0 

9 

Undefined 

10 

DMAO 

11 

DMAl 

12 

INTO (SCC - 85C30) 

13 

INTI (A/D-LM12H458) 

14 

INT2 (EDAC Hard Error) 

15 

INT3 (EDAC Soft Error) 

16 

Undefined 

17 

Undefined 

18 

Timer 1 (Transmitter time-out) 

19 

Timer 2 (SCOS clock tick generator) 

20 - 255 

Undefined 


Table 7. Interrupt Vector Allocation. 


2. EDAC (Setup and RAM Wash) 

Error Detection And Correction (EDAC) memory will cover all addressable Spacecraft Software 
system RAM and will ensure the state of memory which is within the data and code addressing range of the 
M80C186XL. The memory decoding is designed such that all of the 1/2 Megabyte of direct addressable 
memory, from 0 to OxVFFFF, is EDAC RAM for the CPU. With the EDAC circuitry enabled, all memory 
cycles to RAM, either byte or word size, will be intercepted by the EDAC. Each write generates error 
correction patterns which are recorded as well as the data. Each read retrieves the data as well as the 
correction patterns to determine if the data read is correct, is correctable (soft error), or is not correctable 
(hard error). The EDAC will indicate these two types of error to the M80C186XL via interrupts. The soft 
error produces a maskable interrupt, INT3. The hard error produces a maskable interrupt, 1NT2. 

There are tw o errors associated with a RAM memory cycle. The first error is called a soft error 
and is completely correctable. With a soft error, the EDAC is able to reconstruct the correct bit pattern of 
the byte or word cell. The EDAC will respond to a soft error by sending the correct byte or word and then 
asserting an interrupt. The interrupt service routine (ISR) is responsible for remembering at what time the 
soft error occurred. The second error is a hard error which is not correctable. In the event of a hard error, 
the EDAC asserts another interrupt. The soft error service routine will first save the necessary registers on 


44 














































the stack. Then a message indicating that a soft error occurred will be sent to the Event Logger. The soft 
error service routine will then restore the registers and return fi-om interrupt service. The hard error service 
routine must assume that any RAM cell is corrupted and cannot necessarily be corrected, because the 
location cannot be determined. Therefore, this service routine will suspend all interrupts, place all the 
hardware systems into an idle or off state, and then reboot the M80C186XL by jumping to the boot vector. 

a. Initial RAM Clearing 

Upon microprocessor RESET (during startup), the EDAC Hard and Soft Interrupts are 
turned off. All RAM cells are subject to the checking and clearing process described earlier in the startup 
module. Then the EDAC Hard and Soft Interrupts must be cleared. This is accomplished by placing the 
EDAC Hard/Soft Interrupt Clear signal momentarily low (at least one bus cycle). Finally, the EDAC Hard 
and Soft Interrupts are turned on. Note that the EDAC circuitry is always operating, however software can 
ignore EDAC error signals when necessary. Initial RAM clearing can be performed as word write 
operations, reducing the time required to perform the initialization process. 

b. RAM Wash 

The process of performing a RAM wash involves a regularly scheduled software task to 
read data from RAM. However, the data does not need to be written back. The hardware design 
automatically writes back a data word that is incorrect (1 bit error, correctable). This process will cause the 
EDAC circuitry to reset the correction patterns. In the event that a RAM cell develops a bit error, it is 
desirable that a RAM cell is washed before the RAM cell develops a second bit error. If the wash occurs 
before the second bit error, the cell and the correction pattern will be updated, reflecting no errors. In the 
event that a second bit error occurs before the RAM wash, the data will not be correctable and a hard error 
will be generated. RAM wash can be performed using word write operations. The frequency of RAM 
washes must occur such that second bit errors do not occur. 

As an initial rate of washing RAM, the RAM wash software performs RAM reads on 
small blocks of continuous data and then returns control to another software routine. This is repeated over 
and over again until the entire 512 kbytes of RAM have been washed. The process then repeats. A block 
size of 256 bvics (128 16-bit words) can be washed quickly and simply using a REPS MOVSW which is 
part of the M80CI86 instruction set. There are 4096 separate blocks of 128 bytes within the entire 512 
kbytes of RAM. A block wash cycle takes approximately 168 psec. Interrupts and DMA must be off. 

An estimation of the number of SEUs expected in RAM was performed by Oechsel 
[Ref. 21] based upon data from UoSAT-2, a microsatellite similar to PANSAT regarding its orbit and types 
of electronics. Conservative assumptions indicated that the number of SEUs expected is 1.0 x 10'^ 
SEUs/bit/orbit. This equates to an expected time between uncorrectable errors of 1.8 years (nearly the 


45 




expected lifetime of PANSAT). In particular, one assumption declares that the RAM wash will occur once 


90 minutes 1.3184 sec 

4096 blocks “ block ^ ^ 

per orbit. This rate of washing appears suitable. 

This frequency of beginning a block wash is an integral number. If a wash was initiated 
every second, then the calling of the wash routine would be easy to implement into the clock ISR. This 
imposes a very small overhead when considering CPU time associated with RAM washing: 

c. Processing a Single Bit Error 

The interrupt service routine (ISR) for a single bit error consists of removing the interrupt 


1 block 168 /isec 


, which corresponds to an overhead of 0.0168%. 


( 3 ) 


1 sec 1 sec 

condition from the EDAC circuitry by toggling an EDAC control line via the PPI. The EDAC interrupts 
are level-sensitive. This ISR must acknowledge the interrapt by incrementing a single bit error counter and 
posting the time and date of the single bit error to the Event Logger. Because EDAC interrupts are level- 
triggered, further single-bit error interrupt requests will not be detected while software is executing the 
interrupt service routine. Single-bit errors cause a counter to be incremented, accumulating a count of total 
single-bit errors. 


d. Processing a Dual Bit Error 

To reduce the chances of system failure, the dual-bit error interrupt service routine 
should not be stored in RAM since it is susceptible to dual-bit errors. Because dual-bit errors are not 
necessarily correctable, software should not attempt to continue operating on the system that experienced 
the error. The dual-bit error intenupt service routine will place the processor into a halt condition, causing 
the watchdog timer update to fail and thus shutting down the system controller and starting up the alternate. 


E. MAIN 

The convention in a C programming environment is for the function named mainQ to be the first 
subroutine invoked when the C program is executed. This same convention is followed for the PANSAT 
ROM Boot software with the exception that after a microprocessor reset, the Startup software executes 
first, setting up a suitable runtime environment for the actual C program. A flow diagram of the PANSAT 
ROM Boot software main() routine is shown in Figure 19. 


46 



ROM Boot Loader. 


Setup. 


Clock ISR. 


A/D ISR. L>' 


■ 


1 


1 


DMA ISR. 



Figure 19. ROM Boot Loader. 

This diagram begins with a block named Setup which initiates the Interrupt Service Routines, 
represented on the left side of the diagram. Setup also initializes many variables used to control the Boot 
Loader loop. The loop calls each of the blocks shown within the loop on a continual basis. Since a multi¬ 
tasking operating system is not present within the ROM Boot Software, this software loop depends on each 
subroutine called to transfer control back to the main loop on a timely basis. 

The loop begins by checking telemetry (obtaining the most up-to-date sensor data possible), next 
is a check on the battery charging, followed by monitoring the RF system for receiving NPS-based 
transmissions and subsequently transmitting a response. Since this software is also used for testing and 
integration purposes before spacecraft deployment, the Serial Test Port Interface (STPI) is monitored in 
case an external computer is sending requests. Next, any incoming command either via the RF system or 
the STPI is verified and processed. In case there is an apparent hardware failure, alternate hardware 
configurations are checked and used. And, finally the watchdog timer on board the Electrical Power 
Subsystem is reset, indicating that the software is functioning and the System Controller that is currently 


47 















operating should remain so. The loop then repeats. In the event of successful operation of the Boot 
loading process, a secondary loader will be uploaded from NFS to the spacecraft. This secondary loader 
will then take control. The ROM Boot Loader will cease to operate. These higher-level software services 
are discussed in more detail in the following chapter. 

F. PROGRAMMABLE PERIPHERAL INTERFACE 

The Programmable Peripheral Interface (PPI) [Ref. 16] has multiple functions, interfacing with 
several spacecraft components. The primary use of the PPI is to control the Peripheral Control Bus (PCB) 
which is discussed later in this section. The PPI also serves to control the EDAC circuitry with three 
control lines, and performs the Modem mode select using two control lines. 

1. EDAC Control 

The PPI has one control line which interacts with the EDAC circuitry. This control line is used to 
acknowledge to the EDAC that either a hard error or soft error was received and the EDAC state machine 
should clear the error. Failing to clear the EDAC hard/soft error will result in the continual assertion of 
that condition. This control line can clear the errors by forcing it low and then high again, (presumably 
during the interrupt service routine); normally, this control line should remain high. 

2. Peripheral Control Bus 

The Peripheral Control Bus (PCB) provides the interconnectivity between all of the functional 
subsystem electronic components of the spacecraft. This bus identifies each peripheral with a unique 
address, transmits eight bits of data, and accomplishes this data transfer with read and write control lines. 

3. PPI Control Interface 

The active System Controller has control of a PPI by selecting the device associated with PCSl. 
This PPI is programmed to Mode 2 (strobed bi-directional bus I/O) with a value of OxCO to the control 
port. This allows control of the PCB as well as the three unused control lines for the EDAC and Modem 
mode selection controls. The configuration of the 8255 and its port assignments are shown in detail in 
Appendix D. 

4. Peripherals of the Control Bus 

The RF system and the EPS on this bus are not duplicated; all other peripherals are paired. Thus, 
there are two System Control peripherals, containing a System Controller (SCA and SCB), two Analog 
MUX (AMA and AMB), and two Mass Storage units (MSA and MSB). The least significant bit in the 
device selection chooses between one of the two ports of the device. Note the distinction of this versus the 


48 



sub-address bits (bits 5 and 4); these bits feed through to the selected port, as in the case of addressing a 
PPI which requires 2 address lines for the PPI registers. The table below identifies each peripheral and 
indicates the corresponding addresses. 


System Name ,; , 

System | S3-S01 
'"Xildress 

System j 

Address 

RF System 

0000, 0001 

0,1 

Electrical Power System 

1000, 1001 

8,9 

System Control A 

0010, 0011 

2,3 

System Control B 

1010, 1011 

OxA, OxB 

Analog MUX A 

0100,0101 

4,5 

Analog MUX B 

1100, 1101 

OxC, OxD 

Mass Storage A 

0110,0111 

6,7 

Mass Storage B 

1110, 1111 

OxE, OxF 


Table 8. Peripheral Control Bus Devices. 


5. Reading from the Control Bus 

1. Place peripheral select and device sub-address in Port B. 

2 . Set the Read bit to Low to indicate beginning of read. 

3 , Toggle the input strobe (STB) to load the data into the input latch. 

4 . Set the Read bit back to High to indicate end of read cycle. 

5 . Read the data from Port A. 

6. Writing to the Control Bus 

1. Place data in Port A. 

2 . Place peripheral select and device sub-address in Port B. 

3 . Toggle the Write bit (High to Low to High) to force the write, 

7. Software Interface 

A software interface to allow application tasks to talk to peripherals on the Peripheral 
Control Bus requires a function to read from a peripheral, and to write to a peripheral. Reading and writing 
follow a very similar sequence of operations on the control bus. 


o. Application Programming Interface 

The low level software interface functions, available to a task, are identified below. 


49 
































Function Name 

Description 

pcb_portc() 

Toggles Port C control bits (0, 1, and 2). 

pcb_power() 

Toggles power control bits in EPS for each subsystem. 

pcb_init() 

Initialize the Peripheral Control Bus. 

pcb_read() 

Reads a peripheral on the control bus and returns the byte. 

pcbwriteO 

Writes a specified byte value to the specified peripheral. 


Table 9. Low Level Peripheral Control Bus Software Interface. 


b. Timing Requirements 

Reading and writing the PCB are fundamental operations that most software modules use 
extensively. Thus, it is necessary and useful to determine the amount of time these operations cost. The 
pcb_write() function takes 180 clocks, and thus at 7.3728 MHz takes 98 psec to complete. The pcb_read() 
function takes 220 clocks, requiring 119 psec. The consequence of the times required are most obvious in 
the management of the Mass Storage units; this is discussed in a later section. 

G. ELECTRICAL POWER SUBSYSTEM 

The Electrical Power Subsystem (EPS) is responsible for generating the power delivered to all 
other systems within the satellite. Using the Peripheral Control Bus, the switches on the EPS can be 
toggled. The EPS contains eight ports which contain various switches to control EPS battery functions and 
to power on/off other devices on the Peripheral Control Bus. Software will keep track (via copies of the 
EPS registers) of all ofthe settings for all of the EPS ports. Appendix E contains many tables that describe 
the EPS ports and the switch assignments of the ports. 

1. EPS Port Organization 

Ports 0, 1,2, and 3 of the EPS are used to control the configuration of the EPS. Port 0 controls the 
batteries (charge, discharge, and on-line). Port 2 controls the power to the subsystems; this port also 
contains the current inhibit switch used white reading currents. Ports 1 and 3 control multiplexers on the 
EPS which are used to select voltage and current measurements. Port 4 is the Watchdog Timer reset 
switch. Port 5 is used to read back the direction of the current sensors (the only read port via the PCB on 
the EPS). Ports 6 and 7 are not allocated; however. Port 7 is selected when the Watchdog timer needs 
toggling (Port 4 written, and then Port 7 accessed in order for Watchdog timer to latch the update request). 
Ports 0, 1,2, 3, and 5 are described in detail in Appendix E. 


50 




2. EPS Cell Voltage Multiplexing 

EPS voltage and current measurement signals are all multiplexed onto one analog signal and 
delivered to the LM12458 A/D converter on-board the System Controller. The following section describes 
the addressing needed to perform EPS voltage and current measurement selections. 

a. Low Battery Cell Voltage Selections 

The Low Battery Cell Voltage MUX is used to select certain battery cells for voltage 
measurements associated directly with the Low Cells (0 and 1). This MUX is also used to index into the 
Medium and High Cell Voltages MUXes. To select battery cells OA, 1 A, OB, IB for voltage 
measurements, only Port 3 needs to be used. Since Port 3 is used to index into the Medium Cell Voltage 
MUX, these control bits are zeroed when only selecting cells 0 and 1. 

b. Medium Battery Cell Voltage Selections 

The Medium Battery Cell Voltage MUX requires manipulating the Low Cell Voltage 
MUX as well as the Medium Cell Voltage MUX. Prior to selecting the Medium Battery Cell Voltage, the 
Low Battery Cell Voltage MUX must be set correctly. Since the control of the Medium and Low Battery 
Voltage MUXes are controlled both with Port 3 of the EPS, all of the selection actions can take place in 
one write to Port 3. The four least significant bits (1111) set up the Low Cell MUX to allow Medium Cell 
MUX selections to pass through. 

c. High Battery Cell Voltage Selections 

The High Battery Cell Voltage MUX selection method depends on the cell. Cells 5A/B, 
6A/B, and 7A/B require the following selection method. First, select the High MUX input through the 
Low Cell MUX (Port 3 = 0000 1000). Furthermore, the Current Select must be kept disabled (Port 1: bit 0 
= 0). Then, via Port 2, make a selection. Cells 8A/B and 9A/B require the following selection method. 
First, select the High MUX input through the Low Cell MUX (Port 3 = 0000 1000). Furthermore, the 
Current Select must be kept disabled (Port 1: bit 0 = 0). 

3. EPS Cell Voltage and Current Multiplexing 

The eleven current sensors are used to read roll rate experiment currents and also the solar panel 
and battery currents. The Low Cell Voltage MUX selectors are used to index voltage measurement, as 
well as the current selectors. Prior to current selections. Port 3 should be set to allow current selections to 
be made; this is accomplished by setting Port 3 = 0000 1100 (for roll rate), Port 3 = 0000 1010 for batteries 
and solar panel bus. Then the current selection is made. After the address selections, the Spacecraft Power 
Current Inhibit control must be disabled (i.e. enabled) by setting Port 1, Bit 0 to 1. Then, the Spacecraft 
Power Current Strobe must be strobed from high to low to high (Port 1, Bit 1). Then a reading can be 


51 



made. Following the A/D reading, the Spacecraft Power Current Inhibit must be set again (Port 1, Bit 0 set 
to 0). Appendix E shows the configurations needed for current measurements. 

H. SERIAL COMMUNICATIONS 
1. Modem Control 

A System Controller operates the Modem using I/O commands issued from the CPU. The 
Modem has a set of registers within the PA-100 [Ref. 17] and a separate 8-bit latch. Furthermore, a SC has 
the ability to turn on and off the entire Modem board via the PPI control port C bit 0. Modem setup and 
control requires a set of registers within the PA-100 to be configured in a certain sequence. Furthermore, 
feedback from the PA-100 is also required. In order to simplify the programming interface to control and 
monitor the Modem board, two functions exist to assist high-level layers of software. A data structure can 
be created which contains a pair of data, an address and a value associated with that address. The address 
corresponds either to a register within the PA-100 or the 8-bit latch, and the value corresponds to the data 
to be placed at that address. Thus, tables are sent to the Modem board when a new configuration is 
desired. 


2. RF Control 

The RF unit [Ref 36] is controlled via the PCB using one 8-bit latch. Logic within the RF unit 
along with settings made by a System Controller control the selection of a low noise amplifier (LNA), a 
high pass amplifier (HPA) and a corresponding power level, a local oscillator (LO), the power applied to 
the selected LNA and also HPA, and control of transmit and receive switches. A System Controller has 
primary and alternate components (LNA, HPA, LO) within the RF unit. The RF unit takes a System 
Controller’s preferences via PCB commands (Table 10) as well as which SC is active and enables the 
correct components. 



Control Bit Name. 

Description 

7 

HPA 

0 = Selected HPA off, 1 = Selected HPA on 

6 

LNA 

0 = Selected LNA on, 1 = Selected LNA off 

5 

PI 

Power level control (most significant bit) 

4 

PO 

Power level control (least significant bit) 

3 

LHP/LHA 

0 = Primary LNA/HPA, 1 = Alternate LNA/HPA 

2 

LOP/LOA 

0 = Primary Local Oscillator, 1 = Alternate Local Oscillator 

1 

Tx/Rx 

0 = Transmit, 1 = Receive (Signal Path Relay) 

0 

T/R 

0 - Transmit, 1 = Receive (Antenna Relay) 


Table 10. RF Unit Control Port. 


52 






















API function calls are provided for ease of programming as well as making the source code very 
explicit to understand regarding the references to the RF unit. The functions are shown in Table 11. 


Function Name 

Pescrlptibn 

rf_power() 

Toggles power on and off to the RF unit. 

rf_set0 

Sets a particular RF control bit via the PCB. 

rf_timer() 

Starts the Transmitter timer using Timers 0 & 1 of the CPU. 

rftxpowerO 

Sets transmit power using the 2-bit attenuator on the RF unit. 


Table 11. RF API function calls. 


3. see Drivers 

One master interrupt service routine (ISR) handles the input and output services of both Channel 
A (synchronous) and Channel B (asynchronous) of the Serial Communications Controller [Ref. 28]. 
Channel A I/O is handled with DMA, except the special conditions which cause an interrupt. However, all 
I/O for Channel B is handled within this service routine. Since the SCC has only one interrupt source into 
the CPU, all SCC interrupt conditions invoke this one ISR. All conditions are checked within this ISR and 
are handled on a priority basis. The condition checking repeats within the ISR until all SCC interrupt 
conditions have been serviced. An outline of the master SCC ISR is shown in Figure 20. 



Figure 20. SCC Interrupt Service Routine Structure. 


53 




















a. Asynchronous Services 

A variety of software routines allow control of Channel B of the SCC, providing an easy 
yet sophisticated interface with the asynchronous communications port. The core drivers that allow input 
and output to Channel B are serial_out() and serial_in(). These functions simply insert or remove 
characters into buffers that are handled by the interrupt service routine. At a higher-level, software 
routines allow command line input and C Standard Library like printf() capabilities for complex display 
output. 


b. Synchronous Services 

Synchronous data is received and transmitted in blocks as packets. All higher-level 
software modules ultimately want to send a packet of data or receive a packet of data. Since all 
synchronous I/O is handled with the DMA between the memory and SCC, packet send and receive requests 
require an initial DMA setup, and some follow up after the transaction. Since the satellite only works in a 
half-duplex mode, assumptions regarding the state of transmit and receive are made and simplify the 
design. When not transmitting, the SC places the SCC into a receive mode with the DMA already set up to 
transfer incoming data bytes. Thus, during this time, it is not necessary to set up anything regarding the 
transmission of data. When data is required to be sent out a packet is placed into a buffer and remains 
there until the receiver is finished with packet reception. Then, the transmitter is set up, including the 
DMA. During this time, it is not necessary to set up anything regarding the reception of data. 

Synchronous services are complicated by the fact that besides the SCC, communications 
through Channel A also rely on the PA-100 modem and the RF unit. Thus, the PA-100 and RF unit require 
some monitoring in case there is a failure. Failure may only be due to a functional mode of the hardware 
and not circuit failure. Thus, these units may need to be reset or programmed with different parameters. 
Furthermore, extended failure may require a different hardware configuration to be chosen. 

I. TELEMETRY 

1. Scheduling of the LM12H458 

Telemetry from sensors (voltages, currents, and temperatures) is routed onto the inputs of the A/D 
converter on the System Controller, the LM12H458 [Ref. 24]. An interrupt service routine (ISR) is 
responsible for completion of data conversion, and scheduling of another acquisition under the automated 
function of the A/D converter. Since the LM12H458 can be given a program which is a sequence of data 
acquisition steps which can be run independently of the CPU, the A/D converter is programmed to make 
several acquisitions across multiple input sensors without intervention of the CPU. 


54 


In order to simplify the software responsible for operating the A/D converter, a schedule was 
created that indicates for any sequence in the data acquisition, which sensor signals are to be accessed and 
converted. The entire data acquisition cycle was broken up into 42 periods, numbered 0 through 41. After 
the 41^ period, all sensor data has been read and converted at least once. Since some data points need 
more frequent readings than others, certain sensors are read multiple times during the 42 periods. The 
sensors from the EPS require multiple readings per period. The CPU must store the converted values at the 
end of each Period and prepare the LM12H458 for the next Period before resuming other activities. 
Appendix F shows the schedule of A/D conversions. 

2. LM12H458 Setup and Interrupt Service Routines 

Three subroutines implement the software necessary for data acquisition. The first is an 
initialization routine which programs the LM12H458 into the desired mode, calibrates it, programs the first 
sequence of acquisition instructions, and finishes leaving the LM12H458 running independently. 

Another, the core of the acquisition, occurs within the Interrupt Service Routine for the 
LM12H458, diagrammed in Figure 21. At the end of each data acquisition Period, which can have up to 5 
converted samples or as few as one, this routine is invoked via a hardware interrupt. If necessary, current 
directions are read for the just completed acquisition. If temperature sensors are used for the following 
acquisition period, the TMUXes are programmed. Furthermore, the EPS is programmed to multiplex the 
soon to be read sensor. Finally, the LM12H458 instructions are programmed and the service routine is 
finished. After the completion of all 49 Periods, this ISR also sets a flag to notify other software tasks that 
a complete set of new data has been converted. Also, at the completion of the last Period, the LM12H458 
is instructed to complete a calibration, and thus control of the CPU is returned to other software tasks. The 
completion of the calibration causes another ISR to program the LM12H458 to begin again. 


55 


Main ("Pause”) ISR 
for A/D (LM12H458) 





_ i 

Setu 

Calibi 

Inter 

p for 
ration 
rupt. 



Stan 
Calibr 
-i 

[Full 

ation. 


Figure 21. A/D Main ISR. 


Program A/D 
Sequencer. 


Setup ^ for 
"Pause" 
Intemjpt. 


Reset A/dJ 


Start 

Sequencer. 


^ tRET. ^ 


5l 












3. Data Gathering - Temperature Multiplexers 

All temperature signals sensed using thermistors (all temperature measurements except two IC 
temperature probes on the System Controller and Modem boards) are multiplexed onto the Temperature 
Analog Multiplexing units (TMUX) [Ref. 37]. These signals pass through an appropriate signal 
conditioning circuit and are then available to the LM12H1458 for analog-to-digital conversion. This 
conditioned analog signal is passed to the LM12H458, on-board a System Controller. All of the TMUX 
selections are controlled using the Peripheral Control Bus. 

TMUX control is handled by four address lines and four selector lines using the Peripheral 
Control Bus. All multiplexers are fed the same address lines. However, four separate selection lines 
provide the TMUX enabling to each individual TMUX. The following table indicates the assignments of 
the bits that describe the TMUX configuration. 


■IPs 

Function 

7 

Unused 

6 

Unused 

5 

MUX 1 Select (subaddress) Channels 16-31 

4 

MUX 0 Select (subaddress) Channels 0-15 

3-0 

MUX Address (applies to each MUX) 


Table 12. TMUX Control. 


Temperature sensors are named T&c, where x is a number beginning with 0. Temperature sensors 
which deliver a signal to TMUXA are even numbers (including the beginning 0), and temperature sensors 
to TMUXB are odd numbers. Furthermore, all sensors are redundant, for every sensor providing a signal 
to TMUXA, another sensor exists to provide the same sensor location to TMUXB. The number system is 
such that if X is a sensor for TMUXA, jc + 7 is the redundant sensor for TMUXB. 

4. Data Conversion 

Data conversion for voltages, currents, and temperatures are explained in this section. Note that N 
is an unsigned value from the A/D converter. And where appropriate, SIGN is either +1 or -1 and 
determined from reading the current direction sensor. 

o. Battery Current Conversion 

The current going into (positive) or leaving (negative) a battery is determined using 

Equation 4. 


I = 2*SIGN* 




SIGN 0.002442-^5) 


( 4 ) 


57 















b. Spacecraft Bus Current Conversion 

The calculation of the spacecraft bus current is identical to the conversion of the battery 
current except that there is no direction, and thus the use of SIGN is eliminated, Equation 5. 


I = 


N' 




iV* 0.002442-5 


( 5 ) 


c. Battery Voltage Conversions 

Battery voltage measurements are accumulated voltage readings across cells in series. 
Starting with cell 0 as the first cell in series, each successive cell has a voltage measurement across the 
entire series, and not the individual cell. Accumulated Cell Voltages require a conversion weight, W 
(Table 13), which depends on the cell. 





0 

1.0 

1.0 

1 

1.0 

i.b 

2 

1.6953 

1.6969 

3 

1.6997 

1.7015 

4 

1.7014 

1.7029 

5 

2.4267 

2.4283 

6 

2,4262 

2.4314 

7 

2.4311 

2.4317 

8 

4.9 

4.93 


Factor {W) 

Factor (W) 


Table 13. Battery Voltage Conversions. 


First, the accumulated cell voltages are converted (Equation 6). These accumulated cell 
voltages are the steps of voltages measured across the entire cell series, starting with cell 0 as the base cell 
with direct reference to ground. 



*W ^ 0.001221 


( 6 ) 


Next, each individual cell voltage can be calculated by subtracting the cell’s accumulated 
voltage from the cell previous to it, with exception of the first cell, cell 0. This is shown in Equation 7. 


F(0)=F,(0) 


58 


l<i<8 


( 7 ) 




d. Thermistors 

An Omega 440048 thermistor’s [Ref. 38, p. D-4] temperature value is converted using a 
table lookup. This is because the conversion is based upon the mathematically intensive Equation 8. The 
table lookup performs a binary search where there are a maximum of seven compares needed for a lookup. 
The table is used by taking the value from the A/D converter and finding the closest match in the table. 

The position of the match in the table indicates the temperature of the sensor. Appendix G contains a 
complete discussion of the conversion process. 




_ 1 _ 

^ + 5*ln(J?) + C*[ln(i?)]' 


- 273.15 



where R is the resistance of the thermistor, 

V is the voltage sensed across the thermistor, 

andis the Calibration Current A, B, and C are coefficients 

choosen to best fit temperature values in the range from - 0^ C to 30^ C. 

A = 9.306xl0‘'‘,B = 2.218x10“'‘.C = 1.253xl0‘’. 


( 8 ) 


e. Temperature Sensors (ICs) 

Conversion of the IC temperature sensors is straight-forward as shown by the 
relationship expressed in Equation 9. 


T = {N-0.5)*m ( 9 ) 

5. Data Recording 

At regular intervals, preset to every minute but modifiable by command from the ground station, 
all of the sensor data and various software statistics are saved to the mass storage devices. The purpose of 
recording this data is two-fold. First, the system software uses this recorded data to make decisions, in 
particular when the satellite has a power reset, or a System Controller is turned off and its alternate turned 
on. When powered on, a System Controller attempts to find previously saved data in the mass storage 
which will describe the prior state of the satellite. In the case of the first time the satellite operates (i.e. 
after launch), the mass storage is completely initialized. The Battery Charge Monitor (discussed in the next 
chapter) relies on this recorded data to make intelligent decisions regarding the state of the batteries if 


59 



possible. The data is recorded so that it is accessible to the ground station for detailed analysis. An 
overview of the telemetiy record contents is shown below in Table 14. A detailed description of the 
telemetry record is found in Appendix J, documented in the software source code. 


Jtem.'"' 

Qinaiitltyi 

Pjwcriptlon ” 

Time/Date 

1 

Spacecraft time and date recorded in number of ticks (60 Hz). 

Temperatures 

37 

Temperatures of modules, batteries, and solar panels. 

Voltages 

19 

Voltages of battery cells and spacecraft bus. 

Currents 

11 

Currents of batteries, spacecraft bus, solar panels. 

Hardware Configuration 

37 

Subsystem port settings. 

BCM 

24 

Battery Control Monitor parameters. 

EDAC Errors 

1 

Number of EDAC soft errors. 

SU Fails 

1 

Number of superuser access attemps that failed. 


Table 14. Telemetry Record Contents. 


J. MASS STORAGE INTERFACE 

A mass storage unit (MSU) provides four megabytes of Static RAM (SRAM) to serve as file 
storage for the Spacecraft Software. This unit is intended to save user messages (mailbox storage) and 
archived telemetry. In addition, half a megabyte of Flash storage is available for duplicating telemetry. 

1. Hardware Interface Via the PCB 

The MSU is a data storage device of both volatile and non-volatile solid state memory devices. 
The data address to be accessed is presented and the appropriate control (read or write) is indicated. Four 
and a half megabytes of random access storage are incorporated within the Mass Storage Unit. The 
Peripheral Control Bus is used to interface the Mass Storage Unit and the System Controller. A PPI is 
located at base address of the Mass Storage PCB address (see Table 15). Twenty-two bits of the PPI are 
used to latch an address. There is one read signal and one write signal, and one additional signal used to 
indicate if SRAM or Flash is to be accessed. Table 16 indicates addressing and control usage within the 
PPI. 


60 





























PCB 

S3-Sd 

PCB 

Al-AO 

Usage for Mass Storage Units 



Mass Storage A 

6 

0 

PPI Port A 

6 

1 

PPI Port B 

6 

2 

PPI Port C 

6 

3 

PPI Control Register 

7 

0 

Data (read and write) 



Mass Storage B 

E 

0 

PPI Port A 

E 

1 

PPI Port B 

E 

2 

PPI Porte 

E 

3 

PPI Control Register 

F 

0 

Data (read and write) 


Table 15. Mass Storage Unit: PCB Interface. 


PPliPort 

^ Bits UsW':'';;;: f' 

Usage for Addressing or Control 

Port A 

bo - D7 

Memory Addresses (AO - A7) 

Port B 

D0-D7 

Memory Addresses (A8 - A15) 

Porte 

D0-D5 

Memory Addresses (A16 - A21) 

Port C 

D6 

Select: 1 = Flash, 0 = SRAM 

Port C 

D7 

Unused 


Table 16. Mass Storage Unit: PPI Interface. 


For initialization, the PPI should be programmed as an output only device (Ports A, B, and C all 
8-bit outputs); this is accomplished by writing a 0x80 to the PPI Control register. Port C controls both the 
selection of either the Flash or the SRAM devices and the most-significant address bits of both device 
types. Since selected Flash devices draw less current than selected SRAM devices it is best to select the 
Flash devices when a Mass Storage board is powered on (but not being read or written to). Furthermore, 

A18 and A19 select only high address bits of the SRAM; selecting a Flash device in this address range 
causes a non-existent Flash device to be selected, drawing even less power. Therefore, a powered-on Mass 
Storage board, when not performing reading or writing, should have its Port C set to 0x48. 

2. Software Interface 

Device driver software allows the functions of formatting (clearing memory in preparation of 
writing data), writing to, and reading from the Mass Storage units. Although the entire memory space of 
one mass storage can be addressed as a continuous address space, due to logical use of the memory, the 
memory space is visualized and thus segmented into two memory types: the volatile 4 Mbyte SRAM, and 
the non-volatile Mbyte Flash. 


61 
























































a. Reading and Writing Requirements 

Reading from either type of memoiy is straight-forward. An address is programmed into 
the PPI on the Mass Storage board, and then a PCB read retrieves the value of the cell pointed to. Writing 
to the SRAM is similar to reading, except a PCB write is issued. However, writing (and erasing) the Flash 
involves writing specific address and data sequences into the command register of the Flash device 
[Ref. 39] defines these register command sequences which allow writing, erasing, and checking 
manufacturer and device type codes. 


Command. 
Sequence'/. 

i ;,, First ' 

Bus Write 

t; ’’, ' 

Third 

..Bus.:Writd;';{' 

Fourth . 

; Bus Write; 

, Fifth;;.,-., ■ 

Bus Wri^ 

■ ■ 'Sixth. '■ 

■ Biu'Write 

AU values . 
are in Mac, 

Addr 

"'Data- 

Addr 

Data 

Addr 

Data 

Addr 

Data 

Addr - Data 


Read/Reset 

5555 

AA 

2AAA 

55 

5555 

FO 

RA 

RD 

RA = Read Address, 

RD = Read Data 

Scan 

5555 

AA 

2AAA 

55 

5555 

90 

0/1 

Code 


Write 

5555 

AA 

2AAA 

55 

5555 

AO 

WA 

WD 

WA = Write Address, WD = Write 

Data 

Erase 

5555 

AA 

2AAA 

55 

5555 

80 

5555 

AA 

2AAA 55 5555 10 


Table 17. Mass Storage Unit: Flash Commands. 


b. API Functions 

API fimction calls for each memory type are provided for ease of programming as well 
as making the source code very explicit to understand regarding the references to the Mass Storage 
memories. These functions are shown in Table 18. For redundancy purposes, the ROM Boot Loader 
software writes all recorded data to each Mass Storage unit and to both memory types. Thus, the data can 
be quadruplicated. All records of data written to a Mass Storage device use a Cyclic Redundancy Check 
(CRC) [Ref. 40] for read-back verification. The CCITT CRC-16 will detect all single-bit, dual-bit, odd 
numbered, and bursts of fewer than 17 bits wide types of errors. Detection of other errors is about 
99.997%. This is the same CRC algorithm as used within the SCC except that the seed CRC is 0 (instead 
ofOxFFFF). 


Function Name 

Description 

msu_erase_flash() 

Erase entire Flash (sets cells to OxFF). 

msuread_flash() 

Read specified number of bytes from a specified address in Flash. 

msuwritejflashO 

Write a specified number of bytes from a specified address in Flash. 

msu_scan_flash() 

Scan Flash devices for manufacturer and device type codes. 

msa_set_addr() 

Set the mass storage address pointer to a specified location. 

msuerase_sram() 

Erase entire SRAM (sets cells to OxFF). 

msu_read_sram() 

Read specified number of bytes from a specified address in SRAM. 

msuwritesramO 

Write a specified number of bytes from a specified address in SRAM. 


Table 18. Mass Storage Unit: API Functions. 


62 

































































c. Timing Requirements 

Reading and writing to a Mass Storage unit takes a considerable amount of time 
especially writing to the Flash memories. Therefore, it is critical that the amount of time required to 
accomplish such operations is determined and taken into consideration when designing and writing the 
device drivers as well as the high-level code that uses the Mass Storage. In general, reading and writing to 
the SRAM, and reading from the Flash take a similar amount of time. However, writing to Flash is nearly 
eight times slower. Since data may be read and written in blocks, a general formula was determined which 
gives a per byte time requirement. Reading and writing data in blocks is preferred (rather than single byte 
function calls) because the overhead of multiple function calls is reduced, and address incrementing 
techniques can be exploited (e.g. only updating the address digits that change). Table 19 shows the formula 
and the transfer time for 256 byte blocks. 


Function Name 

Clock Cycles Required Per Byte 

Time (n = 256) 

msu_read_flash() 

Clocks = 1210 + n*(862) + (n-l)*(31) + 40 

31 msec 

msu_write_flash() 

Clocks = 320+ n*(7668) 

266 msec 


Clocks = 1207 + n*(862) + (n-l)*(31) + 40 

31 msec 

1 msu_write_sram() 

Clocks = 1207 + n*(834) + (n-l)*(31) + 40 

30 msec 


Table 19. Mass Storage Unit: Timing Of Operations. 


This concludes the presentation of the System Controller software device drivers. These 
drivers are necessary to provide simple and direct control of the hardware peripherals (electronics of the 
System Controller as well as the electronic modules of the spacecraft). However, the goal of the software 
developed for PANSAT is to provide a system which orchestrates all of the hardware of the spacecraft. 
This software is referred to as the System Controller high-level software and is presented in the next 
chapter. 


63 






















64 


VI. SYSTEM CONTROLLER HIGH-LEVEL SOFTWARE 


A. DESCRIPTION 

Upon completion of the hardware initialization and the creation of a runtime environment suitable 
for higher-level layers of software, software progresses to the central loop contained in the module main.c. 
Operation then consists of monitoring and charging the batteries while establishing primitive 
communication with the PANSAT Ground Station at NPS to begin the upload of the Kernel and the PHT 
loader. Thereafter, a higher level protocol will upload BAX, the primitive Telemetry collector, and an 
AX.25“aware loader. Then, using AX.25, the FTLO protocol, the File System, and Bulletin Board services 
software are uploaded. Finally, the spacecraft is ready for general use. 


B. SERIAL COMMUNICATIONS - Serial Test Port Interface 

The Serial Test Port Interface (STPI) is an asynchronous serial communication interface that 
exchanges messages between the System Controller and an external computer acting as a Data Terminal 
Equipment (DTE). The DTE is a dumb-terminal which is capable of sending data and displaying messages 
sent from the SC. A large set of commands is implemented to operate and test the spacecraft via the STPI. 
The command menu is shown below in Table 20. Responses from the commands (sent by the SC) vary 
depending on the command; however, all responses print out as readable messages on the terminal. 


65 


Command 

_^ 

Description 

in 

Input byte 

inw 

Input word 

out 

Output byte 

outw 

Output word 

peek 

Read byte 

peekw 

Read word 

poke 

Write byte 

pokew 

Write word 

dump 

Dump paragraph 


A/D ISR control 


Get recent telemetry 


time: g 

Get time 

time: s 

Set time 


bcm: p 

BCM: on/off 

bcm: c 

BCM: configure 

bcm: s 

BCM: status 


modem:p 

Modem: power 

modem:m 

Modem: mode 

modem:r 

Modem: read status 

modem:w 

Modem: write 


on/off 


clear/spread/test 


see: i 

SCC: initialize 

see: r 

SCC: read register 

see: w 

SCC: write register 

sec: h 

SCC: hunt 

sec: rx 

SCC: Receive 

sec: tx 

SCC: Transmit 


Param. 

2 


Param. 

3 


Param. 

4 


pebr 

PCB read 

select 

subaddr 

pebw 

PCB write 

select 

subaddr 


eps:p 

EPS: power control 

device 

on/off 

eps:b 

EPS: battery control 

battery 

switch 

eps:v 

EPS: read voltage 

select 

cell# 

eps:i 

EPS: read current 

select 

sp# 



msu:p 

MSU: power 

device 

on/off 

msu:e 

MSU: erase flash 

device 

sector# 

msu:r 

MSU: read 

device 

type 

msu:w 

MSU: write 

device . 

type 


tmux: p 

TMUX: power 

device 

on/off 

tmux: r 

TMUX: read 

device 

channel # 


RF: power control 

on/off 

RF: configure 

config data... 





length 


Table 20. STPI Commands 





















































































































































C. BATTERY CHARGE MONITOR 


Two battery packs are within the spacecraft [Ref. 41]. Each battery pack consists of nine nickel- 
cadmium cells with a standard capacity of approximately 4.4 AmpHours. The batteries are for eclipse 
power and power regulation and conditioning circuitry while in sun-soak. The power system must be able 
to switch from external solar power to internal battery power without major power spikes or fluctuations. 
The EPS relies on the System Controller to activate switches and to determine charge levels of the 
batteries. Both batteries will be depleted beyond the capability of operation at launch due to the storage 
time between integration and ejection from the Shuttle. A trickle charge circuit provides battery charging 
at the beginning-of-life while the spacecraft operates in the sunlight. This will allow a low power mode of 
operation during eclipse in the very early stage of the mission until the batteries are sufficiently charged. 
During spacecraft operation the battery control algorithm will use temperature, current, and voltage 
measurements to determine the state-of-health of the two batteries. The state-of-health determines which 
battery is on line (providing buffered power to the spacecraft bus during a sun-soak and full power while in 
eclipse), and which battery is being charged. 

The battery charge monitor (BCM) is an algorithm that controls the charge and discharge cycles 
of both batteries. It controls and monitors the charge and discharge cycles using overcharge times, cell 
temperature profiles, cell voltages and charge/discharge currents. Depending on the battery status, a Target 
battery is selected to be charged. Also, once the satellite is launched into space, the power provided from 
the solar panels must be distributed and regulated. While the satellite is in eclipse, power from the batteries 
is necessary to keep PANSAT operational. The battery has to provide additional power during sunlight in 
the event that the solar panel output is insufficient, such as during transmission. The Online battery 
provides this power. Furthermore, the algorithm indicates the available power for operations, depending 
on the charge state of the batteries: low, stand-by, or normal power operation modes. According to the 
mode, certain subsystems will be turned off to guarantee operation. 

The BCM also checks for corrupt data which is stored to review the charge state history of the 
batteries. When such an error occurs, the algorithm will set the satellite to a default condition and restart 
the battery charging based on measurements only, beginning new charge state history data. The algorithm 
also detects either sunlight or eclipse. This is necessary to activate certain switch configurations to allow 
continuous operation when the satellite is going through a transition from sunlight to eclipse or vice versa. 

1. BCM Top Level 

The BCM is essentially a large series of questions which are asked on a continual and frequent 
basis. The questions consider recent measurements (temperature, current, and voltage) of the batteries, past 
measurements, and whether or not the spacecraft is in eclipse. This series of questions determines how the 
switches within the EPS are turned on and off in order to maintain correct and efficient use of the batteries. 


67 



These switches control which battery is on line, charging (trickle and normal), and discharging. A top- 
down view of the algorithm is shown, starting with the main structure shown in Figure 22. 


Battery Control Monitor 



Figure 22. Battery Control Algorithm Top Level. 


68 







A handful of variables describe the state of the BCM, such as Capacity, Count, Online, Target, 
Mode, and cell voltage maximums. Capacity indicates how much charge is presently in a battery and is 
expressed in AmpHours. The default Capacity for each battery is 0 AmpHours (empty). Count indicates 
how many times a battery has been recharged as opposed to overcharge (discussed later). Initially, a value 
of -2 (UNKNOWN) is assigned which means the battery needs immediate overcharging. Target indicates 
which battery is currently being charged. To begin, the Target is None (neither battery since it must be 
decided). Mode depends on the charge state of the batteries. Initially, Mode is Low (meaning satellite 
operations should consume the least amount of power), and progresses to Standby, and Normal. Cell 
Voltage maximums keep track of the highest voltage each cell in a battery reaches during a charge cycle 
(while it is the Target). 

Other useful parameters are depth of discharge (DOD), temperature references, an overcharge 
voltage threshold, and timers. A previously charged battery which is online and losing charge capacity 
reaches its depth of discharge (DOD) when it has 60% of its full capacity. This is a condition that should 
trigger the battery to no longer be used for discharging and to begin a new charge cycle as soon as possible. 
Temperature references note the temperature of batteries when a battery is first placed on line or started 
charging. Such temperature references are used to monitor rapid temperature increases which can signify a 
battery reaching overcharge; thus, this is a safety mechanism. An overcharge voltage threshold is a voltage 
that is temperature dependent and indicates when a battery is approaching an overcharge condition. This 
condition triggers the starting of timers which further monitor the amount of charge a target battery 
receives before completing a charge cycle. 

2. Battery Use Eligibility and Preference 

As a necessary requirement for a battery to be eligible to be Online or the Target, the conditions of 
the batteries are examined as shown in Figure 23. There are three topics of interest which can persuade 
whether or not a battery is suitable for use. First, if a battery is already being charged (is the Target) and it 
has a cell voltage below 0.9 V, then that battery should not be used. It should be considered defective. 
Second (and this applies potentially to both batteries), if a battery is not currently being charged and has 
already been charged then its cells must have a minimum cell voltage of 1.1 V. Otherwise, that battery 
should not be used. It should be considered defective. If both batteries are still eligible for operation, then 
the temperatures of the batteries are examined (Table 21); that is, both batteries are still eligible for use. If 
the temperatures (an average temperature of all cells) of both batteries are between 0°C and 35°C, then 
both batteries arc eligible for use and there is no preference. Any preference given will be a function of the 
charge state of the batteries (discussed later). However, if the temperatures are out of the range just 
described, then one of the batteries will be preferred over the other. 


69 



Figure 23. Battery Preference, 





Search begins by using lowest temperatures in this table and working towards higher temperatures. 

Battery A 


Battery B 



<-10 

<=0 

<35 

<=45 

>45 

<-10 

Use Warmer A 

A 

A 

B 

<=0 

B 

Use Warmer A 

B 

B 

<35 

B 

B 

No Preference 

B 

B 

<=45 

B 

A 

A 

Use Cooler 

B 

>45 

A 

A 

A 

A 

Use Cooler 


Table 2L Battery Preference Based On Temperatures. 


3. Determine Online Battery 

In order to determine which of the batteries should be online, many questions are answered 
(Figure 24). First, a battery preference (as described above) is considered. If no such preference exists, 
then the following is considered. If there is not already an online battery then the battery with the most 
capacity (stored charge) is chosen. Otherwise, if a battery is already designated as online, it remains online 
as long as its voltage has not dropped below a voltage threshold of 1.1 V and its capacity is above its DOD. 
If the capacity of the online battery is below its DOD and if the other battery is not being charged, then the 
other battery becomes the online battery allowing the depleted battery to begin a new charge cycle. 
However, if the online battery must remain online because the other battery is being charged (disrupting 
charge cycles is not preferred) then this condition is flagged and power consumption within the spacecraft 
must be reduced. 


71 






to other bitta;. 



SeiBitteiyOoliBe 













4. Determine Target Battery 

During the next portion of questioning (Figure 25), if applicable, a battery is chosen to become the 
Target and will begin being charged. Again battery preferences take precedence in the decision as to 
which battery should be the Target. If no such preference exists, and there is not already a Target, then the 
battery that is below its depth of discharge (DOD) is chosen. If both batteries are below their DODs, then 
the battery that has the lowest capacity is chosen. Otherwise, if both batteries are charged above their 
DOD, then no battery becomes the Target. The possibility of no battery being the Target at first seems 
inappropriate. However, the batteries will have the longest life if they are only charged after sufficiently 
being discharged, i.e. reaching an appropriate depth of discharge. 


73 








Figure 25. Determine Target Battery. 


74 
















5. Charging Methods 

Figure 26 shows the charging overview questions which occur prior to attempting to charge a 
battery. First, the satellite must not be in eclipse in order to allow charging. Also, there must be a Target. 
Finally, if charging is appropriate, one of two methods are used, depending on the charge state of the 
Target battery. The two methods are overcharge and recharge. 


Charge Battery 



Figure 26. Battery Charge. 


Overcharge 

A Target battery is charged using the overcharge method when its charge state is 
unknown or it has already been recharged a maximum allowable number of times. The overcharge 
method, shown in Figure 27, keeps the Target charged until a voltage threshold has been reached. This 
voltage threshold depends on the temperature of the battery. Once this threshold has been reached, a timer 
is set. Typical overcharging of a battery is based on a time which depends on the allowable power mode of 
the spacecraft (Low, Standby, and Normal). By charging a set amount of time, a battery can be guaranteed 
to reach beyond its 100% capacity (regarding the amount of charge placed into the battery); and thus, at the 
completion of this overcharge the battery can be considered 100% full, containing 100% of its capacity. 


75 





Overcharge 






iChar^ the I 

I Tal^ I 




Cannot Conttunue 
jOvenrharge due to 
over Negration. 




Figure 27. Battery Overcharge. 


b. Recharge 

A Target battery is charged using the recharge method when its charge state is known 
and it has not been recharged a maximum allowable number of times. The recharge method, shown in 
Figure 28, keeps the Target charged until its full capacity has been reached. This is performed using 
current integration in order to monitor the amount of current that enters the battery. 


76 
















Battery Recharge 



Figure 28. Battery Recharge. 


6. Battery Mode 

The operational mode of PANSAT depends on the charge state of the batteries which is 
maintained by the BCM. The operational mode indicates how much known stored energy is in the 
batteries at any time, and thus dictates how much power should be consumed by spacecraft operations. 
Figure 29 shows the decisions made to determine the mode. 


Determine Battery Mode 



Figure 29. Battery Mode. 
77 















D. GROUND STATION COMMAND INTERFACE 

After deployment, PANSAT only accepts requests received by RF transmissions. The ROM Boot 
Loader understands a very limited set of commands. The goal of the Boot Loader is to load the secondary 
loader while maintaining the spacecraft subsystems (in particular the batteries) in the most simple manner 
possible. Commands are sent from the NPS ground station as packets of data which are requests to the 
satellite to perform some action. The satellite responds to all commands with an acknowledgement packet 
which may contain extra information depending on the command sent. Table 22 shows the commands 
accepted during this initial stage of operation. The command encoding was designed so that each 
command has 4 bit differences between any other command. Even though the packets are CRC encoded in 
order to determine if there are bit errors, it is easy to also apply an encoding mechanism onto the 
commands to provide further error prevention. 


poihmaiid- = 

Encoding 

Description 

Confirm 

0x55 

Confirm a control command. 

Control 

0x5A 

Request satellite to perform a particular operation. 

Execute 

0xA5 

Transfer control to uploaded software (secondary loader). 

Get Parameters 

OxAA 

Get parameters of A/D, BCM, hardware scenarios, RAM 
wash, time. 

Load 

0x66 

Load a block of data into a specific area of RAM. 

Map 

0x69 

Send Address/Data Map for future Load commands. 

Reset 

0x96 

Stop the System Controller, forcing alternate to Reset. 

Set Parameters 

0x99 

Set parameters of A/D, BCM, hardware scenarios, RAM 
wash, time. 

Status 

0x00 

Send state-of-health (SOH) information. 

Status Log Clear 

OxOF 


Status Log Read 

OxFO 

Send recorded SOH. 

Verify 

OxFF 

Verify a block of memory in RAM. 

Unknown 

7 

Command received but is corrupt. 


Table 22. ROM Boot Loader Commands. 


1. Command Packet Protocol 

The data field within a command packet is limited to 262 bytes of data, regardless of the 
command. This odd number was chosen to allow a paragraph aligned, 256 byte block of data to be sent 
with the Load command to upload code and data images. The bytes in the data field are numbered 0 
through 261. The data field format depends on the command. 


mm 

.::v - 

1 Command 

Data (relating to the command) 


Table 23. Command Packet Data Field. 


78 
















































2. Commands 


a. Confirm 

The Confirm command is in response to the spacecraft receiving a command that 
requires confirmation, in which the spacecraft then sends an acknowledgment that requires confirmation. 

b. Control 

The Control command contains another command within the request packet that specifies 
some action the satellite should perform and return any data (or at least an acknowledge of having 
completed the action) back to the ground station. Permissible commands are shown in Table 20. 

c. Execute 

The Execute command also contains an absolute memory address which is an instruction 
pointer which contains the address of uploaded software in which transfer of control will be given. The 
spacecraft will send an acknowledgement before it executes^ requiring the confirm command to be sent 
from the ground station. 

d. Get Parameters 

This command requests the spacecraft to send down all the parameters that describe and 
regulate the activities of the autonomous control algorithms, e.g. RF, Modem configuration, A/D gather 
and record rates, RAM wash rate, and Battery Control Monitor configuration. 

e. Load 

The Load command contains an address followed by a block of data. The address is the 
beginning address where the data should be stored. Thus, the first data byte will be stored at the address, 
the next data byte will be stored at the next larger address, etc. This command allows an arbitrary memory 
image to be transferred from the NPS ground station to PANSAT. Normally, this command is used to 
upload an image of the secondary loader which will take over the work of the Boot Loader. 

The Load command uploads data pages which are up to 256 bytes in size. The absolute 
address at which the data is to be loaded is given. Upon successfully receiving a page without errors and 
storing the page into RAM without errors, the page address is recorded in a list. This list of successful 
loads is used later when verify commands are given. 

f. Map 

The Map command is used prior to a sequence of Load commands in order to let the 
spacecraft know about the number, location, and size of data blocks. All Map commands are 
acknowledged by PANSAT immediately following successful reception. If a negative acknowledgement is 


79 



sent (or if no acknowledgement is sent), the Map command needs repeating. Multiple Map commands 
may be necessary if a large number of Loads follow. 

g. Reset 

The Reset command forces the System Controller to enter a halt state. This will cause 
the SC to fail to update the watchdog timer and thereby causing it to be powered down by the EPS. This 
command causes the spacecraft to first send an acknowledgement of receiving the command^ the confirm 
command must then be sent to perform the reset. 

h. Set Parameters 

This command indicates to the spacecraft that there are new parameters to set within the 
spacecraft which affect the activities of the autonomous control algorithms, e.g. RF, Modem configuration, 
A/D gather and record rates, RAM wash rate, and Battery Control Monitor configuration. This command 
causes the spacecraft to first send an acknowledgement of receiving the command; the confirm command 
must then be sent to perform the parameter setting. 

L Status 

The Status command requests the satellite to send a complete state-of-health packet back 
to NPS. This information contains sensor data acquired by the A/D acquisition system as well as various 
software variables and parameters which describe the operational mode of PANS AT. 

y. Status Log Clear 

This command requests the spacecraft to clear all of the recorded status records on the 
mass storage. This command causes the spacecraft to first send an acknowledgement of receiving the 
command; the confirm command must then be sent to perform the clearing of records. 

k. Status Log Read 

This command tells the spacecraft to send down all of the recorded status records that 
have been saved to the mass storage. 

L Verify 

The Verify command is accompanied by an absolute memory address, which specifies a 
block of data as used in the load command. Upon receipt of this command, PANSAT will check its list of 
receive data blocks from earlier Map and Load commands. A response is returned, in the form of a data 
block starting address, indicating which data blocks failed and need repeat transmission. 


80 



nu Unknown 

In the event that the spacecraft actually receives an incoming packet in the form of a 
command but is unable to make exact sense of the command, this response is sent back to the NPS ground 
station, explaining that no action occurred. 

3. Loading Sequence 

The loading of blocks of data from the ground station to the spacecraft is a complex sequence of 
operations, which is best viewed from a diagram. The sequence, Figure 30, is from the point of view of the 
ground station, sending blocks of data to the spacecraft. To begin, maps are built that describe all of the 
data blocks to be sent up; then the maps are sent using the Map command. Each Map command is 
acknowledged by the spacecraft before the next one is sent. Next, the blocks are prepared and, using the 
Load command, each block is sent up without any acknowledgement from the spacecraft. Finally, 
verifications are prepared. For each Verify command sent, the spacecraft is to send down an immediate 
response. The response may be in the form of multiple packets (if there were many Load errors). 

Following this response from the spacecraft, for each Load error identified, the block is prepared and resent 
to the spacecraft. The verification process is complete when the spacecraft returns a response indicating 
that there are no known Load errors. 


Upload Sequence (Ground station point of view). 



Figure 30. Block Loading Sequence. 


81 








E. SCENARIO CHECKS 

On a regular basis during the execution of the Boot Loader, hardware and software sensors are 
used to determine whether or not various hardware subsystems of PANSAT are functioning correctly. 
Many of these checks are directly related to the communication systems. Since a lack of communication 
fi-om NPS most likely indicates that hardware on board the satellite is not functioning correctly or is not in 
the mode presumed, symptoms that show this type of behavior are monitored. In the event that such a 
symptom is found, the spacecraft either programs the hardware to another configuration or uses an entirely 
different piece of hardware. Figure 31 shows a flow diagram indicating the various symptoms which are 
monitored and the t3q5e of cure used. 


Check Hardware Scenarios. 



Figure 31. Scenario Check. 


82 




VII. RESULTS, RECOMMENDATIONS, AND 

CONCLUSION 


A. RESULTS 

1. Printed Circuit Board 

The System Controller described in this thesis was fabricated on a printed circuit board. The 
layout of the board was performed by David Rigmaiden of the Space Systems Academic Group with the 
assistance of the author and the schematics generated with this document. Accel Technology’s 
P-CAD/Tango software was used as the layout tool. The result is a six layer board suitable for space flight. 
Details of the layout and board manufacturing are beyond the scope of this document. 

The printed circuit board was component stuffed by Rigmaiden and was tested by the author. 

The testing involved the verification of each circuit element on the PCB. Appropriate voltage levels were 
measured and were in accordance with expected values. Higher-level testing was accomplished by means 
of software control and reading back of data if possible. Various voltage meters, oscilliscopes, and an in- 
circuit emulator (ICE) connected to a general purpose computer were used to determine that the system 
was operating properly. 

2. Use of In-Circuit Emulator 

The Microtek MICE-III ICE was used to emulate the M80C186XL during initial tests. The 
microprocessor was removed from the printed circuit board, and the in-circuit emulator connected to die 
CPU’s socket. This setup is shown in Figure 32. The emulator provided a means to run a program in 
emulation RAM and emulation ROM; later, the actual RAM and ROM were tested by placing these 
components onto the actual printed circuit board. The emulator allows rapid modification of the test 
programs without the requirement to re-program the system EPROM. The emulator also provides an 
interface that allows single stepping through test programs at the machine level or at a higher level (e.g. C 
program statements). Furthermore, sophisticated breakpoints based on hardware or software conditions are 
programmable. 


83 



Figure 32. In-Circuit Emulator. 


The emulator exhibited unusual behavior during testing with programmed ROMs. The emulator 
was unable to drive the memory system with correct voltage levels; and thus, the ROMs on the printed 
circuit board were not correctly stimulated and did not operate. This was of little consequence to 
development however, since ROMs are needed only after significant testing and development has occurred. 
This unusual behavior is attributed to the various families of interface logic that differ between the ICE and 
the board. 

3. Software 

Device drivers were used to test the hardware peripherals of the System Controller as well as the 
electronics of the satellite subsystems. Device drivers were tested first individually while observing that 
the hardware was driven as desired. Next, device drivers were tested while operating together as multiple 
interrrupt service routines while noting that the hardware was driven as desired. Higher-level software 
routines were tested using the same methods as described for the device drivers. However, higher-level 
software tests ran autonomously, logging data to a general purpose computer which could be examined 
during and after the tests to ensure correctness of operation. 


84 










4. Testing 

Tests were performed on the fabricated System Controller to evaluate the operation of the 
hardware as well as verify the software that runs on the hardware. The results were all positive. Appendix 
K lists the tests performed during different stages of the System Controller construction. 

B. RECOMMENDATIONS 

The design of the System Controller glue-logic can be replaced with a programmable logic 
device, such as a programmable gate array (PGA). This would reduce PCB area and power consumption. 
The Space Systems Academic Group needs to investigate the acquisition of tools to simulate and test as 
well as program such devices. 

An additional design change would be to not only incorporate the glue logic, but also the EDAC 
controller and memory buffers into the same PGA. This would further reduce power consumption and 
PCB area. Such a controller could use additional M80C186 status bits (S2 - SO). These status bits, along 
with the Bus High Enable and AO signals are available turing the first half of the first T state of the 
microprocessor. These signals can identify if word write operations are about to occur in which the “read 
and correct” can be eliminated and the associated error flags may also be eliminated. This would also 
reduce power consumption since the RAM would be accessed less. 

The peripheral control bus (PCB) of the spacecraft requires too much supervision by the CPU in 
order to be effective for a data bus that requires higher data transfer rates. A simple controller could be 
designed that accesses a small FIFO memory which stores subsystem address, sub-addresses, and data (for 
a PCB write operation). The CPU could quickly add elements to the FIFO and let the controller 
independently handle all of the PPI transactions. Another incoming FIFO would be used to store data read 
from the PCB; it would be accessed by the CPU to gather incoming data. 

C. CONCLUSION 

The System Controller hardware and embedded software described in this thesis provide 
PAN SAT with a reliable digital computer suitable for use in the LEO environment. The system is capable 
of autonomously controlling the spacecraft after launch and reset conditions. The system meets the design 
requirements by using a small number of readily available, reasonably priced components. 


85 



I 




1 


86 




APPENDIX A. HARDWARE SCHEMATICS 


This appendix contains the detailed schematics for the System Controller hardware. The 
following drawings are included: 


Description . 

Drawing (Figure) 

System Controller - CPU and Data/Address Buffers 

Figure 33 

System Controller - Memory 

Figure 34 

System Controller - A/D and SCC 

Figure 35 

System Controller - PCB, Power Detect, and Power Supply 

Figure 36 


87 































































89 






















90 



























































92 



APPENDIX B. SYSTEM CONTROLLER CONNECTOR 

PIN-OUTS 


This appendix contains the pin-outs for all of the connectors of a System Controller. The 
connectors are the 9-pm analog input signals, the 9-pin RS-232 serial test port interface, the 25-pin 
Peripheral Control Bus, and the 37-pin Modem interface. 


"PittJNiinibeiJff 

Name 

Description 

1 

DO 

Data Bit 0 

2 

D1 

Data Bit 1 

3 

D2 

Data Bit 2 

4 

D3 

Data Bit 3 

5 

D4 

Data Bit 4 

6 

D5 

Data Bit 5 

7 

D6 

Data Bit 6 

8 

D7 

Data Bit 7 

9 

SO 

System Select Bit 0 

10 

SI 

System Select Bit 1 

11 

S2 

System Select Bit 2 

12 

GND 

Ground 

13 


System Controller Active 

14 

vcc 

PCB +5 V Power 

15 


Switched +12 V Power 

16 

GND 

Ground 

17 

Unused 

Unused 

18 

RTSA 


19 

PCI 


20 


RF Enable 

21 

RD 

PCB Read 

22 


PCB Write 

23 

A1 

Sub-address Bit 1 

24 

AO 

Sub-address Bit 0 

25 

S3 

System Select Bit 3 


Table 24. Peripheral Control Bus Connector. 


93 









































































Table 25. Modem Connector. 


94 














































































































|Pin Nupber 

Function 

1 

TMUXA+ 

2 

TMUXA- (ground) 

3 

Ground 

4 

TMUXB+ 

5 

TMUXB- (ground) 

6 

Ground 

7 

EPS+ 

8 

EPS- (ground) 

9 

Ground 


Table 26. Analog Signals Connector. 


^iniNumfeeiS^: 

■'3S[ame.iS 

Function 

in^tion 

1 

CD 

Carrier Detect 

Out 

2 

Tx 

Transmit Data 

Out 

3 

Rx 

Receive Data 

In 

4 

DTK 

Data Terminal Ready 

In 

5 

GND 

Ground 


6 

DSR 

Data Set Ready 

Out 

7 

RTS 

Ready To Send 

In 

8 

CTS 

Clear To Send 

Out 

9 

RI 

Ring Indicator 

Out 


Table 27. RS-232 Serial Port Connector. 


95 































































APPENDIX C. CIRCUIT BOARD BILL OF MATERIALS 


Type 

Pattern 

Value 

Designators 

CAPO 8 05 

CAP0805 

.OluF 

CIO ClOO ClOl 


C102 C103 
C104 C105 
C106 C15 CIS 
C69 C70 C71 
C72 C73 C74 
C75 C76 C77 
C78 C79 C80 
C81 C82 C83 
C84 C85 C86 
C87 C88 C89 
C90 C91 C92 
C93 C94 C95 
C96 C97 C98 
C99 

330pF Cll 

CAP1206 CAP1206 . luF C107 C108 

C109 C14 C17 
C2 C21 C23 
C26 C27 C28 
C3 C32 C33 
C34 C35 C36 
C37 C38 C39 
C4 C40 C41 
C42 C43 C44 
C45 C46 C47 
C48 C49 C5 
C50 C51 C52 
C53 C54 C55 
C56 C57 C58 

C59 C6 ceo 
cei C62 C63 
C64 C65 C66 
C67 C68 C7 C9 


CTX32 

CTX32 

33uH 

L3 

DB25RM 

DB25Riyi 

HDC25M5000S-0 

J2 

DB37F 

DB37F 

HDC37F32000S-0 

MJ 

DB9RF 

DB9RF 

HDC9F5000S-0 

J31 


97 




DB9RM 

DB9RM 

HDC9M5000S-0 

J18 

54HC04 

DIP14 

54AC04 

U15 



54HC04 

U25 

54HC08 

DIP14 

54AC08 

U1 U12 U33 



54HC08 

U18 U35 

54HC125 

DIP14 

54HC125 

U2 

54HC32 

DIP14 

54AC32 

U34 U4 



54HC32 

U32 U37 

54HC74 

DIP14 

54AC74 

U29 

DG411 

DIP16 

DG411 

U27 

54HC245 

DIP20 

54AC245 

U38 U39 U8 



54HC245 

UlO U22 U23 

54HC573 

DIP20 

54AC573 

U40 U41 



54HC573 

U19 U20 U21 

U7 

54HC574 

DIP20 

54AC574 

U42 

27C256-120 

DIP28 


U36 U43 

1N751 

DO-35 

{Value} 

D3 D4 D5 

LM50 

LM50 

LM50 

U3 

80C186XL 

P186XL 


U5 

ACS630MS 

P630 


U26 

PCAP3528 

PCAP3528 

2.2uF 

Cl C13 

PCAP6032 

PCAP6032 

lOuF 

Clio C20 C22 

PCAP7343 

PCAP7343 

lOOuF 

C12 C16 C19 

C8 

CTX33-2 

PCTXFORM 

33uH 

L2 

CTX50>2 

PCTXFORM 

50\iH 

LI 

AM85C30 

PPLC44 


U16 

IS82C55A 

PPLC44 


U14 

IiM12H458 

PPLC44 


Ull 


iyiSM8256 


PSRAM 


U30 U31 U44 



MAX744A 

MAX211E 

RES1206 


MBRS140T3 

MBRS340T3 

TPS2013 

ICL8212 

XTAL-OSC 


PWS016 


U13 

PWS028 


U17 

RES1206 

lOK 

R1 R2 R3 R4 

R5 R6 R7 R8 


120 

R22 R23 R24 

R25 


147K 

RIO 


IK 

R15 R16 R17 


IM 

R12 


21.5K 

Rll 


511K 

R14 


5K 

R13 R21 R9 

SMB 

MBRS140T3 

D1 

SMC 

MBRS340T3 

D2 

SOS 

TPS2013 

U6 

TO’99 

ICL8212 

U24 

XTAL’OSC 

14.7456MHz 

U9 


99 



100 



APPENDIX D. PERIPHERAL CONTROL BUS 
PROGRAMMABLE PERIPHERAL INTERFACE PORT 

CONFIGURATION 


This appendix contains a detailed description of the programmable peripheral interface (PPI - 
8255) that is used to control the peripheral control bus of the spacecraft. 


Bit 

KFuiictiori ' 


7 

Read (active LOW) 

6 

Write (active LOW) 

5 

Sub-address 1 

4 

Sub-address 0 

3 

Select 3 

2 

Select 2 

1 

Select 1 


Select 0 


Table 28. Port B Assignments for PPI (Address and ReadAVrite Control). 


'!Pdr)tA<|jdrm 

Port Name 

Usage ;,v. ' -c'",. ■•••, ;■ •..'TV 

0x100 

Port A 

Bi-directional using Port C for handshake. 

0x102 

PortB 

Address selection and Read & Write strobes. 

0x104 

PortC 

Handshaking for Port A, EDAC and Modem Control. 

0x106 

Control 

Control register for this PPI. 


Table 29. PPI Port Usage. 



Function :. . . - 

7 

Handshake (unused) 

6 

Handshake 

5 

Handshake (unused) 

4 

Handshake 

3 

Handshake (unused) 

2 

EDAC Error Acknowledge (active LOW) 

1 

Read Latch Enable (active LOW) 

0 

Modem Power (active LOW) 


Table 30. Port C Assignments for PPI (Handshaking and Control). 


101 























































102 



APPENDIX E. ELECTRICAL POWER SYSTEM PORT 

CONFIGURATION 


This appendix contains a detailed description of the Electrical Power System (EPS) ports. 


Port 

■ Address'^ 

tSubaddress 

Bit 

■Contents 

Porto 

8 

0 

7 

Battery A Charge (/ =enable) 




6 

Battery A Discharge (7 = enable) 




5 

Battery A Online (7 = enable) 




4 

Battery A Trickle Charge (7 = enable) 




3 

Mass Storage A Power (7 = enable) 




2 

Temperature MUX A Power (7 = enable) 




1 

mused 




0 

Battery A Heater (7 = enable) 


Table 31. EPS Port 0. 




iSubaddress 



Port 1 

8 

1 

7 

Low Ceil Voltage MUX Select 2 




6 

Low Cell Voltage MUX Select 1 




5 

Low Cell Voltage MUX Select 0 




4 

Low Cell Voltage Enable (7 = enable) 




3 

Medium Cell MUX Select 2 




wm 

Medium Cell MUX Select 1 




ni 

Medium Cell MUX Select 0 




0 

Medium Cell Voltage Enable (7 = enable) 


Table 32. EPS Control Port 1. 


IPort 

Address 

.'■Sobaddress:^^: 

Bit 

Contents 

Port 1 

8 

2 

7 

unused 




6 

Battery B Heater (/ = enable) 




5 

RF Power (7 = enable) 




EM 

Temperature MUX B Power (7 = enable) 




3 

Mass Storage B Power (7 = enable) 




2 

Antenna Release (7 = enable) 




1 

Solar Panel Current Inhibit (fi = inhibit, I = enable) 




0 

Solar Panel Current Strobe 


Table 33. EPS Control Port 2. 


103 





































































Port^ ^ ''Sub^ddressv:'K Hit .^GoinitMts .:' 

Ports 8_3_ 7 Current Select, or High Cell Voltage Select 3 

_ 6 Current Select, or High Cell Voltage Select 2 

_ 5 Current Select, or High Cell Voltage Select 1 

_ 4 Current Select, or High Cell Voltage Select 0 

_ 3 High Cell Voltage MUX Select 2 _ 

_ 2 High Cell Voltage MUX Select 1 _ 

_ 1 High Cell Voltage MUX Select 0 _ 

_ 0 High Cell Voltage Enable (7 = enable) 

Table 34. EPS Control Port 2. 



Table 35. Read-back Port 5. 


Port# v:Subaddii|$s - Bit. -^inlfents , '• v". . 

Port 6 9_2_ 7 Battery B Charge (7 =^enable) _ 

_ 6 Battery B Discharge (7 = enable) 

_ 5 Battery B Online (7 = enable) _ 

_ 4 Battery B Trickle Charge (7 = enable) 

_3 unused 

_2 unused 

_ 1 unused _ 

_ 0 unused _ 

Table 36. EPS Control Port 6. 


■iBatteiry^Cell; ; 

MUX ^ele« Control (Port 3) | 

OA 

0000 1110 

[OxOE] 

lA 

0000 1001 

[0x09] 

OB 

0000 1101 

[OxOD] 

IB 

0000 1011 

[OxOB] 


Table 37. EPS Low Cell Voltage Selections. 


104 










































































;Battei 7 Cell 

MUX Select Control (Port 3) | 

2A 

1000 nil 

[0x8F] 

3A 

1100 nil 

[OxCF] 

4A 

1010 nil 

[OxAF] 

2B 

1110 nil 

[OxEF] 

3B 

1001 nil 

[0x9F] 

4B 

1101 nil 

[OxDF] 


Table 38. EPS Medium Cell Voltage Selections. 



^ MUX Select Control (Port 2) ’] 

5A 

1010 0000 

[OxAO] 

6A 

1110 0000 

[OxEO] 

7A 

1001 0000 

[0x90] 

5B 

1101 0000 

[OxDO] 

6B 

1011 0000 

[OxBO] 

7B 

nil 0000 

[OxFO] 

8A 

1100 0011 

[0xC3] 

9A 

1100 1011 

[OxCB] 

8B 

1000 nil 

[0x8F] 

9B 

1000 0111 

[0x87] 


Table 39. EPS High Cell Voltage Selections 


Siel^tlbn ^ 


f^UX Select Control (Port 2) 

Ports 


Solar Panel: 


0000 0000 

[00] 

0000 1100 

[OxOC] 

Solar Panel: 


0000 1000 

[08] 

0000 1100 

[OxOC] 

Solar Panel: 


0000 0100 

[04] 

0000 1100 

[OxOC] 

Solar Panel: 


00001100 

[OxOC] 

0000 1100 

[OxOC] 

Solar Panel: 


0000 0010 

[02] 

0000 1100 

[OxOC] 

Solar Panel: 


0000 1010 

[OxOA] 

0000 1100 

[OxOC] 

Solar Panel: 


0000 0110 

[06] 

0000 1100 

[OxOC] 

Solar Panel: 


0000 1110 

[OxOE] 

0000 1100 

[OxOC] 

Solar Panel Bus 


0000 0101 

[05] 

0000 1010 

[OxOA] 

Battery A 


0000 1001 

[09] 

0000 1010 

[OxOA] 

Battery B 


0000 0001 

[01] 

0000 1010 

[OxOA] 


Table 40. EPS Current Selections. 


105 

















































































106 



APPENDIX F. A/D ACQUISITION 


Period 

Cycle 

S3 

A/DINO 

A/D INI 

A/D 1N2 

A/DIN4 

A/D IN6 




(DCS) 

(Modem) 

(EPS) 

(TMUXA) 

(TMUXB) 

0 

0 

0 

DCS 

Modem 

SC Current 

0 

0 

1 

1 




Battery A Cell 0 Voltage 

1 

1 

2 

2 




Battery A Cell 1 Voltage 

2 

2 

3 

0 

1 



Battery A Current 

3 

3 

4 

1 




Battery A Cell 2 Voltage 

4 

4 

5 

2 




Battery A Cell 3 Voltage 

5 

5 

6 

0 

2 



Battery B Current 

6 

6 

7 

1 




Battery A Cell 4 Voltage 

7 

7 

8 

2 




Battery A Cell 5 Voltage 

8 

8 

9 

0 

3 



sc Current 

9 

9 

10 

1 




Battery A Cell 6 Voltage 

10 

10 

11 

2 




Battery A Cell 7 Voltage 

11 

11 

12 

0 

4 



Battery A Current 

12 

12 

13 

1 




Battery A Cell 8 Voltage 

13 

13 

14 

2 




Battery B Cell 0 Voltage 

14 

14 

15 

0 

5 



Battery B Current 

15 

15 

16 

1 




Battery B Cell 1 Voltage 

16 

16 

17 

2 




Battery B Cell 2 Voltage 

17 

17 

18 

0 

■E 



SC Current 

18 

18 

19 

1 




Battery B Cell 3 Voltage 

19 

19 

20 

2 




Battery B Cell 4 Voltage 

20 

20 

21 

0 

■B 



Battery A Current 

21 

21 

22 

1 




Battery B Cell 5 Voltage 

22 

22 

23 

2 




Battery B Cell 6 Voltage 

23 

23 

24 

0 

8 



Battery B Current 

24 

24 

25 

1 




Battery B Cell 7 Voltage 

25 

25 

26 

2 




Battery B Cell 8 Voltage 

26 

26 

27 

0 

9 



SC Current 

27 

27 

28 

1 




Spacecraft Bus Voltage 

28 

28 

29 

2 




Solar Panel 0 Current 

29 

29 

30 

0 

10 



Battery A Current 

30 

30 

31 

1 




Solar Panel 1 Current 

31 

31 

32 

2 




Solar Panel 2 Current 



33 

0 

11 



Battery B Current 



34 

1 




Solar Panel 3 Current 



35 

2 




Solar Panel 4 Current 



36 

0 

12 



SC Current 



37 

1 




Solar Panel 5 Current 



38 

2 




Solar Panel 6 Current 



39 

0 

13 



Battery A Current 



40 

1 




Battery B Current 



41 

21 




Solar Panel 7 Current 




Table 41. A/D Conversion Schedule. 


107 


















































































































































































































108 



APPENDIX G. THERMISTOR TEMPERATURE 

CONVERSIONS 


To simplify temperature conversions for the Omega 440048 thermistors, a table is used to perform 
a binary search where a maximum of seven compares are needed for a lookup. The table is used by taking 
the value from the A/D converter and finding the closest match in the table. The position of the match in 
the table indicates the temperature of the sensor. The following discussion describes how the conversion 
process works. 


T = 


_ 1 _ 

^ + B*ln(i?) + C*[ln(/?)]^ 


-273.15 


( 10 ) 


The equation shown above uses three coefficients which were calculated using the temperature 
range suggestions from the Omege Temperature Sensor manual [Ref X]. A short MATLAB program 
(given below) was created to determine these coefficients based on the assumption that the most accurate 
temperature conversions are needed in the temperature ranges between O^C to 30®C. The ability to change 
the coefficients means that the conversion formula can be tailored to have the best conversion for a certain 
temperature range. In doing so, three temperatures must be selected when using the program. One 
temperature must be below the range, another within the range, and the third above the range. 

Furthermore, there can be no more than lOO^^C between the two extremes, and each successive temperature 
can be no more than 60°C apart. The temperatures used are -30^C, 20^C, and 60°C. The corresponding 
resistances based on the generic lookup conversion provided by Omega are 481 kQ, 37.3 kQ, and 
7.599 kQ . The values for the coefficients are A=9.306xl0'^, B= 2.218x10'^, and 0=1.253x10’’. 

T1 = -30 + 273.15; 

T2 = 20 + 273.15; 

T3 = 60 + 273.15; 

T = [1/Tl; 1/T2; 1/T3]; 

R1 = 481.0E3; 

R2 = 37.3E3; 

R3 = 7599; 

R = [1 1 1; log(Rl) log(R2) log(R3); (log(Rl))"3 (log{R2))"3 

(log(R3))"3]'; 

S = inv(R)*T; 

S 


109 



One channel of each temperature multiplexing unit is reserved as a fixed 1% precision resistor is 
used as a calibration resistor to create a calibration current. The calibration current, Ic, is converted as 
follows. 




4095. 


0 . 001221*1 — 


I = ^ = - 

^ Rc Rc VRc 

where is the resistance of a (fixed 1%) 
Calibration Resistor equal to xxx Q. 


( 11 ) 


Thus, a particular thermistor resistance, R, is converted as follows. 


R = 





= 0 . 001221 * 



( 12 ) 


For quick temperature conversions, a table lookup is used where the value N is an index into the 
table. This table is shown in Table 42. Assuming a constant calibration current, the table can remain 
static. If the calibration current changes significantly, the table can be recalculated simply by multiplying 
all of the entries by the change in the calibration current. 


N = -^^ = Zl9*R*lc ( 13 ) 

Because of the resolution of the A/D converter, temperatures above 88° C do not have unique 
conversions from the A/D. Since 5 mV of noise are allowed within the system, temperatures above 44° C 
are not accurate to within one degree Celsius. Finally, a saturated reading from the A/D, i.e. N = 4095, 
corresponds to any low temperature below -30° C. Note, 4191 is above the limit of the A/D, yet 
corresponds to the next integral temperature below -30° C. 


no 





Table 42. Thermistor Lookup Conversion Table. 


Ill 



















































































































































































































APPENDIX H. SPACECRAFT COMMAND ENCODING 


This appendix gives the command encoding details. 


ByteJO] 

BMllSB^Br4J 

0x05 

Address 


Table 43. Execute Command. 


Byte(0| 

ByteUI -Byte[4j 



OxOA 

Address 

Count 

(0^ 

256) 

Code/data 


Table 44. Load Command. 


BytelOl? 

m 

JBytelSI 

Bytelfi] r 
ByteI91 ; 

BjteHOl 

■ 

Byte(256J- 
B3tci259F; ' 

Byte|2^}' 

' ■ 'f'i 

0x5A 

Address 

Size 

(0=i>256) 

Address 

Size 

(0=>256) 

■ 

Address 

Size 

(0=>256) 


Table 45. Map Command. 


Bytte(0] 


OxFF 

OxAA, 0x55, OxFF 


Table 46. Reset Command. 


mm 

0x00 

Table 47. Status Command. 


BytelO] 

OxAA 


Table 48. Verify Load Command. 


113 








































APPENDIX I. SOFTWARE GENERATION FACILITIES 


This appendix contains the software generation facilities for the ROM Boot Loader embedded 
software for the System Controller, 


A PC compatible workstation using standard software generation tools creates the PANSAT Boot 
ROM software. The Microsoft C Compiler version 5.0 and the Microsoft Macro Assembler version 5.10 
translate the software source code into object modules. The Make facility included with these code 
generators provides an automated method for generating the ROM image. Systems And Software, Xlink86 
version 6.10e links all of the object modules into a relocatable code image. Systems And Software Xloc86 
version 6.10 translates the relocatable image into absolute address code and data. Finally, Systems And 
Software PROM86 version 6.0a prepares a binary image suitable for the ROM. The makefile, named 
dcs.mak and shown below, is responsible for identifying all the source modules and their dependencies 
which are required to build the entire ROM image for the embedded software. 


#####################################################################^######## 

# 

# DCS.MAK 

# 

# 

# Date Who What 

^ -- -{- - 

# 25 March 1996 Jah Creation 

# 


############################################################################## 

# 

# Compiler and Assembler options 

# 

############################################################################## 

#MAKEDIR-. 


# 


# Compiler options: 

/c 

no linking 

# 

/AS 

small model (64k code, 64k data) 

# 

/Zp 

pack structures on n boundary 

# 

/Gs 

no stack checking 

# 

/Od 

no optimizations 

# 

/Oi 

enable intrinsic functions 

# 

/FPa 

FP calls with altmath library 

# 

/G1 

use 80186 instructions 


115 




# /Zi add symbolic debugging information 

CFLAGS = /c /AS /Zpl /Gs /Od /Oi /FPa /G1 /Zi 

# 

# Assembler optionsVMx case-sensitive identifiers 

# /Zi add symbolic debugging information 

AFLAGS = /Mx/Zi 

# 

# General (common) dependencies 

# 

GENDEPS = gen_defs.h gen_apis.h 

OBJS = dcs.obj ad.obj bcm.obj clock.obj edac.obj eps.obj gen apis.obj modem.obj msu.obj\ 
pcb.obj printobj scc.obj stpi.obj terms.obj tlm.obj startup.obj 

# 

# Compilations 
if 

dcs.omf: dcs.abs 

cv2omf dcs.abs to dcs.cv 
prom86 dcs.cv to dcs.omf omf initdata 
prom86 dcs.abs to dcs.bin ad(OFOOOOh, OFFFFFh) initdata one 

# Absolute address relocated image 

dcs.abs: dcs.lnk 

xloc86 @dcs.loc 


# Linked image 
dcs.lnk: $(OBJS) 

xlink86 @dcs.lk 


# source code modules 

dcs.obj: dcs.c dcs.h pcb.h $(GEN_DEPS) 

ad.obj: ad.c ad.h pcb.h tlm.h $(GEN_DEPS) 

bcm.obj: bcm.c bcm.h ad.h clock.h pcb.h tlm.h $(GEN_DEPS) 

clock.obj: clock.c edac.h $(GEN_DEPS) 

edac.obj: edac.c edac.h $(GEN_DEPS) 

eps.obj: eps.c eps.h pcb.h $(GEN_DEPS) 

gen_apis.obj: gen_apis.c gen_apis.h $(GEN_DEPS) 

#int.obj: int.c int.h $(GEN_DEPS) 


116 


modem.obj: modem.c modem.h $(GEN_DEPS) 

msu.obj: msu.c msu.h pcb.h $(GEN_DEPS) 

pcb.obj: pcb.c pcb.h $(GEN_DEPS) 

print.obj: print.c print.h $(GEN_DEPS) 

#rf.obj: rf.c rf.h pcb.h $(GEN_DEPS) 

scc.obj: scc.c scc.h $(GEN_DEPS) 

#scenario.obj: scenario.c scenario.h $(GEN_DEPS) 
#spacket.obj: spacket.c spacket.h scc.h $(GEN_DEPS) 
stpi.obj: stpi.c stpi.h print.h thn.h $(GEN_DEPS) 

terms.obj: terms.c terms.h $(GEN_DEPS) 

tlm.obj: tlm.c tlm.h ad.h bcm.h pcb.h $(GEN_DEPS) 

startup.obj: startup.asm 


117 



All of the modules are linked together by XLINK86 which uses a file named dcs.lk (shown below) to 
identify each module. 


startup.obj, dcs.obj, ad.obj, bcm.obj, clock.obj, edac.obj, eps.obj, gen_apis.obj, modem.obj, msu.obj, 
pcb.obj, print.obj, scc.obj, stpi.obj, terms.obj, tlm.obj, & 
slibca.ssi& 
to dcs.lnk 

Finally, the linked ROM image needs to have all address relocated to absolute addresses 
corresponding to the location of the ROM in the embedded system. This process is called loading, and is 
performed by the program XLOC86 which uses the file dcs.loc (shown below) to describe the relocation 
needed. 


dcs.lnk to dcs.abs & 

NOINITCODE & 

ORDER(CS(& 

FAR_DATA_BEG, FAR DATA, FAR_DATA_END,& 
FAR_BSS_BEG, FAR_BSS, FAR_BSS_END,& 
HUGE_BSS_BEG, HUGE_BSS, HUGE_BSS_END,& 
DATA_BEG, DATA, CONST, MSG, DATA_END, & 
BSS, BSS_END,& 

STACK,& 

CODE, CODE_END,& 

BOOTSTRAP))& 

ADDRESSES(CS(FAR_DATA_BEG(0400H),CODE(0F0000h))) 


118 


APPENDIX J. SOFTWARE SOURCE CODE 


This appendix contains the software source code for the ROM Boot Loader software for the System 
Controller. The following source code files are included: 


Module ;(filena;in 

.bescriptioo:'- . 


ad.h, ad.c 

A/D converter ISR and support routines. 

120 - 129 

bcm.h, bcm.c 

Battery control monitor. 

130 - 146 

clock.h, clock.c 

Clock. 

147 - 148 

cmd.h, cmd.c 

Command interpreter. 

149-151 

dcs.h, dcs.c 

main() and master loop for ROM boot loader. 

152-155 

edac.h, edac.c 

EDAC ISR and RAM wash. 

156-158 

eps.h, eps.c 

EPS support routines 

159-164 

genapis.ch genapis.c 

General (common) subroutines used by other modules. 

165 - 167 

gendefs.h 

General #defmes, typedefs, and macros. 

168 - 169 

int.h, int.c 

CPU interrupt control and support. 

170 - 170 

modem.h, modem.c 

Modem (PA-100) support routines. 

171 - 176 

msu.h, msu.c 

Mass storage support routines. 

177 - 192 

pcb.h, pcb.c 

PCB support routines. 

193 - 197 

printh, printx 

Display support for STPI: printf()-like facilities. 

198-204 

rf.h, rf.c 

RF support routines. 

205 - 207 

scc.h, scc.c 

see support routines. 

208 - 217 

scenario.h, scenariox 

Scenario (alternate hw/sf) support routines. 

218-218 

spacket.h, spacketx 

Synchrounous packet protocol support routines. 

219-219 

startup.asm 

Startup (80186 assembler) module. 

220 - 240 

stpi.h, stpi.c 

Spacecraft test port interface (RS-232) support routines. 

241 - 273 

terms.h, termsx 

Terminal emulation support for STPI. 

274 - 276 

tlm.h, tim.c 

Telemetry management support routines. 

277 - 283 


119 

















































































ad.h ad.c 

/***±*ic******ifkit*ir***ieir**irit********ir**-k*iHc****it****ir1e***ie****1tiricit*1c*ic*1t***1t**1f 

* 

* AD.H 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 

* 

* Date Who What 

* - + - + -- - 

* 15 April 1996 Jah Creation 

* 25 Feb 1997 Jah ROM version: reflects EPS port changes 

* 

★*********♦*****************************♦***********************************/ 


/* Approximate time for a A/D Set to be aquired. This is the approximate 
* difference in time between successive current readings to the batteries- 
*/ 

#define AD_DELTA_T 1 

#define AD_RES ((double)(5.0/4095.0)) 


#ifdef AD 


#define 

AD_ 

BASE 

0x80 



#define 

AD_ 

_INSTR0 

AD_BASE 



#define 

AD~ 

'iNSTRl 

AD_BASE 

+ 

2 

#define 

AD~ 

’lNSTR2 

AD_BASE 

+ 

4 

#define 

AD_ 

INSTR3 

AD_BASE 

+ 

6 

#define 

AD_ 

_INSTR4 

AD_BASE 

+ 

8 

#define 

AD_ 

_INSTR5 

AD_BASE 

+ 

OxOA 

#define 

ad" 

[ 1 NSTR 6 

AD_BASE 

+ 

OxOC 

#define 

AD_ 

[ 1 NSTR 7 

AD_BASE 

+ 

OxOE 

#define 

AD_ 

_CONFIG 

AD_BASE 

+ 

0x10 

#define 

AD_ 

_IER 

AD_BASE 

+ 

0X12 

#define 

ad' 

’iSR 

AD_BASE 

+ 

0x14 

#define 

AD~ 

TIMER AD_ 

BASE + 0x16 


#define 

AD^ 

FIFO 

AD__BASE 

+ 

0x18 

#define 

AD 

LIMIT AD 

BASE + OxlA 



/* Masks */ 

#define RAMOO 0x0000 
#define RAMOl 0x0100 
ftdefine RAM02 0x0200 


/* Define the A/D schedule for readings. 

* The schedule is organized into periods. For startup, there are 

* 54 periods, number 0-53. Each period uses between one and 5 

* inputs on the A/D. A/D INO is the DCS temperature sensor, 

* A/D INI is the Modem temperature sensor, A/D IN2 is the EPS, 

* A/D IN4 is the TMUXA, and A/D IN6 is the TMUXB. 

* 

* Since the EPS contains the current sensors for the batteries and 

* the spacecraft bus (total solar panel current input), and these 

* signals must be read frequently for accurate current integration 

* and quick eclipse sensing, the schedule repeats these readings, 

* interleaving them with other readings. Each interleaving set 

* is called a Set, numbered from 0 to 13. There are normally 


* three 

*/ 

(3) cycles 

per set. 



#define 

NUM_INPUTS 

5 



#define 

NUM_PERIODS 

42 



#define 

NUM_STEPS 

14 



#define 

NtJM_INSTRS 

5 


/* Maximum Sequencer instructions */ 

#define 

NO_PCB 

((unsigned char)OxFF) 

/* 

indicates no PCB required for 





* reading; but a reading is needed. 

* / 

#define 

NO_READ 

((unsigned char)OxFE) 

/* 

/ 

perform no reading on the A/D 


* channel for a given period. 

V 


/* EPS Setup requires potentially more than one Port 1/2/3 writing 


120 






* depending on the sensor. This table is per period and shows 

* for a given period, which port(s) need written to. Also, this 

* table indicates if the Current Inhibit Switch needs to be 

* disabled, i.e. current reading will be made. 

*/ 

#define NOT_USED ((unsigned char) OxFF) /* indicates port is not used */ 


#define NO_CUR 
#define CURRENT 
tdefine CUR DIR 


((unsigned char)0x00) 
( (unsigned char)0x01) 
( (unsigned char)0x02) 


/* not a current measurement */ 

/* current: solar bus, solar panels */ 
/* current w/ directiont */ 


tdefine N0_INSTR ((unsigned int)OxFFFF) /* instruction not used */ 


/* This structure describes to the ad_collect() function how to save A/D 
* samples into the correct categories and positions within those categories. 

*/ 


typedef struct ad_collect_j)arams 

{ 

unsigned char type,- 

unsigned char position; 


ad_collect jparams_struct ; 


/* Sensor types, used by 
tdefine THERMISTOR 
tdefine TEMP_SENSOR 
tdefine V_BATTA 
tdefine V_BATTB 
tdefine V_BUS 
tdefine I_BATTA 
tdefine I_BATTB 
tdefine I_BUS 
tdefine I SOLAR 


ad_collect() and ad_collect_params() */ 
((unsigned char)0) 

((unsigned char)1) 

((unsigned char)2) 

((unsigned char)3) 

((unsigned char)4) 

((unsigned char)5) 

((unsigned char)6) 

((unsigned char)7) 

((unsigned char)8) 


/* AD Error Flags */ 
tdefine AD_WAIT 5000 

tdefine AD_NO_ERROR 0 

tdefine AD_RESET__ERROR 1 

tdefine AD_FIFO_COUNT_ERROR 2 
tdefine AD CALIB WAIT ERROR 3 


void ad_coliect(void); 

void ad_init(void); 

void interrupt far ad_isr{); 


tendif 



tifndef AD 

extern 

int 

samples_ready; 

extern 

int 

ad_flag; 

extern 

void 

ad_collect(void) 

extern 

void 

ad_init(void); 

extern 

tendif 

void interrupt 

far ad_isr 0 ; 


121 





* AD.C 

* 

* Petite Amateur Navy Satellite (PANSAT) . 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* Date Who What 


* 24 April 1996 Jah Creation 

* 25 Feb 1997 Jah ROM version includes new EPS port assignments. 

* 

****** *********ifk***ic**ifk***-k***ir**iiiHr***-k*it*-k**1,*1t*****i(*****-k-k*****itir*****/ 

#include 

#define 
tinclude 
#undef 

#include 
#include 
tinclude 
tinclude 
tinclude 


static WORD 
static WORD 
static int 

int samples__ready = FALSE; 

int ad_flag = AD_NO_ERROR; 


”gen_defs.h" 
AD 

"ad.h" 

AD 

"bcm.h" 

" clock.h" 

"eps.h" 

"pcb.h" 

"tlm.h” 


period = 0; 

ad_values [NUM_PERIODS] [NUM_INPUTS] , 
negative_current [NUM_PERIODS] ; 


/* Schedule of PCB Commands for EPS reading */ 
static const BYTE ad_sch_eps[NUM PERIODS] [3] = 
{ 


/* Current? 

/* Set 0 */ 

Port 3 

Port 1 */ 


{CURRENT, 

(BYTE)0x80, 

(BYTE)0x30) 

, /* ISC */ 

{no_cur, 

NOT_USED, 

(BYTE)0x70), /* 

AO */ 

{NO_CUR, 

NOT_USED, 

(BYTE)0x90), /* 

A1 */ 

/* Set 1 */ 

{CUR_DIR, 

(BYTE)0x90, 

(BYTE)0x30} 

, /* lA */ 

{NO_CUR, 

NOT^USED, 

(ByTE)OxFl}, /* 

A2 */ 

{NO_CUR, 

NOT__USED, 

(BYTE)0xF3}, /* 

A3 */ 

/* Set 2 */ 

{CUR_DIR, 

(BYTE) OxAO, 

(BYTE)0x30} 

, /* IB */ 

{NO_CUR, 

NOT_USED, 

(BYTE)0xF5}, /* 

A4 */ 

{NO_CUR, 

(BYTE)0x01, 

(BYTE)0x10}, /* 

A5 */ 

/* Set 3 */ 

{CURRENT, 

(BYTE)0x80, 

(BYTE)0x30} 

, /* ISC */ 

{NO_CUR, 

(BYTE)0x03, 

(BYTE)0x10}, /* 

A6 */ 

{no_cur, 

(BYTE)0x05, 

(BYTE)0x10}, /* 

A7 */ 

/* (Set 4) */ 

{CUR_DIR, 

(BYTE)0x90, 

(BYTE)0x30} 

, /* lA */ 

{NO_CUR, 

(BYTE)0x07, 

(BYTE)0x10}, /* 

A8 */ 

{NO_CUR, 

NOT_USED, 

(BYTE)OxBO}, /* 

BO */ 

/* (Set 5) •/ 

{CUR_DIR, 

(BYTE)OxAO, 

(BYTE)0x30} 

, /* IB */ 

{NO_CUR, 

NOT_USED, 

(BYTE)OxDO}, /* 

B1 */ 

{no_cur. 

NOT^USED. 

(BYTE)0xF7}, /♦ 

B2 */ 

/* Set 6 */ 

{current, 

(BYTE)0x80, 

(BYTE)0x30} 

, /* ISC ♦/ 

{no_cur. 

NOT_USED, 

(BYTE)0xF9}, /* 

B3 */ 

{no_cur. 

NOT_USED, 

(BYTE)OxFB}, /* 

B4 */ 

/* Set 7 */ 

{cur_dir, 

(BYTE)0x90, 

(BYTE)0x30} 

, /* lA */ 

{no_cur, 

(BYTE)0x09, 

(BYTE)OxlO}, /* 

B5 */ 


122 





{N0_CUR, 


(BYTE)OxOB, 

(BYTE)OxlO}, /♦ B6 */ 

/* Set 8 
{CUR_DIR, 
{N0_CUR, 
{N0_CUR, 

*/ 

(BYTE)OxAO, 
(BYTE)OxOD, 

(BYTE)0x0F, 

(BYTE)0x30}, /* IB */ 
(BYTE)0x10}, /* B7 */ 

(BYTE)0x10}, /* B8 */ 

/* Set 9 
{CURRENT, 

{no_cur, 

{CURRENT, 

*/ 

(BYTE)0x80, 
NOT_USED, 

(BYTE)0x00, 

(BYTE)0x30), /* ISC */ 
(BYTE)OxFD}, /* VSC */ 

(BYTE)0x50), /* SPO */ 

/* Set 10 
{CUR_DIR, 
{CURRENT, 
{CURRENT, 

*/ 

(BYTE)0x90, 
(BYTE)0x10, 
(BYTE)0x20, 

(BYTE)0x30), /* lA */ 
(BYTE)0x50}, /* SPl */ 
(BYTE)0x50}, /* SP2 */ 

/* Set 11 
{CUR_DIR, 
{CURRENT, 
{CURRENT, 

*/ 

(BYTE)OxAO, 
(BYTE)0x30, 
(BYTE)0x40, 

(BYTE)0x30}, /* IB */ 
(BYTE)0x50}, /* SP3 */ 
(BYTE)0x50}, /* SP4 */ 

/* Set 12 
{CURRENT, 
{CURRENT, 
{CURRENT, 

*/ 

(BYTE)0x80, 
(BYTE)0x50, 
(BYTE)0x60, 

(BYTE)0x30}, /* ISC */ 
(BYTE)0x50}, /* SP5 */ 
(BYTE)0x50}, /* SP6 */ 

{CUR__DIR, 

{CUR_DIR, 

{CURRENT, 


(BYTE)0x90, 
(BYTE)OxAO, 
(BYTE)0x70, 

(BYTE)0x30}, /* lA */ 
(BYTE)0x30}, /* IB */ 
(BYTE)0x50}, /* SP7 */ 


}; 


/* Describe how to take the raw samples and organize them by types into 

* the correct sensor type arrays. This is for the EPS readings only. 

* The other channels are easy to categorize based on the period number 

* {e.g. periods 0-31 have TMUX readings, period 0 has DCS & Modem 

* temperature readings). 

*/ 

static const ad_collect_params_struct ad_collect_table[NUM_PERIODS] = 

{ 

/* Period 0, Set 0 */ 

{I_BUS, 0}, 

{V_BATTA, 0}, 

{V_BATTA, 1}, 

/* Period 3, Set 1*/ 

{I_BATTA, 0}, 

{V_BATTA, 2}, 

{V_BATTA, 3}, 

/* Period 6, Set 2 */ 

{I_BATTB, 0}, 

{V_BATTA, 4}, 

{V_BATTA, 5}, 

/* Period 9, Set 3 */ 

{I_BUS, l}, 

{V_BATTA, 6}, 

{V_BATTA, 7}, 

/* Period 12, Set 4 */ 

{I_BATTA, 1}, 

{V_BATTA, 8}, 

{V_BATTB, 0}, 

/* Period 15, Set 5 */ 

{I_BATTB, l}, 

{V_BATTB, l}, 

(V__BATTB, 2}, 

/* Period 18, Set 6 */ 

{I_BUS, 2}, 

{V_BATTB, 3}, 

{V_BATTB, 4), 

/* Period 21, Set 7 */ 

{I_BATTA, 2}, 

{V_BATTB, 5}, 

{V_BATTB, 6}, 

/* Period 24, Set 8 */ 

{I_BATTB, 2}, 

123 



{V_BATTB, 7}, 

{V_BATTB, 8}, 

/* Period 27, Set 9 */ 
{I_BUS, 3), 

{V_BUS, oj, 

{l_SOLAR, 0}, 

/* Period 30, Set 10 */ 
{l_BATTA, 3}, 

{l_SOLAR, 1}, 

{l_SOLAR, 2}, 

/* Period 33, Set 11 */ 
{I_BATTB, 3}, 

{l_SOLAR, 3}, 

{l_SOLAR, 4}, 

/* Period 36, Set 12 */ 
{I_BUS, 4}, 

{l_SOLAR, 5}, 

{l_SOLAR, 6}, 


/* Period 39, Set 13 */ 
{I_BATTA, 4), 

{I_BATTB, 4), 

{l_SOLAR, 7}, 


/********it**1t********ie**ic-k*i[-»i*it***ie1fkir***ifk1fk************-k-k**ir****-k*ir*-k*ic-k*ir*-k 

* 

* voidad_init 0 

* 

* Initialize the A/D, Recalibrate. Setup first (period:=0) program. 

* Set Sequencer Timer {delay before acquisitoin) to 10 msec. 

* 

***********************itifkit** 1 e 1 eie**** 1 e* 1 eir*ic******i(****iritie***irit*ieitifk*****ic****^ 


voidad_init (void) 

{ 

int i ; 

int x; 

WORD temp; 


/* Turn on the TMUXes to allow 
eps_set_power {PWR_TMUXA, ON) ; 
pcb_write (TMUXA, 0, 0x10); 
eps_set_power {PWR_TMUXB, ON) ; 
pcb_write(TMUXB, 0, 0x10); 


temperature sensing */ 
/* select channel 0 
/* select channel 0 


(calibration resistor) 
(calibration resistor) 


*/ 

*/ 


/* Zero out values because no A/D has yet occurred (or forcing reset) */ 
for (i = 0; i < NUM_PERIODS; i++) 

{ 

negative_current[i] = 0; 
ad_values[i](0] = 0; 
ad_values[i] [1] = 0; 

} 

period =0; /* index into ad_sch[][] */ 


/* Setup MUXes A/B for first temperature sensors (Calibration resistors) */ 
pcbw_m(TMUXA0, 0, 0x10) 
pcbw_m(TMUXB0, 0, 0x10) 

/* Setup EPS for first reading */ 

pcbw_m(EPS0, 3, (ad_sch_eps[0] [1])) /* EPS Port 3 */ 

pcbw_m{EPS0, 1, (ad_sch_eps[0] [2])) /* EPS Port 1 */ 

eps_set_port2(eps_get_port2()); 

outpw(AD_C0NFIG, 0x0002); /* Reset the A/D */ 

/* Wait for RESET bit to clear */ 

for (x = 0; (x < AD_WAIT) && (inpw (AD^CONFIG) & 0x0002); x++) 

if (x == AD__WAIT) 

{ 

ad_flag = AD_RESET_ERROR ; 
return; 

) 


124 


outpw(AD_CONFIG, 0x0008); /* Full Calibration */ 

/* Wait for CALIBRATION bit to clear */ 

for {x = 0; (x < AD_WAIT) && (inpw(AD_CONFIG) & 0x0008); x++) 

if (x == AD_WAIT) 

{ 

ad_flag = AD_CALIB_WAIT_ERROR; 
return; 

} 

outpw{AD_CONFIG, 0x0000); /* stop the sequencer and point to RAM 00 */ 

/* Program A/D Sequencer: based on schedule for period 0 */ 

OUtpw(AD_INSTR0, 0xF208); /* EPS */ 

OUtpw{AD_INSTRl, 0xF208); /* EPS */ 

OUtpw(AD_INSTR2, 0xF210); /* TMUX A */ 

OUtpw{AD_INSTR3, 0xF218); /* TMUX B */ 

OUtpw(AD_INSTR4, 0XF200); /* DCS */ 

OUtpw(AD_INSTR5, 0xF204); /* Modem */ 

OUtpw(AD_INSTR6, 0xF202); /* Pause */ 


/* Setup A/D Timer */ 

OUtpw (AD_TIMER, 2000); 

OUtpw (AD_CONFIG, 0x0002); /* Reset the A/D ♦/ 

/* Wait for RESET bit to clear */ 

for {x = 0; (x < AD_WAIT) && {inpw(AD_CONFIG) & 0x0002); x++) 

if {x == AD_WAIT) 

{ 

ad_flag = AD_RESET_ERROR; 
return; 

} 

/* Force A/D to interrupt when 6 readings in the FIFO occur */ 

OUtpw (AD_IER, 0x3004); 

/* Clear any interrupts of the A/D by reading the status register */ 
inpw(AD_ISR); 

/* Allow IRQs from A/D LM12H458 to the CPU */ 

#define IlCON 0xFF3A 

outpwdlcON, 0x0005); /* Edge-trig., ON, priority 5 */ 

/* Start the A/D Sequencer. Interrupt will occur eventually */ 

OUtpw {AD__CONFIG, 0x0001); /* start sequencer */ 

while (samples_ready == FALSE) /* wait for end of first A/D sweep */ 
} /* End of ad_init0 */ 


* 

* void interrupt far ad_isr{) 

* 

void interrupt far ad isr() 

{ 


register int p; 
register int x; 

BYTE temp; 

static int c = 6; 


/* first A/D period has six samples to read */ 


OUtpw (AD_CONFIG, 0x0000); /* Stop sequencer, point to RAM 00 */ 

inpw(AD_ISR) ; /* this clears the interrupt */ 

p = period; /* get a register copy of the current period */ 


/***********************/ 

/* Collect A/D samples */ 

/**********<r************/ 

/* Wait for all the samples in the FIFO */ 

for (x = 0; {x < AD_WAIT) && ({(inpw(AD^ISR) & OxFSOO) » 11) < c) ; x++ 
if (x == AD_WAIT) 


125 



{ 


ad_flag = AD_FIFO_COUNT_ERROR/ 

/* Send non-specific EOI to Interrupt Controller */ 
outpw(0xFF22, 0x8000); 

return; 

} 

if (p == 0) /* 0th period has all six A/D samples */ 

inpw(AD_FIFO); /* discard - double EPS reading */ 

ad_values[0l[0] = inpw(AD_FIF0) & OxOFFF; /* EPS */ 
ad_values[0] [1] = inpw(AD_FIFO) & OxOFFF; /* TMUXA */ 

ad_valuest0][2] = inpw(AD_FIFO) & OxOFFF; /* TMUXB */ 

ad_values[0] [3] - inpw(AD_FIFO) & OxOFFF; /* DCS */ 
ad~values[0] [41 = inpw(AD_FIFO) & OxOFFF; /* Modem */ 

} 

else if (p < 32) /* 1st - 31st periods have 4 A/D samples */ 

{ 

inpw(AD_FIFO}; /* discard - double EPS reading */ 

ad_values[p][0] = inpw(AD_FIFO) & OxOFFF; /* EPS */ 
ad_values [p] [1] = inpw {AD_FIFO) & OxOFFF; /* TMUXA */ 

ad_values[p] [2] = inpw (AD_FIFO) & OxOFFF; /* TMUXB */ 

} 

else /* remaining periods have only 2 A/D sample */ 

{ 

inpw(AD_FIFO); /* discard - double EPS reading */ 

ad_values [p] [0] = inpw (AD_FIFO) & OxOFFF; /*.EPS */ , 

} 

/***********************************/ 

/* Check Current Direction Sensing */ 
/*♦★********************************/ 

/* Was there a battery current reading in EPS ? */ 
if (ad_sch_eps[p][0] == CUR_DIR) 

{ 

/* Read the direction. */ 

pcbr_m(EPSl, 1, temp) /* Port 5 of the EPS */ 

/* Was it Battery A or B ? */ 

if {ad_sch_eps[p] [1] == 0x90) /* Port 3 tells MUX selection */ 
negative_current[pi = (temp & 0x01) ? FALSE : TRUE; 

else 

negative_current[p] * (temp & 0x02) ? FALSE : TRUE; 

} 

/*♦**♦**♦***********★*******★******/ 

/* Setup via PCB for new readings */ 
/*♦**♦**************************★**/ 

/* Has a complete set of data been read? Ready to start over? */ 
P++; 

if (p >= NUM_PERIODS) 

{ 

p = 0; 

samples_ready = TRUE; 

} 

period = p; 


/* PCB commands for the MUXes */ 
if (p < 32) 

{ 

pcbw_m(TMUXAO, 0, 0x10+p) 
pcbw_m(TMUXB0, 0, 0x10+p) 

} 

/* PCB commands for the EPS */ 

if (ad_sch_eps[pi[1] != NOT_USED) /* Program EPS Port 3 ? */ 

{ 

pcbw_m(EPS0, 3, ad_sch_eps[pi [ll) 

) 

/* There is always something sent to EPS Port 1 */ 
pcbw_m(EPS0, 1, ad_sch_eps[p] [21) 




126 





/* Setup A/D for new readings */ 

/******************************/ 


outpw(AD_CONFIG, 0x0002); /* RESET, point to RAM 00 */ 

/* Wait for RESET bit to clear */ 

for (x = 0; (x < AD_WAIT) && (inpw(AD_CONFIG) & 0x0002); x++) 

if {x == AD_WAIT) 

{ 

ad_flag = AD_RESET_ERROR; 

/* Send non-specific EOI to Interrupt Controller */ 

outpw(0xFF22, 0x8000); 

return; 

} 


if (p == 0) 
{ 


outpw(AD_INSTR0, 

0xF208) 

/* 

outpw(AD_INSTR1, 

0xF208) 

/* 

outpw(AD_INSTR2, 

0XF210) 

/* 

outpw(AD_INSTR3, 

0XF218) 

/* 

outpw(AD_INSTR4, 

0XF200) 

/* 

outpw(AD_INSTR5, 

0XF204) 

/* 

outpw(AD_INSTR6, 

0XF202) 

/* 

outpw(AD_IER, 0x3004); 
c = 6; 


if (p < 32) 

outpw(AD_INSTR0, 

0XF208) 

/* 

outpw(AD_INSTR1, 

0XF208) 

/* 

outpw(AD_INSTR2, 

0XF210) 

/* 

outpw(AD_INSTR3, 

0XF218) 

/* 

outpw(AD_INSTR4, 

0XF202) 

/* 

outpw(AD_IER, 0x2004); 
c = 4; 



} 

else 

{ 


outpw(AD_INSTR0, 0xF2 08); 

/* 

outpw(AD_INSTR1, 0xF2 08) ; 

/* 

outpw(AD_INSTR2, 0xF2 02) ; 

/* 

outpw(AD_IER, 0x1004); 



C = 2; 


} 


EPS */ 

EPS */ 

TMUX A */ 

TMUX B */ 

DCS */ 

Modem */ 

Pause */ 

/* interrupt w/ 6 samples in FIFO */ 


EPS */ 

EPS */ 

TMUX A */ 

TMUX B */ 

Pause */ 

/* interrupt w/ 4 samples in FIFO */ 


EPS */ 

EPS */ 

Pause */ 

/* interrupt w/ 2 sample in FIFO */ 


outpw(AD_CONFIG, 0x0008); /* Full Calibration */ 

/* Wait for CALIBRATION bit to clear */ 

for (X = 0; {x < AD_WAIT) && (inpw(AD_CONFIG) & 0x0008); x++) 

if (x == AD_WAIT) 

{ 

ad_flag = AD_CALIB_WAIT_ERROR; 

/* Send non-specific EOI to Interrupt Controller */ 

outpw(0xFF2 2, 0x8000); 

return; 

} 


outpw(AD_C0NFIG, 0x0001); /* start sequencer */ 

/* Send non-specific EOI to Interrupt Controller */ 
outpw(0xFF2 2, 0x8000); 

} /* End of ad_isr() */ 

/***************************************************************************** 

* 

* void ad_check() 

♦ 

* Check ad_flag for error condition. 

* 

*-k**-k*1t*it1r******ir1t1t**it******ic*ifk*ifk**1c*******-k********-k*-k***1c*******it**it**ir*/ 


void ad_check(void) 
{ 


static 

int 

reset_ 

_count = 0; 

static 

int 

fifo_count = 0; 

static 

int 

calib_ 

_count = 0; 

DWORD 


reset 

time = OL 


127 






DWORD fifo__time = OL; 
DWORD calib_time = OL; 
DWORD t; 


t = get_elapsed_time{); 
switch(ad_flag) 

{ 

case AD_NO_ERROR: 
break; 

case AD_RESET_ERROR: 

/* This is a bad problem with no real fix. try initializing again. */ 
if ((++reset_count > 10) && (t - calib_time < ONE_MINUTE)) 

{ 

/* Force a shutdown */ 

} 

ad_init() ; 
break; 

case AD_FIFO_COUNT_ERROR: 

/* There was a count error trying to access the FIFO in ad_isr(). 

* Try initializing the A/D again and try acquisition. 

*/ 

if ({++fifo_count > 10) && (t - calib_time < ONE_MINUTE)) 

{ 

/* Force a shutdown */ 

) 

ad_init() ; 
break; 

case AD_CALIB_WAIT_ERROR: 

/* This occurs only within ad_init{) . It is a bad problem with no 

* real fix. 

*/ 

/* Force a shutdown */ 
break; 

default: 
break; 

} 

ad_flag = AD_NO_ERROR; 

} /* End of ad_check() */ 


/***************************************************************************** 

* 

* void ad_collect{) 

•k 

* Take all raw sensor readings from the last entire round of A/D collecting 

* and organize into the telemetry structure within the .sensors structure. 

* 

* This organization takes data collected in sequence from the A/D ISR, and 

* places it into the .sensors structure which is organized per sensor type. 

* 

* This is simplified by using ad_collect_table [] which has an entry for 

* every A/D acquisition that took place in the last A/D sweep. 

* 

******************************************************************it*********/ 


void ad_collect(void) 

{ 

int i ; 
int pos; 


for (i = 0; i < NUM_PERIODS; i++) 

{ 

if (i == 0) 

{ 

/* DCS & Modem Temps, EPS, TMUXA, and TMUXB readings are available */ 
tlm.sensors.tmp[0] - ad_values[0][3]; 
tlm.sensors.tmp[1] = ad_values[0] [4l ; 

/* Read EPS below.... */ 

tlm.sensors. ts [0] = ad_values[0] II] ,- /* TMUXA */ 
tlm.sensors.ts[1] = ad_values[0] [2] ; /* TMUXB */ 

) /* End of IF (i == 0) */ 


128 


else if (i < 32) 

{ 

/* Read EPS below.... */ 

/* EPS, TMUXA, and TMUXB readings are available */ 
tlm.sensors.ts [i*2] = ad_values[i] [1]; /* TMUXA */ 

tltn. sensors .ts [ (i*2)+1] = ad_values [i] [2] ; /* TMUXB */ 

} /* End of IF (i < 32) */ 

/* All periods have an EPS reading, move it */ 
pos = ad_collect_table[i].position; 
switch{ad_collect_table[i].type) 

{ 

case V__BATTA: 

tlm.sensors.vbattalpos] = ad_values[i] [0]; 
break; 

case V_BATTB: 

tlm.sensors .vbattb [pos] = ad__values [i] [0] ; 
break; 

case V_BUS: 

tlm.sensors.vscbus = ad_values[i] [0]; 
break; 

case I_BATTA: 

tlm.sensors.ibatta[pos] = ad_values [i] [0]; 
if (negative_current[i]) 

tlm.sensors.ibatta[pos] |= 0x8000; 
break; 

case I_BATTB: 

tlm.sensors.ibattb[pos] = ad_values [i] [0]; 
if (negative_current[i]) 

tlm.sensors.ibattb[pos] |= 0x8000; 
break; 

case I_BUS: 

tlm.sensors.iscbus [pos] = ad_values[i] [0]; 
break; 

case I_SOIiAR: 

tlm.sensors.isolar[pos] = ad_values[i] [0]; 
break; 

default: /* ERROR */ 
i++; 
i--; 
break; 

} /* End of SWITCH {ad_collect_table[i].type) */ 

} /* End of FOR */ 

samples_ready = FALSE; /* flagged by ad_main_isr () - waiting for next A/D */ 

} /* End of ad_collect() */ 

End of ad.h ad.c 


129 



bcm.h bcm.c 






* BCM.H 


* Battery Charge Monitor for Pansat 


* Petite Amateur Navy Satellite (PANSAT). 

* Embedded. ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* Date 


Who What 


* 29 Jan 1997 Jah Creation 

* 


#define BCM_V_TH_STEPS 5 

#define BCM__NUM_BATS 2 
#define BCM NUM CELLS 9 


/* # of looksups in the voltage threshold (vs. 
* temperature) lookup table 
V 

/* # of batteries */ 

/* cells/battery */ 


#define BCM_NUM__MODES 3 


/* Low, Standby, and Normal operation modes */ 


/* Power Use Modes determined by charge states of the batteries */ 
#define BCM_MODE_LOW 0 

#define BCM_MODE_STANDBY 1 
#define BCM__MODE NORMAL 2 


/* Values to define the battery which is online and target (charging). */ 
ttdefine BAT__A 0 

#define BAT_B 1 

#define BAT_NONE 2 

/* Battery Controls */ 

#define CTRL_TRICKLE 0x01 
#define CTRL_ONLINE 0x02 

#define CTRL_DISCHARGE 0x04 
#define CTRL_CHARGE 0x08 

/* Operational modes, depending on state of batteries */ 

#define MODE_LOW BCM_MODE_LOW 

#define MODE_STANDBY BCM_MODE_STANDBY 
#define MODE_NORMAL BCM MODE NORMAL 


/♦ This structure holds all of the BCM variables which includes all of the 

* charge state history variables as well as variables which are used to 

* make decisions within the BCM. 

* 

* The following structure is used by other modules to access the BCM states 

* by using the void bcm_info(bcm_info_struct *info) function. 

*/ 

typedef struct bcm_info 

{ 


int 

count tBCM_NUM__BATS] 


float 

cap tBCM_NUM_BATS] ; 


int 

online; 


int 

target; 


int 

mode ; 


int 

dod_detect; 


int 

eclipse; 


unsigned 

long inttimer; 


int 

online_switch; 


WORD 

control[BCM_NUM_BATS] ; 


/* reconfigurable variables which affect 

charging 

float 

dod[BCM_NUM_BATS); 


float 

temp_max; 


int 

count_max; 


float 

over_int; 


float 

cap_max[BCM_NUM_BATS] ; 


float 

efficiencytBCM_NUM_BATS]; 


float 

v_threshold(BCM_NUM_BATS][BCM_V_ 

TH_STEPS] 


130 





float 


vth_low[BCM_NUM_BATS]; 
unsigned long intover_times[BCM_NUM_MODES]/ 

} bcm_inf o_st 2 ruct ; 

/* This structure holds all of the BCM variables which can be modified by other 

* modules when it is desired to change the parameters of the BCM. 

* 

* The following structure is used in conjunction with the BCM function named 

* bcm__setjparams {bcm_params_struct *params) . 

*/ 

typedef struct bcm_params 

{ 

int dod[BCM_NUM_BATS]; 

float temp_dt; 

float t emp_max; 

int count_max; 

float over_int; 

f 1 oat cap_max [BCM_NtJM_BATS 3 ; 

float efficiency [BCM_NUM_BATS3 ; 

float v_threshold[BCM_NUM_BATS] [BCM_V_TH_STEPS] ; 

float vth_low[BCM_NUM_BATS]; 

unsigned long intoveretimes[BCM_NUM_MODES] ; 

} bcm_params_struct ; 


/* Include specifics for BCM.C */ 

#ifdef BCM 

/* Redefine shorthands for BCM routines */ 
#def ine NUM_BATS BCM_NUM_BATS 
#define V_TH_STEPS BCM_V_TH_STEPS 

#define NtJM_MODESBCM_NUM_MODES 
#define NUM_CELLS BCM_NUM_CELLS 

#define NUM CELL TEMPS 10 


/* Charge state history */ 

#define CS_BAD -3 

#define CS_UNKNOWN -2 

#define CS_FORCE_OVER -1 

#define CS_OVERCHARGED 0 

/* positive charge state values are counts (the # of re-charge cycles on a battery */ 
/* Initial parameters */ 

#define DOD 0.40/* Depth of Discharge {% BELOW 100%) */ 

#define TEMP_LOW 5.0 /* Minimum temperature before heating batteries */ 

#define TEMP_MAX 35.00 /* Maximum temperature for charging */ 

#define COUNT__MAX 5 /* # of REcharges before OVERcharge */ 

#define OVER_INTEGRATE 1.20/* OVER Current integration allowed 

* (safety check) before stop charging */ 

#define CAP_A 4.40/* Battery A A*hr capacity */ 

#define CAP_B 4.40/* Battery B A*hr capacity */ 

#define EFF_A 0.83/* Battery A Efficiency */ 

#define EFF_B 0.83/* Battery B Efficiency */ 

/* Timers (in second®) for overcharge checking */ 

#define TIMER_LOW (2.5L * SECS_PER_HOUR) 

#define TIMER_STANDBy (3.5L * SECS_PER_HOUR) 

#define TIMEF^NORMAL (4.5L * SECS_PER_HOUR) 

#define TRICKLETIME FIVE^MINUTES 

/* This is the time Bet on target_time[] to indicate that a battery has not 
* been charged yet. 

*/ 

#define MAX_TARGErr_TIME { (unsigned long int) 4294967296) 


#define VTH_LOW BATA 1.20/* Undervoltage threshold to trigger overcharge */ 
#define VTH_LOW_BATB 1.20 

/* Low cell voltages that trigger battery preference decisions */ 

#define VLOW 0.90/* Minimum cell voltage for ’’healthy'' battery */ 

#define VMAX^LOW 1.10/* Minimum Maximum cell voltage for charged battery */ 

static void bcm_charge(void); 

static int bcm_check_conditions(void) ; 

static void bcm_mode(void); 

static int bcm_in_eclipse(void); 


131 



Static 

void 

static 

void 

static 

void 

static 

void 

static 

int 

static 

void 

static 

int 

static 

void 

static 

float 

static 

float 

void 



bcm_online (int preferred); 
bcm_overcharge(void); 
bcm_recharge(void) ; 
bcin__set_paraTns (bcm_params_struct 
bcm_set_switches (void) ; 
bcm_target(int preferred); 
bcm_tbound(signed char t); 
bcm_v_Tnax_clear(int battery); 
bcTn__v_max_min (int battery); 
bcm_v_min(int battery); 
bcin_tlm_update (void) ; 


♦params); 


#endif 


/* Includes for all modules (except BCM.C) referencing this BCM.H */ 
#ifndef BCM 

extern int bcm__get_mode (void) ; 
extern void bcm_info(bcm_info_struct *) ; 
extern void bcm_init(void); 
extern void bcm_main(void); 

extern void bcm_set_params (bcm_params_struct *) ; 
extern void bcm_tlm_update(void); 

#endif 


* 

* BCM.C 


* Battery Charge Monitor for Pansat 

* 

* Petite Amateur Navy Satellite (PANSAT), 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School, 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* Date Who What 


* 29 Jan 1997 Jah 

* 7 Feb 1997 Jah 

* 24 March 1997 Jah 


Creation 

Remove Delta-Temperature checks in charging. 

Use get_elpased_time() instead of get_time(). 
Check for trickle charge time for both batteries. 






#include <stdio.h> 
#include <stdlib.h> 

#include ”gen_defs.h” 


#include "clock.h" 
#include "pcb.h" 

#define BCM 

#include "bcm.h" 
#undef BCM 

#include "ad.h” 
#include "dcs.h" 
tinclude "eps.h" 

#include "tlm.h" 


/* Assume unknown charge state for both batteries (i.e. dead) */ 
static int count [NUM_BATS] = {CS_UNKNOWN, CS_UNKNOWN} ; 


/* Assume no capacity for both batteries */ 
static double cap[NUM_BATS] = {O.O, 0.0}; 


static int 
static int 
static int 
static int 
static int 
static unsigned 
static int 
static WORD 


online 

target 

mode 

dod_detect 

eclipse 

long int over_timer = 
online_switch 
control[BCM_NUM_BATS] = 


= BAT_NONE; 
= BAT_NONE; 
MODE_LOW; 

= FALSE; 

= TRUE; 

OL; 

= FALSE; 

( 0 , 0 ); 


/* Time since a battery was choosen as a Target. This is originally set to 
* "infinity", so that the BCM knows that this parameter has not been used. 

132 





* otherwise, this timer indicates how long a target has been charging. 

* This varicible is only used when a battery's charget state history is 

* UNKNOWN (e.g. deployment, reset, or data corruption). 

*/ 

static DWORD target_time[NUM_BATSJ = {OL, OL}; 

static float vbatt_avg[NUM_BATS] = {O.O, O.O}; /* Battery Cell Voltage averages */ 

static signed char t_avg[NUM_BATS] = {O.O, O.O}; /* Battery Cell Temperature averages */ 

/* Record of growing Maximum cell voltages of a battery while it is charging. 

* This information is used after the battery is charged to determine if 

* the lowest maximum voltage of these cells in a battery are below an 

* acceptable value for a battery which is in good condition. 

*/ 

static float v_max_cells[NUM_BATS][NUM_CELLS] = 

{ 

{ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 }, 

{ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } 

}; 


/* reconfigurable variables which 
static float dod[NUM_BATS] 
static float temp_max 
static int count_max 

static float over_int 
static float cap__max [NUM_BATS] 
static float efficiency [NUW[_BATS] 
static float vth_low[NUM_BATS] 

#define T_LOW -5,0 
ttdefine T_HIGH 35.0 
static float v_threshold[NUM_BATS] [V_TH_STEPS] = 
{ 

{1.46, 1.46, 1.46, 1.46, 1.46}, 

{1.46, 1.46, 1.46, 1.46, 1.46} 

}; 


affect charging decisions */ 

= {DOD, DOD}; 

= TEMP_MAX; 

= COUNT_MAX; 

= OVER_INTEGRATE; 

= {CAP_A, CAP_B}; 

= {EFF_A, EFF_B}; 

= {VTH_LOW_BATA, VTH_LOW_BATB}; 


Static unsigned long int over_times [NUM_MODES] = 

{ 

TIMER_LOW, TIMER_STANDBY, TIMER_NORMAL 

}; 




* void bcm_main(void) 

* 


void bcm_main(void) 

{ 

int preferred; 


/* get new telemetry */ 
bcm_tlm_update0; 

/* Determine if in eclipse */ 
eclipse = bcm_in_eclipse(); 

/* Determine preferred battery */ 
preferred = bcm_check_conditions() ; 

bcm_online(preferred); 
bcm^target (preferred) ,- 
bcm_raode() ; 
bcm_charge() ; 

if (bcm_on) 

bcm_set_switches0; 

} /* End of bcm_main() */ 


/***************************************************************************** 
* 

* void bcm_charge (void) 

* 

* Determine if charging is to occur. 

133 





void bcm_charge(void) 


{ 


if (eclipse == FALSE) 

{ 

if (target != BAT_NONE) 


{ 


/* There is a Target, and the spacecraft is NOT in eclipse. 

* What type of charging does the Target require? 

*/ 

if ((count[target] < CS_OVERCHARGED) || (count[target] >= count__max}) 
bcm__overcharge () ; 


else 


bcm_recharge(); 


) 


} /* End of bcm_charge() */ 




* int bcm_check_conditions(void) 

■k 

* Determine condition of batteries and wether or not there is a preferred 

* battery to use. 

* 

************♦*********★**********♦*****************★************************/ 


#define WARM -2 

#define COOL -1 

#define NX;M_C0ND STATES 5 


int bcm_check_conditions(void) 

{ 


int 

int 

int 

static 


int 

{ 


).• 


not_op tNUM_BATS )1 
preferred; 
i/ a, b; 

action [NUM_COND_STATES] [NUM COND STATES] = 


{WARM, 

{BAT_B, 

{BAT_B, 

{BAT_B, 

{BAT_A, 


BAT_A, 

BAT_A, 

BAT_A, 

BAT_B} 

WARM, 

BAT_A, 

BAT_B, 

BAT__B} 

BAT_B, 

BAT_N0NE, 

BAT_B, 

BAT_B} 

BAT_A, 

BAT_A, 

COOL, 

BAT_B} 

BAT_A, 

BAT_A, 

BAT_A, 

COOL} 


Static signed char condition [NUM_COND_STATES] = (-10, 0, 35, 


45, MAX_CHAR}; 


/* Start by assuming both batteries are usable */ 
not__op [BAT_A] « not_op IBAT_B] = FALSE; 

/* First, check if there is a target battery */ 
if (target != BAT NONE) 

{ 

/* Want to look at Che lowest cell voltage, but only after the target 

* has been trickle charged, and then normal charged for the fixed 

* length of cimes. 

*/ 

if (get_elap8ed_tifne {) > target_time [target] + TRICKLE_TIME) 

{ 

/* Hake sure lowest cell voltage is above a certain amount. */ 
if <bcir_v_sii n (target) < VLOW) 
not op(target) ■ TRUE; 

} 

} 


/* Now, check if any battery has already been charged at least once. If 

* so, and the battery is NOT the target (being charged), then check the 

* lowest of the maximum cell voltages while the battery was charging. This 

* minimum of the maximum cell voltages must be above a certain amount. 

*/ 

for (i = 0; i < NUM^BATS; i++) 

{ 

if (i != target) 

{ 

if (count[i] != CS_UNKNOWN) 

{ 

/* Check minimum of the maximum cell voltages */ 

134 



) 


} 


if (bCTn_v_max_min(i) < VMAX_LOW} 
not_op[i3 = TRUE; 


/* If there is a preferred battery, then indicate. Otherwise, do temperature 
* tests to still see if there is a preferred battery. 

V 

preferred = not_op [BAT_A3 ? (not_op [BAT_B] ? BAT_NONE : BAT_B} : (not_op [BAT_B3 ? BAT_A : BAT_NONE) 

if {preferred == BAT_NONE) 

( 

/* For each battery, find which temperature category it falls within */ 
for (i = 0; i <= NUM_COND_STATES - 1; i++) 

{ 

if (t_avg[BAT_A3 < condition[i]) 
break; 

} 

a = i ; 

for (i = 0; i <= NUM_COND_STATES - 1; i++) 

{ 

if (t_avg[BAT_B] < condition[i]) 
break; 

} 

b = i; 

switch(action[b][a]) 

{ 

case WARM: 

preferred = (t_avg [BAT_A] >= t_avg [BAT_B] ) ? BAT_A : BAT_B; 
break; 

case COOL; 

preferred = (t_avg [BAT_A] <= t_avg [BAT_B] ) ? BAT_A : BAT_B; 
break; 

case BAT_A: 

preferred = BAT_B; 
break; 

case BAT_B: 

preferred = BAT_B; 
break; 

case BAT_NONE: 

preferred = BAT_NONE; /* no preference */ 
break; 

default: /* error */ 

preferred = BAT_NONE; 

) 

) 

return(preferred); 

} /* End of bcm_check_conditions() */ 


/*******♦**♦***********************************★**********************★**♦**** 

* 

♦ int bcm_get_mode(void) 

* 

* Report which operation mode the batteries are capable of supporting. 

* 

*************************************************************************.***/ 


int bcm_get_mode(void) 

{ 

return(mode); 

) /* End of bcm_get_mode() */ 




* int bcm_in_eclipse(void) 

* 

* Determine if the spacecraft is in eclipse. 

* 

****************************************************************************/ 


135 






int bcm_in_eclipse(void) 

{ 

if {tlin_cnv. iscbus < 0.050) 
return (TRUE) ; 

else 

return (FALSE) ; 

} /* End of bcm_in_eclipse */ 


/**********1fk****ir**ir*irir**********ic*1t***1t**it**1ft*************ir*******ir*-k1eie*1c** 

* 

* void bcm_info(*bcm_info_struct info) 

* 

* Return information that describes the state of the BCM. 

* 

************ir*-k*it**********ii-k*1c*it*i,1eit**1ci,*i,-k**i,1tic-k*icitit1,lt*i,**i,***i,i,1,*ie*1t*****/ 


void bcm_info(bcm_info_struct * info) 

{ 

register int i, j; 


info->online = online; 

info->target = target; 

info->mode = mode; 

info->dod__detect = dod_detect; 
info->eclipse = eclipse; 

/* This is for the elased overcharge timer for the target battery */ 
if (over_timer != OL) 

info->timer = get_elapsed_time() - over_timer; /* duration of overcharging */ 

else 

info->timer = OL; /* indicate not in use */ 


info->online_switch = online_switch; 

info->temp_max = temp__max; 
info->count_max = count_max; 
info->over_int = over_int; 

for (i = 0; i < NUM_BATS; i++) 

{ 

info->count[i] = count[i]; 

info->capU] = cap[i]; 

info->control[i] = control[i); 

info->cap_max[i] = cap_max[i]; 
info->efficiency[i] = efficiency[i]; 

info->vth_low[i] = vth_low[i]; 

info->dod[i] = dod[i]; 

for (j = 0; j < V_TH_STEPS; j++) 

info->v__threshold [i] [j] = v_threshold[i] [j] ; 


for (i = 0; i < NUM_MODES; i++) 

info->over_times[i] = over_times[i]; 

} /* End of bcm_info() */ 


* 

* void bcm_init(void) 


* Initialize the BCM. This is used to force a reset of the BCM for example 

* when a data error has occurred and the charge state variables are no 

* not valid. 




■k-k ! 


void bcm_init(void) 

{ 

register int i, j; 

int preferred; 


/* Deteirmine preferred battery */ 
preferred = bcm_check_conditions(); 


136 


if (preferred != BAT_NONE) 

{ 

/* There is a preferred battery due to environmental/battery 

* performance criteria. Use this battery regardless of 

* other charge state history information. 

*/ 

online = preferred; 

) 

else 

online = BAT_A; /* otherwise, default to Battery A */ 


target 

= BAT_N0NE; 

mode = 

MODE_LOW; 

dod_detect 

= FALSE; 

eclipse 

= TRUE; 

over_timer 

= OL; 

online_swit ch 

= FALSE; 

temp_max = 

TEMP_MAX; 

count_max 

= COUNT_MAX; 

over_int = 

OVER_INTEGRATE; 

cap_max[0] 

= CAP_A; 

cap_max[l] 

= CAP_B; 

efficiency[0] 

= EFF_A; 

efficiency[1] 

= EFF_B; 

vth_low[0] 

= VTH_LOW_BATA, 

vth_iow[1] 

= VTH_LOW_BATB, 

for (i = 0; i 

< NUM BATS; i++) 


{ 

/* Maximum cell voltages, recorded while battery is charging. */ 
for (j = 0/ j < NUM_CELLS; j++) 
v_max_cells[i] [j] = 0.0; 

count[i] = CS_UNKNOWN; 
cap[i] =: 0.0; 

target_time[i] = 4294967295L; 
t_avg(i3 = 0.0; 
dod[i] = DOD; 

) 

over_times[MODE_LOW] = TIMER_L0W; 

Over_times [MODE_STANDBY] = TIMER_STANDBY; 
over_times CMODE_NORMAL] = TIMER_NORMAL ; 

/* Turn OFF all battery controls, but leave the ONLINE battery online */ 
eps_batts_off(online); 

} /* End of bcm_init() */ 


/********************♦**★****♦★*★**********************★********************** 

* 

* int bcm_mode(void) 

* 

* Determine which operation mode the batteries are capable of supporting. 

* 

*************★********************************************♦*****************/ 

void bcm_mode(void) 

{ 

register int other; 


other = (online == BAT_A) ? BAT_B : BAT_A; 

if (count[online) == CS_UNKNOWN) 
mode = M0DE_L0W; 

else if (count[other] == CS_UNKN0WN) 
mode = MODE_LOW; 

else if (cap [online] < cap_max [online] * (1.0 - dod [online])) 

mode = (cap_max [other] < cap_max [other] * (1.0 - dod [other])) ? MODE_LOW : MODE_STANDBY ; 

else 

mode = (cap [online] < cap_max [online] * (1.0 - dod [online] ) ) ? MODE_STANDBY : MODE_NORMAL; 


137 


} /* End of bcm_mode(} */ 






* void bcni_online (void) 

* 

* Determine which battery should be online. 

* 

************it*********-k**ir*ic1ti,*ir-kie**iric1r*ir****-k*********1fk1(**ir******i,ic*-k*****/ 

void bcm__online (int preferred) 

{ 

online_switch = FALSE; 


if (preferred != BAT_NONE) 

{ 

/* There is a preferred battery due to environmental/battery 

* performance criteria. Use this battery regardless of 

* other charge state history information. 

*/ 

if (preferred != online) 
online_switch = TRUE; 

online = preferred; 

if ( (cap[online] <= cap_max[online]*(1.0 - dod[online])) || 
(vbatt_avg[online] < vth_low[online]) ) 
dod_detect = TRUE; 

return; 

} 


/* Is there already a battery online ? */ 
else if (online != BAT_NONE) 

{ 

/* Has the voltage of the online battery dropped below its 
* low voltage threshold. 

*/ 

if ((vbatt_avg[online] < vth_low[online]) && (count[online] >= 0)) 

/* The online battery has charge history and is not 

* acknowledge as needing OVERCharge. Yet, its average 

* voltage has dropped below a voltage threshold, signifying 

* it has less capacity than expected. Therefore, force it to 

* be overcharged in its next charge cycle. 

*/ 

count[online] = CS_FORCE OVER; 

} 

/* Is the online battery below DOD ? */ 

if ( (cap[online] <= cap_max[online]*( 1.0 - dod[online])) j| 
(vbatt_avg[online] < vth low[online]) ) 

{ 

/* What is the Target? If there is already a Target, then 

* the Target must remain charging, and the Online battery must 

* remain online until the Target finishes charging. Therefore, 

* DOD has been reached and a temperature reference must be set 

* on the Target since charging will now occur at a quicker rate. 
*/ 

if (target != BAT_NONE) 

{ 

/* There is a Target battery. Is this the first time this 

* (below DOD) been detected? If so, mark the Target’s 

* temperature for charging decisions. 

*/ 

if (!dod_detect) 

dod_detect = TRUE; 

) 

else/* There is no Target, switch the online battery */ 

online_switch = TRUE; 
switch(online) 

{ 

case BAT__A: 

online = BAT_B; 
break; 
case BAT_B: 

online = BAT_A; 
break; 
default: 


138 


/* This is an ERROR case and should never happen */ 
online = (captBAT_A] >= cap[BAT_B]) ? BAT_A : BAT_B; 
break; 

) 

} 

} /* End of cap[online]... */ 

else/* enough capacity still, no action */ 

{ 

} 

} /* End of if {online != BAT_NONE) */ 


else/* There is no online battery, choose one */ 

{ 

if (count[BAT_A] == CS_UNKNOWN) 

/* Battery A has no charge state history, how about Battery B? */ 
online = (count[BAT_B] == CS_UNKNOWN) ? BAT_A : BAT_B; 

else/* A has charge state history, but what about B ? */ 

{ 

if (count[BAT_B] == CS_UNKNOWN) 
online = BAT_A; 

else 

online = cap[BAT_A] >= cap[BAT_B] ? BAT_A : BAT_B/ 

} 

/* Since a new battery has JUST been selected to become online, force 
* DOD detect to FALSE, 

*/ 

dod_detect = FALSE; 

} /* End of else (no online battery...) */ 

} /* End of bcm_online() */ 


/***************************************************************************** 

* 

* void bcm_overcharge(void) 

* 

* Perform charging on the Target using the OVERcharge method. 

♦ 

★*********************★*********★***************★***************************/ 

void bcm_overcharge(void) 

{ 

/* First, check to make sure the temperature of the Target is low enough. */ 

/* However, this ignored when first starting in case there was a hot-soak 

* on the spacecraft while in the shuttle bay which would cause the 

* spacecraft to be hot when ejected.immediate cooling is expected. 

*/ 

if ((t_avg[target] <= temp_max) || (get_elapsed_time() < ONE_HOUR)) 

{ 

/* Check so that the Target has not OVER Integrated, a safety check */ 
if (cap [target] < cap_inax [target] *over_int) 

{ 

/* Has the Target reached the voltage threshold which is indicative 

* over beginning to reach the overcharge portion of the charge 

* cycle? If overcharge timer (overtime) is NOT zero, then it is 

* already active, which means the voltage threshold was already reached 

* earlier. 

*/ 

if ( (vbatt_avg[target] < (v_threshold[target][bcm_tbound((signed char)t_avg[target])]) 
&& (over_timer == (unsigned long int) OL)) ) 

{ 

/* Below the voltage threshold, continue charging */ 

/* no new action needed. */ 

) 

else/* OVERcharge */ 

{ 

if (over_timer == OL) 

{ 

/* Begin the overcharge, mark the time. Non-zero means the timer 
* is active. 

*/ 

over_timer = get_elapsed_time {) ; 

} 

else/* Already in overcharge, how is it going? */ 

{ 


139 




if (get_elapsed_time0 >= (over timer + over times[mode]}) 

{ 

count[target] = CS_OVERCHARGED; 
cap [target] = cap__max [target] ; 
target = BAT_nonE; 
dod_detect = FALSE; 
over_timer = OL; 

) 

else 

{ 

/* Continue overcharge using NON DOD detect method. */ 
/♦No new action needed. */ 

} 

) 

} 

} 

else/* OVER integration occured, stop the charging. */ 

{ 

count [target] = CS_OVERCHARGED; 
cap[target] = cap_max[target] ; 
target = BAT_NONE; 
dod_detect = FALSE; 

} 

} 

else/* TOO HOT */ 

{ 

/* Do not change capacity; however, it is ASSUMED that the battery charging 

* is not complete. So, the count is placed to CS_FORCE_OVER, so that 

* the next time this battery becomes the Target, it will be forced into 

* OVERcharge. 

*/ 

count[target] = CS_FORCE_OVER; 
target = BAT_NONE; 
dod_detect = FALSE; 

} 

} /* End of bcm_overcharge () */ 


/*********1t*******'k*******ifk'k********ii1e***1c***iric**ir****1t*it*******ir***it***it*iric* 

* 

* void bcm_recharge(void) 

* 

* Perform charging on the Target using the REcharge method. 

* 

*************************************************************************^^**^ 

void bcm_recharge(void) 

{ 

/* First, check to make sure the temperature of the Target is low enough. */ 

/* However, this ignored when first starting in case there was a hot-soak 

♦ on the spacecraft while in the shuttle bay which would cause the 

* spacecraft to be hot when ejected.immediate cooling is expected. 

*/ 

if ( (t_avg[ target] <= temp_max) |j (get elapsed time() < ONE HOUR)) 

{ ’ “ ■ 

if (cap[target] >= cap_max[target]) 

{ 

/* REcharged */ 

count[target]++; 

cap[target] = cap_max(target] ; 

dod_detect = FALSE; 

target = BAT_NONE; 

} 

else 

{ 

/* Continue recharge. No new action needed. */ 

} 

} 

else/* TOO HOT */ 

{ 

/* Do not change capacity; however, it is ASSUMED that the battery charging 
* is not complete. So, the count remains the same as well. 

*/ 

target = BAT_NONE; 
dod_detect = FALSE; 


140 



) 


} /* End if bcm_recharge() */ 

/****************************************************★***★***♦**★*******★***** 

* 

* void bCTn_set_params (bcm_params_struct *params) 

★ 

* Allow BCM parameters to be modified. 

* 

**********************★*******************************•*■*********************/ 

void bcm_set_params (bcm_params__struct *params) 

{ 

register int i, j; 


temp_max = params->temp_max; 
count_max = params->count_max; 
over_int = params->over_int; 

for (i = 0; i < NUM_BATS; i++) 

{ 

cap__max(i] = params->cap_max[i] ; 

efficiency [i] = paraTns->efficiency [i] ; 

vth__low [i} = params->vth_low [i] ; 

for (j = 0; j < V_TH_STEPS; j++) 

v_threshold[i] [j] = params->v_threshoId[i] [j]; 

dod[i] = params->dod [i]; 

} 

for {i = 0; i < NUM_MODES; i++) 

over_times[ij = params->over_times[i] ; 

} /* End of bcm_set_params() */ 


/**********-k**1i*ie***it**ic**it****1t*1r-k*****it****±****-k**ic*-k1eie-k*ie**itic*itit***ic***ii** 

* 

* void bcm_set_switches0 

* 

* Set the battery switches according to all of the decisions made within one 

* pass through the BCM. 

* 

*************♦****************************♦*********************************/ 

int bcm_set_switches(void) 

{ 

register int offline; 
register int not_target; 
int mode; 


/* Indicate which controls are set. Begin by setting all control status off */ 
offline = (online == BAT_A} ? BAT_B : BAT_A; 
control[online! = 0; 
control[offline] = 0; 

not_target = (target == BAT_A) ? BAT_B : BAT_A; 


/* Turn on ONLINE switch for battery to be online. It doesn't matter if 

* the online bateries are being switched (A->B} or (B->A) as long as you 

* FIRST turn ONLINE a battery, and THEN turn OFFLINE the other. 

*/ 

if (eps_set_battery(online, BAT_ONLINE) == ERROR) 
return(ERROR); 

if (eps_set_battery(offline, BAT_OFFLINE) == ERROR) 
return(ERROR); 

control [online] |= CTRL_ONLINE,- 


if (eclipse) /* turn OFF battery controls, EXCEPT online ♦/ 

eps_batts__off (online) ; 

else if (target !== BAT_NONE) /* turn ON all that needs to be - except online (already done) */ 

{ 

/» CHARGING: Normal or Trickle ? */ 

/* Only do Trickle charging on a battery that has no charge state 
* history, and that has only been selected to be charged within 

141 



* the TRICKLE_TIME time frame. 

*/ 

if ((count[target] == CS_UNKNOWN) && 

(get_elapsed_time 0 * target_time [target] ) < TRICKLE__TIME) 

/* Make sure all normal charging switches are OFF */ 

if (eps_set_battery(not_target, BAT_CHARGE_OFF) == ERROR) 
return(ERROR); 

if (eps_set_battery(target, BAT_CHARGE_OFF) == ERROR) 
return(ERROR); 

if {eps_set_battery(not_target, BAT_TRICKLE_OFF) == ERROR) 
return(ERROR); 

if (eps_set_battery(target, BAT_TRICKLE_ON) === ERROR) 
return(ERROR); 

control[target] |= CTRL_TRICKLE; 

} /* End of IF (Trickle Charging) */ 

else/* Time for Normal Charging */ 

{ 

/* Make sure all trickle charging switches are OFF */ 

if (eps_set_battery(not_target, BAT_TRICKLE_OFF) == ERROR) 
return(ERROR); 

if (eps_set_battery(target, BAT_TRICKLE_OFF) == ERROR) 
return(ERROR); 

if (eps_set_battery(not_target, BAT_CHARGE_OFF) == ERROR) 
return(ERROR) ; 

if (eps_set_battery(target, BAT_CHARGE_ON) == ERROR) 
return(ERROR); 

control[target] |= CTRL_CHARGE; 

} /* END of ELSE (Normal Charging) */ 

} /* End of ELSE (target != BAT_NONE) */ 

else /* There is NO Target, so make sure all controls are OFF */ 

eps_batts_off(online); /* turn OFF battery controls, except online */ 


/* Now, check for the battery heaters */ 
mode = (t_avg[BAT_A] < TEMP_LOW) ? ON : OFF; 
eps_set_power(PWR_HEATA, mode); 

mode = (t_avg[BAT_B] < TEMP_LOW) ? ON : OFF; 
eps_set_power (PWR_HEATB, mode) ; 

} /* End of bcm_set_switches() */ 


/*********-k-k***t****t***-k*ir****-k-k******1t**it*i,i,1,*****-k***ic****-k*ir*-k***1r******** 

* 

* void bcm_target(void) 

* 

* Determine which battery should be (targeted) to charge, if any. 






void bcm_target(int preferred) 

{ 

if (preferred != BAT NONE) 

{ 

/* There is a preferred battery to set as the target due to 

* environmental and battery performance criteria. 

*/ 

/* Is there a target battery already, and is it the same as the 

* preferred? If so, do not interrupt (restart) the target 

* selection process. 

*/ 

if (preferred != target) 

{ 

if (count [preferred] === CS UNKNOWN) 

{ 

target = preferred; 
cap[target] = 0.0; 

} 

else if (count[preferred] == CS_FORCE_OVER) 

142 


target = preferred; 


else if (cap[preferred] < cap_max[preferred]*(1.0 - dod[preferred])) 
target = preferred; 

/* else, the preferred battery is not ready to charge - leave it */ 

if (target != BAT_NONE} 

{ 

/* zero out the cell voltage maxes */ 
bcni_v_max_clear (target) ; 

over_timer = OL; /* indicate just determined the target */ 

/* this is the overcharge timer */ 

target_time[target] = get_elapsed_tirae(); 


} 

} 

} 


else if (target == BAT_NONE) 

{ 

/* There is no target, try to choose one if appropriate. */ 
if (count[BAT_A] == CS_UNKNOWN) 

{ 

/♦A has no charge state history, it is the Target; however, 

* if B is also the same, mark its charge history likewise. 

*/ 

if (count [BAT_Bl == CS_UNKNOWN) 

Cap[BAT_B] = 0.0; 

target = BAT_A; 
cap[BAT_A] = 0.0; 

} 

/* How about B ? */ 

else if (count[BAT_B] == CS_UNKNOWN) 

{ 

/* Battery B has no charge state history, but A does. */ 
target = BAT_B; 
cap [BAT_B] = 0.0; 

} 

else 

{ 

/* Does A need to be forced to overcharge ? */ 
if (count[BAT_A] == CS_FORCE_OVER) 
target = BAT__A; 

/* A does not need a overcharge forced, how about B? */ 
else if (count[BAT_B] == CS_F0RCE_0VER) 
target = BAT__B; 

else/* Need to look at Capacities now in order to decide. */ 

{ 

if (cap[BAT_A] <= cap[BAT_B]) 

target = (cap[BAT_A] <= cap_max[BAT_A]*(1.0 - dod[BAT_A] )) ? BAT_A : BAT_N0NE 

else 

target = (cap[BAT__B] <= cap_max [BAT_B] * (1.0 - dod [BAT__B] )} ? BAT B : BAT NONE 

} 

} 

if (target != BAT_NONE) 

{ 

/* zero out the cell voltage maxes */ 
bcm_y_max_clear(target) ; 

over_timer = OL; /* indicate just determined the target */ 

/* this is the overcharge timer */ 

target_time[target] = get_elapsed_time(); 

} 

} /* End of IF (target == BAT_NONE) */ 


else 

{ 

/* The Target has ALREADY been previously choosen, leave it. */ 

} 


143 



} /* End of bcm_target() */ 


* 

* int bcni_tbound (float t) 

* 

* This funcion categorizies a temperature value into an index 

* for table lookup into the voltage vs. temperature table 

* 

* v_threshold[target][temperature] 

* 

* to check if a 

* charging battery has reached the voltage threshold. 

* 

* Jah; optimize 

* 

****★************★*****★*****★*****★*****************************♦**********/ 

int bcm_tbound(signed char t) 

{ 

unsigned char range = (unsigned char)(T_HIGH - T_LOW); 
unsigned char dt = (unsigned char) (range/V_TH_STEPS) ; 

signed char acc = (signed char)T_LOW; /* accumulator from T_LOW to T_HIGH in steps of dt */ 

register int i = 0; /* index corresponding to the temperature */ 


if (t >= T_HIGH) 

return(V_TH_STEPS - 1); 


else 

{ 

while (t > acc) 

{ 

i++ ; 

acc += dt; 


return(i); 

} 

} /* End of bcm_tbound() */ 






* void bcm_tlm_update0 

* 

******************************************************^*********^^^^^^^^^^^^^ 

#define BAT_A_TS0 2 
# de f i ne B AT_B_TS 0 12 


void bcm_tlm_update (void) 

{ 

unsigned register int i, 
WORD a, 

WORD ta 

int 

static DWORD 


j; 

b; 

tb; 

na, nb; 
t old = 


0 ; 


/* for dTime for Cap. calcs */ 


/* Voltages */ 
vbatt_avg [BAT_A] 
vbatt_avg [BAT_B] 


t lm_cnv, vce 11 sa_avg ; 
tlm_cnv.vcel1sb_avg; 


/* Now, update the maximum cell voltages */ 
for (j = 0; j < NUM_CELLS; j++) 

if (v_raax_cells[BAT_A] [j] < tlm_cnv.vcellsa[j] ) 

"^-^^^-Cells [BAT_A] [j] = tlm_cnv.vcellsa(j] ; 
for (j = 0; j < NUM_CELLS; j++) 

if (v_max_cells [BAT_B] [j] < tlm_cnv.vcellsb [j] ) 
v_max_cells[BAT_B] [j] = tlm__cnv.vcellsb [j ] ; 

/* Capacities */ 
if (tlm_cnv.ibatta < -0.020) 

cap [BAT_A] += tlm_cnv. ibatta* ( (double) (tlm_record.etime - t_old) / (double) SECS_PER_HOUR) ; 
else if (tlm_cnv.ibatta > 0.020) ~ 

cap[BAT_A] += eff iciency [BAT_A] *tlm_cnv. ibatta* ( (double) (tlm_record. etime - 
t_old) / (double) SECS_PER_HOUR) ; 


144 


if (tlTn_cnv. ibattb < -0.020) 

cap[BAT_B] += tlm_cnv.ibattb*((double)(tlm_record.etime - t_old)/(double)SECS_PER_HOUR) 
else if (tlm_cnv.ibattb > 0.020) 

cap[BAT_B] += efficiency[BAT_B]*tlm_cnv.ibattb*((double) (tlm_record.etime - 
t_old) / (double) SECS_PER_HOUR) ; 
t_old = tlm_record.etime; 


/* Temperatures */ 

/* Get first average with ALL measurements */ 

for (ta = 0, tb = 0, i ^ 0; i < NUM_CELL_TEMPS; i++) 

{ 

ta += tlm_cnv.tsEBAT_A_TS0 + i] ; 
tb += tlm_cnv.ts[BAT_B_TS0 + i] ; 

} 

a = ta/NUM_CELL_TEMPS; 
b = tb/NUM_CELL_TEMPS; 

/* Now, remove any measurements that are above/below 5 degrees */ 
for (na = 10, nb = 10, i = 0; i < NUM_CELL_TEMPS; i++} 

{ 

if ( (tlm_cnv.ts [BAT_A_TS0 + i] >= (a + 5)) |1 
(tlm_cnv.ts[BAT__A_TS0 + i] <= (a - 5) ) ) 

{ 

ta -= tlm_cnv. ts [BAT_A_TS0 + i] ; 
na - -; 

) 


if ( (tlro_cnv. ts [BAT_B_TS0 + i] >= (b + 5) ) || 

(tlm_cnv. ts [BAT_B_TS0 + i] <= (b - 5) ) ) 

{ 

tb -= tlm_cnv. ts [BAT_B_TS0 + i] ; 
nb--; 

) 

} 

/* Recompute the average */ 
if (na == 0) 

t_avg[BAT_A] = a; /* weird case - avoid divide by zero */ 

else 


t_avg tBAT__A] = ta/na; 


if (nb == 0) 

t_avg [BAT_B] = b; /* weird case - avoid divide by zero */ 

else 

t_avg[BAT_B] = tb/nb; 


} /* End of bcm_tlm_update0 */ 


y*****************ik*********************************************************** 
* 

* void bcm_v_max_clear(int battery) 

* 

* Set the maximum cell voltages history all to zero in order to restart the 

* recording of maximum cell voltages for a particular battery. 

* 

****************************************************************************/ 

void bcm_v_max_clear(int battery) 

{ 

register int i; 


for (i = 0; i < NXJM_CELLS; i++) 

v_max_celIs[battery][i] = 0.0; 

} /* End of bcm_v_max_clear(} */ 




* void bcm_v_max_min(int battery) 

* 

* Return the minimum cell voltage of all of the recorded maximum cell 

* voltages for a particular battery. 

* 

****************************************************************************y 

float bcm_v_max_min(int battery) 

{ 

register int i; 
float x = 100.0; 


for (i = 0; i < NUM_CELLS; i++) 


145 



if {v_Tnax_celIs [battery] [i] < x) 
^ = v_max_cells[battery][i]; 


return(x); 

) /* End of bcm_v_jnax_min () */ 


/***************★***********************************♦************************* 

* 

* void bcm_v_min(int battery) 

* 

* Return the minimum cell voltage from the current telemetry record of cell 

* voltages for a particular battery. 

* 

****************************************************************************/ 


float bcm_v_min(int battery) 

( 

register int i; 
float X = 100.0; 


if {battery == BAT__A) 

for (i = 0; i < NUM_CELLS; i++) 
if (tlm_cnv.vcellsa[i] < x) 
X = tlm_cnv.vcellsa[i]; 

else /* Must be battery B */ 

for (i = 0; i < NUM_CELLS; i++) 
if (tlm_cnv.vcellsb[i] < x) 
X 5= tlm_cnv.vcellsb[i]; 


return(x); 

} /* End of bcm_v_min{) */ 

End of bcm.h bcm.c 


146 



clock.h, clock.c 

/***************************************************************************** 

* 

* CLOCK.H 

* 

* Real time clock for PANSAT 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 

* 

* Date Who What 

* --+-+--- 

* 8 March 1996 Jah Creation 

★ 

***♦******************************************★*****************************/ 


/* Tick intervals for day and time stamping */ 


#define SECS_PER_MIN 60L 

#define SECS_PER_HOUR (SECS_PER_MIN*60L) 

#define SECS_PER_DAy {SECS_PER_HOUR*24L) 
#define SECS_PER_YEAR (SECS_PER_DAY*365L} 


#define 
#define 
#define 
#define 
#define 
#define 


THIRTY_SECONDS (30L) 

ONE_MINUTE (1L*SECS_PER_MIN) 

TWO__MINUTES (2L*SECS_PER_MIN) 

FIVE_MINUTES (5L*SECS_PER_MIN) 
TEN_MINUTES (10L*SECS_PER_MIN) 

ONE_HOUR (1L*SECS_PER__H0UR) 


#ifdef CLOCK 

/* Timer2 is programmed to interrupt once every 1/60 second */ 
#define TICKS PER SECOND 60 


void interrupt far 

DWORD 

DWORD 

void set 


clock_isr 0 ; 
get_elapsed_time(void); 
get_time(void); 
time(DWORD); 


#endif 


#ifndef CLOCK 

extern void interrupt far clock__isr () ; 
extern DWORD get_elapsed_time(void); 

extern DWORD get_time(void); 

extern void set_time(DWORD); 

#endif 


/ 




CLOCK.C 


Real time clock for PANSAT 

Petite Amateur Navy Satellite (PANSAT). 

Embedded ROM software. 

Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 
Jim A. Horning (Jah) 

Revision History; 


Date Who What 


8 March 1996 Jah Adoption from STAR'S clock.c 

*♦****************************★************♦♦**********************♦*******/ 


# include ''gen_def s .h" 

^include "gen_apis.h" 

#define CLOCK 

#include "clock.h" 

#undef CLOCK 


#include "edac.h" 


static DWORD sec_count = OL; /* total elapsed from time of startup */ 


147 









static DWORD base_time = OL; /* UTC offset uses sec count */ 

DWORD icount = OL; 

/★*********★********************************♦***************★***************** 

* 

* clock_isr() 

* 

* This routine is invoked by Timer 2 (INT 13h) - the system clock tick 

* mechanism. tick_count is the total number of ticks since the real time 

* clock was initialized. 

* 

***********************************************************************-(t****/ 


void interrupt far clock_isr() 

{ 

static unsigned int interval = 0; 


icount++; 

if (++interval == TICKS_PER_SECOND) 

{ 

interval = 0; 
sec_count++; 

/* edac_ram_wash(}; */ 

) 

/* Send non-specific EOI to Interrupt Controller */ 
outpw(0xFF22, 0x8000); 

} /* End of clock__isr() */ 

/**********★**************************************************************★*** 

* 

* DWORD get_elapsed_time(void) 

* 

* Return system up time in number of elapsed seconds. 

★ 

**********************************************************************★★***★/ 


DWORD get_elapsed_time(void) 

{ 


return(sec_count); 

} /* End of get_elapsed_time0 */ 

/***************************************************************************** 

* 

* DWORD get_time(void) 

* 

* Return system time in number of elapsed seconds. Based on 1 Jan 1970. 

* 

*************************************************************** 1 ^************^ 

DWORD get_time(void) 

{ 

return(base_time + sec_count); 

} /* End of get_time() */ 

/***************************************************************************** 

* 

* void set_time(DWORD t) 

* 

* base_time maintains the date/time at which the clock was set to a specific 

* time. Thus, base_time + sec_count is the current time. While sec_count 

* maintains the elapsed time since startup. 

* 

*********************************************************.*******************^ 

void set_time(DWORD t) 

{ 

base_time = t - sec_count; 

} /* End of set_time() */ 

End of clock.h, clock.c 


148 


cmd.h, cmd.c 

/***************************************************************************** 

* 

* CMD.H 

* 

★ 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History; 

* Date Who What 

* -+-+--- 

* 

★ ****************************<fHr*********************************************/ 


/******★*********♦************************************************************ 

* 

* CMD.C 

* 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 

* Date Who What 

* - + - + - 

* 19 Nov 1996 Jah Creation 

* 

****************************************************************************/ 


#include "gen_defs.h" 

#define CMD 

#include "cmd.h" 

#undef CMD 


typedef struct ack_packet 

{ 

BYTEcmd; 

BYTEaction/ 

} acl_packet_struct; 


typedef struct cmd_packet 

{ 

BYTEcmd; 

1 


/* Upcoming Command Types (from grounstation to spacecraft) */ 


#define 

CMD_CONFIRM 

0x55 

#define 

CMD_CONTROL 

0x5A 

#define 

CMD_EXEC 

0xA5 

#define 

CMD_GETP 

OxAA 

#define 

CMD_LOAD 

0x66 

#define 

CMD_MAP 

0x69 

#define 

CMD^RESET 

0x96 

#define 

CMD^SETP 

0x99 

#define 

CMD STATUS 

0x00 

#define 

CMD_SLOG_CLEAR OxOF 

#define 

CMD_SLOG_READ OxFO 

#define 

CMD_VERIFY 

OxFF 

#define 

CMD_UNKNOWN 

0x56 


/* not an actual command, but used in the 

* spacecraft ACK packet to identify the 

* type of command that was received. 

*/ 


/* Downgoing Action Types 
#define ACT_CONFIRM 
#define ACT_NONE OxAA 
#define ACT_REPEAT 
#define ACT UNKNOWN 


(from spacecraft to groundstation) 
0x55 


0x66 

0x99 


*/ 


149 











cmd_exainine () 




cmd_examine{) 

{ 


switch (in_packet->cmd) 

{ 

case CMD_CONFIRM: 

ack_packet->cmd = CMD_CONFIRM; 
ack_packet->action = ACT_CONFIRM; 
break; 

case CMD_CONTROL: 

ack_packet->cmd = CMD_CONTROL; 
ackjpacket->action = ACT_CONFIRM; 
break; 

case CMD_EXEC: 

ack_packet->cmd = CMD_EXEC; 
ackjpacket->action = ACT_CONFIRM; 
break; 

case CMD_GETP: 

ack_packet->crad = CMD_GETP; 
ack_packet->action = ACT_NONE; 
break; 

case CMD_LOAD: 

ackjpacket->cmd = CMD_LOAD; 
ack_packet->action = ACT_NONE; 
break; 

case CMD_MAP: 

ack_packet->cnid = CMD_MAP; 
ack_jpacket->action = ACT_NONE; 
break; 

case CMD_RESET: 

ack_packet->cmd = CMD_RESET; 
ack_packet->action = ACT_CONFIRM; 
break; 

case CMD_SETP: 

ack_packet->cind = CMD_SETP; 
ack_packet->action = ACT_CONFIRM; 
break; 

case CMD_STATUS: 

ack_packet->cmd = CMD_STATUS; 
ack_packet->action = ACT_NONE; 

/* append telemetry */ 
break; 

case CMP SLOG CLEAR: 

ack_packet->cmd = CMD_SLOG_CLEAR; 
ack_packet->action = ACT_CONFIRM; 

/* delete all stored telemetry */ 
break; 

case CMD_SLOG_READ: 

ack_packet“>cmd = CMD_SLOG_READ; 
ack_packet->action = ACT_NONE; 

/* append first record of stored telemetry */ 
break; 

case CMD_VERIFY: 

ack_packet->cmd = CMD_VERIFY/ 

ack_packet->action = ACT_NONE; 

ack_packet->action = ACT_REPEAT; 
break; 

default: /* UNKNOWN */ 

/* Valid packet (CRC passed), but command code is not valid */ 
ack_packet->cmd = CMD_UNKNOWN; 
ack_packet->action = ACT_UNKNOWN; 
break; 


150 



/* Place the command in the history buffer */ 

/* Now, send the packet to the packet driver */ 
scc_send_packet(out_packet); 

} /* End of cmd_examine() */ 

End of cmd.h, cmd.c 


151 


dcs.h, dcs.c 

/***********'k***ifk**1i**-k*-k*-k**ic**ie**1r***ic****it*1r****1fk********ii*****iritic****1c1c* 

* 

* DCS.H 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School, 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* Date Who What 

* -^-- - 

* 2 Nov 1993 Jah Creation 

* 

*************** 1c**ir****^-k ***************** *******-k** *********** irir*-k***** **** / 

#ifdef DCS 
#endif 


#ifndef DCS 

extern int debug; 
extern int bcm_on; 
#endif 


/*************************************************************************^^^^ 

* 

* DCS.C 

★ 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 

* Date Who What 

* -+ - - - 

* 2 Nov 1996 Jah Creation 

♦ 

***************************************♦************************************/ 


#include 

cstdlib.h> 

#include 

”gen_defs.h" 

#define 

DCS 

/* #include 

"dcs.h" */ 

#undef 

DCS 

#include 

"ad.h" 

#include 

"bcm.h" 

#include 

"clock.h" 

#include 

"eps.h" 

#include 

"pcb.h" 

#include 

"print.h" 

#include 

"see.h" 

#include 

"stpi.h" 

#include 

"terms.h" 

#include 

"tlm.h" 

/* Function 

prototypes */ 

static void 

boot_loader(void); 

static void 

boot_loader_setup(void) 

static void 

info_screen(void); 

static void 

stpi_only(void); 

static void 

stpi_only_setup(void); 

static int 

use_stpi(int *check); 


int debug = FALSE; 
int bcm_on = TRUE; 






voidmain (void) 


152 






* This is the first routine of the C runtime which is called by the startup 

* (assembler) module. This routine is responsible for determining if the 

* Boot Loader should begin autonomous operations of the spacecraft or if 

* the STPI is being used and control should be passed to the monitor for 

* ground-like operations. 

* 

* To accomplish this, the PANSAT banner is sent out the asynch serial port 

* in the event that a ground computer is attached and will send a response 

* back to the spacecraft. Then this module waits upto 30 seconds for a 

* response via the ground computer. If there is one, control is transferred 

* to the STPI module, by-passing the Boot Loader. Otherwise, control is 

* transferred to the Boot Loader which begins autonomous operation of the 

* spacecraft. 

* 

* A two way flag is used to check for STPI use (and disabling of the Boot 

* Loader) so that it is unlikely that just a single flag gets its value 

* changed accidentally. 

* 

***ifk***ii**1t*******ie*ifkit****itit*1t**ie1r***ic***ii*4e**ic*if*ifk*ir******1t**iiic*ie******ir^ 


voidmain(void) 

{ 

int stpi_on = FALSE; 
int stpi_check = 0; 


/* Send PANSAT banner to the STPI */ 
inf onscreen 0 ; 

/* Jah - check time */ 
while (get_elapsed_time() < 5) 

{ 

stpi_on = use_stpi(&stpi_check); 
if (stpi__on && (stpi_check == 0x5A) ) 

{ 

stpi_only() ,- 

/* STPI Monitor to be used, ground station computer is ready . */ 

) 

/* If STPI Monitor was being used but control is transferred here, 

* then the command to begin the Boot Loader was given. Thus, let 

* the flow of control go to the WHILE loop below which starts the 

* Boot Loader. 

*/ 

) 


/* Spacecraft is to run autonomously */ 
while (TRUE) 

{ 

boot_loader(}; 

/* The Boot Loader subroutine will run forever unless a command is 

* given to disable the Boot Loader, in which case control will be 

* transferred to the statements below. Thus, assume the STPI Monitor 

* is to be run. 

*/ 


/* STPI Monitor */ 
stpi_only(); 

/* The STPI Monitor subroutine will run forever unless a command is 

* given to begin the Boot Loader. In this case, transfer of 

* control will be given back to this WHILE loop, a new iteration 

* of the loop will begin, and automatically the Boot Loader 

* will be called. 

*/ 


} /* End of mainO */ 


/***************************************************************************** 

* 

* void boot_loader () 

* 

****************************************************************************/ 

void boot_loader(void) 

{ 

static int run_boot_loader = TRUE; 


/* Setup */ 


153 




/* boot_loader_setup 0 ; */ 


while (run_boot_loader) 

{ 

check_tlm{); 
bcm_main(); 

/* RF Listen */ 

/* Check/Process command (via RF link) */ 
/* RF Transmit */ 
monitor(); 

/* Scenarios */ 

/* Reset Watchdog timer */ 

) 

} /* End of boot_loader0 */ 






voidboot_loader_setup () 




/ 


void boot_loader_setup(void) 

{ 

ad_init(); 

if(msu_check_flash_tlm{) == ERROR) 

{ 

/* There was an error trying to locate an empty record */ 


while (!samples_ready) 


/* make sure BCM charge state variables are setup correctly */ 
bcm_main() ; 

/* setup time to listen timer */ 

/* setup communications */ 

} /* End of boot_loader_setup 0 */ 


/** 




* info_screen0 

* 


void info_screen(void) 

( 

home(); 
clrO ; 

dprint("\nPANSAT System Controller: "); 
dprint (" %s\n'', _DATE_) ; 

dprint("80C186 running at 7.3728 MH 2 \n”); 
dprint("ROM : F000:0 - F000:FFFF (64 k)\n"); 

dprint("RAM : 0000:0 - 7000:FFFF (512 k)\n"); 

dprint("SCCA: (Cmd = 2 , Data = 6) Synchronous\n") ; 

dprint ("SCCB: (Cmd = 0, Data = 4) UART at 19.2 kbits/sec, 8Nl\n"); 

serial_out(CTRL_W); 

} /* End of info_screen0 */ 


* 

* voidstpi_only 0 

* 


154 




void stpi_only(void) 

{ 

static int run_stpi_only = TRUE; 


while {run_stpi_only) 

{ 

check_tlm() ; 
monitor(); 


} 

} /* End of stpi_only() */ 


* vo i d s tp i_only_s e tup () 



/* bcm_off0; */ 


pcb_write(EPSO, 0, 0); 
pcb_write(EPSO, 2, 0); 
pcb_write(EPSl, 2 , 0); 


/* Battery A control, TMUXA, HEATA */ 
/* Other subsystem power */ 

/* Battery B control */ 


} /* End of stpi_only_setup 0 */ 


* 

* int use_stpi() 


* Monitor the STPI for the sequence of characters that spell PANSAT. If 

* these are sensed in this order, then it is assumed that a ground computer 

* is attached to PANSAT and PANSAT is to go into the STPI monitor mode. 

* 

* This routine is called repetitively during the first 30 seconds and thus 

* keeps a record of any received characters from the SPTI and when six are 

* received does a compare to the character sequence "PANSAT". 




int use_stpi(int *check) 

{ 

static char check_chars[6]; /* 6 chars for PANSAT */ 

static int c = 0; /* index into check_chars [] */ 


if {is_serial_in()) 

check_chars [C++] = serial_in(); 

if (c == 6) 

{ 

if (strncmp(check_chars, "PANSAT", 6} == 0) 

{ 

♦check = 0x5A; 
serial_out(0x5A) ; 
return(TRUE); 

) 

) 


return(FALSE); 

) /* End of use_stpi() */ 

End of dcs.h, dcs.c 


155 



edac.h, edac.c 

/************-k**ic*1t*i,ir******1,ii-k1tit***1r**1c***-k*ir***-k**1fk*ifkir1c****1(it1r*-k-k****i(**ir* 

* 

* EDAC.H 

* 

* Error Detection And Correction routines. 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* 

* Revision History: 

* 

* Date Who What 

* -^ - - - 

* 21 August 1996 Jah Creation 

* 

********************■^************±************************************* 1000 ,*/ 


typedef struct edac_stats 

( 

BYTE huge * ram_wash_ptr; 
DWORD soft_errors; 

DWORD ram_wa sh_cyc1es; 

} edac_stats_struct; 


#ifdef EDAC 

voidedac_get__stats (edac_stats_struct * stats); 
void interrupt far edac_hard_isr(); 
void interrupt far edac_soft_isr(); 
voidram_wash(void); 

#endif 


#ifndef EDAC 

edac_get_stats(edac_stats_struct * stats); 
edac_hard_isr() ; 
edac_soft_isr{); 
ram_wash(void); 

#endif 


extern void 

extern void interrupt far 
extern void interrupt far 
extern void 


* 

* EDAC.C 


* Error Detection And Correction routines. 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 199fc Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah' 


* Revision History 

* Date Wr.r What 


* 21 August 1996 Jar. Creation 


******** 




#include 


■ger._def 6 . h“ 


#define EDAC 
#include ''edac.h" 
#undef EDAC 

#include "int.h" 


156 









#define DOCON OxFFOO 

#define DMAO_OPF OxFFFF 

idefine DMA1_0FF OxFFFF 

tdefine RAM_WASH_COXJNT 64 /* 64 words */ 


/* This marks the location of the RAM wash in Static RAM. It is updated 

* after ram_wash() finishes an interval of washing so that it marks 

* where next to begin washing the next time ram_wash() is invoked. 

*/ 

static BYTE huge * ram_wash_ptr = (BYTE huge *)0; 

static DWORD edac_hard_err = OL; 
static DWORD edac_soft_err = OL; 
static DWORD ram_wash_cycles = OL; 


/*******-ir1tir****1r1r1r******1(ie‘tt-k**1t***1e*ic*1t*itit*1c*****1t**ie1t*ieifkie**ir********ir******* 

* 

* voidedac__get_stats 0 

* 

* Returns the information about the EDAC. The current RAM Wash pointer, 

* the number of soft errors. 

* 

****************************************************************************/ 

voidedac_get_stats (edac_stats_struct * stats) 

{ 

stats->ram_wash_ptr = ram_wash_ptr; 
stats->soft_errors = edac_soft_err; 
stats->ram_wash_cycles = ram_wash_cycles; 

} /* End of edac_get_stats () */ 


* 

* edac_hard_isr() 

* 

void interrupt far edac_hard_isr () 

{ 


/* Send specific EOI to PIC */ 

outpw(INT_EOI. OxOOOE); /* Interrupt OxE (14) - INT 2 */ 

} /* End of edac_hard_isr0 */ 

/**********************•****♦♦**********************★***********★************* 

* 

* edac_soft_isr() 

* 

*****************•»♦•••*••***********♦**************************************/ 


void interrupt far edac soft_isr() 

( 

edac_soft_err*♦; 

/* Clear the EDAC* error •/ 
pcb_portc(2, RESET?. 
pcb_portc(2, SET!. 

/* Send specific ECl to PIC */ 

outpw(INT_EOI, OxCCCFi. /* Interrupt OxF (15) - INT 3 */ 

} /* End of edac_so!t_isr() •/ 


* 

* void edac_ram_wash(void) 

* 

* Washes a 128 byte contiguous block of SRAM. Uses ram_wash_ptr as the 

* starting address. Updates ram_wash_ptr upon terminating. 

* 

********★*♦******************************************★*******************♦**/ 


void edac_ram_wash(void) 

{ 

asm 


157 





pushds 





Ids 

si, 

DWORD PTR ram 

_wash_ptr 


mov 

cx. 

RAM WASH COUNT 


cld 





mov 

dx. 

DO CON 



in 

ax, 

dx 



mov 

bx, 

ax 

; save a copy 

of DMAO config 

and 

ax, 

DMAO_OFF 



out 

dx. 

ax 

; DMA channel 

0 disabled 

inc 

dx 




inc 

dx 




in 

ax. 

dx 



mov 

di. 

ax 

; save a copy 

of DMAl config 

and 

ax. 

DMA1_0FF 



out 

dx. 

ax 

; DMA channel 

1 disabled 

cli 





rep 

lodsw 



sti 





mov 

ax, 

di 

; DMAl config 


out 

dx, 

ax 

; DMA channel 

1 enabled 

dec 

dx 




dec 

dx 




mov 

ax. 

bx 

; DMAO config 


out 

dx. 

ax 

; DMA channel 

0 enabled 

pop 

ds 




_wash_ptr 

+= 

128; 

/* 64 words = 128 

bytes were washed 

(ram_wash_ptr 

> (BYTE huge 

*)0X7FFFFFFF) 



ram_wash_j>tr = {BYTE huge *)0; 
raTn_wa sh_cy c 1 e s++; 

} 


} /* End of edac_ram_wash0 */ 

End of edac.h, edac.c 


158 



eps.h, eps.c 

/***************************************************************************** 

* 

* EPS.H 

* 

* Defines for the RF unit interface routines. 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 

* Date Who What 

* - + - + --- 

* 30 Oct 1996 Jah Creation 

* 

*****★*****************************★***************************♦***********★/ 


/* Power control defines */ 
#define pwr_tmuxa o 

#define PWR_MSA 1 

#define PWR_HEATA 2 

#define PWR_HEATB 3 

#define PWR_RF 4 

#define PWR_TMUXB5 
#define PWR_MSB 6 

#define PWR_ANTREL 7 

/* Battery Control defines */ 


#define BAT_ONLINE 1 
#define BAT_OFFLINE 2 
#define BAT_TRICKLE_ON 3 
#define BAT_TRICKLE_OFF 4 
#define BAT_CHARGE__ON 5 
tdefine BAT CHARGE OFF 6 


#define BAT_DISCHARGE_ON 7 
#define BAT_DISCHARGE_OFF8 


#ifdef EPS 

#define POWER_ON_DELAY 0x1FFF 

voideps_batts_of f (int) ; 

voideps_global_of f (void) ; 

void eps_set__port2 (BYTE value) ; 

BYTE eps_get_port2 (void) ; 

BYTE eps_get_battery (void) ; 

int eps_set_battery(int battery, int mode); 

WORD eps_get_power(void); 

void eps_set_power(int device, int mode); 

void eps_reset_wdog (void) ; 

#endif 


#ifndef EPS 


extern 

void 

eps_batts_off(int); 

extern 

void 

eps_global_off(void); 

extern 

void 

eps_set_port2 (BYTE value); 

extern 

BYTE 

eps__get_port2 (void) ; 

extern 

BYTE 

eps_get_battery(void); 

extern 

int 

eps_set_battery(int battery, int mode) 

extern 

WORD 

eps_get_power(void); 

extern 

void 

eps_set_power(int device, int mode); 

extern 

void 

eps_reset_wdog(void); 


#endif 


159 







* EPS.C 

★ 

* Interface routines for the EPS unit. 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* Date Who What 


* 30 Oct 1996 Jah Creation 

* 6 Dec 1996 Jah Changed port settings per Ron’s EPS modifications 

* 25 Feb 1997 Jah Keep Port 2, Bit l always on (the current MUX enable) 

*****************************************★*************♦********************/ 


#include "gen_defs.h" 

#define EPS 

#include "eps.h” 

#undef EPS 


#include "bcm.h” 
#include "pcb.h" 


int check_bat(int battery, BYTE mask); 


static BYTE portO = 0; 

static BYTE port2 = 0x01; /* Current MUX enabled */ 

static BYTE porte = 0; 


* 

* eps_batts_off() 

* 

* Power OFF all battery controls, EXCEPT the battery ONLINE controls. 

* 


voideps_batts_off(int online) 

{ 

if (online == BAT_A) 

{ 

portO &= OxOF; /* all Battery A controls to be turned OFF */ 

portO 1= 0x20; /* Battery A ONLINE to be turned ON */ 

porte = 0; /* all Battery B controls to be turned OFF */ 

/* Write to portO FIRST to insure there remains a battery online */ 

pcb_write(EPSO, 0, portO); 
pcb_write(EPSl, 2 , port6); 

} 


else if (online -* BATE) 

{ 

/* Turn OFF All battery controls to A */ 

portO &= OxCF, /• ALL battery A controls to be turned OFF */ 

porte = Cx2C, /* Battery B controls to be turned OFF, except ONLINE = ON */ 

/* Write to Pert6 FIRST to insure there remains a battery online */ 
pcb_write( tPS: . 2 . port6); 
pcb_write (EP.S'.,, C. portO); 

} 


} /* End of eps_battE_o{f (1 •/ 

★ 

* eps_global_off() 

★ 

* Power OFF all subsystems, and all 

* ONLINE controls. 

* 

★♦★*********************************^ 

void eps_global_off(void) 


battery controls, EXCEPT the battery 


160 





{ 


portO &= 0x20; 

pcb_write (EPSO^ 0, portO) ; /* All OFF except the online (if it is on) */ 

port2 = 0x01; 

pcb_write(EPSO, 2 , port2); /* Other subsystem power */ 

port6 &= 0x20; 

pcb_write (EPSl, 2 , port6) ; /* Battery B control OFF except the online (if it is on) */ 

} /* End of eps_global_off0 */ 


/♦★*************************************************************************** 

* 

* eps_set_port2() 

■k 

* Power ON or OFF a subsystem, leaving others undisturbed. 

* 

********************************************************★*******************/ 

void eps_set_port2(BYTE value) 

{ 

port2 = value | 0x01; /* Keep Current MUX enabled */ 

pcb_write(EPSO, 2, port2); 

} /* End of eps_set_port2 () */ 


/*********************************************,*********★****♦********★******** 

* 

* eps_get_port20 

* 

* Power ON or OFF a subsystem, leaving others undisturbed. 

* 

****************************************************************************/ 

BYTE eps_get_port2 (void) 

{ 

return(port2); 

} /* End of eps_get_port2 () */ 

/*************★****************************************♦*★******************** 

* 

* eps_get_power(} 

* 

* Get power ON or OFF status for the subsystems. 

★ 

**********★*♦***★**************************★**★***★*************************/ 

WORD eps_get_power(void) 

{ 

/* LSB is power bits of Port 0, MSB is power bits of Port 2 

* Other bits pertaining to battery control, unused bits, or the 

* S/P current inhibit and strobe are maksed off to 0. 

*/ 

return( (((WORD)port2 & 0x007C) « 8) | ((WORD)portO & OxOOOD)); 

} /* End of eps_get_power0 */ 

/***************************************************************************** 


* ep s_s e t_powe r() 

* 

* Power ON or OFF a subsystem, leaving others undisturbed. 

* 

************★*******************★**************★********★*******************/ 


void eps_set_power(int select, int mode) 

{ 

register BYTE temp, mask; 

WORD delay; 


/* This table contains bit positions in EPS ports 0 & 2 for power control 
* bits for the subsystems, heaters, and antenna release. 

*/ 

static WORD power_table [) = {4, 8, 1, 0x40, 0x20, 0x10, 8, 4}; 


switch(select) 


161 


/* Port 0 Power Controls */ 
case PWR_TMUXA: 
case PWR_MSA: 
case PVrR_HEATA: 

if (mode == ON) 

portO j= power_table[select] ; 
else if (mode == OFF) 

portO Sc~ --power_table [select] ; 

else 

return; 

pcb_write(EPSO, 0, portO); 
break; 

/* Port 2 Power Controls */ 

case PWR_HEATB: 

case PWR_RF; 

case PWR_TMUXB: 

case PWR__MSB: 

case PWR_ANTREL: 

if (mode == ON) 

port2 1= power_table[select]; 
else if (mode == OFF) 

port2 &= -power_table[select] ; 

else 

return; 

pcb_write(EPSO, 2, port2); 
break; 

default: 
break; 

) 

if (mode == ON) 

for (delay = 0; delay < POWER_ON_DELAY; delay++) 


} /* End of eps_set_power() */ 


♦ 

* eps_get_battery() 


BYTE eps_get_battery (void) 

{ 

/* MSnibble is Battery A contorl bits of Port 0, LSnibble is Battery B 

* control bits of Port 6. Other bits pertaining to battery control, 

* unused, or the S/P current inhibit and strobe are maksed off to 0. 

*/ 

return(((porte & 0xF0)>>4) j (portO & OxFO)); 

} /* End of eps_get_battery() */ 


/ 




* eps_set_battery0 

* 

********************ir*±*********irir***1r******it********ir*********1tir*fk********/ 

^define MASK_AND 1 

^define MASK_OR 2 


int eps_set_battery(int battery, int mode) 

{ 

register BYTE temp, mask; 


Ewitch (mode) 

{ 

case BAT_CHARGE_ON: 

temp = 0x80; mask = MASK_OR; break; 
case BAT_CHARGE_OFF: 

temp = -0x80; mask = MASK_AND; break; 

case BAT_DISCHARGE_ON: 

temp = 0x40; mask = MASK_OR; break; 
case BAT_DISCHARGE_OFF: 

temp = -0x40; mask = MASK_AND; break; 


162 




case BAT_ONLINE: 

temp = 0x20; mask = MASK_OR/ break; 
case BAT_OFFLINE: 

temp = -0x20; mask = MASK_AND; break; 

case BAT_TRICKLE_ON: 

temp = 0x10; mask = MASK_OR; break; 
case BAT_TRICKLE_OFF: 

temp = -0x10; mask = MASK_AND; break; 

default: 

break; 

) 

switch(battery) 

{ 

case BAT_A: 

if ((mask == MASK_OR) && check_bat(BAT_A, temp)) 
portO 1= temp; 
else if (mask == MASK_AND) 
portO &= temp; 

else 

{ 

dprint("EPS: battery control command error - state not allowed\n'') ; 
return (ERROR) ; 

} 

pcb_write(EPSO, 0, portO); 
break; 

case BAT_B: 

if ((mask == MASK_OR) && check_bat(BAT_B, temp)) 
ports 1= temp; 
else if (mask == MASK_AND) 
ports &= temp; 

else 

{ 

dprint("EPS: battery control command error - state not allowed\n”); 
return(ERROR); 

) 

pcb_write(EPSl, 2, ports); 
break; 

default: 

break; 

} 


return(NO_ERROR); 

} /* End of eps_set_battery0 */ 


/*************★*★************♦*****************************♦**************■**** 

* 

* check_bat() 

* 

* Check to make sure that the new battery control desired to be turned 

* on does NOT conflict with other settings that are already on. 

* 

★***********♦***************************************************************/ 


int check_bat(int battery, BYTE mask) 

{ 

/* Allowed battery ON setting compared to existing settings */ 

/* This table is read with the row being the battery ON setting 

* that is desired. The first four entries are for battery A, the 

* following four are for battery B. The columns represent 

* settings already set ON for battery control; again, the first four 

* are for battery A, the remaining for for battery B. 

* If there is a 1, then the new setting is NOT allowed. A zero indicates 

* the new setting is allowed. 


B Trickle 

B Online - 

B Discharge 
B Charge 
A Trickle 
A Online — 
A Discharge 


-^ I 

1 

-.+ I I 

I I 
* I I I 

I I I 
^ I I I 
I I I I 
I I I I 

I I I I I 
I I I I I 

163 


I 

I 

I 










A Charge ---+ | i | | i | j 

VVVVVVVV 

(hex) 80 40 20 10 08 04 02 01 

bat_table [8] = { 

/* A Charge */0x59, 

/* A Discharge */0xB4, 

/* A Online */0x40, 

/* A Trickle */0xC9, 

/* B Charge */0x95, 

/* B Discharge */0x4B, 

/* B Online */0x04, 

/* B Trickle */0x9C}; 

int i ; 


switch(mask) 

{ 

case 0x10: /* Trickle */ 

i = 3; break; 
case 0x20: /* Online */ 

i = 2; break/ 

case 0x40: /* Discharge */ 

i = 1; break,- 
case 0x80: /* Charge */ 

i = 0; break; 

} /* End of SWITCH */ 

if (battery == BAT_B) 
i += 4; 

/* i is the index into the table */ 

/* The table ANDed with the current information regarding which battery 

* switches are set (ON) are used to see if the new ON request is 

* allowed. 

*/ 

if (bat_table [i] & eps__get_battery () ) 

return(FALSE); /* not allowed */ 

else 

return(TRUE); 

} /* End of check_bat() */ 


/********♦****♦*♦**************•****************★*★**************************** 

* 

* ep s_re s e t_wdog() 

* 

* Toggle the EPS Watch Dog timer so that the EPS will not reset the current 

* active System Controller. This is done using Port 4 of the EPS. 

* 

***********ic******1r******1r***********-k1r-k**********icir****-k-k*ir-k*1t*****1,*1r*iric*it/ 

void eps_reset_wdog (void) 

{ 

WORD i ; 


pcb_write(EPSl, 0, 1 ) ; 
for (i = 0; i < OxlFFF; i++) 


pcb_write(EPSl, 0, 0); 

} /* End of eps_reset_wdog() */ 


End of eps.h, eps.c 


*/ 

static WORD 


164 


gen_apis.h, gen_apis.c 

/***************************************************************************** 

★ 

* GEN_APIS.H 

* 

* Include file for general functions. 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 


* Revision History: 

* Date Who What 


* 5 Sept 1996 Jah Creation 

* 


#ifdef GEN_APIS 

WORD crc_calc (WORD crc, BYTE data); 

WORD check_crc (void *ptr, int size); 

WORDdisable_ints (void) ; 
void enable_ints (void) ; 

WORDprepare_crc (void *ptr, int size) ; 

#endif 

/* prototypes for modules other than msu.c */ 
#ifndef GEN_APIS 

extern WORD crc_calc(WORD crc, BYTE data); 

extern WORD check_crc(void *ptr, int size); 

extern WORD disable_ints(void); 

extern void enable_ints(void); 

extern WORD prepare_crc(void *ptr, int size); 

extern const WORDcrc_table []; 


#endif 


/*************************★***************************************★*********** 

* 

* GEN_APIS.C 

* 

* General functions available to .c files.. 

★ 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* Date Who What 


* 21 Oct 1996 Jah Creation 

* 

•k***ir***'k1fk***ir**i[i[***icit*-k*ic-k***********ir**-k*********ie***ir*****-ii*****ic1fk1r1eie*/ 


#include "gen_defs.h" 

#define GEN_APIS 

#include ''gen_apis .h" 
#undef GEN APIS 


/* CRC lookup table for all 256 CRC combinations from an 8-bit value */ 
#define CRC_TABLE_LEN 256 

static const WORD crc_table [CRC_TABLE_LEN] = 

{ 


0x0000, 

0x1189, 

0x2312, 

0x329B, 

0x4624, 

0x57AD, 

0x6536, 

0x74BF, 

0x8C48, 

0X9DC1, 

OxAFSA, 

0XBED3, 

0XCA6C, 

OxDBEB, 

0XE97E, 

0XF8F7. 

0x1891, 

0x0918, 

0x3B83, 

OX2A0A, 

0x5EB5, 

0X4F3C, 

0X7DA7, 

0X6C2E, 

0x94D9, 

0x8550, 

0xB7CB, 

0XA642, 

0XD2FD, 

0XC374, 

OxFlEF, 

0XE066, 

0x3122, 

0x2OAB, 

0x1230, 

0x0369, 

0x7706, 

0x668F, 

0x5414, 

0x459D, 

0xBD6A, 

0XACE3, 

0x9E78, 

OxSFFl, 

0xFB4E, 

0XEAC7, 

0XD85C, 

165 

0xC9D5, 









}; 


0x29B3, 
OxABFB, 
0x6244, 
OxEEOC, 
0X7AD5, 
0xF69D, 
0x5366, 
0xDF2E, 
0X4BF7, 
0xC7BF, 
0xC488, 
0x48C0, 
0XDC19, 
0x5051, 
OxFSAA, 
0x79E2, 
0xED3B, 
0x6173, 
0xA6CC, 
0x2A84, 
OxBESD, 
0x3215, 
0x97EE, 
0xlBA6, 
0X8F7F, 
0x0337, 


0x383A, 
0x6472, 
0x73CD, 
0xFF85, 
0X6B5C, 
OxE714, 
0x42EF, 
OxCEA7, 
0x5A7E, 
0xD636, 
0XD501, 
0x5949, 
0XCD90, 
0x41D8, 
0XE423, 
0x686B, 
0XFCB2, 
0X70 FA, 
OxB745, 
0X3B0D, 
0XAFD4, 
0X239C, 
0x8667, 
OxOA2F, 
0X9EF6, 
0X12BE, 


OxOAAl, 
0x86E9, 
0x4156, 
OxCDlE, 
0X59C7, 
0XD58F, 
0x7074, 
0XFC3C, 
0X68E5, 
0xE4AD, 
0xE79A, 
0x6BD2, 
OxFFOB, 
0x7343, 
0XD6B8, 
0X5AF0, 
0xCE2 9, 
0x4261, 
Ox85DE, 
0x0996, 
0x9D4F, 
0x1107, 
0xB4FC, 
0x38B4, 
0XAC6D, 
0x2025, 


OxlB28, 
0x9760, 
0x5ODF, 
0xDC97, 
0x484E, 
0XC406, 
0x6IFD, 
OxEDBS, 
0X796C, 
0XP524, 
0xF613, 
0x7A5B, 
0xEE82, 
0x6 2 CA, 
OxC731, 
0X4B79, 
OxDFAO, 
0X53E8, 
0x9457, 
0X181F, 
0X8CC6, 
OxOOSE, 
0XA575, 
0x293D, 
0XBDE4, 
0x31AC, 


0x6F97, 
OxE3DF, 
0x2460, 
OxA828, 
0X3CF1, 
0XB0B9, 
0x1542, 
0X990A, 
0x0DD3, 
0X819B, 
0x82AC, 
0x0EE4, 
0X9A3D, 
0x1675, 
0XB38E, 
0x3FC6, 
OxABlF, 
0x2757, 
OxEOES, 
0x6CA0, 
0XF879, 
0x7431, 
OxDlCA, 
0X5D82, 
0XC95B, 
0x4513, 


0x7ElE, 
0XF256, 
0x35E9, 
0XB9A1, 
0X2D78, 
OXA130, 
0X04CB, 
0x8883, 
0X1C5A, 
0x9012, 
0x9325, 
0X1F6D, 
0X8BB4, 
0X07FC, 
0XA207, 
0x2E4F, 
0XBA96, 
0x36DE, 
0XF161, 
0X7D29, 
0XE9F0, 
0X65B8, 
OXC043, 
0x4C0B, 
0xD8D2, 
0x549A, 


0x4C85, 
OxCOCD, 
0x0772, 
0x8B3A, 
0X1FE3, 
0X93AB, 
0x3650, 
OxBAie, 
0X2EC1, 
0XA289, 
OxAlBE, 
0x2DF6, 
0XB92F, 
0x3567, 
0X909C, 
0x1CD4, 
0X880D, 
0x0445, 
0xC3FA, 
Ox4FB2, 
0XDB6B, 
0x5723, 
0xF2D8, 
0X7E90, 
0XEA49, 
0x6601, 


OxSDOC, 
OxD144, 
0x16 FB, 
0X9AB3, 
0X0E6A, 
0x8222, 
0x27D9, 
0xAB91, 
0x3F48, 
0xB300, 
0XB037, 
0x3C7F, 
OxA8A6, 
Ox24EE, 
0x8115, 
OxODSD, 
0x9984, 
Oxl5CC, 
0XD273, 
0x5E3B, 
0XCAE2, 
0x46AA, 
0XE351, 
Ox6F19, 
OxFBCO, 
0x7788 


static WORD ints_disabled = FALSE; 


/*****************************************************★*********************** 

* 

* WORD crc_calc (WORD crc, BYTE data) 

* 

* Takes a CRC and a new data byte and computes a new CRC, 

* 

****************************************************************************^ 

WORDcrc_calc(WORD crc, BYTE data) 

{ 

return((crc » 8) ^ crc_table[data ^ (crc & OxFF)]); 

} /* End of crc_calc() */ 

/***************************<f************************************************* 

* 

* WORDcheck_crc(void *ptr, int size) 

* 

* Check an arbitrary lengthed buffer with its CRC. This function assumes 

* that the buffer has the CRC appended to the data. The CRC is returned. 

* 

****************************************************************************/ 


WORDcheck_crc (void *ptr, int size) 

{ 

int i ; 

WORD crc ; 

BYTE * p = (BYTE *)ptr; 


for (i = 0, crc = 0; i < size; i++) 
crc = crc_calc(crc, *p++); 

return(crc); 

} /* End of prep_crc() */ 


/*************★*************************************************************** 

* 

* WORDprepare_crc (void *data, int size) 

* 

* Prepare an arbitrary lengthed buffer with its CRC by calculating the CRC 

* and then appending it to the end of the buffer. This function assumes 

* that the buffer is prepared with a length of 2 greater than the data. 

* The high-byte of the CRC is written first, the low-byte follows. The CRC 

* is returned, 

* 

*★************************************★*********♦*************★*************/ 
WORDprepare_crc(void *ptr, int size) 


166 



{ 

int i; 

WORDcrc; 

BYTE*p = (BYTE *)ptr; 


for (i = 0, crc =0; i < size; i++) 
crc = crc_calc(crc, *p++); 

*p++ = (BYTE) ( (crc & OxFFOO) » 8) ; 
*p = (BYTE)(crc & OxOOFF); 

return(crc); 

} /* End of prep_crc() */ 


/***★♦♦******************★*****★************★*********★*********************** 

* 

* WORDdisable_ints() 

* 

* Disable interrupts (if they are not already disabled) . And set the 

* ints_disabled flag to TRUE, indicating that interrupts are no longer 

* enabled. Return the flag which is used to control wether or not interrupts 

* should be re-enabled. 

* 

********************♦*******************************************************/ 


WORDdisable_ints (void) 

{ 

if (!ints_disabled) 

{ 

_disable(); 
ints_disabled = TRUE; 
return(ints_disabled); 

} 


else 

return (FALSE) ; 

} /* End of disable_ints0 */ 

/********♦******************************************** ************* *********** 
* 

* voidenable_ints0 

* 

* Enables interrupts and marks the ints_disabled flag accordingly. 

* 

****************************************************************************yr 

voidenable_ints (void) 

{ 

_enable 0; 

ints_disabled = FALSE; 

} /* End of enable_ints0 */ 

End of gen_apis.h, gen_apis.c 


167 



gen_defs.h 

/****************************************************★************************ 

* 

* GEN_DEFS.H 

* 

* Include file for general definitions used by most .h and .c files.. 

★ 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 

* 

* Date Who What 

* -+ - - - 

* 8 Sept 1995 Jah Creation 

* 

*************♦******************************************************♦***+***/ 

typedef unsigned char BYTE; 

typedef unsigned int WORD; 

typedef unsigned long int DWORD; 


#define FALSE 0 

#define TRUE 1 

#define ERROR 0 

#define NO_ERROR 1 

#define OFF 0 

#define ON 1 

#define RESET 0 

#define SET 1 

#define NULL ’\0' 


/* Character definitions for ASCII */ 
#define NULL_CHAR (char)0x00 

#define BELL {char)0x07 

#define BACK_SPACE (char)0x08 

#define LF (char)OxOA 

tdefine CR (char)OxOD 

#define ESC (char)OxlB 

#define CTRL_Q (char)0x11 

#define CTRL_R (char)0x12 

#define CTRL_S (char)0x13 

#define CTRL_V (char)0x16 

#define CTRL_W (char)0x17 

#define CTRL_X (char)0x18 

#define CTRL_Y (char)0x19 

#define CTRL_Z (char)OxlA 

#define HOME (char)OxlE 

#define NEW_LINE (char)OxlF 


#define MAX_UCHAR (unsigned char) 255 


#define 
#define 
#define 
#define 

MAX_ 

MAX_ 

MAX_ 

MAX_ 

CHAR 

'UINT 

_INT 

_ULONG 

(signed char) 
(unsigned int) 

(int) 

(unsigned long 

int) 

127 

65535 

32767 

4294967295 

#define 

max' 

LONG 

(long int) 

2147483647 


/* DMA Registers 

*/ 

#define 

DOSRCH 

0XFFC2 

#define 

DOSRCL 

OxFFCO 

#define 

DODSTH 

OxFFCe 

#define 

DODSTL 

0xFFC4 

#define 

DO CON 

OxFFCA 

#define 

DOTC 0XFFC8 

#define 

DISRCH 

0xFFD2 

#define 

DISRCL 

OxFFDO 

#define 

DIDSTH 

0xFFD6 

#define 

DIDSTL 

0XFFD4 

#define 

DICON 

OxFFDA 

#define 

DITC OxFFDS 


168 





/* operating Frequencies */ 

#define CRySTAL_FREQUENCY14.7456E+6 

/* Peripheral Clock: half the frequency of the crystal frequency */ 
#define PCLK { (double) (1.0/ (CRYSTAL_FREQUENCY/2.0) ) ) 


End of gen_defs.h 




int.h, intc 

* 

* INT.H 


* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* Date Who What 




#define INT_EOI 0xFF22 

#define INT__REQ_REG 0xFF2E 


* 

* INT.C 


* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School, 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* Date Who What 


****#***********************************************************************/ 

#include "gen_defs,h" 

#define INT_C 

#include "int.h" 

#undef INT_C 


End of int.h, into 


170 









modem.h, modem.c 

/**************************★******★****♦*****************♦***********★★******* 

* 

* MODEM.H 

* 

* MODEM 

★ 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 

★ 

* Date Who What 

* -+-+- 

* 17 July 1996 Jah Creation 

★ 

***********************************************★****************************/ 


typedef struct 

{ 

BYTE address; 

BYTE data; 

} palOO_instr_struct; 


#ifdef MODEM 

#define PA100_BASE 0x200 

#define MODEM CTRL PORT 0x180 


#define 
#define 
#define 
#define 


MODEM_SETUP 0x00/* Encode^OFF,DDS=OFF,Spread=OFF,Reset =OFF */ 

MODEM_RESET 0x01/* Encode=OFF,DDS=OFF,Spread=OFF,Reset=ON */ 

MODEM_CLEAR OxOC/* Encode=ON,DDS=ON, Spread=OFF, Reset=OFF */ 

MODEM_SPREAD OxOE/* Encode=ON, DDS=ON, Spread=ON, Reset=OFF */ 


voidmodem_clear (void) ; 
voidmodem_of f (void) ; 
voidmodem_on (void) ; 
voidmodem_spread (void) ; 


void pal 00_read_regs (void) ; 

voidpal00_write_table (pal00_instr_struct tablet] ) ; 


#endif 


#ifndef MODEM 

extern void 
extern void 
extern void 
extern void 

extern void 
extern void 

#endif 


modem_clear(void); 
modem_off(void); 
modem_on(void); 
modem_spread(void); 

pal00_read_regs(void); 

pal00_write_table (pal00_instr_struct table []) ; 


171 






/*******ic****ir******ir**it1r*-k*1t1t****ir*******it*ir****it***1t**1e**1r********-k*******ic* 

* 

* MODEM.C 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 


Date Who What 


* 17 July 1996 Jah Creation 

* 

************♦**********************************★****************************/ 

#include "gen_defs.h” 

#define MODEM 

#include "modem.h” 

#undef MODEM . 

tinclude "pcb.h" 


static palOO_instr_struct pal00_init[] = 

{ 

{0x01, 0xC6}, /* ALPHA_I FIR filter weights */ . 

{0x04, 0xC6}, /* ALPHA_Q */ 

{0x02, 0x00}, /* IBI__L0 DC removal filter, I channel bias */ 

{0x03, 0xE2}, /* */ 

{0x05, 0x00}, /* QBI_L0 DC removal filter, Q channel bias */ 

{0x06, 0xE2}, /* QBI_HI */ 

/* AGC */ 

{0x07, 0x22}, /* AGC_L AGC reference Level */ 

{0x08, 0x38}, /* AGC_G AGC proportional & saturated gains */ 

{0x09, 0x00}, /* AGC_I AGC initial value */ 

{OxOA, 0xF5}, /* GP1_CTL Init. AGC, apply DC removal filter initial bias */ 

{OxOA, OxFO}, /* GP1_CTL Let AGC free run, remove DC filter initial bias */ 

/* PN Generators */ 

{0x19, 0x00}, /* I_PNT_LO I PN generator taps */ 

{OxlA, 0x82}, /* I_PNT_HI */ 

{0x17, 0x00}, /* l_PNI_LO I PN generator initial register setting */ 

{0x18, OxBE}, /* I_PNI_HI */ 

{OxlD, 0x00}, /* Q_PNT_LO Q PN generator taps */ 

{OxlE, 0x82}, /* Q_PNT_HI */ 

{OxlB, 0x00}, /* Q_PNI_LO Q PN generator initial register setting */ 

{OxlC, OxBE}, /* Q_PNI_HI */ 

{OxlF, 0x77}, /* PN_CNTL0 */ 

{0x20, 0x05}, /* PN_CNTL1 */ 

/* PN Detector */ 

{0x22, 0x00}, /* PNSEL PN detection code select (I or Q code) */ 

/* General Controls */ 

{0x28, 0x39}, /* CNTL_B2 Enable time/level/phase strobes, set polarities */ 

{0x29, 0x01}, /* CNTL_B3 unfreeze, enable output data clock */ 

{0x2A, 0x00}, /* EXT_IN External data input controls */ 

{0x2B, 0x00}, /* GP_3 Clear i/o muxing */ 

{0x2C, OxEA) , /* CNTL_AS Select symbol strobes used by accumulators */ 

/* Phase Loop */ 

{0x39, 0x00}, /* PH_FREQ_0 Phase accumulator initial value */ 

{0X3A, 0x00}, /* PH_FREQ_1 */ 

{0x3B, 0x00}, /* PH_FREQ_2 */ 

{0x3C, 0x00}, /* PH__FREQ_3 */ 

/* Time Loop */ 

{0x14, OxFA}, /* TIM_CTL2 Set subchip and chip counter sync, source */ 

{0x33, 0x09}, /* TM_WIDTH Freq Synth Ctrl Word width = 32-TM_WIDTH bits */ 

{OxOC, 0x00}, /* SC_LO Samples per subchip = 0 */ 

{OxOD, 0x00}, /* SC__HI Clear mode for initialization */ 

{OxOE, 0x00}, /* CHIP Subchips per chip = 0, clear mode for init */ 

{OxOF, 0x00}, /* I_SYM_HI I channel; chips per symbol = 0 */ 

{0x10, 0x00}, /* I_SYM_LO Clear mode for initialization */ 

{0x11, 0x00}, /* Q_SYM_HI Q channel: chips per symbol - 0 */ 

{0x12, 0x00}, /* Q_SYM_LO */ 

{0x15, 0x02}, /* TIM_CTL3 Toggle SYS_INIT, set I strobe via I, Q via Q */ 

{0x15, 0x42}, /* TIM_CTL3 Set I & Q PN to (2^N)-1 or 2^N */ 

{0x15, 0x02}, /* TIM_CTL3 Set I Strobe from I channel, Q via Q channel */ 

{0x2D, 0x00}, /* TM_FREQ_0 Rs, sample clock = 10 MHz for initialization */ 

{0x2E, 0x00} , /* TM_FREQ_1 */ 

{0x2F, 0x00}, /* TM_FREQ_2 */ 

{0x30, 0x80}, /* TM_FREQ_3 */ 

{0x31, 0x00}, /* TM_GAIN_1 Open Timing Loop */ 

{0x32, 0x80}, /* TM_GAIN_2 Initialize Timing Loop */ 

172 




{0x32, 0x00}, /* TM_GAIN_2 Stop initializing loop */ 

{OxFF, OxFF) /* End */ 

}; 


static palOO_instr_struct pal00_clear[] = 
{ 


{OxOB, 


0x00}, 

/* 

PA_SC 

PREACCUMULATOR SCALING CONSTANT */ 



/* PN 

GENERATORS 

*/ 





{0x21, 


0x20}, 

/* 

CC 

FREQ. DISC. ON,SET INT PN, I&Q PN 

ON/OFF 

*/ 

{0x26, 


0x24}, 

/* 

CNTL_B0 

QUADRAPHASE DATA, SEL LEVEL $ TIME 

CHANNEL */ 

{0x27, 


0x3B}, 

/* 

CNTL_B1 

ENABLE DATA REMOVAL, SELECT PHASE 

CHANNEL 

. */ 

/* TIME 

ERROR DETECTOR PROCESSOR */ 



{0x23, 


0x55}, 

/* 

I Q TIME 

SET SCALE FACTORS FOR TIMING ACCUMULATOR 

*/ 

/* PHASE 

LEVEL PROCESSOR */ 




{0x24, 


0x55}, 

/* 

I_Q_LEVEL 

SET SCALE FACTORS FOR LEVEL ACCUMULATOR * 

/ 

{0x25, 


0x55}, 

/* 

I_Q_PHASE 

SET SCALE FACTORS FOR PHASE ACCUMULATOR * 

/ 

/* TIME 

LOOP */ 






{OxOC, 


0x3F}, 

/* 

SC_LO 

Samples per subchip - 0 */ 



{OxOD, 


0x00}, 

/* 

SC_HI 

clear mode for initialization */ 



(OxOE, 


0x00}, 

/* 

CHIP 

Subchips per chip = 0, clear mode 

for init */ 

joxOF, 


0x00}, 

/* 

I_SYM_HI 

I channel: chips per symbol ~ 0 */ 



joxlO, 


OxOl), 

/* 

I_SYM__LO 

clear mode for initialization */ 



{Oxll, 


0x00}, 

/* 

Q_SYM_HI 

Q channel: chips per symbol = 0 */ 



{0x12, 


0x01}, 

/* 

Q_SYM_LO * 

/ 



{0x13, 


0x00}, 

/* 

TIM_CTL1 

NO CODE SLIPPING, CLEAR MODE */ 



{0x16, 


0x00}, 

/* 

TIM_CTL4 

CLEAR MODE, DISABLE */ 



{0x13, 


0x00}, 

/* 

TIM_CTL1 

NO CODE SLIPPING 



{0x2D, 


0x00}, 

/* 

TM_FREQ_0 

Rs, sample clock = START AT 10 MHz 

*/ 


{0x2E, 


0x00}, 

/* 

TM__FREQ_1 

*/ 



{0x2F, 


0x00), 

/* 

TM_FREQ_2 

*/ 



{0x30, 


0x80}, 

/* 

TM_FREQ_3 

*/ 



{0x31, 


0x58}, 

/* 

TM_GAIN_1 

Open Loop, ARM TO CLOSE ON PN DET, 

SET K1 

*/ 

{0x32, 


OxDl}, 

/* 

TM_GAIN_2 

LOAD FILTER WITH INITIAL VALUE, SET GAIN 

K2 */ 

/* PN 

DETECTOR */ 






{0x35, 


0x00}, 

/* 

PNCD_BIAS 

PN DETECTOR BIAS LEVEL */ 



{0x36, 


0x00}, 

/* 

PNCD_INITLO PN DETECTOR ACCUMULATOR */ 



{0x37, 


0x00}, 

/* 

PNCD_INITHI */ 



{0x38, 


OxFF}, 

/* 

PNCD_TIM 

PN DETECTOR CORRELATION TIMER */ 



/* PHASE 

LOOP */ 






{0x3D, 


0x7F}, 

/* 

PH_GAIN_1 

CLOSE THE LOOP, MAKE LOOP FIRST ORDER */ 


{0x3E, 


0xD4}, 

/* 

PH_GAIN_2 

LOAD ACCUM WITH INITIAL VALUE, SET 

GAIN K2 */ 


/* TIME LOOP */ 

(0x15, 0x42), /* SYS_INIT */ 

{0x15, 0x02}, /* SyS_INIT */ 

A PN DETECTOR */ 

(0x34, 0x00}, /* PNCD_CTL PN DETECTOR ACQ/TRACK CONTROLLER */ 

{0x34, 0x04}, /* PNCD_CTL RESTART TRACK SEQUENCE */ 

{0x34, 0x00}, /* PNCD_CTL */ 

/* TIME LOOP */ 

{0x32, 0x51}, /* TM_GAIN_2 Stop LOADING TIME LOOP FILTER WITH INIT VALUE */ 

/* FREQUENCY PULLIN/TRACK SETUP TABLE */ 

/* PN GENERATORS */ 

{0x21, 0x20}, /* CC FREQ. DISC. ON, SET INT PN, I&Q PN ON/OFF */ 

/* PHASE LEVEL PROCESSOR */ 

{0x26, 0x28}, /* CNTL_B0 QUADRAPHASE DATA, SELECT LEVEL $ TIME CHANNEL */ 

{0x27, 0x3B}, /* CNTL_B1 ENABLE DATA REMOVAL, SELECT PHASE CHANNEL */ 

{0x3D, 0x7F}, /* PH_GAIN_1 CLOSE THE LOOP, MAKE LOOP FIRST ORDER */ 

{0x3E, 0x54}, /* PH_GAIN_2 LOAD ACCUM WITH INITIAL VALUE, SET GAIN K2 */ 

/* TIME ERROR DETECTOR PROCESSOR */ 

{0x23, 0x55}, /* I_Q_TIME SET SCALE FACTORS FOR TIMING ACCUMULATOR */ 

/* PHASE LEVEL PROCESSOR */ 

{0x24, 0x55}, /* I_Q_LEVEL SET SCALE FACTORS FOR LEVEL ACCUMULATOR */ 

{0x25, 0x55}, /* I_Q_PHASE SET SCALE FACTORS FOR PHASE ACCUMULATOR */ 

/* COHERENT TRACK SETUP TABLE */ 

{0x3D, 0x54}, /* PH_GAIN_1 CLOSE THE LOOP, MAKE LOOP FIRST ORDER */ 

{0x3E, 0x4E}, /* PH_GAIN_2 LOAD ACCUM WITH INITIAL VALUE, SET GAIN K2 */ 

/• PHASE LEVEL PROCESSOR */ 

{0x26, 0x00}, /* CNTL_B0 QUADRAPHASE DATA, SELECT LEVEL $ TIME CHANNEL */ 

{0x27, 0x3D}, /* CNTL_B1 ENABLE DATA REMOVAL, SELECT PHASE CHANNEL */ 

/* PN GENERATORS */ 

{0x21, 0x00}, /* CC FREQ. DISC. ON, SET INT PN, I&Q PN ON/OFF */ 

/* TIME ERROR DETECTOR PROCESSOR */ 

{0x23, 0x55}, /* I_Q_TIME SET SCALE FACTORS FOR TIMING ACCUMULATOR */ 

/* PHASE LEVEL PROCESSOR */ 

{0x24, 0x55}, /* I_Q_LEVEL SET SCALE FACTORS FOR LEVEL ACCUMULATOR ♦/ 

{0x25, 0x55}, /* I_Q_PHASE SET SCALE FACTORS FOR PHASE ACCUMULATOR */ 

{OxFF, OxFF} /* End */ 

}; 


173 





* modeTn_clear () 

★ 

****************************************************************************/ 

voidmodem_clear (void) 

{ 

modeTn_on () ; 

/* outp (MODEM_CTRL_PORT, MODEM_SETUP) ; */ /* done by modem_on () */ 

palOO_write_table(pal00_init); 
outp(MODEM_CTRL_PORT, MODEM_CLEAR); 
palOO_write_table {palOO__clear) ; 

} /* End of modem_clear() */ 

/***************************************************************************** 

* 

* modem_off() 

* 

****************************************************************************^ 

voidinodem_of f (void) 

{ 

pcb_portc(0, ON); /* Turn this control bit ON to turn OFF modem */ 

} /* End of modem_off() */ 

/********-k*-k-k*-k* 1 ,***’kic*-k-kifk**ifk********-k**ir*-k******-ki,*****-k-k-k*-k*-k 1 titi, 1 e**-k-k**-k*-k 

★ 

* modem_on() 

* 

************************★★********************************♦♦**********★*****/ 

void modem_on (void) 

{ 

WORDx; 

P^^_pc>rtc (0, OFF) ; /* Turn this control bit OFF to turn ON modem */ 

for (x = 0; X < OxFFFF; x++) 

ou tp(MODEM_CTRL_PORT, MODEM_RESET) ; 
for (x = 0; X < OxFFFF; X++) 

outp{MODEM_CTRL_PORT, MODEM_SETUP); 

} /* End of modem_on() */ 

/****************-k****-k***-k***ic*1i1c*-k-kic-k1c1t***ir-k1c*1c*ick-k*******-k*-k-k-k-k-k***1citit**-k** 

* 

* modem_spread() 

* 

************1t*-k*-k*-k-k-ki,-k*-kifk-k*-k-ki,-k*****’ki,ir*ifk*****-kic*1c-k-k*ic*****-k*i,-k***1iitifk**-k/ 

void modem_spread (void) 

{ 

/* normal spread, fixed encode, on DDS on*/ 
outp(MODEM_CTRL_PORT, MODEM_SETUP); 

pal00_write_table(pal00_init); 

outp(MODEM_CTRL_PORT, MODEM_SPREAD) ; 

} /* End of modem_spread() */ 

/***************^**********************************************************^** 

* 

* pal0 0_read_regs() 

* 

****************************************************************************^ 


174 



void pal00_read_regs(void) 

{ 

unsigned int addr, data, x; 

unsigned int data_tab[0x20]; 
unsigned int b; 
unsigned long a; 

double f; 


/* Freeze */ 

OUtp(PA100_BASE + (0x29)<<l, 0x81); 
for (x = 1; X <= 0x14; X++) 

data_tabtx] = inp(PA100_BASE + (x<<l)); 
/* Unfreeze */ 

outp(PA100_BASE + {0x29)<<2, 0x01); 


for (x = 1; X <= 0x14; X++) 

{ 

data = data_tab[x]; 

switch(x) 

{ 

case 1: 

dprintC'Ol: AGC Status 
break; 

case 2: 

b = data; 
break; 

case 3: 

b = (b<<8) + data; 
dprint{«02, 03: I Prefilter 
break; 

case 4: 

b = data; 
break; 

case 5: 

b = (b<<8) + data; 
dprint("04, 05: Q Prefilter 
break; 

case 6: 

a = data; 
break; 

case 7: 

a = (((unsigned long)data) << 8) + a; 
break; 

case 8: 

a = (((unsigned long)data) << 16) + a; 
break; 

case 9: 

a = (((unsigned long)data) << 24) + a; 
f = {(double)a)/((double)214.748365E6); 
dprint("06 - 09 Time Frequency Command 
dprint(" 
break; 

case OxA: 

a = data; 
break; 

case OxB: 

a = (((unsigned long)data) << 8) + a; 
break; 

case OxC: 

a = (((unsigned long)data) << 16) + a; 
break; 

case OxD: 

a = (((unsigned long)data) << 24) + a; 
f = {(double)a)/{(double)214.748365E6); 
dprint("OA - OD Phase Frequency Command 
dprint(" 
break; 


= %02Xh\n'', data) ; 


= %04Xh\n'', b) ; 


= %04Xh\n'’, b) ; 


= %lXh\n", a); 

= %lf MHz\n", f); 


= %lXh\n«, a) ; 

= %lf MHz\n”, f) 


case OxE: 


175 



break; 


case OxF: 
break; 

case 0x10: 

b = data; 
break; 

case 0x11: 

b = (data << 8) + b; 

dprintC'lO, 11: PN Correlation Detector = %04Xh, %u\n’', b, b) ; 
break; 


case 0x12: 

b = data; 
break; 

case 0x13: 

b = (data << 8) + b; 

dprint(''12, 13: PN Correlation Slip = %04Xh, %u\n'\ b, b) ; 

break; 

case 0x14: 

dprint("14: PN Generator Status = %02Xh\n‘', data) ; 

if (data & 0x01} 

dprintC IPN_EP_TOG = l\n") ; 

else 

dprintC’ IPN_EP_TOG = 0\n") ; 

if (data & 0x02) 

dprintC' QPN_EP_TOG = l\n"); 

else 

dprintC' QPN_EP_TOG = 0\n"); 

break; 

) 


} 

} /* End of pal00_read_regs() */ 


/****************±*-kir******1ric*****it*******1fit*ifk*********it**ir*******-k*-k**ir*-k*** 

* 

* pal00_write_table() 

* 

******♦♦*************★********************************.**********************y 

voidpal00_write_table(pal00_instr struct tablet]) 

{ 

int x; 


for (x = 0; table[x].address != (BYTE)OxFF; x++) 

{ 

if (table[x].address == 0) 

outp(MODEM_CTRL_PORT, (WORD)table[x] .data); 

else 

outp(PA100_BASE + (WORD)(table[x].address<<l), (WORD)table[x].data) 

} 

} /* End of pal00_write_table0 */ 


End of modem.h, modem.c 


176 


msu.h, msu.c 


* MSU.H 

★ 

* Include file for Mass Storage Units (MSU) software interface. 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 


* Revision History: 

* Date Who What 

* - + - + - 

* 5 Sept 1996 Jah Creation 

* 

****************************************************************************/ 


#ifdef MSU 

#define NUM FLASH DEVICES 4 


#define 
#define 
#define 
#define 
#define 


FLASH_SECTOR_SIZE ( (DWORD) 0x400OL) /* 16 kbytes */ 

FLASH_SECTOR_END_ADDRESS ( (DWORD) (FLASH_SECTOR_SIZE -1)) 
FLASH_SECTORS_PER_DEVICE 8 

FLASH_SECTOR_MAX_PER_DEVICE (FLASH_DEVICE_SECTORS - 1) 
FLASH_DEVICE_SIZE (FLASH_SECTORS_PER_DEVICE * FLASH_SECTOR_SIZE) 


#define FLASH_SIZE 
#define FLASH_END_ADDRESS 
#define FLASH_SECTORS 
#define FLASH SECTOR MAX 


(NUM_FLASH_DEVI CES 
(FLASH_SIZE - 1) 

{NUM_FLASH_DEVICES 
(FLASH_SECTORS - 1) 


* FLASH__DEVICE_SIZE) 

* FLASH_SECTORS_PER_DEVICE) 


#define ERASE_TIME_LIMIT 
#define WRITE TIME LIMIT 


((DWORD)0X0003FFFFL) 
OxOFFF 


/* Masks to signify the search method that found the first empty record */ 

#define NO_TLM_WRAP 0x0 

#define TLM__WRAP 0x8000 

#define NO_TLM_FIND OxFFPP 

#define NO REC NUM OxFFFF 


voidmsu_init (int device); 
void msu_on{int device); 

void msu_off(int device); 

int msu_flash_erase(int device); 

int msu__f lash_erase_sector (int device, int sector); 

BYTEmsu__f lash_readl (int device, DWORD addr); 

voidmsu_flash_read(int device, DWORD addr, BYTE *buf, int count); 
int msu_flash__writel (int device, DWORD addr, BYTE data) ; 

int msu_flash_write(int device, DWORD addr, BYTE *data, int count); 

voidmsu_set_faddr (int device, DWORD addr) ; 


int msu_calc_f irst_rec (int rec_num) ; 

int msu_check_flash_tlm(void); 

WORDmsu_flash_search(int device) ,- 


int msu_get_tlm (tlm_record_struct *r_tlm, int rec_num); 

voidmsu_save_tlm (tlm__record_struet *r_tlm) ; 

BYTE msu_sram_readl (int device, DWORD addr); 

voidmsu_sram_read(int device, DWORD addr, BYTE *buf, int count) ; 
int msu_sram_writel (int device, DWORD addr, BYTE data) ,* 

int msu_sram_write(int device, DWORD addr, BYTE *data, int count); 

void msu_set_saddr (int device, DWORD addr); 

voidmsu_f test (int device); 
voidmsu_stest (int device); 


#endif 

/* prototypes for modules other than msu.c */ 
#ifndef MSU 

extern void msu_init(int device); 


177 





extern void 
extern void 

extern int 
extern int 
extern BYTE 
extern void 
extern int 
extern int 
extern void 

extern int 
extern int 
extern void 

extern BYTE 
extern void 
extern int 
extern int 
extern void 

extern void 
extern void 


msu_on(int device); 
msu__of f (int device); 

msu_f lash_erase (int device) ; 

msu_flash_erase_sector(int device, int sector); 
msu_flash_readl(int device, DWORD addr); 

msu_flash_read(int device, DWORD addr, BYTE *buf, int count); 
nisu_f lash_writel (int device, DWORD addr, BYTE data); 
n\su_flash_write(int device, DWORD addr, BYTE *data, int count) 
msu_set_faddr(int device, DWORD addr); 

msu_check_f lash_tlm (void) ,- 

msu_get_tlm(tlm_record_struct *r_tlm, int rec_num) ; 
msu_save_tltn (tlm_record_struct *r_tlm) / 

msu_sram_readl(int device, DWORD addr); 

msu_sram_read(int device, DWORD addr, BYTE *buf, int count); 
msu_srani_writel (int device, DWORD addr, BYTE data); 
msu_srani_write(int device, DWORD addr, BYTE *data, int count); 
msu_set_saddr(int device, DWORD addr); 

msu_ftest (int device); 
msu_stest(int device); 


#endif 








* MSU.C 


* Interface for the Mass Storage Units (MSU). 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* The Mass Storage Units have 4 Mbytes of SRAM and 1/2 Mbyte of Flash, 

* The Flash devices are the Am29F0l0. 


* Revision History: 


* Date Who What 


* 5 Sept 1996 Jah Creation 

* 22 April 1997 Jah Support for record keeping. 

* 

***********1r*-k*ic**********-k*******-kir*****-k**1t******-k***itic*******ir****itit*1r**1r/ 


#include 

” gen 

#include 

"bcm.h” 

#include 

”tlm.h" 

#define 

MSU 

#include 

"msu 

#undef 

MSU 

#include 

"dcs.h" 

#include 

"eps.h" 

#include 

"pcb.h” 


/* Flash storage telemtry record pointers */ 

WORDmsu_tlm_rec_num =0; /* current location to record to */ 
WORDmsu_tlm_first_rec_num =0; /* location of oldest record */ 
WORDmsu_tlm_last_rec_num = NO_REC_NUM; /* location of newest record */ 


#define LAST_TLM_REC_NUM ((FLASH_DEVICE_SIZE/si 2 eof(tlm_record_struct)) - 1 ) 

/************1fk******ieir***ic*-k*ie**-k'k-kit1t**ifk****-k****iiick*i[*it*1t*1r1r*-k*it**-kir****ie1rit 

* 

* void msu_init(int device) 

* 

* Initializes a MSU. 




void msu_init(int device) 

{ 


pcb_write(device, 3, 0x80); 


178 




pcb_write{device, 2, 0x48); 


/* Point to landing zone for low power */ 


} /* End of msu_init0 */ 




* void msu_on(int device) 

* 

* Turns ON and initializes a MSU. 

4r 

*********************************★***************************•★**************/ 

void msu_on(int device) 

{ 

WORD i ; 


if (device == MSAO) 

eps_set_power(PWR_MSA, ON); 

else 

eps_set_power(PWR_MSB, ON); 

for {i =r 0/ i < OxlFFF; i++) /* pause for power ON */ 

Tnsu_init (device) ; 

} /* End of Tnsu_on() */ 


/***************************************♦****************★******************** 

* 

* void msu_off(int device) 

* 

* Turns OFF a MSU. 

★ 

******★*********************************************************************/ 

void msu_off(int device) 

{ 

if (device == MSAO) 

eps_set_power(PWR_MSA, OFF) ; 

else 

ep s_s e t_powe r(PWR_MSB, OFF); 

} /* End of insu_off() */ 


/********************************************♦******************************** 

* 

* WORDmsu_flash_codes(int device) 

* 

* Examines the four Flash devices for a MSU to see if the manufacturer 

* code (0x01 = AMD) and the device type (0x20 = 29F010) are readable from 

* each. 

* 

****************************************************************************/ 

WORDmsu_flash_codes (int device) 

{ 

register int i; 

BYTE data; 

register WORD flag = 0; 


for (i = 0; i < 4; i++) 

( 

msu_set_faddr (device, ( (i*0x00020000L) + 0x00005555L) ) ,- 
pcb_write (device+1, 0, ((BYTE)OxAA)); 

msu_set_faddr(device, ( (i*Ox00020000L) + Ox00002AAAL)); 
pcb_write(device+1, 0, ((BYTE)0x55)); 

msu_set_faddr(device, ((i*0x00020000L) + 0x00005555L)); 
pcb_write(device+1, 0, ( (BYTE)0x90) ) ; 

msu_set_faddr(device, (i*Ox00020000L)); 
data = pcb_read(device+1, 0) ; 

if (data == 0x01) 

{ 

msu_set_faddr(device, ((i*Ox00020000L) + IL)) ; 
data = pcb_read(device+1, 0) ; 


if (data == 0x20) 

flag t= (l«i); 


179 



else 

{ 

flag 1= 0x80; 
break; 

} 

} 

else 

{ 

flag I= 0x8 0; 
break; 


/* perform read/reset */ 

+ 0X00005555L)); 
+ 0x00002AAAL)); 
+ 0X00005555L)); 


to landing zone for low power */ 

return(flag); 

} /* End of msu_flash_codes0 */ 


msu_set_faddr(device, ((i*0x00020000L) 
pcb_write(device+1, 0, ((BYTE)OxAA)); 

msu_set_faddr(device, ((i*0x0002000OL) 
pcb_write(device+1, 0, ((BYTE)0x55)); 

msu_set_faddr(device, ( (i*Ox00020000L) 
pcb_write(device+1, 0, ((BYTE)OxFO)); 

) 

pcb_write(device, 2, 0x48); /* Point 


* 

* int msu_flash_erase(int device) 

* 

* Erases all Flash devices within a MSU. 

* 


int msu_flash_erase(int device) 

{ 

register BYTE fdata; 
register int i; 
int pass = TRUE; 

DWORD x; 


for 

{ 


(i = 0; (i < 4) fic& pass; i++) 


msu_set_faddr(device, 
pcb_write(device+1, 0, 
msu_set_faddr(device, 
pcb_write(device+1, 0, 
rasu_set_faddr(device, 
pcb_write(device+1, 0, 
msu_set_faddr(device, 
pcb^write(device+1, 0, 
msu_set_faddr(device, 
pcb_write(device+1, 0, 
msu_set_faddr(device, 
pcb_write(device+1, 0, 


( (i*Ox00020000L) + 
(BYTE) OxAA) ; 

( (i*0x00020000L) + 
(BYTE)0x55); 

( (i*Ox00020000L) + 
(BYTE)0x80); 

( (i*0x00020000L) + 
(BYTE)OxAA); 

( (i*Ox00020000L) + 
(BYTE)0x55) ; 

( (i*0x00020000L) + 
(BYTE)0x10) ; 


0X00005555L) ) ; 
0X000O2AAAL)) ; 
0X00005555L)) ; 
0X00005555L) ) ; 
OX00002AAAL)) ; 
OX00005555L) ) ; 


fdata = pcb_read (device+1, 0) ,- 
X = 0; 

while (((fdata & 0x80) != 0x80) && (x < ERASE TIME LIMIT}) 

if (fdata & 0x20) 

{ 

fdata = pcb_read(device+1, 0) ; 
if ((fdata & 0x80) == 0x80) 
break; 


else 

{ 

pass = FALSE; 
break; 

} 

) 

fdata = pcb_read(device+1, 0); 

X++; 

} /* End of WHILE */ 


180 


if {x == ERASE_TIME_LIMIT) 
pass = FALSE; 

} /* End of FOR */ 

pcb_write(device, 2 , 0x48); /* Point to landing zone for low power */ 

if (x == ERASE_TIME_LIMIT) 
return(OxCO [ i); 

else if (Ipass) 

return(0x80 | i) ; /* 0x80 = Error flag, i = device which failed */ 

else 

return(pass); 

} /* End of msu_flash_erase() */ 


/**1cifklt1t*******1fk1r***1rir1eieic*1t**-kirle**ir*ii****ir1e******-k*ii1iie******1c*********-IHck**** 

* 

* int msu_flash_writel (int device, DWORD addr, BYTE data) 

* 

* Write one data byte to a flash address. 

* 

*******1e***1r*it****1t*-k**1r**1r*ir***1c**1fk**±************1t**1t1ci,****-k-k*i,*****ir****/ 

int insu__flash_writel (int device, DWORD addr, BYTE data) 

{ 

register BYTE fdata; 

int pass = TRUE; 

register WORD x; 


msu_set_faddr(device, {addr&Ox00070000L) + 0x5555); 
pcb_write(device+1, 0, (BYTE)OxAA); 

insu_set_faddr(device, (addr&OxOOOVOOOOL) + 0x2AAA); 
pcb_write(device+1, 0, (BYTE)0x55); 

msu_set_faddr(device, (addr&Ox00070000L) + 0x5555); 
pcb_write(device+1, 0, (BYTE)OxAO); 

insu_set_f addr (device, addr); 
pcb_write(device+1, 0, data); 

fdata = pcb_read(device+1, 0); 

X = 0; 

while (((fdata & 0x80) != (data & 0x80)) && (x < WRITE_TIME_LIMIT) ) 

{ 

if (fdata & 0x20) 

{ 

fdata » pcb_read(device+1, 0) ; 
if ((fdata & 0x80) == (data & 0x80)) 
break; 

else 

{ 

pass - FALSE; 
break; 

) 

} 

fdata * pcb_read (device+1, 0) ,- 

X++ ; 

) 

pcb_write (device. 2 . 0x4B); /* Point to landing zone for low power */ 

if (x == WRITETIMF LIVITj 
pass » FALSE. 

return(pass). 

} /* End of msu_{lash_writel(} •/ 


/* + +*«-*«**«****««******«««*****«**«*<*-«4r + +** + * + * + + + + + + * + + + + + + + + *** + «'*’**** + + **+ + 
* 

* int Tnsu_f lash_write (int device, DWORD addr, BYTE *data, int count) 

+ 

* Write data to a flash address(es). 

****************************************************♦***********************/ 

int msu_flash_write(int device, DWORD addr, BYTE *data, int count) 

181 




( 

register BYTE fdata; 

int pass = TRUE; 

register WORD x; 


X = 0; 

while ((count--) && (x < WRITE_TIME LIMIT)) 

{ 

msu_set_faddr(device, (addr&Ox00070000L) +0x5555); 
pcb_write(device+1, 0, (BYTE)OxAA); 
msu__set_faddr(device, (addr&0x00070000L) + 0x2AAA) ; 
pcb__write (device+1, 0, (BYTE) 0x55); 
msu_set_faddr(device, (addr&Ox00070000L) + 0x5555); 
pcb__write (device+1, 0, (BYTE)OxAO); 

msu_set_faddr(device, addr); 
pcb_write(device+1, 0, *data); 

fdata = pcb_read(device+1, 0); 

X = 0; 

while (((fdata & 0x80) != (*data & 0x80)) && (x < WRITE TIME LIMIT)) 

{ ■ “ 

if (fdata &. 0x20) 

{ 

fdata = pcb_read(device+1, 0); 
if ((fdata & 0x80) == (*data & 0x80)) 
break; 

else 

{ 

pass = FALSE; 
break; 

} 

} 

fdata = pcb_read(device+1, 0); 

X++; 

} 

addr++; 
data++; 

) 

pcb_write(device, 2, 0x48); /* Point to landing zone for low power */ 

if (x == WRITE_TIME_LIMIT) 
pass = FALSE; 

return(pass); 

} /* End of msu_flash_write0 */ 


/***************************************************************************** 

* 

* BYTEmsu_flash_readl (int device, DWORD addr) 

* 

* Read one data byte from a flash address. 

* 

*****±**********************************************************************/ 

BYTEmsu_flash_readl (int device, DWORD addr) 

{ 

register BYTE data; 


msu_set_faddr(device, addr); 
data = pcb_read(device+1, 0); 

pcb_write(device, 2, 0x48); /* Point to landing zone for low power */ 

return(data); 

} /* End of msu_flash_readl0 */ 


/It**************************************************************************** 

* 

* voidmsu_flash_read(int device, DWORD addr, BYTE *buf, int count) 

* 

* Read data from a flash address. This routine only increments the address 

* on the MSU if it has changed; thereby reducing many PCB Writes. The 

* overhead to check for a,c,b address roll-over is nothing compared to the 

182 


* PCB Write. 


★***************************************************************************/ 

voidms-u_f lash_read (int device, DWORD addr, BYTE *buf, int count) 

{ 

register WORD a, b; 

WORD C; 


insu_set_f addr (device, addr); 

a = (WORD)((addr) & OxOOOOOOFFL); 

b = (WORD) (( (addr) & OxOOOOFFOOL) »8) ; 

c = (WORD)((((addr) j 0x00400000L) & OxOOFFOOOOL)>>16); 

while(count--) 

{ 

*buf - pcb_read(devices1, 0); 
buf++; 

/* Now, setup for the next address to write to */ 
a++ ; 

pcb_write (device, 0, a%0xl00) 
if (a > OxFF) 

{ 

a = 0; 
b++; 

pcb_write(device, 1, b%0xl00); 
if (b > OxFF) 

{ 

b = 0; 

C + +; 

pcb_write(device, 2, c) ; 

) 

) 

} 

pcb_write(device, 2, 0x48); /* Point to landing zone for low power */ 

} /* End of insu_flash_read() */ 


/******♦****************************************★*******★*********♦*********** 

* 

* BYTEmsu_sram_readl (int device, DWORD addr) 

* 

* Read data to a flash address. 

* 

****************************************************************************/ 

BYTEmsu_sram_readl(int device, DWORD addr) 

{ 

register BYTE data; 


msu_set_saddr(device, addr); 
data = pcb_read(device+l, 0); 

pcb_write(device, 2, 0x48); /* Point to landing zone for low power */ 

return(data); 

} /* End of msu_sram_readl() */ 


/****icie***it**1fk***1rir***it****1e1r1rit1tit*ieie****ii*****i(ir*****1t**ie*****1tit*-kit1eit***1r*ie*1t 

■k 

* voidmsu_sram_read(int device, DWORD addr, BYTE *buf, int count) 

* 

* Read data to a flash address. This routine only increments the address 

* on the MSU if it has changed; thereby reducing many PCB Writes. The 

* overhead to check for a,c,b address roll-over is nothing compared to the 

* PCB Write. 

* 

*k********************i:kk***********************************************/ 

voidmsu_sram_read(int device, DWORD addr, BYTE *buf, int count) 

{ 

register WORD a, b; 

WORD c; 


msu_set_saddr(device, addr); 


183 


a = (WORD)((addr) & OxOOOOOOFFL); 
b = (WORD)(((addr) & OxOOOOFFOOL)>>8); 
c = (WORD)(((addr) & OxOOFFOOOOL)>>16); 

while(count--) 

{ 

*buf = pcb_read(device+1, 0) ; 
buf++; 

/* Now, setup the next address to write to */ 
a++; 

pcb_write(device, 0, a%0xl00); 
if (a > OxFF) 

{ 

a = 0; 
b++; 

pcb_write(device, 1, b%0xl00); 
if (b > OxFF) 

{ 

b = 0; 

C++ ; 

pcb_write (device, 2, c) ,* 

) 

} 


} 

pcb_write (device, 2, 0x48); /* Point to landing zone for low power */ 

} /* End of msu_sram_read() */ 


/*★*********************★***************************.*★*********** + **********,** 
★ 

* int msu_sram_writel (int device, DWORD addr, BYTE data) 

* 

* Write data to a sram address. 

* 

****************************************************************************/ 


int msu_sram_writel (int device, DWORD addr, BYTE data) 

{ 

msu_set_saddr(device, addr); 
pcb_write(device+1, 0, data); 

pcb_write(device, 2, 0x48); /* Point to landing zone for low power */ 

} /* End of msu_sram_writel() */ 


/************♦************♦***♦*********************************************** 

■k 

* int msu_sram_write (int device, DWORD addr, BYTE *data, int count) 

* 

* Write data to a sram address. This routine only increments the address 

* on the MSU if it has changed; thereby reducing many PCB Writes. The 

* overhead to check for a,c,b address roll-over is nothing compared to the 

* PCB Write. 

* 

****************************************************************************^ 

int msu_sram_write(int device, DWORD addr, BYTE *data, int count) 

{ 

register WORD a. b, 

WORD C ; 


msu_set_saddr(device, addr); 

a = (WORD)((addr) 4 CxOOOOOOFFL); 

b = (WORD)(((addr: 4 OxOOOOFFOOL)>>8); 

C = (WORD)(((addr) 4 OxOOFFOOOOL)>>16); 

while(count--) 

{ 

pcb_write(device^1, 0, *data); 
data++; 

/* Now, setup the next address to write to */ 
a++ ; 

pcb_write (device, 0, a%0xl00) ,* 
if (a > OxFF) 

{ 

a = 0; 
b++; 


184 




pcb_write(device, 1, b%OxlOO); 
if (b > OxFF) 

{ 

b = 0; 

C++; 

pcb_write(device, 2, c); 

) 

} 


) 

pcb_write (device, 2, 0x48); /* Point to landing zone for low power */ 

} /* End of msu_sram_write() */ 


/**♦***★******************★*********************** ****************^^*********^^* 
* 

* voidmsu_f test (int device) 

* 

* Tests a MSU’s Flash devices by writing a pattern to the Flash devices 

* and then reading it back. 

* 

***********★************•*•***************************************************/ 

voidinsu_f test (int device) 

{ 

DWORD addr; 

int i, j; 

BYTE block [256] ; 

BYTE fblock [2563 ; 

DWORD t ; 
extern int icount; 


for (i - 0; i < 255; i++) 
block [i] = (BYTE)i; 

block[255] = OxFE; /* don't use OxFF which is erased value */ 


t = icount; 

msu_flash_write(device, 0, (BYTE *)block, 256); 
t = icount - t; 

dprint ("FLASH 256 byte block write time = %ld ticks.\n", t) ; 
t = icount; 

msu_flash_read(device, 0, (BYTE *)block, 256); 
t = icount - t; 

dprint ("FLASH 256 byte block read time = %ld ticks.\n", t) ; 
retum; 


dprint("Writing Flash data (# = 64K)\n"); 

for (i = 0, addr = OL; addr <= 0x0007FFFFL; addr += 256) 

msu_flash_write(device, addr, (BYTE ♦)block, 256); 

if (++i == 256) 

{ 

i = 0; 

dprint("#") ; 

) 

) 

dprint("\nReading back Flash data (# = 64K)\n"); 

for (i = 0, addr = OL; addr <= OxOOOVFFFF; addr += 256) 

{ 

nisu_flash_read(device, addr, (BYTE *)fblock, 256); 
for (j = 0; j < 256; j++) 

{ 

if (fblock[j] != block[j]) 

{ 

dprint ("Flash read back error at %1X, %X should be %X\n", 
(DWORD)(addr+j), fblockij], block(j3); 
return; 

) 

1 

if (++i == 256) 

{ 

i = 0; 

dprint("#"); 

} 


) 


185 



dprint (”\nFinished: OK.\n''); 
} /* End of msu_ftest{) */ 


* voidmsu_stest (int device) 

* 

* Tests a MSU's SRAM devices by writing a pattern to the SRAM devices 

* and then reading it back. 

* 

****************************************************************************/ 


voidmsu_stest (int device) 

{ 

DWORD addr; 

int i, j; 

BYTEblock[256] ; 

BYTEfblock[256] ; 

DWORD t ; 

#define LAST_ADDR 0x0002FFFFL 
extern int icount; 


for (i = 0; i < 256; i++) 
block[i] = (BYTE)i; 


t = icount; 

msu_sraTn_write (device, 0, (BYTE *)block, 256); 
t = icount - t; 

dprintC'SRAM 256 byte block write time = %ld ticks.\n", t) ; 
t = icount; 

msu_sram_read(device, 0, (BYTE *)block, 256); 
t = icount - t; 

dprintC’SRAM 256 byte block read time = %ld ticks.\n”, t) ; 
return; 


dprint("Writing SRAM data (# = 64K)\n"); 

for (i = 0, addr = OL; addr <= LAST_ADDR; addr += 256) 

{ 

msu_sram_write(device, addr, (BYTE *)block, 256); 

if (++i == 256) 

{ 

i = 0; 

dprint ("#") ; 

} 

} 

dprint C*\nReading back SRAM data (# = 64K)\n"); 

for (i = 0, addr = OL; addr <= LAST ADDR; addr += 256) 

{ 

msu_sram_read(device, addr, (BYTE *)fblock, 256); 
for (j = 0; j < 256; j++) 

{ 

if (fblock[j] != block[j]) 

{ 

dprintC'SRAM read back error at %1X, %X should be %X\n", 
(DWORD)(addr+j), fblock[j], block[j]); 
return; 

) 

) 

if (++i == 256) 

{ 

i = 0; 

dprint("#“); 

) 

} 

dprint C'\nFiniShed: OK.\n"); 

} /* End of msu_stest() */ 


/****************************************************************★************ 

* 

* voidmsu_set_saddr(int device, DWORD addr) 

* 

* Set an address to the SRAM array on a particular device. 


186 





void msu_set_saddr(int device, DWORD addr) 

{ 

pcb_write(device, 0, (WORD)((addr) & OxOOOOOOFFL)); 
pcb_write (device, 1, (WORD) (( (addr) & OxOOOOFFOOL) >>8) ) ,- 
pcb__write(device, 2, (WORD)(((addr) & OxOOFFOOOOL)>>16)); 

} /* End of msu_set_saddr0 */ 


/***************************************************************************** 

* 

* voidmsu_set_f addr (int device, DWORD addr) 

* 

* Set an address to the Flash array on a particular device. 

* 

*****★************************★*****************************★***************/ 


voidmsu_set_faddr(int device, DWORD addr) 

{ 

pcb_write(device, 0, (WORD)((addr) & OxOOOOOOFFL)); 
pcb_write(device, 1, (WORD)(((addr) & OxOOOOFFOOL)>>8)); 

pcb_write(device, 2, (WORD)((((addr) | Ox00400000L) & OxOOFFOOOOL)»16)); 
} /* End of msu_set_faddr0 *{ 


■k 

* voidmsu_save_tlm () 

* 

* Save a telemetry structure to Mass Storage. 

* 


voidmsu_save_tIm (tlm_record_stract *r_tIm) 

{ 

int sector; 

int next_sector; 

int remaining; 

DWORD m su_p t r; 


/* Calculate, and add CRC to end of the record */ 

prepare_crc (r_tlm, sizeof (tlm_record_stract) -2); /* ~2 due to CRC */ 


/* Is there enough room on the existing sector to write out this telemetry 
* record, and the next record ? 

*/ 

msu_ptr = (DWORD)(msu_tlm_rec_num * sizeof(tlm_record_struct)); 
remaining = msu_ptr%FLASH_SECTOR_SIZE; 
if (remaining < 2*sizeof(tlm_record_struct)) 

( 

/* There is not enough room for this and the next record. Erase the 
* next highest sector (unless it is time to wrap around). 

*/ 

sector = msujptr/FLASH_SECTOR_SIZE; 
if (sector == PLASH_SECTOR_MAX) 
next_sector = 0; 

else 

next_sector = sector+1; 

/* erase the "next" sector */ 
msu_flash_erase_sector(MSA, next_sector); 
msu_flash_erase_sector(MSB, next_sector); 

1 


/* Save the record to both MSA and MSB */ 

msu_flash_write(MSA, msu_ptr, (BYTE *)r_tlm, sizeof(tlm_record_struct)); 
msu_flash_write(MSB, msu_ptr, (BYTE *)r__tlm, sizeof(tlm_record_struct)); 


/* Update counter for next time */ 
if (next_sector == 0) 

msu_tlm_rec_num = 0; 

else 

msu__tlm_rec_num++ ; 

} /* End of msu_save_tlm() */ 


187 





* int msu_get_tlin 0 

* 

* Retrieve a telemetry structure from Mass Storage. 

* 

*************************************•*^************ 1 ,*************************/ 


int msu_get_tlm(tlm record struct *r tlm, int rec num) 
{ - - - 
int flag = NO_ERROR; 

DWORD msu_p t r ; 


Tnsu_ptr = (DWORD) (rec__num * sizeof (tlm_record_struct)} ; 

*^su_f lash_read (MSA, msu_jptr, (BYTE*) r_tlm, sizeof (tlm_record_struct)) ; 
if (check;__crc (r_tlra, sizeof (tlm record struct)} != 0) 

{ 

/* Try the other Mass Storage Flash */ 

msu_flash_read(MSB, msu_ptr, (BYTE*)r_tlm, sizeof(tlm_record_struct)); 
if (check_crc(r_tlm, sizeof(tlm_record_struct) ) != 0) 
flag = ERROR; 

} 


return(flag); 

} /* End of msu_get_tlm() */ 


/***************-k*ir*it***-k-kirir****i[**it**irir1r***it*i,***it*ii±*it*ifk***1fk-k*ic*******1fk1r* 

* 

* int msu_check_flash_tlm() 

★ 

* Check Flash for already stored telemetry records. This is first called 

* when the system is Reset to see if any prior state history has already 

* been saved to the Flash. 

* 

*********1c*****1r*i,'»r-k********ir1c*********-k**********1t**********1tic**1,1,1c1t****ifk*/ 

int msu__check_f lash_tlm (void) 

{ 

int rec_num; 

DWORD msu_ptr; 

int tryb = FALSE; 

DWORD etime; 

int flag = NO__ERROR; 

int wrap = FALSE; 

tlm_record_structrtlm; 
tlra_record_struct *r_tlm; 


/* First, check using MSA. */ 

/* Do a search looking for unused portions of the Flash. */ 
if ((rec_num = msu_flash search(MSA)) != NO TLM FIND) 

( ~ ~ 
wrap = (rec_num & TLM_WRAP) ? TRUE : FALSE; 
rec_num &= ~TLM_WRAP; 

/* MSA has an empty location. */ 

msu_ptr = (DWORD)(rec_num * sizeof(tlm_record_struct)); 

msu_flash_read(MSA, rasu_ptr, (BYTE*)r_tlm, sizeof(tlm_record_struct)); 
if (check_crc(r_tlm, sizeof(tlm_record_struct) ) != 0) 
tryb = TRUE; 

) 

else 

tryb = TRUE; /* attempt the same search with MSB. */ 


if (tryb) 

{ 

if ((rec_num = msu_flash search(MSB)) == NO TLM FIND) 

{ ■ " ■ 

/* ERROR. Erase both MSA and MSB. And assume NO recorded data. */ 

rasu_f lash_erase (MSA) ; 

msu_flash_erase(MSB); 

rec_num = 0; 

flag = ERROR; 

} 

/* MSB has an empty location. */ 

wrap = (rec_num & TLM_WRAP) ? TRUE : FALSE; 

rec_num &= ~TLM_WRAP; 


188 


msu_jptr = (DWORD) (rec_num * sizeof (tlm_record_struct) ) ; 

msu_flash_read (MSB, msu_ptr, (BYTE*) r_tlm, sizeof(tlm_record_struct)); 
if (check;_crc (r_tlTn, sizeof (tlm_record_stract)) 1= 0) 

{ 

/* ERROR: Erase both MSA and MSB. And assume NO recorded data. */ 

msu_f lash_erase (MSA) ; 

msu_f lash_erase (MSB) ; 

rec_num = 0; 

flag = ERROR; 

1 

else 

{ 

/* MSA had problems, but not MSB. So, erase MSA. */ 
msu_flash_erase(MSA); 

) 

) 

/* Now, process the last recorded record by using it as the most recently saved 
* history regarding the state of the spacecraft. 

*/ 


/* If the record number returned from the search is not zero, then 

* assume that there is a prior record and this is not the first time 

* recording. 

* If the record number returned from the search is zero, then this could be 

* the first time recording (or at least first timer recording since the 

* Flash was erased) . And thus, there is no history of data to examine. 

*/ 

if (flag == ERROR) 

{ 

/* No state history, both MSA and MSB have just been erased. 

* Begin as if ejection has just occurred. 

*/ 

msu_tlm_rec_num = 0; 
msu_tlm_last_rec_num = N0__REC_NUM; 
ms u_t lm_firs t_rec_num = 0; 

} 

else if (wrap == FALSE) 

{ 

if (rec_num == 0) 

I 

/* Empty Flash */ 
msu_tlm_rec_num = 0; 
msu_tlm_last_rec_num = NO_REC_NUM; 
msu_tlm_f irst_rec__num = 0; 

} 


else 


/* Flash has data, but no wrap around is in effect */ 
msu_tlm_rec_num = rec_num; 
msu_tlm_last_rec_num = rec_num - 1; 
msu_tlm_first_rec_num = 0; 

msu_get_tlm (&tlm_record, msu_tlm_last_rec_num) ; 

} 

} 


else if (wrap == TRUE) 

{ 

/* Flash has data, and wrap around is in effect */ 
msu_tlm_rec_num = rec_num; 
if (rec_num == 0) 

msu_tlm_last_rec_num = 0; 

else 

msu_tlm_last_rec_num = rec_num - l; 

/* calculate msu_tlm_first_rec_nura */ 
msu_tlm_first_rec_num = msu_calc_first_rec(rec_num); 
msu_get_tlm (&tlm_record, msu_tlm_last_rec__num) ; 

} 


} /* End of msu_check_flash_tlm() */ 

/**♦***★********************★************************************************* 

* 

* msu_flash_search() 

* 

* Check Flash via a "top" binary search. That is, use an increasing memory 

* binary search to see if any "empty" tlm records exists (not recorded yet). 

189 



* When performing the "divide and conquer", always take the upper portion of 

* memory. 

*■ 

* If no "empty" record is found, perform a search starting at the bottom and 

* look for the first "empty" record. This is not a fast search (its linear), 

* but there is no way around it since one has no idea where the first hole 

* could be and there is no ordering. 

* 

* The "empty" record number is returned. 






WORDmsu_flash__search(int device) 

{ 

WORDbottom, top, mid, r, sector; 
DWORD etime; 

DWORD msu_ptr; 


/* Binary Search */ 

/* These are the end points of the tlm record storage. Attempt to find 

* an "empty" storage record. Assuming no lower "bottom" holes exist, 

*/ 

bottom = 0; 

top = FLASH_SIZE/sizeof{tlm_record_struct)/ 
while ((top - bottom) > 1) 

{ 

mid = (bottom + top)/2; 
msu_ptr = mid*sizeof(tlm_record_struct); 
msu_flash_read(device, msu_ptr, &etime, sizeof(DWORD))/ 
if (etime != OxFFFFFFFFL) /* in use, look higher */ 
bottom = mid; 

else 

top = mid; 

) 

msu__ptr = bottom*sizeof(tlm_record_struct); 
msu_flash_read(device, msujptr, &etime, sizeof(DWORD)); 
if (etime == OxFFFFFFFFL) 

return(bottom j NO_TLM_WRAP); 
else if (etime == OxFFFFFFFFL) 
return(top | NO_TLM_WRAP); 

/* ELSE -> not found via binary search... continue.,..*/ 

/* Try a "bottom" based search. That is, use a decreasing memory 

* binary search. */ 

for (sector = 0; sector <= FLASH SECTOR MAX; sector++) 

{ 

r = ((sector+l)*FLASH_SECTOR_SIZE)/sizeof(tlra_record_struct); 
msu_ptr = r * sizeof(tlm_record_struct); 
msu_flash_read(device, msu_ptr, &etime, sizeof (DWORD)); 
if (etime != OxFFFFFFFFL) /* in use, skip this sector */ 
continue; 

else 

{ 

/* Examine this sector for the first empty location */ 

/* Do this with a binary search within this sector */ 

bottom = (sector * FLASH_SECTOR_SIZE)/sizeof(tlm_record_struct); 

top = (((sector + l) * FLASH_SECTOR_SIZE)/sizeof(tlm_record_struct)) - 1 

while ((top - bottom) > 1) 

{ 

mid = (bottom + top)/2; 

msu_jptr = mid*sizeof{tlm_record_struct); 

^su_flash_read(device, msu_ptr, &etime, sizeof(DWORD)); 
if (etime != OxFFFFFFFFL) /* in use, look higher */ 
bottom = mid; 

else 

top - mid; 

} 

_ptr = bottom*sizeof(tlm_record_struct); 
msu_flash_read(device, msu_j>tr, &etime, sizeof(DWORD)); 
if (etime == OxFFFFFFFFL) 

return(bottom ( TLM_WRAP); 
else if (etime == OxFFFFFFFFL) 
return(top j TLM_WRAP); 

} 

return (NO_TLM_FIND) ; 

} /* End of msu_flash_search{) */ 


190 




♦ int msu_flash_erase_sector(int device, int sector) 

* 

* Erases appropriate sector in the Flash array- The sector is the absoulute 

* sector for the entire array of Flash memory, thus the relative sector 

* within the device must be determined, as well as the actual device itself. 

* 

it***************************************************************************/ 


int msu_flash_erase_sector(int device, int sector) 

( 

register BYTE fdata; 
register int pass = TRUE; 

DWORD base; 

int X; 


/* First, determine which of the Flash devices contains the absolute sector. 
* The compares are quicker than using arithmetic . 

*/ 

if (sector < FLASH__SECTORS_PER_DEVICE) 
base = OL; 

else if (sector < FLASH_SECT0RS_PER__DEVICE*2) 
base = FLASH_DEVICE_SIZE; 
else if (sector < FLASH_SECT0RS_PER_DEVICE*3) 
base = FLASH_DEVICE_SIZE*2; 
else if (sector < FLASH_SECT0RS_PER_DEVICE*4) 
base = FLASH_DEVICE_SIZE*3; 

msu_set_faddr(device, (base + 0x00005555L)); 
pcb_write(device+1, 0, (BYTE)OxAA); 
msu_set_faddr(device, (base + 0x00002AAAL)); 
pcb_write(device+1, 0, (BYTE)0x55); 

msu_set_faddr(device, (base + 0x00005555L)); 
pcb_write(device+1, 0, (BYTE)0x80); 

msu__set_faddr (device, (base + Ox00005555L) ) ; 
pcb_write{device+1, 0, (BYTE)OxAA); 
msu_set_faddr(device, (base + Ox00002AAAL)); 
pcb_write(device+1, 0, (BYTE)0x55); 

/* Relative sector within the Flash device in address bits A16 - A14. */ 
msu_set_faddr(device, (base + (sector%FLASH_SECTORS_PER_DEVlCE) << 14)),- 
pcb_write(device+1, 0, (BYTE)0x30); 


fdata = pcb_read(device+1, 0); 
x = 0; 

while (((fdata & 0x80) != 0x80) && (x < ERASE_TIME_LIMIT) ) 

{ 

if (fdata & 0x20) 

{ 

fdata = pcb_read(device+1, 0) ; 
if ((fdata & 0x80) == 0x80) 
break; 

else 

{ 

pass = FALSE; 
break; 

} 

) 

fdata = pcb_read(device+l, 0) ; 

X++; 

} /* End of WHILE */ 


pcb_write (device, 2, 0x48); /* Point to landing zone for low power */ 


if (x == ERASE_TIME_LIMIT) 
return(0x80 | sector); 

else 

return(0); 

} /* End of msu_flash_erase_sector() */ 


/*******************************************************♦********************* 

* 

* int msu_calc_f irst^rec (int rec_num) 

* 

* Determine the first (oldest) record used in Flash based on the current 

191 



record number and assuming data wrap around is in effect. 

This location is the first complete (whole) record in the sector after 
the sector that contains the current record, rec_nuni. 

************************************************♦*********************^1 


int msu_calc_first_rec(int rec_num) 

{ 

int s, snext, r; 


/* Determine the next sector */ 

s = (rec_num*sizeof (tlm_record_struct) } /sizeof (FLASH_SECTOR_SIZE) ; 
if (s == FLASH_SECTOR_MAX) 
snext = 0; 

else 

snext = s + 1; 

/* determine # of complete records in Flash upto the next */ 
r = (snext*sizeof (FLASH_SECTOR_SIZE)) /sizeof (tlm_record_struct) ; 

/* the next complete record in the next sector is just the next record */ 

return(r+l); 

} /* End of msu_calc_first_rec 0 */ 


End of msu.h, msu.c 




pcb.h, pcb.c 

/****♦************************************************************************ 

* 

* PCB.H 

* 

* Include file for Peripheral Control Bus (PCB) software interface. 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 

« =: = = = = = = = = = = = =; = = = = 

* Date Who What 

* - + - + - 

* 4 March 1993 Jah Creation 

* 8 Sept 1995 Jah Adoption to PANSAT System Controller architecture 

* 

*******♦********************************************************★***********/ 


#ifdef PCB 

void pcb_init(void); 

void pcb_portc{int bitnum, int mode); 

unsigned int pcb__read(iinsigned int select, unsigned int addr) ; 

void pcb_write(unsigned int select, unsigned int addr, unsigned int value); 

#endif 

/* prototypes for modules other than pcb.c */ 

#ifndef PCB 

extern void pcb_init(void); 

extern void pcb_portc(int bitnum, int mode); 

extern unsigned int pcb_read(unsigned int select, unsigned int addr) 

extern void pcb_write(unsigned int select, unsigned int addr, unsigned int value); 

#endif 


/* Macros for PCBW and PCBR */ 

#define pcbw_m(select, addr, value) {\ 
outp(PCB_PPI_PORTA, (value)); \ 

outp(PCB_PPI_PORTB, PCB_READ_OFF | PCB_WRITE_OFF 


\ 


OUtp(PCB_PPI_P0RTB, PCB_WRITE_ON | ((select) & OxOOOF) 
outp(PCB_PPI_PORTB, PCB_WRITE_OFF | ((select) & OxOOOF) 


((select) t OxOOOF) | (((addr) & 0x0003) << 4) 

(((addr) & 0x0003) << 4) ); \ 

(((addr) & 0x0003) « 4) ); } 


#define pcbr_m(select, addr, value) {\ 

outp(PCB_PPI_PORTB, PCB READ OFF j PCB WRITE OFF 


I ((select) & OxOOOF) j ({(addr) & 0x0003) « 4) ) 

outp(PCB_PPI_^PORTB, PCB_READ_ON ] ((select) & OxOOOF) | {((addr) & 0x0003) « 4) ); \ 

outp (PCB_PPI_CTRL, 2) ; \ 
outp (PCB_PPI_CTRL, 3) ; \ 

outp{PCB_PPI_PORTB. PCB_READ_OFF | ((select) & OxOOOF) [ (((addr) & 0x0003) « 4) ); \ 

(value) = inp(PCB_PPI_PORTA); } 




fr*********************** *********** 


PPI Interface on a DCS to control the Peripheral Control Bus. 

Using Mode 2 (OxCO) the PPI is programmed to support strobed 
bidirectional bus I/O using Port A. Port B is used as output, and 
port C is used for handshaking and other output purposes. 

Port A contains the data (byte value) which is moved across the 
control bus Perl B contains the device selection and sub-address 
control bits, and the Read and Write strobes. 






#define PCB_PP1_BASE 
#define PCB_PPI_PORTA 
#define PCB_PPI~PORTB 
#define PCB^PPI^PORTC 
#define PCB PPI^CTRL 


0x100 

PCB_PPI_BASE+0 

PCB~PPi3aSE+2 

PCB_PPI_BASE+4 

PCB~PPI~BASE+6 


#define PCB PPI INIT OxCO 


/* Read and Write Line Toggling Controls */ 
#define PCB_READ_ON 0x40 

#define PCB READ OFF OxCO 


193 








#define PCB_WRITE_ON 0x80 
#define PCB WRITE OFF OxCO 




* Devices on the PCB 


* These devices are selected via the DCS PPI for PCB control. 

* PPI port B is the addressing register. The following device 

* selects use bits 3 - bits 0 (D3 - DO) of PPI Port B. 

* 

* Note that the low order bit (DO) is used to differentiate 

* between the two selects on the same unit. Device subaddresses 

* are not included here, since they are particular to a device. 

* 

*******************************^***********************.**,*******************,y 


#define 

SCA 

0x02 


#define 

SCAO ; 

SCA 

/* System Control A */ 

#define 

SCAl 

(SCA+1) 


#define 

SCB 

OxOA 


#define 

SCBO i 

SCB 

/♦ System Control B */ 

#define 

SCBl 

(SCB+l) 


#define 

TMUXA 

0x04 


#define 

TMUXAO 

TMUXA 

/* Analog MUX A */ 

#define 

TMUXAl 

(TMUXA+1) 

#define 

TMUXB 

OxOC 


#define 

TMUXBO 

TMUXB 

/* Analog MUX B */ 

#define 

TMUXB1 

(TMUXB+1) 

#define 

MSA 

0x06 


#define 

MSAO MSA 

/* Mass Storage A */ 

#define 

MSAl 

(MSA+1) 


#define 

MSB 

OxOE 


#define 

MSBO MSB 

/* Mass Storage B */ 

#define 

MSBl 

(MSB+1) 


#define 

RF 

0x00 


#define 

RFO 

RF 

/* RF System */ 

#define 

RFl 

(RF+l) 


#define 

EPS 

0x08 


#define 

EPSO ] 

EPS 

/* Electrical Power System */ 

#define 

EPSl 

(EPS+1) 


/* EPS Selects S3-S0 */ 


#define 

EPS_PORT 

_S0 

0x08 

#define 

EPS_PORT 


0x08 

#define 

EPS_PORT 

_S2 

0x08 

#define 

EPS_PORT 

_S3 

0x08 

#define 

EPS_PORT 


0x09 

#define 

EPS_PORT 

Is 5 

0x09 

#define 

EPS_PORT 

_S6 

0x09 

#define 

EPS_PORT 

_S7 

0x09 

/* EPS Sub-addresses Al- 

-AO */ 

#define 

EPS_PORT 

_A0 

0x00 

#define 

EPS_PORT 

_A1 

0x01 

#define 

EPS_PORT 

_A2 

0x02 

#define 

eps_port' 

_^A3 

0x03 

#define 

EPS_PORT 

_A4 

0x00 

#define 

eps_port 

_A5 

0x01 

#define 

EPS_PORT 

_A6 

0x02 

#define 

EPS_PORT 

_A7 

0x03 


* 

* Subsystem addresses of PCB devices 




/***************************************************************************** 

* Mass Storage 

* PPI Interface: Indexed using MSxl 

* Data Port: Indexed using MSx2 

************************************★**********************★****************/ 


194 






#define MS_PPI_BASE 
#define MS_PPI_PORTA 
#define MS_PPI_PORTB 
#define MS_PPI_PORTC 
#define MS PPI CTRL 


0 

MS_PPI_BASE+0 

MS_PPI_BASE+1 

MS_PPI_BASE+2 

MS PPI BASE+3 


/***************************★************************************************* 

* 

* PCB.C 

* 

* Interface routines for the Peripheral Control Bus (PCB). 


* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 


Revision History: 


* Date Who What 


* 4 March 1993 Jah Creation 

* 8 Sept 1995 Jah Adoption to PANSAT System Controller architecture 

* 24 April 1996 Jah Make PCB functions non-interruptable. 




#include 

"gen_defs 

tinclude 

"gen_apis.h" 

#define 

PCB 

#include 

"pcb.h” 

#undef 

PCB 

#include 

"dcs.h" 


/******************★*****★********♦*********★********************************* 

* 

* pcb_init() 

* 

* Initializes the PCB by preparing the PPI controlling the PCB to work 

* in the bidirectional strobed data mode, and to make sure that no 

* read or write commands are occuring on the PCB. 

* 

**************************************************************************it*/ 

void pcb_init (void) 

{ 

OUtp(PCB_PPI_CTRL, PCB_PPI_INIT) ; 
outp (PCB_PPI_PORTB, OxCO) ; 


pcb__portc (0, OFF) ; 
pcb_portc{l, SET); 
pcb_portC(2, RESET); 
pcb_portc(2, SET); 

} /* End of pcb_init() */ 


/* Modem Power OFF */ 

/* PCI = PPI Input Strobe ON */ 
/* Reset EDAC Error Acknowledge */ 


/***************************************************************************** 

* 

* pcb_jportc () 

* 

* Toggles the three output bits of Port C on the PPI. 

* 

*********1e****ieic*-k-k1tir1t*ic*itie*1eit*1c*ir1e*******1e**irir1e***ie1r1e********1t**ii**it**it***ir^ 

void pcb_portc(int bitnum, int mode) 

{ 

register unsigned char temp; 
register WORD state; 

mode &= 0x01; /* make sure only bit DO is used in mode */ 


195 





state = disable_ints0; 

switch(bitnum) 

{ 

case 0; 

temp = mode; 
break; 

case 1: 

temp =5 0x02 | mode; 
break; 

case 2: 

temp = 0x04 I mode; 
break; 

default: 

temp = OxFF; 

) 

if (temp != OxFF) 

outp( PCB_PPI_CTRL , t emp); 

if (state) 

enable_ints(); 

} /* End of pcb_portc() */ 


/***•*•*****★****♦★********************************★★**★*******★**************★* 

* 

* pcb_read() 

* 

* Read one data (byte) from the Peripheral Control Bus via the onboard PPI. 

* 

*********★*************★******************************♦*************★*******/ 

WORD pcb_read (unsigned int select, unsigned int addr) 

( 

/* Note: register not used so that this routine is re-entrable 
* at the point of the last statement, return(temp). 

*/ 

register WORD temp = (select & OxOOOF) | ({addr & 0x0003) << 4); 

WORD value; 

register WORD state; 


state = disable_ints(); 

/* Set Device Select and address without read or write commands */ 
outp(PCB_PPI_PORTB, OxCO | temp); 

outp(PCB_PPI_PORTB, 0x40 | temp); 
outp(PCB_PPI_CTRL. 2); 
outp(PCB_PPI_CTRL. 3); 
outp(PCB_PPI_PORTB. OxCO | temp); 

value = inp{PCB_PPI_PORTA); 

if (state) 

enable_ints(}; 

/* Note: enabling interrupts BEFORE returning from PCBR can result 

* in another piece of software (e.g. inside an ISR) calling PCBR 

* during the stack manipulations following the above _enable(). 

* This would actually result in the issuing of the new PCBR and 

* returning the value of the PCBR, followed by that piece of software 

* returning via an I RETT, and then the PCBR that was interrupted would 

* coutinue with its return(...). 

*/ 

return(value); 

} /* End pcb_read() */ 


/*************♦* ♦••••********»*************************^(.******^*^************* 
* 

* pcb_write() 

* 

* Write one data (byte) from the Peripheral Control Bus via the onboard PPI. 

* 

**********************************************^*****************************^ 


/* PB7 = /RD goes LOW */ 

/* PCI = /Strobe goes LOW */ 
/* PCI = /Strobe goes HIGH */ 
/* PB7 = /RD goes HIGH */ 


196 



void pcb_write(unsigned int select, unsigned int addr, unsigned int value) 

register WORDtemp = (select & OxOOOP) | ((addr & 0x0003) « 4); 
register WORD stated- 

state = disable_ints 0 ; 

ou tp (PCB_PP I_PORTA, value); 

/* Set Device Select and address without read or write commands */ 

OUtp(PCB_PPI_PORTB, (PCB_READ_ON j PCB_WRITE_ON) | temp); 

/* Toggle the Write line */ 

outp(PCB_PPI_PORTB, (PCB_WRITE_ON | temp)); 

outp(PCB_PPI__PORTB, (PCB_WRITE_OFF | temp) ) ; 

if (state) 

enable_ints 0 ; 

) /* End pcb_write() */ 

End of pcb.h, pcb.c 


197 



printh, printc 

/**************************************************************************** 

* 

* PRINT.H 

* 

* DCS printf: void dprint(char *format,...) 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* 

Date 


Who 

What 

* 

1 Feb 

1991 

Jah 

Creation (Star) 

* 

2 Nov 

1993 


Jah Adopted for DCS (from Star) 




/* Include specifics for PRINT.C */ 

#ifdef PRINT 

/* Internal routines to print.c */ 
static int get_width(char *, int *); 

static int get_precision (char *, int *) ,* 

static void print_fp(char *obuf, double x, int precision, int width); 
static void print_ptr(char *, void far *, int); 

static unsigned long int power (unsigned int x, unsigned int y) ,- 

#endif 


/* Include for all other modules */ 

#ifndef PRINT 

extern void dprint(char *format,...); 

#endif 


/**********^***************************************************************** 

* 

* PRINT.C 

* 

* DCS printf: void dprint(char *format,...) 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History; 

★ ================= 

* Date Who What 


* 1 Feb 1991 

* 2 Nov 1993 

* 18 Apr 1996 


Jah Creation 

Jah Adopted for DCS 

Jah FP support 




#include <stdarg.h> 
#include <ctype.h> 
#include <string.h> 
ttinclude <stdio.h> 
#include <stdlib.h> 


#include "gen_defs-h" 

#define PRINT 

#include "print.h” 
#undef PRINT 

#include "scc.h" 


#define NEGATIVE 1 
#define PLUS 2 
#define NEAR_PTR 1 
#define FAR_PTR 2 




198 










get_width 0 


* Get the width for a specific output parameter. This is a number field 

* placed in front of the format type of a star_print format. This 

* number is either followed by a format type (letter) or a period (.) . 

* The period denotes that a precision field will also be specified. 

* 

* This routine outputs the width. 

* 

*********★***★************★*********************************♦***************/ 


static int get__width(char *format, int *i) 

{ 

int itemp; 

char buf[lO]; 
int n; 


itemp = *i; 
n = 0; 

buf[n] = NULL_CHAR; 

while (isdigit(format[itemp])) 

buf[n++] = format[itemp++] ; 
bufEn] = NULL_CHAR; 

*i = itemp; /* update the marker in format string */ 

return(atoi(buf)); 

} /* End of get_width() */ 


/**********************************************************★****************** 

* 

* get_j>recision() 

* 

* Get the precision for a specific output parameter. This is a number 

* field which can be preceeded by a + (default) or -. This number is 

* then followed by a format type (letter). 

* 

* See print_fp() for more details. 

* 

* This routine outputs the precision which can be positive or negative. 

* 

****************************************************************************/ 


static int get_precision(char *format, int *i) 

{ 

int itemp; 

char buf [10]; 

int n; 

int sign; 

int precision; 


itemp = *i; 

sign = PLUS; 

if (format[itemp] == 

{ 

sign = NEGATIVE; 
itemp++; 

) 

else if (format[itemp] == '+') 

itemp++; /* already is PLUS don’t need to flag this */ 


n = 0; 

buf[n] = NULL_CHAR; 

while (isdigit(format[itemp])) 

buf[n++] = format[itemp++] ; 
buf[n] = NULL_CHAR; 

precision = atoi(buf); 
if (sign == NEGATIVE) 

precision -1; 

*i = itemp; /* update the marker in format string */ 

return(precision); 

} /* End of get_j)recision 0 */ 

/***♦***★*******************★*********************************♦*************** 

199 



print_fp() 


Display value of a floating point number, either float or double. 

(The float is already casted as a double when passed to this routine. 


static void print_fp(char *obuf, double x, int precision, int width) 

{ 

char buf[40]; 

int buf_cnt = 0; 

double q, ql, q2; 

long int xi, d; 
int c, n; 


gcvt(x, precision, buf); 
street(obuf, buf); 
return; 


if (x == 0.0) 

{ 

buf{buf_cnt++) = 'O'; 
buf{buf_cnt++] = '.'; 
buf[buf_cnt++] = 'O'; 
buf[buf_cnt] = NULL_CHAR; 
street(obuf, buf); 
return; 

) 


/* Adjust precision to correct defaults for FP printing */ 
if (precision > 8) 
precision = 8; 
if (precision < 0) 
precision = 0; 


if (x < 0,0) 

{ 

buf[buf_cnt++] = '- ' ; 
X *= -1; 


/* Determine # of digits BEFORE the decimal place */ 
for (c = 0, q = X; q > 1; C++) 
q /= 10.0; 

if (c == 0) /* add leading zero before . -> O.xyz ♦/ 

buf(buf_cnt++3 = '0’; 

/* Display the digits BEFORE the decimal place */ 
for (q = X, n = 0; n < c; n++) 

{ 

d = powerdO, (c-l)-n); 
ql = q/d; 

buf [buf_cnt++] = '0' + (unsigned int)ql; /* TOP digit */ 

q2 = (unsigned int)ql * d; /* Only the most significant */ 

q = q - q2; /* Remove largest factor of 10 */ 

} 

bufIbuf_cnt++] = '.’; 

for (n = 0; n < precision; n++) 

{ 

q = q * 10; 

ql = (unsigned int) q; /* O.xyz --> x.yz */ 

buf tbuf_cnt++l = 'O' + ql; /* TOP digit (x) */ 

q = q - ql; /* remove largest factor of 10 */ 

} 

buf[buf_cnt++3 = NULL_CHAR; 
streat(obuf, buf); 
return; 

} /* End of print_fp() */ 


/* 




print_ptr() 


200 



Pointer print for FAR pointer (SEGMENT:OFFSET) or 
NEAR pointer (OFFSET). 

The parameter mode indicates if this is for NEAR or FAR pointer 
printing. 


The format for output is: 

0 1 
(char position) 01234567890 

NEAR xxxx <-- the OFFSET 

FAR xxxx;yyyy the OFFSET:SEGMENT 




static void print_ptr (char *obuf, void far *ptr, int mode) 

{ 


int 


n; 

unsigned 

char 

c; 

char 


buf[10] 

int 


b_cnt; 

unsigned 

long 

P; 


if (mode == FAR_PTR) 
b_cnt = 9; 

else 


b_cnt = 4; 

p = (unsigned long int) ptr; 
buf[b_cnt--] = NULL_CHAR; 
for (; b_cnt >= 0; b_cnt-~) 

{ 

c = (unsigned char) (OxOOOOOOOFL & p) ; 
if ((c >= 0) && (c <= 9)) 

buf [b_cnt] = c + 'O'; 

else 


buf[b_cnt] = (c - OxOA) + 'A'; 

p >>ss 4; 

/★ p>>=l; p>>=l; p>>=l; p>>=l; */ 

if (b_cnt == 5) 

buf[--b_cnt] = 


strcat(obuf, buf); 

} /* End of print_ptr() */ 




dprint() 

Printf for DCS. 


Special characters (translated by compilerl) 
”\n” CRLF 

n\\« \ 

% 

Format: %[width] [.precision] [size]type 
Types 

%c char 

%s string (char *) 

%d int (as decimal) 

%i int 

%u unsigned int 

%x int (as hex) 

%X int (as HEX) 

%p NEAR pointer (OFFSET) 

%P FAR pointer (SEGMENT:OFFSET) 

%f fp (%lf -> double, %f ->float) 

size 

L/1 - long 
H/h - short 




void 

{ 


dprint(char *format,...) 


/* ptr to argument list */ 

/* index in format string */ 

201 


va_list argjptr; 
int i; 


int temp_int; 

long t emp_long; 

double teTnp_fp; 
cha r t emp_cha r; 

char *temp_charptr; 

void far *temp_ptr; 

void *temp_ptr_near; 

static char buf [20]; /* temp buffer */ 

static char obuf[200]; /* the output buffer */ 

int hflag, Iflag; 

int hex^upper; 

int width, precision; 

static char crlf[3] = {CR, LF, NULL_CHAR}; 
int n; 


/* start variable arguement fetching */ 
va_start(arg_ptr, format); 

i = 0; 

Obuf[0] = NULL_CHAR; 

while (format[i] != NULL_CHAR) 

{ 

hex_upper = hflag = Iflag = FALSE; 
width = 100; 
precision = 3; 

.buf[0] = NULL_CHAR; 
switch (format[i]) 

{ 

case CR: 
case LF: 
i++; 

strcat(obuf, crlf); 
break; 

case '% *: 
i++; 

/* width ? */ 

if ((format [i] >= 'OM && (format [i] <= '9')) 

{ 

/* i++; */ /* or more */ 

width = get_width(format, &i); 

} 

/* .precision ? */ 
if (format[i] =- '.') 

{ 

i++; /* or more */ 

precision = get_precision(format, &i); 

} 

if {(format[i] == ‘h') j| (format[i] == 'H')) 

{ 

i + +; 

hflag = TRUE; 

/* set h flag */ 

) 

if {(format[i] == '!■) |1 (formatlil == 'L')) 

{ 

i + +; 

Iflag = TRUE; 

/* set 1 flag */ 

} 

switch(format[i])/* TYPE */ 

{ 

case 'd*: 
case 'D*: 
case 'i': 
case 'I *: 
i++; 

if (Iflag) 

temp_long = va_arg(arg_ptr, long); 

else 

temp_long = (long)va_arg(argjptr, int) 
Itoa(temp_long, buf, 10); 
strncat(obuf, buf, width); 
break; 


case 'u': 
case 'U': 
i++; 


202 




if (Iflag) 

teTnp_long = va_arg {arg_ptr, long) ; 

else 

temp_long = (long)va_arg(arg_ptr, int); 
Itoa(temp^long, buf, 10); 
strncat(obuf, buf, width); 
break; 


case 'X': 

hex_upper = TRUE; 
case 'X': 
i + + ; 

if (Iflag) 

tenip_long = va_arg (arg_ptr, long) ; 

else 

terap_long = 0x0000FFFFL& (long) va_arg (arg_ptr, int); 
Itoa(temp_long, buf, 16); 
if (hex_upper) 

for (n = 0; buf[n] != NULL_CHAR; n++) 
buf[n] = (char)toupper(buf[n]) ; 
strncat(obuf, buf, width); 
break; 


case 'c’: 
case ' C : 
i++; 

teinp_int = va_arg(arg_ptr, int) ; 

temp^char = (char) (teinp_int fit OxOOFF) ; 

bu f[0] = temp_char; 

buf[l] = NULL_CHAR; 

strcat(obuf, buf); 

break; 


case 's': 
case 'S': 
i + + ; 

temp_charptr = va_arg (arg_jptr, char *) ; 

strcat(obuf, temp_charptr); 

break; 

case 'f': 
case 'F': 
i++; 

if (Iflag) 

terap_fp = va_arg(argjptr, double); 

else 

teTnp_fp = (double) va_arg (arg_ptr, float); 
print_fp(obuf, temp_fp, precision, width); 
break; 


case 'p': 
i + +; 

temp_ptr = (void far *)va_arg(arg_ptr, void *); 

print_ptr (obuf, tetnp_ptr, NEAR_PTR) ; 

break; 


case •P': 
i ♦ + ; 

temp_ptr = va_arg(arg_ptr, void far *) ; 
print_ptr(obuf, temp^ptr, FAR_PTR); 
break; 

default; /* not supported */ 

1 ♦ ♦ ; 

break; 

) !* End of SWITCH */ 

break. /• End of CASE */ 

default 

St meat (obuf, (format+i), 1); 

1 ♦ • . 

break, 

} /* End of SWITCH */ 

} /* End of WHILE •/ 

/* send to serial port */ 
put_string(obuf); 

va_end(arg_ptr); 


203 



} /* End of dprintO */ 



unsigned long intpower(unsigned int x, unsigned int y) 

{ 

unsigned int i; 
unsigned long intp; 

P = 1; 

for (i = 1; i <= y; i++) 

P *= X; 

return(p); 

} /* End of pow() */ 

End of printh, printx 


204 



rf.h, rf.c 


* RF.H 

* 

* Defines for the RF unit interface routines. 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 

* Date Who What 


* 30 Oct 1996 Jah Creation 

* 


#define 

RF_HPA 

7 

#define 

RF_LNA 

6 

#define 

RF_LHP_LHA 

3 

#define 

RF_LOP_LOA 

2 

#define 
#define 

RF_TX_RX 1 
RF_T_R 

0 


#ifdef RF 



#define 

TO CON 

0XFF56 

#define 

TOCNT 

OxFFBO 

#define 

TOCMPA 

0XFF52 

#define 

TOCMPB 

0XFF54 

#define 

TICON 

OxFFSE 

#define 

TICNT 

0XFF58 

#define 

TICMPA 

OxFFSA 

#define 

TICMPB 

OxFFSC 


static void 
static void 
static void 
static void 


rf_jpower (int mode) ; 
rf_set(int Ctrl, int mode); 
rf_timer(int delay); 
rf_txpower(int mode); 


#endif 


#ifndef RF 

extern void 
extern void 
extern void 
extern void 


rf_power(int mode); 
rf_set{int Ctrl, int mode); 
rf__timer(int delay); 
rf_txpower(int mode); 


#endif 


/****************♦************************************★*★********************* 

* 

* RF.C 

* 

* Interface routines for the RF unit. 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* Date Who What 

* - + - + - 

* 30 Oct 1996 Jah Creation 




tinclude "gen_defs.h” 

#define RF 

#include "rf.h” 

#undef RF 


205 








static int rf_pcb = 0; 






* voidrf__power{int mode) 

* 

* Used to turn on or off the power to the entire RF unit. 

* 

******★****************♦******★********♦***♦********************************/ 

void rf_power (int mode) 

{ 

eps_set_power(RF, mode); 

} /* End of rfjpowerO */ 

/********ic*'k***1t1,*ir1r*********tc-k*ieit*icirii*************-k**iti,***1fk**ir*****i,******** 

* 

* void rf_set (int Ctrl, int mode) 

* 

* Allows individual bit control of the RF PCB controls. Any bit can be 

* toggled preserving other control bits. Note: the LNA logic is reversed. 

* 

******ir***********1r*1r1c******ir********-kic*-kic1r1c***1t************1fk**ir******ir*1r**/ 


voidrf_set (int Ctrl, int mode) 

( 

switch (Ctrl) 

{ 

case RF_T_R: 
case RF_TX_RX: 
case RF_LOP_LOA: 
case RF_LHP_LHA: 
case RF_HPA: 

if (mode == ON) 

rf_pcb j= (1 << Ctrl); 

else 

rf_pcb &= ~(l << Ctrl) ; 
pcb_write (RF, 0, rf_pcb); 
break; 

case RF_LNA: 

/* reversed logic for LNA control: this is because when the RF 
* unit goes on, you want an LNA on by default. 

*/ 

if (mode == OFF) 

rf_pcb 1= (1 << Ctrl); 

else 

rf^cb &= ~(l << Ctrl); 
pcb_write (RF, 0, rf__pcb) ; 
break; 

default: 

break; 

) 

) /* End of rf_set() */ 




* voidrf_timer (int delay) 

* 

* Begins the RF transmitter timer using delay as a parameter (in seconds). 

* Timers 0 and 1 are used in the cascade mode. Timer 0 is set to a maximum 

* count, internal clock, retrigger, using Compare A only. Timer 1 is set 

* to use an external clock (output of Timer 0), in a one shot mode, using 

* the dual mode Compare A/Compare B. 

* 

****************************************************************************^ 

voidrf_timer(int delay) 

{ 

outpw(T0CNT, 0) ; 

OUtpw(T0CMPA, 0); 
outpw(T0C0N, OxCOOl); 

outpw(TlCNT, 0) ; 

outpw(TlCMPA, 1); /* smallest compare A */ 

outpw(TlCMPB, delay * 28); /* ~28 CMPB per second */ 

outpw(TlCON, 0xC006); /* ext. elk, 1 shot, CMPA/CMPB dual mode */ 

206 


/* maximum count (65536) */ 

/* internal elk, retrigger, CMPA only */ 


} /* End of rf_timer{} */ 


/***♦************************************************************************* 

* 

* voidrf_txpower(int mode) 

* 

* Change power level of the transmitter by controlling the 2-bit 

* attenuator. 

ir 

voidrf_txpower(int mode) 

{ 

rf_pcb -= OxCF; /* mask off all power bits (set to 0) */ 

rf_pcb 1= ((mode & 0x03) << 4); 
pcb_write (RF, 0, rf__pcb)/ 

} /* End of rf_txpower() */ 

End of rf.h, rf.c 


207 



scc.h, scc.c 

/*********♦********************★********♦************************************* 

* 

* see.H 

★ 

* see 

* 

* Petite Amateur Navy Satellite (PANSAT), 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History; 

* Date Who What 

* -^-^- 

* 17 July 1996 Jah Creation 

* 

****★*****★*************★***************************************************/ 


typedef struct 

{ 

BYTE reg; 

BYTE data; 

} scc_instr_struct; 


#define 

SCCA 

0 







#define 

SCCB 

1 







#define 

SCC_CHA_BUF_ 

_SIZE 

516 






#define 

SCC_CHB_BUF~ 

"size 

2048 






#define 

SCCA_CMD 

2 


/* 

Channel 

A 

Command 

*/ 

#define 

SCCA_DATA 

6 


/* 

Channel 

A 

Data */ 


#define 

SCCB_CMD 

0 


/* 

Channel 

B 

Command 

*/ 

#define 

SCCB_DATA 

4 


/* 

Channel 

B 

Data */ 


#ifdef 

SCC 









#define CHA_BUF_SIZE SCC_CHA__BUF_SIZE 
#define CHB_BUF_SIZE SCC_CHB_BUF_SIZE 

unsigned cnv_hex{char buf[]); 

unsigned long int cnv_lhex(char buf[]); 

get_char(void); 

get_string(char *string, int max); 
put_string(char *string); 
hex_ascii_dump(BYTE *ptr, int count); 
scc_init(void); 

scc_write_table(scc_instr_struct tablet], int channel); 
serial_in(void); 
serial_out(BYTE c); 
scca_wreg(int reg, int value); 
sccb__wreg (int reg, int value); 
scc_hunt(void); 


char 

void 

void 

void 

void 

void 

BYTE 

void 

void 

void 

void 

#endif 


#ifndef SCC 


extern unsigned cnv_hex(char buf[]); 

extern unsigned long int cnv_lhex(char buf []); 


extern char 
extern void 
extern void 
extern void 
extern void 
extern void 
extern BYTE 
extern void 


get_char (void) ; 

get_st ring (char *string, int max); 
put_string(char *string); 
hex_ascii_dump(BYTE *ptr, int count); 
scc_init(void); 

scc_write_table (scc_instr_struct tablet] / 
serial_in(void) ; 
serial_out(BYTE c); 


int channel) 


extern void 
extern void 
extern void 


scca_wreg(int reg, int value); 
sccb__wreg (int reg, int value); 
scc__hunt (void) ; 


extern BYTE cha_in_buf0t] ; 

extern BYTE cha_out_buf0t] ; 


208 





extern BYTE 
extern BYTE 
extern BYTE 
extern WORD 
extern WORD 
extern WORD 

#endif 


txa; 
rx_eom; 
hunt; 

a__txunderrun_eom ; 
a_rxoverrun; 
a_brk_abort; 


/***************************************************************************** 

* 

* scc.c 

•t 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software, 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School, 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* Date Who What 


* 17 July 1996 Jah Creation 

* 

****************************************************************************/ 

#include "gen_defs.h” 

#include ''gen_apis ,h" 

#include <stdio.h> 

#include <stdlib.h> 

#include <string.h> 


#define 

#include 

#undef 


#include 

#include 

^include 


see 

"scc.h" 

see 


'• dcs .h" 
"print.h" 
"terras.h" 


WORDjim = 0; 

WORDbl = 0; 

WORDb2 = 0; 

WORDb3 = 0/ 

W0RDb4 = 0; 

WORDal = 0; 

WORDa2 = 0; 

WORDa3 = 0; 

WORDa4 = 0; 

scc_instr_struct scca_init[] = 


{0x09, 

OxCO}, 

/* 

force hardware reset */ 

{0x04, 

0x20}, 

/* 

xl clock, SDLC mode, SYNC mode */ 

{0x01, 

0x00}, 

/* 

disable DMA and interrupts */ 

{0x02, 

0x00}, 

/* 

zero interrupt vectors */ 

{0x03, 

0xC8}, 

/* 

Rx 8 bits, Rx CRC enabled */ 

{0x05, 

0x61}, 

/* 

Tx 8 bits, Tx CRC enabled */ 

{0x06, 

0x00}, 

/* 

SDLC address field */ 

{0x07, 

0x7E}, 

/* 

AUTO RTS, EOM, TX flag */ 

{0x09, 

0x22}, 

/* 

No vector and no INTACK */ 

{OxOA, 

OxAO}, 

/* 

CRC preset=l, NRZI, Flag idle */ 

{OxOB, 

0x09}, 

/* 

TxCK=TRxC, RxCK=RTxC */ 

{OxOC, 

0x2E}, 

/* 

TCL 76,800 Hz */ 

{OxOD, 

0x00}, 

/* 

TCH */ 

{OxOE, 

0x02}, 

/* 

BRG=PCLK, DPPL=BRG */ 

{OxOE, 

0x03}, 

/* 

Enable BRG, BRG=PCLK */ 

{0x03 , 

0xC9}, 

/* 

Enable RX, CRC */ 

{0x05 , 

0x69}, 

/* 

Enable TX, CRC */ 

{0x00 , 

0x80}, 

/* 

Reset TxCRC */ 

{OxOf , 

0x00}, 

/* 

clear all IE bits */ 

{0x00 , 

0x10}, 

/* 

reset ext/status */ 

{0x00 , 

OxlO}, 

/* 

reset ext/status */ 

{0x01 , 

0x10}, 

/* 

int on all Rx or special */ 

{0x09 , 

0x2A}, 

/* 

enable interrupts}; */ 

{OxFF, 

OxFF} 

/* 

End */ 


}; 


scc_instr_struct sccb_init[] = 


209 









{ 


{0x04, 

0x44}, 

/* 

xl6 clock, 

1 stop, no parity */ 

{0x03, 

OxCO}, 

/* 

Rx 8 bits, 

Rx disabled */ 

{0x05, 

0x60}, 

/* 

Tx 8 bits. 

DTR, RTS, Tx off */ 

{OxOB, 

0x56}, 

/* 

Tx & Rx=BRG, TRxC=BRG */ 

{OxOC, 

0x16}, 

/* 

TCL */ 


{OxOD, 

0x00}, 

/* 

TCH */ 


{OxOE, 

0x02}, 

/* 

*/ 


{OxOE, 

0x03}, 

/* 

*/ 


{0x03, 

OxCl}, 

/* 

Rx 8 bits, 

Rx enabled */ 

{0x05, 

0x6A} , 

/* 

Tx 8 bits. 

Tx, RTS enabled */ 

{OxFF, 

OxFF} 

/* 

End */ 



}; 


BYTE hunt FALSE; 
WORDa_txunderrun_eom = 0; 

WORD a_rxover run = 0; 

WORD a_brk_abort = 0; 

ByTEcha_in_bufO [CHA_BUF_SIZE] ; 
BYTEcha_out_bufO [CHA_BUF_SIZE] ; 
BYTEtxa = OFF; 

BYTErx_eom = FALSE; 

BYTE chb 
BYTEchb 
int 
int 
int 
int 


* 

* cnv_hex() 

* 

unsigned cnv_hex(char buf[]) 

{ 

int i ; 

unsigned int val = 0; 


i = 0; 

while (buf[i] != '\0') 

{ 

val 16; 

/* ** ERROR ** w/ MSC6.0 compiler run-time lib*/ 

/* if (isdigit(buf[i])) */ 

/* *♦ ERROR ** w/ MSC6.0 compiler run-time lib*/ 

if ((bufli] >= 'OM ScEc (bufli] <= '9*)) 
val += buf[i] - ' 0 • ; 

else 

val += toupper(buf [i]) - 'A' + OxOA; 

i++ ; 

} 

return (val) ; 

} /* End of cnv_hex() */ 


* 

* cnv_lhex() 

* 

unsigned long int cnv_lhex(char buf[1) 

{ 

int i ; 

unsigned long int val = 0; 


in_buf[CHB_BUF_SIZE]; 
out_buf [CHB_BUP_SIZE] ; 
chb_in__now = 0 ; 
chb_in_next = 0; 
chb_out_now = 0; 
chb_out_next = 0; 


210 


i = 0; 

while {buf[i] != '\0') 

{ 

val *- 16; 

/* ** ERROR ** w/ MSC6.0 compiler run-time lib*/ 

/* if (isdigit(buf [i])) */ 

/* ** ERROR ** w/ MSC6.0 compiler run-time lib*/ 

if {(buf[i] >= '0’} && (bufli] <= '9')) 
val += buf [i] - '0'; 

else 

val += toupper(buf[i]) - 'A' + OxOA; 

i++; 

} 

return (val) ; 

} /* End of cnv_lhex() */ 


* 

* get_char() 

* 

char get_char (void) 

{ 

while (!is_serial_in0) 


return (serial_in 0 ) ; 

} /* End of get_char() */ 


/■k***ir****1r*1r1i**-kie*i,it**ie-k******ic***it****-k**ic**if**ifii*1e**it********-k******ir*±**** 

* 

* get_string{) 

* 

* Get a character string delimited by an ENTER and null-terminate 

* it. Can only accept upto max characters. 

* 

***1t***1r1,**1t1r*****1r1[********1i**ir**i(*ifk1c***ii*****ic**1r-k1t****ie****ii*irit***ir*itit**^ 


voidget_string (char *string, int max) 

{ 

register char c; 
register int i; 


i = 0; 

c = get_char(); 
while (c != CR) 

{ 

if (c == BACK_SPACE) 

{ 

if (i > 0) 

{ 

i-- ; 

serial_out ((BYTE)BACK_SPACE) ; 
serial_out((BYTE)' '); 

serial_out ( (BYTE) BACK__SPACE) ; 

} 

} 

else if (i < max) 

{ 

string[i++] = c; 
serial_out((BYTE)c) ; 


c = get_char{); 

} /* End of WHILE */ 

string [i] = NULL_CHAR; /* Note: CR not saved - NULL instead */ 

} /* End of get_string() */ 


211 



* 

* hex_a scii_dump() 

* 


void hex_ascii_dump{BYTE *ptr, int count) 

{ 

WORD val; 

int i, j; 


for (i = 0; i < count; i += 16) 

{ 

for (j = 0; j < 16; j++) 

{ 

val = ((WORD)*(ptr+i+j) & OxOOFF); 
if (val < 0x10) 
dprint(”0"); 
dprint(''%X ", val); 

) 

dprint(" "} ; . 

for (j = 0; j < 16; j++) 

{ 

val = ((WORD)*(ptr+i+j) & OxOOFF); 
if ((val >= 32) ScSc (val <= 127)) 
dprint ("%c'', * (ptr+i+j) ) ; 

else 

dprint("♦"); 

} 

dprint("\n”} ; 

) 

} /* End of hex_ascii__dump () */ 




* put_string() 

* 

* Send a null-terminated character string to the serial port. 

* 

*********-k**1,*****-k***it1c1t********-k-k********ictt**-k*********-k******-k******ie****/ 


voidput_string(char *string) 

{ 

register WORD state; 


while {*string != NU1.L_CHAR) 

{ 

chb_out_buf [chb_out_next++l = *string++; 
if (chb_out_next > CHB_BUF_SIZE-1) 
chb_out_next = 0; 

} 

state = disable_ints0 ; 
if (inp(SCCB_CMD) & 0x04) 

{ 

outp (SCCB_DATA, chb_out__buf [chb_out_now++] ) ; 

if (chb_out_now > CHB_BUF_SIZE-1) 
chb_out_now = 0; 

} 


if (state) 

enable_ints(); 

} /* End of put_string() */ 

* scc_init() 

* 


void scc_init (void) 

{ 

scc_write_table(scca_init, SCCA); 
scc_write_table(sccb_init, SCCB); 

} /* End of scc_init() */ 


212 


/***************************************************************************** 

* 

* scc_write_table() 

* 

****************************************************************************/ 

voidscc_write_table(scc_instr_struet table[], int channel) 

{ 

int x; 

int port; 


port = (channel == SCCA) ? SCCA_CMD : SCCB_CMD; 

inp{port); /* read status */ 

for (x = 0; table[x].reg != (BYTE)OxFF; x++) 

{ 

outp(port, table[x].reg); 
outp(port, table[x].data); 

) 

} /* End of scc_writestable() */ 


/***************************************************************************** 

* 

* serial_in() 

* 

* Serial input. Check to see if kbhitO was called to see if there 

* was a key pressed (and thus the key pressed has already been 

* retrieved and saved), if so return this. Otherwise, return 0. 

* 

*-k***1r****-k**********it***1r**1c1r******ie**ir*****ie1c******************i,**ir*****ir*/ 

BYTE serial_in(void) 

{ 

register BYTE key; 


if (chb_in_now == chb_in_next) 
key = 0; 


else 


key = chb_in_buf [chb_in_now++] ; 
if (chb_in_now > CHB_BUF__SIZE-1) 
chb_in_now = 0; 


return(key); 

} /* End of serial_in() */ 


/*****-k**********ic*******-kic***ir**-k-k**ii*1r**ir***1e*******-k******it**-k*********1e*i,-k 

* 

* is_serial_in{) 

* 

**‘k*1r******ir*1flr**it*1(***1i**-k***it*tt***-k***ic*i(**1iit*********ie*-k*****************/ 

int is_serial_in(void) 

{ 

if (chb_in_now == chb_in__next) 
return(FALSE); 

else 

return(TRUE); 

} /* End of is_serial_in0 */ 


/**ic**it*********t!ir1t****************1c***1tic****icic*iiit**ifk*1tir****-k*1eic***1fk**1rir**it* 

* 

* serial_out() 

* 

* Serial output. Add the given character to the wrap-around output buffer. 

* No check is made to see if the buffer is full. 

* 

**-k***-k*1r1t1c*1r*******************-k**1,***********it**1t*****-k***************ie**1r/ 

void serial_out(BYTE c) 

213 



{ 

register WORD state; 


chb_out_buf [clib_out_next++] = c; 
if (chb_out_next > CHB_BUF_SIZE-1) 
chb_out_next = 0; 

state = disable_ints0; 
if Minp(SCCB_CMD) & 0x04)) 

{ 

outp(SCCB_DATA, chb_out_buf[chb_out_now++]); 

if (chb_out_now > CHB_BUF_SIZE-1) 
chb_out_now = 0; 

) 

if (state) 

enable_ints(); 

} /* End of serial_out() */ 


* 

* scc_isr() 






void interrupt far scc_isr( 

unsigned es, unsigned ds, unsigned di, unsigned si, 
unsigned bp, unsigned sp, unsigned bx, unsigned dx, 
unsigned cx, unsigned ax, unsigned ip, unsigned cs, 
unsigned flags) 


static 

WORD 

save_rr0b = 

0; 

static 

WORD 

save_rr0a = 

0; 

static 

WORD 

save rrlb = 

0; 

static 

WORD 

rr2b. 

rr3a; 


static 

WORD 

rrOb, 

rrlb; 


static 

WORD 

rrOa, 

rrla; 



jim++; 


/* First, read the Interrupt Vector from Read Register 2. This is a 

* unique SCC register (i.e. it is not duplicate for both channels. 

* Furthermore, this register is accessed from channel B. 

*/ 

inp{SCCB_CMD); /* Reset pointer bits */ 

ou tp(SCCB_CMD, 2) ; 
rr2b = inp{SCCB_CMD); 
switch(rr2b) 

{ 

case 0x00: /* Ch B Tx buffer empty */ 

bl++; 

if (chb_out_now != chb_out_next) 

{ 

outp (SCCB_DATA, chb_out_buf [chb_out_now++] ) ; 
if (chb_out_now > CHB_BUF_SIZE-1) 

chb_out_now =0; /* time to wrap-around */ 


else/* no more to send out */ 

{ 

outp(SCCB_CMD, 0x28);/* WROB = 0x28 */ 

} 

outp(SCCB_CMD, 0x38); /* reset highest lUS */ 

break; 


case 0x02: /* Ch B Ext/Status change */ 

b2 + +; 

outp(SCCB_CMD, 0); 
rrOb = inp(SCCB_CMD); 

if ((save_rr0b & 0x80) ^ (rrOb & 0x80)) 
/* change in break/abort status */ 
inp(SCCB_DATA); 


214 



if (rrOb & 0x4 0) /* Tx underrun/EOM detected */ 

{ 

OUtp(SCCB_CMD, OxCO); 

} 

if (rrOb & 0x04) /* Tx buffer empty */ 

{ 

if (chb_out__now != chb_out_next) 

{ 

outp (SCCB_DATA, chb_out_buf [chb_out_now++] ) ; 
if (chb_out_now > CHB_BUF_SIZE-1) 

chb_out_now =0; /* time to wrap-around */ 

} 

else/* no more to send out */ 

{ 

outp (SCCB_CMD, 0x28);/* MROB = 0x28 */ 

) 

) 

if (rrOb & 0x01) /* Rx data available */ 

( 

chb_in_buf [chb__in_next+ + ] = inp (SCCB_DATA) ; 
if (chb_in_next > CHB_BUF_SIZE-1) 

chb_in_next = 0; /* time to wrap-around */ 

) 

save_rr0b = rrOb; 

outp{SCCB_CMD, 0x10); /* reset ext/status interrupt */ 

outp(SCCB_CMD, 0x30); /* reset special Rx cond. status ♦/ 

outp(SCCB^CMD/ 0x38); /* reset highest lUS */ 

break; 


case 0x04: /* Ch B Rx data ready */ 

b3++; 

chb_in_buf [chb_in_next++] = inp (SCCB_DATA) ; 
if (chb_in_next > CHB_BUF_SIZE-1) 

chb_in_next = 0; /* time to wrap-around */ 

outp(SCCB_CMD, 0x30); /* reset special Rx cond. status */ 

outp{SCCB_CMD, 0x38); /* reset highest lUS */ 

break; 


case 0x06: /* Ch B Special Rx condition */ 

b4++; 

OUtp(SCCB_CMD, 0x01); 
mb = inp (SCCB_CMD) ; 

if (rrlb & 0x20) 

{ 

/* Rx overrun error */ 

} 

if (rrlb & 0x01) 

{ 

/* data has cleared the (SCO transmitter */ 

) 

outp(SCCB_CMD, 0x30); /* reset special Rx cond. status */ 

outp(SCCB_CMD, 0x38); /* reset highest lUS */ 

break; 


case 0x08: /* Ch A Tx buffer empty */ 

al + + ; 
break; 


case OxOA: /* Ch A Ext/Status change */ 

a2 + + ; 

Outp(SCCA_CMD, 0x00); 
rrOa = inp(SCCA_CMD); 

if ((save_rr0a & 0x80) ^ (rrOa & 0x80)) 

/* change in break/abort status */ 

{ 

a_brk_abort++; 

/* Force PA-100 into reacquire */ 

) 

if (rrOa & 0x4 0) /* Tx underrun/EOM */ 

215 



a_txunderrun_eom++; 

/* OUtp (SCCA_CMD, OxCO); */ 

if (rrOa & 0x10) 

{ 

hunt = TRUE; 

/* ignore break/abort */ 

/* setup DMA for frame receive */ 

} 

else 

( 

hunt = FALSE; 

/* allow break/abort */ 

} 

if (rrOa & 0x04) /* Tx buffer empty */ 

al++; 

if {rrOa & 0x01) /♦ Rx character available */ 

a3++ ; 

save_rr0a = rrOa; 

outp{SCCA^CMD, 0x10); /* reset ext/status interrupt */ 

outp(SCCA_CMD, 0x30); /* reset special Rx cond. status */ 

outp{SCCA_CMD, 0x38); /* reset highest lUS */ 

break; 


case OxOC: /* Ch A Rx data ready */ 

a3++; 
break; 


case OxOE: /* Ch A Special Rx condition */ 

a4++; 

OUtp(SCCA_CMD, 0x01); 
rrla = inp(SCCA_CMD); 

if (rrla & 0x20) /* Rx overrun error */ 

( 

a_rxoverrun++; 

} 

if ((rrla & OxCO) == 0x80) /* EOF with NO CRC error */ 

{ 

outpw(DOCON, 0xA3A4) ; /* STOP DMA 0 - no more Rx */ 
cha_in_buf0[514 - inpw(DOTC) - 2] = NULL_CHAR; 

/* make it a char string */ 
rx_eom = TRUE; 

/* ignore break/abort */ 

} 

if ((rrla & OxCO) == OxCO) /* EOF with CRC error */ 

{ 

outpw(DOCON, 0XA3A4); /* STOP DMA 0 - no more Rx */ 

cha_in_buf0 [0] = NULL_CHAR; /* make it a char string */ 
rx_eom - FALSE; 

/* ignore break/abort */ 

) 

OUtp (SCCA_CMD, 0x3 0) ; 

OUtp (SCCA_CMD, 0x3 8) ; 

break; 

default: 

/* Error */ 
break; 

} /* End of SWITCH(rr2b) */ 


/* Check for any pending ints, which will cause the entire SWITCH above 
* to reiterate. 

*/ 

inp(SCCA_CMD) ; 
ou tp(SCCA_CMD, 3); 
rr3a = inp(SCCA_CMD); 

} while (rr3a 0); 


216 




/* Send non-specific EOT to Interrupt Controller */ 
outpw(0xFF2 2, 0x8 000); 

} /* End of scc_isr() */ 


/***************************************************************************** 

★ 

* scca_wreg() 

* 

void scca_wreg(int reg, int value) 

{ 

if (debug) 

dprint("SCCA WR: %X = %X'\ reg, value); 

outp{SCCA_CMD, reg); 
outp(SCCA^CMD, value); 

} /* End of scca_wreg() */ 


/*******************★*************★******************************************* 

* 

* sccb_wreg() 

* 

***1e'tr**1r1t********1tir*ir**ii**********'me*****ii1eifk-kirir****itit*1t*ic*1t**1r*it****irit1r*1r**^ 

void sccb_wreg(int reg/ int value) 

{ 

if (debug) 

dprintC'SCCB WR: %X = %X", reg, value); 

outp(SCCB_CMD, reg); 
outp(SCCB_CMD, value); 

} /* End of sccb_wreg() */ 


* 

* scc_hunt) 

* 

void scc_hunt(void) 

{ 

unsigned long inti; 


dprint("Entering Hunt Mode"); 

OUtp(SCCA_CMD, 3); 

outp(SCCA_CMD, 0xD8); /* Disable receiver */ 

outp(SCCA_CMD, 3); 

outp(SCCA_CMD, 0xD9); /* Enable receiver & enter Hunt mode */ 

for (i = 0; i < OxOOOlFFFFL; i++) 

{ 

if ((i%0x3FFFL) == 0) 
dprint("."); 

if (!(inp{SCCA_CMD) & 0x010)) 
break; 

) 

if (inp(SCCA_CMD) St 0x010) 

dprint("Sync (Flag) not detected, still in Hunt Mode\n"); 

else 

dprint("Sync (Flag) detected!\n"); 

} /* End of scc_hunt() */ 

End of scc.h, scc.c 


217 


scenario.h, scenario.h 

/***************************************************************************** 

* 

* SCENARIO.H 

* 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 

* Date Who What 






* 

* SCENARIO.C 


* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 


* Revision History: 


* Date Who What 

* -^ - ^ - 




#include "gen_defs.h“ 

#define SCENARIO 

#include "cmd.h" 

#undef SCENARIO 


End of scenario.h, scenario.c 


218 








spacketh, spacketc 

* 

* SPACKET,H 


* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* Date Who What 




* 

* SPACKET.C 


* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* • ‘ 

* Revision History: 


* Date Who What 


*********♦******************************************************************/ 

# include ''gen_def s .h" 

#define SPACKET 

#include "spacket.h" 

#undef SPACKET 


End of spacketh, spacketc 


219 









startup.asm 


* 80186 C Startup 

★ 

* This is the beginning of ROM code for PANSAT. 


Revision History 




When 


Who 

What 

28 March 1996 

Jah 


Adopt for Pansat DCS 


FALSE equ 0 

TRUE equ 1 


* 

* MACRO: transmit 

* 


transmit 

LOCAL 


MACRO 

transmit wait 


mov bx, ax 


transmit_wait: 

in al, SCCB_CMD 

and al, 4 

j z t ransmit_wait 

mov ax, bx 

out SCCB_DATA, al 


ENDM 


. * 

/* MACRO: DELAY 
. * 

delay MACRO delay_time 
LOCAL delay_loop 

mov cx, delay_tirae 

delay_loop; 

dec cx 

jnz delay_loop 

ENDM 

. * 

;* MACRO: DISPLAY 
. * 


display 

MACRO 


LOCAL 

displayl 


LOCAL 

display2 


shr 

ax, cl 


and 

al, OFh 


cmp 

al, 9 


jb 

displayl 


add 

al, 037h 

/adjust A-F 

jmp 

displayl: 

display2 


add 

display2: 

transmit 

al, 'O' 

/adjust 0-9 


220 
















ENDM 


; Specify stack size. 

STACK_SIZE EQU 800H /defined in WORDS (2 bytes) = 4k bytes 


*1r*****-k1t***1c*it*ic***ititie***it*ieit**-k*iiir**it**ii***1e**i(ieieit*1t***1eie*ir***-k**ir*****ir*** 

Place EXTRN statements for interrupt handling routines outside 
of all SEGMENT/ENDS pairs. 

***ititit*******1[ie*ie*'k*******-k***1e-k*1c*****ic***-k***it*ir*****ieic**ir***********-k*ie*** 

For example, suppose you have an interrupt handling routine written in C 
with the function name int_hdlr{). 

In order for you to reference the routine in this file, you should declare 
_int_hdlr as an external reference (note that the C compiler prefixes an 
underscore character to the function name). The declaration should be 
placed outside of all SEGMENT/ENDS pairs as follows; 

EXTRN _int_hdlr:FAR 

Refer to the sample code below that initializes the interrupt vector table. 


***1r****ifk-ki,irii1c*ifk1r**1tit**ie1fk-k-k'kit******-kir**-kic**iei[********ic*1c**ir*itit**ieir*ir*-k*ir** 

The primary function of the start-up code is to set up the run-time 
environment before passing control to C function main(). 

The start-up code performs the following functions; 

1) Initialize hardware and check RAM. 

2) Copy initializers from ROM to RAM to setup initialized program variables 
to proper initial values. 

3) Zero all uninitialized program variables. 

4) Initialize interrupt vector table, if necessary. 

5) Setup data segment. 

6) Setup stack segment. 

7) Pass control to C function main(). 


PUBLIC _acrtused 

_acrtused EQU 1 


The symbol _acrtused has to be in lower-case. Starting from version 4, 

when the Microsoft C optimizing compiler compiles a C file, it places an 
external reference to this symbol in the object file. The public definition 

of _acrtused is contained in an object module called crtO, This module is 

placed in the Microsoft C run-time library file. This module contains the 
start-up code for the DOS environment. So when you link your C object files 
with the run-time library file, the linker will extract the start-up object 
module from the run-time library file to satisfy the external references. 

As a result, the start-up code for DOS environment will be included in the 
linker output. 

If you do not make use of any function supplied in the run-time library 
file, you do not link with the library file at all. Then you have to 

include a public definition of acrtused in this file to resolve all the 

external references in the C object files. 

Even though you are building an application for an embedded environment, 
sometimes you may want to link with the run-time library file. The reason 
is that the run-time library file contains both DOS-dependent functions, 
such as printfO, and DOS-independent functions, such as strcpyO. If you 
want to make use of certain DOS-independent functions that are contained in 
the run-time library file, you would link with the library file. If the 
link map shows that the linked module contains the crtO module, you know 
that you have linked in some DOS-dependent functions from the run-time 
library file. 

Make sure you specify this start-up file as the first object file 
in the linker command line, then the other object files and place the 
modified combined run-time library file as the last file. 

The following memory map shows a typical run-time environment of an embedded 
application developed using the Microsoft C optimizing compiler. 

It will help you understand the start-up code presented in this file. 

The naming convention of class names presented here conforms with the 
Microsoft C optimizing compiler, version 4 and up. The names enclosed in 
single quotes are class names of segments. 

High address 


FFFF;0-<-- Bootstrap code (JMP FAR PTR START_) 


I [FAR_DATA] | This area of ROM contains initializers that 

221 







I 

I 

R 

0 

M 


I 

I 


R 

A 

M 


_etext 

_start 
START ' 


end 


edata 


bdata 

ehbss 

bhbss 

efbss 

bfbss 
_ef data 

bfdata 


[CONST] 


[DATA] 


[DATA_BEG] 


'CODE END' 


’ CODE ’ 


•STACK' 


'BSS END' 


'BSS' 


'DATA END' 


'CONST' 


•DATA' 


•DATA BEG' 


'HUGE BSS END' 


'HUGE BSS' 


'HUGE BSS BEG' 


•FAR BSS END' 


•FAR BSS' 


'FAR BSS BEG' 


'FAR DATA END' 


'FAR DATA’ 


'FAR DATA BEG' 


1 


I 


0:0 -- 
Low address 


I are used by start-up routine to initialize 
I segments with these class names in RAM at 
I power-up. 

I (The INITDATA control causes the PROM86 
I utility to place initializers between address 
V labels _bdata and _edata and between _bfdata 
and _efdata in this area of ROM) 

<- This class contains only one segment of zero 

length. Initializers are located at _etext. 
Text segments with class name CODE. 


<- End of DGROUP (size of DGROUP <= 64K bytes) 

<-- This class contains the stack. 


This class contains uninitialized data. 


These three classes of segments are to be 
j initialized with initializers in ROM 
j by start-up routine at power-up. 

I 

V 

<- Start of DGROUP 


This class contains uninitialized data. 


<-- This class contains uninitialized data. 


<-- This class contains initialized data. 


<-- The interrupt vector table should be 

initialized by start-up routine at power-up. 


NOTE: 

It is important to maintain the order of SEGMENTS/ENDS pairs as shown 
below. 


Text segments all have class name CODE. They contain program code 
which is machine instructions generated by the compiler. 

Data segments with class names DATA_BEG, DATA, CONST, BSS and STACK 
belong to a group named DGROUP. Since these segments belong to 
a group, it fcl lows that the total memory space occupied by them 
cannot exceed C4K bytes. 

The object files tnay contain data segments with class names 
FAR_DATA. FAP FiS.*; and HUGE_BSS. 

These classes c! segments are generated by the Microsoft C 
optimizing compiler to support 'far' and 'huge' data objects. 

Check your C manual for details. 

Data segments with class names FAR_BSS and HUGE_BSS contain 
'far' and ’huge* uninitialized data, respectively. These segments 
do not belong tc any group. They should be located before 
the group DGROUP in the RAM space of your target system. The 
advantage of locating these segments before DGROUP is that you may 
use the memory space from the end of STACK segment to the end of 
RAM as heap to implement your own memory allocation scheme. 

For 'huge' data objects, multiple segments may be generated by the 
C compiler to hold a single data object that is greater than 64K 
bytes in size. These segments must be located together in proper 
order. 


222 

































Data segments with class name FAR_DATA contain 'far* and 'huge' 
initialized data. They should also be located before the group 
DGROUP in the RAM space of your target system . 

When you prepare data file for programming eprom, the initializers 
for segments with class names DATA_BEG, DATA, CONST and FAR_DATA 
have to be placed in ROM addresses behind the CODE_END class. 

The INITDATA control of PROM86, version 5,2 and up, performs this 
operation for you. At power-up, the start-up routine will copy these 
initializers from ROM to initialize the appropriate variables in RAM. 

In order to make use of the INITDATA control in PROM86, you 

must preserve the following public labels in this start-up file: 

_bfdata - beginning of initializers in FAR_DATA class 

_efdata - end of initializers in FAR_DATA class 

_bdata - beginning of initializers in DGROUP group 

_edata - end of initializers in DGROUP group 

_etext - end of code 

If you want PROM86 to determine the extraction address range, 
i.e. the ADDRESSES option is not specified in PROM86 v6.0, you must 
preserve the public label _start_ in this start-up file. 

In addition to the above labels, the routine in this start-up file 
uses the following public labels: 

_end - end of uninitialized data in BSS class 
_bfbss - beginning of uninitialized data in FAR_BSS class 
_efbss - end of uninitialized data in FAR_BSS class 
_bhbss - beginning of uninitialized data in HUGE_BSS class 
_ehbss - end of uninitialized data in HUGE_BSS class 


* 

* Segment declarations 

* 


* 

* BEGFDATA 

* 


BEGFDATA SEGMENT PARA PUBLIC ’FAR_DATA_BEG' 

PUBLIC _bfdata 

_bfdata LABEL BYTE ; This label marks the beginning of initialized data 

in FAR_DATA class. 

BEGFDATA ENDS 


* ******************************************************************************* 
■ * 

;* FAR_DATA_START 

, * 

.*1t1i*1t*****itir*ir**ic*ie**1t*1t*ieitieifk**ieie*ii*1t1i***it1e*******1t*****ifk**irit***1r*1rie***it*** 

FAR_DATA_START SEGMENT PARA PUBLIC 'FAR_DATA' 

FAR_DATA_START ENDS 

; By default, the locator places segments with the 
; same class name together. 

; The purpose of the FAR_DATA_START segment is to cause the locator 
; to locate all segments with class name FAR_DATA that contain 
; initialized variables between the BEGFDATA and ENDFDATA segments. 

EMULATOR_DATA segment para public 'FAR_DATA' 

; Segment contains data for the floating point emulator. 

EMULATOR_DATA ends 

.**»*************************************♦*******♦*************************♦** 

.« 

;♦ ENDFDATA 

. * 

I 

fit**-t***it***i,1t*±l[*1ftfk**ifk-k-k****-k*****1r**************1r*-k******ic*ie'kiti(icieici(itifk*it*ie 

ENDFDATA SEGMENT PARA PUBLIC 'FAR_DATA_END' 

PUBLIC _efdata 

_efdata LABEL BYTE ; This label marks the end of initialized data 

223 















; in FAR_DATA class. 

ENDFDATA ENDS 


* 

* BEGFBSS 




BEGFBSS SEGMENT PARA PUBLIC ’ FAR__BSS_BEG' 

PUBLIC _bfbss 

_bfbss LABEL BYTE ; This label marks the beginning of uninitialized 

; data in FAR_BSS class. 

BEGFBSS ENDS 


. * 

; * FAR_BSS_START 
. * 

FAR_BSS_START SEGMENT PARA PUBLIC 'FAR_BSS' 
FAR_BSS START ENDS 


By default, the locator places segments with the same class name 
together. 

The purpose of the FAR__BSS_START segment is to cause the locator to locate 
all segments with class name FAR_BSS between the BEGFBSS and ENDFBSS 
segments. 

Segments with class name FAR_BSS contain uninitialized variables. 


.*****************************it****************i^****************************** 

. * 

;* ENDFBSS 
; * 

•********************‘*fir*-k********iHr***it****irit*itir*-k***ir*****itie*********it***ir**it 

ENDFBSS SEGMENT PARA PUBLIC 'FAR_BSS_END' 

PUBLIC _efbss 

_efbss LABEL BYTE ; This label marks the end of uninitialized data 

; in Fi^R_BSS class. 

ENDFBSS ENDS 


* 

* BEGHBSS 




BEGHBSS SEGMENT PARA PUBLIC 'HUGE_BSS_BEG' 

PUBLIC _bhbss 

_bhbss LABEL BYTE ; This label marks the beginning of uninitialized 

; data in HUGE_BSS class. 

BEGHBSS ENDS 




* HUGE_BSS_START 

* 


HUGE_BSS_START SEGMENT PARA PUBLIC ’HUGE_BSS' 
HUGE_BSS_START ENDS 


By default, the locator places segments with the same class name 
together. 

The purpose of the HUGE_BSS_START segment is to cause the locator to locate 
all segments with class name HUGE_BSS between the BEGHBSS and ENDHBSS 
segments. 

Segments with class name HUGENESS contain uninitialized variables. 




224 
























;* ENDHBSS 
; * 

• **'kitie1[1rif*ir1fk*it1eit1c****1e***-k-k1e*******1i*******it****ii1t**ir****ie1e***i[***ie**ir****if** 

ENDHBSS SEGMENT PARA PUBLIC ' HUGE_BSS_END' 

PUBLIC _ehbss 

_elibss LABEL BYTE ; This label marks the end of uninitialized data 

; in HUGENESS class. 

ENDHBSS ENDS 


-***************************************************************************** 

. ★ 

; * DGROUP segments 

. * 

****************************************************************************** 

; DGROUP GROUP NULL, _DATA, CONST, ENDDATA, _BSS, ENDBSS, STACK 

DGROUP GROUP NULL,_DATA, PSP, CDATA, CONST, HDR, MSG, PAD, EPAD, ENDDATA,_BSS, ENDBSS, STACK 

.***************************************************************************** 

- * 

;* NULL 
. * 

;* This segment contains 8 bytes of zeros. If a (DS:0) null pointer assignment 

!* occurs, these byte locations will be overwritten. You may implement your 

;* own routine to check for null pointer assignment. 

• ★ 
i 

f^iriririricititieitiFiripiriFiritiriticieiricieieie'kifirieic-kieitiriFielrie'k-k-kie-k'kicieipieiriFirir-kir’kitieieie-t’kiriFiriFic-kici^iriticir-kicir 

NULL SEGMENT PARA PUBLIC 'DATA_BEG' 

PUBLIC _bdata ; This label marks the beginning of initialized data. 

_bdata LABEL BYTE 
DB 8 DUP (0) 

NULL ENDS 


.***************************************************************************** 
. * 

;* _DATA 
; * 

; * Segment with class name DATA contains initialized variables. 

. ★ 

,****************************************************************** *********** 

_DATA SEGMENT WORD PUBLIC 'DATA* 

; segment contains initialized variables 
PUBLIC _fac 

_fac DQ 0 ;FP Accumulator 

PUBLIC _errno 

_errno DW 0 /Initial Error Code 

DATA ENDS 


PSP SEGMENT PARA PUBLIC 'DATA* ; MUST BE PARAGRAPH ALIGNED 
; Segment contains data for initializing floating point emulator. 
PSP ENDS 

CDATA SEGMENT WORD COMMON 'DATA' 

DW 0 ; DO NOT DEFINE ANY VARIABLE IN THIS SEGMENT 

_fpinit LABEL DWORD 

PUBLIC _fpinit 

CDATA ENDS 


.***************************************************************************** 

. * 

;* CONST 

f * 

;* Segment with class name CONST contains constants. 

- * 

.***************************************************************************** 

CONST SEGMENT WORD PUBLIC 'CONST' 

CONST ENDS 


HDR SEGMENT BYTE PUBLIC 'MSG' ; HEADER SEGMENT OF ERROR MESSAGE STRINGS 
DB '<<NMSG»' 

HDR ENDS 


225 








MSG SEGMENT BYTE PUBLIC 'MSG' ; ERROR MESSAGE STRINGS 
MSG ENDS 

PAD SEGMENT BYTE COMMON 'MSG' ; ERROR MESSAGE PADDING MARKER 
DW -1 
PAD ENDS 

EPAD SEGMENT BYTE COMMON 'MSG' ; END OF PADDING MARKER 
DB -1 
EPAD ENDS 


* 

* ENDDATA 




****** 


ENDDATA SEGMENT PARA PUBLIC 'DATA_END' 

PUBLIC _edata 

_edata LABEL BYTE ; This label marks the end of initialized data. 

ENDDATA ENDS 


*************************1e*********-k*-kie*1t******ifiriric***'k***-k***ir*-k1r*ic-k-kirit***1eit 

* 

* _BSS 

* 

* Segment with class name BSS contains uninitialized variables. 

* 

*****************1t**ir******it**1e1r1r**ie*1eiritifkir**itir**-k**it*****ititit*ieit1cir1c**ic*irititieirit 


BSS SEGMENT WORD PUBLIC 'BSS' 

_BSS ENDS 


* 

* ENDBSS 






ENDBSS SEGMENT WORD PUBLIC 'BSS END' 


PUBLIC _end 

_end LABEL BYTE ; This label marks the end of uninitialized data. 

ENDBSS ENDS 








* STACK 

* 


STACK SEGMENT PARA STACK 'STACK' 
DW STACK_SIZE DUP (?) 

Stack_tOp LABEL WORD 
STACK ENDS 






TEXT 






_TEXT SEGMENT PARA PUBLIC 'CODE' 
EXTRN __main:NEAR ;C main() 

ASSUME CS:_TEXT 

ASSUME DS:DGROUP, SS:DGROUP 


80186 Initialization 

UMCS equ OFFAOh ;upper memory chip select 

equ 0F038h ; start of EPROM F000:0, 64 K 

226 









external Ready ignored, 0 wait states 


Lower Memory Chip Selects are NOT used 


PACS egu 0FFA4h 

PACS_DATA equ OOOOh ;PCS0 (base) = 0, bus ready must be active 

; to complete a bus cycle, no wait states 
; inserted in bus cycle 


MMCS equ 0FFA6h 

MMCS_DATA equ OOOOOh /Start = 0:0, 512K in size 


MPCS equ OFFASh 

MPCS_DATA equ 04087h 


512K block, + PCS5/6 

PCSx go active for i/o bus cycles, 
requires bus ready be active to complete 
bus cycle (applies to PCS4-PCS6), 

0 wait states inserted for PCS4-PCS6 


PUBLIC START_ 
START_: 

PUBLIC _start 
Start : 


/Must be paragraph aligned (i.e. offset is 0) 
and the address where program code starts. 


80186 Initialization 


mov 

dx. 

MMCS 

mov 

ax. 

MMCS_DATA 

out 

dx. 

ax 

mov 

dx. 

MPCS 

mov 

ax. 

MPCS_DATA 

out 

dx. 

ax 

mov 

dx. 

PACS 

mov 

ax. 

PACS_DATA 

out 

dx. 

ax 


* For the test board w/ separate 1.8MHz SCC clock 
mov dx, 0FFA2h 
mov ax, 03FF8h 
out dx, ax 
mov dx, 0FFA4h 
mov ax, 0037h 
out dx, ax 
mov dx, 0FFA6h 
mov ax, 041F8h 
out dx, ax 
mov dx, 0FFA8h 
mov ax, 0A038h 
out dx, ax 




* Init Peripheral Control Bus 

* 8255 (PPI) at OxCO, 0xC2, 0xC4, 0xC6 

* Mode 2: Port A = bidirectional using Port C as handshaking 

* Port B = Address selections and Read & Write strobes 

* Port C = Handshaking lines 

* 

* After PPI init. Port B is set to OxCO which sets the Read and Write 

* lines high, which clears them since they are active low signals. 

* 

****1rir1fkir**ir*ir*1r***1r**'k'k1t*-k*-k*-kicir***-k1cit**1r*********-kir****ic*it**'k*1e*ic*iiieic**-k*** 


PCB_PPI_BASE equ 
PCB_PPI_PortA equ 
PCB_PPl_PortB equ 
PCB_PPI_PortC equ 
PCB_PPI_Ctrl equ 


OlOOh 

PCB_PPI_BASE + 0 
PCB_PPI_BASE + 2 
PCB_PPI_BASE + 4 
PCB PPI BASE + 6 


/ Port C single bit set/reset 


PCB_ 

PortC_ 

_SetO 

equ 

Olh 

Sets 

Port 

c, 

bit 

0 

to 

1 

PCB~ 

'Portc^ 

Reset0 

equ 

OOh 

Sets 

Port 

c, 

bit 

0 

to 

0 

PCB~ 

'Portc' 

Setl 

equ 

03h 

Sets 

Port 

c. 

bit 

1 

to 

1 

PCB_ 

_PortC_ 

Resetl 

equ 

02h 

Sets 

Port 

c. 

bit 

1 

to 

0 

PCB_ 

PortC_ 

_Set2 

equ 

05h 

Sets 

Port 

c. 

bit 

2 

to 

1 

PCB_ 

_PortC_ 

Re set2 

equ 

04h 

Sets 

Port 

c. 

bit 

2 

to 

0 


mov 

dx. 

PCB_PPI_Ctrl 


mov 

al, 

OCOh 


out 

dx. 

al 

/Setup via the Control port 


227 











mov 

dx, 

PCB_PPI_PortB 


out 

dx, 

al 

/Output to port b (Read & 

mov 

dx, 

PCB_PPl_PortA 


sub 

al, 

al 


out 

dx. 

al 

/Output to port a (Data = 

mov 

dx. 

PCB_PPl_Ctrl 


mov 

al, 

PCB_PortC Setl 

/PCI = PPI Input Strobe 

out 

dx, 

al 


mov 

al, 

PCB_PortC_SetO 

/Modem Power (Active LOW - 

out 

dx, 

al 


Lear 

power settings on EPS (Ports 0 and 2) 

mov 

dx. 

PCB_PPI_PortA 


mov 

al. 

0 


out 

dx, 

al 


mov 

dx. 

PCB_PPI_PortB 


mov 

al. 

0E8h 

/II 10 1000 

out 

dx. 

al 


mov 

al. 

0A8h 

;10 10 1000 

out 

dx. 

al 


mov 

al, 

0E8h 

;11 10 1000 

out 

dx. 

al 


mov 

dx. 

PCB_PPI_PortB 


mov 

al, 

0C8h 

/II 00 1000 

out 

dx. 

al 


mov 

al. 

088h 

,-10 00 1000 

out 

dx. 

al 


mov 

al, 

0C8h 

;11 00 1000 

out 

dx. 

al 



Init 

85C30 (Channel B) for: 

asynchronous, 9600 

bps, no parity, 1 stop bit, 8 








SCCB_CMD 

equ 

0 



/Channel B Command 

SCCB_DATA 

equ 

4 



/Channel B Data 

SCCA_CMD 

equ 

2 



/Channel A Command 

SCCA_DATA 

equ 

6 



/Channel A Data 

BTABLE_LEN 

equ 

(OFFSET SCCb_ 

table 

_end) - 

(OFFSET sccb_table) 

ATABLE_LEN 

equ 

(OFFSET scca_ 

table 

_end) - 

(OFFSET scca_table} 

10 CON 

equ 

0FF38h 




I0CON_INIT 

equ 

OOCh 



/Edge-triggered, turned OFF 

INT0_ISR 

equ 

12 





priority 4 


/public init_scca 
;init_scca: 


in 

al. 

SCCA_CMD 

/read status 

mov 

bx. 

ATABLE LEN 



mov bp, OFFSET scca_table 

public table_loada 
table_loada: 
mov 
out 
inc 
dec 
jnz 

init sccb: 


in 

al. 

SCCB_CMD 

/read status 

mov 

bx. 

BTABLE_LEN 


mov 

bp. 

OFFSET sccb_ 

table 


public table_loadb 
table loadb: 


al, cs:[bp] 
SCCA_CMD, al 
bp 
bx 

table loada 


228 









mov 

al, cs:[bp] 


out 

SCCB_CMD, al 


inc 

bp 


dec 

bx 


jnz 

table__loadb 


public table 

_loadb_done 


table_loadb_ 

done: 


mov 

al, 


transmit 

jmp 

edac_done 


jmp 

init_edac 


scca_table: 

db 

009h 

;point to WR9 

db 

OCOh 

;force hardware reset 

db 

004h 

/point to WR4 

db 

020h 

;xl clock, SDLC mode, SYNC mode 

db 

OOlh 

/point to WRl 

db 

OOOh 

/disable DMA and interrupts 

db 

002h 

/point to WR2 

db 

OOOh 

/zero interrupt vectors 

db 

003h 

/point to WR3 

db 

0C8h 

/Rx 8 bits, Rx CRC enabled 

db 

005h 

/point to WR5 

db 

061h 

/Tx 8 bits, Tx CRC enabled 

db 

006h 

/point to WR6 

db 

OOOh 

/SDLC address field 

db 

007h 


db 

07Eh 


db 

OOFh 

/point to WRl5 

db 

091h 

/Enable Int: Break/Abort, Sync/Hunt 

db 

007h 

/point to WR7 

db 

063h 

/Extended Read, get CRC bits, AUTO RTS, EOM, TX 

db 

009h 

/point to WR9 

db 

022h 

/No vector and no INTACK 

db 

00 Ah 

/point to WRIO 

db 

OAOh 

/CRC preset=l, NRZI, Flag idle 

db 

OOBh 

/point to WRll 

db 

009h 

/TxCK=TRxC, RxCK=RTxC 

;; c3b 

056h 

/TxCLK=BRG, RxCLK=BRG, TRxC=output using BRG 

; db 

OOCh 

/point to WRl2 

; db 

45 

;TCL: to give 78.125 KHz clock 

; db 

OODh 

/point to WRl3 

; db 

OOOh 

;TCH 

db 

OOEh 

/point to WR14 

db 

OOOh 

;BRG=RTxC pin 

; db 

002h 

/BRG=PCLK 

db 

OOEh 

/point to WR14 

db 

005h 

/Enable BRG, BRG=RTxC pin, DTR/Request Function 

; db 

007h 

/Enable BRG, BRG=PCLK, DTR/Request function 

db 

003h 

/point to WR3 

db 

0D9h 

/Enable RX, CRC, enter hunt 

db 

005h 

/point to WR5 

db 

069h 

/Enable TX, CRC 

db 

OOOh 

/point to WRO 

db 

080h 

/Reset TxCRC 

db 

OOOh 

/point to WRO 

db 

OlOh 

/reset ext/status 

db 

OOOh 

/point to WRO 

db 

OlOh 

/reset ext/status 

229 



db 009h 

db 02Ah 


scca_table_ 

end: 


sccb_table: 

/ based on 

SCCB 1 

using 

db 

04h, 

044h 

db 

Olh, 

012h 

db 

03h, 

OCOh 

db 

05h, 

060h 

db 

OBh, 

056h 

/ db 

OCh, 

016h 

db 

OCh, 

OAh 

/ db 

OCh, 

04h 

db 

ODh, 

OOOh 

db 

OBh, 

003h 

db 

03h, 

OClh 

db 

05h, 

06 Ah 

db 

OOh, 

OlOh 

db 

OOh, 

028h 

db 

09h, 

, 02Ah 


/point to WRl 

/DMA Request Mode, Int on Special Rx, EXT INT enable 
/DMA Rec[uest Mode, Int on Special Rx 

/point to WR9 
/enable interrupts 


: at 7.3728 MHz, xl6 clock mode, at 38400 b/s 

/WR4, xl6 clock, 8 bit sync, 1 stop bit, no parity 

/WRl, INT on all Rx or special, Int on Tx empty 

/WR3, Rx: 8 bits/char, Rx disable 

;WR5, Tx: 8 bits/char, Tx disable 

/WRll, Rx: BRG, Tx: BRG, TRxC: BRG 
;WR12, lower TC / this is for 9600 b/s 

/WR12, lower TC / this is for 19.2 kb/s 

/WR12, lower TC / this is for 38.4 kb/s 

/WRl3, upper TC 

/WR14, BRG use PCLK, set DTR, enable BRG 

/P?R3: ... + Rx enable 
/WR5: ... + Tx enable, /RTS 

;WR0: Reset EXT/Status Interrupts 

/WRO: Reset TxINT Pending 


db 09h, 02Ah /WR9: Enable Interrupts 

; based on SCCB using BRG, with 1.8432 MHz clock, with xl€ clock mode, ® 9600 bps 


db 

04h, 044h 

/ WR4, 

xl6 clock, 8 bit sync, 1 stop bit, no 

db 

Olh, 12h 

/WRl, INT 

on all Rx or special, Int on Tx empty 

db 

03h, 

OCOh 

/WR3, 

Rx: 8 bits/char, Rx disable 

db 

OBh, 

060h 

/WR5, 

Tx: 8 bits/char, Tx disable 

db 

OBh, 

056h 

/WRll, 

Rx: BRG, Tx: BRG, TRxC: BRG 

db 

OCh, 

004h 

/WR12, 

lower TC 

db 

ODh, 

OOOh 

/WRl3, 

upper TC 

db 

OEh, 

OOlh 

/WR14, 

set DTR and enable baud gen 

db 

03h, OClh 

/WR3: 

... + Rx enable 

db 

OBh, 

068h 

/WR5: 

... + Tx enable 

db 

OOh, OlOh 

/WRO: 

Reset EXT/Status Interrupts 

db 

OOh, 028h 

/WRO: 

Reset TxINT Pending 

db 

09h, 02Ah 

/ WR9 : 

Enable Interrupts 


sccb table end: 


* 

* Init ED AC 


INT2 = Hard Error 
INT3 = Soft Error 






EXTRN _edac_ 

soft_isr: 

NEAR 

EXTRN _edac 

__hard_isr 

:NEAR 

12 CON 

equ 

0FF3Ch 

I2CON_INIT 

equ 

OlEh 

13 CON 

equ 

0FF3Eh 

I3CON_INIT 

equ 

01 Fh 

IMASK 

equ 

0FF28h 

INT2_ISR 

equ 

14 

INT3_ISR 

equ 

15 

public init_edac 


init_edac: 



/ EXTRN _ad_i s r: NEAR 

/C ad 


/C routine 
/C routine 


/Level-triggered, turned OFF, priority 6 
/Level-triggered, turned OFF, priority 7 


mov 


dx, I3CON 


230 






mov 

ax. 

I3CON_ 

INIT 

out 

dx. 

ax 


mov 

dx. 

12 CON 


mov 

ax. 

I2CON_ 

INIT 

out 

dx. 

ax 


mov 

al, 

•E' 



transmit 


/Perform the Write/Read Test of 0x55AA 
/WRITE 

sub bx, bx 

edac_testl_loopa: 

mov es, bx 

sub di, di 

mov cx, OSOOOh 

mov ax, OSSAAh 

cld 

rep stosw 

mov bx, es 

add bx, OlOOOh 

cmp bx, OSOOOh 

jb edac_testl__loopa 

/READ-BACK 

sub bx, bx 

edac_testl_loopb: 

mov es, bx 

sub di, di 

mov cx, OSOOOh 

edac_test_loopbl: 

cmp ax, WORD PTR es:[di] 

jnz edac_testl_error 

loop edac_test_loopbl 

mov bx, es 

add bx, OlOOOh 

cmp bx, OSOOOh 

jb edac_testl_loopb 


/Passed the Write/Read of 0x55AA 

/Now perform the Write/Read Test of Mod-257 
/WRITE 

sub bx, bx 

edac_test2_loopa: 

mov es, bx 

sub di, di 

sub ax, ax /start w/ 0, count to 257, start over w/ 0 

cld 

edac_test2_loopal; 

mov BYTE PTR es; [di] , al /move just a byte 

inc ax /inc the whole word 

cmp ax, 2SB 

jb edac_test2_Bkipl 

sub ax, ax /start over the count 

edac_test2_skipl: 

inc di /next location to fill 

jnz edac te«t2_loopal/not finished w/ 64k block 

mov bx, es 

add bx. ciooch 

cmp bx, ceOCCh 

jb edar_lestloopa /keep with same count in AX 

/READ-BACK 

sub bx. Lx 

edac_test2_loopb: 

mov es, bx 

sub di. di 

sub ax, ax 

cld 

edac_test2_loopbl; 

cmp BYTE PTR es : (di] , 

jnz edac_test2_error 

inc ax 

cmp ax, 258 

jb edac_test2_skip2 

Siib ax, ax 

edac_test2_skip2: 

inc di 

jnz edac_test2_loopbl/not finished w/ 64k block 

231 


/Start w/ 0, count to 257, start over w/ 0 

al /compare just a byte 
/inc the whole word 

/Start over the count 
/next location to fill 



mov bx, es 

add bx, OlOOOh 

cmp bx, OSOOOh 

jb edac_test2_loopb ,'keep with same count in AX 

jmp edac_vectors 

/Passed Write/Read Test of Mod-257 


edac_testl_error: 

mov al, ' 1' 

jmp startup_error 

edac_test2_error: 

mov al, '2' 

jmp startup_error 

edac_vectors: 

/Setup Interrupt Vectors for EDAC 
sub ax, ax 

mov es, ax 

mov ax, OFFSET _edac_hard_isr 

mov esrWORD PTR INT2__ISR*4, ax /Segment of INT2 vector 

mov ax, SEG _edac_hard_isr 

mov es:WORD PTR INT2_ISR*4+2, ax /Base of INT2 vector 

sub ax, ax 

mov es, ax 

mov ax, OFFSET _edac_soft_isr 

mov es:WORD PTR INT3_ISR*4, ax /Segment of INT3 vector 

mov ax, SEG _edac_soft_isr 

mov es:WORD PTR INT3_ISR*4+2, ax /Base of INT3 vector 

/Allow the interrupts to occur (to the Interrupt Controller) 

/Note: Interrupts are still off to the microprocessor 
mov dx, IMASK 

/ mov ax, 03Fh /Allow INT2 and INT3 interrupts 

; CPU *cli' is still imposed! 
mov ax, OFFh /Mask OFF all interrupts 

out dx, ax 

/Reset any EDAC errors 

mov dx, PCB_PPI_Ctrl 

mov ax, PCB_PortC_Reset2 /EDAC Error Acknowledge (Active LOW) 

out dx, ax 

mov ax, PCB_PortC_Set2 

out dx, ax 

mov al, 'e* 

transmit 

edac_done: 

/Setup see INTO Interrupt Vector and Configure Controller 

/*** DO NOT DO THIS BEFORE THE EDAC TEST OCCURS SINCE THE INTERRUPT VECTORS ARE TRASHED! 
EXTRN _scc_isr:NEAR /C scc_isr() 

sub ax, ax 

mov es, ax 

mov ax, OFFSET _scc_isr 

mov es:WORD PTR INT0_ISR*4, ax /Segment of INTO vector 

mov ax, SEG _scc_isr 

mov es:WORD PTR INT0_ISR*4+2, ax /Base of INTO vector 

mov dx, 10 CON 

mov ax, IOCON_INIT 

out dx, ax 


* 

* Init Timer for Clock 

* 

* Timer 2 Interrupt used, INT I3h (19) 


T2CON 

equ 

0FF66h 

T2CNT 

equ 

0FF60h 

T2CMP 

equ 

0FF62h 

T2_ISR 

equ 

013h 

EXTRN 

_clock_isr:NEAR 


public 

set_timer 



232 




set timer: 


mov 

ax. 

0 


mov 

es, 

ax 


mov 

ax, 

OFFSET _clock_isr 


mov 

es: 

iWORD PTR 013h*4, ax 


mov 

ax. 

SEG _clock_isr 


mov 

es: 

;WORD PTR 013h*4+2, ax 

;Base of TMR2 vector 

mov 

dx. 

T2CNT 


sub 

ax. 

ax 


out 

dx, 

ax 

/Counter Register 

mov 

dx. 

T2CMP 


mov 

ax. 

30720 

/Max Count 

out 

dx. 

ax 


mov 

dx. 

T2C0N 


mov 

ax. 

oeooih 

;no inhibit, INT, Continuous 

out 

dx. 

ax 


mov 

ax, 

OEOOlh 

/same as above, but Enable as 

out 

dx. 

ax 



* 

* Init A/D Interrupt Service 

* 

* INTI = A/D Interrupt 

* 


IICON equ 

I1C0N_INIT equ 

INT1_ISR equ 13 

EXTRN _ad_i s r: NEAR 

public set_ad 
set_ad; 

mov ax, 0 

mov es, ax 

mov ax, OFFSET _ad_isr 

mov esrWORD PTR INT1_ISR*4, ax 

mov ax, SEG _ad_isr 

mov esrWORD PTR INTl_ISR*4+2, ax ;Base of AD ISR vector 


0FF3Ah 

OlDh ;Level-triggered, turned OFF, priority 5 


ir***ic**itieit1t*-k*-ii-k*1r*1r*1r**1r1r*it**1t***it*****ifk*****ieieir***********ir***it*ie******ir*** 

* 

* Perform variable initialization. 

* Initializers are copied from ROM to RAM. 


.****ieir*ic*ir1[*it*****ir-k*1r*ir******1r*iiit*******-k*ir*******itie***irir**ieir1i**********1fitic** 

PUBLIC _init_begin 
_init_begin: 

cld 


;Jah 

mov al, ‘I' 

transmit 

; Transfer Count 

MOV AX,OFFSET DGROUP:_edata ; Transfer counter 
CMP AX,0 

JZ no_init_data 
MOV CX,AX 


; RAM Destination address 
MOV AX,SEG _bdata 
MOV ES,AX 
MOV DI,0 

; ROM Source address 
MOV AX,SEG _etext 
MOV DS,AX 
MOV SI,0 

REP MOVSB ; Begin byte transfer from ROM to RAM 

mov al, 'i' 

transmit 


; Source DS:[SI] 

; Start of initializer storage in ROM 


; Destination ES:[DI] 

; Start of initialized variable area in RAM 


233 




no_init_data: 

; Clear uninitialized data area in DGROUP group 

mov al, »U' 

transmit 

MOV CX,OFFSET DGROUP 
MOV DI,OFFSET DGROUP 
SUB CX,DI 

JCXZ no_uninit__data 

MOV AX,0 ; Initialize to 0 

REP STOSB 

mov al, 'u' 

transmit 


_end ; End of 'BSS' class in RAM 
_edata ; Start of 'BSS' class in RAM 
; Size of 'BSS' class in bytes 


no_uninit_data: 

; Initialize FAR_DATA data in RAM with initializers stored in ROM 


Transfer Count 


MOV AX,SEG _bfdata 
MOV CX,SEG _efdata 
SUB CX,AX 
JCXZ loopend 
MOV DX,CX 

Destination 


Compute size of FAR_DATA segments in paragraphs 

No FAR__DATA class 

Saves transfer count in paragraphs 


MOV ES,AX 
MOV DI,0 


Destination ES:[DIj 

Start of FAR_DATA class in RAM 


Source 

MOV AX,SEG _etext ; Source DS:[SI] 

MOV DS,AX ; Start of FAR_DATA initializer storage in ROM 

MOV SI,OFFSET DGROUP:_edata ; _edata is paragraph aligned 
Normalize Source Pointer 


MOV AX,SI 
MOV CL,4 
SHR AX,CL 
MOV BX,AX 
MOV AX,DS 
ADD AX,BX 
MOV DS,AX 
MOV SI,0 
MOV AX,DX 
loopbegin: 


Process base of source pointer 
Divide by 16 


Adjust base of source pointer 
Offset of source pointer is zero 
Restore transfer count in paragraphs 


CMP AX,1000H 
JBE lastxfer 
MOV CX,8000H 
SUB AX,1000H 
JMP SHORT xferbegin 
lastxfer: 


More than 64K bytes to transfer? 
No 

Prepare to transfer 8000H words 


MOV CL,3 
SHL AX,CL 
MOV CX,AX 
MOV AX,0 
xferbegin; 


Number of WORDS = paragraph * 8 

Set up transfer count in terms of WORDS 

No more to transfer 


REP MOVSW ; Transfer WORDS from ROM to RAM 

CMP AX, 0 ; Any more data to transfer? 

JE loopend ; No 

; Adjust Source and Destination pointers 

MOV BX,AX ; Saves transfer count 

MOV AX,DS 

ADD AX,1000H 

MOV DS,AX 

MOV AX,ES 

ADD AX,1000H 

MOV ES,AX 

MOV SI, 0 

MOV DI,0 

MOV AX,BX ; Restores transfer count 

JMP loopbegin 
loopend; 


Clear uninitialized data area in FAR_BSS class 
Transfer Count 
MOV AX,SEG _bfbsE 
MOV CX,SEG _efbss 

SUB CX,AX ; Compute size of FAR_BSS segments in paragraphs 

JCXZ loopfend ; No FAR_BSS class 

Destination 

MOV ES,AX ; Destination ES: [DI] 


234 





Start of FAR BSS class in RAM 


MOV DI,0 

Transfer Count 


MOV AX,CX 


loopfbegin: 

CMP AX,1000H 
JBE lastfxfer 
MOV CX,8000H 
SUB AX^IOOOH 
MOV BX,AX 

JMP SHORT xferfbegin 
lastfxfer: 

MOV CL, 3 
SHL AX,CL 
MOV CX,AX 
MOV AX,0 
MOV BX,AX 
xferfbegin: 


More than 64K bytes to initialize? 
No 

Prepare to transfer 8000H words 
Saves transfer count 


Number of WORDs = paragraph * 8 

Set up transfer count in terms of WORDs 

No more to transfer 

Saves transfer count 


MOV AX,0 
REP STOSW 

MOV AX,BX 
CMP AX,0 
JE loopfend 
; Adjust Destination 
MOV AX,ES 
ADD AX,1000H 
MOV ES,AX 
MOV DI,0 
MOV AX,BX 
JMP loopfbegin 
loopfend: 


; Initialize WORDS to zero 
; Restore transfer count 
; Any more data to transfer? 

; No 

pointers 


; Restore transfer count 


Clear uninitialized data area in HUGE_BSS class 
Transfer Count 


MOV AX,SEG _bhbss 
MOV CX,SEG _ehbss 
SUB CX,AX 
JCXZ loophend 
Destination 
MOV ES,AX 
MOV DI, 0 

Transfer Count 


Compute size of HUGE_BSS segments in paragraphs 
No HUGE_BSS class 

Destination ES:[DI] 

Start of HUGE BSS class in RAM 


MOV AX,CX 
loophbegin: 

CMP AX,1000H 
JBE lasthxfer 
MOV CX,8000H 
SUB AX,1000H 
MOV BX,AX 

JMP SHORT xferhbegin 


More than 64K bytes to initialize? 
No 

Prepare to transfer 8000H words 
Saves transfer count 


lasthxfer: 

MOV CL,3 
SHL AX,CL 
MOV CX,AX 
MOV AX,0 
MOV BX,AX 
xferhbegin: 


Number of WORDs = paragraph * 8 

Set up transfer count in terms of WORDs 

No more to transfer 

Saves transfer count 


REP 


MOV AX,0 
STOSW 
MOV AX,BX 
CMP AX,0 
JE loophend 


,- Initialize WORDs to zero 
Restore transfer count 
Any more data to transfer? 
No 


; Adjust Destination pointers 

MOV AX,ES 

ADD AX,1000H 

MOV ES,AX 

MOV DI,0 

MOV AX,BX ; Restore transfer count 


JMP loophbegin 
loophend: 


PUBLIC _init_done 
_init done: 


***************************************************************************** 
Initialize the interrupt vector table here 
***************************************************************************** 
Interrupt types 0 to 4 are dedicated internal interrupts. 

Type 0 - Divide-error 

Type 1 - Single-step 

Type 2 - Non-maskable interrupt 

Type 3 - 1-byte INT instruction or Breakpoint 

Type 4 - Overflow 

Interrupt types 5 to 31 are reserved internal interrupts. 

235 









Interrupt types 32 to 255 are available for use. 

For example: 

The interrupt handling routine for vector 32 decimal is assumed to 
be the C function: void interrupt far int_hdlr(). 

The statement declaring code label _int__hdlr as an external far procedure 
has to be placed outside of all SEGMENT/ENDS pairs. 

See the sample EXTRN statement above. It is behind the GROUP statement. 
Below is the sample code to initialize an entry in the vector table: 

TYPE32 EQU 32 
MOV AX,0 

MOV ES,AX /Reference base of interrupt vector table 

MOV AX,OFFSET _int_hdlr 

MOV ES:WORD PTR TYPE32*4,AX /Offset portion of vector 32 
MOV AX,SEG _int_hdlr 

MOV ES:WORD PTR TYPE32*4+2,AX /Base portion of vector 32 


TYPED EQU 0 
MOV AX,0 

MOV ES,AX /Reference base of interrupt vector table 
MOV AX,OFFSET _cintDIV 

MOV ES:WORD PTR TYPED*4,AX /Offset portion of vector D 

MOV AX,SEG _cintDIV 

MOV ES:WORD PTR TYPED*4+2,AX /Base portion of vector 0 


/ Setup data and stack segment here before releasing control to _main 

mov al, 'S' 

transmit 


public setup main 


setup_main; 

mov 

mov 

ASSUME 

mov 

mov 

ASSUME 


ax, DGROUP 
ds, ax 
ds:DGROUP 

ss, ax 
sp, OFFSET 
SS:DGROUP 


DGROUP:stack^top 


/Setup data segment 


/Setup stack pointer 


/FP emulator init function 
mov al, 'F' 

transmit 

EXTRN _al init: FAR 

CALL FAR PTR _a Unit 

mov al, 'p * 

transmit 


Reset the 

EDAC 

Hard 

and Soft Error 

mov 

dx. 

PCB_ 

_PPI_Ctrl 

mov 

al. 

PCB~ 

_PortC_Reset2 

out 

dx. 

al 


mov 

al, 

PCB_ 

_PortC_Set2 

out 

dx, 

al 



Interrupts 

/EDAC Error Acknowledge {Active LOW) 


/Send non-specific EOI to Interrupt Controller 
INT_EOI equ 0FF22h 

mov dx, INT_EOI 

mov ax, OSODOh 


out dx, ax 


/* Mask ON/OFF Interrupts to the Interrupt Controller 


mov 

dx. 

IMASK 


mov 

ax. 

OEEh 

/allow INTD, Timers 

out 

dx. 

ax 



Ready to 

transfer control 

to the C 

run-time, enable interrupts 

mov 

al, 

• M' 




transmit 





in 

al. 

SCCB_ 

_CMD 

/reset pointer 

mov 

al. 

OlOh 




out 

SCCB 

i_CMD, 

al 

/WRD: 

Reset EXT/Status Interrupts 

mov 

al. 

D28h 




out 

SCCB 

_CMD, 

al 

/WRD: 

Reset TxINT/Pending 

mov 

al. 

030h 




out 

SCCB 

_CMD, 

al 

/WRD: 

Error Reset 


236 




mov al, 038h 

out SCCB_CMD, al ;WR0: Reset Highest lUS 

PUBLIC before_main 
before_inain: 

sti 

call_main ;Pass control to C mainO in module dcs.c 


PUBLIC _exit, _exit 

_exit LABEL FAR 

_exit LABEL FAR 

dcs_halt: 

jmp dcs_halt 


***************************************************************************** 

* 

* startup_error 

* 

* This routine halts the processor after displaying the error message which 

* consists of an exclamation point (!) followed by a number/letter. 

* 

* Error Codes: 

* *1’ EDAC RAM Test of 55AA failed 

* . *2’ EDAC RAM Test of Mod-257 failed 

* 

**************************************************************************** 


startup_error: 

mov cl, 

mov al, 

transmit 
mov al, 

transmit 
mov al, 

transmit 

/First ES 

mov ax, 

mov cl, 

display 

mov ax, 

mov cl, 

display 

mov ax, 

mov cl, 

display 

mov ax, 

display 

mov al, 

transmit 

/Now DI 

mov ax, 

mov cl, 

display 

mov ax, 

mov c1, 

display 

mov ax, 

mov cl, 

display 

mov ax, 

display 


al 


cl 


es 

12 


es 

4 


es 


di 

12 


di 

8 


di 

4 


di 


sehlt: 

jmp sehlt 


/ error code 


* 

* FP Support 


237 






Trap for missing floating-point software. 

The floating point initialization routine {_fpmath) will call this routine 

when one of the following conditions occurs: 

(1) 8087 floating point library (87.lib) is linked in but no 8087 coprocessor 
is present, that is, floating point emulator library is not linked. 

(2) Floating point i/o conversions are done, but no floating-point variables 
or expressions are used in the program. 

Default action is to halt the processor. 

PUBLIC _fptrap 
fptrap LABEL FAR 

MOV AX,3 ; Identify label _fptrap. 

HLT 

JMP _fptrap 


ERROR HANDLING 

INT 21H called. Register AH contains the function code. 

If function code is OOH, 25H, 35H or 4CH, the interrupt handler 
will process the call. 

For all other function codes, the interrupt handler will jump here. 
Default action is to halt the processor. 

PUBLIC _doscalled 

doscalled LABEL FAR 

If you want to ignore the dos call, 
replace the following instructions. 

MOV AX,4 ; Identify label doscalled 

HLT 

JMP _^doscalled 

WITH: 

EXTRN _ignored:FAR 

JMP FAR PTR _ignored 

This will cause the interrupt handler to ignore the dos call. 

_ignore is an entry point back to the interrupt handler. 


; PROCEDURE _cintDIV: 

PUBLIC _cintDIV 

_cintDIV PROC FAR ; Divide by 0 interrupt handler. 

MOV AX, 5 ; User-defined error recovery routine. 

• HLT ; Identify label _cintDIV. 

JMP _cintDIV 

_cintDIV ENDP 


VARIABLE _errno: 

For certain C run-time functions, when an error condition occurs within the 
function, an error code will be placed in the _errno global variable. 

If a function sets the _errno variable upon error, its reference page will 
explicitly mention the _errno variable. 

All of the error codes are described in the Microsoft C run-time library 
reference manual. 

The values of these error codes are listed in the errno.h include file. 


FUNCTION matherr: 

You may supply your own version of matherr function in your C program. 
If you do, you can obtain a value from the type field of the exception 
data structure which corresponds to the math error code listed in the 
math.h include file, the Microsoft C run-time library reference 
manual contains a detail description of the matherr fucntion and the 
math error codes. 

If you do not link in your own matherr function, the matherr function 
included in the Microsoft C run-time library will be linked in. 

The function simply returns a zero value. 

If you link in your own version of the matherr function, it may perform 
special error handling, if corrective action is taken and the 
the return value should be nonzero. 


PROCEDURE FF_MSGBANNER: 

_FF_MSGBANNER procedure will be called when an error condition occurs 

within in a math function and certain C run-time functions. 

It writes the first part of run-time error messages to standard 
error as follows: 

'\r\nrun-time error '. 


238 










; It is implemented as a null procedure here. 

PtFBLIC _FF_MSGBANNER 

_FF_MSGBANNER PROC NEAR 

RET 

_FF MSGBANNER ENDP 


PROCEDURE _wrt2err: 

The _wrt2err procedure will be called when an error condition occurs 

within in a math function and certain C run-time functions. 

It takes a near pointer in BX (DS:BX) which points to a LSTRING which is 
to be written to standard error. A LSTRING is a one-byte length followed 
by that many bytes for the character string (as opposed to a null- 
terminated string). 

These LSTRiNGs has the form of the first character being a capital letter 
followed by four digits. For examples, 'R6001', 'M6101', etc. The 

meaning of these error numbers are explained in detail in the Microsoft C 
reference manual. 

The _wrt2err procedure is implemented as a null procedure here. 

PUBLIC _^wrt2err 

wrt2err PROC NEAR 

DS:BX points to the LSTRING. 

RET 

wrt2err ENDP 


PROCEDURE NMSG WRITE: 


The NMSG WRITE procedure will be called when an error condition occurs 
within in a math function and certain C run-time functions. 

It searches the MSG segment for the address of a message string corresponding 
to the error condition. 

If a message string is found, DS:DX = string address, CX = string length. 

You may process or ignore the error message string. 


The follow table lists some of the error message numbers and the message strings 
253 MATH',13,10,'- floating-point error: ',0 

101 'invalid',13,10,0 

102 'denormal',13,10,0 

103 'divide by O',13,10,0 

104 'overflow',13,10,0 

105 'underflow',13,10,0 

106 'inexact',13,10,0 

107 'unemulated',13,10,0 

108 'square root',13,10,0 

109 13,10,0 

110 'stack overflow',13,10,0 

111 'stack underflow',13,10,0 

112 'explicitly generated',13,10,0 


PUBLIC _^NMSG_WRITE 

NMSG WRITE PROC NEAR 
PUSH BP 
MOV BP,SP 
PUSH DS 

POP ES 

MOV DX,WORD PTR [BP+4] ; DX = error message number 

CMP DX,253 

JE NOTFOUND ; Skip error message no. 253, 

; But process other error message numbers 
ASSUME DSiDGROUP 
MOV 
TLOOP: 

LODSW 
CMP 
JE 
INC 
XCHG 
JZ 

XCHG 
XOR 
MOV 
REPNE 
MOV 
JMP 
FOUND: 


SI,OFFSET DGROUPiMSG ; start of near messages 
; AX = current message number 
; Found error message string 


AX,DX 

FOUND 

AX 

AX,SI 
NOTFOUND 
DI,AX 
AX, AX 
CX, -1 
SCASB 
SI,DI 
TLOOP 


; At end and error message string not found 

; Skip until OH 
; Try next entry 


XCHG 

AX,SI 

; SI = offset to String address 

XCHG 

DX,AX 

; DS:DX = String address 

MOV 

DI,DX 

; Determine length of message string 

XOR 

AX,AX 

; String is terminated with byte Oh 

MOV 

CX, -1 



239 





; ES = DS already 


REPNE SCASB 
NOT CX 

DEC CX ; CX = string length 

; May include user-defined code here to output error message 
; DS:DX == String address, CX = string length 
NOTFOUND: 

MOV SP,BP 
POP BP 
RET 

NMSG WRITE ENDP 

PUBLIC _dataseg 

_dataseg DW DGROUP 


TEXT ENDS 


EMULATOR__TEXT segment para public 'CODE' 

public _EmDataSeg 

_^EmDataSeg dw EMULATOR_DATA 

EMULATOR TEXT ends 


BOOTSTRAP SEGMENT AT OFFFFH 
cli 

mov dx, UMCS 

niov ax, UMCS_DATA /Upper Memory CS start of EPROM FOOOiO, 64K 

out dx, ax 

; mov dx, OFFAOh 

; mov ax, 0C038h 

; out dx, ax 

jmp far ptr START_ 

db 'Jah’ 

BOOTSTRAP ENDS 


***************************************************************************** 

* 

* C_ETEXT 

* 

* If you specify the INITDATA control in the PROM86, v5.2 and up, it will 

* cause PROM86 to place all initializers in ROM starting at this 

* location. The start-up routine assumes these initializers are placed 

* behind program code in ROM and copy them to RAM at power-up. 
******'tt*****it******‘ifk**ir*ir*-k1c1r1e*ic1r****1c1t1r***ie-k'kit*******-k1tir1c1i1t**-k‘kieit1[ifk**-ltii1iie-k 


C_ETEXT SEGMENT PARA PUBLIC 'CODE_END' 

PUBLIC _etext 

_etext LABEL BYTE / This label marks the end of program code. 

C ETEXT ENDS 


END START_ ; Make sure the START_ symbol is here! 


End of startup.asm 

I 


240 





stpi.h, stpi.c 

* 

* STPI.H 


* Petite Amateur Navy Satellite (PANSAT) . 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 

* Date Who What 


* 3 Nov 1993 Jah Creation 

* 

****************************************************************************/ 
#ifdef STPI 

#define CMD_STR_LEN 80 

typedef struct 

{ 

char name [10] ; 

void (*fptr) (char *inbuf); 

char usage[81]; 


} cmd_struct; 


static 

char 

*get_token(char *buf, char *token) 

static 

void 

parse_cmd(char *cptr); 

static 

char 

*skip_blanks(char *cptr); 

static 

void 

clear_screen(char *cptr); 

static 

void 

in_port(char *cptr); 

static 

void 

in__portw(char *cptr) ; 

static 

void 

out_port(char *cptr); 

static 

void 

out_portw(char *cptr); 

static 

void 

pcbr(char *cptr); 

static 

void 

pcbw(char *cptr); 

static 

void 

ad_config(char *cptr); 

static 

void 

ad_int(char *cptr); 

static 

void 

ad_read(char *cptr)/ 

static 

void 

ad_status(char *cptr); 

static 

void 

debug_cmd(char *cptr); 

static 

void 

disp_b(unsigned char a); 

static 

void 

disp_w(unsigned int a); 

static 

void 

m_on(char *cptr); 

static 

void 

m_off(char *cptr); 

static 

void 

m_clear(char *cptr); 

static 

void 

m_spread(char *cptr); 

static 

void 

m_hunt(char *cptr); 

static 

void 

m_scca(char *cptr); 

static 

void 

m_sccb(char *cptr); 

static 

void 

pa_read(char *cptr); 

static 

void 

pa_write(char *cptr); 

static 

void 

edit(char *cptr); 

static 

void 

dump(char *cptr); 

static 

void 

load(char *cptr); 

static 

void 

goto_load(char *cptr); 

static 

void 

msa_cmd(char *cptr); 

static 

void 

msb_cmd(char *cptr); 

static 

void 

time_cmd(char *cptr); 

static 

void 

test_cmd(char *cptr); 

static 

void 

rf_cmd(char *cptr); 

static 

void 

tx_cmd(char *cptr); 

static 

void 

rx_cmd(char *cptr); 


241 








static void 

static void 

static void 

static void 

static void 
#endif 


eps_cmd(char *cptr); 
tmux_cmd(char *cptr); 
tlm_cind (char *cptr) ; 
shutdown_cmd(char *cptr); 
bcm_cmd(char *cptr); 


#ifndef STPI 

extern void monitor(void); 
#endif 


/******************★**★********★********************************************** 

* 

* STPI.C 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* Date Who What 

* -+--- 

* 3 Nov 1993 Jah Creation 

* 

***-^*******-k*******-k*****1r*-k********-k-k***-k****'k*****ic-k*******1r*****-k********/ 

#include <string.h> 

#include <ctype.h> 

#include <math.h> 


#include ”gen_def s.h” 

#define STPI 

#include "stpi.h" 

#undef STPI 

#include "ad.h” 

#include "bcm.h" 

#include "clock.h” 

#include "dcs.h" 

#include "eps.h" 

#include "pcb.h" 

#include "print.h” 

#include ”modem.h” 

#include "tlm.h" /* must be before msu.h */ 

#include "msu.h” 

#include "scc.h" 

#include "terms.h” 


WORDadr(int ch) ; 


static cmd_struct cmd table[] = 
{ 


’cls", 
’help", 

clear_screen, 

parse_cmd. 

, "CLS 

"HELP 

Clear the screen.". 

Display this menu.". 

'adc", 
■adi", 
■adr”, 

' ads", 

ad__conf ig, 
ad_int, 
ad_read, 
ad_status. 

"ADC 

"ADI 

"ADR <channel> 

"ADS 

Show A/D configuration.". 

Show A/D interrupt information 
Read A/D channels.", 

Show A/D status.", 

'debug", 

debug_cmd, 

"DEBUG <0/l> 

Debug info Off/Onn", 

' in” , 
'inw", 

' out", 
'outw", 

injport, 
in_portw, 
oi^t_port, 
out_portw. 

"IN <port> 

"INW <port> 

"OUT <port> <value> 

"OUTW <port> <value> 

Input byte from port.", 

Input word from port.", 

Output byte from port.". 

Output word from port.", 

'pcbr", 
pcbw", 

pcbr, 

pcbw. 

"PCBR <select> <addr> 

"PCBW <select> <addr> <value> 

PCB read.", 

PCB write.", 


242 






••mO”, 

m off, 

"MO 


Modem OFF.", 

"ml” , 

m_on. 

"Ml 


Modem ON.", 

" c " , m_ 

clear, "C 



Modem clear mode 78.125k.", 

"hunt", 

m_hunt, 

"HUNT 


Enter Hunt Mode.", 

" s " , m_ 

spread. 

"S 


Modem spread mode 9.842k.", 

"scca", 

m_scca. 

"SCCA 

<WR#> <data> 

Send data to write register (A) 

"sccb", 

m_sccb. 

"SCCB 

<WR#> <data> 

Send data to write register (B) 

"par", 

pa_read. 

"PAR 


PA-100 read registers.". 

"paw", 

pa_write. 

"PAW 

<filename> 

PA-lOO write registers.". 

"load", 

load. 

"LOAD 

<filename> 

Load binary image to 1000:0100, 

"goto", 

goto_load. 

"GOTO 


Jump to 1000:0100.", 

"dump", 

dump. 

"DUMP 

<seg> <off> 

Dump memory.", 

"edit ", 

edit. 

"EDIT 

<seg> <off> 

Edit memory locations.", 

"msa", 

msa_cmd. 

"MSA <0/1 

;r/w/e|s/f> <addr> 

<data> Mass Storage A Control.", 

"msb", 

msb_cmd. 

"MSB <0/1 

:r/w/e:s/f> <addr> 

<data> Mass Storage B Control.", 

"time", 

time__cmd, 

"TIME 

<yy:MM:DD:HH:MM:SS> Get/Set time.". 

"test". 

test_cmd. 

«TEST", 



"rf". 

rf_cmd, 

"RF <0/1; T/R; Tx/Rx; LOP/LOA; LHP/LHA; P #; LNAO/LNAl; HPAO/HPAl; E 

"tx". 

tx_cmd, 

"TX <text message>", 

• 

"rx". 

rx_cmd, 

"RX <1; 

S>", 


"ep s"/ 

eps_cmd, 

"EPS <B A/B 

C/D/O/T ON/OFF; C 

sys ON/OFF; V A#/B#/S; I A/B/S/P#; W>", 

" tmux", 

tmux_cmd. 

"TMUX <A/B CH#/ON/OFF>", 


"bcm", 

bcm_cmd, 

"BCM <ON/OFF>", 


"shutdown" 

, shutdown_cmd, 

"SHUTDOWN", 



"tlm", 

tlm_cmd. 

fi n 



If n 

parse_cmd. 

n n 




* 

* monitor 0 

* 


void monitor(void) 


{ 


static char 

char 

char 

static int 
static int 


C 61 r [CMD_STR_LEN + 1 ] ; 
*cptr • cstr; 

C; 

i • 0; 

end^string = FALSE; 


while (is_serial_in(J && !end_string) 

( 

c = get_char(1. 

if ((i c CKr_STR_LEN} && (c != CR)) 
cstr U1 • c. 

if (c ■« CTi 

{ 

cstrli! . N’JLL_CHAR; /* replaces CR with a NULL_CHAR */ 

end Btrim » TRUE; 

} 

} /* End of WHILE •/ 


if (end_string) 

{ 

parse_cmd(cptr) ; 

serial_out{CTKL_W); /* indicate end of processing command */ 

i = 0; /* reset pointer into command string to zero */ 

end_string = FALSE; /* allow new string building next time */ 

) 


} /* End of monitor{) */ 


243 





* parse_cmd(} 

* 


void pars e_cmd (char *cptr) 

{ 

int n, m; 

char cmd [10] ; 

int found; 

static char iast_cmd[80]; 

if (cptr[0] == •!'} 

strcpy(cptr, last_cmd) ; /* copy last command to this command */ 

else 

strcpy (last_cmd, cptr); /* otherwise, save this command for next time */ 

cptr = get_token(cptr, cmd); 

for (found = FALSE, n = 0; cmd table [n] .name[0] != '\0'; n++) 

{ 

if (strictnp (cmd, cmd table [n] .name) == 0) 

{ 

found = TRUE; 

if (stricmp(cmd, "help”) == 0) 

{ 

home(); 
clr (); 

dprint(”PANSAT Monitor Commands\n") ; 
dprint(”=======================\n") ; 

for (m = 0; cmd_table[m].name[0] != '\0'; m++) 
dprint (’'%s\n", cmd_table [m] .usage) ; 

} 

else if (cmd_table[n].name[0] != '\0') 

{ 

dprint(”\n”); 

(*cmd_table[n].fptr)(cptr); 
dprint (''\n”) ; 

) 

break; 

} 

) 

if (!found) 

{ 

serial_out(0x07);/* beep for error */ 
dprint("Command error.\n”); 

} 


} /* End of parse_cmd0*/ 


* get_token() 

* 


char*get_token(char *buf, char *token) 

{ 

if (*buf == NULL_CHAR) 

{ 

♦token = NULL_CHAR; 
return(buf); 

} 


while ((*buf != * ») && (*buf != NULL_CHAR) ) 

*token++ = *buf++; 

♦token = NULL_CHAR; 

if (♦buf == NULL_CHAR) 
return(buf); 

else 

skip_blanks(buf); 


244 




} /* End of get_token() */ 



* skip_blanks0 

* 


char *skip_blanks(char *buf) 

{ 

while ((*buf ==»«)&& (*buf != NULL_CHAR)) 
buf++; 

return(buf)/ 

} /* skip_blanks() */ 


Supported monitor commands 


* clear_screen{) 


voidclear_screen(char *cptr) 

{ 

home(); 
clrO ; 

} /* End of clear_screen() */ 


* 

* in_port() 


void in_jport (char *cptr) 

( 

char param[20]; 

unsigned char value; 


cptr = get_token(cptr, param); 
value = inp(cnv_hex(param)); 

dprint (" Port %X = %X ”, cnv_hex (param), value); 
disp_b(value); 

} /* End of in_jport() */ 


in_j5ortw () 


void in_portw(char *cptr) 

{ 

char param[20]; 

unsigned int value; 

cptr = get_token(cptr, param); 
value = inpw(cnv_hex(param)); 

dprint(”Port %X = %X ”, cnv_hex (param) , value); 
disp_w(value); 


} /* End of in_j>ortw() */ 






out_port() 


void out_port(char *cptr) 

{ 

charport[10], value[10]; 


cptr = get_token{cptr, port); 
cptr = get_token(cptr, value); 

dprint("Out %X to port %X”, cnv_hex(value), cnv_hex(port)); 
outp(cnv_hex(port), (BYTE}cnv_hex(value) ) ; 

) /* End of out_port() */ 


* 

* out_portw () 

* 


void outjportw(char *cptr) 

{ 

charport [10] , value [10] ; 


cptr = get_token(cptr, port); 
cptr = get_token (cptr, value) 

dprint("Out %X to port %X", cnv_hex(value), cnv_hex(port)); 
outpw (cnv_hex (port) , (WORD) cnv_hex (value)) ,- 

} /* End of out_portw() */ 


/ 




* pcbr 




voidpcbr(char *cptr) 

{ 

char cbuf[20]; 

unsigned int select, addr, value; 


cptr = get_token(cptr, cbuf); 
select = cnv_hex(cbuf); 

cptr = get_token(cptr, cbuf); 
addr = cnv_hex(cbuf); 

value = pcb_read(select, addr); 

dprintC'PCBR %x %x %x*, select, addr, value); 

} /* End of pcbrO •/ 






* pcbw 

* 




voidpcbw(char *cptr) 

{ 

char cbuf1201; 

unsigned int select, addr, value; 


cptr = get_token(cptr, cbuf); 
select = cnv__^hex (cbuf) ; 

cptr = get_token(cptr, cbuf); 
addr = cnv_hex (cbuf) ,- 


246 




cptr = get_token(cptr, cbuf); 
value = cnv_hex(cbuf); 

pcb_write(select, addr, value); 

dprint{”PCBW %x %x %x”, select, addr, value); 

} /* End of pcbwO */ 


* 

* disp_b() 

* 

voiddisp_b (unsigned char a) 

{ 

int n; 


for (n = 0; n <= 7; n++) 

{ 

if (n == 4) 

dprint (" >') ; 

if (a & 0x80) 

dprint(”1"); 

else 

dprint(”0"); 
a = a << 1; 

) 

} /* End of disp_b() */ 


* 

* disp_w() 

* 

void disp_w (unsigned int a) 

( 

int n; 


for (n = 0; n <= 15; n++) 

{ 

if (n%4 == 0) 

dprint(” "); 

if (a & 0x8000) 
dprint("1"); 

else 

dprint(”0"); 
a = a << 1; 

} 

} /* End of disp_w{) */ 


#define 

AD_ 

BASE 

0x80 



ltdef ine 

AD^ 

'iNSTRO 

AD_BASE 



#define 

AD_ 

_INSTR1 

AD_BASE 

+ 

2 

#define 

AD_ 

_INSTR2 

AD_BASE 

+ 

4 

#define 

AD_ 

INSTR3 

AD_BASE 

+ 

6 

#define 

AD_ 

_INSTR4 

AD_BASE 

+ 

8 

#define 

AD_ 

]lNSTR5 

AD_BASE 

+ 

OxOA 

#define 

ad’ 

INSTRG 

AD_BASE 

+ 

OxOC 

#define 

ad' 

_INSTR7 

AD_BASE 

+ 

OxOE 

#define 

AD_ 

_CONFIG 

AD__BASE 

+ 

0x10 

#define 

AD_ 

JER 

AD_BASE 

+ 

0X12 

#define 

AD_ 

_ISR 

AD BASE 

+ 

0x14 

#define 

AD_ 

_TIMER AD_ 

BASE + 0x16 


#define 

AD_ 

_FIFO 

AD BASE 

+ 

0x18 

#define 

AD 

LIMIT AD 

BASE + OxlA 



/* Masks */ 

#define RAMOO 0x0000 

#define RAMOl 0x0100 

247 


#define RAM02 


0x0200 


* 

* ad_config{) 




**/ 


voidad_config(char *cptr) 

{ 

unsigned int temp = inpw(AD_CONFIG}; 


dprint{«A to D Configuration Register: %X = ?rX\n”, AD_CONPIG, temp); 

dprint(” Start = "); 

if (temp & 0x0001) 

dprintC'l, Sequencer is running.\n") ; 

else 

dprintC'O, Sequencer is stopped.\n") ; 

dprintC Reset = " ) ; 
if (temp & 0x0002) 

dprintC'l, unit is still resetting. \n") ; 

else 

dprintC'O, unit is not resetting. \n") ; 

dprint(" Auto Zero = “); 

if (temp & 0x0004) 

dprintC'l, in progress . \n") ; 

else 

dprintC'O, not occurring. \n" ) ; 

dprintC' Full Calibration = ") ; 
if (temp St 0x0008) 

dprint(”1, in progress.\n"); 

else 

dprintC'O, not occurring.\n") ,* 

dprintC' Standby = "); 

if (temp St 0x0010) 

dprint("1, in standby mode.\n"); 

else 

dprintC'O, not in standby mode.\n"); 

dprintC' Channel Mask = ") ; 
if (temp St 0x0020) 

dprintC'l, FIFO bits 15-13 are sign.\n"); 

else 

dprintC'O, FIFO bits 15-13 are pointer.\n") ; 

dprintC* Short Auto Zero = ") ; 

if (temp St 0x0040) 

dprint("l, occurs before every conversion.\n"); 

else 

dprint("0, disabled.\n"); 

dprint(” Sync = "); 

if (temp St 0x0080) 

dprintC'l, SYNC pin is an output.\n"); 

else 

dprintC'O, SYNC pin is an input.\n") ; 

dprintC RAM pointer = %X\n", (temp & 0x0300) >> 8) ; 

dprintC Test = ") ; 

if (temp St 0x0400) 

dprintCl, in test mode.\n"); 

else 

dprintC’O, not in test mode.\n"); 

dprintC Diagnostic = "); 

if (temp St 0x0800) 

dprintCl, in diagnostic mode-\n’'); 

else 

dprintC'O, not in diagnostic mode.\n’'); 

} /* End of adc() */ 


* 

* ad_int() 


248 




voidad_int (char *cptr) 

( 

unsigned int ier = inpw(AD_IER}; 
unsigned int temp, i; 


dprintC'A to D Interrupts: %X = %X\n’', AD_IER, ier) ; 

dprint{" Interrupts enabled: ”); 
for (temp = ier, i = 0; i <= 7; i++) 

{ 

if (i != 6) 

if (temp & 0x0001) 

dprint("%d ”, i) ; 
temp >> 1; 

} 

dprint("\n") ; 

dprint(" Sequencer address to generate INTI = %X\n'', (ier & OxOFOO) >> 8) ; 

dprint (” # of conversions in FIFO to generate INT2 = %X\n", (ier & OxFSOO) >> 11) 

} /* End of ad_int() */ 


* 

* ad_read 

* 


voidad_read (char *cptr) 

{ 

unsigned int c, value, isr, temp; 
double X; 

char buf[20]; 


/* Reset the A/D */ 

/* Wait for Reset bit to clear */ 


/* Full Calibration */ 

/* Wait for calibration to finish */ 


/* Stop sequencer, point to RAM 00 */ 


OUtpw(AD_C0NFIG, 0x0002) ; 
while (inpw(AD_CONFIG) & 0x0002) 

OUtpw (AD_CONFIG, 0x0008); 
while (inpw(AD_CONFIG) & 0x0008) 

OUtpw (AD_CONFIG, 0x0000); 


/* DCS Temperature, MUX+ = INO, MUX- = GND */ 

OUtpw (AD_INSTR0, 0xF202) ; /* acq. time = full way, no wdog, 12-bit, */ 

/* Timer ON, NO sync, Vin- = Gnd, Vin+ = INO 

/* Pause = YES, loop = NO */ 

/* Note: pause will happen after loop */ 

/* Modem Temperature, MUX+ = INI, MUX- = GND */ 

OUtpw (AD_INSTR1, 0xF204) ; /* acq. time = full way, no wdog, 12 -bit, */ 

/* Timer ON, NO sync, Vin- = Gnd, Vin+ = INI 

/* no pause, loop = NO */ 


/* TMUXA, MUX+ = IN4, MUX- 
OUtpw (AD_INSTR2 , 0xF210); 


GND */ 

/* acq. 
/* 
/* 


*/ 


time = full way, no wdog, 12-bit, */ 

Timer ON, NO sync, Vin- = Gnd, Vin+ = IN4 
no pause, loop = NO */ 


/* TMUXB, MUX+ = 
OUtpw (AD_INSTR3, 


IN6, MUX- = GND */ 
0xF218); /* acq. 

/* 

/* 


time = full way, no wdog, 12-bit, */ 

Timer ON, NO sync, Vin- = Gnd, Vin+ = IN6 */ 
no pause, loop = NO */ 


/* EPS, MUX+ = IN2, MUX- = GND */ 

OUtpw (AD_INSTR4, OxF209) ; /* acq. time = full way, no wdog, 12-bit, */ 

/* Timer ON, NO sync, Vin- = Gnd, Vin+ = IN2 
/* no pause, loop = YES */ 


/* RAM 01(1) and 10(2) are not set - limit stuff */ 


/* Timer to slow the conversion rate */ 

/* OUtpw (AD_TIMER, 0x1000); */ 

OUtpw (AD_TIMER, 2000); 

OUtpw (AD_CONFIG, 0x0002) ; /* Reset the A/D */ 

while (inpw (AD_CONFIG) & 0x0002) /* Wait for Reset bit to clear */ 

249 


outpw(AD_CONFIG, 0x0001); /* start sequencer */ 

/* Wait for INT 5 - Pause Interrupt */ 
while (Iinpw(AD_ISR Sc 0x0020)} 

/* Sequencer is stopped, due to Pause in last instruction */ 

/* Wait for 5 samples in the FIFO */ 
while (((inpw(AD_ISR) & OxFSOO) » 11) < 5) 


c = (inpw(AD_ISR) & OxFSOO) >> 11; 
while (c) 

{ 

value = inpw(AD_FIFO); 

dprint("%u) ", (value & OxEOOO) >> 13); 
if (value & 0x1000) 
dprint("-"); 

dprint("%u, ", (value & OxOFFF)); 

dprint("Ox%X, ", (value & OxOFFF)); 

x = (double)(value & OxOFFF); 

X = (x/4095.0)*5.0; 


dprint("%3.31f Volts", x); 

switch((valueScOxEOOO) >>13) 

( 

case 0: /* DCS Temp */ 

X = (x - 0.5)*100; 

dprint(", DCS Temp. = %3.31f C", x); 
brealc; 

case 1: /* Modem Temp */ 

X = (x - 0.5)/.01; 

dprint(", Modem Temp. = %3.31f C", x); 
break; 

case 2: /* TMUXA Temp */ 

dprint(", TMUXA Temp. = %d C", cnv_therm(value&OxOFFF)); 
break; 

case 3: /* TMUXB Temp */ 

dprint(", TMUXB Temp. = %d C", cnv_therm(value&OxOFFF)); 
break; 


case 4: /* EPS Measurement */ 

dprint(", EPS"); 
break 


dprint 

C - - ; 


("\n") ; 


/* Do a diagnostic test */ 

/* Using Diagnostic mode: VIN+ = 000 = VREFOUT, VIN- = 000 = GND */ 


outpw(AD_ 

INSTRO, 0XF202); 

/* acq. 

time = 

full way, no wdog, 12-bit, */ 



/* 

Timer 

ON, NO sync */ 



/* 

Pause 

= YES, loop = NO */ 



/* 

Note: 

pause will happen after loop */ 

/* Using Diagnostic mode: 

VIN+ = 001 

= VREF+, 

VIN- = 001 = VREF- */ 

outpw(AD 

INSTRl, 0XF225); 

/* acq. 

time = 

full way, no wdog, 12-bit, */ 


outpw (AD_CONPIG, 0x0002); /* Reset the A/D */ 

while (inpw(AD__CONFIG) & 0x0002) /* Wait for Reset bit to clear */ 


outpw(AD_CONFIG, 0x0801); /* start sequencer in diagnostic mode */ 

/* Wait for INT 5 - Pause Interrupt */ 
while (!inpw(AD_ISR & 0x0020)) 

/* Sequencer is stopped, due to Pause in last instruction */ 

/* Wait for 2 samples in the FIFO */ 
while (((inpw(AD_ISR) & OxFSOO) >> 11) < 2) 


250 




c = (inpw(AD_ISR) & OxFSOO) >> 11; 
while (c) 

{ 

value = inpw(AD_FIFO}; 
if (c == 2) 

dprint("Diagnostic; VREFOUT to GND: "); 
else if (c == 1) 

dprint("Diagnostic: VREF+ to VREF-: "); 
dprint("%u) ", (value & OxEOOO) >> 13); 
if (value & 0x1000) 
dprint("-"); 

dprint("%u, ", (value & OxOFFF)); 

dprint{"0x%X, ”, (value & OxOFFF)); 

X = (double)(value & OxOFFF); 

X = (x/4095.0)*5.0; 

dprint(”%3.31f Volts\n”, x); 
c--; 

) 

) /* End of ad_read() */ 




* ad_status 

* 

****************************************************************************y 

voidad_status(char *cptr) 

{ 

unsigned int isr = inpw(AD_ISR); 
unsigned int temp, i; 


dprint("A to D Interrupts: %X = %X\n", AD_ISR, isr); 

dprint(" Interrupts Generated: "); 
for (temp = isr, i - 0; i <= 7; i++) 

{ 

if (i != 6) 

if (temp & 0x0001} 

dprint{"%d ", i); 

temp >> 1; 

} 

dprint("\n"); 

dprint(" Sequencer's current address = %X\n", (isr & OxOFOO) >> 8); 

dprint(" # of conversions in FIFO = %X\n", (isr & OxFSOO) >> 11); 

} /* End of ad_status() */ 


* 

* m_off() 

* 

voidm_off(char *cptr) 

( 

modem_off(); 
dprint("Modem OFF"); 
} /* End of m_off() */ 


* 

* m_on() 

Ik- 

void m_on (char *cptr) 

{ 

modeTn_on () ; 
dprint("Modem ON"); 

} /* End of m_on() */ 

251 



* m_clear() 


voidra_clear(char *cptr) 

{ 

modem_clear() ; 
dprint("Modem Clear"); 
} /* End of m_clear() */ 


* m_spread() 


voidm_spread(char *cptr) 

{ 

modem__spread () ; 
dprint("Modem Spread"); 
} /* End of m_spread() */ 


* m_hunt{) 


voidm_hunt (char *cptr) 

{ 

scc_hunt 0; 

} /* End of m_hunt0 */ 


m sccaO 


voidra__scca (char *cptr) 

{ 

charregdO], valuetlO]; 
WORD data ; 


cptr = get_tok:en(cptr, reg) ; 
cptr = get_token(cptr, value); 

if (value[0] == NULL CHAR) 

{ 

outp(SCCA_CMD, cnv_hex(reg)); 
data = inp(SCCA_CMD); 

dprint("SCCA RR#%s = %X ", reg, data) 
disp_b((BYTE)data); 

} 


else 

scca_wreg(cnv_hex(reg), cnv_hex(value) ) 
} /* End of m_scca() */ 


* m_sccb() 


voidm_sccb (char *cptr) 

{ 

charreg[10], valueflO]; 
WORD data; 



cptr = get_token{cptr, reg); 
cptr = get_token(cptr, value); 

if (value[0] == NULL_CHAR) 

{ 

outp(SCCB_CMD, cnv_hex(reg)); 
data = inp(SCCB_CMD); 

dprintC'SCCB RR#%s = %X reg, data) ; 

disp_b((BYTE)data); 

) 

else 

sccb_wreg (cnv_hex(reg) , cnv_hex (value) ) ; 
} /* End of m_sccb() */ 


* 

* pa_read() 

* 

voidpa_read(char *cptr) 

{ 

pal00_read_regs() ; 

} /* End of pa__read() */ 


/***************************************************************************** 

* 

* pa_write() 

* 

* This command requests of the terminal emulator program on the other side of 

* the RS-232 to send the contents of the filename requested via this command 

* parameter. The filename is proceeded with a CTRL-Z which indicates to the 

* terminal emulator that a request to open, read, and download a local file 

* across the serial port. The download is complete when a CTRL-Z from the 

* terminal emulator is sent and received at this end. 

* 

* The data across the serial line comes in pairs. The first is the address 

* offset (into the PA-100) , followed by the data to be written to that 

* address. If there is no data associated with the filename, then only 

* the terminating CTRL-Z will be sent, causing the count, c, to be zero. 

* 

****************************************************************************/ 


voidpa_write (char *cptr) 

{ 

char filename (30] ; 

BYTEx; 

int c, i ; 

static pal00_instr_struct pal00_config[75] ; 


cptr = get_token(cptr, filename); 

dprint ("Receiving data from %s.\n", filename); - 

serial_out((BYTE)CTRL_Z); 
dprint("%s", filename); 
serial_out((BYTE)CTRL_Z)/ 


if ((c = get_char()) == 0) 

dprint("No data downloaded!"); 

else if (c < 75) 

{ 

for (i = 0; i < c; i++) 

( 

pal00__config [i] .address = get_char(); 
pal00_config[i].data = get_char(); 

) 

pal00_config[c].address = OxFF; 
pal00_config[c].data = OxFF; 

dprint("Data received for %d instructions. \n", c); 
pal00_write_table(pal00_config); 
dprint("Data downloaded to PAIOO."); 


253 


else 


dprint("Error, attempting to load a table greater than 75 elements!"); 
} /* End of pa_write() */ 








* loadO 

* 

***************itie**-kifk**1e-kit*****ic***ifk****ie*******ie1c*i,ick****-kic*********-k***-k/ 

void load(char *cptr} 

{ 

char filename[30] ; 

BYTE x; 

unsigned int c, i; 
unsigned long temp; 

BYTE far * ptr; 


temp = ((unsigned long)0xl000<<16) + (unsigned long)(0x0100); 
ptr = (BYTE far *)temp; 


cptr = get_token(cptr, filename); 

dprint("Loading program image from %s to %P.\n", filename, ptr); 

serial_out ( (BYTE) CTRL_Y) ; 
dprint("%s", filename); 
serial_out((BYTE)CTRL_Y); 


c = get_char() ; 
c *= 256; 
c += get_char(); 

if (c == 0) 

dprint("No program image loaded!"); 


else 

{ 

i = C; 

while (i--) 

{ 

X = get__char () ; 

*ptr = X; 

++ptr; 

) 

dprint("Program image loaded, %d bytes.", c); 


} 

) /• End of loadO */ 


* 

* goto__load() 




/ 


voidgoto_load (char *cptr) 

{ 

/* Transfer control to the os RAM image at 0x1000:0100 */ 
_asm 
{ 


cli 

mov 

ax, 0x1000 


push ax 


; new CS = 0x1000 

mov 

ax, 0x0100 


push ax 


; new IP = 0x0100 

sti 

retf 




} 


} /* End of goto_load() */ 


dump() 


254 




voiddump(char *cptr) 

{ 

char buf[10]; 

static BYTE far * ptr = OL; 
BYTE val; 

WORD segment, offset; 

unsigned long temp; 
int i, j; 


cptr = get_token(cptr, buf); 
if (buf [01 != NULL_CHAR) 

{ 

segment = cnv_hex(buf); 
cptr = get_token(cptr, buf); 
offset = cnv_hex(buf); 

temp = ((unsigned long)segment<<16) + (unsigned long)(offset & OxFFFF) 
ptr = (BYTE far *)temp; 

} 


for (i = 0; i < 256; i += 16) 

{ 

dprint("%P ", (BYTE far *) (ptr + i) ) ; 
for (j = 0; j < 16; j++) 

{ 

if (j == 8) 

dprint(" ") ; 

val = ((BYTE)*(ptr+i+j) ); 
if (val < 0x10) 
dprint ('• 0 ") ; 
dprint("%X ", val); 

) 

dprint(” ”); 

for (j = 0; j < 16; j++) 

{ 

val = ((BYTE)*(ptr+i+j)); 
if ((val >= 32) && (val <= 127)) 
dprint("%c",*(ptr+i+j)); 

else 

dprint("."); 

) 

dprint("\n"); 

} 

ptr +== 256; 

} /* End of dumpO */ 




* editO 


voidedit(char *cptr) 

{ 


char 

BYTE far * 

BYTE 

WORD 


buf[10]; 
ptr; 

val; 

segment, offset; 


unsigned long temp; 


cptr = get_token(cptr, buf); 
segment = cnv_hex(buf); 
cptr = get__token(cptr, buf) ,- 
offset = cnv_hex(buf); 

temp = ((unsigned long)segment<<l6) + (unsigned long)(offset & OxFFFF); 
ptr = (BYTE far *)temp; 

dprint (’'\n%P>«, ptr); 
get_string(buf, 50); 
while (buf[0] != NtJLL_CHAR) 

{ 

val = cnv_hex(buf) ; 

(*ptr) = val; 
ptr++; 


255 



dprint (”\n%P>’', ptr) ; 
get_string(buf, 50); 


} /* End of editO */ 


* 

* insu_cmd () 

* 


#define READ 1 

#define WRITE 2 

#define DUMP 3 

#define NONE 0 

#define FLASH 1 

#define SRAM 2 

#define STR_LEN 100 

voidmsu_cmd(char *cptr, int device) 
{ 


char 


buf [10], addr_buf[10] 

unsigned 

long 

int addr; 

int 


type = NONE; 

unsigned 

int 

data; 

int 


action = NONE; 

int 


i = 0; 

int 


j ; 

WORD 


X; 

static BYTE 

Str [STR_LEN] ; 

BYTE 


dbuf [256], val; 

static DWORD 

daddr = 0; 


cptr = get_token(cptr, buf); 


if (buf[0] == >0') 
msu_off(device); 

/* Turn OFF */ 

else if (buf[0] == ’1') 

/* Turn ON */ 


msu_on(device); 


else 


cptr = get_token(cptr, addr_buf); 
addr = cnv_lhex(addr_buf); 

if (scricmp(buf, "rs") == 0) /* Read Static */ 

{ 

if (debug) 

dprint("Reading SRAM @ %lx\n", addr); 
type = SRAM; 
action = READ; 

} 

else if (stricmp(buf, "rf") == 0) /* Read Flash */ 

{ 

if (debug) 

dprint("Reading FLASH ® %lx\n", addr); 
type = FLASH; 
action = READ; 

) 

else if (stricmp(buf, "df") == 0) /* Dump Flash */ 

{ 

type = FLASH; 
action = DUMP; 
if (addr_bufl0] != ’\0') 
daddr = addr; 

/* else, get the next paragraph from the last dump */ 

else if (stricmp(buf, "ds") == 0) /* Dump Static */ 

{ 

type = SRAM; 
action = DUMP; 
if (addr_buft0] 1= *\0') 
daddr - addr; 

/* else, get the next paragraph from the last dump */ 
else if (stricmp(buf, "ws") == 0) /* Write Static */ 

256 



{ 


if (debug) 

dprint("Writing SRAM @ %lx\n", addr); 
type = SRAM; 
action = WRITE; 

} 

else if (stricmp(buf, "wf”) == 0) /* Write Flash */ 

{ 

if (debug) 

dprint ("Writing FLASH ® %lx\n'', addr) ; 
type = FLASH; 
action = WRITE; 

) 

else if (stricmp(buf, "ef") == 0) /* Erase Flash */ 

{ 

if (debug) 

dprint("Erasing FLASH for MSA\n"); 
msu_flash_erase(device); 
return; 

} 

else if (stricmp(buf, "af") == 0) /* Address Flash */ 

{ 

if (debug) 

dprint("Setting Flash address = %lx\n", addr); 
msu_set_faddr(device, addr); 
return; 

} 

else if (stricmp(buf, "cf") == 0) /* Address Flash */ 

{ 

if (debug) 

dprint("Reading Flash Codes...."); 

dprint("Flash Codes = %X\n", msu_flash_codes(device) ) ; 
return; 

) 

else if (stricmp(buf, "tf") == 0) /* Test Flash */ 

{ 

if (debug) 

dprint("Performing Flash test,..."); 

msu_ftest(device); 
return; 

} 

else if (stricmp(buf, "ts") == 0) /* Test SRAM */ 

{ 

msu_stest(device); 

} 

switch(action) 

{ 

case READ: 

if (type == SRAM) 

data = msu_sram_readl(device, addr++); 

else 

data = msu_flash_readl(device, addr++); 

while ((data != NTJLL^CHAR) && (i < STR_LEN-1)) 

{ 

str[i++] = data; 
if (type == SRAM) 

data = msu_sram_readl(device, addr++); 

else 

data = msu_flash_readl(device, addr++); 

} 

str[i] = NULL_CHAR; 
dprint("%s", str); 
break; 

case DUMP: 

if (type == SRAM) 

msu_sram_read(device, daddr, (BYTE *)&dbuf, 256); 

else 

msu_flash_read(device, daddr, (BYTE *)&idbuf, 256) 
for (i = 0; i < 256; i += 16, daddr += 16) 

{ 


if (daddr < 0x10) 
dprint("0"); 


257 



if (daddr < 0x100) 
dprint(”0"); 
if (daddr < 0x1000) 
dprint("0”); 
if (daddr < OxlOOOO) 
dprint("0"); 
if (daddr < 0x100000) 
dprint("O”) ; 
dprint (''%1X ", daddr); 

for (j =0; j <16; j++) 

{ 

if (j == 8) 

dprint(" "); 
val = dbuf[i+j]; 
if (val < 0x10) 
dprint("0"); 
dprint("%X ", val); 

} 

dprint(" "); 

for (j =: 0; j < 16; j + + ) 

( 

val = dbuf[i+j]; 

if ((val >= 32) && (val <= 127)) 
dprint("%c", dbuf[i+jj); 

else 

dprint ("."); 

) 

dprint("\n"); 

} 


break; 
case WRITE: 

while ((*cptr != NULL_CHAR) && (i < STR LEN) ) 

{ 

if (type == SRAM) 

msu_sram_writel(device, addr++, *cptr); 

else 

msu_flash_writel(device, addr++, *cptr); 

i++; 

cptr++; 

} 

if (type -= SRAM) 

msu_sram_writel(device, addr, *cptr); 

else 

msu_flash_writel(device, addr, *cptr); 
break; 

default: 

dprint("MSU command error."); 

} /* End of SWITCH */ 

} /* End of ELSE */ 

} /* End of msu_cmd() •/ 


* 

* msa_cmd() 

* 


voidmsa_cmd(char •cptr) 

{ 

msu_cmd(cpt r, MSAC•, 

} /* End of nisa_c»d •• 


* 

* msb_cmd() 

* 

voidmsb_cmd(char ‘cptr) 

{ 

msu_cmd(cptr, MSBO); 

} /* End of msb_cmd() ♦/ 










258 






* 

* debug_cmd() 

* 

void debug_cmd( char *cptr) 

{ 

char buf[10]; 


cptr = get_token(cptr, buf)/ 

if (buf[0] == '0') 
debug = FALSE; 

if (buf[0] == »!’) 
debug = TRUE; 


} /* End of debug_cmd(} */ 


* 

* t iine_cmd () 

* 

void time_cmd (char *cptr) 
{ 


static int 

mdays[) = (O, 31, 28 

, 31, 

30, 31,‘ 

30, 31, 

31, ‘ 30 , 31, 30, 31}; 

static char 

*dow_str[] = {"Thu", 

"Fri" 

, "Sat"; 

r "Sun", 

"Mon", "Tue", "Wed"} 

static char 

*dom_str[] = {"Jan", 

"Feb" 

, "Mar"; 

, "Apr", 

"May", "Jun", "Jul", 

unsigned longt. 

"Aug", 

et, tdays, tsecs; 

"Sep"; 

, "Oct", 

"Nov", 

"Dec"}; 


char buf[20]; 

int year, month, day, hour, min, sec, dow, leap; 


cptr = get_token(cptr, buf); 

if (buf[0] ==: NULL_CHAR) 

{ 

t = get_time(); 

et = get_elapsed_time(); 

tsecs = t; 

tdays = t/SECS_PER_^DAY; 

/* first, get elapsed years */ 

leap = 2; /* corresponds with Modulo four, starting with 197 0 */ 

year = 0; 

while (tdays >= 366) 

{ 

if (leap%4 == 0) 

{ 

tdays -= 366; 

tsecs ♦= 366*SECS_PER_DAY; 

) 

else 

{ 

tdays -= 365; 

tsecs -= 365*SECS_PER_DAY; 

) 

year++; 

leap++; 

} 

if ((tdays == 365) && !(leap%4 == 0)) 

{ 

tdays -= 365; 

tsecs -= 365*SECS_PER_DAY; 
year++; 

} 

/* now, get the month */ 
month = 1; 

while (tdays >= mdays[month]) 

{ 

if ((month == 2) && (leap%4 == 0)) 

{ 

tdays -= 29; 

tsecs -= 29*SECS_PER_DAY; 

} 

else 


259 


tdays -= mdays [month] ; 

tsecs -= mdays[month]*SECS PER DAY; 

} 

month++; 

} 

day = tdays; 

tsecs -= day*SECS_PER_DAY; 

if (debug) 

{ 

dprint(”year=%d, months%d, day=%d year, month, day); 
dprint ("tsecs remaining=:%ld\n'', tsecs); 

} 

hour = tsecs/SECS_PER_HOUR; 
tsecs -= hour*SECS_PER_HOUR; 

min = tsecs/SECS_PER_MIN; 
tsecs -= min*SECS_PER_MIN; 

sec = tsecs; 

dow = (t/SECS_PER_DAY)%7; /* 0=Thu, l=Fri, etc. ^ 

dprint(''%s %d %s %d, ”, dow_str [dow] , day+l, dom_str [month-1] 
if (hour < 10) 

dprint("0%d;", hour); 

else 

dprint(”%d:", hour); 
if (min < 10) 

dprint("0%d, min); 

else 

dprint("%d;", min); 
if (sec < 10) 

dprint("0%d”, sec); 

else 

dprint("%d”, sec); 

/* Elapsed time */ 
day = et/SECS_PER_DAY; 
et -= day*SECS_PER_DAY; 
hour = et/SECS_PER_HOUR; 
et -= hour*SECS_PER_HOUR; 
min = et/SECS_PER_MIN; 
et -= min*SECS_PER_MIN; 
sec = et; 

dprint(" (Elapsed time = "); 
if (day < 10) 

dprint("0 %d:", day); 

else 

dprint("%d:”, day); 
if (hour < 10) 

dprint(”0%d:", hour); 

else 

dprint(”%d:", hour); 
if (min < 10) 

dprint(”0%d:", min); 

else 

dprint(”%d, min); 
if (sec < 10) 

dprint("0%d)\n", sec); 

else 

dprint("%d)\n", sec); 


buf[2] = NULL_CHAR; 
year = atoi(buf) - 70; 
if (year < 0) 

year += lOO; /* compensate for next century */ 

buf[5] = NULL_CHAR; 
month = atoi(buf+3) - 1; 

buf[8] = NULL_CHAR; 
day = atoi(buf+6) - 1; 

buf[ll] = NULL_CHAR; 
hour = atoi(buf+9); 


, 1970+year) 


buf[14] = NULL CHAR; 




min = atoi(buf+12); 
sec = atoi(buf+15); 

leap = (year+2)/4; /* number of leap years since 1970 */ 

t = year*SECS_PER_YEAR + leap*SECS_PER_DAY; 
while (month > 0) 

t += mdays[month--]*SECS_PER_DAY; 

t += day*SECS_PER_DAY; 

t += (hour*SECS_PER_HOUR) + (min*SECS_PER_MIN) + see; 
set_time(t); 


} /* End of time_cmd() */ 


/*****-kie***1r*1e*1iie*iiir********ieif**ie*ieie**********'kic***1c**-t*****ie1rir*1r-k1e*******it** 

* 

* rf_cmd(} 

* 

**************************************************************************** 

#define TOCON 0xFF56 

#define TOCNT OxFFSO 

#define TOCMPA 0xFF52 

#define TOCMPB 0xFF54 

#define TICON OxFFSE 

#define TICNT 0xFF58 

#define TICMPA OxFFSA 

#define TICMPB OxFFSC 

voidrf_cmd(char *cptr) 

{ 

static BYTE bits = 0x00; 

char buf[10]; 

int temp; 


cptr = get_token(cptr, buf); 

if (striemp(buf, "0") == 0) 
6 ps_set_power(RF, OFF); 

else if (striemp(buf, "1") == 0) 
eps_set_power(RF, ON); 


else if (striemp(buf, "t") == 0) 

{ 

bits 1= 0x01; 
pcb_write(0^ 0, bits); 

} 

else if (striemp(buf, "r”) == 0) 

{ 

bits &= -0x01; 
pcb_write(0^ 0, bits); 

} 


else if (striemp(buf, ”tx”) == 0) 

{ 

bits 1= 0x02; 
pcb_write(0, 0, bits); 

1 

else if (striemp(buf, "rx") == 0) 

{ 

bits &= -0x02; 
pcb_write(0, 0, bits); 

} 


else if (striemp(buf, "lop") == 0) 

{ 

bits &= -0x04; 
pcb_write(0, 0, bits); 

} 


261 



else if {stricmp(buf, "loa”) == 0) 

{ 

bits [= 0x04; 
pcb_write(0, 0, bits); 

} 


else if (stricmp(buf, "Ihp") == 0} 

{ 

bits &= -0x08; 
pcb_write(0, 0, bits); 

} 

else if (stricmp (buf, "lha”) == 0) 

{ 

bits j= 0x08; 
pcb_write(0, 0, bits); 

} 


else if (stricmp(buf, “p") == 0) 

{ 

cptr = get_tok;en (cptr, buf) ; 

temp = cnv_hex(buf); 

temp &= 0x03; 

temp <<= 4; 

bits 1= (BYTE)temp; 

pcb_write(0, 0, bits); 

} 


else if (stricmp(buf, "InaO”) == 0) 

{ 

bits 1= 0x40; /* reverse logic than all others */ 

pcb_write(0, 0, bits); 

} 

else if (stricmp(buf, "Inal") == 0) 

{ 

bits &= -0x40; /* reverse logic than all others */ 

pcb_write{0, 0, bits); 

} 


else if (stricmp(buf, "hpaO") == 0) 

{ 

bits -0x80; 
pcb_write(0, 0, bits); 

} 


else if (stricmp(buf, "hpal") == 0) 

{ 

bits 1= 0x80; 
pcb_write(0, 0, bits); 

} 


else if (stricmp(buf, "e") == 0) 

{ 

OUtpw(T0CNT, 0); 

outpw(TOCMPA, 0); /* maximum count (65536) */ 

outpw(TOCON, OxCOOl) ; /* internal elk, retrigger, CMPA only */ 

Outpw(TlCNT, 0); 

outpw(TICMPA, 1); /* smallest compare A */ 

cptr = get_token(cptr, buf); 
if (buf[0] == NULL CHAR) 

{ 

/* default to 5 second RF Enable */ 
temp =140; /* -5 seconds */ 

} 

else 

{ 

temp = cnv_hex(buf) ; 

^ temp *= 28; /* ^28 CMPB per second */ 

outpw(TICMPB, temp); 

^ outpw(TlCON, 0xC006) ; /* ext. elk, one shot, CMPA/CMPB dual mode */ 

} /* End of rf_cmd{) */ 


262 





* test_cmd() 

* 

****************************************************************************/ 
void test_cmd(char *cptr) 

f 

int c, X; 

WORD value; 
double d; 

#define AD_WAIT 5000 

pcb_write(EPSO, 3, 0x70); 
pcb_write(EPSO, 1, 0x50); 


/* Setup MUXes A/B for first temperature sensors (Calibration resistors) */ 
pcb_write(TMUXAO, 0, 0x10); 
pcb_write(TMUXBO, 0, 0x10); 


pcb_write (EPSO, 3, 0x80); /* EPS Port 3 */ 

pcb_write(EPSO, 1, 0x30); /* EPS Port 1 */ 

eps_set_port2 (eps_get_port2 ()); 

outpw(AD_CONFIG, 0x0002); /* Reset the A/D */ 

/* Wait for RESET bit to clear */ 

for (x = 0; (x < AD_WAIT) && (inpw(AD_CONFIG) & 0x0002); x++) 

if (x == AD_WAIT) 

{ 

ad_flag = 1; 
return; 

} 


outpw(AD_CONFIG, 0x0008); /* Full Calibration */ 

/* Wait for CALIBRATION bit to clear */ 

for (x = 0; (x < AD_WAIT) && (inpw(AD_CONFIG) & 0x0008); x++) 

if (x == AD_WAIT) 

{ 

ad_flag = 1; 
return; 

} 

outpw(AD_CONFIG, 0x0000) ; /* stop the sequencer and point to RAM 00 */ 

/* Program A/D Sequencer: based on schedule for period 0 */ 

outpw (AD_INSTR0 , 0xF2 00); 

outpw (AD_INSTR1, 0XF204); 

outpw (AD_INSTR2, 0xF208); 

outpw (AD_INSTR3 , 0xF210) ; 

outpw (AD_INSTR4 , 0XF218) ; 

outpw(AD_INSTR5, 0xF202); /* Pause */ 


/* Setup A/D Timer */ 
outpw(AD_TIMER, 2000); 

outpw(AD_CONFIG, 0x0002); /* Reset the A/D */ 

/* Wait for RESET bit to clear */ 

for (x = 0; (x < AD_WAIT) && (inpw(AD_CONFIG) & 0x0002); x++) 

if (x == AD_WAIT) 

{ 

ad_flag = 1; 
return; 

} 

/* Force A/D to interrupt when 5 readings in the FIFO occur */ 

/* OUtpw(AD_IER, 0x2804); */ 

/* Clear any interrupts of the A/D by reading the status register */ 
/* inpw(AD_ISR); */ 

/* Start the A/D Sequencer, Interrupt will occur eventually */ 
outpw(AD_C0NFIG, 0x0001); /* start sequencer */ 


263 




/* Wait for 5 samples in the FIFO */ 
while {{(inpw{AD_ISR) & OxFSOO) >> 11) < 5) 


c = {inpw(AD_ISR} & OxFBOO) >> 11; 
while (c) 

{ 

value = inpw(AD_FIPO); 

dprint(''%u) ", (value & OxEOOO) >> 13); 
if (value & 0x1000) 
dprint("-") ; 

dprint("%u, ", (value & OxOFFF)); 

dprint{"0x%X, ", (value & OxOFFF)); 

d = (double)(value & OxOFFF); 
d = (d/4095.0)*5,0; 

dprint("%3.3If Volts", d); 

switch((value&OxEOOO)>>13) 

{ 

case 0: /* DCS Temp */ 

d = (d - 0.5)*100; 

dprint(", DCS Temp. = %3.3lf C", d); 


break; 



case 1: /* Modem Temp */ 

d = (d - 0.5)/.Ol; 
dprint(", Modem Temp. 
break; 

= %3.31f 

C", d); 

case 3; /* TMUXA Temp */ 

dprint(", TMUXA Temp. 
break; 

= %d C", 

cnv_therm(value&0x0FFF)) 

case 4: /* TMUXB Temp */ 

dprint(", TMUXB Temp. 

= %d C", 

cnv_therm(value&OxOFFF)) 


break; 

case 2: /* EPS Measurement */ 

dprint{", EPS"); 
break; 

} 

dprint("\n"); 

C-“ ; 

} 

} /* End of test_cmd() */ 


★ 




* tx_cmd() 




voidtx_cmd(char *cptr) 

{ 

int i ; 


i = 0; 

while ((*cptr != NULL CHAR) && (i < 128)) 

{ 

cha_out_buf0[i] = *cptr; 
cptr++; 
i++; 

) 

/• Setup the pointer to the source for DMA channel 1 (Tx) */ 
_asm 

{ 


mov 

ax. 

SEG cha_out_buf0 

rol 

ax. 

4 

mov 

bx. 

ax 

and 

ax. 

OxFFFO 

add 

ax. 

OFFSET cha_out__buf 0 

adc 

bx, 

0 

and 

bx, 

OxOOOF 

mov 

dx. 

DISRCL 

out 

dx. 

ax 


264 



mov ax, bx 
mov dx, DISRCH 
out dx, ax 


/* Setup the pointer to the destination for DMA channel 1 (Tx) */ 
outpw(DlDSTH, 0x0000); 

OUtpw(DlDSTL, SCCA_DATA) ; 

outpw(DlTC, i); /* DMA Transfer Count */ 

outpw(DlCON, 0x1786); /* DST: i/o, no inc., no dec.; SRC: mem, inc., no dec. 

* terminate on TC; INT on TC; Dest. Synch; 

* low priority; do not use Tmr2; Byte xfer 

* Start the DMA channel */ 


} /* End of tx_cmd() */ 

* 

* rx_cmd() 

* 

void rx_cmd (char *cptr) 

{ 

charbuf [10] ; 


cptr = get_token(cptr, buf); 
if (stricmp (buf, ’'i'') == 0) 

{ 

inp(SCCA_DATA); 
inp(SCCA_DATA); 
inp(SCCA_DATA); 

/* Setup the pointer to the destination for DMA channel 0 (Rx) */ 
_asm 
{ 


mov 

ax. 

SEG cha_in_buf0 

rol 

ax. 

4 

mov 

bx, 

ax 

and 

ax, 

OxFFFO 

add 

ax, 

OFFSET cha_in_buf0 

adc 

bx. 

0 

and 

bx. 

OxOOOF 

mov 

dx. 

DODSTL 

out 

dx, 

ax 

mov 

ax. 

bx 

mov 

dx. 

DODSTH 

out 

dx. 

ax 

Setup 

the 

pointer to the source for DMA channel 


OUtpw(D0SRCH, 0x0000); 

OUtpw(D0SRCL, SCCA_DATA) ; 

outpw(D0TC, 514) ; /* DMA Transfer Count ~ include the two CRC bytes */ 


outpw(D0CON, 0xA366) ; /* DST: mem, inc., no dec.; SRC: i/o, no inc,, no dec. 

* terminate on TC; INT on TC; Source Synch; 

* high priority; do not use Tmr2; Byte xfer 

* START the channel */ 


dprint("Rx initialized and ready, \n''); 
return; 

} 


if (inp(SCCA_CMD) & 0x010) 

dprint("Sync (Flag) not detected, still in Hunt Mode\n”); 

else 

dprint("Sync (Flag) detected! \n'') ; 


if (stricmp(buf, "s") == 0) 

{ 

dprint("Tx Underrun/EOM: %u, Rx Overrun: %u\n”, a_txunderrun_eom, a_rxoverrun); 
dprint ("Break/Abort: %u\n", a_brk__abort) ; 

) 


265 



if (rx^eoni) 

{ 

dprint (”%s\n'’, cha_in__buf 0) ; 
rx_eoni = FALSE; 

} 

else 

dprint("No message received.\n"); 
) /* End of rx_cmd{} */ 


/***************************************************************************** 

* 

* eps_cmd(} 

* 

*****★**★*********************♦****★**********************♦*****************/ 

voideps_cmd (char *cptr) 

{ 

char buf[10] ; 

static char *ctrls[]={"HeatA", "TMUXA”, "MSA", 

"Ant-Rel", "MSB", "TMUXB", "RF", "HeatB", ""} ; 
static char *bat_sw[]={"B Trickle", "B Online", "B Discharge", "B Charge", 

"A Trickle", "A Online", "A Discharge", "A Charge"}/ 
static int bat_cmdl[2][9] = {{O, 0, 0, 0, 0, 1, 3, 5, 7), {O, 0, 0, 0, 0, 9, 11, 13, 15} 

static int bat_cmd2[2] [9] = {{0x70, 0x90, OxFl, 0xF3, 0xF5, 0x10, 0x10, 0x10, Oxio}, 

{OxBO, OxDO, 0xF7, 0xF9, OxFB, 0x10, 0x10, 0x10, 0x10}}; 
static doiible bat_cnv[2][9] = {{l, 1, .585, .585, .585, .409, .409, .409, .409}, 

{l, 1, .525, .525, .525, .21, .21, .21, .2l}}; 

Static int i_sp_cmd[8] = {OxOO, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70}; 

static int i__sp_tbl [8] = {4, 5, 7, 9, 11, 13, 14, 16}; 

int temp, n; 

int bat, dev; 

int X; 

WORD a, tempw; 
double d, sign; 

BYTEb; 


cptr = get_token(cptr, buf); 
switch(buf[0]) 

{ 

case ‘b’: 
case ’B': 

cptr = get_token(cptr, buf); 
if (stricmp(buf, "a") == 0) 
bat = BAT_A; 

else if (stricmp(buf, "b") == 0) 
bat = BAT_B; 

else if (buf[0) == NULL_CHAR) 

{ 

tempw = eps_get_battery0 ; 

dprint("Battery Controls that are ON (0x%X):\n", tempw); 
for (x - 0; X <= 15; X++) 
if (tempw & (l<<x)) 

dprint(" %s", bat_sw[x]); 
dprint("\n"); 
return; 

} 

else 

{ 

dprint("EPS cmd error: battery (%s) not recognized.\n", buf); 
return; 

} 

cptr = get_token(cptr, buf); 
if (stricmp(buf, "c") == 0) 
temp = BAT_CHARGE_ON; 
else if (stricmp(buf, "d") == 0) 
temp = BAT_DISCHARGE_ON; 
else if (stricmp(buf, "o") == 0) 
temp = BAT_ONLINE; 
else if (stricmp(buf, "t") == 0) 
temp = BAT_TRICKLE_ON; 

else 

{ 

dprint("EPS cmd error; control (%s) not recognized.\n", buf); 
return; 

) 


cptr = get^token(cptr, buf); 
if (stricmp(buf, "on") == 0) 

266 



eps_set_battery(bat, temp); 
else if (stricmp(buf, "off”) == 0) 
eps_set_battery(bat, temp+1); 

else 

dprintC'EPS cmd error: option (%s) error.: %s\n", buf) ; 
break; 


case * c': 
case •C : 


cptr = get_token(cptr, buf); 
if (stricmp(buf, "tmuxa") == 0) 


dev 

= PWR_TMUXA; 



else if 

(stricmp(buf, 

"tmuxb") 

== 0) 

dev 

= PWR_TMUXB; 



else if 

(stricmp(buf, 

"msa") = 

= 0) 

dev 

= PWR_MSA; 



else if 

(stricmp(buf. 

"msb") = 

- 0) 

dev 

= PWR_MSB; 



else if 

(stricmp(buf. 

"heata") 

0) 

dev 

= PWR_HEATA; 



else if 

(stricmp(buf. 

"heatb") 

0) 

dev 

= PWR_HEATB; 



else if 

(stricmp(buf, 

II 

II 

u 

0) 

dev 

= PWR_RF; 



else if 

(stricmp(buf. 

"antrel" 

) == 0) 

dev 

= PWR_ANTREL; 



else if 

(buf [0] == NULL_CHAR) 



{ 

tempw = eps_get_j>ower 0 ; 

dprint("Subsystems that are ON (0x%X):\n”, tempw); 
for (x = 0; X <= 15; x++) 
if (tempw & (l<<x)) 

dprint(" %s", ctrls[x]); 

dprint("\n"); 
return; 

} 

else 

{ 

dprintC'EPS cmd error: subsystem (%s) not recognized. \n", buf); 
return; 

) 

cptr = get_token(cptr, buf); 
if (stricmp(buf, "on") == 0) 
eps_set_power(dev, ON); 
else if (stricmp(buf, "off") == 0) 
eps_set_power(dev, OFF); 

else 

dprintC'EPS cmd error: power control syntax error: %s.\n", buf) 
break; 


case 'V : 
case 'V : 

cptr = get_token(cptr, buf); 
if ((buf(0] == 'A') II (buf[0] == 'a')) 

{ 

bat = BAT_A; 
n = atoi(&(buf+1)); 

) 

else if ((buf [0] == 'B') || (buf[0] == *b')) 

{ 

bat = BAT_B; 
n = atoi(&(buf+1)); 

} 

else if ((buf[0] == 'S') || (buf[0] == 's')) 

{ 

bat = BAT_NONE; 
n = 0; 

} 

else if ((buf[0] == NULL_CHAR) |j (temp < 0) j i (temp > 8)) 

{ 

dprint("EPS cmd error: voltage source (%s) not recognized.\n", 
return; 

) 


/* Setup the EPS MUXes via the PCB */ 
if (bat != BAT_NONE) 

{ 

if ((n >= S)) 

pcb_write(EPSO, 3, bat_cmdl[bat][n]); 
pcb_write(EPSO, 1, bat_cmd2[bat][n]); 

267 


buf) 


dprint("Battery 
if (bat == BAT_A) 
dprint("A"); 

else 

dprint("B"); 

dprint(" Cell # %d (accum.) ", n); 

a = adr(4); /* EPS uses channel 4 of the A/D */ 

d = a; 

d = 5.0*(d/4095); 

dprint("%u (0x%X) , %3,31f V -> %3.31f V\n", a, a, d, d/bat_cnv [bat] [n] ) 


else/* its the s/c bus */ 

{ 

dprint("S/C "); 
pcb_write(EPSO, 1, OxFD); 

a = adr(4); /* EPS uses channel 4 of the A/D */ 

d = a; 

d = 5.0*(d/4095); 

dprint("%u (0x%X), %3.31f V -> %3.3lf V\n", a, a, d, d*3.41); 


break; 


case 'i ' : 
case 'I': 

cptr = get_token(cptr, buf); 


if ( (buf 

[03 == 'A') 

II 

(buf [01 == 'a')) 


bat 

= BAT A; 




else if 

((buf[0] == 

'B' 

) II (buflO) == 

'b')) 

bat 

= BAT B; 




else if 
/ 

((buf[0l == 

•S' 

) II (buf(0] == 

‘S')) 

l 

bat 

= BAT_NONE; 




n = 

\ 

-1; 




j 

else if 
/ 

((buf [0] == 

tpi 

) II (buf to] == 

'p') ) 

i 

bat 

= BAT NONE; 





n = atoi(&(buf+1)); 

) 

else if (buf[0] == NULL CHAR) 

{ 

dprint("EPS cmd error; current (%s) not recognized.\n", buf); 
return; 

} 


/* Setup the EPS MUXes via the PCB */ 
if (bat -- BAT_NONE) 

{ 

if (n -* - 1 ) /* its the s/c bus */ 
pcb_write(EPSO, 3, 0x80); 

b - eps_get_port20 j (BYTE)0x01; eps_set_port2 (b) ; 
pcb_write(EPSO, 1, 0x30); 
a* adr(4); 

d»a; 

dprint("S/C current = %u (0x%X), %.31f V -> %.31f mA\n", 
a , a, d/819.0, 1000.0*((d*0.002442)-5.0)) ; 

i 

per write(EPSO, 3, i_sp_cmd[n]); 

t . epE_get_port20 | (BYTE)0x01; eps_set_port2(b); 

pet write(EPSO, 1, 0x50); 
a • adr (4 ) ; 

d • a, 

dprint("S/P:%d {#%d) current = %u (0x%X), %.31f V -> %.31f mA\n", 
n, i_sp_tbl[n], a, a, d/819.0, 1000.0*(d*0.000488 - 1.0) ) 

} 

else /• one of the batteries */ 

{ 

dprint("Battery "); 
if (bat == BAT_A) 

( 


dprint("A"); 

peb write(EPS0, 3, 0x90); 



) 

else 

{ 

dprint("B”); 

pcb_write(EPSO, 3, OxAO); 

} 

b = eps_get_port20 | (BYTE)0x01; eps_set_port2{b); 

pcb_write(EPSO, 1, 0x30}/ 
a = adr (4) ; 
d = a; 


1 


/* Read the direction, */ 

n = pcb_read(EPSl, 1); /* Port 5 of the EPS */ 

if (bat == BAT_A) 
temp = 0x01; 

else 

temp = 0x02; 

sign = (temp &n) ?1.0 : -1.0; 

dprint (" current = %u (0x%X), %31f V ->%31f iTiA\n", 

a, a, sign*{d/819.0), lOOO.0*sign*({d*0.002442)-5.0)); 


break; 


case 'w': 
case 'W : 

eps_reset_wdog(); 

dprint ("Watchdog timer reset.\n'’) ; 
break; 


default: 

dprint("EPS cmd error.\n"); 
break; 

} /* End of SWITCH */ 

} /* End of eps_cmd() */ 


* 

* WORD adr () 

* 

WORDadr_old(int ch) 

{ 

unsigned int c, value, isr, temp, value_save; 
double X; 


outpw(AD_CONFIG, 0x0002); /* Reset the A/D */ 

while (inpw(AD_CONFIG) & 0x0002) /* Wait for Reset bit to clear */ 


OUtpw{AD_CONFIG, 0x0 008) ; 
while {inpw(AD_CONFIG) & 0x0008) 

OUtpw{AD_C0NF:G. 0x0000); 


/* Full Calibration */ 

/* Wait for calibration to finish */ 

/* Stop sequencer, point to RAM 00 */ 


/* DCS Temperature, MUX* - INO, MUX- = GND */ 

outpw(AD_INSTRC, CxF20C); /* acq. time = full way, no wdog, 12-bit, */ 

/* Timer ON, NO sync, Vin- =Gnd, Vin+ =IN0 */ 
/* Pause = NO, loop = NO */ 


/* Modem Temperature, MUX* 
OUtpw(AD_INSTRl, 0XF204); 


/* TMUXA, MUX* * IN4. MUX- 
OUtpw(AD_INSTR2, 0XF210); 


/* TMUXB, MUX+ = IN6, MUX- 
OUtpw {AD_INSTR3, 0xP218); 


INI, MUX- = GND */ 

/* acq. time = full way, no wdog, 12-bit, */ 

/* Timer ON, NO sync, Vin- =Gnd, Vin+ =IN1 */ 
/* no pause, loop = NO */ 

GND */ 

/* acq. time = full way, no wdog, 12-bit, */ 

/* Timer ON, NO sync, Vin-= Gnd, Vin+= IN4 */ 
/* no pause, loop = NO */ 

GND */ 

/* acq. time = full way, no wdog, 12-bit, */ 

/* Timer ON, NO sync, Vin- =Gnd, Vin+ =IN6 */ 
/* no pause, loop = NO */ 

269 



/* EPS, MUX+ = IN2, MUX- = GND */ 
outpw(AD_INSTR4, 0xF2 08); /* acq. 

/* 

/* 


time = full way, no wdog, 12-bit, */ 

Timer ON, NO sync, Vin- =Gnd, Vin+ =IN1 */ 
no pause, loop - NO */ 


/* Dummy instruction to PAUSE */ 
outpw(AD_INSTR5, 0xF2 02); 


/* RAM 01(1) and 10(2) are not set - limit stuff */ 


/* Timer to slow the conversion rate */ 
outpw(AD_TIMER, 1000); 


outpw(AD_CONFIG, 0x0002); /* Reset the A/D */ 

while (inpw(AD_CONFIG) & 0x0002) /* Wait for Reset bit to clear */ 


outpw(AD_C0NFIG, 0x0001); /* start sequencer */ 

/* Wait for INT 5 - Pause Interrupt */ 
while (!inpw(AD_ISR & 0x0020)) 

/* Sequencer is stopped, due to Pause in last instruction */ 

/* Wait for S samples in the FIFO */ 
while (((inpw(AD_ISR) & 0xF800) >> 11) < 5) 


c = (inpw(AD_ISR) & OxFSOO) >> 11; 
while (c) 

{ 

value = inpw(AD_FIFO); 

if (((value&OxEOOO)>>13) == ch) 
value_save = value & OxOFFP; 


} 


C-- ; 


return (value_save) ; 
) /* End of adr() */ 


tmux_cmd() 




voidtmux_cmd(char *cptr) 

{ 

charbuf [10] ; 
int ch; 

WORD a ; 
double X; 


cptr get_token (cptr, buf) ; 
switch(buf[0]) 

{ 

case 'a': 
case 'A' : 

cptr = get_token(cptr, buf) ; 
if {stricmp(buf, "on”) == 0) 

eps_set_power (PWR_TMUXA, ON) ; 
else if (stricmp(buf, "off") == 0) 
eps_set_power (PWR_TMUXA, OFF) ; 

else 

{ 

ch = atoi (buf); 

if ( (ch < 0) II (ch > 31) ) 

{ 

dprint("TMUX: bad cmd (%s)\n", buf); 
return; 

} 

pcb_write (TMUXA, 0, 0x10 + ch) ; 
a = adr{2); 

X = a; 


270 


X = (x/4095.0)*5.0; 

dprint ("TMUXA Channel %d; %u (0x%X) , %3.3lf V -> %d C", 
ch, a & OxOFFF, a & OxOFFF, X, cnv_therm(a) ) ; 

1 


break; 


case 'b': 
case 'B': 

cptr = get_token(cptr, buf); 
if (stricmp(buf, "on") == 0) 

ep s_s e t_powe r(PWR_TMUXB, ON) ; 
else if (stricmp(buf, "off") == 0) 
eps_set_power(PWR_TMUXB, OFF); 

else 


ch = atoi(buf); 

if ((ch < 0) I i (ch > 31) ) 

{ 

dprint("TMUX: bad cmd (%s)\n", buf); 
return; 

} 


pcb_write(TMUXB, 0, 0x10 + ch); 
a = adr(3); 
x = a; 

X = (x/4095.0)*5.0; 

dprint ("TMUXB Channel %d: %u (0x%X) , %3.31f V -> %d C", 
ch, a & OxOFFF, a & OxOFFF, x, cnv_therm(a) ); 

1 

break; 

default: 

dprint("TMOX: bad MUX (%s).\n", buf); 

} 

} /* End of tmux_cmd() */ 


* 

* tlm_cmd() 

* 


void tlm_cmd(char *cptr) 

{ 

int i; 

ByTE*ptr = (BYTE *)&tlm_record; 


serial_out(CTRL_X); 

for (i = 0; i < sizeof (tlm__record_struct) ; i++) 
serial_out(*ptr++); 

} /* End of tlm_cmd() */ 


/******ie*1,***1r***ie********ir*itir******* 

* 

* read_eps_ad() 

* 

************************************ 

unsigned int read_eps_ad(void) 

{ 

OUtpw(AD_C0NFIG, 0x0002); 
while (inpw(AD_CONFIG) & 0x0002) 


OUtpw(AD_CONFIG, 0x0008); 
while (inpw(AD_CONFIG) & 0x0008) 






/* Reset the A/D */ 

/* Wait for Reset bit to clear */ 

/* Full Calibration */ 

/* Wait for calibration to finish */ 


/* EPS, MUX+ = IN2, MUX- = GND */ 

/* outpw(AD_INSTR0, 0xF269); */ 
outpw(AD_INSTR0, 0XF209); /* acq. 

/* 

/* 


/* Vin- = IN3, Vin+ = IN2 */ 
time = 1/2 way, no wdog, 12-bit, */ 
Timer ON, NO sync, Vin- =Gnd, Vin+ =IN2 
no pause, loop = YES */ 


/* Timer to slow the delay before acquisition and consequent conversion */ 
outpw(AD_TIMER, 1000) ; /* 32 clocks * 1000 = ~ 4 msec */ 


outpw{AD_CONFIG, 0x0002); /* Reset the A/D */ 

while {inpw(AD_CONFIG) & 0x0002) /* Wait for Reset bit to clear */ 


outpw{AD_CONFIG, 0x0001); /* start sequencer */ 

/* Wait for INT 5 - Pause Interrupt */ 
while (!inpw{AD_ISR & 0x0020)) 

/* Sequencer is stopped, due to Pause in last instruction */ 

/* Wait for 1 sample in the FIFO */ 
while (((inpw(AD_ISR) & OxFSOO) » li) < l) 

return(inpw(AD_FIFO) & OxOFFF); 

} /* End of read_eps_ad() */ 






* adrO 






unsigned int adr(int ch) 

{ 

int n, i; 

unsigned int total; 


outpw(AD_CONFIG, 0x0002); /* Reset the A/D */ 

while (inpw{AD_CONFlG) & 0x0002) /* Wait for Reset bit to clear */ 

outpw(AD_CONFIG, 0x0008); 
while (inpw{AD_CONFIG) & 0x0008) 

outpw(AD_CONFIG, 0x0000); 

/* Loop Bits set for all */ 
n = 1; 
switch(ch) 

{ 

case 0: /♦ DCS: Single-ended, Vin+ = INO */ 

outpw(AD_INSTR0, 0xF200); 
outpw(AD_INSTR1, 0XF202); 
break; 

case 1: /• MODEM: Single-ended, Vin+ = INI */ 

OUtpw{AD_INSTR0, 0XF204); 
outpw{AD^lNSTRl, 0xF202); 
break; 


/* Full Calibration */ 

/* Wait for calibration to finish */ 

/* Stop sequencer, point to RAM 00 */ 


case 2; /* TMUXA: Single-ended, Vin+ = IN4 */ 

outpw{AD_INSTR0, OxF210); 
outpw(AD INSTRl, 0xF202) ; 
break; 

case 3: /• TKUXB: Single-ended, Vin+ = IN6 */ 

outpw(ADINSTRC, 0XF218); 

OUtpwfADINSTKl, 0XF202); 
break; 

case 4: /• Eiv!; Single-ended, Vin+ = IN2 */ 

outpw (AT. INSTRC. 0xF208); 

OUtpwiAI) :N:TTR:, 0xF202); 
break. 

default: 

return(0;. 
break; 

} /* End of SWITCH •/ 


/* Timer to slow the delay before acquisition and consequent conversion */ 
outpw(AD_TIMER, 1000); /* 32 clocks * 1000 = ~ 4 msec */ 

outpw{AD_CONFIG, 0x0002); /♦ Reset the A/D */ 

while {inpw(AD_CONFIG) & 0x0002) /* Wait for Reset bit to clear */ 


272 




outpw(AD_CONFIG, 0x0001); /* start sequencer */ 

/* Wait for INT 5 - Pause Interrupt */ 
while (!inpw(AD_ISR & 0x0020)) 

/* Sequencer is stopped, due to Pause in last instruction */ 

/* Wait for n sample(s) in the FIFO */ 
while (((inpw(AD_ISR) & OxFSOO) » 11) < n) 


if (n == 1) 

return(inpw{AD_FIFO) & OxOFFF); 


else 

{ 

for {total = 0, i = 0; i < n; i++) 

total += inpw{AD_FIFO) & OxOFFF; 
return(total/n); 

} 


} /* End of adr{) */ 


/**★****★********************************************************************* 
* 

* sbutdown_cmd() 

* 

****************************************************************************^ 

voidshutdown_cmd{char *cptr) 

{ 

pcb_write (EPSO, 0, 0); /* Battery A control, TMUXA, HEATA */ 

pcb_write(EPSO, 2, 0); /* Other subsystem power */ 

pcb_write(EPSl, 2, 0); /* Battery B control */ 

serial_out{CTRL_V) ; 

while (1) 


} /* End of shutdown_cmd0 */ 


* 

* bcm_cmd() 

* 

voidbcm_cmd(char *cptr) 

{. 

charbuf [10] ; 
int ch; 

WORD a; 
double X; 


cptr = get_token(cptr, buf); 

if (stricmp(buf, "on") == 0) 
bcm_on = TRUE; 

else if (stricmp(buf, "off") == 0) 
bcm_on = FALSE; 

else 

( 

dprint("Battery Charge Monitor is ") ; 
if (bcm_on) 

dprint("ON.\n"); 

else 

dprint("OFF.\n") ; 


) /* End of bcm_cmd() */ 

End of stpi.h, stpi.c 


273 


terms.h, terms.c 

/*******************************ieicifk****1i1c*-k*1fk*******-k*-k******ie************** 

* 

* TERMS.H 

* 

* Routines for terminal manipulation. 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 


Revision History: 


* 

* 

Date 

Who 

What 

* 

13 August 1991 

Jah 

Creation 

♦ 

11 Oct 1991 

Jah 

Flight terminal routines (assume printer) 

* 

2 Nov 1993 

Jah 

Adopted for DCS 


************************-k*******-k-k*************************-k**-k******irir****1t/ 

#ifdef TERMS 
#endif 

#ifndef TERMS 

extern void clr(void) ; 
extern void home(void); 
extern void mov_xy(int , int); 
extern void erase_to_eol(void); 
extern void mov_b(int); 
extern void mov_f(int); 
extern void mov_u(int); 
extern void mov_d(int); 

#endif 



#include "gen_defs.h" 

#define TERMS 

#include "terms.h” 

ttundef TERMS 

^include "print.h" 

#include "scc.h" 







void clr(void) 

{ 


274 








serial_out(Oxlb) 
serial_out(0x5b) 
serial_out(0x32) 
serial_out(Ox4a) 


/* ESC */ 
/* [ */ 
/* 2 */ 
/* J */ 


} /* End of clrO */ 




* erase_to_eol0 

* 

****************************************************************************/ 

void erase_to_eol(void) 

{ 

serial_out(OxOD); 
serial_out(OxlB); 
serial_out{'T'); 

} /* End of erase_to_eol0 */ 


* 

* home() 

Hr 


void home() 

{ 

serial_out(Oxlb); /* ESC */ 

serial_out(0x5b); /* [ */ 

serial_out(0x3b); /* ; */ 

serial_out(0x48); /* H */ 

} /* End of homeO 


/*************■*♦*****************•»********♦★****★**************************** 

* 

* mov_b() - Moves cursor back x characters ''ESC[#D" 

* 

****************************************★***********************************/ 

void mov_b{int x) 

{ 

while(x--) 
serial_out(0x28); 

} /* End of mov_b() */ 


/**************************************************************************** 

* 

* 

* mov_f() - Moves cursor forward x characters ''ESC[#C" 




void mov_f(int x) 

{ 

while(x--) 
serial_out(0x2C); 

} /* End of mov_f() */ 

* 

* 

* mov_u() - Moves cursor up x rows ''ESC[#A” 

* 

* 


void mov_u(int x) 

{ 

while(x--) 
serial_out(0x2B); 


275 





} /* End of mov u()*/ 



mov_d() - Moves cursor back x characters ''ESC[#B" 



void mov_d(int x) 

{ 

while(x--) 
serial_out(0x2A); 


} /* End of mov_d() */ 



void mov_xy(int x, int y) 

{ 

serial_out(OxlB); 
serial_out('='); 

serial_out{(BYTE){' * +y-l)); 
serial_out{(BYTE) {• ' + x - 1) ) ; 

} /* End of mov_xy() */ 


End of terms.h, terms.c 


276 



tim.h, tim.c 

/****************************★******************************************** 

* 

* TLM.H 

* 

* Data types and equates for Pansat Telemetry, 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 


* who when what 


* Jah 9 June 95 Creation (hardware sensors) 

* Jah 27 June 95 Software sensors 

* Jah 26 April 96 Adopted for ROM Startup 

* 

************★*★★*******★*****************************★*************★****/ 


#define 

NUM_TS 

64 

/* 

Number 

of 

Thermistors */ 


#define 

NUM_TM 

2 

/* 

Number 

of 

IC Temperature Sensors */ 


#define 

NUM_BAT_CELLS 

9 

/* 

Number 

of 

Battery cells (per battery) 

*/ 

#define 
#define 

TOP_CELL 8 

NUM_SP 

8 

/* 

Number 

of 

Solar Panel Current Sensors 

*/ 


/* Jah */ 

#define NUM_SETS 14 /* Number of Sets in Sequencer Instruction Table */ 

#define CURRENTS_SAMPLED 5 /* Number of currents sampled per complete A/D sweep */ 

#define TLM_RECORD_TIME (TWO_MINUTES) 

/IT************************************************************************ 

* 

* PANSAT Hardware Sensors for ROM Startup. 

* 

* This Structure can be used both for the raw data read from the 

* LM12458 A/D converter (12-bit values reflecting a voltage reading), 

* as well as converted values in the appropriate units needed for 

* decision making routines. 

* 

***********************i^************************************************/ 


typedef struct sensors 

{ 

/* Thermistors */ 
unsigned int ts[NUM_TSl; 

/* IC Temperature Sensors */ 
unsigned int tmp[NUM_TM]; 

/* Voltages */ 

unsigned int vbatta[NUM_BAT_CELLS]; 
unsigned int vbattb[NUM_BAT_CELLS] ; 
unsigned int vscbus; 

/* Currents */ 

unsigned int ibatta [CURRENTS^SAMPLED] / /* over the 42 periods */ 

unsigned int ibattb [CURRENTS_SAMPLED] ; /* over the 42 periods */ 

unsigned int iscbus tCURRENTS_SAMPLED] ; /* over the 42 periods */ 

unsigned int isolar[NUM_SP]; 


} sensors_struct; 


typedef struct cnv_sensors 

{ 

/* Thermistors */ 
signed char ts[NUM_TS]; 

/* IC Temperature sensors */ 
signed char tmp[NUM_TM]; 

/* Voltages */ 
double vbatta; 
double vbattb; 

doubl e vc e 1 1 s a [ NUM_BAT_CELLS) ; 


277 





double vcellsb[NUM_BAT_CELLS] ; 
double vcells a_avg; 

double vcellsb_avg; 
double vscbus; 

/* Currents */ 
double ibatta; 
double ibattb; 
double iscbus; 
double isp[NUM_SP]; 

} cnv__s enso rs_s tract; 

/*******ir1r****1r*it***-kit*******ir******1r********-k-k***-k***-k*1r***ic*****irir1r***** 

* 

* PANSAT Hardware Configuration 

* 

*★*************************★*****************+******♦*******************/ 


/* bw__cfg_stract holds software configuration information regarding 

* hardware systems which is to be recorded to the mass storage unit and 

* available for downloading along with recorded hardware sensors, 

*/ 

typedef struct hw_cfg 

{ 

unsigned char epscfg[3]; /* Ports 0, 2, and 6 */ 

unsigned char pmaxcfg[19]; /* Paramax regsiters + h/w status */ 

unsigned char rfcfg; /* rf configuration */ 

} hw_cfg_struct; 


/* Indexing into pmaxcfg[] */ 


PM_AGC_STATUS1 

0 

/* 

AGC Status */ 

PM_IPFI_H 


1 

/* 

I Prefilter High Byte */ 

PM_IPFI_L 


2 

/* 

I Prefilter Low Byte */ 

PM_QPPI_H 


1 

/* 

Q Prefilter High Byte */ 

PM_QPFI_L 


4 

/* 

Q Prefilter Low Byte */ 

PM_TM_CMD_ 

_0 

5 

/* 

Time 32 bit frequency command (LSB) */ 

PM_TM_CMD~ 


6 

/* 

Time 32 bit frequency command */ 

PM_TM_CMD~ 

_2 

7 

/* 

Time 32 bit frequency command */ 

PM_TM_CMD_ 

_3 

B 

/* 

Time 32 bit frequency command (MSB) */ 

PM_PH_CMD_ 

[o 

9 

/* 

Phase 32 bit frequency command (LSB) */ 

pm_ph_cmd' 


10 

/* 

Phase 32 bit frequency command */ 

PM_PH_CMD_ 

_2 

11 

/* 

Phase 32 bit frequency command */ 

PM_PH_CMD_ 

3 

12 

/* 

Phase 32 bit frequency command (MSB) */ 

PM_PNCA_L 


13 

/* 

PN Correlation Detector Accumulator (LSB) */ 

PM_PNCA_H 


14 

/* 

PN Correlation Detector Accumulator (MSB) */ 

PM_PNCS_L 


15 

/* 

PN Correlation Detector Slip Counter (LSB) */ 

PM_PNCS_H 


16 

/* 

PN Correlation Detector Slip Counter (MSB) */ 

PM_PNG 


17 

/* 

PN Generator Status */ 

PM_HW 


18 

/* 

Paramax hardware interface register */ 


/* Indexing into epscfgp[] */ 
#define EPS_PORTO 0 

#define EPS_PORT2 1 

#define EPS_PORT6 2 


/****************'k***-k***ir****it******1fk**1r-k*****1i*ir*****1r*ii****-tr1r*******it* 

* 

* PANSAT Software Sensors/Configuration/Statistics 

* 

************************************************************************/ 

/* sw_cfg holds all software configuration information which reflects the current 
* state of the satellite. 

*/ 

typedef struct sw^info 

{ 


long 



tod; 

/* 

Current data: UTC since 1 Jan 1970 */ 

int 



ver; 


/* OS version */ 

unsigned 

long 

int 

passcount; 


/* Password counter */ 

unsigned 

long 

int 

suaccess; 


/* # of successful NPS accesses */ 

unsigned 

long 

int 

sufailed; 


/* # of failed NPS accesses */ 

unsigned 

long 

int 

softerr; 

/* 

EDAC: Soft Error count */ 

long 



serrtod; 

/* 

EDAC: Time of last soft error */ 

char far 



*serraddr; 


/* EDAC: Current RAM Wash address */ 


} sw_info_struct; 


278 



hw__c f g_s t rue t 


hw_cfg; 


* 

* Complete Pansat Telemetry (hardware and software) 

* 


/* For current (most recent, not stored to the mass storage unit) telemetry. */ 
typedef struct tlm_recent 
{ 

sensors_struct sensors; 
sw_info_struct sw_info; 


DWORD etime; /* elapsed operating time */ 

DWORD tod; /* time/date */ 

} tlm_recent_struct; 


/* For stored telemetry (in mass storage unit). 

* 

* The data stream containing stored telemetry is a series of these structures 

* of which the size is given before the data download begins. 

*/ 

typedef struct tlm_record 

{ 

sensors_struct sensors; 



bcm__info_struct 

bem; 


DWORD 

etime; 


DWORD 

tod; 

/* 

Jah */ 


/* 

hw_cfg_struet 

hw_cfg 


WORD 

crc; 


} tlm_reco rd_s t rue t; 


/* elapsed operating time */ 
/* time/date */ 

*/ 


#ifdef TLM 

/* Defines for conversion routines */ 

#define THERM_LOW -31 
tdefine THERM_HIGH 88 

#define THERM_TAB_SIZE ( (THERM_HIGH - {THERM_LOW) ) + 1) 

void convert_ad (void) ; 
int cnv_therm(WORD n); 

#endif 


#ifndef TLM 

extern void convert_ad(void); 
extern int cnv_therm(WORD n); 

extern void check_tlra(void); 

extern cnv_sensors_struct tlm_cnv; 

/* Storage for the most recent TLM gathering from the A/D. These are 
* raw data points. 

*/ 

extern tlm_recent_struct tlm; 

/* Define storage for the data to be recorded to the mass storage units. 
*/ 

extern tlm_record_struct tlm_record; 

#endif 


279 





* TLM.C 

* 

* Petite Amateur Navy Satellite (PANSAT). 

* Embedded ROM software. 

* Copyright (c) 1996 Space Systems Academic Group, Naval Postgradate School. 

* Jim A. Horning (Jah) 

* 

* Revision History: 

* ================= 

* who when what 

* - + - + - 

* Jah 30 April 96 Creation 

* 

************************************************************************/ 


#include "gen_defs.h" 

#include "bcm.h" 

#define TLM 

#include “tlm.h” 
#undef TLM 

#include "ad.h" 
#include "clock.h” 
#include "pcb.h” 


/* Define storage for the most recent TLM gathering from the A/D. These are 
* raw data points. 

*/ 

tlm_recent_structtlm; 

/* Define storage for the data to be recorded to the mass storage units. 

*/ 

tlm_record_structtlm_record; 

/* Define storage for converted tlm values for decision making. 

*/ 

cnv__sensors_struct tlm_cnv; 

/* Starting addresses to begin recording telemetry records to Flash */ 
static DWORD msaf_tlm_ptr = 0; 
static DWORD msbf_tlm__ptr = 0; 


/* Conversion factors for telemetry sensors into cnv_sensors */ 
/* Thermistors: This table begins for the temperature beginning 

* at -31 C, and working up per degree C. The table is used 

* in a binary search. Table entries are used as follows: 

* If the A/D value is 4000, then the temperature considered 

* to be -30C, because it is less than the first entry in the 

* table, 4191, which corresponds to -31C. 

*/ 

static const int cnv_therm_tab[THERM_TAB_SIZE] = 

{ 

/* -31 -> -22 */ 


4191, 

3949, 

3723, 3512, 3313, 

3127, 

2952, 

2788, 

2634, 

2490 

/* -21 - 

> -12 

*/ 







2354, 

2226, 

2106 

, 1993, 1887, 

1787, 

1693, 

1604, 

1520, 

1442 

/* -11 - 

> -2 * 

/ 







1368, 

1298, 

1231 

, 1169, 1110, 

1055, 

1002, 

953, 906, 

862, 


/* -1 

-> 8 

*/ 







820,780, 

743, 707, 673, 

642, 611, 583, 556, 530, 






/* 9 -> 

18 * 

/ 







506,482, 

461,440,420, 

401, 383, 366, 350, 335, 






/* 19 - 

> 28 

*/ 







320, 306, 

293, 281, 269, 

257, 246, 236, 226, 217, 






/* 29 - 

> 38 

V 







208,199, 

191, 183, 176, 

169, 162, 156, 150, 144, 






/* 39 - 

> 48 

*/ 







138, 133, 

127, 123, 118, 

113, 109, 105, 101, 97, 






/* 49 - 

> 58 

*/ 







94, 

90, 

87, 

84, 81, 

78, 

75, 

72, 

70, 

67, 

/* 59 - 

> 68 

*/ 







65, 

62, 

60, 

58, 56, 

54, 

52, 

51, 

49, 

47, 

/* 69 - 

> 78 

*/ 







46, 

44, 

43, 

41, 40, 

38, 

37, 

36, 

35, 

34, 

/* 79 ' 

-> 88 

*/ 







33, 

32, 

31, 

30, 29, 

28, 

27, 

26, 

25, 

24 


280 






}; 


/* Voltages */ 
static const double 
{ 

{l.0*AD_RES, 

4.76191*AD_RES, 
{l.0*AD_RES, 

4.76191*AD_RES, 

}; 


cnv_vbatts [BCM_NUM_BATS] [BCM_NUM_CELLS] = 


1.0*AD_RES, 

4.76191*AD_RES, 
1.0*AD_RES, 

4.76191*AD_RES, 


1.90476*AD_RES, 
4.76191*AD_RES, 
1.90476*AD_RES, 
4.76191*AD_RES, 


1.90476*M)_RES, 
4.76191*AD_RES) 
1.90476*AD_RES, 
4.76191*AD_RES} 


1.90476*AD_RES, 
1.90476*AD_RES, 


#define CNV VSC 


(3.41*AD_RES) 


/* Currents */ 
#define CNV_IBATTS 
#define CNV_ISC 
#define CNV ISP 


(2.0*AD_RES) 

{2.0*AD_RES) 

{2.0*AD_RES) 


/*******************************★**************************★***★*******★★***** 

* 

* void convert_ad() 

* 

* Take all A/D raw values stored in the telemetry structure, .sensors 

* substructure, and convert it to floating point values that are in the 

* correct units for higher-level control routines. 

* 

**■*■*****************************★**********★★**********♦********************/ 


void convert_ad (void) 

{ 

register int i; 

double vbatta[NUM_BAT_CELLS]; 
double vbattb[NUM_BAT_CELLS]; 
double ia, ib, isc; 


/* Convert Thermistors */ 
for (i = 0; i < NUM_TS; i++) 

tlm_cnv,ts[i] = cnv_therm(tlm.sensors.tsti]); 


/* Convert Temperature Sensors */ 
for (i = 0; i < NUM_TM; i++} 

tlm_cnv.tmp [i] = (tlm.sensors.tmp[i]*AD_RES - 0.5)*100.0; 


/* Convert Voltages: Battery A, Battery B, and SC Bus */ 

/* These are accumulated cell voltages. Individual converted 

* accumulated values are not necessary to keep, only to use 

* to obtain the individual cell voltages. 

*/ 

for (i = 0; i < NUM_BAT_CELLS/ i++) 

{ 

vbatta[i] « t Irr . sensors .vbatta [i] * cnv_vbatts [0] [i] ; 
vbattb[il ■ tlm.sensors.vbattb[i] * cnv_vbatts[1] [i] ; 

} 

tlm_cnv.vbatta - vbatta (TOP_CELL] ;/* Battery Total Voltage is same as top cell voltage */ 
tlm_cnv.vbattb - vbattb(TOP_CELL]; 

/* These are individual cell voltages */ 
tlm_cnv.vcellBaIC) • vbatta[0]; 
tlm_cnv.vcell£b !CJ . vbattb[0); 
for (i = 1; I c NUV BAT CELLS; i++) 

{ 

tlm_cnv.vce11sa! 1 ! • vbatta [i) - vbatta[i-l]; 
tlm_cnv .vcelIst! 1 ; - vbattb [i] - vbattb[i-1]; 

tlm_cnv.vcellsa a\^ tlm_cnv.vcellsa[i]/ 
tlm_cnv.vce11 si avg ♦- tlm_cnv.vcellsbli]; 

} 

tlm_cnv.vcellsa av'n /- NUM_BAT_CELLS; 
tlm_cnv.vce116b_ avg /« NUM_BAT_CELLS; 

/* The spacecraft voltage ♦/ 

tlm_cnv.vscbus - tlm.sensors.vscbus * CNV_VSC; 


/* Convert Currents: Battery A, Battery B, SC Bus */ 

for (ia = ib « isc =0.0, i=0; i< CURRENTS^SAMPLED; i++) 

{ 

if (tlm.sensors.ibatta[i] & 0x8000) 

ia += -1.0*(((tlm.sensors.ibatta [i] & OxOFFF)*CNV_IBATTS) - 5.0); 

else 


281 


ia += (tlm. sensors, ibatta [i] & OxOFFF) *CNV_IBATTS - 5.0; 

if (tlm.sensors.ibattb[i] & 0x8000) 

ib += -1.0* (( (tlm. sensors . ibattb [i] & OxOFFF) *CNV_IBATTS) - 5.0); 

else 

ib += (tlm. sensors, ibattb [i] & OxOFFF) *CNV_IBATTS - 5.0; 
isc += (tlm.sensors.iscbus[i] * CNV ISC) - 5.0; 

} 

tlm_cnv,ibatta = ia/CURRENTS_SAMPLED; 
tlm_cnv.ibattb = ib/CURRENTS_SAMPLED; 
tlm_cnv. iscbus = isc/CtJRRENTS_SAMPLED; 

/* Call Battery Charge Monitory V,I, and Temperature data updater. */ 

/* Jah */ 

/* bcm_tlm_update0; */ 

} /* End of convert_ad() */ 


/***********ic**-k****ie-ki[****ifk****-k**********ir**ic**1e**1t**********-k*-kic******1t*** 

* 

* signed char cnv_therm() 

* 

* Convert A/D value for thermistor reading into a temperature (Celcius) 

* using table look up for approximation. A binary search is used to 

* speed up the look up process. 

* 

*★*************♦*★******★********************♦***♦**************************/ 


int cnv_therm(unsigned int sample) 

{ 

register int raid, start, end; 


start = 0; 

end = THERM_TAB_SIZE-1; 

/* First see if the sample is less than the smallest table 

* value. If so, this corresponds to a temperature greater 

* than that corresponding temperature. 

*/ 

if (sample < cnv_therm__tab [THERM__TAB_SIZE-1] ) 
return(THERM_HIGH + 1); 

/* Otherwise, the lookup will return the closet temperature, 

* including a temperature below the lowest in the table. 

*/ 

while ((end - start) > 1) 

{ 

mid = (end + start)/2; 

if (sample == cnv_therm_tab[mid] ) 
break; 

else if (sample < cnv_therm_tab[mid] } 
start = mid; 

else 

end = mid; 

) 

if ((end - start) > 1) 

return (THERM__LOW + mid) ; 


else 


if ((cnv_therra_tab(start] - sample) <= (sample - cnv_therm_tab [end] )) 
return(THERM_LOW + start); 

else 

return(THERM_LOW + end); 


} /* End of cnv_therm() */ 

/*********1r*ir************-lc*it1ftr****ifirt,******ifk*****1t*1r*1t1t****i,******ii-kic**ic*-k*** 

* 

* void Check_tIm 0 

* 

* Check to see if the A/D acquisition has completed another sensor sweep, 

* and if so convert the sensor data into a recent tlm record. In addition, 

* check to see if it is time to store the record to mass storage (Flash) , 

* 

****************<r**********************************^*********************^**^ 

282 


void check_tlm (void) 

{ 

static DWORD t= OL; 


ad_check{); 


if {samples_ready) 

{ 

ad_collect(); 
convert_ad(); 

memcpy(&tlm_record.sensors, itlrn.sensors, sizeof(sensors_struct)) 

tlm.etime = get_elapsed_time{); 
tlm.tod = get_tinie(); 
tlm_record.etime = tlm.etime; 
tlm_record.tod = tlm.tod; 

bcm__info{&;tlm_record.bcm) ; 

if {(get_elapsed_time{) - t) > TLM_RECORD_TIME) 
msu_save_tlm(tlm_record); 


} /* End of check_tlm() */ 


End of tim.h, tim.c 


283 


284 


APPENDIX K. TEST PLANS 


This appendix contains the System Controller tests that were followed while evaluating the hardware and 

software. 

Board Stuffing Tests (SC Hardware) 

• Check distirbution of PCB logic power when board powered off. 

• Check output voltage of DC-DC converter for regulated board power. 

• Verfiy power on sensing circuitry. 

• Check bus isolation buffers (54HC125). 

• Verify clock from crystal oscillator. 

• Check microprocessor Reset circuit. 

• Verify microprocessor CLKOUT. 

• Check power and groxmd to all ICs. 

• Record current sinked to board. 

• Verify CLKIN to all clocked ICs. 

• Verify connectors. 

• Verify signal filters to A/D inputs (RC-diode circuit). 

Circuit Evaluation (SC Hardware and Software Device Drivers) 

• Attach in-circuit emulation system. 

• Perform and verify microprocessor Reset and microprocessor initialization. 

• Test asynchronous mode of the SCC (use RS-232 terminal on other end). 

• Check data and address buffers. 

• Verify external interrupts are acknowledged by microprocessor. 


285 



• Test memory and chip selects for ROM, EDAC, and peripherals. 

• Enable and verify EDAC via tests written for Oechsel [Ref. 21]. Include new test for EDAC reset and 

modified write back. 

• Check power switching to Modem board (using the TPS2013). 

• Test manual mode of the 82C55. 

• Verify PCS write and read. 

• Test manual mode of the LM12H458. 

• Test conversion of IC temperature probe (LM50) into A/D. 

• Enable SCC port A synchronous and check for Flag detection and creation. 

Further Device Driver Tests (SC hardware and software) 

• Verify Startup code: CPU init, peripheral init, memory check and clear, stack setup, floating point 

emulation init, passing control to main(). 

• Test clock generator. 

• Test interrupt receive and acknowledge for multiple ISR operation. 

• Check EDAC RAM wash chained into the clock generator. 

• Verify SCC port B asynchronous modes (9.8, 19.2, and 38.4 kbits/sec). 

• Check packet passing into Modem interface using SCC port B. 

• Check terminal emulation and high-level print out display. 

• Test STPI high-level command interface. 

• Check PCB read and write routines (both non-interruptable and re-entrant routines). 

• Test EPS control. 

• Test TMUX channel select capability. 

• Test A/D ISR for data acquisition. 

• Test A/D data conversions. 


286 



• Verify Mass Storage SRAM and Flash read and write operations. 

High-Level Software Tests (SC software) 

• Check detection of STPI during bootup. 

• Check telemetry saving and retrieving to and from the Mass Storage. 

• Check Mass Storage Flash for recorded telemetry to allow for state preservation with system operations. 

• Verify Battery Charge Monitor: ported from Lab VIEW system. Single battery only (A, then B), dual 

batteiy (A and B), full charge, charge with solar simulation, maintaining battery charges, battery 
discharges, environmental tests, autonomous control for long periods (1 day, 3 day, 1 week). 

• Check CRC generation and verification for saved telemetry to Mass Storage. 

• Test RF control. 

• Check software upload and transfer of control routines (allows new software to be loaded, including 

SCOS). 

• Test interface for commands sent through the RF interface. 

• Check stored telemetry download and erase. 

• Verify scenario checking routines for anomolies. 


287 





LIST OF REFERENCES 


1 “PANSAT Functional Requirements,” SSD-S-SY-000, Space Systems Academic Group, Naval 
Postgraduate School, date Draft. 

2 Johnson Space Center, NASA FAX, Subject: Space Shuttle Altitudes and Inclinations, April 1994. 

3 Davinic, Nicholas M., “Evaluation Of The Thermal Control System Of The Petite Amateur Navy 
Satellite (PANSAT),” Master’s Thesis, Naval Postgraduate School, Monterey, CA, September 
1995. 

4 Messenger, G.C. and Ash, M.S,, The Effects of Radiation on Electronics Systems, Van Nostrand 
Reinhold, New York, NY, 1991. 

5 Adams, Leonard, et al., “Proton Induced Upsets in the Low Altitude Polar Orbit, ” IEEE 
Transactions on Nuclear Science, Vol. 36, No. 6, pp. 2339 - 2343, 1989. 

6 Shimano, Y. T., et al., “The Measurement and Prediction of Proton Upset,” IEEE Transactions on 
Nuclear Science, Vol. 36, No. 6, pp. 2344 - 2348, 1989. 

7 “Space Product News, Special Edition, Integrated Circuits For The Space Environment,” Harris 
Semiconductor BR-035, Harris Semiconductor, September 1993. 

8 Kemigan, B. W., Ritchie, D. M., The C Programming Language, Prentice-Hall, Englewood 
Cliffs, N.J., 1978. 

9 Harbison, S.P., Steele, G. L., C A Reference Manual, Prentice-Hall, Englewood Cliffs, N.J., 1991. 

10 CMOS Logic Selection Guide, Harris Semiconductor, Melbourne, FL, 1994. 

11 Embedded Microcontrollers And Processors Volume II, Order Number 270645, Intel Corporation, 
Mount Prospect, IL, 1992. 

12 80C186/C188 80C186XL/C188XL Users Manual, Order Number 272164-001, Intel Corporation, 
Mount Prospect, IL, 1992. 

13 “Embedded Intel 186 Microprocessor Family Frequently Asked Questions”, 
http://developer.intel.com/design/faq/186faqs.htm, Intel Corporation, 1996. 

14 “ICL8211, ICL8212 Programmable Voltage Detectors,” Harris Semiconductor, AnswerFax Data 
Sheet 3184.1, 1992. 

15 “Maxim 5V, Step-Down, Current-Mode PWM DC-DC Converters,” Maxim 1995 New Release 
Data Book, Volume IV, Maxim Integrated Products, 1995. 

16 “82C55A CMOS Programmable Peripheral Interface,” Harris Semiconductor AnswerFax 2969, 
Harris Semiconductor, 1992. 

17 “PA-100 Spread Spectrum Demodulator ASIC, Technical Data Sheet and User’s Guide Rev.O,” 
Paramax, Salt Lake City, UT, 1993. 

18 “TPS 2010/TPS 2012/TPS 2013 Power Distribution Switches,” Texas Instruments Data Sheet 
SLV097, Texas Instruments, 1994. 

19 “M27C256 256k (32k x 8) CHMOS UV Erasable PROM,” Intel Corporation Data Sheet 271008- 
067, 1992. 

20 Dataman S4 User Manual, Dataman Programmers Ltd., Orlando, FL. 


289 



21 Oechsel, C. R, “Implementation Of Error Detection And Correction (EDAC) In The Static 
Random Access Memory (SRAM) Aboard Petite Amateur Navy Satellite (PANSAT),” Master’s 
Thesis, Naval Postgraduate School, Monterey, CA, 1995. 

22 “ASC630MS Radiation Hardened EDAC,” Harris Semiconductor AnswerFax 2100, Harris 
Semiconductor, 1992, 

23 “256k X 8 CMOS SRAM MSM8256-25/35/45/55,” Mosaic Semiconductor Data Sheet Issue 2.2, 
Mosaic Semiconductor, 1993. 

24 “LM12454/LM12H454/LM12458/LM12H458 12-Bit + Sign Data Acquisition System With Self- 
Calibration,” National Semiconductor Data Sheet, National Semiconductor, 1995. 

25 “LM12458 12-Bit Plus Sign Data Acquisition System with Self-Calibration”, 
htq)://www.nsc.com/pC'LM/LM12458.html, National Semiconductor, 1996. 

26 “DG411, DG412, DG413 Monolithic Quad SPST CMOS Analog Switches,” Harris 
Semiconductor AnswerFax Data Sheet 5282.1, Harris Semiconductor, 1993. 

27 “LM50B/LM50C SOT-23 Single-Supply Centrigrade Temperature Sensor,” National 
Semiconductor Data Sheet, National Semiconductor, 1995. 

28 Am8530H/Am85C30 Serial Communication Controller Technical Manual, Advanced Micro 
Devices, Sunnyvale, CA, 1992. 

29 “Maxim + 15 kV, ESD-Protected, +5V RS-232 Transceivers,” Maxim 1995 New Release Data 
Book, Volume IV, Maxim Integrated Products, 1995. 

30 Amateur Radio Relay League, AX.25 Amateur Packet-Radio Link-Layer Protocol (Version 2.0), 
Washington D.C., 1984. 

31 Price, H. E., SCOS Reference Manual, BekTek Corporation, Bethel Park, PA, 1992. 

32 Price, H. E., AX-25 Reference Manual, BekTek Corporation, Bethel Park, PA, 1992. 

33 Price, H. E., Ward, J., “PACSAT Protocol Suite,” Proceedings Of The ARRL 9th Computer 
Network Conference, ARRL, Newington, CT, 1990. 

34 Writing ROMable Code in Microsoft C, Systems And Software, Inc., Irvine, CA, 1990. 

35 Link AndLocate++, Systems And Software, Inc., Irvine, CA, 1990. 

36 Lahti, C. A., “The Design Of The Radio Frequency (RF) Subsystem Printed Circuit Boards For 
The Petite Amateur Navy Satellite (PANSAT),’’ Master’s Thesis, Naval Postgraduate School, 
Monterey, CA, 1996. 

37 Homing, J., and Sheltry, J, “An Analog-to-Digital Acquisition System for PANSAT,”, Space 
Systems Academic Group, 1993. 

38 The Temperature Handbook, Volume 28, Omega Engineering, Stamford, CT, 1992. 

39 Flash Memory Products, Advanced Micro Devices, Sunnyvale, CA, 1994. 

40 McNamara, J. E., Technical Aspects Of Data Communications, Digital Press, Bedford, MA, 1982. 

41 Strewinsky, F. H., “PANSAT Prototype Battery Test And Test Results,” Research Report, Naval 
Postgraduate School, Monterey, CA, 1996. 


290 



INITIAL DISTRIBUTION LIST 

1. Defense Technical Information Center.2 

8725 John J. Kingman Rd., Ste 0944 

Ft. Belvoir, VA 22060-6218 

2. Dudley Knox Library.2 

Naval Postgraduate School 

411 Dyer Rd. 

Monterey, California 93943-5101 

3. Department Chairman, Code EC.1 

Department of Electrical and Computer Engineering 

Naval Postgraduate School 
Monterey, CA 93943-5121 

4. Department Chairman, Code SP.1 

Space Systems Academic Group 

Naval Postgraduate School 
Monterey, CA 93943-5110 

5. Dr. Rudolf Panholzer, Code Sp/Pz.1 

Space Systems Academic Group 

Naval Postgraduate School 
Monterey, CA 93943-5110 

6. Randy L. Wight, Code Sp/Wt.1 

Space Systems Academic Group 

Naval Postgraduate School 
Monterey, CA 93943-5110 

7. PANSAT Project Team, Code Sp.2 

Space Systems Academic Group 

Naval Postgraduate School 
Monterey, CA 93943-5110 

8 Mr. and Mrs. Tony Homing.1 

25380 Vista del Pinos 
Carmel, California 93923 

9. Mr. James A. Homing, Code Sp/Jh.2 

Space Systems Academic Group 
Naval Postgraduate School 
Monterey, CA 93943-5110 


291 











