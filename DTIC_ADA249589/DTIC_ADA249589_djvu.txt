ad jJZ 49 589 


cNTATION PAGE 


FomApprmtd 
OPm No. 0704^188 


>ig»ili>u«*BMttMi»cnnnBfpt«tBli>li€olwlQiifll W e iiM l ln n, »Klu<n 9 WBBWlDWh»wd u e> ^ til i bi»dw.i>WMWn^ 
121SJillMwnDtiil il |g> » Hf,>ai1»«.Ailngwi.V*22ace-4aw»idlBti»aHe»fllWD W Mlo m BdRig u lBaiY<Wrt».0«Bicl 




1^^ 


Rnal: 30 Nov 1990 to 01 Jun 1993 


Validation Summary Resort: Concurrent Computer Corporation. C3 Ada Version 
1.1V, Concurrent Computer Corporation 6650 with Super Lightning Floating pcM 
under RTU Version S.OC (Host & Target), 901130W1.1107 




Wright-Patterson AFB, Dayton, OH 
USA 




ffTliiTMM:!' 


lON/AV 





I iW::g:T?»Tr^TTr«T«:r<CTTOr» 


Ada Validation Facility, Language Control Facility ASD/SCEL 

Bldg. 676, Rm 135 

Wright-Patterson AFB. Dayton, OH 45433 ^ 

REPORT NUMBER 

AVF-VSR-414.0891 

i. iM)N^INQA/l6NlTohlNQ AGENCY NAME(S) AND AODRESS<ES) 

* 

Ada Joint Program Office 

United States Department of Defense 

Pentagon, Rm 3E114 

Washington, D.C. 20301-3081 

10. SPONSORINGA«ONITORING AGENCY 
REPORT NUMBER 



Approved for public release; distribution unlimited. 


(Maximum 200 moms) 

Concurrent Computer Corporation, C3 Ada Version l.lv, Wright-Patterson. AFB, Concurrent Computer Corporation 6650 
with Super Lightning Floating point under RTU Version 5.0C (Host & Target), ACVC 1.11. 



92-11778 


92 4 29 074 




Ada programming ianguage, Ada CompMer Val. Summary Report. Ada Compfler Val. 
Capability, Val Testing. Ada Val. Office. Ada Val. Facility, ANSI/MIL-STO-181SA, AJPO. 




OF REPORT 
UNCLASSIFIED 


N8N7S4<M)1-2ao-S80 


UNCLASSIFED 


OF ABSTRACT 
UNCLASSIFIED 



Swndwd Form 296, (Riv. 249) 
PlMCtWwt by ANSI SMI. 239-126 












AVF Control Nundaer: AVF-VSR-414.0891 

1 August 1991 
90-10-08-CCC 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 901130W1.1107 
Concurrent Coopjter Corporation 
C3 Ada Version l.lv 
Concurrent Coqputer Corporation 6650 
with Super Lightning Floating Point 
under RTU Version 5.0C 
(self-targeted) 


Prepared By: 

Ada Validation Facility 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 




Ac* 

NT" 

rfiC fAB 

'Jtw.iac.vi«a4 
Juii t i f ion 


' ty—,___ 

'_Dl9trlb»tion/ 

:_AvailablliAr Co 4 o 6 

jA*oH aod/or 
Dl 3 t j Speolal 

i«V-\ 








Certificate Information 


Hie following Ada inplementation was tested and determined to pass ACVC 
1.11. Testing was coiopleted on 30 November 1990. 

Compiler Name and Version: C3 Ada Version l.lv 

Host Ccmoputer System: Concurrent Conputer Corporation 6650 

with Super Lightning Floating Point 
under R7U Version 5.0C 

Target Ccoputer System: Concurrent Conputer Corporation 6650 

with Super Li^tning Floating Point 
under RTU Version 5.0C 

Custcmier Agreement Number: 90-10-08-CCC 


See Section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 901130W1.1107 
is awarded to Concurrent Conputer Corporation. This certificate expires on 
1 March 1993. 

This report has been reviewed and is approved. 


Validaticxi Facility 
Steven P. Wilson 
Technical Director 
ASD/SCEL 

Wri^^t-Patterson AFB OH 




45433-6503 


Ada VaUcUjfWoA'Organization 

Director, TTanputer & Software Engineering Division 
Institute fOT Defense Analyses 
Alexandria VA 22311 



Ka Joint Program Office 
Dr. John Soloroond, Director 
Department of Defense 
Washington DC 2C301 












DECLARATION OF CONFORMANCE 


Customer: Concurrent Computer Corporation 

Ada Validation Faeilitjr: Wright Patterson Air Force Base, Ohio. 
ACVC Version: 1.11 


Ada Implementation: 

Compiler Name and Version: C ^Ada Version: 1.1t 

Host Computer System: Concurrent Computer Corporation 6650 

with Super Lightning Floating point under RTU Version 5.0C 

Target Computer System: ; ■' Same as Host 


Customer’s Declaration 

I, the undersigned, representing Concurrent Computer Corporation, declare that Concurrent 
Computer Corporation has no knowledge of deliberate devianons from the Ada Language 
Standard ANSI/MIL-STD-ISISA in the implementation listed in this declaration. I declare that 
Concurrent Computer Corporation is the Implementor of the above implementation and the 
eertificates shall be awarded in the name of Coaeuirent Computer Corporation’s corporate 
name. 

nM‘h 

Seetharama Shastry (date) 

Senior Manager, System Software Development 





TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 


1.1 USE OF THIS VALIDATION SUMMARY REPORT . 

1.1 REFERENCES . 

1.3 ACVC TEST CLASSES . 

1.4 DEFINITION OP TERMS . 


1-1 

1-2 

1-2 

1-3 


CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS . 

2.2 INAPPLICABLE TESTS 

2.3 TEST MODIFICATIONS 


2-1 

2-1 

2-4 


CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT . 

si2 SUMMARY OF TEST RESULTS 

3.3 TEST EXECUTION .... 


3-1 

3-1 

3-2 


appendix a macro PARAMETERS 

appendix B compilation SYSTEM OPTIONS 

appendix C APPENDIX P OF THE Ada STANDARD 











CHAPTER 1 


INTRODUCnCN 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro901 against the Ada Standard [Ada83] xising the 
current Ada Cc^iler Vali^tion Capability (ACVC). This Validation Summary 
Report (VSR) gives an account of the testing of this Ada isplementation. 

For any technical terms used in this report, the reader is referred to 
[Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide IUG89]. 


1.1 USE OF THIS VALIDATION SIOWARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the united States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the conqputers, operating systems, and compiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and candlete, or that the subject isplementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 


Questions regarding this report or the validation test results should be 
directed to the AVF \diich performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 




INTROKJCnCN 


1.2 REFERENCES 


lAda83] Reference Haniial for the Ada Prograniming Lan^age, 

ANSI/MiL-STD-lfilSA, FiEruary ld85 and IK) 665i-l587. 

[Pro90] Ada Compiler validation Procedures . Version 2.1, Ada Joint Program 
office, August 1990. 

[UG89] Ada Conpiler Validation Capability User's Guide , 21 June 1989. 


1.3 ACVC TEST CLASSES 

Con^liance of Ada iaplementations is tested by means of the ACVC. Ihe ACVC 
contains a collection of test programs structured into six test classes: 

A, B, C, D, E, and L. Ihe first letter of a test name identifies the class 
to \diich it belongs. Class A, C, D, and E tests are executable. Class B 
and class L tests are expected to produce errors at conpile time and link 
time, respectively. 

The executable tests are written in a self-checking maiuier and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result vdien they 
are executed. Three Ada library \jnits, the ^ckages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat some compiler 
qptimizations allowed the Ai^ Standard that would circumvent a test 
Objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK FILE is used to check the contents of 
text files written by some of the ^lass C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a coopiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the coopiler. This behavior is 
also verified. 

Class L tests check that an Ada iopleroentation correctly detects violation 
of the Ada Standard involving multiple, separately compiled imits. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
inplementation-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 


1-2 







INTRODOCTION 


For each Ada implementation, a custcmiized test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragraph, removing withdravm tests (see section 2.1) and, 
possibly some inapplicable tests (see Section 2.2 and [UG89]). 

In order to pass an ACVC an Ada ioplementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITIGM OF TERNS 


Ada Coopiler The software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Ccmpiler The means for testing coopliance of Ada implementations. 
Validation consisting of the test suite, the support programs, the ACVC 
Capability user's guide and the tenplate for the validation sutnoary 

(ACVC) report. 

Ada An Ada conpiler with its host cooputer system and its 

loplementation target computer system. 

Ada Joint The part of the certification body vduch provides policy and 
Program guidmce for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification boc^ which carries out the 

Validation procedures required to establish the compliance of an Ada 
Facility (AVF) isplementation. 

Ada The part of the certification body that provides technical 

Validation guidiuice for operations of the Ada certification system. 

Organization 
(AVO) 

Compliance of The ability of the implementation to pass an ACVC versim. 
an Ada 

Implementation 

A functional unit, consisting of one or more computers and 
associated software, that uses common storage for all or 
part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


Computer 

System 


1-3 








iMTimjcncN 


Conformity Fulfillment a product, process or service of all 

requirements specified. 

Customer An individual or corporate entity vAio enters into an 

agreement with an AVF v^ich specifies the terms and 
conditions for A’T services (of any kind) to be performed. 

Declaration of A formal statement fron a customer assuring that conformity 
Conformance is realized or attainable on the Ada implementation for 
vrtiich validation statxjs is realized. 

Host Ccmputer A ccmputer system where Ada source programs are transformed 
System into executable form. 

Inapplicable A test that contains one or more test objectives found to be 
test irrelevant for the given Ada inplementation. 

ISO International Organization for Standardization. 

LRH Ihe Ada standard, or Language Reference Manual, published as 

ANSI/MlL-STO-lSlSA-lSeS and ISO 8652-1987. Citations from 
the LRM take the form "<section>.<subsection>:<paragraph>.” 

Operating Software that controls the execution of pr^rams and that 
System provides services such as resource allocation, scheduling, 

input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
complete hardware implementations are possible. 

Target A computer system \diere the executable form of Ada programs 

Computer are executed. 

System 

Validated Ada The compiler of a validated Ada implemientation. 

Compiler 

Validated Ada An Ada inplementation that has been validated successfully 
Implementation either ty AVF testing or by registration [Pro90). 

Validation The process of checking the conformity of an Ada compiler to 
the Ada prograsoming language and of issuing a certificate 
for this i^lementation. 

Withdrawn A test found to be incorrect and not used in conforndty 
test testing. A test may be incorrect because it has an invalid 

test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 







C31APTER 2 


IKPLEKEinATIGN 0EPENDE2«:iES 


2.1 WIIHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 12 October 1990. 

E28005C B28006C C34006D B41308B C43004A C45114A 
C45346A C45612B C45651A C46022A B4900aA A74006A 
C74308A Be3022B B83022H B83025B B83025D B83026B 
B85001L C83026A C83041A C97116A C98003B BA2011A 
CB7001A CB7001B CB7004A cn223A Ba226A CX:1226B 
BC3009B BD1B02B BD1B06A AD1B08A BD2A02A CD2A21E 
CD2A23E CD2A32A a)2A4lA CD2A41B CZ>2A87A CD2B15C 
BD3006A BD4008A a)4022A CD4022D C3>4024B CD4024C 
C3)4024D a)403lA 0)40510 a)511lA CD7004C ED7005D 
CD7005E AD7006A a)7006E AD7201A AD7201E 0)72048 
BD8002A BD8004C 0)9005A OWOOSB O)A20lE CE2107I 
CE2117A CE2117B CE2119B CE2205B CE2405A CE3111C 
CE3118A CE3411B CE3412B CE3607B CE3607C CE3607D 
CE3812A CE3814A CE3902B 


2.2 INAPPLICABLE TESV3 

A test is inapplicable if it contains test objectives >Aiich are irrelevant 
for a given Ada inplementation. Reasons for a test's inapplicability may 
be supported by documents issued by ISO and the AJPO known as Ada 
Commentaries a^ consnonly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Coomentaries are inclixled as 
appropriate. 


2-1 






IMPLENOnATIQN M3>ENDENCIES 


The following 159 tests have floating-p^int type declarations requiring 
more digits than SYSTEM.NAX_DIGITS: 

C241130..Y (11 tests) C35705O.-Y (11 tests) 

C35706O..Y (11 tests) C35707O..y (11 tests) 

C357O0O..Y (11 tests) C35802O..Z (12 tests) 

C452410..Y (11 tests) C453210-.Y (11 tests) 

C454210..Y (11 tests) C455210..Z (12 tests) 

C455240..Z (12 tests) C456210..Z (12 tests) 

C456410..Y (11 tests) C46012O..Z (12 tests) 

The following 21 tests check for the predefined type I.ONG_INTEC^: 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45612C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001W 

C86006C 


CD7101F 

C35702A, C35713B, C45423B/ B86001T, and C86006H check for the predefined 
type SHORT_FLQAT. 

C35713D 2 uid B86001Z check for a predefined floating-point type with a 
name other than FLGAT, LGNG_FLCAT, or SHORT__FLCA.T. 

C41401A checks that CONSTRAINT ERROR is raised vqpon the evaluation of 
various attribute prefixes; this inplementation derives the attribute 
values from the sv&type of the prefix at compilation time, and thus does 
not evaluate the prefix or raise the exception. (See Section 2.3.) 

C45531M..P (4 tests) and C45532M..P (4 tests) check fixed-point 
(^rations for types that require a SYSTE7I.HAX_nANnsSA of 47 or 
greater. 

C45624A checks that the proper exception is raised if MACHINEjOVERFLOWS 
is FALSE for floating point types with digits 5. For this 
inplementation, HACHlNEjDVERFLQWS is TRUE. 

C45624B checks that the proper exception is raised if HACHINEJ[7VERFLCIWS 
is FALSE for floating point types with digits 6. For this 
implementation, MACHINEJQVERFLOWS is TRUE. 

C86001F recompiles package SYSTEM, making package TEXT_lO, and hence 
package REPORT, obsolete. For this implementation, the package TEXT_IO 
is dependent tpsn package SYSTEM. 

B86001Y checks for a predefined fixed-point type other than DURATZGN. 

C96005B checks for values of type DUR.'.TI0N'BASE that are outside the 
range of DURATIGN. There are no such values for this inplementation. 


2-2 








IMPLEHENTMIGN DEPENDENCIES 


CD1009C uses a representation clause specifying a non-default size for a 
floating-point type. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use representation 
clauses specifying non-defa\ilt sizes for access types. 

BD8001A, BD8003A, BD8004A..B (2 tests), and ADBOllA use machine code 
insertions. 

The tests listed in the following table are not a^licable because the 
given file operations are not supported for the given coiDbination of 
mode and file access method. 


Test 

File Operation Node 

File Access Hethod 

CE2102D 

CREATE 

IN FILE 

SEQUENTIAL 10 

CE2102E 

CREATE 

Otn* FILE 

sequential 10 

CE2102F 

CREATE 

INCXJT FILE 

DIRECT 10 

CE2102I 

CREATE 

IN FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

01^ FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INCUT FILE 

DIRECT 10 

CE2102S 

RESET 

inout"file 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

in'"file 

DIRECT 10 

CE2102V 

OPEN 

0U¥ FILE 

DIRECT 10 

CE2102W 

RESET 

OUT FILE 

DIRECT 10 

CE3102E 

CREATE 

in__file 

TEXT_IO 

CE3102F 

RESET 

Ary node 

TEXT_IO 

CE3102G 

DELETE 


TEXT_IO 

CE3102I 

CREATE 

OUT FILE 

TEXT_IO 

CE3102J 

OPEN 

IN FILE 

TEXT_IO 

CE3102K 

OPEN 

OOT FILE 

TEXT_IO 


CE2107C..D (2 tests), CE2107H, and CE2107L apply function NAME to 
temporary sequential, direct, and text files in an attempt to associate 
multiple internal files with the same external file; USEJEBPQR is raised 
because ten^rary files have no name. 

CE2108B, CE2108D, and CE3112B use the names of teiqporary sequential, 
direct, and text files that were created in other tests in order to 
check that the tenporary files are not accessible after the coopletion 
of those tests; for this inf>lementation, teiqx>rary files have no name. 

CE2203A checks that WRITE raises USE__EFBOR if the capacity of the 
external file is exceeded for SBQU12^IAL_I0. This ioplementation does 
not restrict file capacity. 


2-3 






IMPLEMENIATICN DEPENDENCIES 


EE2401D checks vdiether DIRECT_I0 can be instantiated for an element type 
that is an unconstrained array type; this isplementation raises 
USE_ERRQR on the attempt to create a file, because the maximum potential 
element size exceeds the implementation limit of 2**31 - 1 bits. 

CE2403A checks that NRITE raises USE_ERROR if the capacity of the 
external file is exceeded for DIRECT_ZO. This implementation does not 
restrict file capacity. 

CE3111B and CE3115A associate multiple internal text files with the same 
external file and attenpt to read from one file vdiat was written to the 
other, which is assumed to be immediately available; this implementation 
buffers output. (See section 2.3.) 

CE3202A expects that function NAME can be applied to the standard input 
and output files; in this implementation these files have no names, and 
USE_EFROR is raised. (See section 2.3.) 

CE3304A checks that USE__EBROR is raised if a call to SET LINE LENGTH or 
SET_PAGE LENGTH specifies a value that is inappropriate Tor tHe external 
file, ifiis inplementation does not have inappropriate values for either 
line length or page length. 

CE3413B checks that PAGE raises LAycxJr_ERROR when the value of the page 
number exceeds OOUNT'LAST. For this implementation, the value of 
COUNT'LAST is greater than 150000 making the checking of this objective 
impractical. 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 14 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the way 
expected by the original tests: 

B29001A BC2001D BC2001E BC3204B BC3205B BC3205D 

C34007P and C34007S were graded passed by Evaluation Modification as 
directed by the AVO. These tests include a check that the evaluation of 
the selector "all" raises OONSTRAINT_ERROR ’•hen the value of the object is 
null. This implementation determines the result of the equality tests at 
lines 207 and 223, respectively, based on the subtype of the object; thus, 
the selector is not evaluated ari no exception is raised, as allowed LRM 
11.6(7). The tests were graded passed given that their only output from 
Report.Failed was the message "NO EXCEPTXGN FOR NULL.ALL - 2". 

C35713D aixl B66001Z were processed incorrectly during validation testing: 
the AVF inadvertantly substituted "NO_SUCH_TYPE" for the macro FLOATJNAME 
instead of "LONG_LGNG_FLQAT", %hich is the name of a predefined floating- 


2-4 





IMPLQ1E2n3VTXON ISPEMDENCIES 


point type in this implementation. This mistake in processing was noticed 
after testing had completed, and the AW asked the customer to process the 
tests with the correct macro value; the customer complied with the request 
and provided the results of correct processing, which showed that the tests 
were passed instead of inapplicable. 

C41401A was graded inapplicable by Evaluation Modification as directed 
the AVD. This test checks that the evalioation of attribute prefixes that 
denote variables of an access type raises COMSITtAIMT ERROR %hen the value 
of the variable is null and the attribute is approprTate for an array or 
task type. This implementation derives the array attribute values from the 
subtype; thus, the prefix is not evaluated and no exception is raised as 
allowed by LRH 11.6(7), for the checks at lines 77, 87, 108, 121, 131, 141, 
152, 165, and 175. 

CE3111B and CE3115A were graded inapplicable 1:^ Evaluation Modification as 
directed by the AVO. The tests assume that output from one internal file 
is unbuffered and may be immediately read by another file that shares the 
same external file. This implementation raises END_ERROR on the attempts 
to read at lines 67 and 101, respectively. 

CE3202A was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test applies fxmction NAME to the standard input file, vhich 
in this implementation has no name; USE^ERROR is raised but not handled, so 
the test is aborted. The AVO ruled that this behavior is acceptable 
pending any resolution of the issue by the ARG. 


2-5 







CHAPTER 3 


PROCESSING INFORMATIGN 


3.1 TESTING ENVIRC]NHENT 

Ihe Ada inplementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact for technical information about this Ada 
is^lementation system, see: 

Michael Devlin 
106 Apple Street 
Tinton Falls NJ 07724 
(201) 758-7531 

For a point of contact for sales information about this Ada implementation 
system, see: 


Michael Devlin 
106 J^le Street 
Tinton Falls NJ 07724 
(201) 758-7531 


Testing of this Ada inplementation vras conducted at the customer's site by 
a vali^tion team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test 
of the custcmdzed test suite in accordance with the Ada Programming 
Language Standard, i^ether the test is applicable or inapplicable; 
otherwise, the Ada Inplementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable and aj^licable), a resxilt vms 
obtained that conforms to the Ada Programming Language Standard. 


3-1 






PROCESSING INFORNATION 


Total Number of ^>plicable Tests 3841 

Total Number of Withdravm Tests 61 

Processed Inapplicable Tests 89 

Non-Processed I/O Tests 0 

Non-Processed Floating-Point 

Precision Tests 159 

Total Number of Inapplicable Tests 248 


Total Number of Tests for ACVC 1.11 4170 


All I/O tests of the test suite were processed because this implementation 
supports a file system. The above nubber of floating-point tests were not 
processed because they used floating-point precision exceeding that 
supported by the isplementation. 


3.3 TEST EJffiCUTICN 

Version 1.11 of the ACVC cooprises 4170 tests. When this ccnpiler was 
tested, the tests listed in section 2.1 had been withdrawn because of test 
errors. The AVF determined that 249 tests were inapplicable to this 
ioplementation. All inapplicable tests were processed during validation 
testing except for 159 executable tests that use floating-point precision 
exceeding that sipported by the ioplementation. In addition, the modified 
tests mentioned in section 2.3 were also processed. 

A magnetic tape containing the custcxnized test suite (see section 1.3) was 
taken on-site the vali^tion team for processing. The contents of the 
magnetic tape were configured on a 3280 MPS machine and transferred via tar 
tapes to the host machine. 


After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada isplementation. 


The tests were coopiled and linked on the host computer system, as 
appropriate. The executable images were transferred to the target computer 
system by the communications link described above, and run. The results 
were captured on the host conputer system. 


Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See ^pendix B for a cooplete listing of 
the processing options for this implementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were: 


3-2 







PROCESSING INFORMATION 


Option 

Effect 

-1 

Generate a listing file. 

-L 

Specify the name of the file or a directory 
for the listing file. 

-ffl 

Specify the main program name. 

-o 

Specify the name of the executable image file. 

-V 

Cause the coopiler to write a version 
identification and information messages 
to be displayed. 


Ihe listings were printed on a remote system via a remote shell call. Test 
output, conpiler and linker listings, 2 uid job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site hy 
the validation team were also archived. 




APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are eiqplained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum ii^t-line length, which is 
the value for $MAX_lN_LOl—also listed here. These values are expressed 
here as Ada string aggregates, i*diere "V" represents the maximum input-line 
length. 


Macro Parameter 


Macro Value 


$MAX_IN_LEN 

255 

$BIG_ID1 

(1..V-1 -> 'AS V -> '1') 

$BIG ID2 
$BIG_ID3 

(1..V-1 -> 'A', V -> '2') 
(1..V/2 -> 'A') & '3' & 
(1..V-1-V/2 -> 'A') 

$BIG_ID4 

(1..V/2 -> 'A') & '4' & 
(1..V-1-V/2 «> 'A') 

$BIG_INT_LIT 

(1..V-3 -> '0') & "298" 

$BIG_REAL_LIT 

(1..V-5 -> '0') & "690.0" 

$BIG_STRING1 

A (1..V/2 -> 'A') & 

$BIG_STRING2 

& (1-.V-1-V/2 -> 'A') & '1 

$BLANKS 

(1..V-20 


$MAX_LEN_IMr_BASED_LITERAL 

"2:" & (1..V-5 -> '0») & "11;" 

$MAX_IJN_REAL_BASED_LITERAL 

"16:" « (1..V-7 -> '0') & "F.E:" 




MACRO PARAMETERS 


$MAX_STRING_LITERAL & (1..V-2 -> 'A') & 


The follofwing tedsle lists all of the other macro parameters and their 
respective values: 


Macro Parameter 

Macro Value 

$ACC_S1ZE 

32 

$ALIGNHENT 

4 

$COONT_LAST 

2147283647 

$DEFAULT_MEM_SIZE 

2147283748 

$DEFAULT_STOR_UNIT 

8 

$DEFAULT_SYS_NAME 

CCUR_MC68K 

$DELTA_DOC 

2#1.0#E-31 

$ENTRY_AI»RESS 

SYSTEM, si gnal_user_2_ref 

$ENrRY_ADDRESSl 

SYSTEM. signal_child_ref 

$ENrRY_ADDRESS2 

SYSTEM. signal_j)ower__restore_ref 

$FIELD__LAST 

512 

SFILEJTERMINATOR 

9 9 

$FIXED_NAME 

NO_SUCH_FIXED_TYPE 

$PLQAT_NAME 

NO_SUCH_FLQAT_TYPE 

$PORM__STRING 

nif 

$P0RM_STRINS2 

"CANNOTJffiSTRICT_FILE__CAPACITY’’ 

$GREATER THAN DURATION 

0.0 


$GREATER THAN DURATION BASE LAST 

lOOOOTJ.O 

$GREATER THAN FLOAT BASE LAST 

“ “ “ 16?1.0#+32 

$GREATER THAN FLOAT SAFE LARCX 

16¥0.8#E+32 








MACRO PARAMETERS 


$GREATER THAN SHORT FLOAT SAFE LARC£ 

” 0.0 

$HIGH_PRI0R1TY 255 

$ILl£GAL_E]nTSNAL_FILE_NAMEl 

/iMdir/filel 

$ILLEGAL_EXTERNAL_FILE_KAME2 

>^»rongdi r/f ile2 

$INAPFR0PR1ATE LINE LENGIH 

” -1 

$INAFPROPRIATE PAGE LQ9STH 

” -1 

$INCLUDE_PRAGMA1 PRAGMA INCLUDE (’’A2800601.TST") 

$INCLUDE_PRAGMA2 PRAC34A INCLUDE ("B28006F1.TST") 

$INTEGER_FIRST -2147483648 

$INTBGER_LAST 2147483647 

$INTEGER_IAST_PLUS_1 2147483648 

$INTERFACE_LANGUAGE ASSEMBLER 

$LESS_THANJWRATION -0.0 

$LESS THAN DURATION BASE FIRST 

” “ ” - 2 ^ 0000.0 

$LINE_TERMINATOR ASCII. LF 

$LOW_PRIORITY 0 

^MACHINE CODE STATEMENT 

NULL 

$MACHINEjGODE__TJfPE NOJWCHJTYPE 

$MANTISSAJDOC 31 

$MAX_DIGITS 18 

$MAX_INT 2147483647 

SMAX_INT_PLUS_1 2147483648 

$M1N_INT -2147483638 


A-3 








MACRO PARAMETERS 


$NAME 

TINY_INTEGER 

$NAME_LIST 

CCUR_MC68K 

$NAME_SPECIFICATI0N1 

/benl/a:?)! 8 3/acvcll/chape/X212 OA 

$NAME_SPECIFICATI0N2 

/benl/nipl83/acvcll/chape/X2120B 

$NAME_SPECIFICAnON3 

y43enl/1ipl83/acvcll/chape/X3119A 

$NEGJBASED_1NT 

16#FFFFFFFE# 

$NEW_MEM_SIZE 

2147483648 

$NEW_STDR_UNIT 

8 

$NEM_SYS_NAME 

CajR_MC68K 

$PAGE_TERMINATOR 

ASCII-LF & ASCII.FF & ASCII.LF 

$RECORD_DEF1NIT10N 

NEW INTEGER 

$RECORD_NAME 

NO_SUCH_MACHINE_CODE_TYPE 

$TASK_SIZE 

32 

$TASK_ST0RAGE_S1ZE 

10240 

$TICK 

1.0/60.0 

$VARIABLE_ADDRESS 

GET_VARIABLE_ADDRESS 

$VARIABLE_ADDRESS1 

GET_VARIABLE_ADDRESS1 

$VARIABLE_ADDRESS2 

GET_VARIABLE_ADDRESS2 

$YCX}R PRAGMA 

VOLATILE 


A-4 







APPEllDIX B 


OOHPIIATION SYSTEM OPTIONS 


The ccxnpiler zund linker options of this Ada isqplenentation, as described in 
this Appendix, are provided by the custcmer. unless specifically noted 
otherwise, references in this a^^ndix are to cozqpiler and linker 
documentation and not to this report. 


Option Effect 


-1 If specified, listing file is generated 

(listing is not generated by default) 

>L This option specifies the name of the 

file or a directory for the listing file, 
(defaiilt filename is source_filejname.l) 

-m This option will specify the main program 

name (a parameterless procedure). 

-c This option will specify the name of 

the library unit on \diich the ccnqpleter 
should be run. Ais will cause the 
conpilation of all generic instantiations. 
This option was not specified. 

-o This option specifies the name of the 

executzJole image file. This c^tim is 
ignored if hd option is not given. 

-A This option instructs the compiler to 

generate assembly listing. No assembler 
listing was required, (not specified). 

-C This option instructs the compiler to 

copy the source file being coopiled 
into the program library, (not specified) 


B-1 






OOMPIIATICN SYSTEM OPTIONS 


Option 

Effect 

-S 

This option tells the conpiler to svippress 
all run-time checks, (not specified) 

-0 

This option controls the optimization 
level of the conpiler. (the compiler 
performs all optimizations by default) 

-I 

This option tells the compiler to obey 
pragma Inline, (default is to obey the 
pragma) 

-s 

This option tells the coopiler to perform 
only ^e syntax analysis, (not specified) 

-V 

This option causes the conpiler to write 
a version identification and information 
messages to be displayed. This option 
was specified, (the default is to 
suppress such information) 


B—2 






APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics of this Ada isplementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this ^jpendix are to coipiler documentation and not to this 
report, inplementation-specific portions of the package STANDARD, \duch 
are not a part of ^ipendix F, are: 


package STANDARD is 


type INTEGER is range -2147483648 .. 2147483647; 


type 

type 

type 

type 

type 

type 


TINy_IMrEGER is range -128 .. 127; 

SHORT_INTEGER is range -32768 .. 32767; 

FLOAT is digits 6 range -16fO.FPFFrF#E32 .. 16#0.FFrFFF#E32; 

LONG_FLQAT is digits 15 
range -16#0.1 
16«0.] 

LGNG_LQNG FLOAT is digits 18 
range -16?0.FFFFFFFFFFFFFFFF#E4096 .. 

16#0.1 


DURATION is delU 0.00006103515625 
range -131072.00 .. 131071.99993896484375; 


end STANDARD; 


C-1 




APPENDIX F 

IMPLEMENTATION-DEPENDENT CHARACTERISTICS 


F.1 INTRODUCTION 

The Ada programming language definition requires every Ada compilation system to 
supply an Appendix F containing all implementation-spedfic aspects of the compiler and 
the run-time system. 

F^ IMPLEMENTATION-DEPENDENT PRAGMAS 

Table F-1 lists all pragmas in C^Ada predefined as well as implementation-defined. 


TABLE F-1. PRAGMA IMPLEMENTATION SUMMARY 


PRAGMA 

IMPLEMENTED 

COMMENTS 

BYTE_PACK 

Yes 

The elements of an array or record are packed down 
to a minimal number of bytes. 

CONTROLLED 

No 

Not applicable because no automatic storage 
reclamation of unreferenced access objects is 
performed. The complete storage requirement of a 
collection is released when it passes out of scope. 

ELABORATE 

Yes 

is handled as defined by the Ada language. 

EXTERNAL_NAME 

Yes 

Defines the link-time name of a statically allocated 
object or of a subprogram. 

INLINE 

Yes 

Is handled as defined by the Ada language, with the 
following restrictions: The subprogram to be 
expanded inline must not contain declarations of 
other subprograms, task bodies, generic units, or 
body stubs. If the subprogram is called recursively, 
only the outer call is expanded. The subprogram 
must be previously compiled, and if it is a generic 
instance, it must be previously completed. 

INTERFACE 

Yes 

Is implemented for the languages C and Assembler. 

UST 

Yes 

Is handled as defined by the Ada language. 

MEM0RY_S1ZE 

No 

You cannot change the number of available storage 
units in the machine configuration, which is defined 
in package SYSTEM. 

OPTIMIZE 

No 

Optimization of a compilation can only be 

controlled using the -o option on the adac 

command line. - ■ 

PACK 

Yes 

The elements of an array or record are packed down 
to a minimal number of bits. 

PAGE 

Yes 

Is handled as defined by the Ada language. 

PRIORITY 

Yes 

Is handled as defined by the Ada language. 
Priorities in the range 0 ~ 255 are supported. 


TABLE F-1. PRAGMA IMPLEMENTATION SUMMARY (Continued) 


48-555 FOO ROO 


F-1 




























PRAGMA 

IMPLEMENTED 

COMMENTS 

SHARED 

Yes 

Is handled as defined by the Ada language. 

STORAGE.UNIT 

No 

You cannot change the number of bits in a storage 
unit which is defined as 8 in package SYSTEM. 

SUPPRESS 

No 

Different types of checks cannot be switched on or 
off for specific objects; however, see suppress all. 

SUPPRESS^a 

Yes 

This pragma allows the compiler to omit the 
generation of code to check for errors that may 
raise constraint_error or program_error that 
may be raised due To an elaboration order problem. 

SYSTEM_NAME 

No 

You cannot change the system name which is 
defined as CCUR_MC68K in package SYSTEM. 

VOLATILE 

Yes 

Specifies that every read or update of a variable 
causes a reference to the actual memory location for 
the variable. That is. a local copy of the variable Is 
never made. This is similar to pragma srared. 
except that any variable may be specified. This 
pragma causes all optimizations on the specific 
variable to be suppressed. 


F^1 Pragma INLINE Restrictions 

Inline expansion of subprogram calls occurs only if the subprogram does not contain any 
declarations of subprograms, task bodies, generic units, or body stubs. For recursive calls, 
only the outer call is expanded. The subprogram body must be previously compiled and if 
it is a generic instance, it must be previously completed. If for one or more of these 
reasons the inline expansion is rejected by the compiler, a corresponding warning message 
will be produced. 

F.3 REPRESENTATION CLAUSES 

The following subsections describe the restriaions on representation clauses as defined in 
Chapter 13 of the Reference Manual for the Ada Programming Language - ANSI/MIL-STD- 
1815A‘1983. 


F.3.1 Length Clauses 

A length clause specihes the amount of storage to be allocated for objects of a given type. 

The following is a list of the implementation-dependent attributes: 

TSIZE must be <- 32 for any integer, fixed point, or enumeration 

type. For any type derived from float. long_float. or 
LONG_LONG_FLOAT. the size must be equal to the d^ault value 
selected by the compiler. These are 32. 64. and 96. 
respectively. The only value allowed for access types is 32 (the 
default value). If any of these restrictions Is violated, the 
compiler will report a restriction error. 


F-2 


48-555 FOO ROO 

















TSTORAGE_SIZE If this length clause is applied to a collection, the exact 

amount of space specified will be allocated. No dynamic 
extension of the collection will be performciu. If the length 
clause is not specified, the collection will be extended 
automatically whenever the allocator new is executed and the 
collection is full. 

TST0RAGE_S1ZE If this length clause is applied to a task type, the specified 

amount of stack space will be allocated for each task of 
corresponding type. The value supplied should not be less 
than 1400. If no length clause is specified for a task type, a 
default value of lOK bytes is supplied by the compiler. Stack 
space allocated for a task is never extended automatically at 
run-time. 

TSMALL There Is no implementation-dependent restriction. In 

particular, even values of SMALi. which are not powers of 2 
may be chosen. 

F.3.2 Representation Attributes 

The Representation attributes listed below are as specified in the Reference Manual for the 

Ada Programming Language - ANSI/MIL~STu-l 815A~1983, Section 13.7.2. 

X’ADDRESS is only supported for objects, subprograms, and interrupt 

entries. Applied to any other entity, this attribute yields the 
value SYSTEM.ADDRESS^ZERO. 

X'SIZE is handled as defined by the Ada language. 

R.C'POSlTION is handled as defined by the Ada language. 

R.C’FIRST.B1T is handled as defined by the Ada language. 

R.C‘LAST_BIT is handled as defined by the Ada language. 

TSTORAGE_SIZE applied to an access type, this attribute will return the amount 

of storage currently allocated for the corresponding collection. 
The returned value may vary as collections are extended 
dynamically. 

TST0RAGE_SIZE for task types or task objects, this attribute is handled as 

defined by the Ada language. 

F.3.3 Representation Attributes of Real Types 

This subsection lists all representation attributes for the floating point types supported; 

P'DIGITS yields the number of decimal digits for the subtype P. The 

values for the predefined types are 6. 15. and 18 for the.types 
FLOAT. LONG_rLOAT. and LONG_LONG_FLOAT. respectively. 

P’MANTISSA yields the number of binary digits in the mantissa of P. Table 

F-2 shows the relationship between 'digits and 'mantissa. 


48-S55 FOO ROO 


F-3 



TABLE F-2. P*MANT1SSA VALUES 


P'EPSILON 


P'EMAX 


P'SMAa 




1 

5 

10 

35 

2 

8 

11 

38 

3 

11 

12 

41 

4 

15 

13 

45 

5 

18 

14 

48 

6 

21 

15 

51 

7 

25 

16 

55 

8 

28 

17 

58 

9 

31 

18 

61 


yields the absolute value of the difference between the model 
number 1.0 and the next model number above 1.0 of subtype 
p. Table F*3 summarizes the values for 'epsilon. 


TABLE F-3. P'EPSILON VALUES 


DIGITS 

EPSILON 

DIGITS 

EPSILON 

1 

16#0.1#E0 

10 

16#0.4#E-08 

2 

16#0.2#E-01 

11 

16#0.8#E-09 

3 

16#0.4#E-02 

12 

16#0.1#E-09 

4 

16#0.4#E-03 

13 

16#0.1#E-10 

5 

16#0.8#E-04 

14 

16#02#E-11 

6 

16#0.1#E-04 

15 

16#0.4#E-12 

7 

16#0.1#E-05 

16 

16#0.4#E-13 

8 

16#0.2#E-06 

17 

16#0.8#£-14 

9 

16#0.4#E*07 

18 

16#0.1#E-14 


yields the largest exponent of model numbers for subtype P. 
The values of 'sua are given in Table F-4. 


TABLE F-4. P’EMAX VALUES 


DIGITS 

EMAX 

DIGITS 

EMAX 


20 


140 


32 

mSm 

152 


44 


164 


60 

■9 

180 


72 

14 

192 


84 

15 

204 


100 

16 

220 

8 

112 

17 

232 

9 

124 

18 

244 


yields the smallest model number of subtype p. The values of 
ALLareglven 


F-4 


48-S55 FOO ROO 

















TABLE F-5. PSMALL VALUES 


DIGITS 

SMALL 

DIGITS 

SMALL 

1 

16#0.8#E-05 

10 

16#0.8#E-35 

2 

16#0.8#E-08 

11 

16#0.8#E-38 

3 

16#0.8#E-11 

12 

16#0.8#E'41 

4 

16#0.8#E-15 

13 

16#0.8#E-45 

5 

16#0.8#E-18 

14 

16#0.8#E-48 

6 

16#0.8#E-21 

15 

16#0.8#E-51 

7 

16#0.8#E-25 

16 

16#0.8#E-S5 

8 

16#0.8#E-28 

17 

16#0.8#E-S8 

9 

16#0.8#E-31 

18 

16#0.8#E-61 


P'LARGE yields the largest model number of the subtype p. The values 

of 'LARGE are given in Table F*6. 

TABLE F-6. P’LARGE VALUES 


DIGITS 

LARGE 

i 

16#0.F8#E05 

2 

16#O.FF3ifE08 

3 

16#0.FFE#E11 

4 

16#0.FFFE#E15 

5 

16#0.EEFF.C#E18 

6 

16#0.FFFF_F8#E21 

7 

16#0.FFFFJT8#E25 

8 

16#0.FFFF.FFF#E28 

9 

I6#0.FFFF.FFFE#E3I 

10 

16#0.FFFF.FFFF.E#E35 

11 

16#0.FFFF_FFFFJ'C#E38 

12 

16#0.FFFF.FFFFJT8#E41 

13 

16#0.FFFF_FFFFJTF8#E45 

14 

16#0.FFFF_FFFF_FFFF#E48 

15 

16#0.FFFF>FFFF_FFFF_E#E51 

16 

16#0.FFFF_FFFF_FFFF_FE#E55 

17 

16#0.FFFF_FFFF_FFFF_FFC#E5 8 

18 

16#0.FFFF_FFFF_FFFF_FFF8#E61 


The following attributes will return characteristics of the safe numbers and the 
implementation of the floating point types. For any floating point subtype p, the attributes 
below will yield the value of the predefined floating point type onto which type p is 
mapped. Therefore, only the values for the types float, long_float. and 
LONG_LONG_FLOAT are given in Table F-7. 


48-555 FOO ROO 


F-S 











TABLE F-7. IMPLEMENTATION-DEPENDENT ATTRIBUTES FOR FLOAT TYPES 


ATTRIBUTE 

FLOAT 

LONG_FLOAT 

LONG.LONG_FLOAT 

P'SAFE_EMAX 

125 

1021 

16382 

P’SAFE_SMALL 

16#0.4#E-31 

16#0.4#E-255 

■iiiriMMii—i 

P'SAFEOARCE 

16#0.1FFFJT#E32 

16#0.1FFFJTFF« 

FFFFJFC#E256 

16#0.3FFF_FFFF_ 

FFFF_FFFE#E4096 

P’MACHINE_ROUNDS 

TRUE 

TRUE 

TRUE 

P'MACHINE_OVERFLOWS 

TRUE 

TRUE 

TRUE 

P*MACHINE_RAD1X 

2 

2 

2 

P'MACHINE_MANT1SSA 

24 

53 

64 

P’MACHINE_EMAX 

128 

1024 

16384 

P’MACHINE_EMIN 

-125 

-1021 

-16382 


F.3.4 Representation Attributes of Fixed Point Types 
For any fixed point type tr. the representation attributes are: 


TMACHINE_ROUNDS 

TMACHINE^OVERFLOWS 

TMANTISSA 

rsizE 


is TRUE 
is TRUE 

is in the range 1.31 
is in the range 2.32 


F.3.5 Enumeration Representation Clauses 

The integer codes specified for each enumeration literal have to lie within the range of the 
largest integer type of the implementation (which is integer). The maximum number of 
elements in an enumeration type is limited by the maximum size of the enumeration image 
table which cannot exceed 65335 bytes. The enumeration table size is determined by the 
following generic function: 


gensxic 

typ« ENUMERATIONJTYPE is (<>); 
function ENUMERATION_TABL£_SIZE sotuzn MATURiO.; 

function ENTn4£RATI0N_TABLE_SIZ£ sotuzn NATURAL is 
RESULT ; NATURAL 7-0; 
bsgin 

for I in EN0MERAT10N_TYPE'FIRST .. ENUMERATIONJIYPE'LAST 
loop 

doclsxB 

subtyp* £ is ENUMERATIONJTYPE range I .. I; 
begin 

RESULT RESULT + 2 + E'WIDTH; 
end; 

end loop; 
return RESULT; 
end ENUMERATION TABLE SIZE; 


F-6 


48-555 FOO ROO 


































F.3.6 Record Representation Clauses 

With a record representation clause, you can define the exact layout of a record In memory. 
Two types of representation clauses are supported: alignment clauses and component 
dauses. 

The value given for an alignment clause must be either 0. 1, 2, or 4. A record with an 
alignment of 0 may start anywhere in memory. Values other than 0 will force the record to 
start on a byte address which is a multiple of the specified value. If any value other than 0. 
1,2, or 4 is specified, the compiler will report a restriction error. 

For component clauses, the specified range of bits for a component must not be greater 
than the amount of storage occupied by that component. Caps within a record may be 
achieved by not using some bit ranges in the record. Violation of these restrictions will be 
Bagged with a restriction error message by the compiler. 

In some cases, the compiler will generate extra components for a record. These cases are: 


• If the record contains a variant part and the difference between the smallest and the 
largest variant is greater than 32 bytes and 

— it has more than one discriminant or 

— the discriminant can hold more than 256 values. 

In these cases, an extra component is generated which holds the actual size of the 
record. 

• If the record contains array or record components whose sizes depend on 
discriminants. In this case, one extra component is generated for each such component 
holding its offset in the record relative to the component generated. 

The compiler does not generate names for these extra components. Therefore, they cannot 
be accessed by the Ada program. Also, it is not possible to specify representation clauses 
for the components generated. 

F.4 ADDRESS CLAUSES 

Address clauses can be used to allocate an object at a specific location in the computer's 
address space or to associate a task entry with an interrupt. 

Address clauses are supported for objects declared in an object declaration and for task 
entries. If an address clause is specified for a subprogram, package, or task unit, the 
compiler will report a restriction error. 

For an object, an address clause causes the object to start at the specified location.. 

F.4.1 Interrupt Entries 

Address clauses are supported for task entries. An address clause applied to a task entry 
enables an operating system signal to initiate an entry call to that entry. The address 
supplied in an address clause for a task entry must be one of the constants declared in 
pmekmgm SYSTEM for this purpose. 

The interrupt is mapped onto an ordinary entry call. The entry may also be called by an 
Ada entry call statement. However, it is assumed that there are no entry calls waiting for 
the same entry when an interrupt occurs. Otherwise, the program is erroneous and behaves 
as follows: 

• If an entry call on behalf of an interrupt is pending, the pending interrupt is lost. 

• If any entry call on behalf of an Ada entry call statement is pending, the interrupt entry 
call takes precedence. The rendezvous on behalf of the Interrupt is performed before 
any other rendezvous. 


48-555 FOO ROO 


F-7 




F.5 PACKAGE SYSTEM 

The Ada language definition requires every implementation to supply a package system. 
In addition to the declarations required by the language, package system includes 
definitions of certain configuration-dependent characteristics. The specification for the 
C^Ada implementation is given below. 


package SYSTEM is 

type ABDRESS is private; 


ADDR£SS_NULL : constant ADDRESS; 
ADDRESS ZERO : constant ADDRESS; 


function (LEFT : ADDRESS; RIGHT 

function "+" (LEFT : INTEGER; RIGHT 

fimction (LEFT : ADDRESS; RIGHT 

fimction (LEFT : ADDRESS; RIGHT 


INTEGER) 

ADDRESS) 

INTEGER) 

ADDRESS) 


return ADDRESS 
return ADDRESS 
return ADDRESS 
return INTEGER 


function SYMBOLIC.ADDRESS (SYMBOL : STRING) return ADDRESS;- 

— Returns the address of the external symbol supplied by 

— SYMBOL, which must be a string literal. This value can 
~ be used in address clauses for objects, providing the 

— capability of referring to objects declared in C or Assembler. 


type NAME is (CCUR_MC68K); 

SY5TEM_NAM£ : constant NAME CCUR HC68K; 


ST0RAGE_UN1T 

MEM0RY_S1ZE 

M1N_INT 

MAX~INT 

MAX^DIGITS 

MAX~MANT1SSA 

FINE_DELTA 

tick” 


constant 

constant 

constant 

constant 

constant 

constant 

constant 

constant 


8; 

2 •* 31; 

- 2 •* 31; 

2 ** 31 - 1; 
18; 

31; 

2.0 »* (-31); 
1.0 / 60.0; 


type XJNSIGNED.SHORT.INTEGER is range 0 .. 65^535; 
type 0NSlGNED3lNY_iNTEGER is range 0 . . “255; ^ 

for 0NS1GNED_SH0RT_INTEGER'SIZE use 16; 
for UNSIGNED_TINY_BrrEGER'SIZE use 8; 


subtype BYTE is UNSIGNEDjriNY_INTEGER ; 

Siibtype ADDRESS_RANGE is INTEGER;” 

subtype PRIORITY is INTEGER range 0 .. 255; 

type SIGNAL is ( 

SIGNAL_NULL, 

signal'rangup, 
signal”interrupt, 
signal“quit, 

signal”illegal_instrdction, 

SIGNAL“TRACa:_TRAP, 

signal”abort, 

SIGNAL_EMT_INSTRUCTION, 

signal”floating_point_error, 
sigmal”kill, 
signal”bus_error, 
signal“seg:ientation_violation , 
signal“bad_argument_to_system_call , 

SIGlIAL“pipi WRITE, 


F-8 


48*555 FOO ROO 









SXGNAL.ALASM, 

signalIterminate, 
signal”user_i, 
signalIusesIx , 
signal_chii5, 
signal_power_restore, 
signalIstop,” 

SIGKALJEERM1NAL_ST0P, 

signal~continueT 

SIGNAL_TERMINAL_INPUT, 

signal_terminal”output, 

SIGNAL_INPUT_CHARACrER, 

signal“cpu_time_limit_exceedei> , 

SIGNAL_FIli_SI2E_LIMIT_EXCEEDED, 
SIGNAL_WIND0W_RES1ZED, 
SIGNAL20Wr_0F3AND_DATA_0N_S0CKET, 

signai<_virtuaI_timer_alarmT 

SIGNAli_PROFILING_TIMER_ALARM, 
SIGNAL~10_lS_P0silBLE) ,• 


— SIGNAL_mjLL_REF 
S1GNAL_HANGUP_REF 

signalIinterrupt_ref 

SIGNAL_QUIT_REF “ 

— SIGNAL~fLI.EGAL_lNSTRUCTION_REF 
SIGNA1_TRACE_TRAP_REF 

signal”abort“ref “ 

S1GNAL~EMT_1NSTRUCT10N_REF 

— signalIfloating_point_error_ref 

— signal_kill_ref"’ 

— signal_bus_error_ref 

— signalIsegmentation_violation_ref 
S1GNAL_BAD_ARGUMENt“tO SYSTn-l'cALL REF 
SIGNAE_PIPE_WRITE_REF ” 

— SIGNAL_ALABM_REF “ 

SIGNAL_TERMINATE_REF 

— SIGNAL_USER_1_REF 

signalIusep,~2”ref 

signal_chix5_ref 

SIGNAL_POWER~RESTORE_REF 

— SIGNAL_STOP_REF ~ 

signaOermInal_stop_ref 

SIGNAL_CCNTINUE~REF 

signal_terminal”input_ref 

SIGNAL_TERMINAL_OTJTPUT_REF 
SIGNAL_1NPUT_CHARACTER_REF 
SIGNAI._CPir_TiME_LIMIT_EXCEEDED_REr 
SIGNAL_F1I.E_SI2 E_LIMIT_EXCEEDe5_REF 
SIGNAL_W1ND0W_RESIZED_REF ” 

signalIout_of”band_data_on_socket_ref 

SICNAL_VlRiuAl_TIMiR_ALARM~REF 

sicnal~profiling_tim£r_alarm_ref 

SIGNAL”lO_IS_POsilBLE_REF 


intentionally ooitted 
: constant ADDRESS; 

: constant ADDRESS/ 

: constant ADDRESS; 

intentionally omitted 
: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS ; 

intentionally omitted . 
intentionally omitted 
intentionally omitted 
intentionally omitted 
: constant ADDRESS; 

: constant ADDRESS; 

intentionally omitted 
: constant ADDRESS; 

’ intentionally omitted 
: constant ADDRESS; 

; constant ADDRESS; 

: constant ADDRESS; 

intentionally omitted 
; constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS 
: constant ADDRESS; 

: constant ADDRESS; 

: constant ADDRESS; 


48*555 FOO ROO 


F-9 





type PROC£SS_ID is new IMT£G£R; 

subtype AST.MUtffiER is IKTEGUR range 65..12B; 

type AST.PRIORXTY is range 0..32767; 

for AStIpRIORITY'SIZE use 32; 

— definitions for AST support. 


function TO_C_ROUTINE (ADA_ROUTINE : ADDRESS) return ADDRESS; 

— Converts an address of an Ada routine to an address 

— of a C routine that can be used as an AST handler. 

— This routine allocates some space on the heap 

— and initializes it with code that changes the 

— C calling conventions into Ada calling conventions 

— so that the caller thinks that a C routine is being 

— called. 


type EXCEFTION_ZD is new INTEGER; 


NO_EXCEPTION_ID : constant EECEPT10M_ID 

— Coding of the predefined exceptions: 


CONSTRAINT_ERROR_ID ; 
injMERIC_ERROR_ID** 

program_errorIid 

STORAGEJERR0R_ID 

taskingIerror^id 

STATUS_ERR0R_1D 
M0DE_1^0R_ID 

nameIerror”id 
use_error.5d 

DEvicE_ERROR_lD 
END_ERROR_ID 
DATA_ERROR_ID 
LAyOUT_ERROR_lD 

TIME_ERROR_ID 

NO ERROR CODE 


constant EXCEPTION^ID 
constant EECEPTION^ID 
constant £ECEPT10N~ID 
constant EECEPTION.ID 
constant EXCEPTION^ID 

constant EXC£PTION_ID 
constant EXCEPTION^ID 
constant EXCEPTION^ID 
constant EXCEPTION_ID 
constant EECEPTION^ID 
constant EXCEPTION^ID 
constant EECEPTION^ID 
constant EECEPTION.ID 

: constant EECEPTION.ID 

■» 

: constant 0; 


0; 


16i0002_0000i 

16i0002l0001l 

16i0002l0002# 

16i000220003« 

16f0002~0004l 

16i0002_0006t 
16i0002~0007t 
16i0002~0008t 
16l0002~0009t 
16«0002'000AI 
1610002 OOOB* 
16i0002_000CS 
16«0002_000Di 

1610002 OOOEf 


type EXCEPTION_INFORMATION 
is record 

EXCP_ID : EXCEPTION^ID; 

— Identification of the exception. The codings of 

— the predefined exceptions are given above. 

CODE.ADDR : ADDRESS; 

— Code address where the exception occurred. Depending 

— on the kind of the exception, it nay be the address of 

— the instruction which caused the exception, or it 

— nay be the address of the instruction which would 

— have been executed if the exception had not occurred. 

SIGNAL : SVSTBi.SIGNAL; 

Signal that caused this exception to be raised, 

— else SIGNAL_NULL. 
end record; 


procedure GET.EXCEPTION^INFORMATION 

Tz 3CCP_INF0'’: out EXCEPTION_INFORMATION); 

—* This siibprograa oust only be called froa within an exception 

— handler BEFORE ANT OTHER EXCEPTION IS RAISED. It then returns 

— the infozi&ation record about the actually handled exception. 

— Otherwise, the result is undefined. 


F-10 


48-555 FOO ROO 









function INTEGER_TO_ADDRESS(ADOR : ADDRESS_RANGE) xotuin ADDRESS; 
function ADDRESS_To“lNTEGER(ADDR : ADDRESST return ADDRESS_RANGE ; 
pragma INI.INE(INTEGER_TO_ADDRESS, ADDRESS_TO_INTEGER); 

— Conversion between address and integer types. 

type EXIT_STATUS is new INTEGER range 0 . . 2**8-l; 

N0RMAD_EX1T : constant EX1T_STATUS 0; 

ERRNO : INTEGER; 

for ERRNO use at STMBOLIC_ADDRESS(”_errno") ; 

— Allows access to the ERRNO set by the last system call, C, or 

— assembler routine call that was made on behalf of the calling 

— task. 

procedure EX1T_PR0CESS( STATUS : in EXIT_STATUS HORMAL^EXIT); 

— Terminates the Ada program with the following actions.- 
— All Ada tasks are aborted, and the main program exits. 

— All I/O buffers are flushed, and all open files are closed. 

private 

— Implementation-defined 
end SYSTEM;’ 

F.6 TYPE DURATION 

DURATION'SMALL is 2'*'^ scconds. This number is the smallest power of two which can 
represent the number of seconds in a day in Jongword fixed point number representation. 

SYSTEM.TICK is equal to 1.0 / 60.0 seconds, duration'small is significantly smaller than 
the actual computer clock-tick. Therefore, the accuracy with which you can specify a delay 
is limited by the actual clock-tick and not by duration'small. Table F-8 summarizes the 
characteristics of type duration; 


TABLE F-8. TYPE DURATION 


ATTRIBUTE 

VALUE 

APPROXIMATE 

VALUE 

DURATION’DELTA 

2#1.0#E-14 

— 61 fiS 

DURATION'SMALL 

2#1.0#E-14 

— 61 MS 

DURATIONTIRST 

-131072.00 

~ 36 hrs 

DURATION’LAST 

131071.99993896484375 

- 36 hrs 

DURATION’SIZE 

32 



48-S55 FOO ROO 


F-11 





F.7 INTERFACE TO OTHER LANGUAGES 

The pragma INTERFACE Is implemented for two programming languages: C and Assembler. 
The pragma has the form: 

pragma INTERFACE (C, subprogranunamc)/ 


pragma INTERFACE (ASSEMBLER, SUbprogratrUftame); 

Here. subprograrrL.name is a subprogram declared in the same compilation unit before the 
pragma. 

The only parameter mode supported for subprograms written In the C language is in. The 
only types allowed for parameters to subprograms written in the C language are integer. 
LONG_FLOAT. and STSTEM. ADDRESS. These restrictions are not checked by the compiler. 

Details on interfacing to other languages are given in Chapters 6 and 7. 

F.8 INPUT/OUTPUT PACKAGES 

The following two system-dependent parameters are used for control of external files: 


• the NAME parameter 

• the FORM parameter 

The NAME parameter must be a legal RTU pathname conforming to the following syntax: 

pathname [/] ( dirname [/ dirname )/] filename 

dirname and filename are strings of up to 14 characters length. Any characters except 
ASCII. NUL, ' ’ (blank), and V’ (slash) may be used. 

The following is a list of all keywords and possible values for the form parameter in 
alphabetical order. 


APPEND -> FALSE | TRUE Only applicable to sequential and text files. If 

TRUE is specified in an open operation, the file 
pointer is positioned to the end of the file. This 
keyword is ignored in a create operation. The 
file mode must be in_file. The default is 

append -> FALSE. 

MODE -> numeric^literal This value specifies the access permission for an 

external file. It only takes effect in a -create 
operation. It is ignored in an open operation. 
Access rights can be specified for file owner, 
group members, and ail users. The 
numericjiteral has to be a three digit octal 
number. The single bits of this number have the 
following meaning: 


F-12 


48-555 FOO ROD 





8#400# read access owner 

8#200# write access owner 

8# 100# execute access owner 
8#040# read access group 

8#020# write access group 

8#010# execute access group 
8#004# read access all others 

8#002# write access all others 

8#001# execute access all others 


You can specify any sum of the above. The 
default value is 8#666#. 

Note that the RTU operating system will subtract 
the process's file mode creation mask from the 
mode you have specified. You can change the file 
mode creation mask with the RTU command 
umask (see the RTU Programming Manual). For 
example, if your session has a file mode creation 
mask of 8#022# and you create a file with mode 
8#666#. the file will actually be created with the 
privileges 8#644#. 

RECORD_FORMAT, -> VARIABLE 1 

“ FIXED This parameter is only allowed for sequential 

files. The default value is variable. 

REC0RD_SIZE -> numeric^Hteral Only applicable to sequential and direct files. It 

“ specifies the number of bytes in one record. 

This parameter is only allowed for files with a 
fixed record length. When specified in an open 
operation. It must agree with the corresponding 
value of the external file. If element_type is a 
constrained type, the maximum ~ size of 
ELEMENT_TYPE Tounded up to the next byte 
boundaiy is selected by default. If 
ELEMENT^TIPE Is an Unconstrained array type 
and you" want a fixed record length file, this 
parameter must be specified. 

TRUNCATE ->FALSE 1 

FIXED Only applicable to sequential files. The 

FILE_MODE must be OUT_FILE. When TRUE is 
specified in an open operation, the file size is 
truncated to zero. The previous contents of the 
file is deleted. If false is specified, the file is 
not changed initially. If less records than the 
initial file size are written, old records will 
remain unchanged in the file. This parameter is 
ignored for create operations. The default 
value is true. 


F.8.1 Text Input/Output 

There are two implementation-dependent types for text_io; count and field. In C’Ada 
they are implemented as: 


type COUNT is range 0 .. INTEGER'LAST, 
subtype FIELD is INTEGER range 0 .. 512; 


48-555 FOO ROD 


F-13 



The line terminator is implemented by the character ascii.lf. the page terminator by the 
sequence ascii.lf, ascii.ff. ascii.lf. There is no character for the file terminator. End 
of file is deduced from the file size. 


F.9 UNCHECKED PROGRAMMING 


F.9.1 Unchecked Storage Deallocation 

The generic function unchecked_deallocation is supported as specified in the Reference 
Manual for the Ada Programming Language - ANSI/MIL-STD-1815A-1983, Section 13.10. 

F.9.2 Unchecked Type Conversion 

The generic function tJNCHECKED_C0NVERSl0M is supported as specified in the Reference 
Manual for the Ada Programming Language - ANSI/MIL-STD~1815A-1983, Section 13.10. 
However, the following restrictions apply: 

The generic parameter target must not be an unconstrained array type. If target'size > 
SOURCE'SIZE, the result of the conversion will be unpredictable. On the other hand, if 
TARGET'SIZE < SOURCE'SIZE, the left-most bits of the source will be copied to the target 

F.10 IMPLEMENTATION-DEPENDENT RESTRICTIONS 

The following is a list of implementation-dependent restrictions of the compiler 

• The maximum length of a source line is 255 characters. 

• A program library may contain no more than 16381 compilation units. . . 

• A single compilation unit may not contain more than 65534 lines of Ada source text 
(Depending on the complexity of the code, the actual number of lines acceptable may be 
considerably smaller than the upper limit) 

• The number of directly imported units for a single compilation unit may not exceed 
255. Directly imported units are those referenced by vrith clauses. 

• The maximum number of nested s«paxat«s is 511." 

• The main program must be a parameteriess procedure. 

• The maximum length of an Identifier Is 255 (maximum line length). All characters of an 
identifier are significant 

• The maximum number of bits of any object is 2** -1. 

• The maximum length of a pathname is 255 characters. 

• The maximum length of a listing line is 131 characters. 

• The maximum number of errors handled is 1000. 

• The maximum number of units that may be named in the pragma ELABORATE of a 
compilation unit is 255. 

• The maximum total size for text of unique symbols per compilation is 300000 bytes. 

• The maximum parser stack depth is 10000. 

• The maximum depth of nested packages is 511. 

• The maximum length of a program library name is 242 characters. 


F-14 


48-555 FOO ROO 



• The amount of statically allocated, non-lnitialized data in a compilation unit cannot 
exceed unsGEii'LAST bytes. 

• The amount of statically allocated, initialized data in a compilation unit cannot exceed 
INTEGER'lAST bytes. 

F.11 UNCONSTRAINED RECORD REPRESENTATION 

Objects of an unconstrained record type with array components based on the discriminant 
are allocated using the discriminant value supplied in the object declaration. However, if 
no discriminant is supplied in the object declaration, the compiler will choose the 
maximum possible size. For example; 

type DTNAM1C_STRING ( I£NGTH : NATURAL 10 ) is 
xecoxd 

STR ! STRING ( 1 .. LENGTH ); 
end xecoxd; 

DSTR : DYNAMIC_STRING; 

For the record dstr, the Compiler would attempt to allocate natural'last bytes. 
However, this is more than 2 GBytes. As a consequence. constraint_ereor would be 
raised. On the other hand, the declaration 


CSTR : DTNAM1C_STRING (80); 


causes no problems. TTie compiler would allocate 84 bytes for cstr. 

F.12 TASKING IMPLEMENTATION 

The C*Ada system Implements fully pre-emptive and priority-driven tasking. Pre-emptive 
means that task switches may take place even when the currently running task does not 
voluntarily give up processor control. This may happen when a task with a high priority is 
waiting on an external event (the time period specified in a delay statement expires). When 
this event occurs, processor control is passed to the waiting task immediately if it has the 
highest priority of the tasks ready to run. 

The C^Ada run-time system keeps track of all tasks in two categories: tasks which are 
ready to run and those that are suspended because they are waiting for something (e.g.. a 
rendezvous to occur or waiting in a delay statement). The tasks ready to run are sorted in 
a queue by priority (high priorities first). Within one priority, they are sorted in the order 
in which they entered the "ready" state (tasks waiting longer are served first). Whenever 
the run-time system needs a task to schedule, the first task in the queue is selected and 
run. 

The accuracy of delay statements Is governed by the resolution of the operating system 
dock which is 1.0/60.0 seconds (system.tick). Although the resolution of the type 
DURATION is much higher (2'‘^ seconds), task switches caused by the expiration of a delay 
can only take place on a dock tick. A task waiting in a delay enters the "ready" state when 
the next clock tick after its delay period has expired. 

Another implementation-dependent aspect of tasking is the stack size of each task. All task 
objects of a task type with a length clause and all tasks of an anonymous task type have a 
stack space of lOK bytes. For task types, a length clause may be given. The spedfied 
amount of storage space will be allocated for each task object of that type. 

In addition to stack space, a task control block is allocated for each task object, ft occupies 
250 + 20 * numberjof^enthes bytes. The task control block is deallocated when the task 
passes out of scope. 


48-555 FOO ROO 


F-IS 


A program Is erroneous if any of the following operations are performed simultaneously 
by more than one task: 

• The allocator new is evaluated for the same collection. 

• Input-Output operations are performed on the same external hie. 

A C’Ada task is not implemented as an Independent operating system process: rather, tiiC 
whole Ada program is one operating system process which does not use threads. 


F-16 


48-S5S FOO ROO 




