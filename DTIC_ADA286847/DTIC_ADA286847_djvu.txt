Software Productivity Consortium 


o 




aprogramming in Ada Course 
Lectures and Exercises 



Department of Defense Ada Joint Program Office 




W \9 


ft 


rJr 


I 





SP094094<CMC 
Version 01.01^ 


November 1995 





► 


KSmBuiTSrSTA’ 



fcur public 
tioa Vq]i««iri 






SOFTVWRE 
PROOuonvrrY 
njNsamTLM 

SPt: Building 
22 1 i Roc k Hill Ruad 
Herndon, Virginia 22070 
(703) 742-8877 


m 


4 











ad^ Al286 847 

........Ill 1111111111111111111111(11 nil nil 


Megaprogramming in Ada Course: 
Lectures and Exercises 


SPC-94094-CMC 


Version 01.01.04 


November 1995 


Prepared for the 

Department of Defense Ada Joint Program Office 


produced by the 

SOFTWARE PRODUCTIVITY CONSORTIUM 


SPC Building 
2214 Rock Hill Road 
Herndon, Virginia 22070 


Copyright © 1995, Software Productivity Consortium, Herndon, Virginia. This dcKumcnt can be copied and distributed without fee 
in the U S., or internationally. This is made possible under the tcims of the DoD Ada Joint Program Office's royalty-free, worldwide, 
non-cxclusivc, irrevocable license for unlimited use of this material. This material is based in part upon work sponsored by the DoD 
Ada Joint Program Office under Alvanced Research Projects Agency Grant #MDA972-92-J-1018. The content does not necessarily 
reflect the position or the policy of the U.S. Govenment, and no official endorsement should be mferred. Hie name Software Produc¬ 
tivity Consortium shall not be used in advertising or publicity pertaining to tiiis material or otherwise without the prior written permis¬ 
sion of Soffivarc Productivity Consortium, Inc. SOFTWARE PRODUCITVITY CONSORTIUM, fiSC. MAKES NO REPRESEN¬ 
TATIONS OR WARRAN'HES ABOUT THE SUITABIUTY OF TTBS MATERIAL FOR ANY PURPOSE OR ABOUT ANY 
O'lHER MATTER, AND THIS MATERl/ L IS PROITDED WITHOUT EXPRES,S OR IMPLIED WARRANTY OF ANY 
KIND. 

1' ' cl 7 


•■'vl |i.' fii 
.'jlrilrUtioii 


• • 


Ai 


95-02632 





IBM is a registered trademark of International Business Machines Corporation. 
Macintosh is a registered trademark of Apple Computer, Inc. 

Microsoft and MS-DOS arc registered trademarks of Microsoft Corporation. 
Windows and Windows 95 are trademarks of Microsoft Corporation. 




REPORT DOCUMENTATION PAGE 


Form Approved 
0MB No. 0704-0188 


Public rtporting burden lor this collection of information is estimated io average i hour per response, including ine lime foi reviewi 
gathering and maintaining the data needed, and completing aixJ leviewmg me (x>llection of information Send comments regarding 
collection of information, including suggestions for reducing this burden to Washington Headquarters Services, Directorate for intoi 
Davis Highway, Suite 1204. Arlington, VA 22202-4302, and to the Office of Management and Budget. PaperwofK Reduction Pro)£ 

ng insiructions. searchinn existing data sources, 
this burden estimate or any other aspect of this 
'mation Operations and Reports. 1215 Jefferson 
ict (0704-0198), Washington, DC 2G503 

1 - AGENCY USE ONLY (Leav* blanlf) 

2. REPORT DATE 

September 1995 

3. REPORT TYPE ANI 

Technical Re 

D DATCS COVERHJ 

port - Final 


4. TITLE AND SUBTITLE 


5. FUNDING NUMBERS 


Megaprogramming in Ada Course: Lectures and Exercises 

s. AUTHOR(S) R. Christopher, L. Finneran, S. Wartik 
Produced by Software Productivity Consortium under contract 
to Virginia Center of Excellence 

7. PERFORMING ORGANIZATION NAMES(S) AND ADDRESS(ES) 

Software Productivity Consortium 
SPC Building 
2214 Rock Hill Road 
Herndon, VA 22070 


G MDA972-92-M018 

8. PERFORMING ORGANIZATION 
REPORT NUMBER 

SPC-94094-CMC, 
Version 01.01.01 


9, SPONSORING / MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

ARPA/SISTO 


10. SPONSORING/MONITORING 
AGENCY REIOFTT NUMBER 


Suite 400 

801 N. Randolph Street 
Arlington, VA 22203 


11. SUPPLEMENTARY NOTES 


N/A 

12*. DISTRIBUTION / AVAILABIUTY STATEMENT 


12b. DISTRIBUTION COOP 


No Restrictions _J_1_ 

13. ABSTRACT {Mwdnium 200 vmrd&} 

This is a short course that introduces novice programmers to .software engineering concepts and 
illustrates them using the Ada programming language. The course, which takes about two weeks to 
teach, is aimed at advanced placement computer science high school classes. It stresses problems 
that arise in programming in the large, particularly those caused by change, communication, and 
complexity. It shows how software engineers employ abstraction, information hiding, and software 
reuse to deal with these problems. The solutions shown are expressed in Ada. The students see and 
appreciate how Ada can help them solve real problems. 


The course material contains viewgraphs instructors can use as the basis of lectures. Each viewgraph 
has accompanying notes that show how to present the viewgraph and suggest topics for discussion. 
The course is divided into four units; following each unit are summaries, suggested group activities, 
and homework assignments. A comprehensive examination and an evaluation form are also included. 


U. SUBJECT TERMS 

Software engineering, software reuse, course, Ada, information hiding, 
abstraction 


15. NUMBER OF PAGES 
162 

1i. PRICE CODE 


17. SECURITY CLASSIFICATION 
OF REPORT 

Unclassified 


18 SECURITY CLASSIFICATION 
OF THIS PAGE 

Unclassified 


19. SECURITY CLASSIFICATION 
OF ABSTRACT 

Unclassified 


20. LIMITATION OF ABSTRACT 

UL 




• • • • 




NSN 75.10-01-280-5500 


Standard Form 298 (Rev. 2-89) 
Proucribed try ANUI Uid :.'39-l0 
290 102 






















CHANGE HISTORY 


Version Number 

Date of Change 

Change Description 

Version 01.00.05 

April 1995 

Original document. 

Version 01.01.04 

November 1995 

Title of course, copyright notice, and slide format 
is changed. 



















CONTENTS 


Tab 


Unit 1: Software Engineering. 1 

Unit 1: Software Engineering, Workbook. 2 

Unit 2: Abstraction . 3 

Unit 2: Abstraction, Workbook . 4 

Unit 3: Information Hiding. 5 

Unit 3: Information Hiding, Workbook. 6 

Unit 4: Reuse . 7 

Unit 4: Reuse, Laboratory. 8 

Test and Survey. 9 







a • 


a 


a 


a 


a 


I® (S 
















Contents 



This page inientionally left blank. 


• • 




ACKNOWLEDGMENTS 


Lisa Finneran and Steve Wartik created and wrote this course. Christine Ausnit and Jeff Facemire 
reviewed it for the Consortium; Jerry Berry and Lydotta Taylor served as external reviewers. Bob 
Christopher supervised the course’s development. Bobbie Troy lent her technical editing skills, and 
Deborah Tipeni and Debbie Morgan proofread and corrected the final version. 






Acknowledgments 


This page intentionally left blank. 






This material is based in part upon work sponsored by the Advanced Research Projects Agency under Grant #MOA972-92-J-1018. 

The content does not necessarily reflect the position or the policy of the U.S. Government, and no official endorsement should be inferred. 





'5^ 




O) 

c 

% 

o 


0) 

jC 


w 

3: 

U) 

c 

CO 


CO 

x: 

c 

5 

o 

■o 

CO 

5 

o 

o 

c 

<0 

X3 

3 

to 

u. 

3 

O 

U5 

<0 

CD 

« 

k* 

3 

O 

O 

w 

x: 


O 

CO 

(/> 

3 

O 

(/> 

5 


52 2r c 


o- 

CO 

■a 

o 

o 


<n 

CO 

c 


V) cn (0 c 

£®o'cn-2-ts 

i 2 2^^ ° ^ 

0)°-w « ^ 

I's-ge-- 

CT ~ 2 

■’O C .£ > BJ 

c -^ ■'^ <0 


E 

o 

E 


Q.-— CO 

g-W CO 

2 S 

CT'O .b (0 
=> Q.t= 


CO 


CO is 0) 


x3 ^ in C- OJ fl5 


cO 


crt 


= i_ CO 

1 s = 


B e _ 

c n .S 


c^- 

I 

c 

CO 


C" 

$ 

o 

c 

£ 

CO 

V- 

O) 

o 


CO 

CO 


CO S 

k. 

<0 
> 
o 

CO 
CO 

5 

ca 

x: 


o 

to 

CO 


2 O 


3 

o 

>. 

CO 

£ 

E 

O) 

o 


<0 

k- 

CO 


o 

CO 

CO 

CO 


o 

CO 

CO 

£ 


E 

E 

O) 

2 

Q. 

2 

CO 

o 

CO 

CO 

<0 


_ w o. (D 2 — (fl 

5 ^ oj E « - 5 ^ ■« 

§ ^ |.| B i 

^ CO 
O 

o 
'cl 

^ tl) 

> w 

to CO Tv - 

CO £ & o -a 

2 c *- c 

3 o /R 52 2 
o c O 55 o 


.52 

to Q 

<0 t; c^ 

b--^ o 5 = € 

gl^lEcO^^ 

CO ta ® ^ 
to cnc o E-^<i>‘n 
O. CO C o 
Q. C O to 
o o 


•52 23 


o‘»?a,o'S- 


C0-8B.5 &-S5-0 8 7 

|| >< >,« b o| 

2o tjCOCg'O^ 

2c5^§-B ^ 

3 cO Q p 


^6'° 


o 

o 


cO 


2 $ 2 
CO 


CO 

O) 

rt 

CO 

CO 

x: 


CD 

to 

O 


to 

c 

g 

"to 

<0 

3 

cr 


3 

O 

>» 

o 

■O 

5 

o 

I 


CO 

O) 


3 

o 

>> 

2 

3 


CO 

♦-» fc- t 

CL CO 

.^■§ 
r ^ 

= cjcJTz _'=cox: 


CO 
CO 2 
C3 5 

O) ^ 




E CO 0 § 

'to "b CO 
CO 2 2 cj 
CO > i: t= 

Q c to 

c — 3 


O 3 cO o 

o i: 


<0 to CO ’o) 


S> o 


E 

o 


>■15 

CO (0 

to x: 


c 

_o 

o 

CO 

■■6 

CO 


to 

E 

CO 

4-* 

to 

>s 

CO 

X 

b 

Q. 

E 

o 

tj 

ch 

■2 

CO 

■a 

g 

to 

o 

E 

CO 

CO 

c 

6) 

c 

CO 

CO 


CO 

CO 

3 

CO 

CO 


o 

'co* 

£ 


(0 

Q. 

<0 

x: 


I 

x: 

CT 

_C 

CO 

CO 

c 

CT 

c 

CO 

E 

CO 


?= o 


b 5 


$ 

o 

X 


$ 

o 


_ — ^ w oj ;= to ^ 

c eg s E-oc-^ Q 

-S-i2l"l8.2 8 


o 

o 

sz 

o 

to 


b) c 

X i5 


. c 

to CO CO 
b Cl) 

C3) 2 
CO cO 

g)B 


0^0)1^? E 


O) 

C ? cj)r— c 

fft o o 0) ,E * 

® E « ^ g ■= 




^ CO 
2 .i X XI 




UJ 

gc 

t- 

z 

Ui 

Ul 

X 

H 

X 

o 

u. 

(fl 

UJ 

> 

H 

O 

UJ 


E.'co 

Ti 

to .=, 


m 

o 


b 

JO 

CO 

CO 

X3 

g 

3 

O 

x: 

to 

CO 

c 

CO 

TJ 

3 

to 

CO 

X 

H 


co 

l-E 

si 

to C 

E 0 ) 

CD X 


o 

CO 


CO 

CO 


o 

CO 

to 

CO 

CO 

CO 

2 

■o 

TD 

CO 


$ 

o 

X 

•o 

c 

cfl 

•O 

CO 

ex 

g 

<0 

> 

CO 

■O 

5 

to 

CO) 

CO 

3 

o> 
c 
cO 


CO 

is. 

<- b 
•E X 

g u 

eXTO 
X c 
LU CO 


^ CO 
o O) 

p CO 

o x: 

c <0 

b -p 

^ c 
O CO 

P b 
- b 

to CO 
£2 

C 3 

CG E 
O.E 

X o 

LU O 


(8) 


! 


cO 

■O 

< 

^ -a 


CO 

CO 


X 


O) 


$ .E 

<- b 
E 0) 
b £ 
cx'co) 

X C 
LU CO 


3 

< 


i • 


1 



























flj ’? "S ® Q. 
c • ^ “t: <5- 

.2’=''§ o ■§ i" 

laiisg 

— >, s 0) T! « 
TD = -^ s: c w 
0) (0 rt ■*- 
> .9 P - Q) g 
o j= £ w p: ■— 

itli|i 

^ C3) 0) W c 

■^0 2^. Qj — 


3 05^ 


nJ « 

Q. C <0 


Q- > o 

c 5 « 

■“ O jC 
0) W 

£ OJ 3 

^ -C o 
O -C 
V "o 

.9 c o 

iC C3 ^ 

1- q.£ 


w <- o ^ ^ ^ ^ 
3 S = tj ">£ £ 
m 4:; rt .0), CD ^ ro 

^ 0-0 2eE^ w 

CD c .y ^ 
cn |5 ® W ra a 
CD " £ CO CD £ .t; 

c £ 52 ra ^ 

lo .2 0.0 g .!= D 
Q-e e £ « CD 
£ 2 o "D o OJ .c 

o £ cj CD o ^ *- 

0 E f- c T3 |_ ♦; 
... P § .S> CD S 

2 “ ^ !g .E ^ « 

5 g g C§ - ffO) 

“'-S.g-pl 

I E.2 

S s O’ O'-r 

CO Cfl ,e “Jr > 01 (Q 

'»-><wOcDC- 
^ o >- "O p 

C CD 2 “ <D C .2 
is -o is 5 o 
E gc^E § E o. 

cd|^ i| 8’.^ 

CD o O o lI o 

> Cfl 5 (J, w Q. 

^ o I 

^ , d CO Q.'g 

S' CD 3 • CD p E 

^“8i« o £ 

<D CD to £ S > 


■;l « x: w .E c CD 
- “o ° 0) C o •§ 
D)<2 b .2 o 
C C ^ 2 trt C) 

•p 0) (0 > CO 1_ c 

E p D.40.2 CO o 

E g g S’ E 

2 .2 0) p cc TJ 

r*n <T» “ fli ^ ^ 


2—2 p ■.= TD 

g’gll g,E.2 s 

dI ■§ i « 8 ;e .2 


CO CO CO CD 

o g C.E 

CD E CD CD 
C 3 p C 

■|8 2^ 

§ CO 3 

2 O O CD- 


o CD x: O 

CO .c -^ *= 

*" t! « -3 
>.eD O’ 2 
CO T3 E 

o 1 § c 

Q .C O 
CDrg CD 
c Cj ■□ 

•K . CO (D 

1^2^ 

C O)^ 

C (/) c 

0) G> o g 

-g^o-g . 
S 2 • S-^ 
Q-lo£ 

Jr 5 Q. Q. CD 

i8i2| 

^ CD CD eo = 

^ .E >- 5 .2 

2 

t » CD := 
® Jr 2 52 CO 
CO O -E ™ CL 

c T, 2 

•E p; <D 2 

liisi 

= 0) w ^ = 

2 g.®z^ 

^ ” i: CO 

C 2 ^ w TO 

o 1 - o S .£ 

<a 9*'°^ 

TO E CO co 2 

C O CD O S 

fO to CD o 3 

x: g E = i3 

O g « CO . 

O O) O oj <? 
C TO CD 

I 

■ 

’ ^’.^2 d)E 
t ° S g 2 
.2 o E 3. 
!2 co CD ? 

i E o 

o .c .b 52 

CO i_-o.— 

< .« £ .E E 



</) 



£ 



<u 



w 

05 


>» 

(/> 

E 


£ 

cO 

? 

c 

0 

s 


0 

CL 


CO 

0 


0) 

0 


05 

> 



0 


jg 

TJ 


05 

"m 


C 

■•-* 

0 


’q. 



0 

0 


0 

x: 


> 

♦- 


0 

-0 

'S 


c 

0 

05 



0 


c 

03 

■e 

C 

0 

0 


0 

CL 


a. 

0 


E 

Q. 


0 

lo 


CO 

E 


w 

0 


c 

CO 


0 

(0 

b 

’<*-* 

CO 

0 

+-» 

CD 

E 

0) 

'c 


J3 

05 

3 

E 

Ui 

C 

0) 

E 

‘■B 

ja 

0 

0 

;u 

0 

0 

3 

>. 

>> 

0 

JT 

X 


5 

> 

(0 

c 

c 

w 

•♦-» 

'ffi 

‘cO 

c 

<D 

"D 

3 

Cb 

X 

LU 

Q. 

X 

LU 


I 





Programming in-the-Large 





(§) 


I • 


• • 





i'S? 


I 




</) 

c/) 

Z3 

O 

tn 

a 


>» >» 0) -ti 

iz <D »- w 

'5> oj £ ^ 
■c J 2 o - 

o 3 

_ U 0- ia 

rt ? PE 


0) ■ 


(C 


<D -D O 

S:2- 
m E 


E 


o 

D) 

C 

'C 

0) 

0 ) 

c 

O) 

c 

0? 


° dj fl) 
« CD £ -C 
o c rt *- 
O ® t; 

-« H ° 

CD w .5 
3 to W £ 
f— 

^ -n ‘ 
— o V 
O 03 C ^ 
w ■ 


■D 

03 

-C 


«■! 


E 

o 


<0 

•O ? CD 

■Se c _ 

-c S CD O 
® £ CD' 

CD £ SJ C 

0) (5 '5 S ^ 
cr (S 

CD Js - 
'" X o 
/-n CD ^ 
CT * CD 
■E CD Q 

g>J5 « 


<0 


c 

§ W 

o -a 
c 


CD 


2 

CO ® O .S *5 

« w 2 c 
E £* c: Q..O 

B -3 0) TO 
w 3 c 5 ffi 
P c u o § 


E c 
re o ri 
5 -a c 


° x: 0) ™ 
•p x: -t 
©.£■"« 
£ T3 5 £ 

0) 0) O o 

O « 2 *- 
ere . <u 
5 ® in > 

c £g ^ 

® S’:: a 


w 
re re 

3 *- 

E ® 
re 

O V) Q 2 

2-Srcn 


c2 

•2 g 

SO 5 


O 


CD 


O > 03 </) 

CO -Q — 

9 O CD^ 

2 .9 o 
u. 2^ o 

■s > 

1 ^ « iG ? 

2 p r- <r> c 

cS ^ g? i 

. P ^ o: 

i2£ 


3 re § 




p 


e 2 

e 05 

3 c 
«'6) 


‘^Q. 
p E 

o£^o ^-O 
w c c _i c 

® >- . ® 

O 3 P to C 

S' C3--0 t; ^ 

m P C o 'Sj 


re 


p 
i ^ 


5 -o 

p — Tf 

a"® 2? 

.2 ® z:^' 

p .9 p *' x: 

F re -a r 

P ■o 'e p 95 
cj re £ g p 

§33 2 S 

p-2 

« ® 

re re 3 ? p 

re 2 p 5 

■*— • t 

VJ 10 ^ 

•C $ O) ^ 

P 6 CD 
O XJ 

2.E-S. - 

CD TO 


^ s ® 

P O C 
O CD P 

?s,| 


p 

<5 

jC 


re 

x: 

O 


c 

g 

"(3 


* 

re re £ 


p CD 


03 ^ 

O) *0 

3-3 ® 


c 

03 

'55 

0) 




t§l 

O O P 

c-g'E 
« o 2 

£■0 3 

2 0 - 
o p 


■*—■ III - 

O W 


2 

o ■« - 

E CO „ 

-o E 

—* ♦- 03 


<*>-» ^— w 

2 *0 4:? 

8 ®o 

•n ™ ■ 

C 23 
CO fc o 
oB° 

^.£ p 

isf 

® p re 

^ p 


£ i - 
B ^3 

|st 

.2 o 

P Q. 2 
is rr-c: 

re ■“•*-• 


P 


re .<2 

x: ^ 


e T ^ re 
• n p P T3 

^ c -a 

S " ^ g 

re's o-E 
32 ocd._ 

■^Sio — Q39>^^(0 

hS -a ? o 
c 3 S P 
Z) xj 4S Ti S 


x: OP 

D) - 
C 

f 

P 

n 


■p 

p 

a. 

.Q. 


p Tj ._ 

rt^3 p 
— re re 


re$ 

x: 

o S 


a.e 

■P 


re 

P 

x: 


" ^ lU to 

C .2 CD T> 


O) 

p 2 
XI (0 


5 TJ' ^ 

^ 2 O 
re .y re 

o re ® . 

W gjfi XI 
2 CD P 
2 >,0-0 

PTI t 8 

f£3a2 


c 

(0 

O) 

c 

*03 

c 


>. 

o 

*</) 

*c 

o 

0) 

Li. 

o 

5 

4= 

o 

re 

p 

p 

_> 

o 

re 


■C 

p 

c 

CO 


re 
« 

'C 
u 
re •£ 


n 


o 

re 

p 

xr 

re 

P 


TS 

P 


p 

03 


<A 

O) 


*D 

0) 

O 

o 

”D 

O 


c 

0) 

E 

Q. 

Q> 

> 

03 

T3 

0) 


C ^ 

§ I 

XI 5^ 


s 

<0 

x: 


CD) 

C 

c 

p 

p 

c 

O) 

c 

p 

2 

re 

S 

4 ; 

o 

CO 


c^. p 

o>J; 

•i i 

8 ° 

> 

E£ 


'*- CD 

^ O 
3 CO 
TJ 

P .. 
x: c 


o 

re 


■o P 
•F - 

■E o) 

p CO 


re p 
c £ 
p o 
£ re 

p 3 
.!= O 
3 

cr c 
P ■« 

W. tu 

o)-S 
c o o 

'55 . S 
o re .9 
3 o re 
o P .9 
- E o 

q>2 I 

P 3 c 
^0-0 
re p g 


E 

^ O) 


X) 

o 


£ ■§ 

^ c 

^ p 55 


CO 

S 

O S 

<0 5 
o O 

’i 5 
SS 

I ^ 

D 2 


•E >“ 

p s 

i Q 

CD p 
c H- 
p V) 


m 
c 

_ D) o 

Q. c 5 

re t. 

p X p 

re o x; 
P "K 

X k, o 

c: 

H— — 

p c if 

|§ = 

O CTO 
> 're P 
5 P > 

19,3 


CO 

03 

C 

> 

o 

c 

o 

c 


c 

03 

E 

*5 

cr 

ff 

D) 

C 

‘03 

c 

o 

jC 

O 

c^- 

03 

0) 

X. 

o 

o 

CO 

03 

JaC 

CO 

E 


o 

o 

$: 

o 

jz: 

V? 


c 

03 

E 

'o 

cr 

03 


jO 

3 

o 


O 

o 
c 
,0 

■O 
•O 

V. 

^ 0 
E 

3 S 
O re 
>v 3 

C “ 

re ® 
O E 


p 

c 

■ 5 . 

o 

w 

D) 

c 

"C 

p 

p 

c 

CT 

c 

p 

2 

CO 

$ 

4= 

O 

re 

re 

o 

•*-* 

■ . •D 
O p 


UJ 

> 

p 

o 

Ui 

-3 

m 

O 


p 

X 

CO 

p 

X 

2 

3 

o 

X 

re 


c 

p 

X 

3 


P 

X 

I- 


re 

X 

<*-• 

re 

E 

p 

X 

9 

X 

p 

X 

p 

s 

w 




Megaprogramming in Ada Course: Software Engineering, 1-3 





Software Crisis 



y o*, 
-o g> 
2 2-0 
a $ =1 

o >-Q 

is 5 o 
^ *o o 

eg O “O 

O 5 i 


•& </) 
W ■o 
'■? 0) 
ro o 

V/ ^ 


^ E (/> ^ 

£ w E c 2 

W 0) O _ 0) c 

= S: o O) c 0 ) ^ 

p CO o c c j2; 3 

5 <o’5)£c:x“ 
^ 5 +- 0)0 0. 

o o2«ct-w0E 
> tf) o ^o 

o> 

1^1 I 




























































DISCUSSION 

Let’s take a look at the major factors for change surrounding large software system 
development. From the previous slide, we see that large software systems must accommodate 
cha ging requirements and design. When thinking about the types of changes, realize that large 
sof-.vu.re systems exist for very long periods of time. Consider the space shuttle. The software 


0) Q. 
x: 3 


.2^ o) 
^ c 
.9 03 

O' 03 
"D 


J O) 

c c 
03 

JZ .w 
(D Q 

o cn 
■*" c 


CO CO 

•— w- 

-g. 
.e ° 

^ 03 

O) 

O 03 
O)-? 

|o 

o 0 

03 
0 TJ 

h' i 


CO 0 
0 O) 
03 "O 
C 3 
03 XI 

03 


^ c 
.9 0 

0 w 
> 03 

0 X 
•O I- 


C-. 0 

w c 

g’E 
0 0 
-c Q. 
“ E 


c 

« .25 

0 O 

CO 0) 
JC 

c ■<- 
O c 

'■s; o 

o w 
c o 

R 0 


o ^ 
-Q (1) 

■u 0- 


h- 

— 03 
>>.> 

5 E 

0 0 

> 

C ‘4= 
03 C 

z 

> 03 

> "O 


"O 03 

LIJ 

0 

-T- 0 

X 0 

u 

IIJ 

3 "O 
0 

3 

h” 

cn 

• 

• 

“3> 

CQ 

0 

03 • 

x: 

1- 









Reasons for Software Changes 


a) ^ 

c <» s 

h X J2 

LU;;; cc 


M I 

?i 

(C o O 

5 o> C 
■a c 2 

<0 £ c 
X U UJ 

□ m 


c 

.2 

« S £ 

§ I g’S' 

I p ? ^ 2 


Tk O 'Jt d) 

t> Q, o ,2 n 

o c fl> !t 

Q .E CCo O 



inomomoLOOino 

'^^CQCOCMCM'r-'i— 

oBueijo aBe^ueojOd 


• • 

























DISCUSSION 

Software engineers do much more than just code; data on software development shows only 
15% of their time is spent in coding. Gathering requirements and producing a design involve 
various communication skills. For example, usually a team of software engineers elicits 


o « 

fl 

“■ N 
03 5 

£ a 

o o 

P 


■Q to 
o P’ 


03 

CO 

03 

x: 

I- 6 
Z 

o . 

03 (0 

‘o'-S 

03 ^ 

5§ 


C Q. 

.1= E 
0 ) o 
■P o 


03 O 
03 

0) Q. 

— p 

- p 

s ^ 
i 2 
05 B: 

.O CO 


I— CL 


(0 C 
£ .05 

fl « 

la 2 
o I o 

% o ^ 
?^o UJ 

Ei2 S 

c , 

<I> 0 r" 

CO E S 

03 lu 

03 Q 

■O m 

H 2 « 


O 

0 0 
JZ 

O) Q, 

c 

0 

B S 

C CL 

o 9- 
o p 
u .c 

•}± x: 
035 
E'^ 

O ^ 

O 03 
>'JC. 

0 o 
E 

0 o "O 
X5 03 

2S2 

Q-‘c P 
0 p 9 
E !?S 
S ° 

trt — O 

~ O- o 
E x: 
5 P Q- 
O X P 


o ^ 


° § 
0 E 

P o 

0) o 

.Q >. 

1 s 

O TO 

I— 

0 0 

0 0 
4—* k* 

C 03 
0 "O 

■o C 


I • 


• • 





0) 

Q> 

■- C 
13 O 

0"4= 
(D <0 

DC O 

>« C 

Si 

fi 

c O 

o 

o 



@ 

■# 


a. 




DISCUSSION 

As you can see from this pie chart, software engineers spend the majority of their time 
communicating. In fact, they spend over 35% of their day communicating! Communicating 
encompasses many different aspects: 


U) 

Ci 

E 

o 

(/) 

D 

O 

k— 

o 

c 

<a 

0) 

Wa 

0) 

( 1 ) 

c 

‘cn 

c 

0} 

<D 

k— 

CO 


o 

CD 

sz 

o 

o 

O) 

c 

c 

CD 

cn 

k— 

o 

O) 

c 

12 

CO 


CD 

O) 

CO 

c 

CO 

E 

CO 


CD 

E 


CD 

xz 


o 

CO 


CO d) 

3 C 
§ CO 
£-1 


•O 

c 

CD 


<= XJ 


n 

CO 
CD CD 


8 


CD 

E 




> 

CD 

C 

1^ 


3 

■o o 
^ cO 
CD ^ 

2 H 

CD • 
CD 

^ r- 

bz C 
CT <0 


5 -S CD 


cn 

k. —■ 

O 

5 oj 

|l 

o CD 

•C C 

CO "tQ 

.i’-e 

i 

o £ 
CD o 
*- O 

.S' c 

CL O 

i cn 
cn 3 


in 
£ 

£ £ 
o) <5 

2 £ 

CL O) CD 


c 
o 

C3 '-S 

.. CO 

x-£ i. 


CD O) 

o 


CD 


■C cn 


si! 


co 


*= o 


-6 

^ -a 

B c 

I. CD 

O Q- 

cn 


.E Q. 

C3 3 

C o 

5) 

2 cn 
CO cn 
S P 


cn o 
•£C0 
CD . 
X) CD 
3 "Cl 

^ R 


0) 


o 

CO 

cn 

CD 


o 

cO 


C O) 

o .E 
•O CO 
o .E 
■o 

Ti o 
TO CD 

.i= C o 
CD CO .Z 
C T3 
CD P 


c 

3 

cn 

k_ 

CD 

CD 


OJ CL 

55 O) 
$ C 


o P 
E ■o 
c p 


o E 

W 5 


S-'3 
8 ^? 


o >^ 

XD P 
jC 

>k-*^ 

Is 

D> 

£ "cn 

CO CD 

xz -a 

ra'o 

g'o 


0 


cn 

Cl 


D) 


3.-^ 

E X 

c P 3 

ig-R 

CD E 
O r- 
P O .E 

O 

P CJJ ^ 

o to S 
P o 


X3 

CD 

P 

C 


c 

X3 3 

^ E 

0 C 

cn o P 
o x: 

2 o*" 

CD 

P CD 


</) 

z 

2 c 


0 0 

X3 

2 O 

;P 0 -i: 
O P P 
P P £ 


W 

a...* 

c 

0 

E 

0 

k.. 

3 

cr 

0 


O 

< 

QC 

UJ 


U1 

a 

3 

I— 

W 


P 
.i= ^ 

By- 


0 

<n 


3 C>- 0 

O P TD 
><TD C 
O 3 

P ^ n 

•p CD-2 

^58 


HI 

> 

H- 

O 

Ui 

-> 

OQ 

o 


0 

Xi 

0 

P 

XI 

P 

3 

O 

c~ 

tn 

U) 

•*-» 

c 

0 

XJ 

3 

4.^ 

0 

0 

.C= 

I- 


0 

0 

C 

O) 

c: 

0 

0 

k_ 

0 


o 

« 

0 

u. 

o 

0 

o 

c 

0 

tz 

o 

Cl 

E 

c 

0 

x: 

o 

3 

W 

Ui 

>k 

_0 

Q. 

C 

o 

0 

O 

’c 

3 

£ 

E 

o 

o 

>> 

x: 

c: 

0 

CL 

X 

UJ 






• • 


0 


• 9 


Megaprogramrr.ing in Aria Course: Software Engineering, 





How Do Software Engineers 
Spend Their Time? 



Copyright © 1995, Software Procfuctiv!t^onsort!Imr 




DISCUSSION 

The discipline of software engineering emerged to solve the software crisis. Software engineering uses sound 
engineering principles in the development of software systems. The main objective of software engineering is to facilitate 
the production of high quality software systems within budget and on time. 

This course concentrates on three aspects of software engineering; 


^ OJ 

■S' o 
'x c 

0 3 

Q. E 
E E 
o o 
o o 


5 $ 

(/) cn 

jQ. ^ 

0 0 
-c ^ 

Ui D) 

c c 

'k_ 'C 
0 0 
0 0 
c c 
O) 'o) 
c. c 
0 0 
0 0 


— OT aj o "o 
p 03 x:o 0) 

_Q) Q ® ^ 

■Q d P 9? -o 9? 

o E ^ OT n *" 

t aj OT « 

-■9 Dj® S 2 


0 ? 0 
« 0) .-2 -iS 


« 0) .52 

2 ® ” g^'i O 

° ° ‘F ® 3 .2 

>“ 0 ) £ m g o 

CL O _ ^ W 

0) TO 55 

2 n O 5 03 "C 

-C CL ^ ^ T3 0) 

W CO to O 3 -Jo 

^ O ® 03 O 


■g 

a> 

■O 

3 o 

Jt: 

£ 0 

a> 

0 E 

0) 

E 0 

-C 

C O-' 

0) 

.2^ E 

N 

0 - • 

E 

0 n 
O c - 

c 

0 ^ 


ig-D-5 C_J 
C 03 §,-^ 

^ .23-c i= U) D 

■S3 2 .2 <0 0) o' 

0.0) TO C; Q c 

^ S I g .£ I 

:i cn ^ o iS 

^ ® O c -i “ 

To g I g 

2 0) .2 o g I 

(/3 d) ‘jr C k, $ 

o S5 -S c o 
^ ^ ^ o _g) (/) 

-Q ^ >.^ ‘w r- 

o> « II -S I 

-Q > ^ 3 — 

^ ^ j= 9 o o 

g c g)>'xi g 

® £ == o. 


-g O g CO ■§ 03 

o "3 0-0 E c 

jc « ^ 2 c w 

tit "S^ 03 £ c 3 

E m2 ® E „ 

C 3 03 ^ o QJ 

.03 cn Q c C w ] 

-o JD CC 0) -c " 1 
0) g w 5 2 , 
og’oMog! 
3 C :E O E £ 4 

O CO 0 (CJ t o 0 

> E E ! 


2 t? o w E 
0) «3 §,03 ra 

o CO E E CL 
>< c CO 

l'"S|8 

■§ O o to£ 

^ D>^ h" 

O $[( • 

fc m 0 Q. W 

0 -o it: O 0 

« >»^ ° E 
g o .N I 8 

i§|«g 

,2 .E V) .2 

1-1 ^ « 

0 £ 0 > 
a E^£ ? 

. 0 c/3 0 o 

0 Q.'^ 03 c 

® S £ i :s 

1= +- 3 :£ ,2: 

2 O' "o 

C CO oj C33_ 

0 0) O 2 
E .C 0 O 3 

Q.- £ -Q o 

^ .52 _ "o ^ 

Q) .2 C 3 

■D O .S E _ 

0t^2 O E 

t. .0^0 
g P o O 5 
5 2 o t. o 

cE § CO CL ^ 

8| E ® 0 

0 8 g ^ ro 
0 so "o ^ 
o £ 8 w o 
"3200” 

8 3 £ .2 ® 

CD JO *- Q.*- 
_f ~ ^ 

Q.= 3 C O 

— 5 J3 05 (/j 

O 3 ® 2 £ 

O §,0 g Q. 

- s-js 

r- > 3 .Q 0 

0 O OE 0 

t >•— 0 

0 0-3^0 . 

CL 0 2 -flj .0 0 
E <3 £ > Q. 0 

52 2 5^5 -8 "o 
C 8- O E N g 

2 C o 0 Q. „ 

0 .03 0 0 

.2 0 3 0^0 
C fl) o 0 
go >^0 o’g 

E 2 I £ c g 

C3 3 = 0 j: “S: 

O.Q to 5 F 2 


3 .E 

2, © 

Q. 

0^ 

0 0 

J= Q. 

ccJ 

0 Q- 

■O “t 

O o 

g <1> 

0 o 

c, 0 

■q. 


W o 


^ ^ ' 
ll I HN 


0 ^ 

^ ■§. 
0 _ 


0 ^ 
JC 0 
C03 03 

•E .E 

0 0 
0 0 
.E .2 

03 ‘03 

c c 


.Q *- *- 

0 CO 55 

0 B s 

^ ^ ? 


0 0 
JC j: 


I S- X 

E LU UJ 







Large Projects Demand Software 

Enaineerina 


^ c 

^ «) .2 
■z 0) -5 
(0 o CO 

■n ^ ^ 

O S £ 

S £ £ 

• • • 



O C « 

CO (A O c 

s « i i 

3 ^ g o £ 

E a> 1 

£ < S ■§ a 


X ^ 

0 ) E 

o E 

E .5> S 
o S S 

O Q QC 



Megaprogramming In Ada Course: Software Engineering, 1-7 Copyright 61995, Software Productivity Consortium. 













DISCUSSION 

The U.S. Department of Defense (DoD) is a major developer and user of computer software. In 
1974, the DoD and its contractors were using more than 100 different programming languages. 
This made it difficult to reuse existing software and transfer software engineers from one project 
to another. A single standard programming language was needed. 




O (A 

II 

c w 

(A 


■o 

o 

ca 


u> 
w 
'in 
_ O 

':= 0) 

o 2. 

45 § 

.c O 

<0 

C3 i= 

p CO 

OS T3 
~ <D 
OiM= 

1'^ 

E 03 

E2 

2 <A 

cc 2 of 

0) S ^ 
> o 

^ 0) TD 

2-o.S 

03 CO 0) 

M S - 
O 03 

O « D) 
— O C 
0 0-2 

CO c “ 

'C o 

CO °-r- 

5 rao 
-S o 

Q it 

Q 

.b CD 

03 ^ 

.C C 03 


03 CD 03 CD 
0>JZ JO s: 

CO ^ 

i' 1'5 a 

n <0 S ® 

^ E .Q 

03 2 03 CO 

£ ^ 2 “ 

I— CO CO 

CO CA .--c 

-515 

T3 05 —* 5 

CD C33 

^■*“0X3 
^ C (A g 

Hfi 

cO ^ 3 
"5 03 (j j= 
r3-o . 5 

c= 5 iS c 

■o 00 ct-9 

■i .E CO 03 

^ '-E E 03 

C/3 CO "O ^ D 

S g- 

W --1 O 
03 qi CH CD cj 

03 o E CO CD 

COO^"^ — 

D E /rt -O 

03 Q- ^ ^ 


c 

CO 


03 


.£ 03 

e:: 

E g 

03 o 

p 

Q_ CO 


.O 5 


E 

E 

CO 


C .b 
03 


CO 

< g « 

CD "O 
03 -a 

£ '= § 

I— o $ 


- CA 

O 

>. 

CD ^ 

■2^ 
O 03 
—I c 

- .03 

CD CA 
O 03 

a-D 


CO 

CO 

x: 


o 

c: 

0) 

u. 

CO 


>% 

c 

CO 

c 

o 


c p ® 

2^‘q- 

o 

co'S = 

o$| 

LL g < 

^ C 
CA •— 


T3 « 


5 


03 r- 

-N I- O 

■o 

CO "O 
■p CO 
5 CA 

CO C C 

cfl i5 S 

•4— CO 

CD w ^ 

O) 

CO o 

O “O ^ 

<f Q- 

■) 

no ^ 

gs 

i5 CD CO E 

O 

03 CD CA o 

^ x: — 

■f— CO 


_ 

03 03 
03 -O O 

Ql . ^ 

E «= 


C T) . ^ 
C CD 5 
E 'w 

CO ^ cO "D 

2 c c® 

Q. CA ^ jP 


CO 2 CD 

o.-i£ 
?■'- 
s ° 

CO CD 

go® 

f is S 

y CO 

CA <• :g 

0> -r- ^ 

^ p 


lo P 


C t; 


CO 

> 

CD 

CD 

C 

'c 

'cO 

•4-f 

c 

o 

o 

L- 

03 

o 

Q. 


*-■ CO c n. 

'9.'9 ® E 


X 

Q> 

CL 

E 

o 


03 

sg-CA 

03 

CA 3 

2to 

3 03 

S « 

03 
03 £ 
C« 

03 £ 
-C 

o o 

>s 
03 CA 

2 £- 
p o 

O <0 
CO p 
03 < 

*- 5 

3 O 

o x: 

CO 03 
CA 

ll 

i” 


CA c- 

.— !s 
•?= CO 


CO 

CD 


x: 

$ 


CO — 
> p 


SJE 

= I 

CA I 


■e 

o 

g:sx 

O 03 
CA CA 

o 

o 2 

'=p 

■t p~ 

O D) 

§:^ 

sz c 

n 


u 

c 

o 

E 

E 

o 

u 


CO 

1 
45 
CD 

CA E 

™ O 

C73 

CO r 
O CD 
03 

c 


03 


(/) 
z 

03 g 

P3 tr 


O 

< 

cc 

UJ 

H 


c c: 
o .2 _ 
3 -S? — 


CA 

?. 9 - 

1 .S 

o ^ 

03^3 

E-i 

Q. 03 
03 
03 C 

£ 03 

c 

CA 0 


I- 

Z 

UJ 

Q 

3 

I- 


0 

o 

■o 

o 


0 

cO 


0 

JQ 

CO 

0 

XJ 


d MMK 

o £ o C/) 


UJ 

> 

O 

UJ 

“3 

DQ 

O 


0 

0 


O 

in 

in 

in 

0 

I— 

T3 

■o 

0 


T3 

0 

Q. 

O 

0 

> 

0 

P 

V) 

0 

5 

0 

03 

0 

3 

03 

C 

0 


C73 

C 

E 

E 

0 

L. 

133 

O 


0 

T3 W 
< 0 
C3. 
0 O 

sz c 


o 

3 

o 

x: 

in 

CA 

c 

0 

TD 

3 

V) 

0 

x: 

H 


£ 5. 

2 03 

£ c 

k. 

— CD 
CD 

i3 E 

s-'g 

LU 0 







» 


9 


Megaprogramming in Ada Course: Software Engineering, 1-8 








MepaproKramminK in Ada Course: Software EnginccririB, Workbook 


UNITl: SOFTWARE ENGINEERING 

UNIT SUMMARY 

Much industrial software development produces very large software systems, consisting of millions 
of lines of code. Such a system takes years to develop. It’s a team effort, not an individual activity. In 
fact, a software system is typically a joint effort by several companies. 

Your Computer Science courses have probably concentrated on writing code. To write code requires 
many skills. These skills include mastering a programming language, using algorithms and data 
structures, and using a compiler—all fundamental skills you need each time you create a program. Yet 
despite the need for these skills, they are not the most important ones professional programmers 
possess. Writing code is the smallest, easiest part of developing software. There are other activities 
that consume far more time and require much greater skill. 

Programming in-the-large (that is, developing large software systems) is very hard. Most large 
software systems are delivered later than planned and contain bugs. Many people even believe this 
country faces a software crisis because programming in-the-large is so difficult. 

Why is developing large software systems so hard? Much of the reason stems from two factors: change 
and complexity. We will study change and complexity in this course. 

Once software is written, it changes. This is a fact of life. When you write software, you seldom 
anticipate all the ways it will be used. (Consider that, as of this writing, Microsoft Corporation has 
produced six versions of DOS, six versions of Word, and three versions of Windows.) Also, you seldom 
discover all the bugs. New uses and bugs call for change. The problem with change is not that it occurs, 
but that implementing a seemingly simple change often require.s huge amounts of work. If you’ve ever 
made a change that rippled throughout your program, you understand why. Then too, think of how 
much more work you would have if you also needed to change user’s manuals, installation guides, and 
other supporting material that accompanies large software systems. 

Programs are complex because of the sheer number of details inherent in them. No doubt you realize 
that the larger your program, the more things you need to keep track of. But really, complexity only 
truly manifests itself in team settings. Though you may understand your own code well enough, you’ll 
experience troubles explaining its inner workings to someone else (you’ll have a chance to try in 
Unit 2). Therefore, when you write software in a team, you spend much of your time communicating 
with other team members about the software. You also spend much of your time writing technical 
documents that describe your work. Management briefings, user’s manuals, and design reports are 
examples of such documents. Therefore, complexity necessitates communication. 

Change and communication make developing software potentially very problematic. For this reason, 
this course shows software development to be an exercise in engineering. This is why Unit 1 introduces 
software engineering as the preferred way to develop software. The dictionary defines engineering as 
the disciplined application of science and mathematics in making systems that are useful to humanity. 
Software engineering is applying science and mathematics to help you make useful software systems. 

When you practice software engineering, you follow a software development process, shown in 
Figure 1. The process breaks software development into a set of coherent steps. In each step, you foci' s 
on a particular aspect of developing software: 






In the Requirements step, you focus on the problem you must solve. 


• In the Design step, you focus on organizing a solution to the problem you defined in the 
Requirements step. 

• In the Code step, you write source code, implementing the plan you created in the Design step. 

• In the Test step, you test the software you created in the Code step to be certain it meets the 
requirements you defined. 

Focusing on specific areas in each step helps you deal with change and communication problems. 



Figure 1, The Software Development Process 

Programming languages can also help you deal with change and communication problems. In this 
course, you will learn about the programming language Ada. You will see how a software developer, 
through careful and correct use of Ada’s features, can facilitate communication of necessary 
information to other softv/are developers in a team. You will also see how developer.s can use these 
features to lessen the workU ad in response to change. 







MeRaprogramniinB in Ada Course; Software Engineering. Workbook 


UNITl: SOFTWARE ENGINEERING 

GROUP ACTIVITY 


Communication 

Your Student Government Association has decided to purchase a vending machine and wants you to 
build it from the following parts: 

1. A money acceptor 

2. A change dispenser 

3. A set of food dispensers 

4. An item selector 

Split into groups. Allocate the parts among the people in your group. Working independently, 
everyone must write down which other parts they think will interact with their own part. When 
everyone is finished, get together and compare your results. 






HOMEWORK 


Look up the definition of engineering in a dictionary. What does it say? Based on this definition, what 
do you think software engineering is? 













McRaproRramming in Ada Course: Software Engineering, Workbook 


UNITl: SOFTWARE ENGINEERING 

TEACHER NOTES FOR EXERCISES 
GROUP ACTIVITY 


Communication 

Your Student Government Association has decided to purchase a vending machine and wants you to 
build it from the following parts: 

1. A money acceptor 

2. A change dispenser 

3. A set of food dispensers 

4. An item selector 

5. A coin return button 

Each of these is visible to the person operating the machine, Behind the scenes, however, they work 
together to provide people with vending services. 

Split into groups. Allocate the parts among the people in your group. Working independently, 
everyone must write down which other parts they think will interact with their own part. When 
everyone is finished, get together and compare your results. 



Figure 2. Interaction Among Vending Machine Parts 

That is, the money acceptor lets the item selector know how much money has been fed in to date. The item 
selector notifies the food dispenserwhen the person makes a choice and arranges for change to be dispensed 
if the person has fed in more money than the item costs. The money acceptor also notifies the coin retiini 
how much has been fed in; if the person presses the coin return button, then the coin return has the change 
dispenser provide change. 

This is only one pos.sible solution. When students do this activity, they will probably come up with conflicting 
ideas of how the parts interact. Of course, if they had agreed on how each part behaves beforehand, they 
would not have had this difficulty. 

This activity illustrates the need for communication in software. Too often, group members begin working 
without a clear idea of what everyone else is doing. The result is akin to what the .students will experience 
in this activity. 


• •••••• 













MeRaproRramminR in Ada Course: Software Ensineerins, Workbook 


HOMEWORK 

Look up the definition of engineering in a dictionary. What does it say? Based on this definition, what 
do you think software engineering is? 

Dictionaries define engineering as the application of science and mathematics (some add arts) in order to 
make properties of matter and nature useful to humanity in structures, machines, systems, or processes. 

Software engineering then, is the application of science, mathematics, and arts (to appreciate the artistic 
component, look at some modem multimedia applications) in order to make properties of matter and 
nature useful to humanity in creating software systems. There are two types of properties: 

1. Properties of matter and nature. These come from the problem you ’re solving. For example, if you 
are writing a program that calculates the time a ball takes to fall when dropped from a certain height, 
you use properties of gravity as determined by the laws ofphysics. 

2. Properties of software. Software is not matter, and it does not occur in nature, so we must consider 
its properties separately. Software properties include algorithm execution speed (the big O notation) 
and memory use. These properties are what make up the discipline of computer science. 












DISCUSSION 

Software complexity is a major issue facir»g large software development efforts. Abstraction is 
one of the fundamental ways that humans cope with complexity. An abstraction provides a 
simple view of a problem by summarizing the interesting and essentia! properties. In other 
words, you emphasize details that are significant and suppress details that are not. 
















Megaprogramming in Ada Course: Abstraction, 2-1 Copyright © 1995, Software Productivity Consortium. 













































Planning a Trip? 


■D 

o 

o c 

c 2 < 

3 0)0 
O C i- 
>* ■= W 

*D W 

11 

^ £ < 

M O 0) 

^ ^ o 

c > O 

4.1 ^ 

CO 4= ■ 

Jz ^ O 

5 2 Q 


(0 T3 

■o a 
0) ■? 

<u 

C J 
3 O 

§. - 
4. 

2 o 2 

=3 

o «J 2 
> 


(0 

2 

iO ci> 

c o> 
^ c 
o < 

H- ^ 

CO o 

O Jj 

4— 

o o 

a Q. 
(0 (0 


I I I 


0) c» 
o 0) 
c Q. 
^ (0 

o E 

iE 0) 

•o 2 

5 £ 

(0 2 

z s 

CO ^ 

6 HH* 

5 5 






• • ' 







Megaprogramming ir Ada Course: Abstraction, 2-3 





Abstraction 




g (0 


c d) 

O il 

(0 o 

8 g, 

1 ^ 

c 

</) « 
o <i> 

s S 

H E- 

4> 3 

« ? 

£ n 

S o 
i? s c 

5 tr o 

2 

Q- w E 
o S 

.j- w 

O *-» r* 
C .= 
5 CO m 
CD > ^ 

> ® ^ 

< <D *fe 

iL. O 


w fl) 
o "D 

■Q +- 

*- s 

C *0 

w t: 
o o 
^ a 

c E 

'E 


c 

C 3 
LU CO 












CO x: 0) <D 
O CO c 

•i ^ ® o 

— <D <D a> 

u -*->»— x: 
c 'c r- ♦- 
® 5 ■— . - 

® <D t- CD 

E £. 05 °- 

03) Jr 
2w 

^ to (O 5 

E "3 o 8 

0) 0) ti) 

sl-l" 

z °-0£ 

° c 
CO £ - 

jU CO 03 

'm <15 03 

05 -a cn-s; 
"5 tn <u <5 
cc ^ ^ ^ 

<0 3 ‘ CD 

■O O CD o 
ctj >.x: c 


- ^ -D o 52 

*-! it ffl -r) 


0 0 T3 
-<= S c: 
0 O 
^ C3 
0—0 


0 n ♦- 
« ‘fe 

^ 55 ° 
0 0.0 
x: o 

CO — 

^ CO 

■£ h- -- 
0 .<2 
o o £ 

O. CO 

k. 

§12 
O X « 
05 *" m 
DQ 0^ 

C" *" o 

C 0 
O C 03 
0 0 O 


■a o <0 T3 

X 0.2 w 5 

c =2^ 

1 2 

S? !> ^ • C15 

)=is> Q) ^ 

^ O C E m 

2 z g) 05 2 

Q- . 03 ^ c 

0 C13 CO 

Q.^ 3 2 

c »- g Q. 0 

03 X t; 03 

‘"cE-c o 2 

« 8 = .s 

05 5 O O 
is CO S 0) 


« 8 =3 ^ 

2 ra i -2 0 

I 2 c ^ "2 
„ ._ O ^ 03 
g (13 03 O C 

0) "2 0 o 

> o cl^B 

<5 03 0 0 
<0 c c ^ 

^ 03 O 

o > . Tn 0 

^2 E c5 

C 2 « ■« 

0 —03 - C 

§;E 2 0 §. 

3 0 Q.T3 « 


F >> 
0^ 

-b 

1 0 
T3 0 
0 

E V 

0 0 

S-« 


0 c ^ 

ao S' 

0 ^ 

■g 0-2 

O 0-03 
<-5 fS X 
03 CO ^ 

B 

0 0 O 
X X o 

(— X X 
g 03 
O O 
X c 
2 O o 
^ 2 <2 
.t= +; 0 
5 Q- 

05 2 
o t X 
c o .i± 

8 Q.X 

E 

•— 03 
2 W.C 

0 > 

2 <-> o 

3.05^ 

^ -S' ^ ■ 

'"|o§ 
^8-^2 
> 0 Q. 


^ C 

O 0 

ET OL 
K CL 

O 0 

< 

QC T3 


K -Si 

^ =E 

tJLl $ 


•E 2 

1 ^ 

8 ^ 

*- > 

8 03 
■ ^ X 

'2 5^ 

2 S 

g 0 

o X 

^ o 

u. 

<15 Q. 
2s 
0 O 

2 5 


0 ii! 

X 0 
0 X 
(U 03 

-Q ^ 

1 - 

o n 

X c 
0 0 


X 0 
0 'O 
T3 X 

2 => 




pie of Abstraction: 



Megaprogramming in Ada Course; Abstraction, 2^ Copyright 61995, Software Productiv!tyCorlsolt!!!r 





DISCUSSION 

Our design consists of three modules: a module to read the input file, a control module to store 
the numbers in reverse order, and a module to write the output file. Concentrating on the control 
module, what is a good abstraction for storing numbers in reverse order? A stack. Let’s create a 
stack module to store the the numbers from the input file. 


« 


CO o 


C (D 
.2£ 


■5. 5 5 

Q. 
3 


> .Q 
O O'® 

(C 

CO 
(C 

c 
o 

CO _ ■■g 

r» = 3 
< 5 o 

g^aTco 

0 

Q. 5 

i- 

O) 0) 

£.2 E 
5 -5 cj 
05 SS o 

1= to 1- 

cc ^ <i> 
0) -t; x: 
<3 O 0 

T3 £ CJ5 

CO}:; 

.O'O I 

o 

y > 2 

E 0 ^ 
E = ^ 

8 lf 

e c 0) 
0 

« 0 
0 r: 

3 5 
■a 

Eg 

8“ 

0 v- 

0 


C ^0 

s 

3 


o 

•D 


0 13. 
.? > C 
0 0™ 
.E — 

~ .C 


0 


% 


0 O 
. C 

0 .0 CD 

0 P 


0 


O 
0 O 


0 

C 0 <0 

CD 
> 


0 

o 


^ o 

B r. 

0 o 
p ca 

0 T 3 . 

0 f" 
c 0 .= 

0 {5 3 O 
0 “■ 
c .9 -Q ” 

05 05=: £ 


0 O § 


C 


0 


O 

S O 


0 

r: c 
o 

D)« 

.E •o 

^ ^ 

E -c 

o I 


0 0 

0 c 

1;^ ■- 
0 0 

o 
0 .9 


.-ti 


0 
Q. 

O 

o . 
CTg 

0 O 

:i ° 

oJ ^ 

c p 
o .E 

O 0 & 

I z, 0 8- 
O O 5 O 
X >.< o 


i2 

O = l_ 
.£ 05 0 0 

^ 0 0 E 
0 
Q. 

E 


0 "O 
0 


£ _ -Q 

Q. 0 

E ^ c 
o t 3 g 
o 0 .9 


JE .9 
_c 0 c ^ 

•1 - ■2’'l 

^ a, « 2 

0 w 

S 

T3 0 £ 

3 £ aj ^ 

o 0 -5^ o 
> -O 2 X 


>. 

0 


5 

o 

sz 

05 

c 


o 

0 

CL 

0 

o 

o 

JC 


o 

"O 


0 B 


0 

o 

•D 

O 

£ 

0 

0 

0 

x: 


Q. 

E 

o 

0 

05 

0 

C 

0 


(/} 

z 

g 

h- 

O 

< 

cc 

111 


*= E 

CO 0 

> >s 

■3 i 

o ^ 

XJ 0 
0 JZ 

— w 
2 w 
o ic 
I- 

li 

n p 
o o 

ii 


= 0 


o 

>>■0 


Z £ = 


«/> 

UJ 

> 

H- 




Q 

13 

h“ 

V) 


UJ 

"3 

CQ 

O 


I 

x: 

■o 

c 

0 

0 

c 

o 

■O 

0 

n 


X 3 

0 

0 

Xl 

5 

3 

o 

x: 

0 

0 

c 

0 

X3 

3 

0 

0 

XT 

H 


0 

T3 

0 

0 

C 


C 

.0 
c5 

o 
’c 
o 

£ 

£ 
o 
o 

■O 

c 
0 

^ 'tc 
■§ 

£ > 
CL C 
F 0 

o g 

“ I 

i .0 

^ 05 

c 

£ 
0 
■5 

05 

.E 
v.* 
0 

TO 


0 

0 

•o 


■o 

0 

0 

3 

o -- 

C 

0 o 


o 

0 

0 

X3 

0 

? 

O 


c 

|0 

CL 

X 

LU 


0 

CJ 

c 

0 

■c 

o 

Q. 

E 

0 

x: 

0 

II 

X 0) 
UJ 05 


KJM 









Example of Abstraction: Design 









DISCUSSION 

A stack is a sequence of items in which Items are added and removed from the top of the stack. 
The details or behavior that are important to us for a stack are: 

• Every stack has a top (you can read the topmost item on the stack). 


o 


B 

n3 


c ^ 
O 5= 


Q- o 
F cC 
a5 03 

« OJ 

^ S 

o H- 
CC O 

00 0) 
CO .y 
u. w 
<D 0) 
-F .c 


C •“ 
(0 C 

(/) Gl 
3 O 
Q. Q. 

D 3 
O O 


C /3 

0) (D 

t— 

c c 
cO cO 
o o 

O O 

> 


O C o 
i_ E CO 

o o 

^ g S 3 

0) c > CO 
JO 0 (0 £ 

CD O •?; CO 
£ C 

o 

03 Q. CD 

riNE 

« - 5^ t: 

^ ^ fs ° 

JO ^ JS CO 

r E o E 

o £ o2 

CO 3 <0 

E c 

.^•co^ « 

o i: S.B 

v> o F ■” 

i8.<2-5 

■5“-gS? 

CD 1 -.“ CO vD 
JC CD -K ^ 

CJ) c: 

CD CD CD CO • 
^ 'F x: o>^3 
cO .E CD .CO 

CO c "F “ 
3 cO m 

g cO CD 

O w E 5 
2 05 m -E 
c o a E — 
CO x: c E flf 

t *- .E CO 2 

o ■“ ^ CO ;i= 
F **= C 3 ^ 

^ — CD 

E c 05 £ co 

O - " « ^ 

0) ^ « 03 

CO o E CD ^ 
-*-! c ra XI .. 

CO _ v>. 

3 O E 

io ^ i3 E 

■Jo ^ CD 

* 1 ! O CO <• Ji: 

0 -Jg ^ £ 

^ 'cO -D CD 
E 0 0 rt O 


W 

0 

G. 

w E 
z 0 
O X 

1 — 

o B 

< i 


I- <15 : 

Z 0-2 

“ CD 

UJ ^ s 


J= 

5 d) 
0.E 
c -C 
So 


Is 
0 ^ to 
^ 0 ^ 

5 0 p 
o j: p 
X 5 

111 


0 0 

S g 

er< —' 


x: 


G 

E 

0 

X 

c 0 


E 0 


2 lu 
« 


• • 









Using a Stack Abstraction 





o _ 
■= X) 
■5 c 
g 0) 

C 0) 

W I 

E w 

B <D 


^ E 
o a 

C 

0 -o 

E. ^ 

0 ) o 

'H: £ 

(0 m 

<n 

0 n 

c 

2 S 

w -o 
^ 0 
O "D 

0 ■a 

«« 

m £ 

0 

^ 52 
o E 
0 0 

tr .t: 





Copyright © 1935, Software Productivtty Consortium. 



DISCUSSION 

A specification defines the behavior of an abstraction. A specification defines the visible parts of the abstraction. 
A specification serves as a contract between the implementer o* ♦he abstraction and a user of the abstraction. 
The important point here is that a user of the specification defines the operations, not how those operations will 
be implemented. This means identifying the name of the operation and its input and output parameters, if any. 







stack Specification 





i 






c 

o 

n 

c 

(U 

Q. 

d) 

■O 

c 


o 

(d 





c 

o 

■ MM 

"S 

o 

■ IM* 

■ MB 

o 

o 

Q. 

CO 

T3 

0) 

15 

o 

(0 

■ ■BB 

(/) 

■ MB 



<D 

O) 

0 


C 
• ■■■■ 




3 

"O 

0) 

o 

o 

V- 

Q. 


■ 

c 

CO 

0 

O 

O 

CD 




o 

I- CD 


c c 

o c 

‘-I—• 

o o 

c c 

3 3 


i 




Megaprcgramming fn Ada <^urse: Abstraction, 2-7 Copyright © 1995, Software Productivity ConsorHurtu 






Q. ca 0) 0) 

^ o* 

O « > CO 

w. c ^ ^ 

O) C 0) o 
o £ jc 5 
^ ^ ^ Cl 
3 03 

o 9>-s “• 
>'5 -^-a 
cn "o n. £ 

5 S-F 
O Q. £ c 
= c® S 

(0 « £.2 

TJ *- *-• 

— < -a « 

. ^ co o 

03 C £ ‘.P 
D)< ^ '5 
« «8 

o S- 

CO 3 '3 W 

Q--a o ^ 

CO 2 5 o) 

■n E «»o CO 

■c’ ij 

c o c g 
CO .t; <0 Q. 

? 3 « CO 

C J 0 ” 

'lo ^3 W 

03 .£ Tl ^ 
h: C 0 ^ 

O t S CL 

2 o 

•“ 2 0.5 

WJ O) „ 

;F O c/l ‘tr 

cS - 0) o 

O J3 Cfl 
•D 03 CD M 

^ O CB W 
CO 5 C 
O o O 
03 c Cfl ^ 

> i= C 03 

^ <0 .2 O) 

F CO -a CO 
C- Co Si* 

O XI h: iS 
CO m « 

o c o 2 
cO C3 0 ** 
^ ^ cd 
^^032 

« £ 9:^ 

03 .^2 

.5 cn T) 
cn 0) 03 ■ 

<“ CL-a “ 

J= ?^i3 ® 

o 03 .a 

■Si 

0) .3 2 

'i 8 '03 

z <0>25S 

2 2 </>■ o c 
n S 2 c: .2 
n E 3 o -a 

3 O "O +3 2 
J ^ ® CO 
J w O w -rr . 

2 03 2 o <i> 

D _j u. o "O . 


F '5 C" 

:£ |S 

<n Q..2 

« e « 

8.2 s 

£ CO <n 
03 o c 
<0 S= CD 

.2 8'^ 
x: Q. c 
h- CO .P 


CO H CO 

3«: o CO 

“li 

03 < 0) 

•S • o 

*- 03 O 


CD "O 
!»: 03 

S 2 

Q. Q. 2 

c/> _ O 

v< C/3'*j 

o O « 
CCS X3 .2 
W rtia 
^ c o 
a JO 03 

° ^s■ 

“8« 

/-.» i-ri 


^■S 03 .C rt 

Q. C^ O o cO 

0) 2 >> i_ .a 
.F x: X2 03 c 
~ TD C” E 

.2 “o C13 ^ CD 

> CO Q- 

i= 3 03 x: c 

cn ^ o 

03 CO j- Wno 


^ rri 

0 «d ^ 
it= "D CO 
act) 
8 CO CO 

Ol '^3 

S CO o 

o ^ c. 

a CD 3 

CO cO 0= 

.2 Q.-0 

r- 

<0 

cn “S 2 

03 . o 


n) v4/ w vu i_ a 

JS § « S’ ® 03 

7^ a V v2 c O 


« 8,£ 
Q. 03 <0 

CO Q. 

^ CD eg 

03 CO ^ 


c: o 

CD 03 O 

g_E ^ 

O- 03 
0 Q_ cd 

x: c -fe 


i? rt 

03 2 

■O rh C3 

C O’ W 

8 

*-1 >. 
8 c 2> 
C” .2 03 

J i0-» 

CO g f 

^ E « 

2 .o - 

c .E ■o 
|.a 8 

O C 0 

0.0 03 

E 1< S 

•~ 03 -Q 

•5 C 8 

c 03 a. 

#ft 0 


O) 0 

I ° 

O 

< -9 

QC c/3 

UJ ■> 

t <0 


c " 

CO g 

(D E 

S’O 
cO v 

ol-^ 

CO 

0.0 C 
-0-3 
3 . O 

' CD) O 2. 

I 8 § 

g tr^ 
E 03 CT 
8^2 
i°c 

w ^ — 

O W 

.a g 2 

■rt .. 

UJ • 

3 jC *n 

■ ^^8 
I a _ -2 


a -o S 
^EE > 
t 0 3 i- 


03 

2 rt 
O o 

XI CO 
CO o. 

03 CO 
X "O 


x: 0 

CO Jq 

m CO 'w- 
a CD 

C o 0 

0 3° 


g.< H.i5 


Megaprogramming in Ada Course: Abstraction, 2-6 





i 


\ 



o 

JZ 

HH* 

CD 

O) 

O 

4-» 

CD 

C 

o 

■ ■■■ 

o 

c 

3 

•o 

^ (0 
(0 O 
O Q. 

V. u. 

3 3 

X) a 

o ^ 
O £J 

Q. ® 

CD S. 
JO ^ 
.3 

CD ^ 

o> £ 

^ 0 
O In 

g. 3 

■5 
0 g 
“““ 

0 n 



0 

O) 

0 

4 -* 

c 

c 


c 

0 0 

£ 

o ^ 
iS LU 
CO ^ 

1-' 0 
0 D 
D) D_ Q_ 
0 

4-< 0 0 

r- iZ Jr 

"D 


C 

i_ 

3 


Q. 

O 


— 3 

0 T3 
CD CD 0) 

« 8 “ 
CL 


2 

Q. 


C 

0 

0 

o 

o . - 

CD 
0 

11 

Q, ^ 

E 2 

LLl. CL 

I O 

12 H 

c c 

,2 .2 

4 —* 4 —< 

o o 

c c 

3 3 


0 

D) 

0 


Z3 • 

0 o 
0 

N 

W ‘r' 

r- ^ 
O d) 

4 —• 4 —• 

o c 

C — 
3 -O 
C 
0 









i 


» 


B 






DISCUSSION 

Eventually, you have to implement the various operations for the stack program. You do this by 
writing the Ada package body. 

The Ada package body provides the implementation of the subprograms defined in the package 
specification. For every procedure and function you define in the specification, you must 


>' 
0) c 
> CO 

o)E 
).« >> 

si S 

03-t; 
CO 2 
Q. 

CJ 

' (0 2 
Q.£ 


^ 0) 
^ 03 

q.E 

-k- o 


C OJ 

5 9 03 

|5-g 

o ^ 

E 3 
- 5 o 

03 ^ 


'■|§“ 

fSs 

o 9^ 
0.0^ 
o o fc 

•b >^TD 


03 O C 0) 

£ >• O O 
0) 0) OJ O 

Q. 03^ O 

.i .2 *“.« 

2 « ^ ^ 

^ <0 <D £ 

>« O O c 
J rt g 

ra- tj g. 

CO'S o W 

2 03 CC o 
-C u- _r~ 

Q) ti ^ 

2 o O <0 

O O ^ Q3 

^ I'll 

0^ = 1 
12°: ? 

Q) 5) Q) 5 

-C </5 

5 03 ^-52 

^ O x: ^ 

CL-C^ -O O 

2 o §3^ i 

.52 ^ ^ 

“ o g O c o 

o o 2 o 

03 ^ O C < 

s 

s £s.ol z 


” CL.C g S. Z 

£ ° 

o E= H 
< 287 =$ CO 


c 2 

2 5 

2 03 
CO CL 
CX. 03 
03 ^ 
03 

fn W 


O C" _ 

9 03-^ 
> b w 

5 ■? 'co 
X 2 T3 



.T3 

52 0 


0 .D 


2 0^ 
? C33 


0 0 


2 ^ 
P U 

.52 

2 CO 
CL 

>> 

■0 

- 03 
0 ^ 
03 ±3 

0 

JD 

la 0 
0 *- 

0 

■a 0 

03 

5 .Q 

0 


■0 

0 

0 

0 ” ^ 

Q. 

0 >. 

0 

■0 

^ 0 

< 

£ 

C 

2 

0 

x: ” 

’*-• >s 


IS S 

P I 

IS i 
s ^ 

O h- 


^ "a o 
•9 c: JZ) 

^20 
E CO 03 

iO 0 2 

CL -o -g 
X c ^ 
UJ 3 ^ 


•A 


Megaprogramming in Ada Course: Abstraction, 2-9 



















DISCUSSION 

When one package or subprogram uses operations, types, or variables provided by another package, it must 
name that package in a “with” clause. A with clause allows you to include a package specification into your unit. 
This allows a package or subprogram to gain visibility into the Ada specification being named. Once other 
developers have “withed” the compilation unit, they can invoke or use anything in the specification. 


0 ) C (U 

D) s -c 

ns 2 

a> ai> 

-cog 

<0 ns "D 
5) 

a. o Q. 

D C CS 

S ^ 13 
'0 . 0 

= ^ g 

ra D..O 

^■3o 

oO'*- 

a I 0 

£3 E 
'c to 
g-5 c 

■a'fe ^ 

CD ij 
DC SJ CO 

2 a 
5 0 

to o S 

.E *- 

■3 "D 

o 0 ) 0 
C ES CD 

I S CO E 
to CT £- 
>.0) 

0^11 
O c/3 >> o 

O I s= . 

CL 0 0 g_ 

^ o) n. 

'*■ c a c 
0 “ 0.2 
^ o 

iS _ -q' § 

“ o^T- 

l.y -'-D 

^ S CD 0 

O D) 

CD 0 CD 5 

S °-C ° 
I— w .£ CL 


.tr c 3 

*-.2 a 
c: -K 
<i> ?5,5 
c .2 O 

0)0 0 ' 

0 0.^ 

Cl ^ 

CD w > 

^^0 
c £ b 

3 aj -a 

2 IS 

2§-2 

0.0 CD 
O % 

O. "O -S 

QJ °- 
O c o 

c -a o 

E o 0 

0 o > 
o 5 0 

111 

O 

0 0^ 

■O 2 O 
•^00 
0 ■> >' 

D>E O 

O O « . 

jC c^. CO "2; 

O 0 i_- O 
-J 2P CD CL 
2 c oi 
P 0 0 O 

^ 

- O 1“ o 
1.0 


0 ™ O 

S i £ 


E g g- 

0 E 0 

$2S| 

£i’*l 

all I 

iioo 

o O W *“ 
O Q_ O 

**— u. 4-« 

O Q- O _ 
^ j- ^ CC 

|iS2“ 

O-D o ® 
£ O O g 
0 olCLE 
0 O !=; 0 
03 o£ -E- 


w 0 o 
■CEO 
0 ^ 

0 "O 

d).2 0 

C 0 C 
•E O •=: 

0 = iS 

O Oc 

= ^ s 

3 O O 

E ^ IS 

8 E 0 
t= 2 

« 0 .2 
Om o 

S T? 


. 0 ^ 

0 05 0 

^2 5 

88 “ 
>.3 3 

wJ5 o 
0 0 > 
O)*.. C^- 

0 X .0 

£ .2 I 

0.0 £ 0 

_ o J-j CD 

0 CD X S 
. 2 CDi5 

^ 0 O §. 

0 

S "o £ 
« o|- 

c C 2 c 


— vu t 3 

g O) o o 
m CCJ 5 

CD O ^ X 
. . (d n) 0 
C o 0 Q. 

■2 0 0 E z 
0 £ 2 o o 

E o 50 g H 

c g,0 2 < 

00 ”“’' 

8^ 8)8, ^ 

T3 2 o o h- 

< o o o iS 


n 0 
? 
O 0 
C>. 0 £ 

2 00 “ 
’5 0 E 

2 

5 opB’ 

o -^O 
2 I 
■2 0-0 
o 0 0 

o 


3 3 

o o 
>'? 
s « 

o 2. 
§.0) W 

o-to > 
CO o 5 


G) 

E 

O) 

E 

cd 

0 

0 

0 

cd 

TS 

Q. 

c 


0 

0 

£ 

0 

0, 

0 

c 

c 

0 

<d 

E 

c 

0 

•“ 

c 

E 

cd 

TO 


'0 

D) 

s 

0 

0 

Q. 

0 


3 

3 

0 

« 

0 

Cd 

■R 

Id 

0 

0 

c 

0 

0 

0 

5 


0 

0 

JZ 

SI 

■0 

•O 

c 

c 

cd 

Cd 

E 

“SJ 

0 

0 

“O 

*3 

c 

c 

=) 


• 

• 








Clients of lnteger_Stack 




2 a 
^ o 
O h- 

A j*; 
O i 


■g 

«o'g> 

I S S 

® 13 <D 

c ^ £ 

sl-i, 

« 2 LU 


. o o 

CC D) 

w -g 

O II 
D) • • 

<D 

C 

c 0 

E 

jQ) jO) 
S LU 


S- Ci 

=3 O 

OQ: 

c ^ 
o iS 
E CO 
^ J ■■• 

LU 0) ^ 
0 ^ 
^ S-g 
0 


■5 

Ql zj 

3 o 

O .1 


O-g 


13 

•o' 

0 •♦-* 
0 c 

QC ” 
> E c 
^ E 

o ^ 
O LiJ 


Q. 0 
O = 
O LL 

is' 

® 6 -w- 

ir 1 c 

1-0 i 

C £ I 

g^LU 0 
C ^ m 

C ^ 
c 0 0 , 

c E •■= CD . 

§^o ^ 


ii: I :3 

CO CL 

I ^ r- 

•- 9-~i 
0 Q. C I 

O) o 

iS O 03 g 
^ -O S C 








DISCUSSION 

A package specification allows us to deal with complexity by implementing a problem separately 
from the solutions to other problems. As a programmer, you design the interface to your solution. 
(For the lnteger_Stack package, this is when we specified the procedures and functions we would 






Megaprogramming in Ada Course: Abstraction. 2-11 


















DISCUSSION 

This slide summarizes the topics covered in Unit 2. 

Abstraction allows you to manage complexity and enhance communication by concentrating on 
essential information. Think about how lucky we are that we can defer tough decisions until later 
(e.g., an actual implementation of a stack). We use abstraction in our every day lives, not just to 







Summary 


W 


E o 

8 

o E 

c c 
cn “ 

E (Q 


4>> C 


^ (0 
CO 0) 

S c 
o o 


"5 o) 
c -E 
.2 « 


s S 

^ o 
2 c 


5 o 
< o 


S c *(5 


o o 
= « £ 


g c 
? 0) 


D) o 
C CO 


6 E E 


CO W 


w ® S 

o i" -E 


c ^ 

CO W 


CO 

O CO "D 
CO .t: — 


CD O 

CO i5 
^ t: 
o o 

CO ti 


to E 
^ o 

< it 


• • 




Megaprogrammtng in Ada Course: Abstraction, 2-12 Copyright © 1995, Software Productivity Consortium. 




Mcgaprogramming in Ada Course: Abstraction, Workbook 


UNIT 2 : ABSTRACTION 

UNIT SUMMARY 


Abstraction 

Abstraction is a technique employed during software design. It lets the developer temporarily 
suppress irrelevant details so he or she can concentrate on essential information. Developing software 
requires defining a great deal of detail, so any techniques that can be used to consider information 
selectively are of great value. Abstraction is one such technique. 

What is “essential information” and what are “irrelevant details”? Typically, essential information is 
the data you need in your program and what you will do with it. The irrelevant details are how you will 
represent that data. In general, you can use this division into what versus how to help you differentiate 
between essential information and irrelevant details. 

For example, suppose a program is to create a file of integers whose content is that of another file of 
integers, but in reverse order. You can design a program that does this as follows. The program will 
read the integers from the input file, storing each one on a slack as it is read. When all integers have 
been read, the program will pop each integer off the top of the stack and write it to the output file. 
In this design, you have created four modules: one to read input, one to write output, one to hold the 
stack, and one to control the others (see Figure 1). 


Input 


Control 1 


Output 

Module 

* 

Modulo 


Modulo 



Figure 1. Module Design for Reversing a File of Integers 

Wheii you’re working in a team, it’s important to create the module design. You can assign each person 
one or more modules. This is a good way for team members to work together. 

Recall that a stack is a linear list of values accessible only through a fixed set of operations: Push, Pop, 
Top, Is__Empty, and Size. This statement of a stack is an abstraction. It proclaims the essential 
information—namely, what five operations can be used to access a stack. It also defines what kind of 
descriptive information other packages can see, for example, the stack’s size. It suppresses irrelevant 
details, such as how the stack will be represented. 








Megaprogramming in Ada Cou rsc: Abstraction, Workbook 


This essential information is the abstraction’s specification. In Ada, you can package the essential 
information to show its interrelatedness.* 

pBckaga Integer_Stack is 

proc«dur« Push (Element: in Integer); 
procadure Fop; 

function Is_Empty return Boolean; 

function Top return Integer; 
function Size return Integer; 
and Integer_Stack; 

In Ada, the package construct groups together a set of procedures and functions. (You can also include 
constants, variables, and data types, as will be shown later.) Everything between the first line and the 
end line is declared to be part of the package specification. This package specification declares two 
procedures and three functions. The first procedure. Push, has a single parameter. Element. This 
parameter is declared in, which means that you must supply a value for it when you invoke it. 
Furthermore, its value will be unchanged when Push finishes. 

The specification gives you enough essential information to let you write most of the program,** 


with Integer_Stack; 
procadurs Write_Output: is 
Element: Integer; 

begin 

Open (Output_Eilei OuL_l'’ile, 
Eile_Name); 

Set_Output (Output_l''ile) ; 
while Integer_Stack.Size > 0 loop 
Element Intoger_Stack.Top; 

Put(Element); 

Integer_Stdck.Pop; 
end loop; 

Close (Output_I''ile) ; 
end Write_Output; 

These two procedures both begin with, the line with integer_.gt;a(-:k, meaning that the iiiforniatioii 
in the package specification of integer_stack is within their scope. They can, therefore, within 
invoke Push, Pop, Toi), and size. Notice that references to these procedures and functions arc 
preceded by the package’s name and a period; e.g., integer_stack. Pop. This is Ada’s way to avoid 
ambiguities, since other packages might have procedures and functions with the same names as those 
found in Integor_Stack, 

The package specification scrve.s as a contract with other modules in the program. When you write 
it, you are suppressing the implementation as an irrelevant detail but promising that you will develop 
an implementation that provides the functions stated in the specification. In Ada, you place this 
implementation in a package body, which is separate from the package specification. 


with Integer_Stack; 
procedure Read_Input is 
Element; Integer; 

begin 

Open(lnput_File, In_File, 
File_Namc); 

Set_lnput(lnput_FilG) ; 
while not Eud_Of_Filu loop 
Get(Element); 

IntegQr_Stack.Pusli (Element); 

end loop; 

Close(Input_File); 
end Heaol_lnput; 


* In ttic cciiic; Iragnients, Ada reserved v'orils are .shown in boldface typo. 

*' For simplieily and clarity, the code examples omit details of file input and output. 







pKCkage body Integer_Stack is 
Index: Integer := 1; 

typs Stack_Repre.sentation is array (1..100) of Integer; 

Stack: Stack_Representation; 

procadura PuL;h (Element: in Integer) is 

bagin 

Stack(Index) := Element; 

Index := Index + 1; 
and Push; 

prooedura Pop is 
bagin 

Index := Index - 1; 
and Pop; 

function Top return Integer is 
bagin 

return Stack_Contents(lndex-1); 
end Top; 

function Size return Integer is 
begin 

return Index 1; 
end size; 

and lnteger_Stack; 

Other modules, sucli as K<jad_input imd Write_output, do not need to know any details ol' tlie 
implementation. They only need tlie inl'oi mation in the sjiceirieation. Tlie Ada programming language 
enforces tliis. Head_input and WriLe_Output can access the iidbrmation in tlie package 
specification, but cannot access the information in tlic package body. They can invoke size but ctinnot 
determine tliat stack is an array or that size works by accessing the variable i ndox. 'I'lie designer 
of integtu-._stack has liiddcn the irrelevant details. This shows how you can use abstraction to write 
a module that shows to other modules only wliat you consider to bo essential information. 

Ada packages help teams design and iinjileinent |)iograms using abstraction. A team Vi/ill assign a 
single developer the responsibility to develop a module such as a slack. I'iie developer will design an 
Ada package .specification for the stack. Me or she will then compile the slack’s s]reeifieation and place 
it in a central library that all the other team members can acce.ss. The other members who need a stack 
can reference the abstraction as they develop their own programs. 'I'lii.s gives them access to exactly 
enough information to design and implement their own modules. Meanwhile, the stack developer will 
implement the package body foi the stack, then compile the package boily and place it in the library. 
Note that other team members can compile their modules without the stack package body, but they 
can’t execute them until the stack package body has been placed in the library! 






MeRaprORramminR in Ada Course: Absiraclion, Workbook 


This pagf inMUionuUy left hhmk. 


4 




• • • • 




Mcgaprogrammin); in Ada Course: Absiraction, Workbook 


UNIT 2 : ABSTRACTION 


GROUP ACTIVITY 

Split the class into two-person teams. One member of the team should examine the following code: 

typa A is array (<>) of Integer; 
procadura p(pl: in A; 

p2 : In Integer; 
p3: out Integer) la 
u, m, 1: Integer; 
bagln 

1 := a'first; 
u := a'last; 
vrhila 1 < u loop 
m := (l+u)/2; 
if pl{m) = p2 than 
p3 ;= nt; 
return; 

elslf pi(m) > p2 than 

u : - ni- 1; 

else 

1 lu + 1; 
and If; 
and loop; 

p3 ;■ a'first-1; 
and p; 

Describe the irrclcvunl information in this code to your partner. In other words, do not discuss what 
you believe is tlie purpose of this code. Instead, discuss only tlic algorithms and the data it uses. 

Your partner is to guess the essential information from your description: what imrpose the code 
accomplishes. The essential ial'ormation should be de.sciibed in lernis of two things: 

• 'I'he value of p3 when the procedure finishes executing 

• The name of the procedure 









This page intentionally left blank. 






MenaproRramming in Ada Course: Abstraction, Workbook 




UNIT 2 : ABSTRACTION 


TEACHER NOTES FOR GROUP ACTIVITY 

Split the class into two-person teams. One member of the team should examine the following code: 

cyp* A is array (<>) of Integer; 
procadura p(pl: In A; 

p2 : in Integer; 
p3: out Integer) is 
u, m, 1: Integer; 
bagln 

1 ;= a'first; 
u := a'last; 
while 1 < u loop 
n\ (l+u)/2; 
if pi(m) = p2 than 
p3 := in; 
ratum; 

alsif pi (ni) > p2 then 
u := m-1; 

else 

1 := Ill + 1; 

0 and if; 

and loop; 

p3 := a'tirst-1; 
and p; 

A few words are in order to the teacher who knows Pascal but not Ada. You may wish to rewrite this example 
in Pascal for your students, since the purpose of the activity is to understand the algorithm rather than to 
learn Ada. In any case, here is some explanation of the code. 

• The notation < > in the top line is Ada’s natation for unconstrained array bounds that are 
determined when a procedure is called. Thus, any array of integers can he passed to p. The notations 
a 'first and a 'last (read "a tic first” and "a tic last,” respectively) are the upper and lower 
induces of whatever array is passed to p. 

• Instead of Pascal's 

whlla condition do bagln 
statementl; 

stateinentn 

and 

Ada uses 

whlla condition loop 
statementl; 


» 






I 


I 


» 


I 


I 


» 


• ••••• 




7 







statementn; 

•nd loop; 

• Ada’s return statement causes control to return immediately from the procedure in which it’s 
executed. 

• Instead of Pascal’s 

If conditionl than bagln 

statementl; ... ; statementn 

•nd 

•laa If condition2 than bacrin 

statementa; ... ; statementz 

and 

alaa bagln 

statementA; ... ; statemontZ 

and 

Ada uses 

if conditionl than 

stateniontl; ... statementn; 

alalf condition2 than 

stateraenta; ...; statementz; 

alaa 

StatementA; ...; statementZ; 

and If; 

Matching each if with an end if eliminates the need for begin blocks. Note also the els if, 
which clearly shows that cundi tion2 logically matches condi tioni. 

De.scribc the irrelevant information in this code to your partner. In other words, do not discuss what 
you believe is the purpose of this code. Instead, discuss only the algorithms and the data it uses, 

Your partner is to guess the es.sential information from your description: what purpose the code 
accomplishes. The essential information should be described in terms of two things: 

• The value of p3 when the procedure finishes executing 

• The name of the procedure 

The procedure p is a binary search algorithm. The identifier names are deliberately abbreviated to make 
the activity more challenging. A better declaration would be: 

procadura Perf<jrm_Binary_Search(Values; in A; 

Eleraent_To_Search_Kor: in Integer; 

Location_0£_Element: out Integer); 

This procedure specification .succinctly captures that essential information which must he known to 
developers that use this procedure. However, as they write their module.s, they do not care about details of 
the implementations like the identifier names. 





Megaprogramming in Ada Course: Abstraction, Workbook 


The student asked to listen to her or his partner should, in effect, come up with this declaration. In other 
words, the procedure takes as input a sorted array of integers (pi) and an integer value (p2). It returns in 
p3 the index of the value if the value exists in the array. If the value is not in the array, it returns in p3 the 
integer value that is one less than the first valid index into pi. The student presenting the irrelevant details 
might say something like: 

"The procedure has two inputs. One is an array of integers. The second is an integer. It declares three integer 
variables. 

"It begins by assigning two of the variables the lower and upper bounds of the array. It then checks to see 
if the second parameter equals the value midway between these two bounds. If it does, then the procedure 
assigns the index of the middle value to the third parameter and exits. 

"If the second parameter does not equal the value in the middle of the array, the procedure resets the bounds 
it will check. If the second parameter is greater than the value in the middle of the array, the bounds arc reset 
to the first half of the array. Otherwise, they are reset to the second half of the array. 

“This process repeats until a value matching the second parameter is found, or until the difference between 
the bound is 0 or less. In the fanner case, the third parameter is set to the index of the matching value. In 
the latter case, it is set to one less than the array’s lower bourui." 

This activity will be very difficult if students do not know the algorithm. If your students have not learned 
about binary searching, you should substitute an algorithm you have previously taught them. 








MeRaprogramminR in Ada Course: Abstraction, Workbook 










This page intentionally left blank. 




» 




» 


___ » 

10 


• •••••••• 



















CO 


<D C _ 3 


w W — 

JC X .b: 1^ 
® ^ ^ 
■Dq. 2 3 3 
p 


c 

o 


O p tf ^ 


o 


1 = 

O TJ 

W (1) 


«•- (0 i2 
0 o D.'jg 

O 0 0 

W 0)'P 


S 0 .g 0) 


« « 
0 0 


® O 

o)*: 

|.i’§ o 


w 

0 

o 

3 


-2* 0 3 -2: -a 
WO ~ 


ii - O 0 P 

•o ” 0 !: 

I 

-O 0 c ■*" 


■P cw ^ c: o 
■^<=052 

i ° cfS 
s^S.£< 

0 c ^ "D to 
0 -c o c -e 

.g 0 >> 0 0 

O) 0 CO - 0- 


c c ^ £ 


0 ‘O)^ B 0 


I ® D)E O 
|o«O0 
= -c -a c 0 

sa-ii 


^ t 0 


E 

0 

e 

Q. 

0 

O 


C 

0 

t 


0 

x: 


o 0 CO = 


0 0 


.g 0 0 


g 

(/) 

CO 

D 

O 

W 

Q 


c p i= 

_ TJ 
0 0 3 
— O 0 
^ .t: rn 

•S’ ^ 

0 0 
0 0^ 
*^0 3 


Q. 

0 

0 


D) 


C 

0 

O 


0 
0 E 


D) 

P 


D) Q. 2 

•Sc 

cog 


0 « 


Q. 

< 


-- 0 . 
0 0 
Q. 0 "P 
c ^ 0 
.c < Q. 


CO 0 

2 ■- 

0 0 
O) C 


i5 o 


B >, 


0 


0 


^ JC 
3 

0 
C 

C ^ 
0.2 
% B 


3 

O 

>• 


0 


o 

&' 

0 

> 

0 


0 

Xl 


c 

0 


13 

B 


C 
D) 0 

^ E 


c 0 0 
0 g-O) 
E - 2 

« 5 °- 

2 0B 

Q-JC > 
0 

I— 0 

-ox: 


c 0 _ 
g x: E 

§-£ o 
0 

O 0 P 

O’ O .h: 
0 ■}- 0 
0 0^ 
•0 0“ 


0 0 ® 
-Q 

0^ E 
0-2 0 
c E 0 
0 0 
O C 0 

o 

0 JC 

3 m 0 
o 5? "q 
0 


E 

0 0'“ 
0 0 O 
■►’> 0 

0 3 0 
c o x: 
— >» 0 


0 

JC 


0 

0 


0 


•a 

o 

x: 


0 

E 


X3 

0) 

0 

c 


3 

O 

>. 


0 

•Q 


0 

0 


O 

o 


I- 


0 

0 

JD 

3 

0 


0 

I ° 

>> 0 


0 

D. 

0 

JC. 


0 

0 

Q. 

O 

c 


CD 

c 

'3 

O) 


0 

J3 

E 

0 

E 

E 

0 

0 


o 

0 

0 


0 


0 

x: 

5 


c o 


O) 

'0 

0 

■O 

0 


0 

0 

0 

o 

.4—» 

C 


0 


D) JC 

'0 


0 

o 


0 cn 
0) ^ 


0 

k. 

o 


c 

o 


■§ 
0 E 


C 3 
g> O 

0 ^ 
0 0 
O ^ 


i 


CD 0 


c 

o 

o 


0 
c -C 

o -k- 

ii 


0 

E 


«= 

x: 0 


K_ ^ 


0 
o o 


x: ^ 


c 

0 


C 0 


0 0 
■a c 


c o 


0 o 

pL. 


0 T3 
T3 C 


C 0 


0 

■c 

0 

Q. 


O 

5 


c 

o 


c 

0 

o 


0 

o 


0 

JC 

E 


3 

E 

E 

o 

0 


0 0 


E 

0 

.0 

o 

Q. 


E 

0 

0 


JC 

o 

0 

0 


0 
O 

c 
0 0 


S "0 
0 g 

3 Q- 
0 0 
c ^ 
liJ c 


0 - 


D5 

C 


^i- 


3 0 p 
g EP 

0 'g I 

Q.'O E 
E 0)0 
o c c 

o :- .= 

TsS 0 

c P t 

”*0 0. 
0 O Q. 
Oi-S 3 
C 0 0 

B £ P 
.gl 5 

0 ^ p 

E 0 
0-50 
5 o 

0X3 = 


B ^P 5 


Q. 

0 E 

JC 0 
•»- 0) 

© ~ 

0 c _ 
0 0 ■;« 


0 

_ c 

5 = il 

3 5 

° ^ = 
o O) 
*; >- '0 
c . 0 
3 >4'D 


0 

JC 


0 P 
Q. 0 
P 0 


^0.0 


r- P .— 


Z 

D 

lU 

E 

I- 

z 

lU 

liJ 

I 

H 

cc 

o 

u. 

w 

UJ 

> 

H- 

O 

UJ 

m 

o 


0 

c 

o 


0 

E 


0 

X3 

0 


0 


0 

X3 


P 

3 

O 

JC 

0 

0 

c 

0 

•O 

3 


0 


0 

JC 


0 

0 

x: 

1- 


0 

X3 

0 


T3 

C 

0 


0 


■0 

C 

0 


T3 

O 

JC 

k-* 

0 

c 


c 

o 


c 

O) 

0 

0 

■O 


CD 

C 

TJ 

£ 


0 

E 

P 

c 


c 

O 


c 

0 

0 


0 

E 

o 

4 *— 

c 


0 

X3 


0 

0 

> 

Q. 

0 


O 

P 0 


JC 

0 

c 

o 


Q. 

O 


S- 0 


c 

'i_ 

Q. 


0 

x: 


0 

X 


_c 

0 

Q. 

X 

UJ 


_c 

'0 


T3 

C 

0 
■•—» 
CO 

0 


CL "0 


X 

UJ 


c 

D 


E 

riJ 


D) 

o 


0 . 

0 


o 

tc 

0 

Q. 


c 

o 


0 

c 

o 


o 

p 


0 

D) 

c 

0 

X 

o 

0 


O) 

c 

p 

X 


0 

X 


0 

0 

O 0 
3 P 

P 

0 0 
*- Q. 
D) 

E P 
P :E 

X O 


C CC 

•B 0 

p 2, 

o P 
p 
E o 


0 

0 


0 


Q. o 
X 0 


O) 

c 

TO 


C 

O 


0 

E 

O 

c 


1 C 

O 

CL 

Q. 

3 

0 


0 

E 

0 

'c 

0 


o 

0 

E 


P 


0 

> 


p a 


TO 

C 

0 


0 

0 

O) 

0 

0 

0 

CL 

0 

■o 

< 


0 


5 

o 

X 


•O 

c 

0 


0 


p S) p 


TO 


UJ c D 


m 


• { 







. Software Engineering 



Megaprogramming in Ada Course: Information Hiding, 3* 












































DISCUSSION 

This slide discusses the stepwise refinement design method. Stepwise refinement is the first method 
most students learn. 

In this slide, stepwise refinement is used to create a program that solves a problem similar to the one 


LL (/} 

.'.i 

S-‘c 5 

O-^ 

JD CD 

C 3 *(/) X! 

5 

> rt E 
o -c o 
£ § w 

><0, E 

JO S O 

^ E 

E if: CD 
CD ^ 

;s= S 

^ Q o 

B > o 
d) a 
'’5 ^ -a 

ij) £ 0 


c tr T^ 
o cc -= 

O > 

P 3 D) 

o g-2 

E -b Q. 


CD CD 0 ‘t; 

.C JZ jC ° 
or) 

■0.0)'^ 0 
O W 2 -tu 
0 tD 5 c 
■0-0 O 8 3 

3 3 M CD ~ 
o o x: £ 

. O CD ~ 


^ E 3 -3 T 3 

ilEo 58 

O) «> 3 

2 0 0 


E of o o 

0^3 2 

,-^00 
S 0) $ Q- 
.c o 

3 — 3 ^ 

O O) 3> O 0) 
E .b £ c "O 

0 g « o 
0 9- ca 0 0 




'Cfl .9 Q. 0 " jiC 

o 5 2 ■fS 
0 E Q_ ^ 

■a , 

C.g 0 
S 0^ 


.0 J, ^ 0 is 

0 0 2 0 0- 

”i 3 ®g' 

^ >< - JS 
Pc - 0 E 
J 0 2 ^ E 
■* c 0 Qi 3 
JS T 0 

E V- -‘- X3 


0 = T 3 3 .E 


3 ■0.'" 

^ 2 Q. 0 o 
0 CJ o 

■E o 0 0 S 

0 ■*“ D)X3 ^ 

E 0 .E .ES > 
0 2 '0 Jrt ^ 
e E 0 5S 0 
;c: £ 0 > x: 

E ^ 8 cat- 
^ 

CD CO CD 

W H— 4^ ” 

■5 0 o - 1 : 

Q.^ f- 0 3 
0 T3 0 5 

C ^ V-/ 

E 0 0 0 

o 0 0£ 

O. 

kio ^ ^ 

3 O O 3 iS 
o 05 O) CO. 0 

>- 0 0 .E Q 


-o .0 

8 Q-2 0 -S 
0 £ F :j= Q. 

E "0 0 E 

E 0 0 £ O 

B'o'.Q 2£ 

^ 0 B "O o 
0 CC o 0 **“ 

" 0 0 2 &' 

0£ ^ 0 8 
X) F 0 0 
■0 P tZ-.E E 
00 =3 

0 EiS'Sco 

■a 0 0 »_ .-t; 

*- Q.Q 0 C 

0 E .-V -01 Z) 
x: .E Q (z 

|ii!§ 


E >>-0 in > 

S||l| 

0 g ca — 0 

^ 0 n, 0 

0- 3 ^ -2 m 

0 o o -0 
0 >>*^ .0 CD 

§'23 

= 0 — 1_y 

m V y— I ^ 


0 X !c • S 
0 0 5 ■=:- 

2o02|i 
■ ^ O) 0 I 

0 S- i-0 

£-2 3 0 0 

0 Q DC 

O 0 0 0 0 

> £ -0 -0 -0 
^ 4—' 4—» 4>^ 


0 x: 

0 2 

o 0 
0 

TJ 

0 D) 
C C 
D)~ 


0 2 
XI p 
0 

F 0 
O) 0 t/> 

E 0 

._ TO £ 

0 S E 

.0 Cp 0 

^ J E 

0 0 ». 

E 3 0 

"O -C 

■0 o n 

O c ° 

2 ^ 

0-0 

0 0 0 

K ~ ~ 
0.2 
^Bsz 

3 W o 

9 0 

O 0 0 
E x: - 
<n 

•E 0)0 
0 C 3 

E c "0 
0 £ o 

0-^ E 
083 

( 3 )“*“ c 

’U) 0 0 

050 

^ w c 

D. C — 

0 8-2 
■^0-0 (0 
£ E o z 

■PcD ^ 2 
E -0 ffl F 

0'0£ 2 
o 0 o C 
^0-0. 

0 0 0 jr 
0 0 0 2 
- D) 0> '_ 

E .E .E z 

0 0 0 Ml 

0 0 0 Jr 
*^00 Q 

£ Q. a w 


o- c 
0 0 
3 E 

10 
E 0 
0 E 

2 c 
0 0 
> o 

0 3 

0= O 
0 5 >.. 


s§ 

T3 ^ 
0 0 
0 SZ 
3 |_ 


0 .-ti 
£ Q- 

0 Q. 
I C 

flN 


0 O oj 

1- 0 c 
0 0 0 
^ 0 ra 
0 2 
O C Q. 

0 .2 
I 0 c 

£ "o .c > 
3 0 0 F 

o £ c O 


s 

£ 3 > 

O Q. 0 


I 


Students should be able to; 

• Explain the actions each module performs 

Megaprogramming in Ada Course: Irformalion Hiding, 3-3 





Stepwise Refinement Desig 



Megaprogramming in Ad:i Course: Information Hiding. 3-3 Copyright © 1995, Software Productivity Consortium. 


















DISCUSSION 

This slide shows a stepwise refinement hazard: problems can arise from changing an early decision. 

Suppose you change the representation of Data. For instance, suppose it’s an array and you want to 
change it to a linked list. Look at all the places where it’s referenced (shown in boldface). You will 


CD ^ 

c i'-s ® 

5 CD c 
2 CD ^ 

£ 

■D ^ E ■§« 

Oj o p 

V. >' 0 

0 O — 

.y ca 

o 2 o 0 
o ^ ‘w 5^ 
22 o ^ 

f= "O ^ 

C 4-I 

S 5''0 W 
^ g 05.2 
SJ C "D ^ 

Q- vl 
0 £ 8.0 
O *- >- :g 
O.E 

C) 

2 g Q.»- 

iS X o 
^ 0' 0) ^ 

d Q.-^ C 

o n c •?= 

0 0 0 
CD o > 

^ C^ 

0 d ^ 

^ 5 2 -- 

O 2 ^2 

0 ^ o 

-S? ” > -O 05 
X) o 0) V, 

sf 2 8^ 

0-8 o ^ E 

■COT PE 

0 O c ^ 

R t -0 0 E 

.2 x: Q. 2 

■c o ^ o 2 
S.2 o S.-0 

0 £ c 
.2 Q. 0 0 
■ ■ 05 i~ 0 
0 ^ C t= 3 

2 O_ O 

HI- 00£ 


8-^ i= 

I- ^ 

Q. 3 < 

0 2 £E 

W 05 lZ 
>1 3 ^ 

XZ O “ 

^ £ H 

gi S 

05 Q 
*-■ 0 H 

^ h: 

—I o </) 


0 >, C 0 
C X5 0 

o-d£ g 

^ -2 - « 
<>• •= 0 
0 E 05^ 

0 'c 
Q 0 — o 
,^005 
O -3 „ 
^ 2. 
C 0 05 

O .N C _C 

"ca o 

0 2 

g 0 £ o 
^002 


0 > 0 ■ 

0 2 o 
■£99.2 0 

^ o t 
0^00 
^ ^ 4- 

■t; c 

£000 


05 05 - o 

p 2 C O 
O’ CL O O 
O i_ ^ 

0 3 0 0 
>• O X 
>> ^■’3 

■f ■§ P ^ 

0 g 0 P 
c ^ -o 5 

0 3 . 

JS 9 3 0) 
O .,s ^ 

>-0 o 
O O ^ c 

2- E c^- 
.2200 
X ^ P 05 . 

3 _0 -O 

-O H 
>'-■2 0 CD 
0 .— H 
2 0 0 H. 
O > C\J , 

O a. 0 CO , 


X5 -Q 

o 

0 *- 
■Q ^ 

S s 

o c 


C LU 
0 


Megaprogramming in Ada Course: Informalion Hiding, 3-4 






Hazard of Stepwise Refinement 





• • 













DISCUSSION 

This slide shows the chain of decisions the designer made when creating the design for this program. 

The slide shows both the decisions and the order in which the designer made them. Any time you 
design a program, you follow a thought process like what this slide depicts. 

The representation of Data depends on the algorithm for the main module. If you had decided on an 


C CU c 
« ^.2 
+- "o .52 
w o 
3 O) 0) 

C -D 
TO "O 1- 
<D CO t3 

CO £ 

^ ■O 

oisi d 

■ C o = o 
■n ^ S 

2 CO 5- y 

o O o -O 

o sz 

3 . C 0) 

-i? o £ 

O « 

CO fc C <D 

2C0;|1 

^ 8 •- 
5 2 .C 

.t= .2? .c c 
X3 O 
eg CO >, CD 
<0 -c TJ vr 

^ 55 5 3 

o > Crt .o 
iS CL D CL 

</) o O 0) 

ca *4- 
o ~ c 

2 iS CO 

§:§i 

i-g°2 

x: CD .y CO 
CJ CD — 

co c iS 2 

CD C O 
CD CD C/} 
"O > V) XJ 
CD CO CD C 
JC x: CD 

3 n 2 §■ 

CO 5 £ ^ 

^ -I ^ 

5 O CD 
E >^ CO £ 
C I -D 

n ^ CD CD 

O CO Q. o 
25fc ^ J? 
CO CO "D CD 


<3 

is® 

*25 iS^ 

k- M) C 
(D 0) 

£ E Q- 
*■^ 0) 

“Ssa 

to CO ■— c 
c p -c CO 
o 5 

■r: o <0 
m CD 

■S O JC 
^ "t; 

— <0 o 
■^co 0 ^ 

CO CD .2 S 
05 C T3 2 

CD ° ^ 

hS I ° 

. — 5. CO 
CO CD m ei5 
C 2 S{ CO 

c 3 S 

a .8 “ t 

■O ■*- 0) CO 
eg E £ CD 
3 O _ TJ 

■5 fc CO CO 
a? c .Si c 

CL.^’ C O 

c 8 £ £ 

O -3 o CO 

■0= -Q 
C CO o O 
2 o 

§■ g n g, 

•a ° «5 c 
w ^ ^ 

w 8 g ^ o 

O c fc £: C 

• 033^0 
5 = O > < 

<5 >. c - ji 

S|.ll z 

_h- 0) i_ — 

Jir C 0) C Z 

^ CO "O _o UJ 
05 g >, W Q 
O) cL'iZ O p 
£- C (0 CD H’ 

£ .2 0) TJ CO 


o — 


CO CD 

M- > 

o 

Q. CD .ti 

E£ o 

CO _ D) 

^ .£ frf 
05 ^ ™ 

4-4 

C C^. CO 
CO tz -C 

.2 ’2 ^ 

ll€ 


CD CD O 
x: J3 

‘^-‘T "o 

CD CD 
O 00 CD 
C . C 

££3 
2 £ o 

■-1= 

.9 t (0 


c ^1 J= 
05 -o'.2 

c g ■§ 

£ 05 3 

c £ w 

.E CD 
CD.S " 

C/) 

CO 

2 £ "3 
05 -c; CD 
4= o -g 
CD 2} O 
JC CO 05 
T3 

>*- CD 
O JC 

|g| 

8 S 03 

■o c S 


cu ir 
Ct: CO >> 

^ 05 „ 

T3 O jf 

d 

CO E ■»- JZ 
cz x: O .-t; 

52 o CO Q) 

o ■= 

05 CO to ™ 

T5 .C 0 
^ (n tn 

2 £ c 0 
£ 3 .95 > 

T5 to ^ 

£ o 05 DC 

2 E^ CD 
</) 0) 5 ±3 
§ E §,c: m 

2 CD C3J > 

E > 05 ’55 r- 

‘l’ 05 P g »-- 

Q DC ~ -o O 

UJ 






e Design Decision Chain 



Megaprogramming In Ada Course: Information Hiding, 3-5 Copyright 6 1995, Software Productivity Consortium. 


















c 

o 

E 

E 

o 

o 

03 

w 

52 

!c 

l~ 

o 


CO 

o 


0) 
n 

= TD 

i 3 

O CO 


03 


X) 


z 

g 

(0 

CO 

3 

O 

CO 


c 
> D 

« 

CO •*- 

c 
0 o 
n 

:= O 
CO (0 

.52 ^ 

h- CO 


C 5 
E" "a E 
0 o £ 

Q.**- 
c <1> O 
° 

W -- CO 

0 c ® 

Q. 0 13 
'O' £ ^ 

cos E 

JE o a> 
5 £ 


0 

4 -* 

C 


o 

ic 

5 

■O 

c: 

0 

W 

0 

3 

n 

o 

E 

0 

x: 

k- 

^ 3 
O O 

■E 0 
5 c 
o S 

x: 2 

« O) 
CD 2 
CD Q- 


0 

0 

0 


C rr: 
0 8 
E S 5 J 

•t;^ SZ <Ji 
O CD 
. CO 

’ uj ■£ 

log 

5 .a jc 

a[ 

o 
$ 


0 

0 

XI 

TJ 


0 

C 

O 


c 
_ o 

O 0 

E ' 


i 

<i> 


O) 

c 


> 0 JC 


0 

^ d 0 

o^fE 

0 0 • 

0 0 _0 

0 :;5 O 

^ 0 E 

C 0 

i -1 
0 2 0 

ni ^ 

O g.S’ 
j- 5 0 

°- •- 52 

<D 

S’ ■“ 

0 'ni ■ 
C ^ F 

rr< -C* ^ 

g CD 


0 

5 

O 

JC 


c 

o 


C3) 0 0 TJ 


E o) 


0 


c 

0 


•t; JC 

O O 
CL C 

E w 
o >'J= 
o 0 ••« 
0 « 5 

"D 


° c CO 

>» 0 y 


g 0 

...52 

gp 


o i2 
«= 0 


— 0 0 .^5 

■■ %o 

. 0 

0 £ 
C 

.9 JC 
X 3 O 

tJ 3 
0 0 


^•3 0 

jT X2 T 3 

— 0 

0 o :E 

0 -E 0 
^ 5 


. O « 


0 


c a> 


0 


o E 
0 


O 3 0 X3 

TJ C 0 o 

S ^ o ^ 

CD 

c! ^ o j:i 
4-0 5 = 
~ Ci- 
iX W 
0 
> 
o 
0 


0 

L_ 

0 f_ 

0 -E 
N .y 

0 -E 
0 5 

I* 

0.C 

4 - 0 

0? 
E 0 

c 0 

E 

0 C 
»- O 
T- 

0 0 


0 


•o 
0 
0 
o 
C0 9 - 
,c E 

c 0 
fc o 
0 


o 


0 t: 

sag 
0 . 0 


- 0 
.52 Q.-I i ^ 

K^'S 
0 0 £ 


o *- -Ji O) 

0^S 2 
to. 

S0ca 
0 0.0 0 

^ 0 E 
I- 0 I 8 


0 

o 

x: 

0 

5 

o 

x: 

0 

o 

0 


0 0 _: 
O 


" 5 -- 

0 .9 


.52 
o 0 
cd 


0 ic .9 0 -o 

o 
c 


c 

o 


3 

X3 


O 

c 


0 


Q_ 0" 
0 0 


0 

LU 


0>2.g S 2 = 

*" 0 2 
3 


TJ 

52 ^ 


0 0 

0^0 
.9 o o 


■D TJ 
rC x: X 3 ° 0 

h- 0 0 E E 


0 

0 

o 

c 3 

0 


0 0 0 
o-gl 5 

0 O -g CO 
O) o 2 p 
0 0 D) E 

«“a| 

■p ^ 

S S £ 0- 
0 0 

E 0 0 W 

0 o 0 0 
.£ oQ£ 

0 -V 0 0 

‘-000 
0 S 2 0 

0 0 k 0 

$ E >2 0 
0 - 0 52 S 

T 5 

0 0 c 


5 = 0 
sz a 


0 


$ 

o 


5 o 


0 

E 
0 
XJ 
p 
Q. tn 


0 

E 0 
k 0 
c o 0 


0 0 9 

0 trt Q. S 
-0^0 

S 2 •a 
0 0 o 
0 J::;.JC: 

o 0 cs-sc 
•— is O 0 
0 a. j- c 

CO 0 Q. «= 

0 S, 

o 0 -c -S’ 
> x; CO 
.g 0 0 

c c "0 

o .9 t 3 


TJ 

0 


O.E 


P © ^ 0 O) 


c c _ ._ 
© g 0 "o 

© i 52 c 
S: o O r- 

“-.g-o 9 

0 0 ’trt 

> c 0 9 

0 0)0 E 
'0 •“ o 
0 0 "O 'tr 
“ 0 .E 
c 


C TJ 

° 0 0)9 


0 JZ 
'sz 


•O 

c 

0 

in 

I 

CD 

0 

■O 


0 


CO — 

-S 

TJ -O 


0 

k.. 

0 


3 

</) 

$ 

o 

c 


C 0 
0 

E 3 2 
CFt-O 

.0 o 


0 


CO 

z 

g 

t— 

u 

< 

a: 

UJ 


UJ 

a 

3 


CO d E 0 CO 


0 

O) 

c 

0 

0 


■O 

0 

"5 

0 

o 

0 

0 

0 

0 

XJ 

c 

0 

o 


I 


c 

© 

E 

0 

c 

4 - 

E 

0 

52 

> 

d 

0 

4— 

0 


0 

XI 

o 

O) 

© V 

.0 (D 

0 
0 C 

4— 4- 

0 XJ 
TJ 3 
0 

0 0 
I £ CO 

UJ 

0 k.— 


80 

© 13 

D)'D 

O 

E E 


- . 5 


O 

UJ 

”3 

ffl 

o 



c 

0 

O 


0 

XJ 

0 

0 

d 

d 

3 

O 

SZ 

0 

0 

c 

0 

•o 

3 

4— 

CO 


CO 

JC 


c 0 
0 o 

i ^ 

■E o 


0 

k- 

0 
.52 
5 

d N 
0 0 
0 0 


C 

o 

o 

0 

0 


E 

o 


T) 

0 

> 

0 

TJ 

0 

0 

3 

■O 

o 

E 

0 

JC 


o 

x: 

c 

jo 

d 

X 


d 

E 

0 

4— 

c 

0 

E 

0 

c 

0 

0 

52 

> 

d 

0 

44 

0 


o 

JC 


0 

d 

X 


LU UJ 




MegEprogramming in Ada iDourse; InfoiTTia'ion Hiding, 3-6 





Modules From Stepwise Refinement 











4 


■O 

o 

£ 

03 

E 

c 

O) 

U) 

0 ) 

■D 

O) 

c 

ig 

£ 

c 

o 

(5 

E 

E- 

o 

c 

03 

JC 

D) 

C 

CO 

=I 

T) 

03 

4-* 

CO 

03 

O 

C 

O 

CO 

o 

Q. 

E 

o 

o 

03 

■o 

E- 

03 

4—' 

o 

CO 

CO 

§ 

o 


Z 

g 

</) d) 
(/) T3 


is CO 


3 

O 

g 

Q 


CO 

CO 

•C 

h- 


03 wJ 
£ 03 
"O 
C o 

c c 

2 T 3 


r~ 

« « 
- 03 
•£ 3 
CO -o 
C7) O 

< E 


CO "g 03 
•- X3 £ 

i i-e 

<D Cu 

0 C ■" 

^ E « 

< >— 


CO 

03 


cvi 

'c 

3 


CO 

03 

C 


4-1 cO c c' 


CO 

£ c 
? w 


•o ~ 
S O 


03 

E- 

CL 

P 


« CO 


i-, = rr C 

p S o 


^ 03 CO 


03 

CO 

5 

a. 

03 

-4-* 

CO 

03 

C 

’co 

o 

•o 

03 

"cO 

03 

E. 

C3 

03 

5 


o 

- 1:^ 
trt OJ 
O 03 
— "O 


03 

•9-o„ 

o 03 C 
.£ o. co 
}= to > 

■^03 
C 03 03 
g CO fc 

tZ 3 

CO ^ 
Q-cb 

^ F 03 
^ c Q. 


o 2 


-ii: r= *- 
3 :E CO 


03 

£ 03 32 


03 2, 03 

C .23> 


■D CX3 


i_ CO 

cO 


o 
’5 

03 

03 
^ O 

“ 3 

CO TJ 


E 

CO 

.2 

03 

o 

+-• 

o 

o 


^ "O (^J 

o c 

T3 CO 03 

F ^ = 
= .2C0 


CO CO 

■C E 

r- O 

C— H— 

03 C 

'co _ 

-S S5 

T3 *4 

c 

= 03 
03 CO 

> CO 

> 03 


c 

o 

o E 
iS ^ 

« 03 

<13 53 
x: (0 
_'e: 

o| 


o x: 

3 - 


CO 

4-4 

c 

03 
CO 

03 - 


.2 


0) 


o 


03 
03 
- c 
CO <5 
£0 

0) ® 
03 03 
C" r- 




CO 




03 


= O 


03 


<13 4-4 £ m 
O.P 


C -O 03 
CO CO .C 
O 03 

" 03 -C 


P 

O 

X 

03 

C 


03 
03 03 
C CO 


■"O 

c 

CO 


032 

■O T-l - 

CO ^ CO 

E S g 

0) C t 

r“ -C 

^ o I- 

.0 = in 

CO 0) 

■5 5 .£ 

03 — 

•a C “5 

E 2 CO 
03 CO "co 
.c ■!=; = 

^ <13 o 

O 2iS 

^ <13 S 

CO 

O 0 ^ C 

3l5.i 

•4-^ ' 


0 

E 

03 

c 


O) ® >- 
C Ci. 

‘n C3 
:= 03 
O Q. 

O — ■♦■4 

■“ 03 c 
E b 

0 ) Sf; ._ 

Q- 'tcc 
O 03 

03 5 ■“ . 

x: 03 T3 

h- C13 CO Ci3 

x: o 

£ 03 F-'O 
CO C 03 P 
03 tfl *- 
Q. 

4.4 o o 
c t 

^ 2 .« 

F c: JO 
Q.-- - 


b ■“ 


o 

03 o b 

> si CO 

03 2 


03 

U- 

co 




2 
3 

o 

2 

4-4 

CO 
CO 

Ic 

^4 

03 
CO 

2 

C3 

2 
■a 

03 

_ 5 

O F O 


cO 

03 

03 

CO 


CO 


a. 03 

E 


s B t/3 

l2-i 

CO o ^ 

03 2 
cO CO 2 

_ P E 


2 ^ 03 

O S= T3 CO 

3 : - 

□ > "O W 
03||.E 

=5 t ^ C 
CO O CO 

03 CO o £ 
^ 03 "O .. 
CO C O ■£ 
£=E0 


Ci 

03 


03 

2 ^Ll 

<F 1=: 

b 03 ^ 

■F 5 
>,"0 

c — o 
cO 
F 

CO 


E 

03 

E 

E 

CO 

03 

03 

c 

O 

E 

CO 

c 

o 

V 4 

CO 

g 

'c 

o 


CO .2 


03 CD 

P= E 
o-i 

CO b 


x: 

I- 


nfi 

CO F 

b 8 

“ O 
DC 4- 

_ . "O 

CD. 03 03 
X 1= 03 
03 U- C 


>. 

■g 

3 

4-' 

CO 

o 

c 

CO 

4-* 

03 


03 

O 

■O 

o 

E 

c 

'co 

E 

03 

x; 


03 

03 

CO 

o 

2 

o 

X 

03 

o 


b 

<>• JC 

><4-4 

Q. 03 

CO b 
03 JC 

o 

■a CO 
cO 3 

:E 'b 

5 ° 


b 

O 


T3 

O O 

E ? 




03 

5 


cO 

jx 

03 

.2 Z 

.2 o 

o ^ 

03 H 

■D O 

03 
JC 


< 

DC 

UJ 


03 

3 E. 

O o 

4w 

F ' . 
C -o 
1_1 to 
F 


> F 

I? 

SI 

O F 
C C 


« 

F 

XI 


F CO 


b 

■O 

o 


J- 

z 

UJ 

Q 

3 

h- 

(0 


F 
-X 

o 

E ^ 


c 

'f 

E 


w 

F 03 


X 

h- 


o 

M— 

C\J 

T— 

I 

CO 

F 

X 

CO 


CO 

UJ 

> 

O 

UJ 

-3 

DQ 

O 


b 

n 

F 

F 

JQ 

'a 

g 

u 

X 

CO 

CO 

4-4 

c 

F 

•O 

CO 


F 

> 

F 

X 

o 

F 

P 

F 

O 

X 

CO 

X 

o 

X 

"f 

E 

c 

03 

'co 

F 

n 

F 

>> 


•o 

c 

F 

C 

F 

tr 

o 

Q- 

-i 

.« 

F 

O 

cr 

F 

■D 

C 

F 

Q. 

F 

T3 

C 

b 

O 

"O 

o 

E 

X 

5 

■Q 

C 

F 

■E4 

CO 

E. 

F 

"D 

C 

13 


• # 


Explain the goal of this decomposition versus the one created using stepwise refinement 








H- 

■o 


o 

© 

■o 

(A 

c 

(D 

(0 

o 

CD 

0 



a 

o 

b 

0 

c 



’3 

(0 

0 

■■■■ 

> 


0 


o 

0 

c 

c 

c 

O 




c 

O C Q) 
+= D)-= 

lo! 

w o 

= .s-± 

« g <D 

t) ■= .E 

-I a._i 


Megaprogrammlng In Ada Course: Inlormation Hiding. 3-7 Copyright C 1995, Software Productivity Consortium. 




















DISCUSSION 

This slide sho.vs the decision chain for information hiding. 


( 3 ^ 


Q) Q.^ 

15 | 

E-Se 

■=23 

In® 

E 2 -o 




0 

i_ ^ tfl 

o-a (n'sz 

t/> cC , 

- eI 

5 0 c 

2 o 
‘^^00 
0 0 oj 2 

ro £ 

■a ♦- 

c ° - 

« 0 5 3 

« a)« « 

o ® 

5 § 

CO'*- C(J 0 


0 

Vi 

■a 

c. 

o 

o 

0 

W 

0 

x: 


0 

Vi 


IQ 

O t 
' ? O 

I ^ Q. 


0 

Vi 

4 —• 

Vi 


0 

x: 


US’! .S 
.E.Q 

.£ o Q ■o 
•- S « 

W XI “ > 

C s 2 

^0 3 ^. 


>,™ - 
E P ® 


.s™ 
: >- 


0 C -S 

c .E O C 

0 c 3 g 

E “ ^ t 

■~ • O QJ 

9>tn E.E 

0 o 

tf) 0 .. 

■ "D 


O' 

0 


5 P Q> n. 

< 1 ^ w-* (0 ^ 

® n x: 

0 2 t: 

0 , c 5 


« 

0 

3 

■o 

o 

E 

0 

05 

C 

0 

sz 

o 

Q 

•O 

0 

0 

c 

c 

o 

3 

o 

>> 

0 ' 

05 

c 

0 

.C 

o 

0 

c 

0 

E 

0 

■3 

CT 

0 

V- 

0 

x: 


Vi 

0 

3 

•o 

o 

E 

0 

05 

C 

0 

x: 

o 

o 

4—< 

T 3 

0 

0 

c 

c 

o 

3 

O 

>. 

05 

0 

4-* 

0 

c 

o 


0 

0 

0 

O 

L- 

0 

0 

C 

0 

2 

3 

■o 

o 

E 

3 

o 

o 

>n 

c 

0 

E 

0 

05 

C 

0 

sz 

o 


0 

3 

O 

3 

>_ 

0 


0 

4-4 

W 

c 


3 

O 

>» 

0 

0 

o 


>. 

0 

I.- 

0 


0 

C 

0 

E 

0 

Q. 

E 

3 

O 

>% 

0 

05 

C 

0 

XI 

u 

3 

O 

>1 


c 

0 

05 

4-5" 

0 

0 

k- 

4 -* 

c 

o 

o 

>. 

X 3 

4-5' 

c 

0 

C 

»>« 

U) 

_c 

'S 3 

>— 

0 

0 

? 

Q. 

0 

CO 


C 05 

^ £ T) 

XI 05 

0 ^ c 

0 C (fl 
0 O XI 

~ ‘-S “ 

0 c — 

05 - « 
r-CO-Q 

E 0 c 0 

0 XI •“ :t: 

o o c 0 
c •— _ 
o 0 0 0 
o t S).Q 

5 c o 
0 o 0 05 

O i: t 3 95 

.^“00 
o c •*- x: 
<u c >,_ 
■o 0 -^= 

^ 05 Xlr£: > 

•c 2 — 0 

0 Q. ^ E 
0 0 0 

•^0 0 
0 ™ • ‘o 

|£ S ^ 

.0!^ 

II £| 

0 -c 0 — 

I « 0 ® 

X 8 o c 
c!« o 
0.2 O C 

iR«i 

° X 5 ^*-. 

0 g 

S • UJ ~ 
0 0 tj 
® C <;j g 
o c *- 
^ £ O ®- 
0 0^-0 
C 0 — 
"O <u " 
c 0 


o 

0 


® ® 0 0 
§■ 0-2 E 
-o 2 Q- ® 

_ 0 c 

1§ « ® 
T 3 0 0 
"O 0 

k- 

O 


<z 
0 
3 
O' 

0 
V- 

0 
05 
C 
0 
XI 

o 

XI 

£ o 

^.1 

Vi 0 

E£ 

2 0 

05 Q- 
p O 

0 “ 
05 .E 

0 ~ 

r- 

0 c; 

0 ® 
c E 
.E>fe 
0 'tr 
Q> S 
a . 

. 0 

0 05 
05 C 
C 0 
0 x: 
x: o 
® 0 
£ ® 
iE 

05 E 

£ E 
0 
0 
■D 


0 

C 

o 

■0 


® I. 


.52 0 0 0 

8 E E 0 
tS XI x: 1- 
^ ^ 

000c 
■t 5 2 ’ 2 »£ 
_j 0 0 £ 


05 

c 

p 

o 

XI 


E 

XI 

o 

05 

0 

•O 

c 

0 

0 

k. 

3 

4-4 

O 

3 

L- 
4—' 
0 

0 

c 3 

Q 

c>- 

0 

0 

05 

C 

0 

XI 

o 


0 


o 

3 

b. 

0 

0 

4.4 

0 

"O 

0 


O0 2 


fi 


C 0 
.2 -O 

0 o 
0 0 

I 


XI 0 

o x: 

c 0 
•- 0 ) 
Jr, ^ 

(D r- 

■o 0 
O O 
0 
.C 


c 
o 

■si 

0 a> 

Qj T 3 
C 

= 0 
0 £ 
£^ 
® 

cc 

I- 

■H 4 0 
0 

eE 


XI 

0 


0 
w 

05 

2 d) 
0 ) 

0 

^ 0 
0 ® 

44 

c 
0 

E 

23 

3 X 3 
O . 
0 0 

® 

.c £ , 


0 

> 

0 


0 

0 

CO 

w 

05 

rt. S' ci 5 

0 C r" 

0 

z 

c 

0 

0 

05 — £ 

44 

0 

XI 

g 

H” 

C 05 2 
0 ^ 05 
XI *- > 

4-4 

0 

0 

0 c- 0 

0 

c 

05 

< 

oc 

UJ 

c 

0 

’0 

!,«£ 




vx 
0 

2 ■O ^ 

»- 0 0 

2 XI 0 

m 5 £ 
D 

3 • 

h- 

V> 


S' ^ 

0 Q-x: 
00:^ 

& >* o 

3 0 05 

CO £ 0 


UJ 

> 

p 

o 

UJ 

-3 

CD 

O 


0 

XJ 

0 

0 

X3 

P 

3 

P 

0 

£ 

c 

0 

'O 

3 

0 

0 

.C 

I- 


S. 

0 

S 



Explain the first decisions you make in information hiding 



il ^ 

O "O 

c 

(/) (0 
c 

S. S2 

O fe W 

^ » -Q 
O ^ u 

«-D £ 

O IS o 

^ £t5 

« IS ra 

2 ^ ^ 
CO (0 0) 
Q. 0) O 

W 3 3 

s?? 

■S 2 S 

:5 • • 


0 I 

“L 


T3 *2 
O (0 

E "o 
0 E 

■o o 
o w 

q2 


0 0 
0 >- 
C 0 

1-1 

I» 

C 0 

E2 
' 0 ^ 
T3 ^ 

O "S 
^ Si 
o E 


3 <n 

V. 0) 

w .£ 

•C O) 

■S *= 
^ =5 

■S 1 


Q £ 


E 0 
£ 0 
.t:: c 

.11 

’1 

■o 2 

II 


k =3 

o a 

I« 

0 O) 
■O -Z C 

o o •■= 

0 D> 'Z 

Q 0 5 


0 > 

O) ^ 

c -o 

(0 

£ 0 
O -c 

c S> 

g ^ 

0 o 

3 0 ) 0 

o C 3= 

>»= 0 

5 g G> 
Dot: 


h. m 

O -s 

F "O 
t o 

0 :£ E 
■o -z _ 
o o .E 

(U O CO 

Q 0 E 


o = 

E •£ 
0 £ o> 

■O -z .E 

■q O ^ 

® £» s 

Q 0 £1 


2. F 

■='w 

s ® 

!5 S 

O ^ 

So 


• • 


¥-■ 













I 


' C CO o 
0 ) (0 
' T3 2 .£ 


m I— -♦-» 

O c 05 to 
0? 05 


-5e1« 


o §-d_^ 

9 S 3 OJ 

^ ^ 


05 £= ^ 
- 

^ CO 

o T, 0) 

Si'o 

f/5 

Q-x: c 
o «-> o 
.£ o c 

^ 'Iw 

Q. i_ JO 
05 -h 

^ c 

S S o 

TO — TO 

05 it-' O 

al;;? 0) 

^ -a 

<D ^ 0 

1 E£ 

W 0 Q 

CO ^ c5 
jc o 2 

I— CO o 


£ t= t: 

; ■§ is 

! ■D ^ 5 

■ 5 -a o 

■ cO c3 »- 

> -c 03. 

C3 . (0 
CO ^ - 
•t: 5 §• 

^ O 0 
°^.Q 

.iso 

^ o I 

jED|5 

03--11 

o -O -c 
O- 0 (- 
05 ^ o 

*- CD 2 

is > -s 
0 0® 
i- o E 

^ CO O 
CC 0) , 

E Q.— 

CO JS 0"' 

o-i 3 

3 0.-0 

^ o 
O c c 

^ -G is 

CD 0 O) 

£ -t .S 

o « CO 
-00 

£ CD 5 
< .C 0 
3 0 - '5 

= ■0^0 

S p.g 5 

= CO o 
r) 0 0 x: 

- .C SZ £.» 

sr o = 

E O 8 03 
• c £ C 

0 o .o o 

5 ^ CO C3 

5 8.iS 

§^■2.2 
3 £ .£ 0 


3 CO 0 3 >- 

C 03 > -o ii 

SS § I o 

B o c c 

! 8 ^ 5 | » 

1€Se ” 

:s»i^ s 

E-sg,!^ I 

£ *- CD ^ o C 

a. raifc ^ 

^ P ^ </) *0 Q) 
p c ^ X3 0 

. 0 o — 0 

E TO 03 f5 
1 |o3 g T3 

C 5-^ OS 0 

E cr . ^ E .c ^ 

2 TO o: ? o t3 0 

O) C.26 EG g 
O 03 G . C 03 .9 

S' $ i| - S' g 
” -oa-Ss “ i 

o-‘ 0 G c CO 

D) ^ •= 0 03 0 "p 
03 0 0 0 3 c 

^ 3 S C i 5. ^ 

O •=->^ .= CD >> -o 

o C 0 S 

S^'to f .| i 

O C is ..g G 03 TO 
0 0 = G .9 E ” 

'.i Bp is I 
s^i ” is s 

M^s- £ c o -c 

■9 2 ° .93 0 oa- C 

™ a. c 0 > O) 0 
S O O -g 'p :§ 5 

3 i2 "O ^ g S 3 
- 0 g 3 -Sx: O 

C 0)0.9 0 C ^ 

0 C 0 >” o TO 

^ ;-g "9 .c G G C 

o - 0 : G TO *= E £ 

>- c .c 0 -C o 

■ .2 =1 P ■§ 0 

TO — TO -a 5E .9 3 

0 0 0 O 0 CO 

3 E 3 E — — 0 

•D n "0 CO iO fl, 

O £ O 0 0 o 0 

E £ E £ > H 


> ‘F c 

0 TO -4= 

*" (- E o 

o ilt 

° '0 

.9 c o)G 

« TO ""Jg 

CO © 0) 

C Q-— 5 

9 2^0 

I0I1 

g-Sp £ 

2 -i.g0 

iSgo| 

G .S c: DC 

”0 0 0 

0 ^ > p 

C: p 0 

0 5 -C c 

C .S'" 

.2 0 0 p 

0 05 0 :& 
c TO ^ i_ 

O 0 §) §5 
C= ? 3 J= 

0 -o 
S o 0 

S P C 03 
f- 0 c c 
0 1-0 
TO 3 0 x: 

0 .Co 

Q-g o o 

0 fc - — 

2 £ .^0 
o’p-g 

— O) c 

— 0 .9 0 

^ cgI 

3 0 0 0 
p t x: 
>'0" 00 

« Q. !=^ 0 

g’E -^ ? 

05 05 

_ 0 C 2 3 

§E'P1 

»||»E 

2?|i'i 

h- Q..9 u_ E 


0 0 
TO 2 

O 0 
0 0 
S 3 

Cl 


^ 3 •■ 

o 

fc >s‘ 


t o 
o *= 

fr 0 

W 4-^ 

c 

.2 s 

>,2 
P CL 


w 5 2 


:C ^ 

— > 

/1\ ■ . 


0 OQ 
B O 


05 ._ 

J 3 .0 

0 '0' 

E E 

n^ 

S G 

3 

o c 


0 X 
C Ol 
0 






Information Hiding Principies 


! \ 


O) 

c 


0 ) 

E 

o 

CO 


c 

o 

ra 

E 


c 

C Q 

O c 

1 > 
^ 52 
^ E 

cS o 

D 

0) *0 

5 ? 

■D C 

O k. 
C 0) 
^ JZ 

o o 

CO o 
LU C 


O 
CO 
X 

o 

O) 

c 

E ±; 

XJ o 

n 

CO 

o > 

42 i 

o 

.E CO 


CO 


CO 

o 

^ 3 

£ -o 

o 

® E 

3 ^ 

■u 

o _ 
c o 


o 


O CO 
CO -C 

UJ ^ 







• • 














DISCUSSION 

This slide shovi/s an interface for the Line Holder module. 

The Line Holder holds a list of lines. You need it to provide the sarrie capabilities the array did in the 
stepwise refinement-derived program. It must let you store lines, access lines stored, and determine 


O) 

inB 
— c 


O Q. 
« O 
03 C 


=> E 

T3 Q) 
<U .C 
C 

W C 
03 03 

■a > 

03 2 

3 ^ 
•a 

9 ^ 
E -Q 


03 C 

f Bed 

I gw 

E 03 
0 o:d 


3 0 0 C < 

o Q.^ (C : 
>,^o O ' 

0 C 3 

E eel — o 

O CO . 
'■*— 0 “ - 
03 c /3 c TO 

.y =Zj 0 
o ; 

s.0o,«: 

05 B I ^ 

S c 0) 
o *5 Q- 5 • 

^oZ 

o g: 


•- 0 a? = 

^ O 0 0 
£ 2 o T, 


^ 0 -S .2 

3 q ^ 0 o 

■e3 o _ C 

O cx% o 2a 

.E 3 >s.^ 

o M- . .52 0 

>°0-',-g 

B CO w 2 o § 

;c0°l-,Z 

'2 .2 c 03 c 

TO o ^ e: 

0 n o .2 -I, 


E 0 o 

0 x: +3 

2 5^ 

CL O O 

< "w .E 


0 0 03 

25^ “<■ 

0)0 i: ^ 

CO Qi 

j*: 0 0 g . 
q -p u) 2 

0 .E 3 ^ 
O. c 
0 0 0 0 
£: 

^^03 

0 -firt 0 o ; 

^Es>- 

^ —I . 

“ 131 

o 0 .<2 — 
>- -o □ 2 


T3 Q. C 

0 a B 

- O) 0 
0 C c 

E 0 52 


.52 ^ 


03 (1) 

E ^ 

11 

I?. 


0 Q- 0 

eB B 


■*- 03 O 

0 c I 
~ ■*—> 
O TJ 0 

z a □ 


^ UJ 
- > 
0 I- 
2 O 
0 

8 S 

D O 


2 2 
3 

o c 


2 X 
c LU 
0 


• • 


■pqaprogramnninri in Ada Course: Informafion Hiding, 3-10 






interface Example: Line Holder 

















The Hidden Information 


^T3 

to ■g 
o' o 


0) 0) c .£ — 

f s'g’-'? 

•5 Q. O O 
C3 

a 


o II 
ja J-L 


l: o 

Oi CO 

a> «J 

E 3 g 

3 CO ■== 

2 >. 

CO CO T3 
CD OJ TJ 
c c .g < 


O a> 

I ^ 

CO ■*= 

I o 


t c 


CO 

CD 

3 

cO 

> ^ 
^ F 


CD .E CD 


CD 
. , C 

S ^ 
S 

Q o 


S’ >S o •£ 

^ W c§ , , 

« E I CO .E 
S -'1 E 

$“°,E 

•s.i,-a'f § 8 

I _l _J O 

O X CD CD T3 

to ® Q- Q- y 

: > 2 S 


E §5 

o £ ° 

1 -^ S 

iS a> 9 


g (0 

Q- CO ."z: 

(1) -S £ 

jC « r*) 

H £: "a 










z 

9 

</) 

Ui 

D 

O 

w 

Q 



Megaprogramminq in Ada Course: Infonnation Hiding, 3-12 









0> 

I s 

® 5. 


CO 

'w' ^ ~ 


— O (D 
c' “ I 

E CD JS 
(0 c Z 
2 □ 

os' J - 
:= = LL 
LL CL I 

1 = 3 
= '5rB- 

Q. CD 3 

S C O 


i-C S UL 
I S2 I 
■a CD 0) 
CO > .♦; 
o o ^ 

cc oc $ 


U_ CO 
c 

n .£ 
Q. _l 

3 ^1 

° 

M ® 
o 

ilT 3 
r o .E 
® ~ 
CL m i- 

O CO £ 


_c 

-I, CL 
O 

3 o 


—' _l 

.1 c 

. 5 ^ 03 


- =3 ^ 

LL O. ® 

!±> c N 

S .55 

Q. (ij .ti 

O 00 = 


CO 

cu 

CL .S 

O _l 

o „ 

. ® ^ 

— tx 

•*J ® 1 

O -■ o 
! r H 
■a ^ I 

C 0 ® 

m c .S 

■ 4-> "j I 1C •-- 

® -o O 0 

|C5<-o g 

5 ® O 


I =- 
"D O 
? O 

< -D 
C 


« « 
8 g 


(0 £ 

o 

□ o 

■D c- 

E -B 

0 iS 
w c 

0 s 

£ w 

;r P 
o SL 
0 £ 

o ^ 


• • 


• • 






















J 





Another Implementation 


o 

o 

(Q 

t: <D 

S £ 

.E (0 0) 

S' E 

jC £ (0 

H (/) OT 


0) LO 
■s? LO 

> ^ 

Q- ZZ- 
w ^ 

W 'B 

u. ^ CO 

O H-' 0) 

I O c 

-J J -* 

iii W CD 

.E □ Q. 

0) g.:5 

C3) 5; 3 
nj CO 


(0 

W c = 
0 ) O -D 
U JS O 
(0 ^ Jsd 
t 2 C 

<D ^ IS 

c 5J « 

0 > s 

:C ^ 0) 

h- Q. 3 


i "S 

Li o 

£ 

c ^ ^ 

E “ E -'i 

03 CO CD M-' 

UU C LU CD ^1 

W^iW^W 

-'i q -I, hi -b' 

C CO C CD CD o 

Li Li Li > Z g) 

CD CD CD -n 

Q. Q. Q. 2 

3 s 


c 

d) 

I « 

C 3 L 0 ) ^ 

E =.•£ 

O S o 

£ S J? 

K- 3 (0 


CO 

CO 0 

Z .£ 

CD _l 

? oT 

O N 

^ll 

0 .-t; 

c c 


C C II 0 

I /ft ^ 

—* 0 C/) ~ 

•*1^ iT (Vi fv< 

= w vw 

o ^ n F 

•° g .s - 

0 O CD) "D 

C5) i- CD C 

0 Q.X) 0 









DISCUSSION 

This slide summarizes the topics co ered in Unit 3. 

In software design, you break up a problem into a set of modules that, working together, solve the 
problem. You should do this to help you manage the com- axity of the solution. Think of how hard it 
wou'T oe to write programs if you couldn’t use procedures o. jnctions. 


o 

■O CO 
O ■=; 

O § 

O) O. 

Co 

W 

03 

<= d 

■8 .95 

> "D 

”5 

:3 o 

O >. 

o 

5 a- 


<2 <0 

C CO 

O Crt iJ 
CO 03 
CO 03 .C 

C 3 o 

c: o c 

CO 

O D. CO 

S5 to.'9 

Q r: .c 

c ;5 o 


o c E 

>,0 - 

Q. CD 
^ 2 — 

w !■§ 
£ O.E 

CO o 

=> ■R E 
^ F ^ 

< t CO 


o o *- 

ic § « 
5 .Q E 

- CO E 

03 — 03 

^ o 

<15 ^ 

P 03 Q. 

S 

g 

to 

c E o 
E o <u 

O Cfl Ol 

•p ... X 
P p <D 

• o 2 
E Ro 

03 CO 9 

221, 


CO c o 

E.Q ° 

« 13-a 
o o 

O);^ O 

.9. -o <=” 
p O o 
.25 F CO 
<55 CO 
03 -a 
•Q 03 CO 
CD :> 

Jto c 

CO o <« 

® eto 
= ^ CO 

CD 03 '*" 

t 1= 9 o 


W 2-- 

i] °-R j? 

al (/) 

- oP ^ 

C CO 8 O 

F o 2 m 

o t CX > 
C o c <15 
P Q. F T, 


5 ; P -O 03 
CL CO CD c 

CD o P CO 
+.< cj —1 I— 


. 03 
03 CO 

c j*: 
ip ro 

.C Q. 


03^ 

W O 
3 

TD O 
.25 E c 

CO O CD 
03 +3 "O 
TD CO "O 

CO i ^ 
O O 03 

■5 “c 
•0-0 
O C 
F 03 O 
O CD 
O O 

0^0 

£ ® c 

03 ^ 

R E ■“ 

.i p CO 


03 

CD ;= 
CO CO 
v> cD 

CO 

Q. CD 
03 

cO o 
5 CO 

< cx 


5 CL 
CO CL 

_ p 

s -<= 

CO 

^ <5 
.25 8 

■O-D 
CD CO 
£ w 

O Ic 


03 W 

c Z 

'co O 
CO ^ 
03 r- 
g O 


^ UJ 

CO I— 

<15 

■o I- 

cj Z 

2 UJ 

CO Q 

E P 


o x: 

03 
073 0 

-I” 

•:= ■>> 


UJ 0) 

”0 TO 


c 

O 03 
CO CT 
03 03 

03 ■O 
p CO 


■O <15 

s ^ 

o 


03 03 

.C .C 

4 -* 

c c 

i5 i® 

C- CL 
X X 
LU Lii 


• • 


o • 






Summary 


CO 

0 ) (/i 

o ^ 

CO -5 

£ o 

■5 E 

O' M- 

0) o 

c "S 

o> W 
'co 

□ (0 


i 2 

C 

CO 

0 

0 

3 

0 

1- 

0 

■0 

0 

0 

c 

0 

w 

D> 

C 

CO 

CO 

'"O 

£ 

3 


0 ) 

w 

c 

O) 

f" 

O) 

.2 

CO 

E 


JZ 

0 

0 

E 

»« 

> 

CO 

0 

.Q 

£ 

c 

■D 

CO 


0 

GJ 

O) 

c 3 

0 


c 

CO 

'co 


c 

3 

*{0 

■ ■■i 

*> 

> 

> 

To 

0 

To 

3 

CO 

■ ■H 

0 

S 

Cu 



%lr 

> 

*D 

Q. 

CO 

■ MS 

■D 

r^m 

CO 

lU 

■ ^H 


0) 

> (0 
■5 o 

O Q. 
0 .ir 

£ o 
o .E 

G)' Q. 
Q. O) 

(0 E .E 

’55 

O) ■= 
C (0 

£ ® s 

■h XJ Q 


CO Q. ^ 

E « £ 

2 &■£ 

^ cz 
o o o 
^ o E 

LU Q. 0 

I -S Q- 

i Se 


Hegaprogrammlng In Ada Course: Information Hiding, 3-14 Copyright © 1995, Software Productivity Consortium. 












Megaprogramming in Ada Course: Information Hiding. Workbook 


UNIT 3: INFORMATION HIDING 


UNIT SUMMARY 

The first step of developing software from requirements is to create a design. In design, you break a 
problem into a set of modules and a structure. The modules, working together in accordance with this 
structure, form a solution to the problem. Breaking a problem into modules is important for two 
reasons. First, it helps you deal with the complexity of software because you can grasp the workings 
of a small module more easily than you can grasp the worldngs of an entire program. Second, if you 
are part of a team, it lets you allocate work assignments among the team members. 

Stepwise refinement is a popular design method. In stepwise refinement, you break up a problem by 
creating an algorithm to solve that problem. At first, you keep each of the steps of the algorithm 
abstract. If you cannot express a step as a single instruction in a programming language, you refine 
it into another algorithm. You do this for each step and for each step of each algorithm you create. 
You keep refining until you can express every step as a single computer instruction. 

At each refinement, you are making a decision. Once you have made the decision, subsequent 
decisions will depend on that decision. You can think of design as a chain of decisions. 

As an example, let’s consider the problem from Unit 2 of reading, reversing, and writing. In this unit, 
we shall change the example slightly: 

• The program will read and reverse a set of lines, not integers. The reason for this change will 
become clear in Unit 4. 

• A stack is not used to solve the problem. The implementation chosen here more clearly 
compares and contrasts stepwise refinement and information hiding. 

You begin stepwise refinement by creating a main module. This module describes an algorithm that 
will solve the problem and the data structures used in the algorithm. You do not state the algorithm 
exactly, but rather use procedures and functions to describe large processing steps. For example, the 
main module for the Reverscr program is: 

procedure Reverse_File is 

type List_Of_Lines is array {1..1000 ) of String (1,.255); 

Data: List_Of_Lines; 

Input„File_Nanie. constant String := "input.txt"; 

Output_File_Name: constant String ;= "output.Cxt"; 

I: Integer; 

be^in 

kead_File(Input_File_Name, Data, I); 

Reverse_Lines(Data, I); 

Write_File(Output_File_Narne, Data, I); 
end Reverse_File; 

This describes a straightforward algorithm: read a file’s contents into a variable named Data, reverse 
the contents of Data, and write Daca to another file. 









McBaproRramminB in Ada Course: Inforinalion Hiding, Workbook 


I ■ 1 

I ■ 

I I 

1 

! 



You next decompose each procedure. You might decompose Read_File as follows:* 

procAdur* Read_File(Input_File_Narae: in String; 

Data: out List_Of_Lines; 

I: in out Integer) is 

F: file_type; 

Length. Integer; 

bogin 

Open(F, In_File, Input_File_N£me); 

Set_Input(F) ; 

I := Data'first,• 
while not End_Of_File loop 
Get_Line(Data(I), Length); 

I := I + 1; 
and loop; 
end Read_File; 

In Ada, a procedure may have parameters that are declared in, out, and in out. The Unit 2 
Summary described in parameters. An out parameter is one whose value may be set but not accessed. 
A procedure can both set and access an in out parameter. 

The notation Data' first is the lower index bound of the array Data. This notation helps you write 
code that does not need to change if, for some reason, you decide to change the index range of an array. 

You follow this strategy until no procedure contains any procedures that need to be decomposed. Here 
are Reverse and WriCe_File: 

procadura Reverse_Lines(Data: in out List_Of„Lines; 

I: in integer) is 
Copy—Of—Data: List_Of_Lines; 

begin 

Copy_Of,_Data := Data; 
for J in Data'first .. I-l loop 
Data(J) := Copy_oe._Data (I-J) ; 

and loop; 

end Reverse_Lines; 

procedure Write_FilG(Output_File_Narae; in String; 

Data: in LiL ' Of_Lines; 

I: in Inttger) is 

F: file_type; 

begin 

Create(F, Out_FilG, Output_File_Naine); 

Set_Output(F); 

for J in Data'first .. I-l loop 
Fut_Line(Data(J)); 
and loop; 
end Wiite_File; 

You can see from the above discussion that Figure 1 is the decision chain followed to derive this 
program using stepwise refinement. 

* For .siniplidly and clarity, the code examples omit detaiLs of file input and output. 





# 





(i) 








I 


I 


k I 


» 


2 






( 




Mesuprofiramming in Ada Course: Information Hiding, Workbook 


Algorithm for 
main module 

i 


Representation of 
Data (array) 



Algorithm for Algorithm for Algorithm for 

reading file reversing writing file 

i i i 

Use a while loop Use a for loop Use a for loop 

Figure 1. Decision Chain for Stepwise Refinement 


Stepwise refinement has a hazard. The decisions made early are often crucial ones and, also, are often 
subject to change. Because decisions made late in the design depend on decisions made early, 
changing a decision made early often has global repercussions and necessitates many changes to the 
software. Such a change is especially troublesome in a team because news of the change must be 
communicated to all relevant team members. Think of how difficult this must be on a project involving 
teams scattered across the nation at several companies. You can easily sec why change is one of the 
great contributors to faulty and costly software. 

Information liding is a design method that helps you deal with change. When you perform 
information hiding, you use the principles of abstraction covered in Unit 2. You describe each module 
in terms of an interface and hidden information. The interface defines exactly what other modules 
can know and use: the essential information. The hidden information states things no other module 
may assume: the irrelevant details (urelevant insofar as other modules are concerned). This leads to 
designs where changes are confined to a few modules. 

In stepwise refinement, the early decisions focus on algorithms. In information hiding, they focus 
more on modules. Figure 2 shows the decision chain for the Reverser program derived using 
information hiding. 




Decide (o .separate decision chains for: 

■ • Modules that read, reverse, and write 
• Modules that store data — 


Decide modules needed 
to read, write, and reverse 


/ 


Decide algorithm 
for reading input 


Decide algorithm 
for reversing 



I 


Decide algorithm 
for writing output 


Decide algorithm 
for main module 


\ 


Decide modules 
needed to stoic data 


i 

ata! 
Idinj 

I 


Decide data structui ' 
for holding lines 


Decide algorithm 
for holding lines 


Figure 2, Decision Chain for Information Hiding 





■*) 


> 


» 


» 









.1 



Mcizaprogrammin|i in Ada Couisc: Informati o n Hiding, Workbook 


Information hiding gives you criteria you can use to judge the quality of your design: 

• A module is designed well if it does not know any of the hidden information of other modules. 

• A module is designed badly if the decisions in it depend on decisions in other modules (e.g., 
if Reverse_Fiie assumes Stack is implemented using an array). 

• Your objective during design is to minimize the number of badly designed modules. 

The ability to judge a design’s quality is an important part of sound engineering practice. 

Once you have created your design; you must implement it. The Ada programming language has 
features that help you hide information as you write modules; 

• You can use a package to implement a module defined by information hiding. You can use the 
package specification to show the interface. You can use the package body to implement the 
hidden information. The rules of Ada allow other packages to access any information in a 
package specification, but do not allow other modules to access information in the package’s 
body. 

• You can use private types to ensure that data type representations are hidden information. 
Private types declare a data type name that other packages may access, but they forbid other 
packages from making any assumptions about the representation of the data. 

Here is the Line Holder module implementt ' as an Ada package. First, the package specification: 

package Line_Holder ia 

type LiHt_Of_Line3 is private; 
subtype Line is String(1..255); 

procedure Initialize(Lines; out List_Of_Lines); 

procedure Add_Line_To_List(Line_To_Add; in Line; 

Lines: in out List_Of_Lines); 

function Line_Number(Lines; in List_0£_Lines; I: in Integer) 
return Line; 

function Nuinber_Of_Lines(Lines; in List_Of_Lines) return Integer; 
private 

Max_Lines: constant Integer ;= 10000; 
typo Lines is array (1..Max_Lines) of Line; 
type List_Of_Lines is record 

Number; Integer range 0..Max_Lines; 

Values: Lines; 
end record; 
end Line_Holder; 

The type LiEt_of_Line.s is declared private. This means other packages may reference its name and 
declare variables of the type, but they cannot reference its representation. This forces them to 
manipulate variables of type List _Of_Lines through the procedures and functions provided in the 





MeyaprogramminB in Ada Courst: Information Hiding, Workbpook 


package specification, the only ones permitted to access the representation. In this way, the designer 
of the Line_Hclder package controls what is essential information and what is hidden. 

The package’s private part contains the representation of List_of_Lines. The private part is that 
part following the reserved word private up to the end of the package specification. The private part 
declares a list of lines to be a record containing an array of lines and an integer variable that can store 
how much of the array is in use. 

Next, the package body; 

package body Line_Holder is 

procedure Initialize(Lines: out List_Of_Lines) is 

begin 

Lines.Number := 0; 
end Initialize; 

procedure Add_Line_To_List(Line_To._Add; in Line; 

Lines: in out List_Of_Lines) is 

begin 

Lines.Number := Lines.Number + 1; 

Lines.Values(Lines.Number) ;= Line_To_Add; 
and Add_Line_To_List; 

function Line_Nun\ber(Lines : in List_Of_Lines; I; in integer) 
return Line is 
begin 

return Lines.Values(I); 
end Line_Number; 

function Nuraber_Of_Lines(Lines: in List_Of_Lines) return Integer is 

begin 

return Lines.Number; 
end Number_Of_Lines; 

end Line_Holder; 

The interface to the Line_Holder package gives you enough information and functionality to write 
the other modules in the program. The main module uses it only to declare variables of type 
LisL_0£_Lines. Unlike the stepwise refinement version, it has no knowledge of how a list of lines 
is represented, so changes to the representation won’t affect the main module—or any other module. 
Here is the main module: 

with Line_Holder, Read_File, Write_FilG, Reverse_Lines; 
procedure Reverse_File ie 

Input_File_Name; constant String := "input.txt"; 

OuCput_File_Name; constant String := 'output.txt"; 

Input_Lines, Output_.Lines: Line_Holder.List_Of_Lines; 
begin 

Read_File<Input_File_Nanie, Input_Lines); 

Reverse_Lines(Input_Lines, Output_Lines); 

Write_File(Output_File_Name, Output_,Lines); 
end RGverse_File; 







Megapro.gramming in Ada Course: Information Hiding. Workbook 


Notice the use of the with clause, explained in Unit 2, to allow this procedure to reference the 
interfaces of the Line_Holder package interface and the procedures it calls. 

The o'he modules can also be implemented as Ada procedures. For example, the Reverse module 
can be implemented as follows: 

with liine_.Holder; 

procedure Reverse_Lines(Original_Lines:In Line_Holder.List_Of_Lines; 

Reversed_Lines: in out Line_Holder.List_Of_Lines) 

is 

begin 

Line_Holder.Initialize(Reversed_Lines); 

for I in reverse 1..Line_Holder.Number_Of_Line3(Original_Lines) loop 
Line_Holder.Add_Line_To_List{ 

Line_Holder.Line_Nuinber(Original_Lines, I), Reversed_Lines); 

end loop; 

end Reverse_Lines; 

Compare this to the stepwise refinement version. Notice how it uses the same algorithm but does not 
depend on how a list of lines is represented. This is especially valuable in a team, where developers 
need freedom to experiment with different implementation strategies and cannot risk disturbing other 
developers. Since other developers have made decisions based only on the interface, and since 
implementation strategies are hidden information, the information hiding method grants developers 
this freedom. 

Information hiding is a good design method for individuals too. You may have already encountered 
a situation where a change you thought would affect only one part of your program required much 
more work than you thought. Information hiding helps you avoid this. 




Megaprogramming in Ada Course: Informaiion Hiding. Workbook 


UNIT 3: INFORMATION HIDING 

GROUP ACTIVITY 


Hiding Information 

The implementation of the vending machine software was developed using information hiding and 
includes a module Change Calculation. The purpose of this module is to calculate the change required 
from the purchase of some item in the machini... The interface of this module is as follows: 

pacKaga Change_Calculation is 

typo Coin_Value_And_Number Is record 
Value: Positive; 

Number; Positive; 

end record; 

Number_Of_Coins_Used_In_DiEpen3ing_Change: constant Integer := 3; 

type Coin_Money is array(1..Number_Of_Coins_Used_In_Dispansing_Changs) 
of Coin_Value_And_Nuinber ; 

procedure Calculate_Change(Price:in Positive; 

Money_Received; in positive; 

Change: in out Coin_Money); 

end Change_Calculation; 

Procedure Calculate_change, given a price for an item in the vending machine and an amount of 
money received (both in cents), returns in change coinage that makes up the difference. For example, 
if the price is 60 cents and the money received is 75 cents, the contents of the array Change will be: 



Value 

Number 

Change(1) 

25 

0 

Change(2) 

10 

1 

Change(3) 

5 

1 


That is, the change is 0 quarters, 1 dime, and 1 nickel. 

The information hidden in this module is the algorithm used to calculate how many coins of each type 
to dispense. 

Here is the implementation of the module’s hidden information, that is, the package’s body: 

package body Change_Calculation Is 

procedure CalcalatG_Change(Price;in Positive; 

MonGy_Received: in positive; 

Change, in out Coin_Money) is 
Change_To_Dispense: Natural; 

begin 













Change(1).Value :=25; 

Change(2).Value := 10; 

Change (3) .Value := 5 ; 

Change_To_Dispense := Money_Received - Price; 

Change(1).Number := Change_To_Dispense/Change(l).Value; 
Change_To_Dispense := Change_To_Dispense mod Change(l).Value; 

Change(2).Number := Change_To_Dispense/Change(2).Value; 
Change_To_Di.spense := Change_To_Dispense mod Change(2).Value; 

Change(3).Number := Change_To_Dispense/Change(3).Value; 

«nd Calculate_Change; 

«nd Change_Calculation; 

Consider the following problems: 

1. Identify the hidden information in the Change_Calculation module. 

2. Can you think of another algorithm to implement Calculate_change? 

3. You are to build a new version of the vending machine. This version will be sold in Germany. 
The German monetary system differs from that of the United States. It is based on the 
Deutsche Mark (DM). There are 100 pfennigs in a DM. Germany has 1 pfennig, 5 pfennig, 
10 pfennig, 50 pfennig, 1 DM, 2 DM, and 5 DM coins. German vending machines don’t 
dispense as change paper money or coins less than 10 pfennigs. 

German vending machines dispense drinks, but dispensing food hasn’t caught on in Germany 
or most other European countries. Drinks cost anywhere from 50 pfennigs to 1.2 DM. 

Create a new version of the change_calculation module that calculates change for a 
machine that receives and dispenses German money. Make as few changes to the interface as 
you can. 

4. Why is it important that you change the interface as little as possible? 

HOMEWORK 

1. Adapt the change calculation module of the vending machine for use in another country. 

2. A rational number is a number that can be expressed as the ratio of two integers. Use 
information hiding to design and implement a program that reads two rational numbers, adds 
them, and prints the result: 

a. Decompose the problem into a set of modules. For each module, state its interface and 
its hidden information. Describe the interface as an Ada package specification; 
describe the hidden information in English. 

b. Implement each module. Represent a rational number as a pair of integers. 

c. Change the implementation of rational numbers to a single floating-point value. What 
are each implementation’s relative advantages and disadvantages? In what programs 
would you use one or the other? 














TEACHER NOTES FOR GROUP ACTIVITY 


The package Change_Calculation presented here illustrates how you can use the programming 
language Ada to implement modules designed using the information hiding design method. The package 
specification is the module’s interface. It provides a single procedure that another module may use to 
determine what coins, and how many of them, must be dispensed to provide a person with change for their 
purchase. The package also has several data and type definitions. This is usual in information hiding: 
developers will accompany the procedures and functions with data types that support their use. 

1. Identify the hidden information in the Change_Calculation module. 

The algorithm is the hidden information, so it’s the implementation of calculate _change. 

2. Can you think of another algorithm to implement caiculate_change? 

Here’s one. Though slightly more complex than the first algorithm, it’s actually easier to change 
when you do activity 3. The reason is that the original algorithm made a design assumption that 
change was always dispensed using three coins. 

procedure Calculate_ChangG(Price: in Positive; 

Money_Received: in positive; 

Chaiige: in out Coin_Money) is 
Chauge_To._Dispense: Natural; 

begin 

Change(1).Value := 25; 

Change(2).Value := 10; 

Change(3).Value := 5; 

Change_To_Dispense ;= Money_Received - Price; 
for C in Change'range loop 

Change(C) .nuit\ber := Change_To_Dispense / Change (C) .Value ; 
Change_To_Dispense := Change_To_Dispense mod Change(C).Value; 

end loop; 

end Calculate^Change; 

In Ada, you use the notation change 'range in a for loop to index each value in the array change. 
In this case, the loop index variable c assumes the values I, 2, and 3, in that order. 

3. You are to build a new version of the vending machine. This version will be sold in Germany. 
The German monetary system differs from the United States’. It is based on the Deutsche 
Mark (DM). There are 100 pfennigs in a DM. Germany has 1 pfennig, 5 pfennig, 10 pfennig, 
50 pfennig, 1 DM,2 DM, and 5 DM coins. German vending machines don’t dispense as change 
paper money or coins less than 10 pfennigs. 

German vending machines dispense drinks, but dispensing food hasn’t caught on in Germany 
or most other European countries. Drinks cost anywhere from 50 pfennigs to 1.2 DM. 

Create a new algorithm that calculates change for a machine that receives and dispenses 
German money. Make as few changes to the interface as you can. 








MegaproRrammin^ in Ada Course: Information Hiding, Teacher Notes 


Here is one answer. The lines in italics are the lines that differ from the original. The algorithm now 
calculates change for a machine that dispenses coins from 10 pfennigs to 2 DM. The interface had 
to be changed slightly to support this, since the U.S. version assumed that 3 types of coins (quarters, 
dimes, and nickels) were dispensed, whereas the German version dispense:. 4 types (10pfennig, 50 
pfennig, 1 DM, and 2 DM). 

package Change_Calculacion is 

type Coin_Value_And_Nuinber is record 
Value: Positive; 

Number: Positive; 

end record; 

Number_Of_Coins_Used_In_Dispensing_Change: constant Integer := 4; 
type Coin_Money Is 

array(1..Nuinber_Of_Coins_Osed_In„Dispensing_Change) 

of Coin_ValMe_And_Nuiaber ; 

procedure Calculate_Change(Price:in Positive; 

MQney_Rc:ceived : in positive; 

Change: in out Coin_Money); 

end Change_Calculation; 

package body Change_Calculation is 

procedure Calculate_Change(Price:in Positive; 

Money_Received: in positive; 

Change: in out Coin_Money) is 
Change_To_Dispanse: Natural; 

begin 

Change(1).Value := 200; 

Change(2).Value := 100; 

Change(3).Value ;= 50; 

Change(4J.Value ;= 10; 

Change_To_DispenGe := Money_Received - Price; 

Change(1).Number := Change_To_Dispense/Change(1).Value; 
Change_To_Dispense := Change_To_DiGpensG mod Change(1).Value; 
Change (2 ) .Number := Change_To_Dispense/Change {?.) .Value ; 
Change_To .Dispense := Change_To_nispense mod Change(2) .Value; 
Change(3).Number := Change_To_Dispense/Change(3).Value; 
Change_To__Dispense := Change_To_Dispense mod Change(3} .Value; 
Change {4} . Number .- = Change_To_Dispense/Change (4) .Value; 
end Calculate_Change; 
end Change_Calculation; 

• Why is it important that you change the interface as little as possible? 

Suppose you are part of a team and are writing a module that uses this module. You will have made 
some design decisions based on the interface you expect. If that interface changes, you may have 
to rethink your decisions. 












Megaprogramming in Ada Course: Information Hiding. Teacher Notes 


You will often find you cannot avoid making any changes to a module's interface. However, you 
can plan ahead when you design a module by thinking of the things that are likely to change. This 
is part of what information hiding is all about. The things you thi.,k are most likely to change are 
the things you hide behind an interface. You may have to make certain parts of the interface 
susceptible to change. Here, the number of coins in the monetary system had to change. However, 
by making that value a constant, you can let other modules rely on the constant rather than on a 
literal. In this way you can lower the likelihood of inadvertent effects. 








Mcfiaprogrammins in Ada Course: Information Hiding. Teacher Notes 


TEACHER NOTES FOR HOMEWORK 


Students may do the homework problems in any programming language, although using Ada will help them 
separate interface from implementation. If they use Pascal, encourage them to use units (if your compiler 
supports them.) 

1. Adapt the change calculation module of the vending machine for use in another country. 

In France, the monetary system is based on the French Franc. The coins are 1, 5, 10, 20, and 50 
centimes, and 1, 2, and 5 Francs; 100 centimes equals 1 Franc. French vending machines dispense 
coins from 20 centimes to 2 Francs, inclusive. Products cost between 1.2 and 8 Francs. 

package Change_Calculation is 

Nuinber_Of_Coins_To_DispGnse: constant Integer := 4; 

end Change_Calculation; 

package body Change_Calculation Is 

procedura Calculate_Change(Price:in Positive; 

Money_ReceivGd; in positive; 

Change; in out Coin_Money) is 
Change_,To_Dispense: Natural; 

begin 

Change(1).Value := 200; 

Change(2).Value := 100; 

Change(3).Value := 50; 

Change(4).Value := 20; 

Change_To_Dispense := Money_Received - Price; 

Change(1).Number := Change_To_Dispense/Change(1).Value; 
Change_To_Dispense ;= Change_To_Di.spense mod ChangetD.Value; 
Change(2).Number Change_To_Dispense/Change(2).Value ; 
Change_To .Dispense := Change_To_Dispense mod Change(2).Value; 
Change(3).Number ;= Change_To_Dispense/Change(3).Value; 
Change_To_DiEpense ;= Change_To_DispGnse mod Change(3).Value; 
Change(4).Number ;= Change._To_Dispense/Change(4).Value; 
and Calculate_Change; 
and Change_Calculation; 

2. A rational number is a number that can be expressed as the ratio of two integers. Use 
information hiding to design and implement a program that reads two rational r mbers, adds 
them, and prints the rcsulti 

a. Decompose the problem into a set of modules. For each module, state its interface and 
its hidden information. Describe the interface as an Ada package specification; 
describe the hidden information in English. 

It’s important that the students try to design the modules before plunging into the 
implementation. They should try to come up with the answer to this question before 







McBJproKranimin.i; in Ada Course: Informalion Hiding, Ti:acher Notes 


tackling Part b. However, it’s also okay if they don ’/ get the correct answer on the first try. 
Engineering design is an iterative activity. 

There are two modules, Rational_Number and Main. Rational_Number has the following 
interface: 

package Rational_Nuinber ia 
type Rational ia private; 

function Rational_Number(Numerator: in Integer; 

Denominator: in Integer) 

return Rational; 

function Add(rl, r2: Rational) return Rational; 
function Numerator(r: Rational) return Integer; 
function Denominator(r: Rational) return Integer; 
private 

type Rational is record 
Numerator; Integer; 

Denominator; Integer; 
end record; 
end Rational_Number, 

The hidden information of this module is the representatio:x of rational numbers and the 
algorithms used by the functions that manipulate them. 

The main module has the following interface: 

procedure Read_Sum_And_Print_Rational_NuinberE; 

The hidden information of this module is the algorithm it uses. 

b. Implement each module. Represent a rational number as a pair ( f integers. 

The following implementation takes the trouble to normalize rational numbers after each 
operation—that is, it divides the numerator and denominator by their greatest common 
divisor. If your students have not yet encountered this algorithm, you may want to provide 
it for them. 


» 




I 


I 








14 





McRaproRramming in Ada Course: Information Hiding;, Teacher Notes 




package body Rational_Number is 

-- This ppckage implements rational numbers as pairs of integers. 

— The f intage to this scheme is that rational numbers are 
-- represented exactly. The disadvantage is that numbers must 

— be normalized after creation and each arithmetic operation, 

-- requiring some extra time. 

procedure Normalize(r: in out Rational) .is 
Numerator, Denominator: Natural; 

Remainder: Natural; 

begin 

Numerator := abs(r.Numerator); — Find the greatest common 

Denominator := abs(r.Denominator); — divisor of the numerator 

while Denominator /= 0 loop -- and denominator using 

Remainder := Numerator rem Denominator; — Euclid's 
Numerator := Denominator; — algorithm. The algorithm 

Denominator := Remainder; — ends with numerator 

end loop; -- holding the GCD. 

r.Numerator ;= r.Numerator / Numerator; 
r.Denominator := r.Denominator / Numerator; 
end Normalize; 

function Rational_Number(Numerator: in Integer; 

Denominator: in Integer) 

return Rational is 
r: Rational; 
begin 

r.Numerator := Numerator; 
r.Denominator := Denominator; 

Normalize(r); 
return r; 

end Rational_nurober; 

function Add(rl, r2; Rational) return Rational is 
r: Rational; 

begin 

r.Numerator ;= rl.Nurnerator*r2.Denominator 
+ r2 , Numerator*!’! . Denominator; 
r.Denominator := rl.Denominator * r2.Denominator; 

Normalize(r); 

return r; 

end Add; 

function Numerator(r: Rational) return Integer is 

begin 

return r.Numerator; 
end Numerator; 

function Denominator(r; Rational) return Integer is 

begin 

return r.Denominator; 
end Denominator; 
end Rational_Number; 






m 














• • 


15 






Mcgaprogramming in Ada Course: Information Hiding, Teacher Notes 


This implementation of the main module goes through the rigamarole necessary to instantiate the 
generic packages needed for integer input and output. That’s not important for the purposes of this 
assignment. Rather, have the students concentrate on the algorithm. 

with Rat-ional_Number, Text_IO; 

procedure Read_Sum_And_Print_Rational_Nuinbers is 

paclcage Integer_IO ie new Text_lO.Integer_IO(Integer); 
rl, r2. Sum: Rational,_Number.Rational; 

Numerator, Denominator: Integer; 

begin 

Text_IO.put('Enter the first number: '); 

Integer_IO.get(Numerator); Integer_IO.get(Denominator); 

rl := Rational_Number.Rational_Number(Numerator, Denominator); 

Text_IO.put('Enter the second number: '); 

Integer_IO.get(N'mierator); Integer_IO.get(Denominator); 

r2 := Rational_number.Rational_number(Numerator, Denominator); 

Sum := RatiQnal_Number.Add(ri, r2); 

Text_IO-put('The sum is "); 

Integer_IO.put(Rational_Number.Numerator(Sum)); 

Text_IO.put('/'); 

Integer_IO.put(Rational_Number.Denominator(Sum)); 
end R3ad_Sum_And_Print_Rational_Numbers; 

c. Change the implementation of rational numbers to a single floating-point value. What 
arc each implementation’s relative advantages and disadvantages? In what programs 
would you u.se one or the other? 

The package specification is identical, except that the representation of Rational changes. 
Replace the lines: 

typo Rational is record 

Numerator: Integer; 

Denominator: Integer; 

end record; 


with: 

type Rational is new float; 

Here is the package body: 

package body Rational_Number is 

-- This package implements Rational numbers as floating-point 
-- quantities. The advantage to this scheme is that it is 
-- very fa.st for performing arithmetic operations. The 
-- disadvantage is that the numerator and denominator must be 
-- approximated rather than computed exactly. 

Number_Of_Denorainators: const2mt := 10; 

Denominators: constant arrayd,.Number_Of_Denominators) of Integer 
:= (1, 2, 3, 5, 7, 11, 13, 17, 19, 23); 





Megaprogfamming in Ada Course: lnform;>iiQn Hiding. Teacher Notes 


function Rational_Nuinber { Numerator: in Integer; 

Denominator: in Integer) 

return Rational is 
begin 

return Rational(Numerator)/Rational(Denominator); 
end Rational_Nuinber ; 

function Add(rl, r2: Rational) return Rational is 

begin 

return rl+r2; 
end Add; 

— Compute the numerator and denominator of r. The algorithm 

— is to choose for denominator the value in the denominators 

— array such that numerator = floor(r*denominator) and 

-- numerator/denominator is closer to r than for any other 

— value of denominator in the array. 

procedure Compute_Numerator_And_Denominator_Of_Rational( 
r! in Rational; 

Numerator, Denominator: Integer) is 

d, n: Integer; 

dprime, nprime: Integer; 

begin 

d := Denominators(Denominators'first); 
n :- Integer(r*Rational(d)); 

for i in Denominators'first+1 .. Denominators'lust loop 
dprime ;= Denominators(i); 
nprime := Integer(r‘Rational(dprime)); 
if abs(Rational(nprime)/Rational(dprime) - r) 

< abs(Rational(n)/Rational(d) - r) then 
d := dprime; 
n := nprime; 
end if; 
end loop; 

Numerator := n; 

Denominator := d; 

end Coraputo_Numerator_And_Denominator_Of_Rutional; 

function Numerator(r: Rational) return Integer is 
d, n: Integer; 

begin 

Coraputc_Numerator_And_Denominator_Of_Rational(r, n, d); 

return n; 

end Numerator; 

functioi Denominator(r: Rational) return Integer is 
d. _ Integer; 

begin 

Compute_NumGrator_And_Denominator_Of_Rational(r, n, d); 
return d; 
end Denominator; 


end Rational_Nuinber; 






Megaprogramming in Ada Course: Information Hiding. Teacher Notes 


The differences between the two implementations may be summarized as follows: 

- The first implementation is slower. It must execute the normalization operation after 
creation and every arithmetic operation. Moreover, adding two rational numbers using the 
first implementation requires three multiplications and one addition, whereas adding them 
using the second implementation requires only a single addition. 

— The second implementation is less exact. The first always represents a rational number as 
the ratio of two integer quantities, which is the definition of a rational number. The second, 
which uses a floating-point value, represents a fixed number of significant digits. 
Furthennore, its algorithm fir determining the numerator and denominator is accurate 
only to two significant digits. 

You would use the first implementation in programs where accuracy is of more concern than speed. 
You would use the second implementation when speed is of more concern than accuracy. You must 
also assess what operations you will use most frequently. The first implementation will be both faster 
and more accurate if you invoke the numerator and denominator functions more often than the 
addition and creation functions. 



























I 

I 

i 


1 


[ 


j 

i 



9 


i --d 


— TJ O 


z 

o 

0) 

CO 

D 

o 

CO 


CO (1) 
C-° 

o = 


0) 

CO 


CO 

t- 0 


o 

CO 

c 

a> 

V. 


o 

(O 

0 

V. 

0 


O 

^ 0 

= n 

g o 

0 5 

c o 

'w cn 
3 c 

•- iS 

0) § 
> o 
■? — 
O 

">8 

si 

0 2 
0 


o 

OT 


o 

w 

w 

0 

w 

OT 

3 

o 

CO 


CO 

Q K 


e ^ 

r- 

2 § 

CLx: 

5 


0 

w 

c 

0 

o 

3 

O 

>s 


0 D) C 


« 

3 

0 


0 

0 


■o 

<u 


E O’ 

w ■« 

_ 3 0 

^ CO ^ 

C 0 D) 

« ‘cn:£ 
0 5 !E 
a to x: 


a ui 


d 

tft ^ 


o 


3 

cr£ 

2 0 

■e -o 

o ^ 

=*= c 
0 t 


0 


5 

o 


o « 
3 O 


c 

3 

o 

c 

0 


?§| 

O 0 •- 
« 0 0 
C i: ^ 

Mn 

s;- 

= c w 
>00 
5 3 
0 O 
CO 0 
^ "D 
0 

*- O 
JO 

£ 0 


c 

3 

CO 

!c 

H 


■ti .y »- 

0 4= 0 

0 .i2 > 


0 E 


5 = 


2 o) 


0 


0 ~ 
0 




0 

k. 

<0 


0)13 0 -o 


c 

0 0 O 

O c X) 

0 0.0 

■ 0. 


g’xj 


£ 

— O 


0 


2 i2 0 


■E c 3 := 


_ 0 
D) 0 

C coO 2 

•O CD) O 

*- O) r- 
*-0—0 


^ . t: 


O) 0 0 
c <n j~ 
Uj E ■ „ 

■ °-E 
c 


0 0 
V- ^ 

0 3 

0 5 
O’ 0) 
0 x: 


0 

3 

U 


O 0 
O-'O >. 
E = CQ 
- CO ^ 


0 


0 

0 

0 


cTci) 

0 O') 


- 

. 0 
4—» fj) 
O 3 
0 0 
O ‘- 

^2 


0 

^ ” 0 

> 3 > 
0 ^ 

^ 

% §>0 

5 2 3 

(T 2 2 


E "o 

^ 0 
0 0 — 

ai<^ 
o 

-5 

O ^ 
„ Q.-0 .E 

0 = < -o 

5 0 

o — c 0 

SZ . - 0 

.S2^ ^ °- 
- o 

0 iE 

0 iE 

3 "O 
0 


Z 

15 

LU 

gc 

H 

Z 

UJ 


- 2 

0 
X) 
0 


.O ■= -D 

eE 

o 0 


cc .0 0 E 


UJ 

X 

h- 

K 

O 

U. 

CO 

UJ 

> 

H 

O 

UJ 

“3 

ffl 

o 


0 

.Q 

]g 

3 

O 

4= 

0 


C 

0 

■O 

3 

0 

0 

sz 

J- 


0 

0 

3 

0 

0 

_c 

0 

Q 


0 

0 

3 

0 

_C 

0 

Q. 

CD) 

C 

x: 

c 

o 

0 

E 

i_ 

o 

c 

0 

2 


X. 

UJ 


0 

0 

3 

0 

0 

■c 

o 

Q. 

CD. 

3 

0 

e 

0 

‘c 

0 

.0 

O 

0 

£ 

_o 

*£I 

0 

C 

0 

o> 

0 

TD 

< 

0 

4= 

5 

O 

x: 


0 ■o 
-o E 

c w 
0 0 
CL "O 


c 


























DISCUSSION 

This slide depicts a common software development situation. You have implemented the Reverser 
program from Unit 3. which reverses the lines in a file. Now suppose you’re developing another 
program, and it needs to store a list of integers. The Line Holder module has a similar, but not quite 
identical purpose; it stores lines, not integers. Can you save yourself work by using it in this program? 


O "O 
c 0 ) 

3 C 
-Q 3 

sS. 

<u "co 

CO ^ 
2 $ 


■O t 

o $ 

« ° 
<D 

5 3 

^ O 

3^ 

o o> 
> .£ 


Q.-^ 
_ CD 
CC C 

W ■« 

S I 

IS 

2 0) 
t- 

« i. 

3 = 

= 5 


CO 2 
•E 2 Q. 
=> O) ® 

o.E 0 ) 

"v. 

E o 5 
« -2 Jr 
_ 

O «J £ 
a. CD oj 
i_ £ XI 

2 a> 2 

2 > Q. 
CD P 
> >“ CD 

O 3 £ 

g,; 

£ 2 o 

CD CO 
TJ _ 

2 5-2 
E.--1 

CD C ^ 

Q.Z) 

E c E 
— So 
o E J= 

c E 
■O fc cc5 

_ cC w. 

>. o 2 

CD ^ °- 

q.£ 

Q. *- 

=! C 9- 
co ^.g 

2| ^ 
2 O. o 
^ E 


= 05 2 3 £ 


CD 'E CO 


s O 

w E 

x: 

o§ 

D- 


= o .£ 


C 03 


■O S 0)2 

g 3 § 2 

E O o 5 

O) ^ 

.£ 0) « = 
« § s § 

£ ” S ig 

CD CO O O 

x: o to 35 

™ 3 (D O 

=' = §2 
CO CD ^ 5 
-o rC o: i_ 

2 CO o 
CO 5 o 


^ CD 

0 ^co 

CD — .to 
Q. S CO 

CO-^ o E 
CO to — 2 

l_ Q 

CD C X CM 
P O O 
CO o c 

t= E 9 D 
o o 9 

O CO 2 .£ 


^ CD .-- 

c c CO £ c 
CO CD ^ 3 


O S O 
•“ 3 Q. CD 
to JD CD 2 

OQ .2 § I 

12 o 2 

_ >» O) 

o.to c E 

■t; tD Q. 
TJ O jc 
9 tD > C 

x: o -Q CD 

CO to 

CD CD ^ 

1 := 
.o-g 

£ C 05 

C S'£ C 

E .o- c 5 

o 9 2 8 
o'e t:^3 

•“ VO >s vj 
CD X 3 >> 

■5-- O C 

2 = 
2 CO 3 9 

> CO -g 2 

> CD 2 E 


CO 

CD • 

§>§ 
o) E 

C 3 ) O 

o: 9- 

E 3 

IS 

&< 


(/) CO 

Z "o 

O CD 
_ O 

^ to 

O t 

< CD 

s S 

7 O C/} 

= ><11] 

I- ^ > 

Z t- 

lU X O 


CO CD 

c Q 


Understand that reuse involves planning ahead 





























DISCUSSION 

This slide presents the prevailing theme of this unit: you should capitalize on others’ work when developing software. 
This is known as practicing software reuse. 

Moreover, you should develop the attitude that you have little excuse for not doing so. Whatever program you write 
bears some resemblance to a program someone has written already. At least some portion of it will be similar to 


<D a? ” 

^ 03 0) 

O .C 

■3 03 O 

il.c 

I « 3 

TO D3 ^ 

X3 2 c 

g. 

£0 I 

o 

0) w 

0)0.^ . 
E £ 

03 E § 

JC ® 5 

03 o 3 
.9- c o o 

<D <U -C 

S £ 

3 ^ -O 

cr E S ™ 

. ^ 
s'” 03 
5 "Cl 

^ o to 5 
M 03 3 o 
c 

03 T3 -a 

£ ® <0 w 
O 03 '03 

-oS^& 

c 2 c 

T) £ O 

i 2 ” 2 
I SS2 

sz c W 


3 0 0-0 in 
03 03 03 3 03 

E Q) 03 

>> D) 

- s.» C 2 E 

03 5 — 5 03 

^530 
rt £ o 9 o 
1 g o 

2. i’ll I 

P ■d3_£'o-° £ 

<5 fii >' 03 03 ~ 

5 03 03 C w OT 

£ -c m ^ 03 

O Cl , - ^ O Q_ 

« .9 o m ^ 
03 0 : > _: 7 ; — 
c 05 O 2 ° 03 

'.;3 O 0) .9 ^ 03 

W ^ P -C 3 

■x 2 O £ o 03 

03 0. S 03 i CC 


3 >x O 
O <0 

- -o 

03 03 O 

2 E “ 

o p 03 


c t— 05 


E c ® 
E £ -D 
o o ♦- 

»- O 3 


|g c 

£ ^ 03 

2 03 
C -= CO 
o 05 
05 =j 03 
~ 03 03 
i: 3 3 

03 03 2 

§ « « 
g 03 « 
03 03 
03 03 

JZ ” 3 

■o ~ £ 

03 £ o 

f £ n 

ja i_' >> 
03 03 

05 > x: 
x: ffl *-• 

« I o 

03- 

~ . O 

3 03 C 
O -o CO 

- gw 
O c 
5 O I- 

03 § -2 


■« W « 

'•—3 0 
03 Tj^ 
X3 jz g 

eg® 

— -J frt 


« 03 03 

03 03 P 
*= 3 05 . 
•C 03 X 


£ C £ C 
>7r 05 O O 
C/J O .Q O 


£ -5 

■F -O 
.9 o 
03 £ CO 

■s; ^ 

05 C ^ 

€ c 


C/5 

:3 

o 

0 

c £ 

05 03 

> 03 

■o O 

CO Q. 


05 03 03 


j=: > > 

O E £ 

_g JO 

03 Q- Q. 

03 X X 

£ LU LU 



Megaprogramming in Ada Course; Reuse, 4-3 







Two Software Maxims 













DISCUSSION 

This slide presents some data that shows how much effort reuse can save you. 


"05 Qi • 

E -a .c 2 

cc = 

O .52 -D O 

F, to 


CO C S'D 
^ O W r- 


^ 0 

W C ^ 

/1*k 


-SI 0 0? = 
■D gtO 

8 ra.E r', — 

0 h- O .2 
0 .0^0 
c 0 j= JC 

O 0 CO 0 

f 

■= 0 = ' ' O 

to _ 0 ^ 

Tr^ro-O^- 
O .E -g c 0 

CO 0 ° £ 

■-XOJOt- 
0 0) £ C o 

Y £ to ‘2 "D 
o •g QJ 0 

(L ‘j= :> 0 ^ 


E i 

0 o 5 ^ 

^ 0 S= £ & 

cn^ -fS S 52 
•= O 0 ir 

■c: x: 0 0 

^ 0 £ Q. 
o£ c 0 o 


Q. 0^ 
0 ^ 
J0 Q. 

■>- ^ 
o ^ 
0 o 

Q. >> 
X - 
0 £ 

2 S 

13 +5 

<= 

■« 0 
o ^ 

^9- 

SZ 0 

O) 

0 E 

0 o 

■E E 
~ 0 
o 

o ^ 
tr^ o 
o' 5 

O tn 


0 iS CD ■« 0 0 

.0 0 0 TO § o 
-g “ ^ 0 I O ° 
^ 0 ^ .i 8 O = 

4; 0 2 o ^ 5 p 
O£C0 5 


0g3 2 I 

^'Z ^ 
0 >% “^ >^ 0 
> c 0 42 -c 
0 0-0^-^ 
"o - >< 

0 .-2 ^ ° -Q 

i- cr 0 i_ i_ 


O d 0 = 
0 -c: ■« 
0 0-^0 

^ 0 
£ C 0 -0 
o 0 ,x- 

§ g.^.^ 

06 6 2 
o T- x: Q. 
>' -« 0 — 

, - x: 0 

^ E 0-E 

E 0 D)c 

^ 0 0 o 

2 -o jC o 

“■g ■§ 

■■i - 0 I 

0 o -D -o 

0-^fe ^ 

E i O^ 

° o t3 
0 0 £ 2 

:i^ ^ 0 

o o 0 42 

o o 

9, w 0 0 
o T" y § 

2 ><‘o p 
c a> CT 
0 0^0, 


£ 0 "O O .y 

"TT /IX /— /1\ //X 


S ="e Q 
« S S o> 


C 0 >» 0 
0 

f:; ^ 0 y 
0-1^0 
o O > 'o' 


“'000 

.E 2 0 

0 “ x: 0 

O JC o 0 

0) 

C vP 

“»°E 


0^000 
eg >,'c0 0 p 

o E O 3 3 
c/3 £ = c c 


■4^ w 

8o 

x''^ 0 

0c\j ^ 

0 ti TJ 

-O 

£ 0 CM 


0 I'' O 

3 0 0 0 

P .E 0 0 

J 3 

^-o 0 0 

0 o ^ 

> o E 0 

if^i 

JZ 0 o 0 

•£Z >'5= 


0 .0^ 

^ 0 

0 0 

^ "D 

— •4-» 

^ c 
c- 0 
0 Q. 

t3 

0 0 

■o'-0 

E'P 

0 cn 
0 0 
4-rf .C 


0 0 

"O 0 

w- 0 

g.0 

0 E 

■o E 
o o- 
o 5 
0 
o > 
0 
^■o 


F .9 


^ »- 
c 2 
2 uj 
£ □ 
E D 

D) I- 

0 C/) 


3 '0 

O 0 

>% 0 

o ^ 

Q c 


c UJ 
0 


^ liJ —» 

i O 03 


Megaprogramming in Aaa Course: Reuse, 4-4 





Some Software Reuse Data 


O 

O 

O 

O 


O 

o 

O 

a 


O (0 

(/) o 
S G> 
■= <2 

t g 

o O 
Q. (!) 

o E 

> - 

o § 

o 

£ > 

CQ CO 

5 ^ 

o 

(n 

(D 0> 
"D 

S? o 

2 o 

O H- 

CD 0) 
H = 


o 

CL 


0) 

0) 

3 

0) 

cc 


0) 

(0 

3 

0) 

oc 

o 

lO 


0 

0 

3 

0 

QC 

o 



(sAeq) 1J043 









• • 










z 

o 

cf) 

0 ) 

D 

o 

CO 

Q 


03 


•S « 03 0 ) 

? "Cl -c: 
£ 0 ® ■*- 


(0 


<u 

.•= o 


0 

c 


0 


> 0 JD 

> ^3 ^ 


0 


JQ 

0 


C 

0 


n 

0 

Q. 

0 

O 

X3 

0 

L_ 

'(/} 

0 

0 

0 

L- 

0 

c 

0 

O) 

0 

O) 

c 

i 

o 

JC 

0 

>* 

n 

k- 

0 

■c 

Q. 

0 
• 4 —» 

w 

0 

c 

o 

CM 

't 

0 

;g 

CO 

0 

0 


:= 0 C 

0 ^ 2 - 
Q. > O) 0 
05 - O > ns O 

O 0 0 ^ 

Q. ^ _C5 ^ 

^ X ^ o 0 

0 d S' "rj 
0 K .8 c 


0 
0 

“pi I 

£ < j*: 

O 0 c § 

0 ) S .£ S ® 

0 p 0 5 

r O 5 0 
° 52 o 

0 yj 0 ^ 

§ 0 -o O’ o 

s 0 s r: 

o 0 C C 

X c — 

E 2 
0 2 


0 

E 

0 

0 


■a 

0 

0 

c 


■D 

c 


F= 0 

-n ^ — 
^ O O 

0 9 £ 

c 


0 

0 

0 

c 

0 

O 

0 

5 

cn 

c 

X 

4 —* 

0 kJ 

E 05 

§ s- 

0 0 

- 0 
> 


0 


0 


■O 

0 0 
0 


■— TD 

' 0 
k_ 

0 


C »- "O 0 
S 0 0 5 -O 


2 0 
0 o: 

> 

0 
X 


1 ^ 
i— 

O) 


O) 


a °-_0 
P o 


O ^ 

0 ° 

O 0 

c E 

o 0 

0 o> 3 
c 20 
'-C kJ 

Q. c 2 

0 o o 

■D X 

0 . k. 

0 0^00 

> 0 

>, 0 4^ O 
0 V > 

E 8 0 

0 0 C 

^ ^ 2 - w 

'• 5 : O) _ > 


0 

2 

o 

X 


£ >< 


o 
« 

C 0 

0 £ 
■*-* 

C >s 

0 X 

5 T3 
0 


< o 0 


. 0 
u) "o 

E 


0 0 

^ Q. 

|§ 

C Q. 

~ 2 
2 I 

0 0 
2 0 

5 g 

1 @ 

C X 
0 

>s'^ 

C k- 
0 0 

« >- 
■Q . 

0 ^ 
0 0 

c _ 
c 

^ Vm 
= 0 

2 ^ 
Q. C 3 ) 

E 2 

2 2 
^0 
2 P 

Q, k_ 
0 £ 
EP 0 
-1 
<•« 
0 

E Q- 

0 ^ 
0 0 


c 

0 

5 


C 35.2 
O +!- 

k— “ 

CL 3 


0 
fc 


0 


X 


0 
o 

0 

1 
0 
X 

f- 


o ^ 

X 3 
0 O _ 

5 E£ 


o 0 0 

k- 4-* 

0-2 2 
0 o Q- 


0 


E 

o 

o 


0 


0 

3 


«= ^ 

0 ■= 

0 X 
Cl 


2 0 ^ 
X X 


0 - 
28. 
0 

2 2 
o 0 

X X 


^ 0 
2 0 0 

o > X 
0 0 0 
Q.^ X 

O ■“ 
o> 
0.E 
0 02 
X 0 ■=! 
I— 0 X 


0 

0 

0 


0 

0 

3 

X 

o 

E 


0 

0 

X 

0 

X 

o 

>k 

c 

0 

E 

0 

k. 

0 

X 

0 

0 

E 

0 

k— 

C 3 

2 

X 

0" 

X 

£ 

0 

X 

0 

0 


0 

0 

0 

k. 

0 

X 

o 

X 

0 

0 

0 

3 


0 

X 


(0 

z 

g 

h“ 

o 

< 

X 

UJ 


0 ® 


0 

> 

0 

0 


O) 

p 


E 

E 
0 
a. 
o 

> 

^00 

2 0 0 
X 0 c 

O 0 

00” 

XX P 


c 

o 

0 


c 

o 


h- 
Z 

CJ) lU 

° § 

i H 

< CO 


3 — 
O Di 

■S 2 

Cu ^ 
CO a 

30 

0.0 

0 

E“„ 
0 0 
c 


0 

0 

0 *= -D 
0 O 0 

P ^ X 

III 

.0 P 
^ 0 _ 
X 0 

0^0 
Cu 

0 = ,- 

&” o 
(c 2 s= 
"^5 0 

Q O ^ 

fs-i 

X 0 

0ls^ 

I 

X 0 ^ 

§ll 
s“-i 


£ g’.S 

>k 3 
C 

0 c 

cE 

- E 

0 o 


X 
0 
0 
3 


0 
0 P 
fc 0 
- o 0 
0X0 
00 
0 X 0 
.0 ^ ^ 

O 0 

2 

3 0-- 
o P k_ 
>00 
>00 

. - 0 
0 lt 
g 0 

0 Ui 


0 


jst: 

c 

j>. 0 

kU 

3 

X 

0 X 

k- 

X 


0 X 

0 

3 

p 3 

E 

0 

0 0 


>>x 5 

0 

0 

■*-• i=L 

X 

X 

c 

0 

•4-* 

0 0 

, ■ 

0 

0 0 

0 

X 

Jtl ^ 

X 


!tr U- 

“D <X> 

5 


^ . 
£ o 

o ^ 

c 0 

O 0 
0 — 


3 
■*—* 
o 

3 

k_ 

0 

0 

0 

X 

>. 

c 


0 


c 

0 


O) 

c 

'k_ 

-*-* 

0 

0 

o 

0 

0 

C3 

0 

k. 

0 

X 

o 

0 

X 


CO 

UJ 

> 

K“ 

O 

UJ 

X 

m 

o 


0 

E 

0 

O) 

p 


o 

0 

X 

0 

0 

X 

X 

3 

o 

X 

0 

0 

+-* 

c 

0 

X 

3 

•I—* 

CO 


0 

3 

O 

X 

0 

X 

0 


cn 

c 

X 

k_ 

0 

3 

O 

x 

0 

X 

0 

O 

X 

0 

* 4 —* 

X 

0 

X 

0 

0 ' 

O) 

c 

X 


0 •— 

k- 

0 
> 

0 
0 
C- 0 

■— p 

— O 
X 


0 

0 

3 

0 

X 

■4—* 

X 

O) 

E 

0 

3 

X 

o 

E 

0 

>> 

X 

s» 

c 

0 

X 

X 

LU 


0 

0 

C 

0 

Cf) 

0 


c 

o 


0 

X 

X 

c 

2 c 

0 is 
k- 0 

0 ™ 

? S’ 

Z) X 


i) 


Megaprogramming in Ada Course; Reuse, 4-S 











































/- 


W 03 
CO O) 


£ 

to 


c 

CO 

SI 

o 

a> 

E 


Q» 

C 

Qi 

D) 

CO 


sz 

cn 

o 


CO 

OJ 

3 

"O 

o 

E 

CD 

25 

CO 

CO 

3 

CD 


to 

"O 

< 

5 

o 

x: 


Z 

g 

Ui 

U) 

3 

o 

g 

Q 


to 

o 


to 

CD 

■o 


to 

to 

h- 


— (DO 

■op m 

C O £ 

O 3 - 

03 I •— 
W ^-1 
.= 03 
: —’ ^ 


CD 


CD H- 
XI O 


CD r- P 

P E ® 

^ O 5t- 

to 
0 


E c 

2 5 S £ 

> o n 
CJ) > _ 

ro ^ E 

^ w o o 

O ^2 CD 

Q. w »- 
CO ® p 0 
CO ~ o Cl- 
p -j X «- 

03 A I® 

•^11 o :s 

o i-'i 

~ 0 03 


0 


CD 

■cO ■^> 


o eg OJ 
0 ) 0 ^ 
ro'o 

5 CD - 
0^:0 
ro Zj c 

“-CD-* 


.2 :5 o 


</) 

■c 

o 

Q. 

Cl 

3 

w 


CD CO P 
C 0 ^ 

0 O O 
0)0 « 

“■&I 

oeI 
2.1 ^ 
v_ “ 0 

0 T3 £ 
TO 0 _ 

o E -^ 

1 0 to 

0 "^ ^ 

2 k. 0 

0 

_i ** 

0 


b 

0 


0 0 

O) Q. 


^ 0 


000 
jc ‘C ^ 

^ g 0 
>00 
> 0 )Z 


0 

2 

o 

X 


0 

JO 


Q. 

0 


0 ^ 
4= 0 0 t 
C £ 0 

iS H- O .E 


c E o CO 

c2 0 2 

< P CL 

■ 0 9 - 

w J 0 0 


0 

XI 


(O 


c 0 ct: 

o .9 0 E 0 

I— I _ .m "S 


t; 

0 

Q. 


l-i 0 P 
♦= 0 K 

C O) 


0 


0 

4 jk ^ s 


0 


♦- Jc 3" 

W O C 

•- S--" g- 

^ 2 o 

XI 0 C 

-00 
O T3 *5 

•4^ 


0 

JC 


0 P 


0 


o 

o 

0 


0 


_ 0 
0 -^ 

:= 0 
_ C 
0 O 


0 


0 

JO 


E £ 
0 0 


0 

XI 


w 


O 

XI 


c 

o 

N ;= 

0 

XI 

0*^ 
£ 0 

CD 

5 0 

P o 
0 0 
n Q. 


0 ~ 

Q. O) 

o .E 

.— 

3 


0 

0 

0 


0 
c , 
0 0 

0 0 


01 T- 

>.C0 


0 


C .b; 


j<: 

O 

o 


o 


*-< >» 
4- X3 

° >. 
0 = 


0 CO 


030 


5 

o 


?= O 


0 


2 


0 


§§ 
0 
O) 
0 

0 

JO O 
3 0 
0 Q. 


COP 


0 0 
.2, CD 

•-' 03 
£■£ 
0 — 

O) 03 
0 C 


.£^ 


o 0 


S 3 


,rt CA 
0 ^ 

0 O 

0 5 


E 0 

O XI 


0 5 
o o 


0 


91 C 


.9 0 
Jr, o 


3 

p 


D) >< 


0.9 


0 


0 


C3) 


5< 
o c 
a. 0 

CID 
0 03 
XI 

C 


5 A 
o " 


0 

V-. 

0 


x: p 0 

« 0 g. 


C Q. 


.2 D) 0 

co.r 


*= E 


c 

0 


^ S 5 


0 X3 


^ 0 


0 


0 


■C> 

c 

o 

o 

0 

0 


0 0 
0 > 
>,0 


0 0 E 


x: 

h- 


0 0 
0 iS 


B 0 


-r- 0 

^ C 
0 — 

C 

0 C 
^ O 


c 

0 


0 

o 


0 0 
X) _ 


0 ♦- 
0 -•-> 
XI C 
0 
0 *5 

0 c 
c 

0 
I V. 

I 0 
c 
O) 




0 

T= 0 

S -a 


0 


0 

c 


0 

3 


0 P 
o o 


0 

JO 


TO 

c 

0 


0 

jC 


0 

0 


■*-* O 
.2 0 


0 

0 

0 ■ 


0 g 


TO 

0 p 
CD t 0 

C 0 CD 


0 

JO 


TO 


ti CD 0 
•^0 0 
O 0 


CO 

z 

o 


Cl 

0 

0 

xo 


0 
CO 

0 0 


CO 

c. 


0 


O 

< 

QC 

m 

I- 


co i= 

0^4- 

03 CO O 

C — 0 




O ^r rn 

0 

E 


0 


0 

4—» 

0 


0 

X 3 

0 


0 

E 


0 

xo 


Z 

UJ 

Q 

3 

(/} 


0 0 
~ 0 
3 


0 

c 


cn 

UJ 

> 


3 

o 

JO 

0 


0 

JO 


P 7S 


0 


03 ^ 0 
XI 0 x: 
I- 2 I- 


O 

UJ 

“3 

m 

o 


0 


c 

0 

TO 

3 


(f) 


0 

O) 

0 

j<: 

o 

0 

Q. 


0 

p 

O 

X 


0 

XI 


E 

p 


TO 

0 

25 


c 

0 


0 

C 


0 
CD 
0 
JX 
O 

0 0 

Q- CD 


o 

c 

0 


0 

CL 


0 


B S 

0 o 


.E X 


0 

o 


2 -* 
0 0 


0 


c 

0 

CL 

X 

LU 


TO 

c 

0 

4-4 

CO 


0 

TO 

c 

D 


c 

o 


0 


c 

0 


0 

c 


0 

JO 


■a 

0 

4-* 

0 


0 

0 

c 

3 


0 

0 

CL 

0 

Q. 

E 

0 


0 

JC 


p 

0 

k. 

0 

0 

o 

0 

23 

0 

I— 

o 

p 


0 

CD 

0 

j*: 

o 

0 

CL 


0 

0 

O 

X 


0 

XI 


0 

CD 

0 


0 

4-4 

0 


C 

0 


0 

C 


5 

o 

XI 


c 

0 

Q. 

X 

LU 




Megaprogramming in Ada Course: Reuse, 4-6 







Ada Generic Package 


o 
c 
0 
D) 

« L.I 

” E 
£ 21 

5 a 


0 

*-> 

cd 

> 


0 ) 

0 

O 

c 

2 

0 

k. 

0 

> 

O 

E 

0 


0 

••—I 

> 


E 

0 


o 

'l_ 

0 

C 

0 

D) 


Q- (/) 
w 

n'» 

;o 

= I -■ 

Q. ® a 

j*: 

o 
0 
Q. 


W 


=1 

O 

C/j 

E 

0 

oT 

N 

0 


Q. 

W 

W C 
_l ”■ 
0 


ZJ 

■O 

0 

o 

o 

Ol 


E 

0 


0 

0 

=J 

X* 

o ^ 
o 2 


0 

0 



U3 

0 



4-* 


O 

0 


c 

a 


T3 



k. 

O 

o 

*»- 

o 


0 

w 

ui 

0 

Ik. 

0 

0 

c 

£ 

0 

'.IZ 

1- 

> 


•I 91 

• • O) 

05 »- 
0 I- 

^ 05 
^ 0 

I ^-E 

o fc o 

o CO o 

w ,0 E 

§ 0 w 

g 0 1 

X 0 0 
0 Q. Q. 

0 

> 


0 

0 

_o 

0 

> 


0 

05 

C 

0 


0 


0* 

0 c 

^ 0 

a> 0 .. 
■9 Q> "o 

§ ^ o 

3 0 0 
Z > 0 

n 
c 
0 


0 

p 

o 

I 

■O 

c 

0 



0 


A 

E 

0 


0 
;o 
o 
cX 

0 
a 

■r^ 0 

c 0 
O T3 

CO o 
.£2 “l 

0 i 

c -E 


in 

in 

CM 


0 


0 

bS 

jD o 
O 0 
0 Q. 




package lnteger_Holcler is new HoIder(ltem => Integer); 



U) 0) 
U) Xi 


coo 

.2 r 5 

■a fl) 

« ^ 

s ai 

O 0) OT 

Q. »- _ 

W O .— 

g, o E $ 

^ ^ o° 

o c V 

CO 0) 0 ^ 
Q. O) C 

.y < ® C 

I 

O) ^ 0 '<4- 

o i w 
0 0)= ® 
o ro o P 

3 ■g'^.w 

■a 0 o , 

S 

« c -S 

.2 "o 0 c 

^ § 12 - 
0 o 5 
0 *: 5 o 

b; 0 2^ C 
0 O ffl CO 
O SC C 

■a ■§ I D) 

I «io 

o o 5 S 
0 ■»: ^ 9- 
> 0 0^ 
0 c c 

^ 2J. ^ g 

0 o? 0 § 

*- ri ^ 

§ ®t:-a 

S “a 0 0 
‘a ° Jcz 5 
o 0 o 

0 g 0 
5 c'lSco 
^ o;y4 

= Iss 

CO CL 

^ 0CO 
^00. 
0 o gj w 

0 ) g j2 0 

1-^ T" ^ •» 


.2 >, 
.t: -o 
■o o 

■s-° 

Co 

0 

0 O) 

:Ei2 

.2 CO 
Q. 


0 0 
O) cn 
0 0 

y C5 
0 0 
Q. Q. 


Q t- 


0 0 c 

c Q.E 52 

2, ^ <c 0 

O) 0 t ^ 

Cu ^ 

< .2 a o 


■O 0 

a. 

g 0 

V-* :C 
<0 I- 

s 

0 

9-0 0 
« E CO 
o 0 
0 CO .2 
c ^ 0 

0 O C 
D)“ 0 

n^ CD 

0 c C 
.-C 0 O 
h- CD C 


•^0-0 

^5,9 *= 

c n w ■*- 

D) , 0 jD 

0 2s S’ - 
O) ^ 

<b o6 

5 O CO ^1 

'c Q. 

0 °-.2 0 
«) .2 0 .2 


« 0 '■" w 
3 O) 0 C 

? t: = 

O r- O 2 

> E c cJ 

2 t; c 

E '*" S 0 
E -0 0 
2 - 
C3iCL Q) CO 
o ^1 CD 0 
^ ^ 0 CD 
CL 0 JiC M 

- frt o 
0 .2 0 o 

c c 0- 0 

a Q. 

2s0 0 

g’c 15 0 

^ '-i^ -<-• 

O -CO 
0 0 0 
“• 0 w X 

o -0 .E 

‘C 0 

0^00 

c 0 x: o 

0 CD*^ ’O 
O) 0 0 

ji«: o o 

^ 2 ns 0 

o Q- 2 0- 

0 

0 :> t 0 
O > 0 
0 0^„ 

1 0 0| 

0208 

£00 
»1 8 “-, 
$•§ 8 J 

o r3 >' 2 

C . 0 
C 0 0 0 (J 
0 CD D) CD-2 

0000 a 
^ ^ ^ 2 

2 o o o a 
O 0 0 0 0 
>-0,0. 0.0 


0 ■ 4 —» 

> O 

c o 

Q-jD 
0 « 
03 C 

■E o 
0 ■■*::' 
O 9- 


g W 

0 z 
03 O 
0 ^ 
0 o 
0 < 
■E CC 
£ 111 
iS H 
0 z 
c = 

0 !r 
o z 
>' Hi 
c O 

I 5 

$ w 


-2 m ^ 
i: 0 ^ 
O 

E 0 H 

0 03 O 
4 .. 0 UJ 
0 "0 

S DO 
> 0 ar 
>0.0 



0 



03 



0 






0 



0 



0 . 



.0 



0 

jj 


c 

c 


0 

p 


03 



0 



0 

c 

0 

0 


4-4 

C 


C 



0 

- 


4W 

0 

C 

TO 

c 

0 


TO 

'i_ 


d 

0 

0 

4—* 


0 

0 

E 

b 

•*-> 

0 

0 

0 

0 

0 

0 

TO 

0 

0 . 

0 

0 

p 

0 

■ 4-4 

*k— 

0 

c 

.0 

5 

p 

0 

0 

Zj 

0 

.c 

c 

_03 

sz 

0 

'0 

0 

p 

0 . 

S4— 

0 
■♦— » 
c 

X 

HI 

0 

Q 

0 



TO 

0 

• 

• 


^1 






Concepts of Generics 






c\r 




CL CL 

00 




V. 




52 

0 

CL 



0 

0 

o' 

L. 



5 

5 




5 

0 

□l 


CtJ 

CL 

0 

a 

0 

o 

o' 


.O 

.O 

0 

o 

C: 

0 

c. 

0 

0 

CD 

0 


c 

c 

0 

o 

0 

0 

0 

. j*; 

c 

O) 

C3i 

: y 

: "O 

0 

0 

c 

O) 



CL 

0 







Megap.-ogramming In Ada Course: Reuse, 4-7 Copyright © 1995, Software Productivity Consortium. 









DISCUSSION 

This slide presents generic formal objects, another type of generic parameter. 

You may want to parameterize a generic package with things other than data types. For instance, the 
designer of the Holder package might want to let other packages estimate the maximum number of 


<n 

(0 

o 

o 

oa 

Q. 

V) 

<0 


T3 

C 

CO 


< 

DC 

CD 

II 

£0 O 

is 

E ^ 

O 0) 

0 ) o 

jC _ 
CO 

0) E 
u fc 
c o 
in 


.o 

.52 

To 

cu 


*- CO 

<n in 


52 

!c 

t- 


cu 


in 


3 o 


in 


3 o £ 03 

— CO S > 
v-‘ £ O 


CO 


CO > 


3 ® 

5 CO -o ~ 
Q. > CO 2 
*- 3 o 

o 0 .5 .c 
0 c ' 4 = 

S' O cq *5 

=5 0 

0 0 -Q 
c 0 w 0 
E — ~ Q- 

£to| 2 

-y-o § 0 

0 t .C 
C ^ 

to 0 0 « 

W 0 0 ) 0 
0 


Ci 




0 

c 

0 

D) 


in 52 
0 £ 
3 

0 .0 

> 3 
IT3 
O 

5 ^ 


E (0 

2 2^ 

CO O 


o .0 


in 

2 

0 

o 

0 

■D 

0 


0 


0 CO 

o)iS 
.52 c 
C £ z 

S o.^ 

^ 0) 0) 
^ 3 £ 


. 3 
TJ O 
O >■ 
x: ^ 

c tj 
0 c 

O 3 

0 E 

3 »_ 
"O 0 
O Q. 

£§■ 


w ^ ^ O 

O’ 0 0 -O 

C > 0 O 

-3 0 0 0 

^OJOO^ 

O. ^ 4-> I— 

0 T> 


0 

o 

0 


0 

2 

o 

X 

0 


0 T= 


0 
in in 
Oi o 
c Q. 

£ E 


_ O .5= 
■i=i 0 0 ^ 

0 2 0 0 
0 B 
0 .- 

0 ^ go 

0 c 

O cO O 

cl -E 0 o 

c E 0 

0 TO E "5 
0 « 0 E 

rj .E q.£ 


c 52 -c 'S 
0 0 .-t; o 
5 0 


0 sz 
0 o 

f I 


2 
0 0 
D>=i= 

w 0 0 

2 0 o £ 

0 ® 0 u. 

t; Q. o 


O 

0 

T3 


C 0 0 

2 •*- o 


3 

^ 2 TJ 0 

^oB^ 

c .2 o 


0 


E:° 

S-2 0 S 


t; 0 


0 
— ^ 

"o 2 


Q. 
■- ^ 


■5 o "O 0 

i«- 


0 

0 k_ 0 
E V- 0 3 
.E O) 0 
jC 0 O 
O- 0 

3 V- 
o I 


c 

0 


S’" 

■O 0 
— 0 ™ 
^ 2 
^00 
^ > "o 
>■^10 
O- ■“ 
0 
> 


0 

0 

E 


c 2 


CJ T3 

— cu y 


(/) 

z 

o 

p 

o 

< 

cc 

iil 


z 

UJ 

Q 

3 

I— 

0) 


O 

<=^5 

0 QJ 

■o 2 
0 o 
0 31 
o 


oy 0 
0 0 
~ c: 

0 0 

^00 

cn2 2 

li 


0 


0 P 3 


■° Trt — 

0 E 2 

0 C ^ 

3 0 

«|| 


.ii c: 

^3 

T— O 


I 


5 

T5 




0 O 
0 O 
3 0 


^'^ssz 

-- 0 £ ^1 

>, O) 0 —I 

iilll 


0) 

lU 

> 

I— 

o 

m 

-3 

m 

o 


0 

D) 

0 


C 

0 


0 

0 

2 

0 

0 

2 


0 

CD 

0 

O 

0 

CL 


0 

0 

E 

0 

k— 

0 

Ql 

S 

0 

S' 

o 


0 0 
2 E 
B o 

-L n— 

0 .0 


0 

J3 

0 

0 

J3 


CD 

g 

c 

0 

+-J 

0 

c 


o 

0 


0 JC 


2 

3 

o 

JZ 

in 

in 

4 —* 

c 

0 

•D 

3 

CO 


X 

m 


0 

c 

0 

CD 

0 


D. 

0 

O 

c 

o 

o 

0 

JC 

T3 

C 

0 

4-* 

0 


0 0 
CL P 


C 

D 








Generic Formal Objects 


£ C 

O o 

- ^ 

o 

> (n 

rz O) 

CO 

U) ^ 

o 

CD (0 
-J Q. 


0 2 

JO 0 ) 
^ 0 £ 

-Q n U> 
2 w ? 

■s 0.E 

O O £ 


E o 

I » 

.E a 

X E 
re E 

E i 


.■t; 0 0 ^ 

o « -S •- 

£ -g -2 i ro 

" S--s'^ ■'s 

0 ? .52 2 m ■“ 


— C O 


2 v>l fl. D) 

^ ^ 9 ; 0 

0 0 Q. 

c: IE ^ o 
0 0 
O) Cl 


0 

— vu 


0 0 
-j -O 
—' 0 

0 o 

Q. 


0 

0 

3 (/) 
0 o 

g '>3 

O 0 

£ 2 

0 o 

VN 

0 -C 
0 ) 0 
X £ 


§'-D 0 
2 Jr D) ^■' 

io 8 S E 

« 2; i= I . _ 

rn 0 L: — "O 

E Z 0 o 

0 .5^2 "c ^ 

0 0 0 

03 Q. 0.2 > ^ n: 

> .^ .^ 0 "D 

^ 0 


. . 0 
D) 

0 03 
^ D) c 
0 0 — 
C c A 
□ — II 
A A c 
" " 

E £ :^ 
0 0 - 
i=: ili o 

" - S 

O O O 
o CO O 

2 A 

A ii " 

II 0 0 

0 13 0 

o -S 

.5 0 

0 "^1 > 

s' 

“it 

■rrT3 0 

0 o 15 

-T- o 

n 5 > 
^ 0 > 
^ C 0 

® 0 ^ 
C ~ (0 

.55 0 
^ -u 0 

^ ¥ o 
o I H 

^11 

0 

c c UJ 


0 0 0 
0 ) 0 ) 0 ) 
0 0 0 
ji: 

o o o 
0 0 0 
Q. Q. Q. 


• • 


Megaprogramming in Ada Course; Reuse, 4-8 Copyright 61995, Software Productivity Consortium. 














DISCUSSION 

This slide presents a problem that will motivate the need for increased flexibility in declaring a generic 
formal object. 

Suppose you want to store students’ grades. Moreover, you decide that you want to store them by 




V) 

•o 

k. 

o 

o 

0) 

0) 

> 

CO 


12 

(0 

o 


rs 

oo 

>• in 

^ 2 
w Q- 

^ o 

cn -Q 
CO ca 

B 05 
CO ^ 

03 5 

c <0 
0) 2; 
*o ^ 

E 

03 <u 


CO 


CO 03 
03 -n 

o 2 
'5 
CO E 

O 
•*“> 
03 

CO C 
03 CO 

c ^ 

SE 

O O 
>*CO 

^ O’ 

m 

B O 

-C 

rs CO 
CO 

«.E 

03 O 
>. 03 


0 

g 

0 

k- 

0 

H— 

0 

!c 

0 

C 33 

0 

0 

■D 

0 

E 

u. 

0 

0 

0 

TO 

X 

0 

0 

0 

>4 

0 

0 

C 

0 

>s 

£ 

Q. 

0 

s: 

x: 

4 -» 

0 

m 


® to 

SI 


O) 

•E -o 
« o 

CO I 

bE 

O 03 
_0 03 
'S 2 0 

= 03 
CO 

■£■■£ 
iP S 3 

O 03 

cO — 

03 ^ 

tj; O 

« > 
4 —* 

c ^ 

03 >, 

■o 
o 


03 3 O 0 

n ?c ^ li. 


_ 0) 

ZD ^ 

C 03 
wJ CO _ 

S ^ CO 
^2 O 


_a 3 -Q 


CO 

x: 


03 C 

E 

'03 . O 

CO 0 
c 2 
T o 
« X 
c 

03 03 

2 CD 
03 TD 
O 


3 

■D 

O 

E 

CO 

03 


CO 

IZ 


CO 


03 

03 


c 
0 
i- 

CO 
Q. 
Q. 
CO 

03 * 
3 
O 
0 

ca 0 

O 03 


03 

0 

c 

o 

E 

o 

(n 


0 

jC 


C 

0 

TO 

3 


O 

E 

o 

sz 

t' 

0 

> 


CO .«2 o 


0 c 

TO O 

0 O 

0 ^ 
■O o 

o ^ 

>• if) 


if) 

0 

‘5 

O’ « 
0 0 
£ >« 
]9 o 

If 
0 0 
O O 
■Jrt o 

o 0 

£ 0 
CO 

0 

i-» 

9. CD 

£ o- 


CO "D 

0 O 
03 O 
0 0 

c® >! 

g 

CO 

0 ) 0 
o£ 


^ 0 
o-o 

0 2 
Q. 0 


4.4 

CJ 

Q."*” 

0 

fT ^ 
-1 

O 0 

> o 
c- 2 

CM £ £ 
di J 3 

22 0« 


o 

0 


0 
o 
o 

«> iS ” 
B g 


0 

■O 

0 


C33 

0 


— *j I CO 

cd CO ^ ‘o 

n 03 0 


0 
03 
0 

o 

0 

Ql 

S' 

O 

CO 

X 

_l 

o 

o 

sz 

o 

CO 

0 

SI 

0 

CO 

0 

o 

o . 
0 
r- 0 

0 0 
O) 

0 03 
032 


0 

3 

0 

0 

X 3 


C 

g 

0 

E 

k. 

c 


O C 
3 3 £ 

o "3 

> ^ 
o 0 £ 
x: -o 


o ^ 


0 

o 

c 

iS 

0 

c 


0 

jc: 


0 

x: 


0 

TJ 

0 

k. 

o 

CO 


^£ E 
c 0 
0 


£ I 


0 0 
h- 2 

3 
O 

5 


0 

0 

3 


>» 

C 

0 

C 

0 

0 


0 

> 


£ ^ 


03 0 
£ 

O C 

X .3 


-= 0 
0 jE 

C 0 

O’ 0 
cl 

0 O 

4- ^ 

^ 0 
0 ~ 

■e $ 

0 0 

o 
0 *- 

0 E 

0 ^ 

0 0 

0 > 

X 0 
0 T 3 
"D ._ 

.E E ^ 


0 

0 

X 

0 

■O 

c 

0 

0 

.X 

0 

E 

p 

3 

o 

o 

3 

o 

>4 


•D 

0 

"co 


iZ O 
0 0 

2 0 


0 

E - 

2 tz _ 
o £ £ 

■°£ 2 I 

|sl-s 

o o C $ 

»sil 

H" O w 


O 

^E 
0 0 
x: *- 
0 

° 0 3 
c 5 
.S’ 0 

C'’ 4.- 

0 5 
£ 0 

.E c 

§-B 

0 0 
5= 3 

0 '0 

-2 >5 
,0 ^ 
jc o 
J— 0 


3 

O 

>< 

c 

0 

x: 

5 


0 

X3 

0 

0 

3 

E 

•o 

c 

0 

0 

2 CO 

X 0 
0 3 
0 

E > 
o § 
E^ 


lU 

> 

1 “ 

o 

lU 

■3 

m 

o 


£ 

.Q 

0 

0 

XI 

p 

3 

o 

x: 

0 

£ 

c 

0 

T3 

3 

CO 


0 

0 

•o 

0 

k. 

O) 

4.4 

c 

0 

•o 

3 

0 

0 

0 

0 

O 

O 

0 

■o 

c 

0 

0 

g 

0 

o 

TO 

0 

0 

3 

0 

X3 

C 

0 

O 

0 

P 

"co 

0 


c 

o 

0 

0 


CD 

3 

4 —* 

0 

0 

x: 

4 —' 

5 

o 

c 

£ 

Q. 

X 

LU 





Megaprogramming in Ada Course; Reuse, 4-9 








Recording Student Grades 


CO 

k. c^. 
<0 >- 
0 ) o 

>T3 

O o 

LO ^ 

TJ CO 
O g 
gj c 
CD -e 

^ E 


w D 
S d 
^ m 

3 S 

C w 

^ (U 

E •§ 

LT ^ Cd 
0 C/D 

:5 0 ^ 

O O) 0 

10 ^ 

£ o ^ 

1 §. 


oO 

^ w' 

£ ? <B 

«|E 

0 0 I 
^ c x; 

13 C 
^ 

C/5 2 S 
0 
Q. 


03 0 
O 

CM 0 


E W 
o «•> 

m ^ 

■a o 

c 0 

0 Q. 


XJ Q 

h— 00 ‘ 

O 05 
O T- 

2 0' 

0 ^ 

i i 

o »- 
o 0 

0 C35 

CE S 

1 c 
— 

0 rQ 
^ 0 

0 

Q. 

>, 


Q. 

E 

R o 

o 

< E 


o 

o' 0 

UD QC 

A J 
II ^ 

0 0 

|a 
1 " 
X 

frt C 


o O 
^ I 


2 ^ 05 

0 "D 
-X 3 

O -i= 

0 CO 



Megaprogramming in Ada Course: Reuse, 4-9 Copyright © 1995, Software Productivity Consortium. 












DISCUSSION 

This slide presents generic range parameters. A generic range parameter solves the problem 
discussed on Slide 4-9. 

You could solve the problem with the indexes by adding to the Holder package another generic 






0 ) CO W 
>-3 0) 

£ E CL 

CO c 
o i 
O 0 ) 

>- 

. S CO 

-c c r: 

CO d) 

O c 

CL . 

>-</) — 
O CO CO 

.i g 

CO -g, 0) 

™ CO CD 
CO •- -p 

0 ) g-- 

■n H- >> 

< ° S 
^ 0 ) 

O) CD) 

® c: c 

o El 

5 CD S 
0^0 

XK ^ 


o):£ o 

S - 8 

c « o 

- = CO 

CO >< l~ 
cc 0) . 

> TD X 

> C 0) C 

E ■o o -o 
EcE 0) E 

CO ^ D) to 
5 vf 

TJ ^ E 0) 

S <dE 

8 S!5,-c — 

I - ^ 

-■^ o J 
ra 2 

« 2 ^ 0) 
o ^ -c 
2 •— 0) 

isl-; 

"Isl 

C ^ ^ 5 x 

E 

9 0) o 

c _i -o ^ 
T w X 2 

2 -sE 5 


>s -° « 

-I ro _ d) 
E 2 5 -c 

c CD ^ 
0) CO 2 :“ 
SZ o T) 
— If- LJ cu 

.eS^I 

E ■“ -o Z 

CD <0 ~ 

-Q 2 5 

CD ^ _ 

•IS 

.C .-t 03 
.CO c 

4 = E S« m 


O 

X) >. 

|E 

2 CD 


3 O 03 
O ^ CD) 

>'?r: c 


« E o 


« CO 

.o ^ 

E ^ 

-a 

“9 

m 

O 


03 CO 
s: '- 


CD O 


.E X 

E ■§ 

■O c 
=3 'E 
o 5 

>, CO 


> 03 

i .E 

^ c 

0) CO 


CD .C ♦- 

■° -D 5 
■D C O 
•5 CO JC 

Owe 

■82^ 

« E g- 

C Z LU 
CD 


• • 


1 







Generic Range Parameters 


■O 

(/) g; (/) 

3 c5 O 

C/) c -= 

S i § 

gy E X 
OF ^ 
c ■= -O 
OS E c 

i £ E 

i g I 

g 

< "o E 


(D 0 .- 

O) -Ji 0 
r— 0 ^ 

J= > 0 Co 

CO ^ 0 ^ 
^ "O 

X - — w 

^ E ^ -H- 

0 ^ w 

0 _i 

O r!n 

•C 0 0 0 

0 Q. Q.J2 Q. 
C O ^ 

0 0^ 

05 Q. 


o 

o 


0 

0 

c 


■x 



0 

co' 

E 

"D 

c 

E 

0 

4-* 

0 

4-* 

0 


c 

05 

E 

13 

•4—• 

0 

4-> 

0 

1 

0 ... 
k- k« 

c 


^ 0) 

1 


C X 05 

— 00 
■ • ■*“* 

-D ^ C 
"D ^ — 


I — 

o .” ■*:= 


. ^ ^1 - - 
.55 I -1 0 

—J 4- C _J 

I ^ io 
P. E io 

0 ^1 0 C 

E £ S o 
S I ffl s 
'— E 

S S E 0| 

^ -n^ ^ 
? e' F 

m m ^ ^ 


13 C C 

■o -o o O 

0 0 4 =-^ 

O O O O 

p o c c 

0.0.3 a 


0 ^ 3 


^ o 0 0 

0 o .Si F 

0 p ^ 0 



0 CO iJ 

Jill I 

> ^ ^ 0 T3 

i- C 

Q. 0 



Megaprogramming in Ada Course: Reuse. 4-10 Copyright © 1995, Software Productivity Consortium. 















DISCUSSION 

This slide shows how to use the new Holder module. 

The slide shows two generic instantiation examples. The first, Students, is equivalent to the example 
on-Slide 4 - 9 . However, the equivalence is obtained by specifying a range and, in particular. 




Megaprogramming in Ada Course: Reuse, 4-11 









o 

c 5 


o 

o 

o 

CO 

0 ) 

JZ 

Ui 

c 

w 




CO 

Lj 

CT' 

o 

X 

1 

O CO 

^ H 

O CO 
CO ^ 
ij CD 
CD "O 

> E 

l^.CO 

co' l: 

CO 
CD 

^ CD 

D> 

C 

< ( 7 ) 


c 

CD 


CD 

> 

LJJ 

I 

CO 

■ 4 -- 

c 

0 

■a 

• 4 —> 

CO 


< 

M— 

O 

^1 

0 

J 3 

E 

3 

z 

2 

CO 

X 

_l 

o 

o 

sz 

o 

CO 

+ 

o 

00 

C 0 


o 

00 


0 

0 

>- 

0 

> 

LU 

I 

« 

c 

0 

T3 

3 

■ 4 —• 

CO 


oi 

I O 

3 0* 
Z O) 
I C 

E iy) 
^ 5 :^ 

o 0 

CO 70 

51 

o 

O (O 

E 

CO ^ 

II =J 


0 

0 


CO 


c ■=. 


CD 


0 

0 

>“ Q. 
>- O 
O O 


D5C0 D. 
.E »- O 
CO £ o 









D) 

C 

'-a 

'jc. 

c 

o 

c 3 

E 

u- 

o 

T 3 

C 

C3 

c 

o 


O 

OT 

cn 

D 

O 

£2 

Q 


03 

n 

n] 

w 

13 

2 

a 


03 

03 

o 

£ 

03 


03 

33 

■O 

o 

E 

OJ 

03 

CO 

Q. 

(0 

•o 

CO 

03 

k- 

O 

£ 

03 

sz 




t3 

CO 

« 

n 

CO 


03 

CO 

n 

03 

CO 

o 

03 

03 

;d 

1 o 

x: 


X 3 

CO 

cx 

CO 

T3 

CO 

E 

o 


CO 

03 

E 

o 

o 


X3 

CO 

<0 

D 

03 

tr 


2 5 

CO "O 

>' o 

II 

CO ^ 

=3 CO 

8 E 

o o 

03 

M 03 

3 Q- 

2 03 

o 

T 3 ^ 

C k_ 

E g 

c 

•- CO ^ 

c .1 

■5.0 § 

03 c a 

03 3 

^ tz 

^ 03 .9 

i!J 3 3 

« ^ to 

E 

-S cn 

^ ^ ‘t 

a 

03 .9 Q. 
0-2 
t 03 </3 

CD cO E 

^ o CO 

E 

03 :tz 
O fa 03 

03 5 =5 

^ &-Ci 

CO b o 

E CO E 

C 03 £0 

Sgf 


CO c 
■ CO 

o 


CO 

X) 


CO 


O — 

ll 

03 2 
Ol^ 

CO O 
03 
D. 

JZ X 
— 03 

t « 

k 

* g.. 

.9 . w 

" 03 9 

o -= o 
0 ) ^ 
0-^3 b 
cn Q. c 

CB CO O 
" T 3 O 
C cc ^ 

CO ° 


c 

o 


o -:^ 


03 
03 03 


C 

2 

cO 


o 9 


o 

■c 

2 ” c: 
CX g 

5 o 
§ ^ 
5 
o 

03 X 

3 


C 

03 

0 =: 

o 

CO 


o o 

■cO « 
x: .£ 

CO 


o 

CO 
. CO 
03 -O 
03 


E 

CO 

CO 

03 


.9 O i= 

03 E 
^ ® o 

03 ^ t 
^ 03 


2 ^ 
03 W 


O 


2 CO 
CO 
X3 
O 

0 03 CO 

I- ^X 1 


2 5-- 

3 O o 
X3 X « 

2 . 03 

E.E 3 
1_ CO T3 

3 03 O 
O CO C 

^2 0 

t3 o c 

c E .25 

3 CO 
H- 03 03 
O £ -o 

2 *- 2 
^ ® 03 

CD-g^ 

£ o 2 


O 03 03 

3 .E 

03 -a TS 

o 2 ^ 

^ c 
— 03 o 
C £ •i= 

O — CO 

■^•S E 

O CO £ 

321 

"D to 

O -O >, 

E 2 Q. 

^ O CL 
CJ) CO CO 

£ CO 

o 

o 
o _ 

CO <0 


03 5 

2 o 

CO ^ 

cz 

O c 
o g 

CO g 

S E 
o 

4.^ '+■- 

3 c 

O •“ 
■^.2 


c 

jc 

•a 


— <0 

-5 -' 

o 2 
x: 3 

CO TO 

3 c 

o 9 

^ 03 

2" — 

M 

cO 

c o 
25 £ 
CO o 
e 

■o c 


CO 

to CO 

o ^ 

03 5 

k. > 

1 = 

>- CO 

c- E 

o .E 

o o 

c w 

2 o 

I ^ 


03 


C. 

o 


3 o 
o £ 


g 

CO 

cO 

X 3 

03 


C2. -,- 3 ; 


CO ® 

TO 


|J, 

Ss 

a “ 

> CX 


c 

CO 

o 


O £ 


2 

3 


3 

o 


03 

-ti (fi ^ 
O CO CO 
p 03 "D 

ii 


03 

x: 


CO 

03 


c 

CO 

5 

CO 

E 

CO 
U) C/) 

2 E 

“■o 

*- 

2 CL 
O CO 
■J=: >' 
■2 
■= J 

CO 


CD 1 - 
C ^ CD 

S *- £ 

-•^ 03 O 

cO f- 
^ E — 
g ^ 

o 2 ‘i’ 

2 o 

5 03 CO 
*“ C tl 

o > 2 
CO £ .E -3 
CO CO T 3 

03 t= £ E 
2 

03 ■o - S 

C ^ 

E E CO 
2 b 0 3 

■=^2 E 

.Q g.o32 

CO to 

~ OT o 2 

2 .-t:; o o 
0 5 0-_Q. 
0 0^0 
c — 
o 3 o 

O O w 

S TO -Q 2 

O .>,41; ■— 
_ Q. O 

^ ^ ^ ^ 
O O X3 C 

>- 5 TO Q. 


03 


CO 


0 
2 
3 
T 3 
O 

E 

2 
xa 
TO 
0 
3 
0 

i_ 

0 •= 

4 -* 

TO 

0 
ih- 

O 

3 
O 
>. 

Q. 

0 


O 

2 

TO 

0 

0 

3 

4 —» 

TO 

0 


C 
C 0 

i> 8E 

3 
03 

c 
TO 

CO 
T 3 
< 


•o 

0 


x: 

CX 

TO 

T3 

CO 


0 

0 


0 

03 

CO 

03 

0 


CO 

X3 


0 

TO 

Q. 

0 

>4 


J3 

TO 


g 

‘k. 

0 

c 

4-» 

0 

2 

E 

2 


!E 

^3 


0 


"D 

0 


C33 

3 

X3 

E 


M— 

0 

f— 

0 


c 

0 

x: 


03 

4-» 

0 

0 


0 

0 

c 

3 

TO 


■0 


5 


0 

jC 

0 

0 


4.4 

'0 

x: 


c 

TO 




0 





0 


c 

0 

0 


TO 

-C 

TO 


■c 

4 —* 

t 


0 

0 

0 


CX 

■— 

C 


E 

0 

0 

0 


0 

CO 

2 

3 


k_ 

TO 

0 

4-> 

c 

■0 

0 


0 

0 


E 


a. 

c 

TO 


‘o 

CO 


C 

$ 

.£ 


'k- 

CX 

0 

x: 

0 

5 

0 


C33 

c 


JZ 


b 

0 

0 


x: 

0 

0 

4-. 


c 

0 

0 

g 


g 

03 

TO 

b 

to 

C3 

TO 

0 

C 

0 

X3 

E 

0 

Q. 

0 

TO 

'f— 


o> 


0 .2 
9 0 

0 

0 

0 

X3 

_C“ 


0 
5 Q- 

^.i 


r 

TO UJ 


O 

3 

O 


> 

>: o 

UJ 
s 
CD 

o 


2 

3 

o 

x: 

0 

0 

c 

0 

"O 

3 

4 —» 

CO 


5 

c 

2 

Q. 

X 

LU 


<«) 











Designing Reusabie Moduies 


X 

O 

LL 


CO 

C 

D) 

V. 

3 

O 

>- 


c 

o 


(/) o 

0) 

XJ <D 
4-i C 

o 0 ) 

(0 O) 

X m 

<u S: 

c 

(0 

>» 
w .ts 
iJ = 

3.-S 
^ X 
O 0) 

I- *0 
0) 0) ^ 

£ 5 w 

o2 S 

O (0 0) 

.'S <D E 

2 

^ CO 
0. O Q. 


O 

G) 

CO 

o 

5 CO 

CD ^ 

£ CD 
TS 

c > 

§ 2 

•«-* Q. 

CO CO 

“■S 

® -g 

CO c 

■C I 

Q. CO 

CD Q- 
£ CD 

c ■*- 

o ^ 
5 -= = 

<ir>fi 

■S T3 X 
« O 0) 
X M= 


3 

O 


CO 

•o 

o 

5 

CD 

O 


CO 

CD 


g « 

■i ® 

Q. 3 
0)0 
I 

1 ® 

o ® 
O (0 

3 

CO CD 

o O) 

H— » 

C CO 
— 0 
■D "D 

C 3 

o 

c > 
.2 Q. 
O CD 
2 
CO 

n 

< 


(g) 
















Picture for Reuse 































g 

cn 

(/) 

3 

O 

g 

□ 


CO C 

E:S 
ifi 5 

w E 

CD m 
03 « 

I ” 


03 


0 


0 
o’ 

M gr 

cn ^ o 
c ~ 

■q. ra o 

"o ’^P 

> -^ ti 
0 C3) O 

X] x; C 

-c *fe ■n 


5 

w 

E 

0 

S3 

O 

Q. 

0 

sz 


2 
C! ^ 

O 03 

.y 0) 
tS .£ 

O 03 
CL 0 
0-0 
JC "O 


0 


^ O 
a sz 
a; w 


0 
> 

0^0 
o 

“ o 


^ o 


TJ 2 D 

%<no 

O)— yj 
03 CD) 

C C 0 

0 S ^ 

0 c -55 
0 03 ” 

O 0 ) 2 

03 ^ 

C « 

0 5 


2 o 
0 « 


C 
0 
5 
=> 

^ o ° 

".I E 
o o 

O 0 c: 

c S’ o 
= on 

- o o 
0—0 
w 0 

E g) 

<D <D -O 
^ -C 3 

h-H ^ 


(D 

(0 

w 

3 

O 

O 

w 

Ic 


3 — 


O) 

■C ^ 
0) = 

g I 
■& 
c 
0) 

0) 
nJ 


o 

CO 

CO 

o 

0) 

a 

CO 

CO 

3 

o 

c 

o 

n 

Q) 

■ 4 -» 

2 

*-* 

C 

CD 

O 

c 

o 

o 

CD 

5 


r= SZ 


C 

g 

to 

o 

c 

3 

E 


E 

0 

E 

0 

n 

0 

0 

u 

E 

X 

X 

x: 




5 

5 

5 

CO 

CO 

CO 

Q. 

Q. 

Q. 

0 

CD 

0 

X 

X 

X 

D) 

D) 

05 

C 

C 

c 

x 

'k_ 

X 

0) 

0 

0 

0) 

0 

0 

c 

C 

c 

‘D) 

'd) 

’O) 

c 

c 

c 

CD 

0 

0 

<D 

0 

0 

V. 

k. 

k. 

(0 

0 

0 

> 


> 

£ 

£ 

£ 

0 

0 

0 

« 

tn 

Ui 

5 


3 : 

0 

0 

0 

X 

X 

X 


0 


o 


L 0 0 0 

; cs.g 
.9 0 0 

' 0 S’S 

' 0 .E S, 

rji: 0 03 
0 JO 0 

•9 ^ "3 
; 0^< 
0 t: c 


0 E^0 

x: o 0 •“ £ 

C CD) g ° 

W CO .h= *0 O ^ 

<0 c 2. £ ^ CO 

^ 0 g-n 0 0 
0 E ■- E £ 0 
E “ 0 0 0)9 
£ g-£.g.c g 

i-l o I 

(2 g 0)0 
®l'o ^Q. 

o fl) 0 .0 

>,900 
0 £ 0 0 

.£ .0 !! 0 •■^ 

~ 0 g ‘ol o o 

0 (§ I 0 g .g 
E 0*0 E ^ 
cx. c: c j— 

O £ 0 g.o . 

§ gx; 0«s 

0 J II '9 .9 9 , 

"o rt .-= .£ 2^ 

S 3 0 0 

0 0^ 

|l§iPlg 

£.^ 0 0 0 . ,;j 

0-5 3 £< 

0 o 0 c S 9 

^ ^ ^ 0 to O 

t- S *3 J cd)£ ’c 

o > 0 0 < -E 0 
0 o ^ ^ 

0 5 *- ffl o o o 
^ 0O g 0 

I! 0 ^ >. CD) 2 .-2 

o — g -.E 0 .> 

9 >s 0 -K Q.-0 

*; 9 05 2 0 T. 

C Q. r- “ rn ^ 


o 


<0 O) ^ 

c d ^ .E 3 
c c o) 

0 ) Q) rt 

5 CO Q) 

XJ XI ■* c > 
O O y CO S 
Q. o. Q. E a. 



( 8 ) 


• • 













Course Summary 












MuRaprogramming in Ada Course: Reuse, Workbook 


UNIT 4: REUSE 


UNIT SUMMARY 

As you develop software, you will often find that you need a module that offers functions and data 
types similar to, but not exactly matching, one you have developed in the past. The more experience 
you gain with software, the more you will find this to be true. You will also find that other people have 
developed software you might be able to use. In other words, no program is totally unique. It solves 
a problem related to problems that have already been solved, and its modules and structure resemble, 
in part, modules and structures of existing programs. 

You should try to reuse existing software whenever you can. Studies have shown that in many 
programs, especially larger ones, 50% of the lines of code can easily come from existing programs. 
Reuse of 70% of the code is not uncommon. Since a software developer produces an average of 40 
lines of code per day over the course of a project, it’s easy to calculate just how quickly the savings will 
add up. 

Unfortunately, reuse is harder than it might seem. You’ll find the primary reason is that you developed 
your modules for use in a specific program. When you try to use them in another program, you often 
realize you need something slightly different; a function must operate on a string rather than an 
integer, for instance. You may find that writing a new module from scratch is easier than modifying 
an existing module. 

There are several things you can do to improve the chances that a module will be reusable. One is to 
use generic packages. When you write a generic package, you declare generic parameters that specify 
the different ways you expect you might want to use the package. You can then instantiate the generic 
package by providing values for the parameters that meet the needs of specific programs. For example, 
you can use Ada generic packages to rewrite the Line_Holder package so it can hold integers, strings, 
or any object that is a valid Ada data type: 

gancrlc 

typa 11:hu\ Is private; 
packags Holder la 

typa List- la privata; 

procadura Initialize(Items: out List); 

privata 

Max_Values: constant Integer := 10000; 

typa Items is array (Integer range 1..Max^Values) of Item; 
typa List ia racord 

Number: Integer ranga 0..Max_Values; 

Values: Items; 
and racord; 
and Holder; 

If you then declare a data type representing a line: 

•ubtypa Lino la .String(1 .,255); 










(i) 








• • 










1 


i 



MegaproRramming in Ada Course: Reuse, Workbook 


you can create a Line_Holder package that behaves identically to the one in Unit 3 using the following 
generic instantiation: 

packaga Line_Holder is new Holder(Item => Line); 

Because Holder is a generic package, you can use it to hold objects of any type. For example, you can 
use the following generic instantiation to hold a list of integers: 

packaga Integer_Holder is naw Holderdtem --> Integer); 

The Ada compiler cranks out a new package based on the parameters to the generic instantiation. It’s 
as if you took the Holder package and substituted Line or Integer everywhere item appears. See 
Figures 1 and 2, drawn from the Ada code on Slide 4-6. In each figure, the generic Holder package 
on the left side, with its generic parameter item, is instantiated to yield the package on the right. 



Data types ain.1 numeric values are examples of parameters you often use to make a module more 
reusable. 

Ada has many kinds of generic irarameters. Figures 1 and 2 illustrate a generic type parameter. You 
can also write generic packages with generic formal object parameters. A generic formal object is a 
parameter that’s a constant value, such as an integer or a character. For example, you could add a 
parameter Max_Valucs that controls the maximum number of values a holder can store. See 
Figures 3,4, and 5, drawn from the Ada code on Slide 4-8. A second generic parameter, Max_va] ues, 
has been added to the Holder package. This parameter lets you specify the maximum number of 
values an instantiation of the Holder package can store. You can now control both the type and size. 
Figure 3 creates a package that stores 1,000 lines. Figure 4 creates a package that stores 30 integers. 
Figure 5 creates a package that stores 50,000 integers. 

A generic type parameter can be any valid Ada data type, even one declared from a generic 
instantiation. Figure 7, drawn from the Ada code on Slide 4-9, illustrates this point. Here, the item 
used in the lower generic instantiation is of type List from the package students, which was 
instantiated from Holder. 


2 














Megaprogramming in Ada Course; Reuse, Workbook 



Mgurc 3, Generic InslaiUialuni of the Holder Package to Hold 1,000 Lines 

Another usel'ul kind of generic parameter is the generic range parameter. It is a special case of the 
generic type parameter, where the type you provide is a subtype of integers. Using subtypes helps you 
overcome the situation in Figure 7, where to index calendar years you must create a new data type to 
hold the years of a school’s existence. Figure 6 uses the Year_index subtype in the lower generic 
instantiation to create a holder module whose indexes range from 1980 to 2029. 

You can also improve the chances that a module will be reusable by spending some extra time thinking 
about reuse as you develop the module. Ponder the functions that the module offers. Think about what 
is essential to the module and what is incidental to the program for which you arc developing it. This 
will help you realize what generic parameters are appropriate. 


































Figure 5. Generic Inslanliation of the Holder Package to Hold 50,000 Integers 

Reuse goes hand in hand with the information Jiiding design method covered in Unit 3. To create 
reusable software, you must make it adaptable to a range of situations in which it will likely be used. 
You can do this by hiding how the essential functions work, but showing, on the interface, the exact 
ways in which the adaptation is possible. This separation of interface and hidden information comes 
directly from information hiding. 














































Megaprogramming in Ada Course: Reuse, Workbook 


Name 

Math_Grade 

CS_Grade 

History_Grade 


Index / 

Item / 

type List; 

procedure Initialize; _ 

List: 

I Item I ... I Item | 

1 Max Values 


Student Index 


Generic ll. 

Instantiation 


Z S/i/^^£r 
type List; 

procedure Initialize; 

List; 

1 Student; 

Name 

Math_Grade 

CS_Grade 

History_Gradc 

SO Student; 

Name 

Math_Gradc 

CS_Grade 

HistoryGradc 


Index 


Item 


type List; 


procedure Initialize; 

List: 

Item 

Item 

1 

Max_Valucs 


Year Index 


Item Index 

J L J L 


Generic 

Instantiation 


_ 

typo List; 

procedure Initialize; _ 

List; _ 

1980 Sluden l Holder: 

1 I Name, Grades | 

50 I Name, Grades I 


2029 Student Holder: 

1 I Name, Grades | 

• • t 

50 I Name, Grades I 




Figure 6. Instantiating Student Grades and School History Using Generic Range Parameters 


• • 










McRaprogramming in Ada Coui^se: Reuse. Workbook 



Figure 7. Inslantiating Sludeni Grades and School History 























Mcgnprogramming in Ada Course: Reuse, Laboratory 


UNIT 4: REUSE 

LABORATORY SPECIFICATION 


Note: This laboratory is not being produced for the pilot offerings. The laboratory will appear in a 
later version of the course, based on comments received from the teachers of the pilot 
offerings. ITiis specification provides a definition of the current vision for such a laboratory. 
Because the laboratory has not been built, not all issues have been resolved. Unresolved issues 
are shown in italic text. 

PART 1: BACKGROUND 


In this laboratory, you will assemble vending machine software. You will not write this software 
yourself; you will use the reuse techniques you learned in your lecture to create it. You will work in 
groups, jointly reusing and developing the software. 

Suppose you are an employee of the Press ’n Gobble Vending Machines Company. One day, your sales 
department informs you that it has located two potential markets Tor the vending r chines your 
eompany builds. However, none of Press ’n Gobble’s current machines quite fits .ther market. 
Management has decided to develop new ones and assigns you to develop the software the machines 
will need. 


Here is a description of each machine: 


1 . 


The first machine is to be sold in the United States. It will dispense a variety of food products. 
It will look as shown in Figure 8. Items in the second row cost 65?. Ail other items cost 55c. 







-n 


1 


Caramd 


u 

e 

1 


a 

a 

e 

a 


u 

sr 

b 


11 


12 

13 

14 

15 


l| 

1 5 


v- a 




. 21 


22 


23 


,r 

# 






a,a 

Will 


ll 



31 


32 


33 


34 


35 



t 

1- 


a 

if ^ 


11 

<3^ 


I'g 


4, 

<3 

95 

C 


41 


42 

43 

44 

45 


Money 

Received 



injliliiip: 

iDllBilS; 




Enter 

Selection 




Figure 8. A Foiid-Dispensing Vending Macninc 










2. The second machine is to be sold in Germany. It is shown in Figure 9. This machine is to 
dispense hot beverages: coffee, decaffeinated coffee, tea, and espresso. Because it dispenses 
only a few items, it does not have a numeric keypad for selection. Instead, each item has a 
button; you push that button to get the item. Of course, German labels will be .substituted for 
the English ones when the machine is placed in final production. You can insert 10 pfennig, 
50 pfennig, 1 DM, 2 DM, or 5 DM coins. The machine dispenses change using 1 DM, 50 
pfennig, and 10 pfennig coins. 



Figure 9, A Driiik-Dispcnsing Vending Machine 


Your assignment for this laboratory is to generate the software for both vending machines. You will 
do so by choosing the necessary software modules, as explained in the exercises below. You must 
compile and link these modules. You can then run the software. 

The SoFiwARE Design 

Press ’n Gobble’s software developers maintain an exten.sive, well-organized reuse library of the 
modules they have developed over the years. Furthermore, they have developed a general design for 
vending machine software. When presented with the '•equirements for a new vending machine, they 
can quickly determine the modules they need. Every program they develop always has the modules 
listed in Table 1. 










Table 1, Software Modules Used In All Press ’n Gobble Vending Machines 


Module Name 

Module Description 

Change Return Button 

Signal that the money the person has entered so far is all to be returned. The 
hidden information of this module is how it is determined that the button 
has been pressed. 

Coin Return 

Dispense a selected amount of money, in coins. The hidden information of 
this module is how the hardware that dispenses coins is activated. 

Coin Acceptor 

Accept coins and nrovide to the software the value of the coin. The hidden 
information is thi ucans by which it is determined what coin was entered. 

Item Dispenser 

Dispen.se a product to the person. The hidden information of this module 
is how the hardware dispenses products. 

Money Accumulator 

Maintain a record of how much money the person has entered so far. The 
hidden information is the means to calculate and represent this 
information. 

Item Selector 

Signal a selection. The hidden information of this module is how it is 
determined that the person has prc.ssed the buttons to make a selection. 

Input Event Handler 

Collect and respond to the .signals issued by other modules. The hidden 
information of this module is the algorithm for collecting and responding 
to signals. 

Change Calculator 

Determine the amount of change needed for a purchase. The hidden 
information of this module is the algorithm for calculating change. 

Price Information 

! 

Maintain the price for items dispensed by the machim, and allow 
determination of whether a .specified amount of money is sufficient to 
purchase a specified item. The hidden information is the representation of 
the prices and the algorithm for determining whether the purchase price is 
enough. 

Holder 

Maintain a list of items. The hidden information is the representation of 
the list and the algorithms for acce.s,sing it. 


The details of some of these modules may vary between machines, but a form of each module exists 
in the software of any vending machine Press ’n Gobble sells. This list of modules is not intended to be 
complete, just illustrative. They were derived usinf' information hiding. Moreover, many of them are used 
in both vending machines. This module sharing is the primary requiremetU for any design. • 

Press ’n Gobble’s software library has other parts too. These parts are only needed in certain vending 
machines, as described in Table 2. 

Table 2, Software Modules in Specific Press ’n Gobble Vending Maehines • 


Module Name 

Module Description 

Include If... 

Bill Acceptor 

Accept bills, and provide to the software the 
value of the bills. The hidden information is the 
means to determine what bill was entered. 

The vending machine is to accept 
both coins and bills. 

Money Display 

Display an amount of money. The hidden 
information is the algorithms used to activate 
the display. 

The vending machine is to display 
the amount of money the person has 
entered so far. 










































Megaprogramming in Ada Course: Reuse. Laboratory 


PART 2: LABORATORY EXERCISES 

Exercise 1: United States Vending Machine 

You are to create the software needed for the vending machine to be sold in the United States. You 
must perform the following steps: 

1. Read ^he description of the food-dispensing vending machine on Page 7. 

2. Determine the modules you will need for the vending machine’s software. 

3. Assign a set of modules to each member of your group. You should bear in mind that some 
modules are larger than others and partition them equally across your group so eveiyone has 
approximately the same workload. Use the figures in the last column of Tables 1 and 2 as a 
rough guide to the relative time each person will need for each module. Thin column isn’t in 
place yet and can‘t be until the software is written. We shall need to time each module's compilatioi 
and prepare the figures based on that information. Note that Steps 1 through 3 would make an 
excellent prelaboratory homework assignment. 

4. Each person must perform the following steps. See the accompanying write-up on using the 
laboratory for instructions on how to do so. 

a. Create a directory in which to work with her or his assigned set of modules. 

b. Copy the modules assigned to her or him from Press ’n Gobble’s library of reusable 
modules to the directory created in Step a. 

c. Write generic instantiations for the following modules ;.. .We shall ask the students to 
write a few generic instantiations, just so they get the feel of adapting reusable modules to 
fit a specific need. We shall provide them with templates, and we shall provide the teacher 
with the answers. 

d. Create an Ada library. This is assuming that the Ada compiler does not support 
concurrent compilation using a single library. 

e. Link her or his library with the library of everyone else in their group, 

f. Use an Ada compiler to compile her or his modules. 

There is one complication to Step 4.f The modules are represented as Ada packages. 
As Unit 1 mentioned, Ada packages must be compiled in a particular order. You and 
your fellow group members must observe the rules in Table 3 as you compile your 
modules. 


Table 3. Compilation Dependencies Among Press ’n Gobble Software Modules 


Module Name 

Compilation Dependencie.s 

This column lists a module that’s 
dependent on at least one other module. 

This column lists all dependencies. 





MeBaproRramminji in Ada Course: Reuse, Laboratory 












• • 










II 


• • • t • • • • •• 


/ 5. Your group is now ready to create an executable program. The person who compiled module 

^ main program must invoke the Ada linker. 

You may now execute your program, using the following input data :.... 

After you have finished executing your program, answer the following questions: 

1. What communication difficulties did you encounter and how did you overcome them? 

2. How would you compare this to your experience with software development? 

Exercise 2: German Vending Machine 

Repeat Steps 1 through 5, this time creating software for the vending machine Press ’n Gobble will 
sell in Germany. 

When you have built the software, execute your program, using the following input data :... 

Now answer the following questions: 

1. How many modules from the first assignment did you reuse without any additional work? 

2. How many modules from the first assignment did you reuse by performing different generic 
instantiations? 










MegaprogramminB in Ada Course: Reuse, Laboratory (Instruclions) 


PART 3: INSTRUCTIONS FOR LABORATORY 

Note: This laboratory will ultimately be available for a variety of platforms (IBM PC, Macintosh, 
etc.). This write-up, which describes how to use the laboratory, is specific not only to each 
platform but to the institution in which it is used. A separate version of this write-up is 
therefore needed for each platform, and instructors must tailor it to their own institutions. In 
all cases, students must; 

— Have an Ada compiler 

— Be able to create files 

- Be able to read files created by other students 

- Be able to read a set of files created by the instructor 

For simplicity’s sake, this write-up is written as if the laboratory were being run in the following 
environment: 

— Each student has access to an IBM PC (or compatible) computer with a 286 or 
compatible processor. 

- Each PC is connected to a file server on drive S. 

- Each student has permission to create files in a subdirectory of drive S. 

- Eacli student can create and edit text files (Microsoft’s edit application or most Pascal 
compilers would do). 

— Each student has access to an Ada compiler. 

As in the laboratoiy descriptions, unresolved issues appear in italic text. 

This write-up describes how to use your computer to perform the vending machine laborato:y 
exercises. The emphasis is on Steps 4 and 5, since these are the steps that involve using the computer. 

1. To perform this step, you must log on to your computer. Then perform each of the following 
steps: 

a. Create a directory in which to work with your a.ssigned set of modules. For this 
laboratory, you will work in the directory s: tadaiab. Create a directory whose name 
is your last name: 

C!\>S: 

S:\>mkdir \adu I abXyournanie 
S:\>chdir \adaIabXyourname 

b. Copy the modules assigned to you modules from Press ’n’ Gobble’s library of reusable 
modules to the directory you created in Step l.a. You will find these modules in the 
directory s: \adalab\pressgobiiIe_moduIes. The modules are in the following 
files: 








Megaprogramming in Ada Course: Reuse. Laboratory (Instructions) 


Here we include a table listing all the modules shown in 
the tables in the laboratory. For each module, we state 
the file or files holding its code. 

S: \BdBlab\yourriaaia>copy \adalab\filel. ada . 

Perform a copy command for each module assigned to you. 

c. If you have been assigned module X, you must write a generic instantiation of package 
Y named Z. A generic instantiation of y has the form: 

package Z is new Y{P1 => VI, P2 -> V2) ; 

Use text editing application to create a file named z.ada that contains the above line. 
Use valuel for vl and value2 for V2. 

d. Create an Ada library, using the following command: 

S; \adala])\yournai)]«>/nkiib 

c. Link your library to that of other members of your group. For example, if your partners 
are hername and hisname, issue the following two commands: 

S: \adalab\yourxiajn»>iinkllii s : \adalib\hernan\e\ada . i ib 
S : \adalab\yourijajn«>iinkIijb s : \udalib\hisname\ada . lib 

f. Compile your assigned set of modules. For instance, if you are assigned modules 
stored in files x. ada, y. ada, and z. ada, issue the following commands: 

S:\adalab\youriiajn«>ada x.ada 
SI\adalab\youriiama>ada y.ada 
SI \adalab\yoiiri 2 amo>c-ida z.ada 

Be sure to observe the dependency rules! If you do not, you will get an error message 
from the compiler: 

Thti error nioasage when a package can't ba bound. 


2. Whoever in your group was assigned to compile the file main . ada must now link together all 
the modules: 

S:\adalib\yournaJiia>iiuk main 

This will produce a file called ;nain, exe. You can execute this file by typing the command: 

S: \adallb\yournaina>;nain 









Megaprogramming m Ada Course: Reuse. L aboratory (Instructions) 




» 





K 


» 


i 


This page intenlionally left blank. 


i • 


» 


» 






McKaprogramnniim in Ada Course: Reuse, Laboratory (Teacher Notes) 


UNIT 4: REUSE 

LABORATORY SPECIFICATION 

TEACHER NOTES FOR LABORATORY 

This section must describe to the instructor how to conduct the laboratory. Topics include: 

• Suggestions on how to make the example seem more realistic by inventing a background tailored 
to the school in which the course is being taught 

• Answers to the laboratory exercises 

• Additional questions the teacher may want to ask students 





Thin page intentionally left blank. 




TEST FOR 

MEGAPROGRAMMING IN ADA COURSE 


1. True/False Software developers spend the majority of their time writing code. 

2. True/False The majority of software changes result from the need to enhance the 

software. 

3. True/False A programming language can help developers manage . change and 

communication. 

4. True/False The only information in a package that is visible to other packages is that 

contained in the package specification, outside the private part. 

5. Abstraction helps developers separate the_from 

the__. 


6. True/False A developer who builds an Ada package must write both the specification and 

the body before it is useful to other developers. 

7. True/False The stepwise refinement design method results in designs that are easy to 

change. 

8. True/False The first decisions you make when following the information hiding design 

method concern the modules in your program. 

9. True/False Software developers usually find similarities between the programs they are 

developing and programs they have developed previously. 


10. Ada 


developers can reuse. 


help software developers build packages that other software 


• • 


11. Describe the purpose ol software design. 







'aprogrammini 


R in AQa k^oursc: icsi 


12. Using the principles of abstraction and information hiding, design the interface for a module 
that implements a counter—that is, something another module might use to maintain a count 
of the number of times some event or situation occurs. 




i 













13. Consider the following specification of a package for searching an array of integers: 

packaga Integer_Array_Search la 

BUbtypa Array_Index Is Integer ranpa 1..1000; 

typa Integer_Array la array (Array_Index) of Integer; 

procadura Search_Array( 

Array_To_Search: in lnteger_Array; 
Nutnber_Of_Eleinent£j: in Array_Indcx; 
Element_To_Search_For: in Integer; 

Elen\ent_Found: out boolean; 

Index_lf_Found: out Array_Index 

1 ; 

and Integer_Array_Search; 

Use generics to rewrite this package to be more reusable. 




• • 


















McRaprosramming in Ada Course: Test 


TEST FOR 

MEGAPROGRAMMING IN ADA COURSE 

TEACHER ANSWERS 

Software developers spend the majority of their time writing code. 

The majority of software changes result from the need to enhance the 
software. 

A programming language can help developers manage change and 
communication. 

The only information in a package that is visible to other packages is that 
contained in the package specification, outside the private portion. 

5. Abstraction helps developers separate the essential information _from 

the irrelevant details _^^_. 

A developer who builds an Ada package must write both the specification and 
the body before it is useful to other developers. 

The stepwise refinement design method results in designs that arc easy to 
change. 

The first decisions you make when following the information hiding design 
method concern the modules in your program. 

Software developers usually find similarities between the programs they are 
developing and programs they have developed previously. 

10. Ada s^’nerics _ help software developers build packages that other software 

developers can reuse. 

11. Describe the purpose of software design. 

Software design lets software developers decompose a problem into a set of modules. Each of these 
modules is simpler than the whole. This is necessary to reduce the complexity of the overall system, 
making it easy for individuals to understand portions of a system. 

Another reason for software design is to break a problem into parts that can be assigned to a set of 
individuals. In other words, software design is necessary for large programs to ensure that each 
person on a team has a coherent development assignment. 


6. liue/ palse | 

7. True/ pals^ 

8. [rrue/talse 


9. Irrue/False 


1. True/ t^alsel 

2. tTrue/f alse 

3. iTrue/f alse 

4. Irrue/^ alse 







^i) 










B 




e 


B 


B 


B B B B B 


B • 


3 













Megaprogramming in Ada Course: Test 


12. Using the principles of abstraction and information hiding, design the interface for a module 
that implements a counter—-that is, something another module might use to maintain a count 
of the number of times some event or situation occurs. 


( 5 ) 



The following package specification provides other packages the ability to initialize the count 
to 0, to increment the count, and to determine its current value. This is the essence of counting. 

package Counter la 

procedure Set_To_Zero; 
procedure Increment; 

function Current_Value return Integer; 
end Counter; 






13. Consider the following specification of a package for .rrhing an array of integers: 

package Integer_Array_Search Is 0 

subtype Array_Index is Integer range 1..1000; 
type Integer_Array is army (Array_Index) of Integer; 

procedure Search_Array{ 

Array_To_Search: in Integer_Array; 

Nuinlner_Of._Elements : in Array_Index; 0 ® 

Element_To_Search_.For: in Integer; 

Element_Found: out boolean; 

Index_If_Found: out Array_Index 

1 ; 

end IntegGr_Array_Search; 

• 

Use generics to rewrite this package to 1 • more reusable. 

You can make the array's base data type and index generic. Note the name change for the 
second parameter. The old name was based on an ordinal counting system. In the generic 
version, the array’s lower bound might not be 1. 

• 

generic 

type Item is private; 

type Array_Index is range <>; 
package Array__Search is 

type Generic_Array is array {Array_Index) of Item; 

• 

procedure Search_Array( 

Array_To_SGarch: in Generic__Array; 

Last_Eleraent: in Array_Index; 

Element__To_Search_For: in Item; 

Element_Found: out boolean; 

Index_If_Found: out Array_Index ® 

) ; 

end Array_Search; 


- • 

4 


s 





SURVEY FOR 

MEGAPROGRAMMING IN ADA COURSE 


Please answer the following questions. The organization that developed the course material will use 
this information to improve the course. 

1. Do you feel that you understand basic software engineering principles (abstraction, 
information hiding, and reuse) after taking this course? 


2. Do you see value in the.se principles? Why or why not? 


B • 


3. Do you see value in using a programming language such as Ada that helps you express these 
principles? Why or why not? 


4. Would you like to learn more? 


« 


f 





Megaprogramming in Ada Course: Survey 


5. What activity(ies) or example(s) was most helpful to you in undefstanding the basic software 
engineering principles? 


6. Do you have any other suggestions for how the course can be improved? 









Megaprogramming In Ada Course: Survey 


SURVEY FOR 

MEGAPROGRAMMING IN ADA COURSE 
TEACHER ANSWERS 


There are no right or wrong answers on this section. A suggestion for this survey would be to hand it 
to the students after they have completed the test and give them extra credit if they fill it out and hand 
it in the next day. 







Megaprogramming in Ada Course: Survey 


This page intentionally left blank. 



Megaprogramming in Ada Course: 
Laboratory for Unit 3 


ts) 



i*) 






SPC-95013-CMC 

■ 

Version 01.01.04 


November 1995 


Prepared for the 

Department of Defense Ada Joint Program Office 


Froduced by the * 

SOFTWARE PRODUCTIVITY CONSORTIUM 

SPC Building 
2214 Rock Hill Road 
Herndon, Virginia 22070 

» 

Copyright © 1995, Software Productivity Consortium, Herndon, Virginia. This document can be copied and distributed without fee 
in the U.S., or inteniationally. This is made possible under the tenns of the DoD Ada Joint Program Office’s royalty-free, worldwide, 
non-exclusive, irrevocable license for unlimited use of this material. This material is based in part upon work sponsored by the DoD 
Ada Joint Program Office undci Advanced Research Projects Agency Grant #MDA972-92-J-1018. The content docs not necessarily 
reflect the position or the policy of the U.S. Government, and no official endorsement should be inferred. Jlie n.ime Software 
Produ' 1 Mty Consortium shall not be used in advertising or publicity pertaining to this materiai or otherwise without tl le prior written * 

permission of Software Productivity Consortium, Inc. SOFTWARE PRODUCnVTTY CONSORTIUM, INC. MAKES NO REP¬ 
RESENTATIONS OR WARRANTIES ABOUTTHESUITABIUTY OF'THJS MATERIAL FOR ANY PURPOSEOR ABOUT 
ANY OTOER MATTER AND TIES MATERIAL IS PROVIDED WmiOUT EXPRESS OR IMPUED WARRANTY OF 
ANY KIND. 

ft 


• • • • • • • • •• 








PREFACE 


This laboratory and teacher notes are part of the Megaprogramming in Ada Course (SPC-94094-CMC, 
version 01.01.04) produced by the Software Productivity Consortium. The course, which is a short 
course aimed at high school students, consists of four units: software engineering, abstraction, in¬ 
formation hiding, and software reuse. The laboratory described in this write-up should be performed 
at the end of the information hiding unit (Unit 3), preferably after the students have completed Home¬ 
work Assignment 2 of Unit 3. Assignment 2 deals with concepts of the software that students will use 
in the laboratory and, therefore, serves as a good introduction to the laboratory material. 


• • 


4 






Preface 


This page intentionally left blank. 






Mcgaprogramming in Ada Course: Unit 3, Information Hiding, Laboratory 


UNIT 3: INFORMATION HIDING 


LABORATORY 

In this laboratory, you will compile and execute an implementation of the rational number package 
from Homework Assignment 2 in Unit 3. 

The software you will use is in three files; 

• RATNUM. ADA, which contains the package specification for rational numbers. 

• RATNUM_B. ADA, which Contains the package body for rational numbers. 

• READ_SUM. ADA, which contains the procedure Read_Sum_And_Print_Rational_Numbers. 
This procedure uses the rational number package to read, sum, and print two rational 
numbers. 

You must first compile the software. Perform the following steps: 

1. Create a directory called RATNUM on your C drive: 

C;> md ratnum 

2. Change your directory to RATNUM: 

C;> cd ratnum 

3. Copy the software to your current directory. Your teacher will provide you with the location 
of the software. For example, if it is located in S:\ADA\RATNUM, you would execute the 
following command; 

C:\RATNUM> copy s:\ada\ratnum\*.ada 

4. Compile the software. You must first compile the rational number package specification, then 
the rational number package body, then the Read_Sum_And_Print_Rationiil_Numbers 
procedure: 

C:\RATNUM> janus ratnum.ada 
<J:\RATNUM> janus ratnum_b.ada 
C;\RATNUM> janus read_sum.ada 

You must type thi-, .ada file name suffix. 

The Ada compiler will print diagnostic information as it compiles each file. This information, 
not shown here, should indicate that compilation is progressing without errors. If you see any 
error messages, contact your teacher. 

5. Link the software; 

C:\RATNUM> jlink read_suin 





► 




» 




t 


1 


I 





Do not type a file name suffix. 


After you successfully complete these steps, there will be an executable file called READ_SUM.COM 
in your directory. 

You may now execute the software; 

C:\RATNUM> read_sum 

You will be prompted to enter two rational numbers. You will be asked for the first number’s 
numerator, then its denominator, then the second number’s numerator, and finally the second 
number’s denominator. Enter each number as an integer. For instance, the following shows how to 
instruct the program to compute 1/7 + 3/5: 

C: \RATNUM> read_EUn\ 

Enter the numerator for the first number: 1 
Enter the denominator for the first number: 7 
Enter the numerator for the second number• 3 
Enter the denominator for the second numt)' ■ : 5 
The sum is 26/35 

Exercises 

1. Use the software to compute 3/18 - 10/7. 

2. Try using the software to compute 1/1000 + 1000/1. 

a. Why do you think the software fails? (1 lint: Examine the Add function to discover how 
two rational numbers are added.) 

b. The lectures on abstraction and information hiding covered the need to express a 
module’s functional' > package specification. Based on this laboratory, what else 
do you think must be lu u jrackage specification? 






Megaprogramming in Ada Course: Unit 3, Information Hiding. Teacher Notes for Laboratory 


UNIT 3: INFORMATION HIDING 


TEACHER NOTES FOR LABORATORY 

Note-. This course contains a simplified version of a planned software laboratory. A more elaborate 
version may be available at a later date. 

You should have received, along with these instructions, a floppy diskette containing the software 
solving Homework Assignment 2 in Unit 3. This software is almost identical to that shown in the 
Unit 3 Teacher Notes, with the following exceptions: 

• The software on the floppy diskette includes some error-handling code that lets the compiled 
program terminate gracefully under abnormal conditions. 

• The software on the floppy diskette uses a friendlier input paradigm. 

The floppy diskette includes the three files of Ada source code discussed in the laboratory write-up: 
RATNUM.ADA, RATNUM_B. ADA, and READ_SUM.ADA. You must provide each student with a copy of 
these files. If your computers are linked together on a network and have access to a central file server, 
you can place them on that server. Each student can then copy the files directly from that server to 
her or his own computer, as shown in the laboratory write-up. You can also provide each student with 
a floppy diskette containing the source files and ask them to copy the files from that diskette to their 
hard drive. 

Each student must be able to use an Ada compiler. The instructions in the laboratory write-up use the 
Janus/Ada compiler from R&R Software, Inc. See the file READ_ME.TXT on the floppy diskette 
for more information on using this compiler. 

Exercises 

1. Use the software to compute 3/18 - 10/7. 

This simple exercise ensures that students know how to use the program they have just compiled. 
Be sure they enter the input values correctly only integers are accepted. Entering anything else will 
cause the program to stop prematurely. 

2. Try using the software to compute 1/1000 + 1000/1. 

a. Why do you think the software fails? (Hint: Examine the Add function to discover how 
two rational numbers are added.) 

The Add function uses the following formida to add two rational numbers R1 and R2; 

R.Numerator := R1.Numerator * R2.Denominator 
+ R2 .Numerator * R1 .Denominator 
R.Denominator := R1.denominator * R2.denominator; 

Evaluating the first assignment statement using 1/1000 and 1000/1 yields: 




MeKaproKramminK in Ada Course; Unit 3, Infiinrialion Hidins, Teacher Noles for Laboratory 


1X1+ 1000 X 1000 
= 1 + 1000000 

An examination of the representation of a rational number in the package specification 
reveals that Numerator and Denominator are values of type Integer. An Integer value can 
range from —32,768 to 32,767. Since 1,000,000 is greater than 32,767, evaluating the 
expression causes an overflow. The Ada language requires that a compiler generate code 
to detect these conditions. This is an instance of language standardization, discussed in 
Unit 1. 

b. The lectures on abstraction and information hiding covered the need to express a 
module’s functionality in a package specification. Based on this laboratory, what else 
do you think must be in a package specification? 

The package specifications shown include information on the procedures and functions, 
and how to use them. The specifications should also show the ways in which the procedures 
and functions can fail! 




