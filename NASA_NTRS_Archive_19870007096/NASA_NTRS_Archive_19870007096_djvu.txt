3£0 


RSD-TR-12-88 


/ A J - &/ - 


s/ys-Q ^ 

)3V- 



TOWARD REAL-TIME 
PERFORMANCE BENCHMARKS 

FOR ADA 


Russell M. Clapp 
Louis Duchesneau 


Richard A. Volz 


Trevor N. Mudge 
Timothy Schultze 


July 1088 


{NAS A-CR- 180125) TOSAED BE A1-3IME 
iEBFOBEANCE BENCH HARKS I0E fili (tlichigau 
Uciv. } 137 p CSCL 09B 

G3/61 


N87-16529 


Unclas 

43361 


Robot Systems Division 


Center for Research 
on Integrated Manufacturing 


College of Engineering 

The University of Michigan 

Ann Arbor, Michigan 48109 USA 



RSD-TR-1S-80 


TOWARD REAL-TIME 
PERFORMANCE BENCHMARKS 

FOR ADA 1 ’ 2 


(Second Edition) 


Rnssell M. Clapp 
Louis Duchesneau 
Richard A. Volz 
Trevor N. Mudge 
Timothy Schultze 


Department of Electrical Engineering and Computer Science 
The University of Michigan 
Ann Arbor, Michigan 48100 


July 1088 


CENTER FOR RESEARCH ON INTEGRATED MANUFACTURING 

Robot Systems Division 

COLLEGE OF ENGINEERING 
THE UNIVERSITY OF MICHIGAN 


*Ada i> a refiftercd tndcmiik of the Department of Defense. 

*Thii work su partially sponsored by Land System Dreision of General Dynamics and NASA. . 



RSD-TR- 12-88 


TABLE OF CONTENTS 

1. Introduction 1 

2. Review of Ada Time Units 3 

3. Measurement Techniques 4 

3.1 Isolation of Features 4 

3.2 Basic Measurement Accuracy 5 

3.3 Operating System Interference 9 

3.4 Resolution of Measurements 12 

4. Features to be Measured 13 

4.1 Subprogram Overhead 13 

4.2 Dynamic Allocation of Objects 14 

4.3 Exceptions 15 

4.4 Task Elaboration, Activation, and Termination 15 

4.5 Task Synchronization 16 

4.8 Clock Function Overhead 16 

4.7 Arithmetic for types TIME and DURATION 17 

4.8 Scheduling Considerations 17 

4.8.1 Delay and Scheduling Measurements 19 

4.8.1. 1 Minimum Delay Overhead 19 

4.8.1.2 Fixed Interval vs Preemptive Delay Scheduling 20 

4.8. 1.3 Compensation for Minimum Delay Overhead 20 

11 


RSD-TR-12-86 


4.9 Memory Deallocation and Garbage Collection 21 

4.10 Interrupt Response Time 22 

5. Results 23 

5.1 Subprogram Overhead 24 

5.2 Dynamic Allocation of Objects 25 

5.3 Exceptions 26 

5.4 Task Elaboration, Activation, and Termination 26 

5.5 Task Synchronization 26 

5.6 Clock Function Overhead and Resolution 27 

5.7 Arithmetic for types TIME and DURATION 27 

5.8 Delay and Scheduling Measurements 27 

5.9 Storage Deallocation and Garbage Collection :. 28 

6. Summary and Conclusion 28 

7. Acknowledgements 29 

8. References 30 

FIGURES 31 

APPENDIX A 33 

APPENDIX B 37 

APPENDIX C 55 

APPENDIX D 72 


11 ! 


TOWARD REAL-TIME PERFORMANCE BENCHMARKS 

FOR ADA 1 ' 2 


by 

Russell M. Clapp 
Louis Duchesnean 
r Richard A. Volz 

Trevor N. Mudge 
Timothy Schultze 

The Robotics Research Laboratory 
The College of Engineering 
The University of Michigan 
Ann Arbor, Michigan 48109 

Abstract 

This paper addresses the issue of real-time performance measurements for the Ada 
programming language through the use of benchmarks. First, the Ada notion of time is 
examined and a set of basic measurement techniques are developed. Then a set of Ada 
language features believed to be important for real-time performance are presented and 
specific measurement methods discussed. In addition, other important time related 
features which are not explicitly part of the language but are part of the run-time sys- 
tem are also identified and measurement techniques developed. The measurement tech- 
niques are applied to the language and run-time system features and the results are 
presented. 

1. Introduction 

“Ada is the result of a collective effort to design a common language for program- 
ming large scale and real-time systems.” So states the foreword to the Ada Language 
Reference Manual [1]. Examples of real-time systems include the avionic system in an 
airplane, the system that controls and commands a robot, and even the controller for a 
video game. The common denominator among these applications is the need to meet a 
variety of real-time constraints. While Ada was intended for such applications, there is 
nothing in the Language Reference Manual (LRM) which ensures that Ada programs, 
regardless of processor speed, will have the performance to accommodate the real-time 
constraints of particular applications. The Ada Compiler Validation Capability (ACVC) 
suite of programs was established to validate the form and meaning of programs written 
in Ada, but was not intended to specify the size or the speed of their object code, or the 
precise nature of their task scheduling mechanisms, all of which are critical to real-time 
performance. The language contains mechanisms intended for real-time applications but 


*Ada is a registered trademark of the Department of Defense. 

*This work was partially sponsored by Land System Division of General Dynamics and NASA. 


RSD-12-80 


leaves performance issues to supplemental measurement. This paper addresses the issue 
of real-time performance measurement, particularly the issues of time measurement and 
scheduling for which adequate requirements for real-time applications are not explicitly 
stated in the LRM. 

Benchmarks provide a direct way to measure performance. This paper will explore 
the design and use of a set of benchmarks suitable for measuring the real-time perfor- 
mance of the code produced by an Ada compiler. Benchmarking can be approached in 
two ways: 

• develop a composite benchmark, such as the Whetstone or the Dhrystone [2, 3], 
or, 

• develop a set of benchmarks, each measuring the performance of a specific 
feature of the implementation, [4]. 

The former is easier to apply, but no single composite can capture all of the information 
required for even a modest spectrum of real-time applications. Moreover, detailed 
knowledge of the performance of individual features is often required for applications 
planning. In addition, such knowledge will be useful in understanding the relation 
between real-time performance, language constructs, and compiler implementation. 
Therefore, our approach will concentrate on techniques for measuring the performance of 
individual language features. 

The development of benchmarks to measure the performance of individual language 
features involves a number of complex operations, including: 

• isolation of the feature to be measured; 

• achieving measurement accuracy; 

• achieving measurement repeatability; 

• elimination of underlying operating system interference from 

• time slicing, 

• daemons, 

• paging. 

Each of these operations is considered in this paper. In addition to the performance of 
individual language features there are other real-time performance measurements that 
are associated with the run-time system. These include measurements of the scheduling 
and storage management algorithms. 

This paper focuses on features from the language and run-time system believed to 
be important for real-time performance, concentrating not only on the benchmarks, but 
on the basic measurement techniques used. A comprehensive effort to acquire bench- 
mark programs and provide an extensive database of comparative results on all major 
Ada compilers is being conducted under the auspices of the ACM Special Interest Group 
in Ada [ 5]. Most of the benchmark tests presented in this paper were contributed to 
that effort during the summer of 1985. The remainder of the tests, those developed dur- 
ing F all of 1985, were contributed in Winter of 1986. 

The development and interpretation of measurement techniques for real-time pro- 
gramming is based upon the Ada notion of time. Section 2 reviews this notion. Section 
3 presents techniques for achieving basic measurement accuracy, isolating the features to 
be measured, and determining the interference of operating system functions. Section 4 


2 


Benchmarks- Ada 


RSD-12-88 


presents the set of features believed to be important for real-time performance, discusses 
why they are considered to be important, and describes the measurements to be made 
by the benchmark. Particular focus is given to scheduling operations and time measure- 
ments. Section 5 then presents the results of the benchmark tests for several compilers: 
Verdix Versions 4.06, 5.1 and 5.2, running with Unix 4.2 bsd on a VAX 11/780, DEC 
VAX Ada Version 1.1 running with Micro VMS 4.1 on a Microvax II, DEC VAX Ada 
Version 1.3 running with VMS 4.4 on a VAX 11/780, and Alsys Version 1.0 running with 
Aegis Version 9.2 on an Apollo DN 660. It should be noted that these versions of the 
compilers are intended for time-shared use, not for real-time applications. Therefore the 
results should not be interpreted with real-time performance in mind. At the time of 
this writing, however, these were the principal Ada compilers available to the authors 
and the results do help illustrate the methods presented. The parameters obtained also 
give an indication of the areas in which users should look for improvements in cross- 
compilers intended for real-time applications. 

2. Review of Ads Time Units 

The Ada LRM defines several entities that relate to time, its representation within 
Ada programs, and the execution of Ada programs. These include: 

(1) The data type TIME, objects of which type are used to hold an internal representar 
tion of an absolute point in time. 

(2) The data type DURATION, objects of which type are used to hold values for inter- 
vals of time. 

(3) A predefined package, CALENDAR, which provides functions to perform arith- 
metic on objects of type TIME or DURATION. 

(4) A predefined function, CLOCK, which returns a value of type TIME corresponding 
to the current time. 

(5) DURATION’SMALL, which gives an indication of the smallest interval of time 
which can be represented in a program. It is required to be less than or equal to 20 
milliseconds, with a recommendation that it be as small as 50 microseconds. 

(6) The value SYSTEM.TICK, which is defined as the basic system unit of time. 

(7) The operation delay which allows a task to suspend itself for a period of time. 

The semantics associated with the first three of these entities are clear. Those of the last 
four warrant some discussion. 

Values of type DURATION are fixed point numbers, and thus are integer multiples 
of the constant DURATION’SMALL. DURATION objects are only data representations 
of time. They do not imply in any way actual performance of a system for time meas- 
urements or scheduling. There is no required relation between the clock resolution time 
and DURATION’SMALL. For example on the Verdix and Telesoft compilers for a VAX 
Unix system, DURATION’SMALL is 61 microseconds, while the timer resolutions are 10 
milliseconds and 1 second respectively. 

The CLOCK function generally presumes an underlying clock or timer which is 
periodically updated at some rate undefined by the LRM. We call this period the reso- 
lution time of the system. CLOCK simply returns the value of time associated with the 
current value of the underlying timer. If the execution time of CLOCK is less than the 
time resolution, successive evaluations of CLOCK may return the same value. 


Benchmarks-Ada 


3 



RSD-12-80 


The term “basic system unit of time” is not very specific. One might think that it 
means the basic CPU clock cycle. However, the constant SYSTEM.TICK is used by 
several compiler vendors to hold the value of the resolution of time measurements avail- 
able from the CLOCK function. 

In addition to the above, an implementation may have other important time 
related parameters which are not identified in the LRM. For example, some validated 
Ada implementations frequently insert sizable delays in conjunction with the delay 
statement which are neither directly specified by the programmer, nor caused by system 
load, but are present simply for convenience in the implementation of the complier and 
run-time system. Parameters in this category will be identified in the discussion that 
follows and techniques for measuring them will be presented. 

3. Measurement Techniques 

There are two basic techniques for measuring the time to perform an operation. 
The first is to isolate the operation and make time measurements before and after per- 
forming it. For this to be adequate, the time resolution of an individual measurement 
must be considerably less than the time required by the operation to be measured. 
Unfortunately, this is typically not the case and an alternative method must be used. 
The second technique, and the one used here, is to execute the operation a large number 
of times, taking time readings only at the beginning and the end, and obtaining the 
desired time by averaging. 

While this sounds simple and straightforward, there are a number of complications 
which must be handled carefully if the results obtained are to be meaningful: 

• isolation of the feature to be measured and avoidance of compiler optimizations 
which would invalidate the measurement; 

• obtaining sufficient accuracy in the measurement; 

• avoidance of operating system distortions; 

• obtaining repeatable results. 

These issues are dealt with in the subsections below. 

3.1. Isolation of Features 

The basic technique for isolating a specific feature to be measured from other 
features of the language is to use two execution frames, a control loop and a test loop 
which differ only by the feature whose execution time is to be measured. Thus, a differ- 
ence of execution times between the control loop and the test loop theoretically yields 
the time of the function being measured. Code optimization, however, can distort 
benchmark results by removing code from test loops, eliminating procedure calls or per- 
forming folding. The benchmark programs, therefore, must utilize techniques to thwart 
code optimizers. 

The key to avoiding these problems is to not let the compiler see constants or 
expressions in the loops whose times are being measured. For example, instead of using 
a for loop with a constant iteration limit, a while loop is used with the termination 
condition being the equality of the index variable to an iteration variable. The index 
variable is incremented by a procedure, the body of which is defined in the body of a 
separate package. The iteration variables are declared and initialized in the specifica- 
tion of a library package. Since the iteration values are kept in variables (not 


4 


Benchmarks- Ada 


RSD-12-88 


constants), and the body of the increment procedure is hidden in the body of the pack- 
age, there is no way the benchmark loops can be removed by optimization as long as the 
package specification and body are compiled separately with the body being compiled 
after the benchmarking unit. 

Similarly, the compiler must be prevented from removing the execution of the 
feature being tested from the loop or eliminating the loop entirely from the control loop 
which does not contain the feature. To ensure that these problems do not happen, con- 
trol functions are inserted into both loops and the feature being measured is placed in a 
subprogram called from a library unit [6]. Again, if the bodies of these subprograms are 
compiled separately, and after the benchmark itself, there is no way for a compiler to 
determine enough information to perform optimization and remove anything from either 
the control or test loops. These techniques will be evident in the benchmarks described 
below. 

The loops must each be executed N times, as discussed in the next section, to pro- 
duce the desired accuracy. The form of the test loop is 


Tl CLOCK; 
while I < N loop 
control functions; 

D 0_SEP AR ATE_PRO C_F ; — the function F whose time is being measured 
INCREMENT^); (LI) 

end loop; 

T2 CLOCK; 

T m T2-T1; 

The control functions and subprogram call to increment I are included to thwart code 
optimizers. The control frame would be identical to this except that a separately com- 
piled function DO_SEPARATE_PROC_NULL would replace 

DO_SEPARATE_PROC_F . 


3.2. Basic Measurement Accuracy 

Knowledge of both the resolution of a time measurement and the variability of the 
time needed to make a time measurement are required to determine the number of itera- 
tions needed to obtain a parameter measurement within a given tolerance. Let r be the 
basic time resolution unit in terms of which all time measurements are made. Then, the 
value returned by the CLOCK function at time t is 


L 


t +r t ±r, 

T 



( 1 ) 


where [zj is the “floor” function (the largest integer less than or equal to z ), r e is the 
nominal time required to perform the CLOCK function, and r, is a variable indicating a 
(hopefully) small random variation in the time required to perform the CLOCK function. 
Since a difference of CLOCK measurements will be used, r e will subtract out of the 
equations to be developed and can be ignored. It is assumed in all of the equations that 
follow that r, is small in comparison to r and can also be ignored. In any application, 
however, this assumption must be verified. One of the tests described in the Sec. 4 can 
be used for this verification. 


Benchmarks- Ada 


5 



RSD-12-86 


If the time required to execute the loop excluding F is T 0 , and the time required to 
perform function F is Tp, i.e., Tp is the time we are trying to ascertain, then the differ- 
ence between the values returned by the two calls to the CLOCK function above will be 

T m -IV «(r 0 + Tp)±S T, (2) 

where 


0 < 8 < 1 . 


Then Tp is given by 


T P 



-T 0 ± 


6 • r 
N 


Thus, the accuracy of the measurement is determined by 


— r <- r 
N N 


( 3 ) 

( 4 ) 


Once the time resolution unit, r, is determined, the number of iterations can be chosen 
to provide the accuracy desired. However, one must be aware of cumulative error 
buildup, and if T 0 is obtained by a similar type of measurement, one must increase N 
for both measurements. 


In order to measure r, a call to the CLOCK function is placed in a loop which is 
executed a large number of times. Each value of time obtained is placed in an array. 
We will now show that the second difference of the values obtained will evaluate either 
to zero or to the time resolution unit. 


Let the time to complete one execution of the loop be 

Tioop (1) “ » ‘ r + 6 ' r where n is an integer and 0 < 8 < 1 . (5) 


Without loss of generality consider that the first execution of the loop begins at time 
zero. Then the time at the end of the k th iteration will be 

Tioop {k) = k- n- r+k 6r (6) 

and the measured time will be 

T m (k) — k • n • t+ 1* • 6\ • t (7) 


since the times returned are a multiple of the CLOCK resolution, r. The first difference 
of the measured times can be written, 

AT m (k)=T m {k +1)-T m {k) = n • r+ {[.(* + lWJ - |* *]} -r . (8) 

We note that since k is an integer and 8 lies in [0,1) we have, 

[(A: + 1) • - \_k • 8\ — 0 or 1 (9) 


In the second difference of the times measured by the CLOCK function the n • r in (8) 
will subtract out to yield, 

//(*,*) = AT m (A)-Ar m (*-l) = {L(ifc+lMJ - 2 -|* • 8 \ +L(*-1)-*J} - ^10) 

Now, if H(8, k ) is plotted as a continuous function of k with 6 as some fixed constant in 
the interval [0,1), the periodic waveform of Fig. 1 is obtained with 1/ 6 as the period. 


0 


Benchmarks- Ada 



RSD-12-88 


The value x in Fig. 1 is the interval of A for each period where H(S, A ) is equal to r or 
-r. The function is equal to zero when it is not r or -r, so for each period, this interval 
of A is y = 1/ £ - 2 • * . The value of y for H (£, A ) is dependent on the value of £. 
To determine y consider the three floor function terms that comprise H (£, k ). Observe 
that, because of the coefficient of -2 on the second term, the function is equal to zero 
only when all three terms evaluate to the same value or three consecutive integers. This 
implies that H(S, k ) is equal to r or -r only when two of the terms are equal and the 
third term is one greater or one less. Rewriting the three terms in H(8, k) as follows: 

|A •* + *!, L* • , [A • £ - £J , (10.1) 

it is easy to see that for all three terms to be equal, it is necessary that £ < 1/2. Also, 
it can be observed that for all three terms to have different values it is necessary that 
£ > 1/2. If £ =* 1/ 2, neither case applies, and two of the three terms are always equal. 
Therefore, there are three cases to consider when determining the value of y . The sim- 
ple case is when £ = 1/2. Since H(S, k ) is never equal to zero in this case, 
y — 1/ 5 - 2 * a =®0, implying that x =■ 1/ 2 % 6 = 1. 

The second case to consider is when $ < 1/2. To find the interval of k for which 
all three terms in (10.1) are equal, let k • £ - 6 equal some integer m . Then, since 
6 < 1/ 2, (A; • £ + £J = m and [A: • £J = m . To find y let (A: + y ) • £ + £ —m + 1 

i.e. the point where the function steps up by r. When this is true, 

L(A + y ) * £ - £J = m and [(A + y ) ♦ #J = m and H(8, k ) is no longer equal to zero. 
So, 

(A: + y)*A + 5=*m +1 
(A - A- lJ+y +1-2-1 

i.e. , m + y - 6 — m +1-2-6 
y =1/6-2 

and then y 1/ £ - 2 • * = 1/6-2 implying that x —l. 

A similar analysis is performed for the third case when 6 > 1/2. In this case 
H(6, k) is zero when the terms of (10.1) evaluate to three consecutive integers. Let 
k ■ b + 6 — m so that |A • £J = m - 1 and [k • 6 - 6\ — m - 2. Again, let 

y = 1/ 6 - 2 • * and then let (A; + y ) * 6 - 6 = m - 1. When this is true, 

L(A + y) • £J — m - 1 and |_(A: + y) * 6 + £J = m and the function is no longer equal 
to zero. So 


(k + y ) • 6 - 6 — m -1 

(10.0) 

• (A •£ + £)+ y • 6 — tn —1+2 • £ 

(10.7) 

i.e. , m+y-£ = m- l + 2- £ 

(10.8) 

• 

• 

• 

II 

1 

(10.9) 


and then y — l/£-2*ar=»2-l/£ implying that x — 1/ 6 - 1. This completes the 
analysis of H(6, k ) when A is a continuous variable. However, the function in (10) is 
not continuous, but discrete for integer values of k . The second difference then, is a 
sampling of the waveform in Fig. 1. This sampling yields one of the following sequences, 


( 10 . 2 ) 

(10.3) 

(10.4) 

(10.5) 


Benchmarks-Ada 


7 



RSD-12-86 


0, r, r, 0, 0, r, r, 0, 0, r, — r, 0, 


when 6 < 1/ 2, or 


(11a) 


•••) t , t , 0, ..., 0, r, r, 0, ..., 0, r, r, 0, ... 


(lib) 


when 6 > 1/2. When 6 = 1/2, there are no zeros in the sequence. Also the number of 
zeros between any two (r, -r) pairs can vary by 1 . 

To see how the sequences of (11) are obtained, consider the period of the waveform 
in Fig. 1 and the values of * and y. Since 6 < 1, the period of the waveform, 1 / 6, is 
greater than 1. In the case where 6 < 1/ 2, at =1 and it is easy to see how sampling 
the waveform for integer values of k produces the sequence of ( 11 a). 

To demonstrate that the sequence of (lib) is obtained when 6 > 1/2, it will be 
shown that a sample value of 0 can never follow a sample value of -r. Also, it is not 
possible to sample two consecutive, values of -r or two of r . 

Consider the values associated with the waveform in Fig. 1 as discussed above. 
Since, 1 / 2 < 6 < 1 , the period is bounded by 1 < 1 / 6 < 2. The value of * is 
1/6-1, and y is 2 - 1/ 6. Recall that y is the length of the period where the function 
is zero. Also, note that x + y =*1. This ensures that, if a value of r is sampled at 
some point on the curve, the next point where the curve is equal to r is a distance 
greater than x + y away or a distance less than * away. Since x < 1 , x + y = 1 , 
and the curve is sampled at integer points, a sample of r may not immediately follow a 
sample of r. The same is true for samples of -r. Similar reasoning also shows that a 
sample of 0 may not follow a sample of -r. Because the sample interval is 1 and 
x + y = 1, a sample of -r is always followed by a sample of r. However, a sample of 0 
or -r may follow a sample of r depending on the relative values of * and y . 

The approximate number of zeros between the (r, -r) pairs in (11) can also be 
determined. In the case where 6< 1/2, the number of zeros is 


L 0 = 1/6-2 . ( 12 a) 

This follows because 1/ 6 > 2 and L 0 is the number of samples in one period, less the 
two samples for r and -r. 

For the 6 > 1 / 2 case, we show that H(6, k) = -H( 1 - 6, k). First note that if j 
is an integer and e > 0, |_ j - ej = j — 1 — |_ e J . Now let 7 = 1 -6 implying that 
6 = 1 - 7 . For the 6 > 1/2 case then, 7 < 1/ 2. Substituting for 6 in each of the three 
terms in ( 10 . 1 ) yields 


«+i — 1 L(* + 1 ) • — L(* + 1) '(1 -7)J 

= l(* +l)-(* + 1 ) • 7 J 
= k + 1 - 1 -L(* +l)’7j 


( 12 . 1 ) 

( 12 . 2 ) 

(12.3) 


«0 = L* * — L * * (1 — y) J 

— L* -* *7j 

= k - 1 - L* • 7 J 


(12.4) 

(12.5) 

( 12 . 6 ) 


8 


Benchmarks- Ad a 



RSD-12-80 


(12.7) 

( 12 . 8 ) 
(12.9) 


«-i — L(* - !) "rj — L(* -i) (i - tt) J 
“ L(* - 1) - (* - 1) • TfJ 


-1-1-K* +l)-7j . 

Combining (12.3), (12.6) and (12.9) we get 
H(S, k ) — a +1 - 2 a 0 + a_! (12.10) 

— k - L(* + 1) ' 7j ~ 2 • k + 2 + 2 * Ik • qj + k-2- l(* - 1) • qj (12.11) 

= - L (k + 1 ) • q J + 2 |. * • q J - L (* - 1 ) • 1 J (12.12) 

= -H{l-6,k) . (12.13) 

Thus, from (12a), the number of zeros in this case is simply 

'i.-jr*-* • ( 12b > 


The above result also explains why the sequence of (11a) is the negative of the sequence 
of (lib). 

L 0 , then, can be controlled empirically by adding instructions to the loop calling 
the CLOCK function. This procedure adjusts the value of 6. 

We note that if n in the above equations is zero, then a first difference measure* 
ment will suffice, yielding a string of zeros with r appearing occasionally. The only pur- 
pose of taking the second difference was to eliminate n . 

This second differencing procedure gives a reliable technique for measuring the reso- 
lution time of the CLOCK function. As will be seen below, this technique is also useful 
for measuring a number of other parameters associated with the real-time performance 
of a system. 


3.3. Operating System Interference 

The isolation of the feature to be measured from other language features and code 
optimization is not the only isolation which must be achieved. The timing of the feature 
to be measured must also be isolated from times of other user processes or of the operat- 
ing system itself. Since the CLOCK function measures absolute time, any other 
processes executing during the test, e.g., in a time shared mode, would contribute to the 
measured time and thus distort the results. Some operating systems, e.g., Unix, provide 
a timing function which nominally measures only the time of the processes being tested, 
excluding the times of the operating systems or other user processes. Not all operating 
systems can be expected to have this function, however, and even for those that do, 
there is a question of how precisely this calculation is made. Therefore, benchmark tests 
should be run on a system with no other user processes in concurrent execution and with 
all daemon processes disabled. A consequence of this requirement is that no output 
should be generated by a benchmark until all timing is completed because a request for 
output could create an independent process that runs concurrently with the benchmark. 

Even with this disabling of daemon processes and running on a single user system, 
there are still timing anomalies to be detected and measured, most notably time sharing 
activities of the operating system. The operating system can still be expected to inter- 
rupt the benchmark periodically, check the queue for other processes waiting to run, and 
return control to the benchmark process. Also, for sufficiently high use of memory, 


Benchmarks-Ada 


9 


RSD-12-80 


operating system paging functions may be invoked. However, except for memory 
allocation/deallocation tests, benchmarks can usually be designed to use less memory 
than the size which will cause paging activity. The frequency and duration of these 
operating system actions must be determined and taken into account in the timing cal- 
culations. 

We begin by analyzing the effect of a function F ot which periodically intrudes on 
the operation of the benchmark. Let the function F ot require a constant T 0 , seconds 
and occur with period T p . Make the following definitions: 

T t — actual time required to execute the control loop N times, 

T c j =* actual time required to execute the control loop and F , N 
times, 

n e = number of times F ot is executed during T e , 
n t j — number of times F 0 , is executed during T e f , 

T e M = measured time for T t , 

T e ” = measured time for T c j , 

It then follows that 


T e = AT-r 0 + n e -r M (13) 

T e f = N- (T 0 + T P ) + n cf T 0 , (14) 

Since the measured times must be multiples of the time resolution r, we have 


T m ^ T ' + s e - t 
T e m f - T cf +6 e/ -r 

where -l<S e ,S e f <1. Then, letting the calculated time difference be Tj 
it is straightforward to obtain 

Tf ~~N TT* T - ~ (Kl ' K) ~N 

Next, we observe that n e and n e j must be integers and hence that 

r ‘ -U 

+ f c 
1 P 

n cf =-jr + <«/ 

x p 

for some -l<e e ,( e j <1. And then 

»cf -» t ”y ' [n ‘Tp + {n e f - n e ) • T„ j + e c/ - e e 


(15) 

(16) 

_ m v • 


(17) 


(18) 

(19) 

(19.1) 


10 


Benchmarks- Ada 



RSD-12-88 


T 0I 

Let 0 = — ” , and simplify to get 

T p 


N • 7> . 

n cf “ ~ + ( n e/ - n e ) • 0 + t ef - t t . 


Solving for n e t - n e yields 


(" c/ " ” e * " T, • (1 - /?) + 1 - 0 ' (fe/ € * * • 


' ( f e/ e e ) x r 

T, ( 1-0) N ■( 1-0) ' 1 e/ ~ ° e ~N 


Combine with (17) to get 

Tp ~ ^ ‘ Tf 
which can be simplified to 

( 1 . 0 I • T art _ T - * (**/ ~ ) _ / c r \ r 

l 1 + 1 - 0 ) T? N N (1-0) ( $ef ~ 6e ) ’ N ’ 

S 1 

Since 1 + = - — - , multiply both sides by 1 - 0 to get 

1-01-0 

T p-^j (I-« + 2 < -^ + 2 • * • (1 - y») • -T 

for some -1 <8, €<1 where 


(19.2) 

(19.3) 

(19.4) 

(19.5) 

( 20 ) 


0 ~ 



<1 


The two right most terms in (20) can be made arbitrary small by choosing N sufficiently 
large. The effect of 0 shows that the results previously obtained in (3) are pessimistic 
and that a correction can be applied if T p and T ot can be determined. 

Estimates of T p and T 0 , can be obtained by the same second differencing tech- 
nique described above for obtaining the resolution time of the CLOCK function. 
Assume, for the moment, that T ot satisfies the relation T ot » r, and that T p — m • r 
for m »1, and that 6 in (5) is zero. The latter assumption means that the contribu- 
tion to the second difference from the resolution time, r, itself is also zero, and the fol- 
lowing analysis will reflect only the effects of T g , . From a filtering point of view, the 
time measurements are simply a staircase input to the simple second difference filter. 
The output string, then, is just 


..., 0, T ot , — T ot , 0, ...» 0, T ol , T ol , 0, 


( 21 ) 


This directly yields T 0 , , and periodicity of the sequence gives the frequency of the opera- 
tion, T p . 

If 6 0, then the above sequence will have the sequence of (11) superimposed upon 

it, which may occasionally distort the value of T ol by ± r. Further, if T 0 , is not an 
integral multiple of r, the values in the sequence will only be within r of T g ,. If 
T 0I » r, reasonable estimates of the parameters should still be obtainable. Theoreti- 
cally, it is possible to derive the precise value of T 0I based upon the number periods in 


Benchmarks-Ad& 


11 


RSD-12-83 


(21) between fluctuations of size r in the values. In practice this will be difficult to 
detect because of the length of sequence required and the distortion from the (r ,-r) 
occurrence as in (11). 

If T 0I < r, it is again theoretically possible to obtain the measurements, but a bit 
more difficult in practice. In this case, we begin by examining the sequence of (11) and 
determining the length of the string of 0’s between every (r ,-r) pair. If T e = 0, then 
this length may not vary by more than 1. Any deviation by more than 1 indicates an 
occurrence of F 0$ . For T 0 , < r, this will be reflected by a shortening of the length of 
the string of zeros. The amount by which the string is shortened is a measure of T 0 , 
(measured in multiples of the loop time), and the period with which this is repeated indi- 
cates T p . 

Minor extensions of this technique allow multiple periodic operating system func- 
tions of differing service times to be detected and evaluated. However, it is generally 
very difficult to fit the execution time and period of more than a single function to the 
sequence of (11). Nevertheless, by accumulating the shortening of the strings of zeros 
and dividing by total time, it is typically possible to get an overall estimate of the 
operating system overhead involved. 

Actual tests with this approach revealed another difficulty. Some implementations 
of the CLOCK function involve the dynamic allocation of records, which in turn may 
involve the invocation of a run-time system function. As will be discussed in Sec. 5.2, 
the time required to perform this operation can vary quite widely. This variation in 
storage allocation time will give the appearance of operating system overhead. To avoid 
these problems, the Ada CLOCK function should not be used for tests to determine the 
operating system overhead. Instead, an implementation dependent subprogram is 
required which can read the system timer without invoking any variable time system 
functions such as storage allocation. Such a system dependent subprogram was written 
and used in our tests. It should be noted, however, that for all of the other tests to be 
described, the CLOCK function is evaluated only at the beginning and the end of a loop 
iterated a large number of times, and the effect of the dynamic storage allocation is 
effectively eliminated, as shown in (20). Thus, except for determining the operating sys- 
tem overhead, the Ada CLOCK function may be safely used. 

3.4. Resolution of Measurements 

The result of (20) was based upon a periodically occurring function which always 
took the same time to execute. In practice this assumption may not be entirely true. 
Repeated executions of the benchmark can provide both a test of the validity of the 
assumptions and improve the accuracy of the results obtained. 

The distribution of the estimates can be observed by running a repeated set of tri- 
als. One can then average the results obtained from each trial. The variance of the 
resultant estimate is reduced by TVj if trials of the benchmark are made. 

An alternative strategy is to use the minimum of the values obtained. However, in 
this case, one must be careful to determine the minimum of T e j and T e separately and 
use these values in the computation of Tj . Otherwise, one is likely to use a larger than 
average value of T e in combination with a smaller than average value of T t j and pro- 
duce a result which is distorted on the side of being too small. 


12 


Benchmarks- Ada 


RSD-12-80 


4. Features to be Measured 

This section of the paper describes features which are relevant to real-time execu- 
tion and whose performance should be measured. A motivation is given for each test as 
well as a precise statement of what is being measured. Where the measurement requires 
techniques beyond those described in Sec. 3, specific details are given. 

The specific features discussed are: 

• subprogram calls; 

• object allocation; 

• exceptions; 

• task elaboration, activation, and termination; 

• task synchronization; 

• CLOCK evaluation; 

• TIME and DURATION evaluations; 

• DELAY function and scheduling; 

• object deallocation and garbage collection; 

• interrupt response time. 

All but the last three are clearly measurements of features specified in the LRM. 

In the areas of tasking, timing and storage management, the compiler implementors 
have been given a great deal of implementation latitude. Consequently, it is difficult to 
develop a priori a set of benchmarks which completely characterize these areas since the 
range of implementation techniques which may be used is open ended. Knowledge of the 
type of disciplines implemented is important before it can be determined what parame- 
ters it is relevant to measure. Thus, measurement techniques in these areas are oriented 
toward determining the general nature of the implementation techniques used. 

4.1. Subprogram Overhead 

With today’s software systems running into sizes that exceed one million lines, 
modular programming is a necessity. Such a programming style, however, leads to an 
increase in procedure and function calls. In a recent study, Zeigler and Weicker found 
that 26.8% of a typical Ada program as implemented in the iMAX 432 system was sub- 
program calls [7]. Shimasaki, et al., obtained a range of 26.5% to 41.4% for typical 
Pascal systems [8]. The overhead associated with a subprogram call and return should 
not deter software producers from using a structured programming style. A possible 
way to avoid the cost of this increased overhead is to have the compiler generate an in- 
line expansion of the code of the subprogram where the call to it occurs. There is a 
trade-off here, however, in that as the call/return overhead is eliminated, the size of the 
object module is increased. Ada provides for a method of in-line expansion with the 
INLINE pragma, but a compiler is not required to implement this or any other 
pragma. By measuring both subprogram overhead and the time needed (if any) to exe- 
cute code generated by an in-line expansion, one can determine whether or not the 
language/computer will encourage real-time systems programmers to use good program- 
ming techniques. 

Several tests were designed to provide insight to different aspects of subprogram 
calls. The first test measures the raw overhead involved in entering and exiting a 


Benchmarks-Ada 


13 


RSD-12-80 


subprogram with no parameters. Next various numbers of INTEGER and ENUMERA- 
TION parameters are passed to determine the overhead associated with simple parame- 
ter passing. Composite objects may be passed either by copy or reference. Another test 
will determine which method is used because, if the parameters are passed by reference, 
the time required will be independent of the number of components of the object. The 
final case involving parameters is the one in which the formal parameters of the subpro- 
gram are of an unconstrained composite type. The test in this case is designed to meas- 
ure the additional overhead present in passing constraint information along with the 
parameter itself. All of the tests include passing the parameters in the modes in, out, 
and in out. 

All of the tests involve two different types of subprogram calls, one to a subpro- 
gram that is a part of the same package as the caller, and the other to a subprogram in 
a package other than the one in which the caller resides. These two sets of tests deter- 
mine if there is any difference overhead between intra- and inter-package calls. In the 
case of intrarpackage calls, all of the tests are repeated with the addition of the INLINE 
pragma to determine if the INLINE pragma is supported and, if it is, the amount of 
overhead involved in executing code generated by an in-line expansion as opposed to exe- 
cuting the same set of statements originally coded without a subprogram call. 

The final aspect of the tests involves the use of package instantiations of generic 
code. All of the tests for both inter-package and intra-package calls are repeated with 
the subprograms being part of a generic unit. This test is designed to determine the 
additional overhead involved in executing generic instantiations of the code. 

4.2. Dynamic Allocation of Objects 

Writing software without distinct bounds on the size of arrays and records, or the 
number of tasks or variables offers the advantage of portability and ease of support for 
the software as the application changes. Moreover, the ability to dynamically allocate 
objects is important to the development of some algorithms. However, in the case of 
embedded real-time systems, the time required to dynamically allocate storage may 
make it an undesirable feature. In order to determine if dynamic allocation of objects is 
feasible in a real-time application, the associated overhead must be measured. 

Three types of allocation are considered. The first case is that of allocating a fixed 
amount of storage by either entering a subprogram or a declare block with the objects 
declared locally. Although the amount of storage needed is known at compile time, it is 
allocated at run time. The second case is the allocation of a variable amount of storage 
not known at compile time by entering either a subprogram or declare block. An exam- 
ple of such an object would be an array with variable bounds. The third case of 
dynamic allocation is that done explicitly with the new allocator. This allocator can be 
used to allocate a single object of a particular type. 

The tests presented measure the overhead associated with each type of dynamic 
allocation. In the case of fixed length allocation, the times to allocate various numbers 
of objects of types INTEGER and ENUMERATION are measured as well as the times 
to allocate various sizes of arrays, records, and STRINGS. The objective is to determine 
the allocation overhead involved, and if there is any difference in the overhead based on 
the type of object allocated. In the variable length case, arrays of various dimensions 
bounded by variables are allocated. This test is designed to determine if allocation time 
is dependent on size of the object. In particular, it is expected that many compilers will 


14 


Benchmarks- Ad a 



RSD-12-86 


allocate small objects on the stack assigned to the task, and larger objects off the heap 
(-which will typically take a much longer time). Finally, in the case of the new alloca- 
tor, allocation time of objects of type INTEGER and ENUMERATION as well as com- 
posite type objects of various sizes are measured. This test will again show if allocation 
time is dependent on size (in the composite type object case). Also, these measurements 
will give an idea as to the relative efficiency of this method of allocation as opposed to 
the fixed length case. 

4.3. Exceptions 

Embedded real-time systems require extensive error-handing and recovery so that 
errors may be isolated and reported without bringing the whole system down. Also, 
modular programming encourages the abstraction of abnormal error reporting. Since 
many real-time systems must function in the absence of human intervention (space 
ships, satellites, etc.), the ability- to provide extensive exception handling is of great 
importance. In order for these real-time systems to operate properly, efficient exception 
handling must be available. 

Four types of exception handling routines are interesting since they represent dif- 
ferent ways in which exceptions are raised: NUMERIC_ERROR, 

CONSTRAINT_ERROR, TASKINGJERROR, and user-defined exceptions. The 
NUMERIC_ERROR exception is first discovered by the hardware and the exception is 
propagated back to the run-time system by an interrupt signal from the hardware. The 
CONSTRAINT_ERROR is raised by the Ada run-time system. The 
TASKING_ERROR is raised during task elaboration, task activation, or certain condi- 
tions of conditional entry calls. And, the user-defined exception is raised by the pro- 
grammer. Except for the user-defined exception, the method of raising the exceptions 
can be done both by forcing the relevant abnormal state in the code and by using the 
raise statement. 

In order to gauge the efficiency of exception handling, measurements of time to 
both respond to and propagate exceptions must be examined. The response time for an 
exception is the time between the raising of the exception and the start of the execution 
of the exception handler. When an exception is raised in a unit and no handler is 
present, the exception is propagated by raising the exception at the point where the unit 
was invoked. The time between raising an exception in a unit and its subsequent raising 
at the point where the unit was invoked is the time necessary to propagate the excep- 
tion. In the tests presented here, both of these times are determined for three of the 
four types of exceptions mentioned above. Where applicable, the exceptions in the tests 
are raised both by the raise statement and by forcing the abnormal state to occur in the 
code. 


4.4. Task Elaboration, Activation, and Termination 

The tasking function provides the heart, of the real-time power and usefulness of 
Ada. Many algorithms, such as buffering algorithms, involve the creation and execution 
of tasks, e.g., the reader-writer scheme described in Barnes [9]. Nevertheless, task ela- 
boration, activation and termination are almost always suspect operations in real-time 
programming and programmers often allocate tasks statically to avoid run-time execu- 
tion time. It is, therefore, of special interest to explore the efficiencies of task elabora- 
tion and activation. 


Benchmarks-Ada 


15 



RSD-12-80 


The time measured in this test is the time to elaborate a task’s specification, 
activate the task, and terminate the task. This composite value gives an indication of 
the overhead involved in the use of the tasking function. Of course, individual values 
for each component of this metric would provide more detailed information about the 
efficiency of tasking overhead. However, the coarse resolution of the CLOCK function 
currently available prevented measurement of the individual values, due to the large 
number of iterations needed to get a precise measurement. Iterating through a loop a 
large number of times where tasks are created without being terminated causes the run- 
time system to thrash and prevents an accurate measurement. When higher resolution 
clocks are available, the source code of the test can easily be changed to time each indi- 
vidual part of the metric. 

Some additional information can be determined about the time for task activation, 
however. The test for measuring the composite of elaboration, activation, and termina- 
tion is run for the two possible cases of task activation: 1) entering the non-declarative 
part of a parent block and 2) by using the new allocator. The first case can be further 
divided into two categories. The task to be activated can either be declared directly in 
the declarative part of a block, or it can be an object declared to be of a task type. In 
the case of task activation using the new allocator, an access type object is allocated 
that is a pointer to an object of a task type. The difference in the times provided by 
these three tests gives some insight into the relative efficiency of the two types of task 
activation. 

4.5. Task Synchronisation 

Important in multi-tasking is the ability of tasks to synchronize. In Ada, synchron- 
ization is supported in the rendezvous mechanism. This mechanism allows tasks to pass 
information to one another at key points during their execution. To start, the rendez- 
vous involves at least two context switches: one to the run-time system and then 
another to the acceptor if it is ready to accept the rendezvous. The run-time system 
must check if the acceptor is indeed ready to receive the rendezvous and this adds to 
the overhead associated with the context switches. If the overhead associated with a 
rendezvous is too great, then the efficiency of execution in a multi-tasking environment 
will suffer. 

The synchronization test measures the time to complete a rendezvous between a 
task and a procedure with no additional load present. This method, then, gives a lower 
bound on rendezvous time because no extraneous units of execution are competing for 
the CPU. This test is also repeated for rendezvous where various numbers, types and 
modes of parameters are passed. 

4.0. Clock Function Overhead 

In a real-time application, the CLOCK function provided in the CALENDAR pack- 
age may be used extensively. The overhead associated with calling the CLOCK function 
can be an important contribution to the speed limit with which timed loops can be 
coded. The benchmark test measures the overhead associated with a call to and a 
return from the CLOCK function provided in the package CALENDAR. The method 
used is essentially the same as the one used to measure the overhead associated with a 
entry and exit of a do-nothing subprogram in a separate package. 


10 


Benchmarks- Ada 



RSD-12-88 


4.7. Arithmetic for types TIME and DURATION 

Dynamic computation of values of types TIME and DURATION is frequently a 
necessary component of real-time applications. An example of such a computation is the 
difference between a call to the CLOCK function and a calculated TIME value which is 
often used as the value in a delay statement. If the overhead involved in this computa- 
tion is significant, the actual delay experienced will be somewhat longer than antici- 
pated. This could be critical in the case of small delays. 

The objective of the test in this case is to measure the overhead associated with a 
call to and return from the “+” and functions provided in the package CALEN- 
DAR. Times are measured for computations involving just variables and both constants 
and variables. Although both '*+’* functions are essentially the same (only the order of 
parameters reversed), both are tested. This is done because a discrepancy in the time 
needed to complete the computation will occur if one of the functions is implemented as 
a call to the other. 

4.8. Scheduling Considerations 

Two requirements of many real-time programs are the need to schedule tasks to 
execute at particular points in time and the need to allow execution to switch among 
tasks. Ada provides the delay statement to allow programmers a mechanism for han- 
dling the former. The latter can be achieved through a variety of mechanisms. The 
scheduler provided by the run-time system is entered at certain synchronization points 
in a program, at which time other tasks may be placed into execution. Also, the underly- 
ing system may implement a time slice mechanism. Great freedom is provided Ada 
implementors in realizing these mechanisms, however, and as a result the schemes used 
can have a greater impact on the suitability of a particular implementation for real-time 
applications than the raw execution speed of many other constructs. 

The principal issue involved, from a real-time perspective, is the mechanism by 
which tasks are placed into execution. The LRM states that the order of scheduling 
among tasks of equal priority, or among tasks of unstated priority, is undefined. Fair 
scheduling is presumed. Synchronization points are the beginning and end of task 
activations and rendezvous. These are the only points at which a user can be sure that 
the scheduler will be entered in a system which does not implement priorities. The issue 
that arises is determining when a task becomes eligible for execution after the expiration 
of a delay. An implementation may elect to only check for expiration of the delay 
periodically, at synchronization points, or in a variety of other ways. 

To illustrate the problem consider an embedded system in which the programmer 
has control over all nonsystem tasks to be executed, and consider a simple polling loop 
whose purpose is to receive messages from a network device and post them to a local 
mailbox. While it would undoubtedly be desirable to have such a function interrupt 
driven, assume for this example that the underlying system precludes this possibility, 
hence the need for the polling loop. The basic loop, ignoring the need to allow other 
tasks to run, might reasonably have the form: 


loop (L2) 

if DEVICE_HAS_MESSAGE then 

RECEIVE(MESSAGE); -- May be entry or procedure call 


Benchm&rks-Ada 


17 


RSD-12-88 


DEPOSIT(MESSAGE); — May be entry or procedure call 
end if; 
end loop; 


The problem is how to allow other tasks to occasionally obtain service from the CPU, 
and still have the polling loop execute frequently enough that messages do not remain 
pending for long periods of time. The basic loop given above must be modified to ensure 
that this occurs. 

As a first strategy, suppose that a delay 0.05 statement is inserted before the if 
statement to provide an opportunity for other tasks to execute. One would expect that 
if all tasks have equal or undefined priority this strategy would allow other tasks to have 
a chance to run every time the message task runs, and that the message task would have 
a chance to run in accordance with underlying fair scheduling system. Further, if only 
the message task is ready to run, one would expect it to run approximately once every 
50 milliseconds. However, if, as is the case in some validated compiler systems, the 
expiration of this delay is only checked periodically, say at 1 second intervals, to see if 
any delayed tasks are ready to be reactivated, the polling loop may only be executed 
once a second, in spite of the fact that there are no other tasks ready to run. We call 
this type of scheduling fixed interval delay tcheduling. It may be performed quite 
independently from time slicing or other task scheduling which may be part of the same 
scheduling system. 

If priorities are supported, one might also place a PRIORITY pragma before the 
loop to give the polling loop a higher priority and “ensure” that it will run in preference 
to other tasks, if ready. Even in this case, however, it is not clear when the implementar 
tion will check to determine if the delay has expired. This matter is presently under 
consideration of the Language Maintenance Committee, and it is thus wise to have a 
method for testing the scheduling algorithm used. 

Even if fixed interval delay scheduling is used, acceptable performance may still be 
achieved under some circumstances if an implementation checks for tasks to schedule at 
points in addition to synchronization points. For example, if the loop given above is 
modified as shown below, other tasks may still obtain CPU service if the scheduler is 
entered to choose a new task to run each time a select is encountered. 


loop 

■elect 


when DEVICE_HAS_MESSAGE => 

accept RECEIVE(MESSAGE) do — MESSAGE is an out parameter 
DEPOSIT(MESSAGE); - procedure call 

end do; 
else 
null; 

end select; (L3) 

end loop; 


Given a fair scheduler, some other task would then have an opportunity to execute each 


18 


Benchmarks- Ada 



RSD-12-86 


time around the loop. Of course, either the other tasks must relinquish control suffi- 
ciently often or the scheduler must time share with sufficient frequency so that the pol- 
ling loop can regain control often enough. The price for the use of additional scheduling 
points is extra scheduling overhead. 

In order to develop many real-time Ada programs it is thus clearly necessary to 
have supplemental information about the scheduling strategies used by an implementar 
tion. A method for determining the time slice interval was described earlier. In the next 
subsection, techniques for determining the scheduling discipline related to delay expira- 
tion are described. 

4.8.1. Delay and Scheduling Measurements 

This section proposes a test which allows information regarding preemptive or fixed 
interval scheduling to be obtained. The test is based upon embedding a simple delay 
statement inside of a loop executed a large number of times, for example: 

T1 : — CLOCK; 

while I < N loop (L4) 

delay DEL; 

INCREMENT(I); 

end loop; 

T2 : — CLOCK; 

The interpretations desired will require running this test for several different ranges of 
values of DEL. Typically, the proper value ranges will not be known a priori, and might 
range over five orders of magnitude. The correct set of ranges must be determined 
empirically for each implementation. It will generally also be necessary to execute the 
test as the only process running on the CPU. Based upon this test several useful 
interpretations can be obtained by plotting d(DEL) vs. DEL where 


d(DEL) — ( T2 - T1 ) / N - TL , 


and TL is the loop overhead time. That is, d(DEL) is the actual delay time achieved. 
Ideally, the points of this plot should lie on a straight line, with slope one, as shown in 
Fig. 2. The deviation of the plot from this ideal provides useful information about the 
scheduler. 

4.8.I.I. Minimum Delay Overhead 

First, it is necessary to determine some information about the behavior of the 
scheduler for small values of DEL. Some implementations are smart enough to recognize 
situations in which the requested DEL is smaller than the overhead required by the 
delay function, and simply do a return to the calling unit immediately. To study this, 
let T s be the time required to perform the delay operation exclusive of any time the 
task is on a delay queue and the processor is performing work for another task, i.e., it is 
the overhead associated with delays. Typically, T s will depend upon DEL. For example, 
the overhead associated with returning to the calling program if DEL is below some 
threshold would be different from the overhead associated with placing the task in a 
delay queue. 


Benchm&rks-Ada 


19 


RSD- 12-88 


Beginning with DEL =* DURATION’SMALL make a series of runs of (L4) for 
increasing values of DEL, and generate the plot described above. Suppose d(DEL) 
remains constant for small values of DEL as shown in Fig. 3. This suggests that for 
DEL less than some components of T f, the system does an immediate return to the cal- 
ling program (or immediate rescheduling of the calling program). The threshold used 
can be obtained by increasing DEL until the curve ceases to be a straight line of slope 
zero. Care must be taken in choosing the values of DEL since the range of values 
required may well exceed an order of magnitude. 

If, on the other hand, d(DEL) shows a slope of 1, even for small values of DEL, 
then it is likely that the system always puts the calling task on a delay queue for the 
specified duration. In this case, a straight line passed through the sample points will 
intercept the ordinate at the value of T s for small values of DEL. Unfortunately, this 
latter effect may be difficult to observe if scheduling is nonpreemptive. 

4.8. 1.2. Fixed Interval vs Preemptive Delay Scheduling 

Next, we try to determine if fixed interval delay scheduling or true preemptive 
scheduling based upon interrupts from a programmable clock are used. If for DEL > T ^ 
the points of the plot He on a straight line of slope 1, preemptive scheduling is indicated. 

If the straight line with a slope of one is not achieved, it is suggestive that true 
preemptive scheduling is not being used. The plot is then likely to be a staircase func- 
tion if fixed interval delay scheduling is being used. To see this consider that only this 
task is executing and that after the first iteration of the loop, the delay statement will 
be encountered very shortly after the expiration of one of the fixed scheduling intervals. 
If the DEL specified does not exactly reach the end of the next scheduling interval, suffi- 
cient extra delay will be inserted implicitly to reach the end of the scheduling interval. 
Thus, after the first loop, the actual delay will be approximately some multiple of the 
scheduling interval. If the scheduling interval is large compared to TL, then the size of 
the step in the plot will be approximately the interval of the scheduler as illustrated in 
Fig. 4. Again, obtaining a sufficient set of values for d(DEL) is not entirely straightfor- 
ward. Some compilers are known to have a scheduling interval more than five orders of 
magnitude larger than DURATION’SMALL. Therefore, some cleverness is required in 
selecting the values of DEL to use, e.g., a coarse to fine search strategy. 

There is one additional characteristic to a scheduling strategy which might compli- 
cate the interpretation somewhat. If the implementation does do preemptive scheduling 
but with a time resolution element larger than DURATION’SMALL, a staircase plot will 
also result. Distinguishing between these cases can be difficult. If the measurement 
clock resolution, r, is relatively small compared to T1-T2 for N= 1, the two cases can 
be distinguished by rerunning the experiment for a fixed DEL with randomized starting 
times. In the case of true preemptive scheduling, T2-T1 should remain relatively fixed 
while for fixed interval delay scheduling, T2-T1 will vary randomly with the range of 
variation corresponding to the size of the interval of the scheduler. 

4.8.1.3. Compensation for Minimum Delay Overhead 

Finally, if preemptive scheduling has been used and DURATION’SMALL is signifi- 
cantly less than T $, further information can be obtained. Theoretically, d(DEL) will be 
a straight line having slope 1 and passing through the origin. It will actually do so only 
if the system has compensated the delay time by T $. An offset of the line so that it 


20 


Benchmarks- Ada 



RSD-12-86 


does not pass through the origin is indicative of either no compensation for T$ or 
incorrect compensation. More generally, due to the dependence of T & upon DEL, the 
plot might be composed of several line segments, and one could examine each line seg- 
ment as described above. If a fixed interval delay scheduler has been used this effect will 
be dominated by the extra delays introduced by the scheduler, and will not be visible. 

While the data obtained in the test described above must be analyzed in several 
different ways, this test does provide information which allows a great deal of useful 
information to be determined about an implementation. 

4.9. Memory Deallocation and Garbage Collection 

Memory allocation and dellocation processes are often critical to the operation of 
real time systems. Systems can fail because there is insufficient (virtual) memory avail- 
able, because the allocation or deallocation times are too large, or because a deallocation 
process (garbage collector) is implicitly called at times not under control of the applicar 
tions program. (The authors are painfully aware of the latter possibility through per- 
sonal experience.) 

There are two reasons why insufficient memory failures might occur. First, there 
might just intrinsically be too little space available in the pool of storage from which 
allocations are made. For most systems, this problem will probably not occur. More 
importantly for real-time systems, however, is the fact that the LRM does not require an 
immediate return to the storage pool of the deallocated storage, and a validated compiler 
has been found which does not return storage to the pool even if 
UNCHECKED_DEALLOCATION is called. Embedded systems are often expected to 
run for long periods of time, and while the total amount of storage in use at any one 
time may not be large, if deallocation does not take place, the system will eventually run 
out of storage unless the applications program takes over storage allocation responsibil- 
ity. Further, storage deallocation for real-time systems should be under explicit control 
of the applications program. Some systems implicitly call a garbage collector, either 
periodically, or when the amount of allocated or unallocated storage reaches some thres- 
hold level. Garbage collection can then take a substantial length of time, and unless it is 
run at the lowest possible priority (and priorities need not be supported), it can disrupt 
the operation of the system. For example, imagine a tight 1 millisecond control loop on 
an aircraft suddenly put into abeyance for a couple of seconds. 

There are also interesting run-time system or operating system effects which one 
might wish to observe. For any virtual memory system, the amount of memory allo- 
cated can eventually reach the point where paging takes place. Both the amount of 
memory for which this occurs and the paging times required may be of interest. For 
example, it has been found that in a Unix system, when the allocation storage 
approaches the virtual storage limit, overhead times of several seconds occur. (This is 
probably not a problem, however, since the virtual size limit is so large that rarely, if 
ever, would one run into this problem.) 

The basic idea in building tests to measure the effects mentioned above is to use 
the new allocator in a loop with various controls on whether it is or is not possible for 
deallocation to take place. The second differencing techniques described in Sec. 3.2 can 
be used to measure the relevant times which occur. 


Benchmarks-Ada 


21 


RSD-12-80 


For one test, a large array of pointers to a sizable array of data is declared. Then 
each time through the loop, a pointer to a newly allocated data array is placed in the 
pointer array, as shown below. 


type INT.ARRAY is array(1..10,1..10) of INTEGER; 
type ARRAY_PTR is access INT_ARRAY; 

PTR.ARRAY: array(l-.MAX) of ARRAY.PTR; 

TIME.ARRAY: array(l-.MAX) of TIME; 
begin 

for I in 1..MAX loop 
PTR.ARRAY(I) := new INT_ARRAY; 

TIME_ARRAY(I) := CLOCK; (L5) 

end loop; 


This forces the storage acquired to be kept and not deallocated since the pointer to it 
remains throughout the run. By making the loop counter sufficiently high, more storage 
will eventually be requested than is available in the system, and the exception 
STORAGE JERROR will be raised. A second difference analysis on the time array will 
yield the results on the storage allocation and paging times. 

A second test uses the same loop structure, but only two access variables. Each 
time around the loop, the content of one access variable is shifted to the second, and the 
newly acquired data is assigned to the first access variable, thus implicitly freeing the 
storage allocated two iterations previous to the current one. (This shifting structure is 
used to break up the possibility of an optimizer avoiding the actual allocation of 
storage.) If the exception STORAGE_ERROR is also raised on this loop, lack of any 
implicit deallocation is indicated. If a garbage collector is implicitly called, this will be 
detected by the second difference analysis on the array of clock times. 

The third test is similar to the second except that a call to 
UNCHECKED_DEALLOCATION is added to the loop to try to force deallocation. If 
the exception STORAGE_ERROR is still raised, either 
UNCHECKED_DEALLOCATION does not function properly or there is some global 
limit on the amount of storage which can be allocated which is independent of the avai- 
lability of storage to be allocated (a strange and unlikely occurrence). 

These tests provide basic information on the storage allocation and deallocation 
mechanisms used by an Ada system. 

4.10. Interrupt Response Time 

Interrupt response time is clearly critical for many real-time embedded systems. 
Techniques for measuring it, however, are difficult to develop since, in general, hardware 
external to the CPU must be involved, i.e., the test cannot be based only on program- 
ming. Second, the times which must be measured will be at substantively different 
points in the test program and the use of iteration to improve accuracy of measurement, 
as shown in (4), can not be expected to work in this situation. 


22 


Benchmarks- Ada 



RSD-12-88 


The first problem to be faced is the generation of the interrupt signal in a con- 
trolled and time measurable fashion. This can be accomplished by adding a parallel 
interface to the system to be tested and writing a special driver for the interface which 
must be directly accessible from the benchmark program. The output from the parallel 
interface is treated as a logic signal to cause an interrupt to the processor. The pro- 
cedure for outputting a signal through this interface must be written to be directly call- 
able, and hence time measurable, from the benchmark program. The procedure must 
not have to go through the underlying run-time or operating system. Then, using tech- 
niques described earlier it will be possible to obtain an accurate measure of the time 
required to output a signal to the interface. 

Two program segments are required for the benchmark. The first is a loop which 
repeatedly records the clock and outputs a signal to the parallel interface. 


TIME_ARRAY : array(l..MAX) of TIME; 
begin 

for I in 1..MAX loop (L6) 

TIME_ARRAY(I) := CLOCK; 

SEND_SIGNAL; — to parallel interface & create interrupt 

end loop; 


The second program segment is an interrupt handler which simply records the time at 
which it is invoked and returns from the interrupt. If possible, the interrupt handler 
should be set at a higher priority than the main loop. 

The output procedure call and clock recording overhead can be calculated by the 
techniques described above. Let T 0 , be this time. Next calculate the average time 
difference between the times recorded in the main loop and the corresponding times 
recorded in the interrupt handler. Denote this average by T „ t . Then, one can calcu- 
late the interrupt response time as T„ t - T„ . 

5. Results 

In this section we illustrate the application of the benchmarks by their use with 
several compilers: Verdix Versions 4.06, 5.1 and 5.2, running with Unix 4.2 bsd on a 
VAX 11/780, DEC VAX Ada Version 1.1 running with Micro VMS 4.1 on a Microvax II, 
DEC VAX Ada Version 1.3 running with VMS 4.4 on a VAX 11/780, and Alsys Version 
1.0 running with Aegis Version 9.2 on an Apollo DN 660. All user and daemon processes 
were disabled (except for the swapper and page daemon, which can never be disabled). 
The tests described in Sec. 3 were run to determine the operating system overhead 
injected into the measurements for Unix on the VAX. The components to overhead 
individually required significantly less than the resolution of the time measurement, r. 
Thus, as indicated in Sec. 3.3, it was difficult to get an accurate value for the overhead. 
Nevertheless, by examining the amount by which the string of zeros is shortened we 
were able to obtain a crude estimate of the overhead. With this approach, we estimated 
the overhead to be 5%. Due to the coarseness of this estimate, we present the rest of 
the results without modifying them to reflect the operating system overhead for time 
slicing. 


Benchmarks-Ada 


23 


RSD-12-80 


The number of iterations used in the test and control loops was chosen to produce 
results theoretically accurate to the nearest tenth of a microsecond or tenth of a mil- 
lisecond (except where noted) depending on the size of the quantity being measured. 
The results were very repeatable. Raw control and test results were usually repeatable 
within 0.1 or 0.2 microseconds (per iteration) for tests with similar target accuracies. 
This allowed us to see the effects of single instruction differences between two different 
situations and exposed a number of interesting implementation variations. 

We found that similar, but not absolutely identical, situations, e.g., passing one 
parameter versus passing several parameters, resulted in slightly different code sequences 
for some compilers. We even found positional dependencies in which the timing varied 
among identical functions on the basis of the relative position of units within a package 
or their position relative to double word boundaries in memory (related to the number of 
memory fetches required). With the assistance of some of the compiler vendors, we 
tracked down exactly what was happening in a number of such cases just to be sure that 
our benchmarks were correct. We will describe some of these below as illustrations of 
the differences which can occur. 

A consequence of such minor variations is that it is difficult to place meaning on 
results any closer than a couple of microseconds, even though theoretically more accu- 
rate results have been obtained. There are two reasons for this. First, the number of 
special cases to track down is sufficiently large as to require a very large effort to be 
complete. Second, even if one did track down each situation completely, there would be 
so many separate cases to report that one could not reasonably try to use all of the data 
anyway. 

A summary of the test results is presented in the tables in Appendix A. Highlights 
are discussed here; a complete list is given in Appendicies B thru G. 

5.1. Subprogram Overhead 

A summary of the results of making procedure calls of various kinds is given in 
Table A.l. There are several surprises in this table. First, it is evident that simply 
checking one kind of procedure call is inadequate. For some compilers, the differences 
among different kinds of calls (generic, non-generic, intra or interpackage) can be as 
much as two to one. Detailed investigation of DEC VAX compiler outputs showed that 
there were differences in certain elaboration and stack checks between the generic and 
non-generic versions of the code. 

A second characteristic, not obvious from the table, is the effect of code optimiza- 
tion. The DEC compiler, in particular, will in-line procedures for small procedure sizes 
automatically as a time optimization even if INLINE is not used. While this improves 
performance substantially, it makes it difficult to test procedure calling time, and raises 
a question of interpretation of the results. The numbers not available for procedure calls 
in Table A.l indicate circumstances in which the compiler INLINEd the test procedure, 
reducing the time to near zero. 

As a second illustration of minor code differences, consider the procedure call times 
with 1 or 10 integer arguments (not shown in detail due to size of data). For a single 
integer argument, the calling time was less for in out mode parameters than for out 
mode parameters. This relative timing was reversed when 10 parameters were passed. 
The reason was that the DEC peep-hole optimizer could see that a single in out formal 
did not receive an assignment (in our benchmark) and therefore optimized the exiting 


24 


Benchmarks- Ada 



RSD-12-86 


assignment out of the code, while for 10 parameters in the parameter list, the window 
was too small for that observation to be made and the exiting assignment was done for 
all parameters. That optimization was not performed for the out mode case. 

The per argument times associated with procedure calls were checked for lists of 1, 
10 and 100 arguments of INTEGER and ENUMERATION types, except for the Alsys 
and VAX Version 1.3 compilers, which would not handle argument lists of length 100. 
The differences in times among the modes seem to indicate copying associated with pass 
by value and initialization of variables. Variations also occurred in the number of regis- 
ters used, and therefore saved and restored, as a function of the number of parameters 
passed. The “+” in the per argument table indicates that a fraction of a microsecond 
was added to each argument passed, depending upon the number of registers used. 

Although we did obtain repeatable results with the Alsys compiler, the results did 
not fit a linear formula well, and are thus not reported that way. The values were in 
the range of 4-7 microseconds per argument. 

5.2. Dynamic Allocation of Objects 

The memory allocation tests, shown in Table A.2, are divided into two categories, 
allocations performed in a declarative region on entering a procedure, and allocations 
performed via the new allocator. 

The time required for fixed size storage allocation in a declarative region was small 
(a few microseconds) and roughly constant for each of the compilers. Thus, this was not 
shown in the table. The time required for dynamically bounded arrays varied approxi- 
mately as a linear function of the number of dimensions, which had been expected (con- 
sidering the formulas typically used for computing array dope vectors). The times were 
in the 10-20 microsecond per dimension range for all compilers except the Verdix 5.1 and 
Alsys compilers, which were appreciably larger. All of the ranges used in these tests 
were kept small in order to avoid other storage effects, such as allocating from the heap 
for objects above some size threshold. 

Two significant effects were discovered that had to be taken into account in order 
to obtain useful results in dynamic allocation via the new operator. First, for the Ver- 
dix 4.06 compiler, problems arose with the underlying memory management mechanism. 
This version never deallocated storage. Thus, as the amount of storage allocated across 
a large number of iterations began to grow, the operating system began to swap memory 
pages onto disk. This paging time was sufficient to distort the test results. To eliminate 
this difficulty, a sequence of pretests were run to determine the number of iterations 
that could be included in the test before paging became a significant problem. The tests 
were then run with this number of iterations. This reduced the precision somewhat, but 
useful results were still obtained. Versions 5.1 and higher did deallocate storage, which, 
while they eliminated the paging problem, did increase slightly the storage times 
recorded. 

Second, most of the compilers used a multi-level storage allocation scheme. Small 
objects were allocated from some locally held storage pool, while for larger objects, calls 
were made to the underlying system for more storage. The latter were quite evident 
since they typically required near an order of magnitude larger time than objects allo- 
cated from the local pool. To make these results evident, the dynamic storage requests 
via new were run several times with some object sizes from 4 to 4,000 bytes. The wide 
range of times shown in table A.2 simply reflects the fact that small objects were 


Benchm&rks-Ada 


25 


RSD-12-88 


allocated locally ■while large objects required a system call. 

The multilevel nature of dynamic storage allocation was also found (though it was 
not easy to detect) in the CLOCK function. The Verdix CLOCK function dynamically 
allocates a record each time it is called. The time to allocate this record from the local 
pool is only a few 10’s of microseconds. However, every once in a while the local pool 
becomes exhausted, and a system call must be made to obtain more storage. The time 
to obtain a new chunk of storage is on the order of 3 milliseconds. Thus, the time to 
allocate any one object can be quite variable. The possibility of a CLOCK call occasion- 
ally taking a long time due to the need to acquire more storage can have a devastating 
effect on real-time programs, as CLOCK will be used in many, if not most, real-time 
scheduling loops. Since the system call for more storage doesn’t happen very often, it 
will be difficult to isolate the problem. Consequently, it is important to identify all 
implementation supplied procedures or functions which allocate storage. 

5.3. Exceptions 

The exception handling tests are divided into two sets. In the first set an exception 
is raised within a declare block, and the exception handled by a handler at the end of 
the block. In the second set an exception is raised from within a procedure which does 
not have an explicit handler. The exception is then propagated to the calling block, 
which handles the exception at the end of the block from which the procedure was 
called. Exceptions were raised by three methods, explicitly with the raise statement, 
violation of a subtype range, and INTEGER overflow. 

The results of the exceptions tests are shown in Table A.3. In general, the com- 
pilers all take little or no time for exceptions that are not raised, which is an important 
characteristic for real-time applications. However, all of the exception handing times are 
significantly longer than would be required for condition testing and subprogram calls. 
When very fast response is required, users may find it necessary to explicitly handle 
exceptional situations in the body of their program rather than relying upon the Ada 
exception mechanism. The much larger times associated with implicitly raising 
NUMERICJERROR are associated with the fact that this kind of error is first trapped 
by the operating system, which then passes control back to the exception handler. In an 
embedded system with a dedicated real-time operating system, this time could be signifi- 
cantly less than occurred in our test results on a time-shared system. 

5.4. Task Elaboration, Activation, and Termination 

This test was run for the three different types of task elaboration and activation 
explained in Sec. 4.4. Table A.4 shows the task elaboration, activation and termination 
times for the compilers tested. For each individual compiler the differences between ela- 
boration and activation in a declarative region or via the new operator did not differ by 
more than 15% and thus are not reported separately. The table shows that efficient 
techniques for task elaboration, activation, and termination are possible. 

5.5. Task Synchronization 

The test here was rather straightforward. The test involved entering a block where 
a task was activated and a subprogram called that executed a rendezvous with that task 
repeatedly in a loop. The control for this test is of the same structure, except that the 
loop is iterated with no rendezvous. The results are also shown in Table A.4. The ren- 
dezvous times varied significantly, again indicating that as development continues on 


28 


Benchmarks- Ads 


RSD-12-80 


successive versions of compilers, the rendezvous times can be decreased. Entry calls with 
parameters showed that the additional time to pass parameters was negligible. 

5.6. Clock Function Overhead and Resolution 

Table A.5 shows the overhead associated with the CLOCK function. The numbers 
reported are averages obtained over several test runs. There is a large variation in the 
length of time required by the different compilers. The large increase in overhead 
required by the Verdix 5.1 and 5.2 compilers is due to a change in the data structure for 
objects of type TIME and an increase in the number of procedure and function calls 
within the CLOCK function. Unix system routines are called by CLOCK to get the 
time and compensate for the time zone. Daylight savings time is also taken into account 
and the time is normalized with respect to Greenwich Meridian Time. Since TIME 
objects are represented as Julian days and seconds, an Ada function in the CALENDAR 
package is also called to compute the Julian day. We were able to determine this infor- 
mation about the CLOCK function by examining the source code of the body of the 
CALENDAR package. While useful for some applications, these extensive computations 
are too time-expensive for many real-time applications, and some additional clock like 
function will be required for real-time applications. A CLOCK resolution of 10 mil- 
liseconds is marginal for many real-time applications. 

5.7. Arithmetic for types TIME and DURATION 

The TIME math tests measure overhead involved in addition and subtraction 
operations involving the types TIME and DURATION. All possible combinations 
involving variables and constants of each type are tested. Table A.6 shows the results. 
It appears that constant expressions are evaluated at compile time in all of the com- 
pilers. The difference of more than an order of magnitude between operations on the 
type TIME and the type DURATION is probably due to the representation of TIME as 
a record, while DURATION is fixed point. The variation in the results between the ver- 
sions of the Verdix compiler for expressions involving type TIME is due to a change in 
the record used to represent TIME. 

5.8. Delay and Scheduling Measurements 

This test involved the measurement of time elapsed during the execution of a 
delay statement. The results appear in Table A.5. 

For the Verdix 4.06 compiler, a minimum delay value of 1.4 milliseconds was 
detected. This delay occurred for requested delays between zero and slightly less than 1 
millisecond (actually, the upper bound is 16 times DURATION’SMALL, the greatest 
model number less than 1 millisecond). This value corresponds to the part of the curve 
before the jump in Fig. 4. For the Verdix 5.2 and DEC compilers the minimum actual 
delay was 10 milliseconds, and while for the Alsys compiler it was 1 second. 

The actual delay values in other cases were more difficult to isolate, due to the 
nature of the scheduling systems. Verdix Versions 4.06 and 5.1 use fixed interval delay 
scheduling with a delay value of 1 second. Thus, for a requested delay of 1 millisecond or 
greater, the actual delay was for the remainder of the one second time slice in which the 
delay expired. Since it is impossible to see this effect when a large number of iterations 
are run, the test was run repeatedly with the loop executed only once on each test. A 
delay generated by executing a statement a random number of times was inserted before 
the delay statement to vary the value remaining in the time slice. This test confirmed 


Benchmarka-Ada 


27 


RSD-12-88 


that requested delays between 1 millisecond and less than 10 milliseconds resulted in 
actual delays between 10 milliseconds and 1.01 seconds, that is, the value remaining in 
the 1 second time slice plus 10 milliseconds. As the requested delay was increased, the 
staircase function of Fig. 4 was obtained, with the step size being 1.01 seconds. The 
extra 0.01 seconds corresponds to one clock resolution time and appears to be time spent 
in the scheduler before the basic 1 second time slice is reset. 

Both the Verdix Version 5.2 and the DEC compiler used preemptive scheduling 
with a time resolution of 10 milliseconds. Due to the 1 second time resolution of the 
Alsys compiler, it was neither practical nor useful to test its scheduling algorithms 
further. 

5.9. Storage Deallocation and Garbage Collection 

The storage deallocation tests provided an insight to the type of deallocation facili- 
ties provided for objects declared dynamically with the new allocator. The object used 
for allocation throughout this test was a one dimensional array consisting of 1000 
INTEGERS. The size of the virtual memory space available is approximately 32 megar 
bytes, the limit imposed by the operating system. This is the size at which 
STORAGEJERROR should be raised by (L5). 

By modifying the test loop to use only two access variables, instead of the array of 
access variables in (L5), we found that the Version 4.06 run-time system does not per- 
form garbage collection, since STORAGE_ERROR was still raised at the same point. 
Further, by explicitly calling UNCHECKED_DEALLOCATION after every allocation 
and observing that STORAGE_ERROR was still raised at the same point, we concluded 
that the UNCHECKED_DEALLOCATION procedure does not reclaim storage in that 
version of the compiler. 

The Version 5.1 and 5.2 compilers also do not perform garbage collection, but 
UNCHECKED_DEALLOCATION does reclaim storage for scalar types, records, strings 
and statically bounded array types. Storage is not reclaimed for unconstrained array 
types. Due to improper setting of system parameters on the Microvax II, the DEC VAX 
Ada Version 1.1 tests (performed by a third party) were ill behaved for large amounts of 
storage allocation, and the tests were not performed on this version. 

6. Summary and Conclusion 

This paper has developed a series of benchmarks to test the real-time performance 
of an Ada compiler and run-time system together with a set of analysis tools to aid in 
the interpretation of the test results. In order to obtain accurate results, the tests 
should be run as the sole application on the machine being used with as many system 
daemons disabled as possible. To verify the quality of the environment in which the 
tests are being run, a simple test of repeatedly reading the system clock and analyzing 
the results to identify the frequency and size of operating system activity should be per- 
formed before running the tests. 

Although the benchmarks are intended for testing real-time performance, the only 
Ada systems available to us at the time of development were intended for time-shared, 
and not real-time, use. Time shared systems often place less emphasis on the real-time 
performance than on general program development and execution support, and the 
results of applying our tests bore this out. However, by the same token, the results 
point to areas in which users should expect significant performance improvements in 


28 


Benchmarks- Ada 



RSD-12-86 


systems intended for real-time applications. Among the areas so noted are: improved 
performance of the task scheduler, the incorporation of pragma INLINE, improved 
storage management facilities, higher speed operations with respect to TIME, and a 
reduction in tasking and CLOCK overhead. 

There are also a small number of real-time relevant tests which we were not able to 
perform on the systems available to us, i.e., the interrupt response time and the behavior 
of the system with respect to task scheduling upon I/O requests. A test was proposed 
for the former, and the time-shared operating system determines the behavior of the 
latter at a level above the tasking level of the Ada program. Further work is required in 
these areas when suitable testing facilities are available. 

Finally, we make several observations based upon our experience in developing 
these benchmarks. First, so many implementation dependent variations are validateable 
that it is not safe, in our opinion, to use an Ada compiler for real-time applications 
without first checking it with performance evaluation tools. Characteristics such as time 
management, scheduling and memory mangement can have validated implementations 
that will devastate a real-time application. Real-time performance evaluation is difficult. 
Due to the great variety of implementation dependencies allowed, it typically requires 
interpretation and benchmark changes for each individual compiler tested. And, real- 
time performance evaluation is really only meaningful for dedicated embedded systems. 

7. Acknowledgements 

The authors wish to thank Chuck Antoneili for sharing his knowledge of the Unix 
operating system and his help in obtaining and interpreting direct time readings from 
Unix, and Ron Theriault, Jarir Chaar, and Sue Hsieh for numerous late nights in helping 
run the benchmark tests. We are also grateful to Bill Meier of Digital Equipment Cor- 
poration for running our benchmarks on a VAX 11/780 and assisting us in deciphering 
some of the minor anomalies that occurred. We are also appreciative of assistance from 
Rob Bedichek and Steve Ziegler of Verdix. 


Benchmarks-Ada 


29 



RSD-12-88 


8. References 


[1] Ada programming language (ANSI/MIL-STD-1815A). Washington, D.C. 20301: 
Ada Joint Program Office, Department of Defense, OUSD(RfeD), Jan. 1983. 

[2] H. J. Curnow and B. A. Wichmann, “A synthetic benchmark,” The Computer 
Jour., vol. 19, no. 1, pp. 43-49, Feb. 1973. 

[3] R.P. Weicker, “Dhrystone: a synthetic systems programming benchmark,” Com- 
munication* of the ACM, vol. 27, no. 10, pp. 1013-1030, October 1984'. 

[4] P.J. Jalics, “Comparative performance of cobol vs pl/1 programs,” Computer 
Performance Evaluation U*er* Group 16th Meeting, Oct. 20-23, 1980. 

[5] J. Squire, “Performance issues workshop,” ACM SIGADA User* Committee Per- 
formance Issues Working Group, July 15-16, 1985. 

[6] M.J. Bass man, G.A. Fisher, Jr., and A. Gargaro, “An approach for evaluating the 
performance efficiency of Ada compliers,” Ada in Use , Proc. of the Ada Int’l 
Conf., May 14-18, 1985. 

[7] S.F. Zeigler and R.P. Weiker, “Ada language statistics for the iMAX 432 operat- 
ing system,” Ada Letters, vol. 2, no. 6, pp. 63-67, May 1983. 

[8] M. Shimasaki, S. Fukaya, K. Ikeda, and T. Kiyono, “An analysis of pascal pro- 
grams in compiler writing," Software Practice and Experience, vol. 10, no. 2, pp. 
149-157, Feb. 1980. 

[9] J.G.P. Barnes, Programming in Ada. London: Addison- Wesley Publishing Co., 
1984. 


30 


Benchmarks- Ada 




RSD- 12-88 


0 

E 


>. 

« 

0 

T3 


O 
3 
— * 
O 
< 


■ 


Command delay time 


Figure 3. The Delay Curve for Small Values of DEL 
Showing Minimum Delay Overhead. 


0 



Small minimum 
delay, possibly 
- 1 ms 


■ a S\y ■ 


Large time, possibly as much as Is 




Command delay time 


Figure 4. The Delay Curve for Fixed-Interval Scheduling 


32 


Benchmarks- Ada 



APPENDIX A 


V ' 


Benchmark Results 

The following tables summarize the results of the benchmark tests run. All values are 
reported in microseconds except where noted. The compiler/hardware combinations 
tested are: 


Compiler 


•.« Machine 


Operating System 


Verdix 4.06 
Verdix 5.1 .■ 

Verdix 5.2 ax 

Alsys 1.0 r 

DEC VAX Ada, V.1.1 
DEC VAX Ada, V.1.3 


Vax 11/780, 4M real memory 
Vax 11/780, 4M real memory 
Vax 11/780, 4M real memory 
Apollo DN660, 4M real memory 
DEC Microvax II, 5M real memory 
DEC VAX 11/780 


Unix bsd 4.2 
Unix bsd 4.2 
Unix bsd 4.2 
Aegis Version 9.2 
Micro VMS 4.1 
VMS 4.4 


* Table A.1 

Procedure Calls, no arguments 


Compiler 

Inter- 

package 

Intra- 

package 

Inline 

Generic 

Interpackage 

Generic 

Intrapackage 

Verdix 4.06 

'* 17.7 ftsec 

27.7/isec 

28.6psec 

25.9psec 

30.5#rsec 

Verdix 5.1 

17.6 

16.8 

0.4 

18.5 

17.6 

Verdix 5.2 

18 

17 

0.0 

18 

20 

Alsys 1.0 

14 

12 

31 

8 

27 

DEC VAX Ada, V.1.1 

46.1 

X 1 

3.0 

45.9 

x 1 

DEC VAX Ada, V.1.3 

27.0 

x 1 

0 

15 

x 1 


Additional overhead 

per integer argument 


Compiler 

in 

out 

in out 

Verdix 4.06 

~1.5psec 

~3.0jisec 

~3.0/isec 

Verdix 5.1 

-1.5 

-3.0 

-3.0 

Verdix 5.2 

-1.5 

-3.0 

-3.0 

Alsys 1.0 

-4.2 

-2.8 

-4.7 

DEC VAX Ada, V.1.1 

-1.3 

—3+ 

-6+ 

DEC VAX Ada, V.1.3 

-1.5 

—3+ 

—6+ 


'Compiler INLINED the call reducing value to lero. DEC has supplied a value of 15.1/isec for this call. 


Benchmarks-Ada 


33 


RSD-12-88 


Table A.2 


Dynamic Storage Allocation 


Dynamically bounded arrays 1 in Declarative Region 


Compiler 

1-D Array 

2-D Array 

3-D Array 

Verdix 4.06 

31/jsec 

46/isec 

54^sec 

Verdix 5.1 

143 

149 

161 

Verdix 5.2 

19 

31 - 32 

43- 46 

Alsys 1.0 

28-41 

74 - 84 

145 - 168 

DEC VAX Ada, V.1.1 

9- 18 

22- 25 

37-38 

DEC VAX Ada, V.1.3 

13 - 18 

21 - 31 

46- 48 


Dynamically bounded 
Compiler 

arrays 2 allocated via 
1-D Array 

new 

2-D Array 

3-D Array 

Verdix 4.06 

221 - 284/isec 

309 - 1200/jsec 

326 - x V s ec 

Verdix 5.1 

200 - 260 

280 - 1140 

300 - 3,370 

Verdix 5.2 

220 - 280 

290 - 1300 

300 - 3,350 

Alsys 1.0 

2,249 - 2,185 

2,191 - 2,217 

2,300 - 2,334 

DEC VAX Ada, V.1.1 

410 - 450 

430 - 870 

490 - 4,830 

DEC VAX Ada, V.1.3 

290 - 300 

280 - 300 

370 


Compiler Fixed length objects (small, no arrays) located via new 


Verdix 4.06 
Verdix 5.1 
Verdix 5.2 
Alsys 1.0 

DEC VAX Ada, V.1.1 
DEC VAX Ada, V.1.3 


133 - 300/xsec 
227 - 270 
130 - 239 
1,963 - 1,985 
310 - 510 
250 


integer arrays with range 1 along each dimension. 

®Two tests each, integer arrays with ranges 1 and 10 along each dimension. 
Storage errors resulted when we attempted to allocate larger amounts of storage. 


34 


Benchmarks- Ada 


RSD-12-88 


Table A.3 

Exception Handling 


Compiler 


User Defined, not Raised Numeric Error, 

implicitly raised 

Block Procedure in Procedure 


Other Exceptions 
Handled Propagated to 
in Block Calling Procedui 


Verdix 4.06 

Opsec 

Q/isec 

2.47ms 

345 - 402/xsec 

614 - 671/isec 

Verdix 5.1 

0 

1 

2.55 

315 - 372//sec 

544 - 613/xsec 

Verdix 5.2 

0 

1 

2.72 

396 - 448jisec 

718 - 783jusec 

Alsys 1.0 

0 

0 

17.95 

8.8 - 9.8ms 

19 - 20ms 

DEC VAX Ada, V.1.1 

4 

16 

0.89 

667 - 836/isec 

736 - 894{*see 

DEC VAX Ada, V.1.3 

3 

12 

0.60 

414 - 541/isec 

482 - 619/isec 


Table A.4 
Tasking Times 

Compiler Rendezvous Task Elaborate, 

Activate, 

Termin ate 


Verdix 4.06 

3.50ms 

19.6ms 

Verdix 5.1 

3.40 

20.4 

Verdix 5.2 

0.82 - 0.89 

3.6 

Alsys 1.0 

9.55 

14.2 

DEC VAX Ada, V.1.1 

1.85 

8.2 

DEC VAX Ada, V.1.3 

1.1 

6.6 


Bench marks- Ada 


35 


Table A.5 

Timing & Scheduling 


RSD-12-88 


Compiler 

Clock 

Call 

Clock 

Resolution 

Delay Scheduling 
Method 

Effective Delay 
Resolution 

Verdix 4.06 

570psec 

10ms 

fixed interval 

Variable 10ms - lsec 

Verdix 5.1 

3,550 

10ms 

fixed interval 

Variable 10ms - lsec 

Verdix 5.2 

3,644 

10ms 

preemptive 

10ms 

Alsys 1.0 

1,500 

lsec 

r 

lsec 

DEC VAX Ada V.1.1 

95 

10ms 

preemptive 

10ms 

DEC VAX Ada. V.1.3 

89 

10ms 

preemptive 

10ms 


Table A.B 
Time 

Compiler TIMEs DURATIONS DURATION := TIME - TIME; 

only only 


Verdix 4.06 

188 - 241 /i sec 

7.2 - 7.6/isec 

111/isec 

Verdix 5.1 

716 - 812 

6.3 

50 

Verdix 5.2 

816 - 889 

6.0 

75 

Alsys 1.0 

88 - 105 

1 - 2 

189 

DEC VAX Ada, V.1.1 

98- 109 

x 1 

118 

DEC VAX Ada, V.1.3 

91 - 94 

1 

94 


Reliable data unavailable. 


38 


Benchmarks- Ada 


RSD-12-80 


APPENDIX B 


The following pages contain result tables for all of the tests run. These results 
are for the Verdix Compiler Version 4.08 running with Unix 4.2 bsd on a Vax 11/780. 
Some values contain explanatory footnotes. 


Benchmarks-Ada 


37 




RSD-12-80 


fSBQMAL PAGE ; 
OF POOR QUALITY 


Subprogram Overhead (non- gene r i c ) 
Number of Iteration! = 10000 • 10 


Time | 

(microsec. )| 

Direction!# Passed 
Passed jin Call 

Type 

Passed 

Size of 
Passed Var 

27.7 | 



0 



3 0.3 | 

I 


1 

INTEGER 


31.1 | 

O 


1 

INTEGER 


3 1.0 | 

I _o 


1 

INTEGER 


43.1 i 

I 


1 0 

INTEGER 


58 . 1 1 

O 


1 0 

INTEGER 


58.7 j 

1.0 


1 0 

INTEGER 


182.1 j 

I 


100 

INTEGER 


330.8(1) | 

o 


100 

INTEGER 


44S.7(2)| 

i _o 


100 

INTEGER 


20.8 j 

I 


1 

ENUMERATION 


3 1.0 ! 

o 


1 

ENUMERATION 


3 1.0 j 

1-0 


1 

ENUMERATION 


43.7 j 

I 


1 0 

ENUMERATION 


58.2 j 

o 


1 0 

ENUMERATION 


58.1 | 

I o 


1 0 

ENUMERATION 


182.8 | 

I 


100 

ENUMERATION 


353.7(3) | 

o 


100 

ENUMERATION 


601.4(4)| 

i _o 


100 

ENUMERATION 


30.3 | 

I 


1 

ARRAY of INTEGER 

1 

33.0 j 

o 


1 

ARRAY o f I NT EGER 

1 

33.0 | 

i_o 


1 

ARRAY of INTEGER 

1 

52.6(5) | 

I 


1 

ARRAY of INTEGER 

1 0 

3 1.0 j 

o 


1 

ARRAY of INTEGER 

1 0 

31.2 ! 

I o 


1 

ARRAY of INTEGER 

1 0 

30.5 j 

I 


1 

ARRAY of INTEGER 

100 

30.6 I 

o 


1 

ARRAY of INTEGER 

100 

30.7 i 

1-0 


1 

ARRAY of INTEGER 

100 

31.6 i 

I 


1 

ARRAY of INTEGER 

10000 

3 1.2 j 

o 


1 

ARRAY of INTEGER 

10000 

31.4 i 

1.0 


1 

ARRAY of INTEGER 

10000 

30.2 j 

I 


1 

RECORD of INTEGER 

1 

31.7 j 

o 


1 

RECORD of INTEGER 

1 

3 1.0 ] 

1-0 


1 

RECORD of INTEGER 

1 

3 1.1 j 

1 


1 

RECORD of INTEGER 

100 

3 1.1 ( 

o 


1 

RECORD of INTEGER 

100 

31.1 j 

1-0 


1 

RECORD of INTEGER 

100 

32.2 | 

I 


1 

UNCONSTRAINED ARRAY 

1 

32.2 j 

o 


1 

UNCONSTRAINED ARRAY 

1 

32.1 ! 

1-0 


1 

UNCONSTRAINED ARRAY 

1 

32.6 ; 

I 


1 

UNCONSTRAINED ARRAY 

100 

32.4 | 

o 


1 

UNCONSTRAINED ARRAY 

100 

32.4 { 

i_o 


1 

UNCONSTRAINED ARRAY 

100 

32.3 j 

1 


1 

UNCONSTRAINED ARRAY 

10000 

32.3 i 

o 


1 

UNCONSTRAINED ARRAY 

1 0000 

32.2 | 

I _0 


1 

UNCONSTRAINED ARRAY 

10000 

30.5 [ 

I 


1 

UNCONSTRAINED RECORD 

1 

3 1.8 | 

o 


1 

UNCONSTRAINED RECORD 

1 

31.0(6)| 

1-0 


1 

UNCONSTRAINED RECORD 

1 

30.2 j 

1 


1 

UNCONSTRAINED RECORD 

100 

3 1.8 | 

o 


1 

UNCONSTRAINED RECORD 

100 

30.0(7) j 

1-0 


1 

UNCONSTRAINED RECORD 

100 


(1) 

• Results 

for 

t h i 

8 

test 

have 

ring 

e d 

f r om 

3 30 

i o 

390 

m i 

c r o a 

e c o n d s 

‘ (2) 

• Results 

for 

t h i 

8 

test 

have 

ranged 

f r om 

336 

t o 

6 65 

mi 

c r o a 

e c o nd 3 

(3) 

• Results 

for 

th i 

8 

test 

have 

ranged 

f r om 

3 4 0 

t 0 

361 

mi 

c r o s 

e c o n d 3 

1 <«> 

- Results 

for 

t h i 

8 

test 

have 

ranged 

f r om 

352 

t 0 

601 

m i 

c r o s 

e c o n d s 

(5) 

- Other runs 

hare 


i n d i c a t e d 

that 

t b i 

s v a 1 

u e 

i 8 

30.8 

m i 

c r o s 

e c o n d s 

(») 

- Other runs 

have 


i nd i cat ed 

that 

t h i 

s v a 1 

u e 

! 8 

31.7 

mi 

c r o a 

e c o nd s 

(7) 

- Other runs 

have 


i nd i c a t e d 

that 

t b i 

s v a 1 

u e 

1 8 

31.8 

m i 

c r o s 

e c o nd s 


Benchmarks-Ada 


39 



RSD- 12-80 


Subprogram Overhead (inline) 
Number of Iterations = 10000 • 10 


T i me ] D i r e c t ion 

I# Passed! 

Type 

| Site 

o f | 

(microsec. )j Passed 

jin Call | 

Passed 

(Passed 

Var j 


28.6 


0 

1 1 


20.0 

I 

1 

j INTEGER j 


30.0 

O 

1 

j INTEGER j 


31.7 

I _o 

1 

j INTEGER i 


43.3 

I 

1 0 

| INTEGER j 


63.4(1) 

o 

1 0 

j INTEGER j 


58.4 

I _0 

1 0 

j INTEGER | 


185.1(2) 

I 

100 

j INTEGER | 


330.7(3) 

o 

100 

j INTEGER | 


363.2(4) 

i _o 

100 

| INTEGER j 


20.0 

I 

1 

j ENUMERATION j 


31.0 

o 

1 

| ENUMERAT I ON j 


32.1 

i _o 

1 

(ENUMERATION j 


42.7 

I 

1 0 

(ENUMERATION ! 


58.3 

o 

1 0 

(ENUMERATION ! 


58.1 

i _o 

1 0 

(ENUMERATION j 


182.1 

I 

100 

(ENUMERATION ! 


335.0(5) 

o 

100 

(ENUMERATION j 


347.0(6) 

i _o 

100 

(ENUMERATION j 


30.2 

I 

1 

(ARRAY of INTEGER j 

1 

32.5 

o 

1 

j ARRAY of INTEGER ! 

1 

32.7 

i _o 

1 

j ARRAY of INTEGER 

1 

30.8 

I 

1 

j ARRAY of INTEGER ( 

1 0 

30.8 

o 

1 

j ARRAY of INTEGER j 

1 0 

3 1.3 

i _o 

1 

j ARRAY of INTEGER j 

1 0 

30.4 

I 

1 

j ARRAY of INTEGER I 

100 

30.0 

o 

1 

| ARRAY of INTEGER | 

1 0 0 

30.5 

i_o 

1 

| ARRAY of INTEGER | 

100 

3 1.4 

I 

1 

j ARRAY of INTEGER j 

10000 

31.3 

o 

1 

| ARRAY of INTEGER j 

10000 

3 1.3 

i _o 

1 

| ARRAY of INTEGER | 

10000 

30.5 

I 

1 

j RECORD of INTEGER ( 

1 

32.4 

o 

1 

j RECORD of INTEGER j 

1 

34.1(7) 

I o 

1 

j RECORD of INTEGER ! 

1 

3 1.0 

I 

1 

j RECORD of INTEGER j 

100 

3 1.3 

o 

1 

j RECORD of INTEGER | 

100 

3 1.1 

I _o 

1 

j RECORD of INTEGER j 

100 

32.1 

I 

1 

(UNCONSTRAINED ARRAY j 

1 

32.3 

o 

1 

(UNCONSTRAINED ARRAY | 

1 

32.2 

i _o 

1 

(unconstrained ARRAY j 

1 

32.2 

I 

1 

(unconstrained ARRAY | 

100 

32.3 

o 

1 

(unconstrained array ( 

100 

32.3 

i _o 

1 

(unconstrained array j 

100 

32.3 

I 

1 

(unconstrained ARRAY 1 

1 0000 

32.2 

o 

1 

(UNCONSTRAINED ARRAY j 

1 0000 

32.2 

i _o 

1 

j UNCONSTRA I NED ARRAY j 

1 0000 

30.5 

I 

1 

(UNCONSTRAINED RECORD j 

1 

3 1.7 

o 

1 

(unconstrained record! 

1 

3 1.7 

i_o 

1 

(unconstrained RECORD j 

1 

30.5 

l 

1 

(UNCONSTRAINED RECORD j 

100 

3 1.7 

o 

1 

(unconstrained record! 

1 0 0 

3 1.7 

1 _0 

1 

(unconstrained record! 

100 


(1) 

- Other runs 

have 


i n d i e a t e d 

that 

t h i 

s v a 1 

u e i 

I 8 

58.1 

mi 

c 

ro j 

e c o nd 9 

(2) 

• Results 

for 

t h i 


test 

have 

ranged 

f r om 

185 

t 0 

242 

mi 

c 

r o s 

e c o nd 9 

(3) 

- Results 

for 

t h i 


test 

have 

ranged 

f r om 

3 30 

t 0 

348 

m i 

c 

r o s 

e c o nd a 

m 

• Results 

for 

t h i 


test 

have 

ranged 

f r om 

3 6 3 

t 0 

3 78 

m i 

c 

r o s 

e c o nd 9 

(S) 

- Results 

for 

t h i 


test 

have 

ranged 

f r om 

335 

i o 

375 

m i 

c 

r o s 

e c o n d s 

(6) 

- Results 

for 

t h i 


test 

have 

ranged 

f r om 

342 

t 0 

4 05 

m i 

c 

r o 8 

e c o n d 9 

(7) 

- Other runs 

hare 


i n d i c a t e d 

that 

t h i 

9 va 1 

u e i 

I 8 

32.0 

mi 

cros 

e c o n d 9 


40 


Benchmarks- Ada 



RSD-12-86 


Subprogram Orerketd (generic) 
Number of Iteration = 1 0000 • 10 


Time 

| D i r e c t ion 

1# Passed | 

Type 

| Site 

of | 

(microsec . ) 

j Pas sed 

| in Cal I | 

Pa ned 

j Pa s s ed 

Var | 


30.5 | 


0 

1 1 


3 4.6 ; 

I 

1 

j INTEGER I 


35.7 | 

O 

1 

j INTEGER | 


35.8 j 

i_o 

1 

j INTEGER j 


48.2 | 

I 

1 0 

j INTEGER j 


63.3 j 

o 

10 

j INTEGER j 


63.5 j 

i_o 

10 

| INTEGER i 


165.3(l)j 

I 

100 

j INTEGER | 


355.3(2) j 

o 

100 

j INTEGER j 


393.5(3) | 

1-0 

100 

j INTEGER j 


34.3 j 

I 

1 

j ENUMERATION j 


35.9 j 

o 

1 

j ENUMERATION | 


35.8 j 

i_o 

1 

{ENUMERATION | 


48.0 j 

I 

1 0 

{ENUMERATION j 


62.8 j 

o 

1 0 

{ENUMERATION | 


63.4 j 

1-0 

1 0 

{ENUMERATION | 


199.0(4) j 

1 

100 

{ENUMERATION | 


369.3(5) | 

o 

100 

{ENUMERATION | 


350.9(6) j 

i_o 

100 

{ENUMERATION | 


35.0 | 

I 

1 

1 ARRAY of INTEGER | 

1 

36.6 { 

o 

1 

j ARRAY of INTEGER j 

1 

36.3 1 

1.0 

1 

j ARRAY of INTEGER j 

1 

35.7 j 

I 

1 

| ARRAY of INTEGER | 

10 

35.4 j 

o 

1 

| ARRAY of INTEGER | 

1 0 

35.8 1 

1.0 

1 

| ARRAY of INTEGER j 

1 0 

35.6 l 

I 

1 

| ARRAY of INTEGER | 

100 

35.6 j 

o 

1 

j ARRAY of INTEGER | 

100 

35.6 [ 

I_0 

1 

| ARRAY of INTEGER [ 

100 

35.3 j 

I 

1 

j ARRAY of INTEGER j 

10000 

35.3 { 

o 

1 

j ARRAY of INTEGER | 

10000 

35.4 | 

i _o 

1 

j ARRAY of INTEGER | 

10000 

35.0 | 

I 

1 

j RECORD of INTEGER j 

1 

36.5 i 

o 

1 

j RECORD of INTEGER j 

1 

36.5 ] 

1.0 

1 

| RECORD of INTEGER | 

1 

35.4 | 

I 

1 

j RECORD of INTEGER { 

100 

35.3 I 

o 

1 

j RECORD of INTEGER j 

100 

35.4 j 

I_0 

1 

j RECORD of INTEGER j 

100 


(1) 

- Results 

for 

t h i 

s 

test 

hare 

ranged 

f 

r om 

165 

t 0 

190 

mi 

croseconds . 

(2) 

- Results 

for 

thi 

9 

test 

bare 

ranged 

f 

r om 

355 

t 0 

397 

mi 

croseconds . 

(3) 

• Results 

for 

i h i 

8 

test 

have 

ranged 

f 

r om 

344 

t 0 

303 

mi 

croseconds . 

(O 

- Results 

for 

t h i 

9 

test 

hare 

ranged 

f 

r om 

186 

t o 

200 

m i 

croseconds . 

(S) 

- Results 

for 

t h i 

9 

test 

bare 

ranged 

f 

r om 

321 

t 0 

550 

mi 

croseconds . 

(8) 

- Results 

for 

thi 

8 

test 

bare 

ranged 

f 

r om 

350 

t 0 

471 

mi 

croseconds . 


Benchmarks-Ada 


41 


RSD-12-80 


Subproghnm Overheid (cross pickige, non-generic) 
Number of Iterations = 10000 • 10 


( 

T i me 

microsec.) 

Direct ion|# Pissed 
Pissed jin Ci 1 1 

[ Type 1 S i i e of 

1 Pissed jPissed Vir 

T 

1 

1 

17.7 


0 

1 I 


T 

1 

10.4 

I 1 

1 

j INTEGER | 


1 

1 

2 1.0 

o ! 

1 

| INTEGER | 


1 

1 

21.2 

1-0 1 

1 

j INTEGER j 


1 

1 

3 1.6 

i ! 

1 0 

j INTEGER i 


1 

1 

46.6 

O 1 

1 0 

j INTEGER j 


1 

1 

46.7 

1-0 I 

10 

j INTEGER j 


1 

1 

106.4(1) 

I i 

100 

j INTEGER j 


1 

1 

323.6(2) 

O ] 

100 

j INTEGER j 


1 

1 

324 .5 ( 3 ) 

I-O- 1 

100 

j INTEGER j 


1 

1 

10.6 

I 1 

1 

[ENUMERATION j 


! 

1 

20.6 

o i 

1 

j ENUMERATION ! 


1 

1 

20.6 

1-0 i 

1 

j ENUMERATION j 


1 

1 

3 1.5 

I I 

1 0 

j ENUMERATION ) 


1 

1 

50.0(4) 

o 1 

1 0 

j ENUMERATION j 


1 

1 

46.6 

i_o i 

1 0 

j ENUMERATION j 


1 

1 

170.1(5) 

I ! 

100 

j ENUMERATION 


1 

1 

322.4(6) 

o 1 

100 

j ENUMERATION 


1 

1 

335.6(7) 

1-0 1 

100 

[ENUMERATION j 


1 

1 

10.0 

I j 

1 

(ARRAY of INTEGER j 

1 

1 

1 

2 1.1 

o I 

1 

| ARRAY of INTEGER j 

1 

1 

1 

20.4 

1-0 ! 

1 

j ARRAY of INTEGER [ 

1 

1 

1 

10.6 

I ] 

1 

jARRAY of INTEGER j 

1 0 

1 

1 

10.6 

O ! 

1 

(ARRAY of INTEGER | 

1 0 

1 

1 

10.6 

1-0 I 

1 

(ARRAY of INTEGER ! 

1 0 

1 

1 

10.2 

I 1 

1 

(ARRAY of INTEGER j 

100 

1 

1 

10.6 

o i 

1 

(ARRAY of INTEGER j 

100 

1 

1 

10.6 

1-0 ! 

1 

(ARRAY of INTEGER j 

100 

1 

1 

10.6 

i ! 

1 

(ARRAY of INTEGER j 

10000 

1 


10.1 

o i 

1 

(ARRAY of INTEGER 1 

10000 

1 


10.1 

1-0 ! 

1 

j ARRAY of INTEGER [ 

1 0000 

1 


20.6 

i j 

1 

j RECORD of INTEGER j 

1 

1 


21.2 

o | 

1 

j RECORD of INTEGER | 

1 

1 

1 

2 1.1 

1-0 1 

1 

(RECORD of INTEGER [ 

1 

1 

1 

10.8 

I i 

1 

j RECORD of INTEGER [ 

100 

1 

1 

10.6 

o i 

1 

(RECORD of INTEGER 

1 0 0 

1 

1 

10.6 

i_o ! 

1 

j RECORD of INTEGER j 

100 

1 

1 

23.2 

i j 

1 

(unconstrained ARRAY j 

1 

1 

1 

23.4 

o ! 

1 

(unconstrained ARRAY ( 

1 


1 

23.3 

i-O ! 

1 

(unconstrained array ( 

1 

1 

1 

23.3 

I j 

1 

(unconstrained array ( 

100 

1 

1 

23.3 

■ o i 

1 

(unconstrained array ( 

100 

1 

1 

23.3 

I-O ! 

1 

[UNCONSTRAINED ARRAY ( 

100 

1 

1 

23.2 

I ! 

1 

(unconstrained array i 

10000 

1 

1 

23.3 

o 1 

1 

(unconstrained array i 

10000 

1 

1 

23.3 

I_0 j 

1 

(unconstrained array j 

10000 

1 

1 

20.5 

I 

1 

(unconstrained RECORD 1 

1 

1 

1 

22.4 

O 1 

1 

(unconstrained RECORD ( 

1 

1 

1 

22.4 

I-O | 

1 

(unconstrained RECORD 1 

1 

1 

1 

20.4 

I j 

1 

(unconstrained record! 

100 

1 

1 

22.2 

o 1 

1 

(unconstrained RECORD j 

100 

1 

1 

22.3 

I-O 1 

1 

[UNCONSTRAINED RECORD 1 

100 

1 


(1) 

- Results 

for 

t h i 

9 

test 

hire 

ringed 

from 

1 70 

t 0 

1 96 

m i 

c r o 9 

e c o n d s 

(2) 

• Results 

for 

t h i 

9 

t e st 

hive 

ringed 

f r om 

3 23 

t 0 

347 

mi 

c r o 9 

e c o n d s 

(3) 

• Results 

for 

t h i 

9 

test 

hive 

ringed 

f r om 

323 

t 0 

380 

m i 

c r o s 

e c o n d s 

(4) 

- Other runs 



i nd i cited 

t h 1 1 t b 

s va 1 

u e 

9 

46.6 

mi 

c r o 8 

e c o nd s 

(S) 

• Results 

for 

t h i 

9 

test 

hive 

ringed 

f rom 

170 

t 0 

182 

mi 

c r o 8 

e c o nd s 

(«) 

- Results 

for 

t h i 

9 

test 

hive 

ringed 

f r om 

322 

t 0 

391 

mi 

croj 

e c o n d s 

(7) 

- Results 

for 

t h i 

9 

test 

hive 

ringed 

f rom 

3 3 1 

t 0 

360 

mi 

c r o s 

e c o nd s 


42 


Benchmarks- Ada 



RSD-12-80 


Subprojr im Or e r head (generic, cross package) 
Number of Iterations = 10000 * 10 


(mi 

Time |D 

croiec. ) | 

r e c t ion 
Passed 

# Passed 
in Call 

( Type 

| Passed 

| Site of 

(Passed Var 

I 

1 

I 

25.0 



0 

i 

1 

1 

1 

30.0 


I 

1 

j INTEGER 

1 

1 

1 

32.3 


O 

1 

j INTEGER 

1 


1 

32.8 


i_o 

1 

| INTEGER 


1 

1 

43.8 


I 

1 0 

j INTEGER 

1 

1 

1 

57.6 


O 

1 0 

j INTEGER 

1 

1 

1 

58.3 


1-0 

1 0 

| INTEGER 

1 


1 

185.2 


I 

100 

j INTEGER 

1 

1 

1 

335.0 


O 

100 

j INTEGER 

1 

1 

1 

360.1(1) 


i_o 

100 

| INTEGER 

1 

1 

1 

3 1.3 


I 

1 

(ENUMERATION 

1 

1 

1 

3 1.8 


O 

1 

(ENUMERATION 


1 

1 

32.8 


i_o 

1 

| ENUMERATION 

1 

1 

1 

44.3 


I 

1 0 

(ENUMERATION 

1 

1 

1 

58.0 


O 

10 

| ENUMERATION 

1 

( 

1 

50.0 


i_o 

1 0 

| ENUMERATION 

1 

1 

1 

183.8 


I 

100 

(ENUMERATION 

1 

1 

1 

338.6 


O 

100 

(ENUMERATION 

1 

1 

i 

334 .7(2) 


i_o 

100 

| ENUMERATION 

1 

1 

1 

31.4 


I 

1 

j ARRAY of INTEGER 

| 1 

1 

1 

33.2 


o 

1 

(ARRAY of INTEGER 

| 1 

1 

1 

33.2 


i_o 

1 

j ARRAY of INTEGER 

| 1 

1 

1 

3 1.2 


I 

1 

I ARRAY of INTEGER 

| 1 0 

1 

1 

3 1.1 


o 

1 

|ARRAY of INTEGER 

10 

1 

1 

3 1.2 


i_o 

1 

j ARRAY of INTEGER 

j 1 o 

1 

1 

3 1.5 


I 

1 

j ARRAY of INTEGER 

1 100 

1 

1 

3 1.5 


o 

1 

j ARRAY of INTEGER 

( 100 

1 

1 

3 1.5 


i _o 

1 

|ARRAY of INTEGER 

I ioo 

1 

1 

3 1.0 


I 

1 

(ARRAY of INTEGER 

j 10000 

1 

i 

3 1.0 


o 

1 

(ARRAY of INTEGER 

( 10000 

1 

1 

3 1.0 


i_o 

1 

(ARRAY of INTEGER 

| 10000 

1 

1 

3 1.4 


I 

1 

(RECORD of INTEGER 

1 1 

1 

1 

33.3 


o 

1 

j RECORD of INTEGER 

j 1 


1 

33.3 


i_o 

1 

(RECORD of INTEGER 

( 1 

1 

1 

3 1.3 


I 

1 

(RECORD of INTEGER 

i 100 

1 

1 

3 1.3 


o 

1 

j RECORD of INTEGER 

100 

1 

1 

3 1.2 


i_o 

1 

(RECORD of INTEGER 

( 100 

1 

(1) 

- Re s u 1 t s 

for this test bare ranged from 335 to 360 micros 

e c 

(2) 

- Results 

for this test hare ranged from 334 to 346 micros 

e c 


Benchmarks-Ada 


43 


RSD-12-88 


i 

Number of Iterttioig =s 10000 • 10 




Dynami c A 1 1 o c a t 

ion in a Declarat 

v e Re g i 

o n 


i 


Time 1# Declared 

! Type 



S i s e of 

1 

(mi 

c r o s e c . ) | 


] Declared 



Ob j e c t 

I 

1 

2.3 I 

1 

| Integer 





1 

7.4 j 

10 

j Integer 





1 

6.3 j 

100 

j Integer 




1 

1 

3.9 j 

1 

j S t r i ng 



1 

1 

1 

3.7 i 

1 

j S t r i ng 



1 0 

1 

1 

4.5 j 

1 

j S t r i ng 



100 

1 

1 

2.2 j 

1 

| En ume ration 




1 


0.8(1) | 

10 

| En ume ration 





1 

18.9(2) j 

100 

| En ume ration 




1 

1 

3.6 | 

1 

| Integer Array 



1 


1 

5.4 | 

1 

j Integer Array 



1 0 

1 

1 

5.5 j 

1 

| Integer Array 



100 

1 

1 

8.2(3) | 

1 

j Integer Array 



1000 

1 


12.2(4) | 

1 

{integer Array 



10000 

1 

I 

0.1(5) | 

1 

j Integer Array 



100000 

1 

1 

5.2 1 

1 

j Integer Array 



1000000 

1 

1 

30.9 j 

1 

| 1 -D Dynami c a 1 1 y 

bounded 

Array 

1 

! 

! 

30.7 | 

1 

j 1 -D Dynami ca 1 1 y 

bounded 

Array 

1 0 

1 

1 

45.8 j 

1 

j 2 -D Dynami ca 1 1 y 

bounded 

Array 

1 

1 

1 

45.6 | 

1 

j 2 -D Dynami ca 1 1 y 

bounded 

Array 

100 

1 

1 

59.2 j 

1 

j 3 -D Dynami ca 1 1 y 

bounded 

Array 

1 

1 

1 

59.0 ! 

1 

3-D Dynami ca 1 1 y 

bounded 

Array 

1000 

1 


2.1 j 

1 

[Record of Integer 


1 

1 


2.7 | 

1 

[Record of Integer 


1 0 

1 

1 

2.6 1 

1 

[Record of Integer 


100 

1 


Note: Times reported include any dell I oc> t ioi required upon leaving the sco 

of the declared variables. 


(i) - 

Other 

rnas 

have 

i n d i c a t e d 

that 

this 

value 

is 1.9 

m i 

c r o s 

e c o n d s . i 

(2) - 

Other 

runs 

have 

i nd i cat ed 

that 

this 

value 

is 1.9 

mi 

c r o s 

e c o n d s . < 

(3) - 

Other 

runs 

have 

i n d i c a t e d 

that 

this 

value 

is 6.1 

mi 

c r o s 

cconds . 

( 0 ( 5 ) 

- The 

s« t 

e s t s 

consistent 

1 y report 

ow v a 

u e s . 





44 


Ben chmar ks-Ad a 


RSD-12-88 


Number of I tent i on = 1 0000 


Dynamic Allocution with NEW nllocutor 



Time |# Declared 

(microsec. )j 

Type 

Declared 

| Site of 

| Ob j e c t 

1 

1 

! 

134 

1 

integer 

I 

1 

1 

1 

133 

1 

En ume ration 

1 

1 

1 

1 

140 

1 

Record of Integer 

1 

1 

1 

1 

211 

1 

Record of Integer 

1 

5 

1 

1 

203 

1 

Record of Integer 

1 

1 0 


1 

435 

1 

Record of Integer 

1 

20 

1 

1 

1 024 ( 1 ) 

1 

Record of Integer 

i 

50 

1 

1 

4847(2) 

1 

Record of Integer 

1 

100 

1 

I 

1 30 

1 

String 

1 

1 

1 


157 

1 

String 

1 

10 

1 

1 

303 

1 

String 

1 

1 00 

1 

1 

130 

1 

Integer Array 

1 

1 

I 

1 

283 

1 

Integer Array 

1 

10 

1 

1 

4048(3) 

1 

Integer Array 

1 

1 00 

1 


221 

1 

1-D Dynamically Bounded 

Array | 

1 

1 

1 

284 

1 

1-D Dynamically Bounded 

Array | 

10 

I 

1 

300 

1 

2-D Dynamically Bounded 

Array j 

1 

1 


4 782 ( 4 ) 

1 

2-D Dynamically Bounded 

Array j 

1 00 

1 

1 

326 

1 

3-D Dynamically Bounded 

Array j 

1 

1 


Note: 


Stortfe is 
results in 
iterations 


not reclaimed by calling UNCHECKED .DEAL LOCATION, this 
excessive disk paging for the noted cases. Runs with 
result in more accurate results with less precision. 


f ewe r 


(1) 

- When 

run 

with 

only 

(2) 

- When 

rn n 

with 

only 

(3) 

- When 

m n 

with 

only 

(<) 

- When 

ran 

with 

only 


100 

i t e rat 

ions 

this 

test 

100 

i t e ra t 

i o a s 

this 

test 

100 

i t e rat 

ions 

this 

test 

100 

i t e ra t 

ions 

this 

test 


y i 

i e 1 d s 

700 

microseconds 

y i 

i e 1 d s 

1200 

microsecond 

y i 

i e 1 d s 

1100 

mi crosecond 

y i 

■elds 

1200 

mi crosecond 


Benchmarks-Ada 


45 


RSD-12-80 


Number of Iterations = 10000 


ORIGINAL PAGE ts> 
OP POOR QUALITY 


Exception Handler Tests 


Ex c e 

p t i o n 

r ft i 

led and bandied in a bl 

ock 



0 

n S EC . 


User De f 

i ned , 

Not Rais 

e d 



345 

nSEC . 


User De f 

i n e d 





372 

nSEC. 


Cons t ri i 

n t Error, Imp I 

i c i t 1 y 

Ra i s 

e d 

356 

a S EC . 


Co n s t r a i 

nt Error, Expl 

i c i t 1 y 

Ra i s 

« d 

( 

1 ) 


Name r i c 

Error 

, imp 1 i c i 

t 1 y Ra 

i s e d 


301 

a SEC . 


Name r i c 

Error 

, Exp I i c i 

t 1 y Raised 


402 

nSEC . 


Tasking 

Error 

, Ex p 1 i c i 

t 1 y Ra 

i s e d 


Exception 

r ft i 

s e d in a 

procedure and 

handled in 

the 

0 

a S EC . 


User De f 

i n ed , 

No t Rais 

e d 



6 1 4 

a SEC . 


User Def 

i n e d 





654 

a SEC . 


Constrai 

n t Error, Imp 1 

i c i t 1 y 

Ra i s 

t d 

626 

nSEC. 


Co n s t rai 

n t E r 

r o r , Expl 

i c i t 1 y 

Ra i s 

c d 

2460 

nSEC. 


Name r i c 

Error 

, Imp 1 i c i 

t 1 y Ra 

i s e d 


670 

nSEC. 


Nnme r i e 

Error 

, Ex p 1 i c i 

t 1 y Ra 

i s e d 


67 1 

nSEC. 


Tasking 

Error 

, Ex p 1 i c i 

t 1 y Ra 

i i ed 


Th i s 

ctie 

i 9 

not band led co 

rrectly by the 

comp i 

1 er 


an i t 


46 


Benchmarks^ Ada 



RSD-12-86 


CMXmML PAGE IS 
OF POOR QUALITY 


Task Eliborate, Act irate, and Terminate Time: Declared Object, No Type 
Number of Iterations = 100 

For test gnmb e r 1 

Task elaborate, activate, terminate time: 19.6 milliseconds. 


Task Elaborate, Activate, and Terminate Time: Declared Object, Task Type 
Number of Iterations = 100 

For test nnmb e r 1 

Task elaborate, activate, terminate time: 19.6 milliseconds. 


Task Elaborate, Activate, and Terminate Time: NEW Object, Task Type 
Number of Iterations = 100 

For test numb e r 1 

Task elaborate, activate, terminate time: 17.4 milliseconds. 


Benchmsrks-Ada 


47 


RSD-12-86 


Rendeivooa Time: No Pirtmetera Passed 

Number of Iterations = 100 


Task Rendeivous Time: 3.5 milliseconds 


Benchmarks- Ada 


RSD-12-88 


Number of Itertl ion = 10000 


ORIGINAL rage is 
of POOR QUALITY 


Clock 

f I1C t 

i o n 

col 

line 

ore 

r h eod 

588 

mi 

croseconds 

Clock 

f on c t 

i o a 

col 

lias 

ore 

r h eod 

572 

mi 

croseconds 

Clock 

f no c t 

i o n 

col 

lias 

ore 

rbeod 

560 

mi 

croiecoids 

Clock 

f no c t 

i o & 

col 

lias 

0 YC 

rheod 

560 

mi 

croseconds 

Clock 

f one t 

i o n 

C 0 1 

lias 

o ye 

r h eod 

575 

mi 

croseconds 

Clock 

f no c t 

i o a 

col 

lias 

ore 

r keod 

578 

mi 

croseconds 

Clock 

f no c t 

i o a 

col 

1 i as 

ore 

rheod 

585 

mi 

croseconds 

Clock 

f nn c t 

i oa 

C 0 1 

l i as 

0 Y« 

rheod 

577 

mi 

croseconds 

Clock 

f met 

i o a 

col 

lias 

o y« 

rheod 

563 

mi 

croseconds 

Clock 

f nn c t 

i oa 

col 

lias 

O YC 

rheod 

575 

mi 

croseconds 

Clock 

f net 

i o a 

col 

lias 

o Ye 

rheod 

563 

mi 

croseconds 

Clock 

fnct 

i o a 

col 

lias 

O YC 

rheod 

560 

mi 

croseconds 

Clock 

( net 

i o a 

CO 1 

lias 

O YC 

rheod 

567 

mi 

croseconds 

Clock 

(net 

i o a 

col 

1 i as 

0 YC 

rheod 

675 

mi 

croseconds 

Clock 

f nn c t 

i o a 

c o 1 

lias 

0 YC 

rheod 

568 

mi 

croseconds 

Clock 

f noct 

i o a 

C 0 1 

lias 

0 YC 

rheod 

573 

mi 

croseconds 

Clock 

fnct 

i o a 

col 

1 i as 

0 YC 

rheod 

571 

mi 

croseconds 

Clock 

f nn c t 

i o a 

col 

lias 

0 YC 

rheod 

562 

mi 

croseconds 


i 


! 


\ 


Benchmarks- Ada 


49 


RSD-12-88 


Number of Iterations = 10000 • 10 


TIME snd DURATION ms t h 


Microseconds Operstion 


188.5 

Time 

: = 

Vsr_time + Vsr.dtrst i on 

231.8 

Time 

: = 

Vsr.t ime - Vsr.durs t ion 

226.8 

Time 

: = 

Vsr.dsrst ion + Vsr.t ime 

241.0 

T i me 

: — 

Vsr.t ime - Const.dnrstion 

111.3 

Du r n t 

i o a 


= Vsr.t ime - Vsr.t i me 

7 . 3 

Durst 

i o a 


= Vsr.durstion + Vsr.dtrst ion 

7 . 2 

Durst 

i o a 


= Vsr.durstion - Vsr.durstion 

7 . 6 

Durst 

i o a 


= Vsr.durstion + Const.dnrstion 

7 . 6 

Durst 

i o a 


— Vsr.durstion - Const.dnrstion 

7 . 7 

Durst 

i o a 


»* Const.dnrstion + Vsr.durstion 

7 . 7 

Durst 

i o a 


'= Const.dnrstion - Vsr.durstion 

1 . 2 

Durst 

i o a 


= Const.dnrstion + Const.dnrst i 

1 . 2 

Durst 

i o a 


= Const.dnrstion - Const.dnrst i 


o n 
o n 


50 


Ben ch m ar ks- Ad a 



RSD-12-86 


Delay S t a t erne a 
Namb er of Iter 

t Test 
a t i o a t 

• Min imam Delay Va 1 
=* 1 0000 « 10 

me 

For cate a omb e 
Desired delay 
Actaal delay t 

r 

time: 
i me : 

1 

0 . 000061 035 156250 
0 . 00 14 03808503750 

t e c o ad t . 
s e c o ad s . 

For cate aamb e 
Detired delay 
Actaal delay t 

r 

time: 
i me : 

2 

0.000122070312500 
0. 00 1403808503750 

t e c o a d t . 
t e c o ad t . 

For cate avmbe 
Detired delay 
Actaal delay t 

r 

t ime : 
» me : 

3 

0.000183105468750 

0.001403808503750 

s e co ad s . 
t e c o ad t . 

For cate aamb e 
Detired delay 
Actaal delay t 

r 

t ime : 
i me : 

4 

0.000244140625000 

0.001403808503750 

t e e o a d a . 
seconds . 

For cate aambe 
Desired delay 
Actaal delay t 

r 

time: 
i me : 

5 

0 . 00030517578 1250 
0 . 00 14038085037 50 

seconds . 
seconds . 

For case aambe 
Desired delay 
Actaal delay t 

r 

time: 
i me : 

6 

0.000366210037500 
0 . 00 1403808503750 

seconds . 
seconds . 

For cate aambe 
Detired delay 
Actaal delay t 

r 

time: 
i me : 

7 

0 . 000427246003750 
0. 00 1403808503750 

seconds . 
seconds . 

For cate aambe 
Desired delay 
Actaal delay t 

r 

time: 
i me : 

8 

0.000488281250000 

0.001403808503750 

seconds . 
seconds . 

For cate aambe 
Desired delay 
Actaal delay t 

r 

time: 
i me : 

0 

0 . 000640316406250 
0 . 001403808503750 

seconds . 
seconds . 

For cate aamb e 
Desired delay 
Actaal delay t 

r 

time: 
i me : 

1 0 

0.000610351562500 
0 . 00 1403808503750 

seconds . 
seconds . 

For cate aambe 
D e sired delay 
Actaal delay t 

r 

time: 
i me : 

1 1 

0 . 00067 1 38671 87 50 
0 . 00 1403808503750 

seconds . 
seconds . 

For cate aamb e 
Detired delay 
Actaal delay t 

r 

time: 
i me : 

1 2 

0 . 0007324 21 87 5000 
0 . 00 1 403808503750 

seconds . 
seconds . 

For cate aambe 
Detired delay 
Actaal delay t 

r 

t ime : 
i me : 

1 3 

0.000703457031250 

0.001403808503750 

seconds . 
seconds . 

For cate aamb e 
De tired delay 
Actaal delay t 

r 

t i me : 
i me : 

1 4 

0.000854402187500 
0 . 00 1403808503750 

seconds . 
seconds . 

For cate aamb e 
Desired delay 
Ac t a a 1 delay t 

r 

t i me : 
i me : 

1 5 

0.000015527343750 

0.001403808503750 

s e c o ad s . 
seconds . 

For cate aamb e 
Desired delay 
Actaal delay t 

r 

t i me : 
i me : 

1 6 

0.000076562500000 

0.001403808503750 

seconds . 
s e c o n d s . 


Benchmarks- Ada 


51 


RSD-12-86 


The f o 1 lowing remits tre consistent with the analysis given in the report. 
Reqiei t ed de I sjri betweei 1 mi I I i lecoid ud less thtt 10 mi I I i seconds resulted 
i n a c t u a I delays between 10 milliseconds and 1.01 seconds, that is, the raise 
remaining in the 1 second time slice pins lOmilliseconds. In general, a 
requested delay of D seconds results in an actual delay between D seconds and 
D+ 1 seconds. In all cases the actual delay is always greater than or equal to 
the requested delay, as required by the LRM. 

Delay Statement Test 
Number of Iterations = 1 


For case numb e r 

Desired delay time: 0 

Actual de I ay t i me : 1 

For case numb e r 

Desired delay time: 0 

Actual delay time: 0 

For case numb e r 

Desired delay time: 0 

Actual delay time: 0 

For case n umb e r 

Desired delay time: 0 

Actual delay time: 0 

For case numb e r 

Desired delay time: 0 

Actual delay time: 0 

For case numb e r 
Desired delay time: 0 

.Actual deity time: 0 

For case number 

De s i red de I ay t ime : 0 

Actual delay time: 0 

For case numb e r 

Desired delay time: 0 

Actual delay time: 0 

For case numb e r 

Desired delay time: 0 

Actual delay time: 0 

For case numb e r 

Desired delay time: 0 

Actual delay time: 0 

For case numb e r 

Desired delay time: 0 

Actual delay time: 0 

For case numb e r 

Desired delay time: 0 

Actual delay time: 0 

For case n umb e r 

Desired delay time: 0 

Actual delay time: 0 

For case numb e r 

Desired delay time: 0 

Actual delay time: 0 


1 


. 001 037 507 856250 
.000000000000000 

seconds 

seconds 

2 

. 002075 1 0531 2500 
. 720080468750000 

seconds 

seconds 

3 

.003112702068750 
. 750000000000000 

seconds 

seconds 

4 

. 004 1 503 00625000 
.250048730468750 

seconds 

seconds 

5 

. 0051 87 08828 1250 
. 33006582031 2500 

seconds 

seconds 

6 

. 006225585037500 
. 600051 1 71 875000 

seconds 

seconds 

7 

. 007263183503750 
. 850085351562500 

seconds 

seconds 

8 

.008300781250000 
. 000048730468750 

seconds 

seconds 

0 

. 000338378006250 
. 660082010156250 

seconds 

seconds 

10 

. 010375076562500 
. 460070703125000 

seconds 

seconds 

1 1 

. 011413574218750 
. 500075585037500 

seconds 

seconds 

1 2 

.012451 171875000 
. 540087702068750 

seconds 

seconds 

1 3 

.013488760531250 

.770068261718750 

seconds 

seconds 

1 4 

. 014526367187500 
.860005117187500 

seconds 

seconds 


52 


Benchmarks- Ada 



RSD-12-88 


Del&y Statement Test 
Number of Iteration* 


WlOflML RAGE B 
W POOR quauty 


For esse n omb e r 
Desired delny time: 
Actusl dels? time: 

1 

0 . 097858250000000 
1 . 000000000000000 

seconds . 
seconds . 

For esse numb e r 
Desired de 1 sy time: 
Actusl dels? time: 

2 

0. 195312500000000 
0.719970703125000 

seconds . 
seconds . 

For esse numb e r 
Desired delny time: 
Actusl d e 1 sy time: 

3 

0 . 292988750000000 
0 . 750000000000000 

seconds . 
seconds . 

For esse numb e r 
Desired delay time: 
Actusl d e 1 sy time: 

4 

0 . 390825000000000 
1 .259948730488750 

seconds . 
seconds . 

For esse numb e r 
Desired delsy time: 
Actusl delsy time: 

5 

0 . 488281250000000 
1 . 339965820312500 

seconds . 
seconds . 

For esse numb e r 
Desired delsy t ime : 
Actusl delsy time: 

6 

0.585937500000000 
0 . 709960937500000 

seconds . 
seconds . 

For esse number 
Desired delsy time: 
Actusl delsy time: 

7 

0.683593750000000 

0.859985351562500 

seconds . 
seconds . 

For esse number 
Desired delsy t ime : 
Actusl delsy time: 

8 

0 . 781250000000000 
0.949951171875000 

seconds . 
seconds . 

For esse numb e r 
Desired delsy t ime : 
Actusl delsy time: 

9 

0 . 878906250000000 
1 . 720980468750000 

seconds . 
seconds . 

For esse numb e r 
Desired delsy time: 
Actusl delsy time: 

10 

0 . 978562500000000 
1 . 469970703125000 

seconds . 
seconds . 

For esse numb e r 
Desired delsy time: 
Actusl delsy time: 

1 1 

1 . 074218750000000 
1 . 590975585937500 

seconds . 
seconds. 

For esse numbe r 
Desired delsy time: 
Actusl delsy time: 

1 2 

1 . 171875000000000 
1 . 549987792968750 

seconds . 
seconds . 

For esse numbe r 
Desired delsy t ime : 
Actusl delsy time: 

13 

1.269531250000000 
1 . 779968261718750 

seconds . 
seconds . 

For esse numbe r 
Desired delsy time: 
Actusl delsy time: 

1 4 

1 . 367187500000000 
1.869995117187500 

seconds . 
seconds . 

For esse numb e r 
Desired delsy time: 
Actusl delsy ti me : 

1 5 

1.4648437 50000000 
1.589965820312500 

seconds . 
seconds . 

For esse numb e r 
Desired delsy time: 
Actusl delsy time: 

16 

1.562500000000000 

2.269958496093750 

seconds . 
seconds . 


Benchmarks- Ada 


53 


RSD-12-86 


Delay Statement Teat 
Nnmber of Iterations = 1 


For case nimb e r 
Desired delay time: 
Aetna! delay time: 

1 

0 . 21 3823046875000 
1.000000000000000 

seconds . 
seconds . 

For case numb e r 
Desired delay time: 
Aetna! delay time: 

2 

0 . 427246003750000 
0 . 730000234375000 

seconds . 
seconds . 

For case nnmb e r 
Desired delay ti me : 
Ac t na 1 delay time: 

3 

0 . 640860140625000 
0 . 750000000000000 

seconds . 
seconds . 

For case n umb e r 
Desired delay t ime : 
Aetna! delay time: 

4 

0. 854492187500000 
1 . 260058406003750 

seconds . 
seconds . 

For case nnmb e r 
Desired delay time: 
Aetna! delay time: 

5 

1.0681 15234375000 
1 . 330065820312500 

seconds . 
seconds . 

For case n nmb e r 
Desired delay t ime : 
Actual delay time: 

6 

1 . 281738281250000 
1.600051171875000 

seconds . 
seconds . 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

7 

1 . 405361328125000 
1 . 850085351562500 

seconds . 
seconds . 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

8 

1.708084375000000 
1 . 030041406250000 

seconds . 
seconds . 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

0 

1 . 022607421875000 
2 . 729080468750000 

seconds . 
seconds . 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

1 0 

2. 136230468750000 
2. 460070703125000 

seconds . 
seconds . 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

1 1 

2 . 340853515625000 
2.600085351562500 

seconds . 
seconds . 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

1 2 

2 . 563476562500000 
3 . 550007558503750 

seconds . 
seconds . 

Fo r case nnmb e r 
Desired delay time: 
Actual delay t ime : 

1 3 

2 . 777000600375000 
2. 770068261718750 

seconds . 
seconds . 

For case nnmbe r 
Desired delay ti me : 
Actual delay time: 

1 4 

2 . 000722656250000 
3 . 850085351562500 

seconds . 
seconds . 

For case n nmb e r 
Desired delay time: 
Actual delay time: 

1 5 

3. 204345703125000 
3. 580065820312500 

seconds . 
seconds . 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

1 6 

3. 417068750000000 
4. 260058406003750 

seconds . 
seconds . 


54 


Ben cb m ar ks- Ad a 



RSD-12-88 


APPENDIX C 


The following pages contain result tables for all of the tests run. These results 
are for the Verdix Compiler Version 5.1 running with Unix 4.2 bsd on a Vax 11/780. 
Some values contain explanatory footnotes. 


Benchmarks- Ada 


55 


RSD-12-86 


Compiler Time Related Valves 


System T i c k= 0.000048730468750 Seconds 

Duration Sma I 1= 0.000061 035156250 Seconds 


56 


Benchmarks- Ada 


RSD-12-80 


Subprogram Overhead (loi-(eieric) 


Namber of 

Iterations 

=10000 • 

1 0 


T i me 


| D i r e c t ion 

# Passed 

1 Type 1 

Site of 

(microsec 

) 

Passed 

in Call 

j Passed jPassed Var 

10.8 



0 

1 1 


18.8 


I 

1 

j INTEGER j 


20.1 


O 

1 

| INTEGER 


19.2 


I _o 

1 

j INTEGER j 


29.3 


I 

10 

| INTEGER | 


4 2.2 


O 

1 0 

j INTEGER j 


4 5.3 


i_o 

10 

j INTEGER I 


168.4 


I 

100 

| INTEGER ! 


325.1 


o 

100 

j INTEGER | 


329.3 


i_o 

100 

| INTEGER 


16.5 


I 

1 

| ENUMERATION | 


17.6 


o 

1 

(enumeration j 


18.5 


i _o 

1 

(enumeration S 


29.7 


I 

1 0 

(enumeration j 


56.9 


o 

1 0 

(enumeration j 


59.5 


i_o 

1 0 

(enumeration s 


168.3 


I 

100 

(enumeration 


320.0 


o 

100 

(enumeration | 


326.6 


i _o 

100 

(enumeration ; 


16.9 


I 

1 

j ARRAY of INTEGER j 

1 

20.2 


0 

1 

(array of INTEGER j 

1 

19.2 


1.0 

1 

(ARRAY of INTEGER 

1 

19.2 


I 

1 

j ARRAY of INTEGER j 

1 0 

17.7 


o 

1 

(ARRAY of INTEGER I 

1 0 

18.9 


i_o 

1 

j ARRAY of INTEGER 

1 0 

19.6 


I 

1 

(ARRAY of INTEGER j 

100 

18.6 


o 

1 

j ARRAY of INTEGER i 

100 

18.6 


i _o 

1 

(ARRAY of INTEGER 

1 0 0 

19.1 


I 

1 

j ARRAY of INTEGER j 

10000 

17.7 


o 

1 

(ARRAY of INTEGER j 

1 0000 

19.4 


1-0 

1 

j ARRAY of INTEGER j 

10000 

18.7 


I 

1 

(RECORD of INTEGER j 

l 

19.2 


o 

1 

(RECORD of INTEGER j 

1 

19.4 


I _0 

1 

j RECORD of INTEGER i 

1 

17.4 


l 

1 

(RECORD of INTEGER j 

100 

19.8 


o 

1 

j RECORD of INTEGER j 

100 

17.8 


i _o 

1 

(RECORD of INTEGER i 

100 

21.2 


l 

1 

(unconstrained array i 

1 

2 1.1 


O 

1 

(unconstrained array i 

1 

2 1.2 


i _o 

1 

(unconstrained array j 

1 

2 1.2 


I 

1 

(unconstrained array j 

1 0 0 

21.1 


o 

1 

(unconstrained array j 

100 

2 1.2 


i _o 

1 

[UNCONSTRAINED array i 

100 

21.1 


I 

1 

(unconstrained array j 

10000 

21.1 


o 

1 

(unconstrained array j 

10000 

21.1 


i _o 

1 

[UNCONSTRAINED ARRAY j 

10000 

19.3 


I 

1 

(UNCONSTRAINED RECORD j 

1 

19.2 


o 

1 

(UNCONSTRAINED RECORD j 

1 

20.5 


i_o 

1 

(unconstrained RECORD 1 

1 

10.3 


I 

1 

(UNCONSTRAINED RECORD 1 

100 

19.1 


o 

1 

(UNCONSTRAINED RECORD 1 

100 

20.4 


i_o 

1 

(UNCONSTRAINED RECORD 1 

100 


Benchmarks- Ada 


57 


RSD-12-89 


Subpro; rim Overheid (inline) 
Number of Iterations = X0000 * 10 


( mi 

Time 
c r o s e c . ) 

Direction!# Passed 
Passed jin Ca 1 1 

1 Type 1 

i Passed j 

S i s e of 
Passed Var 

! 1: 

1 

0 . 4 

1 

0 

1 ! 


7 1 

1 

1 . 4 

I j 

1 

j INTEGER j 


1 1 


2 . 6 

o i 

1 

j INTEGER j 



1 

2 . 2 

1-0 

1 

j INTEGER | 


1 

1 

15.2 

i i 

1 0 

| INTEGER ; 


1 

1 

20.3 

O 

10 

| INTEGER j 



1 

30.4 

I.o I 

10 

j INTEGER j 


i ; 

1 

152.8 

I 1 

100 

j INTEGER | 


1 

1 

315.0 

o i 

100 

j INTEGER | 




381.4 

1-0 ! 

100 

j INTEGER j 


1 

1 

1 . 8 

i 

1 

j ENUMERATION j 



1 

2 . 5 

o i 

1 

j ENUMERATION j 



1 

2 . 5 

1-0 ! 

1 

j ENUMERATION j 


1 

1 

15.1 

i 

10 

j ENUMERATION j 


1 1 

1 

30.0 

O | 

1 0 

j ENUMERATION j 


1 

1 

30.0 

I.o 1 

1 0 

j ENUMERATION ! 


I 1 

1 

153.2 

I 

100 

[ENUMERATION 




311.8 

O j 

100 

j ENUMERAT I ON 




353.6 

i_o ! 

100 

j ENUMERATION | 


I ] 

1 

-0.1 

i I 

1 

j ARRAY of INTEGER j 

1 

1 


1 . 0 

o i 

1 

j ARRAY of INTEGER ! 

1 


1 

0 . 0 

I.o 1 

1 

| ARRAY of INTEGER 

1 


1 

0 . 3 

1 1 

1 

| ARRAY of INTEGER j 

1 0 

1 j 

1 

0 . 5 

o j 

1 

j ARRAY of INTEGER 

1 0 

! 1 

1 

0 . 5 

1-0 I 

1 

j ARRAY of INTEGER j 

1 0 


1 

0 . 0 

i j 

1 

j ARRAY of INTEGER \ 

1 0 0 



0 . 4 

o 1 

1 

(ARRAY of INTEGER | 

100 

1 


0 . 4 

I.o ! 

1 

j ARRAY of INTEGER j 

1 0 0 

1 


1 . 1 

i ! 

1 

j ARRAY of INTEGER ! 

10000 


1 

0 . 0 

o ! 

1 

j ARRAY of INTEGER ! 

10000 


1 

0 . 5 

i_o j 

1 

| ARRAY of INTEGER j 

10000 

1 1 

1 

0 . 4 

i : 

1 

j RECORD of INTEGER j 

1 


1 

0 . 0 

O i 

1 

j RECORD of INTEGER | 

1 


1 

0 . 2 

1-0 ; 

1 

j RECORD of INTEGER i 

1 

1 


0 . 4 

i 1 

1 

j RECORD of INTEGER j 

100 

i 1 

1 

0 . 6 

o j 

1 

j RECORD of INTEGER j 

100 

i 

1 

0 . 4 

I.o ! 

1 

| RECORD of INTEGER ! 

1 0 0 


1 

2 . 5 

I | 

1 

j UNCONSTRAINED ARRAY j 

1 


1 

2 . 5 

o | 

1 

j UNCONSTRAINED ARRAY j 

1 

1 

1 

2 . 5 

I.o ! 

1 

j UNCONSTRAINED ARRAY j 

1 

1 

1 

2 . 6 

i 1 

1 

j UNCONSTRAINED ARRAY | 

100 

1 

1 

2 . 6 

o j 

1 

j UNCONSTRAINED ARRAY j 

100 

1 

1 

2 . 5 

1-0 1 

1 

(unconstrained ARRAY j 

100 

1 

1 

2 . 1 

I 

1 

(unconstrained ARRAY ( 

10000 

1 

1 

2 . 6 

o 

1 

(unconstrained array ( 

10000 

1 

1 

1 . 1 

1-0 i 

1 

(unconstrained array j 

10000 

1 

1 

2 . 7 

I 1 

1 

[UNCONSTRAINED RECORD | 

1 

1 

1 

2 . 8 

o I 

1 

(unconstrained RECORD ( 

1 

1 

1 

2 . 7 

1-0 | 

1 

(UNCONSTRAINED RECORD j 

1 

1 

1 

2 . 0 

1 I 

1 

[UNCONSTRAINED RECORD j 

100 

1 

1 

2 . 7 

O ! 

1 

(UNCONSTRAINED RECORD j 

100 

1 

1 

2 . 7 

I.o 1 

1 

(unconstrained RECORD ( 

100 

1 


58 


Benchmarks- Ad a 



RSD-12-88 

ORIGINAL PAGE IS 

Subprogram Overhead (generic) rye POOR QUALITY 

Number of Iterations = 10000 • 10 


( 

T i me 

microsec . ) 

| D i r e c t i o n | 
[ Passed | 

# Passed 
in Call 

1 Type 

| Passed 

1 

1 

S i s e of 
Passed Var 

T 

1 

I 

18.5 


0 

1 


1 


T 

1 

21.6 

I 

1 

j INTEGER 


I 


1 


23.2 

O 

1 

| INTEGER 


1 


1 

! 

24.9 

I _o 

1 

| INTEGER 


1 


1 


34.4 

I 

1 0 

j INTEGER 


1 


1 

] 

48.9 

o 

1 0 

j INTEGER 


1 


1 

1 

49.1 

i_o 

1 0 

j INTEGER 


1 


1 

t 1 

173.4 

I 

100 

| INTEGER 


1 


1 


344.6 

o 

100 

| INTEGER 


1 


1 

| | 

333.5 

i_o 

100 

INTEGER 


1 


1 

1 

21.4 

I 

1 

| ENUMERATION 

1 


1 

i j 

24.6 

o 

1 

j ENUMERATION 

1 


t 

! I 

24.6 

i_o 

1 

| ENUMERATION 

1 


1 

j 

34.4 

I 

1 0 

| ENUMERATION 

1 


1 


50.0 

o 

10 

j ENUMERATION 

1 


1 

i i 

51.0 

1.0 

1 0 

| ENUMERATION 

1 


1 


173.1 

I 

100 

j ENUMERATION 



1 

1 | 

37 4.7 

o 

100 

j ENUMERATION 

1 


1 

i I 

359.4 

I o 

100 

ENUMERATION 

1 


I 


23.1 

I 

1 

ARRAY of 

INTEGER 

1 

1 

1 


23.3 

o 

1 

ARRAY of 

INTEGER 

1 

1 

! 


23.0 

i_o 

1 

ARRAY of 

INTEGER 

1 

1 

1 


22.5 

I 

1 

ARRAY of 

INTEGER 

1 

1 0 

1 

j i 

2 1.2 

o 

1 

ARRAY of 

INTEGER 

1 

1 0 

1 


23.9 

i_o 

1 

ARRAY of 

INTEGER 

1 

1 0 

1 

1 

26.3 

I 

1 

ARRAY of 

INTEGER 

1 

100 

1 


22.2 

o 

1 

ARRAY of 

INTEGER 

1 

100 

1 

| 

2 1.7 

i_o 

1 

ARRAY of 

INTEGER 

1 

100 

1 

! j 

23.4 

I 

1 

ARRAY of 

INTEGER 

1 

10000 

1 

i 

22.0 

o 

1 

ARRAY of 

INTEGER 

1 

1 0000 

1 


2 1.5 

I o 

1 

ARRAY of 

INTEGER 

1 

1 0000 

1 


22.0 

I 

1 

RECORD of 

INTEGER 

1 

1 

1 

i j 

23.8 

o 

1 

RECORD of 

INTEGER 

1 

1 

1 

j 

23.1 

i _o 

1 

RECORD of 

INTEGER 

1 

1 

1 

i 

23.0 

I 

1 

RECORD of 

INTEGER 

1 

100 

1 

i 

22.3 

o 

1 

RECORD of 

INTEGER 

1 

100 

1 

i 

2 1.7 

1.0 

1 

RECORD of 

INTEGER 

1 

100 

1 


j 

I 

I 


Benchm&rks-Ada 


59 


RSD-12-80 


Subprogram Overhead (cross package, non-generic) 
Number of Iterations = 10000 • 10 


T i me 

"|57 

r e c t i o n | # Passed| 

Type 

| Site 

o f | 

(microsec . 

)l 

Passed jin Call j 

Passed 

| Pa s s e d 

Var j 


17.81 I 0 


10.7 

1 

I 

1 

j INTEGER j 


20.2 

1 

O 

1 

j INTEGER 1 


10.0 

1 

i _o 

1 

j INTEGER j 


3 1.0 

1 

I 

10 

j INTEGER j 


46.3 

1 

o 

1 0 

j INTEGER j 


46.1 

1 

i_o 

1 0 

j INTEGER j 


170.0 

1 

I 

100 

j INTEGER j 


321.8 

1 

o 

100 

j INTEGER j 


322.0 

1 

i _o 

100 

j INTEGER j 


10.6 

1 

I 

1 

(enumeration j 


20.4 

1 

o 

1 

j ENUMERAT I ON i 


20.2 

1 

I _o 

1 

j ENUMERATION j 


33.4 

1 

I 

1 0 

j ENUMERAT I ON j 


46.4 

1 

o 

1 0 

j ENUMERAT I ON | 


46.4 

1 

I _o 

1 0 

(enumeration | 


160.8 

1 

I 

100 

(enumeration | 


32 4.5 

1 

o 

100 

(enumeration j 


321.1 

1 

i _o 

100 

(enumeration | 


10.7 

1 

I 

1 

(array of INTEGER | 

1 

20.7 

1 

o 

1 

(ARRAY of INTEGER | 

1 

20.7 

1 

i _o 

1 

(ARRAY of INTEGER 1 

1 

10.6 


I 

1 

(ARRAY of INTEGER | 

1 0 

10.1 


o 

1 

(ARRAY of INTEGER | 

1 0 

10.1 


I _o 

1 

j ARRAY of INTEGER j 

1 0 

10.6 

I 

I 

1 

(ARRAY of INTEGER j 

100 

10.1 

1 

o 

1 

j ARRAY of INTEGER | 

100 

10.1 


i _o 

1 

j ARRAY of INTEGER | 

100 

10.7 


I 

1 

j ARRAY of INTEGER j 

10000 

10.1 

1 

o 

1 

j ARRAY of INTEGER j 

10000 

10.2 


i _o 

1 

(ARRAY of INTEGER j 

10000 

10.0 

1 

I 

1 

(RECORD of INTEGER j 

1 

20 . S 

1 

o 

1 

(RECORD of INTEGER j 

1 

10.0 

1 

i_o 

1 

(RECORD of INTEGER j 

1 

10.8 

1 

I 

1 

(RECORD of INTEGER j 

100 

10.1 

1 

o 

1 

(RECORD of INTEGER ! 

100 

18.7 


i_o 

1 

j RECORD of INTEGER j 

100 

2 1.3 

1 

I 

1 

| UNCONSTRAINED ARRAY j 

1 

20.7 

1 

o 

1 

(unconstrained ARRAY ( 

1 

20.7 


1-0 

1 

(unconstrained ARRAY ( 

1 

21.2 

1 

I 

1 

(unconstrained array j 

100 

20.8 


o 

1 

(unconstrained array j 

10 0 

20.8 


1-0 

1 

(unconstrained array ( 

100 

21.3 


I 

1 

(unconstrained array j 

10000 

20.8 


o 

1 

(unconstrained array ( 

10000 

20.8 


i _o 

1 

(unconstrained array j 

1 0000 

20.3 

1 

I 

1 

(unconstrained RECORD ( 

1 

22.0 

1 

o 

1 

(unconstrained RECORD j 

1 

21.0 

1 

I _o 

1 

(unconstrained RECORD ( 

1 

20.3 

1 

I 

1 

| UNCONSTRAINED RECORD j 

100 

21.0 

1 

o 

1 

(unconstrained RECORD ( 

100 

21.0 

1 

I _o 

1 

j UNCONSTRAINED record j 

100 


80 


Benchmarks- Ada 


RSD-12-S8 


Subprogram Overhead (generic, cron package) 
Number of Iteration* = 10000 • 10 


T i me 

(microsec.) 

D i r e c t i o n | 
Passed | 

# Passed 
in Call 

i Type 

| Pas s e d 

1 s 

j Pas 

i x e of 
s e d Va r 

1 

1 

22.2 

1 

0 

1 

1 


1 

27.2 

I | 

1 

j INTEGER 

1 


1 

27.8 

O | 

1 

j INTEGER 

1 


1 

27.5 

1-0 1 

1 

j INTEGER 

1 


1 

30.3 

I i 

1 0 

| INTEGER 

1 


1 

53.6 

O I 

10 

j INTEGER 

I 


1 

53.4 

i_o I 

1 0 

j INTEGER 

1 


1 

180.1 

I i 

100 

j INTEGER 

1 


1 

328.6 

o I 

100 

j INTEGER 

1 


1 

330.3 

1-0 1 

100 

j INTEGER 

1 


1 

26.5 

I 

1 

j ENUMERATION 

1 


1 

26.0 

o 

1 

j ENUMERATION 

1 


1 

27.0 

i_o ! 

1 

j ENUMERATION 

1 


1 

38.0 

l 

1 0 

j ENUMERATION 

1 


1 

54.3 

o 

1 0 

| ENUMERATION 

1 


1 

53.4 

1-0 | 

1 0 

| ENUMERATION 

1 


1 

176.1 

I I 

100 

j ENUMERATION 

1 


1 

331.7 

O I 

100 

| ENUMERATION 

1 


1 

337.3 

1-0 i 

100 

j ENUMERATION 

1 


1 

26.8 

I 1 

1 

j ARRAY of INTEGER 

1 

1 

t 

27.7 

O ! 

1 

| ARRAY of INTEGER 

1 

1 

1 

27.6 

1-0 i 

1 

j ARRAY of INTEGER 

1 

1 

1 

27.2 

I | 

1 

| ARRAY of INTEGER 

1 

1 0 

t 

26.2 

O ! 

1 

j ARRAY of INTEGER 

1 

1 0 

1 

25.8 

1-0 | 

1 

| ARRAY of INTEGER 

1 

1 0 

1 

27.1 

I | 

1 

| ARRAY of INTEGER 

1 

100 

1 

26.3 

o i 

1 

| ARRAY of INTEGER 

1 

100 

1 

26.2 

1-0 i 

1 

j ARRAY of INTEGER 

1 

100 

1 

3 1.6 

I 1 

1 

(ARRAY of INTEGER 

1 

1 0000 

1 

27.0 

O ! 

1 

( ARRAY of INTEGER 

1 

1 0000 

1 

27.0 

I -O i 

1 

(ARRAY of INTEGER 

1 

1 0000 

1 

27.2 

I | 

1 

(RECORD of INTEGER 

i 

1 

1 

27.7 

o I 

1 

j RECORD of INTEGER 

1 

1 

1 

26.7 

1-0 j 

1 

j RECORD of INTEGER 

1 

1 

1 

27 . 2 

I 1 

1 

(RECORD of INTEGER 

1 

100 

1 

26.2 

o ! 

1 

j RECORD of INTEGER 

1 

100 

1 

26.2 

i_o 1 

1 

j RECORD of INTEGER 

1 

100 

1 


Benchmarks-Ada 


01 


RSD-12-80 


Nnmber of 

Iterations = 10000 

• 1 0 




Dynami c A1 1 o cat 

ion in a Declarative R eg i 

0 & 


T i me 

|# Declared 

1 Type 

1 

S i s e of 

(microsec. 

) 1 

| Declared 

1 

Ob j e c t 

0 . 0 

1 1 

| Integer 

1 


-1.3 

1 

j Integer 

1 

\ 

27.5(1) 

100 

j Integer 

1 


0 . 0 

1 1 

{String 

1 

1 

0 . 0 

j 1 

{String 

1 

10 

0 . 1 

1 l 

{String 

1 

100 j 

-0.5 

j l 

j Bn nme rat ion 

1 

I 

-1.8 

i 1 o 

j Bn nme rat ion 

1 


-1.5 

S ioo 

j Bn nme rat ion 

1 


0 . 1 

{ i 

{Integer Array 

1 

1 j 

1 . 0 

! 1 

j Integer Ar ray 

1 

10 

1 . 3 

i t 

{Integer Array 

1 

100 l 

-0.4 

j i 

{Integer Array 


1000 

143.0 

j i 

|l-D Dynamically bounded 

Array i 

1 

779.0 

| l 

jl-D Dynamically bounded 

Array | 

10 

148.9 

j i 

j 2 - D Dynamically bounded 

Array | 

1 

160.6 

| i 

|3-D Dynamically bounded 

Array j 

1 1 

-1.0 

| i 

jRecord of Integer 

1 

1 

-0.6 

j l 

{Record of Integer 

1 

10 1 

-0.8 

| i 

jRecord of Integer 

i 

100 

Note: Times reported include 

any deallocation required 

upon leaving the see 


of the declared variables. 

(l) - Other rita hace indicated that this raise is too small to meastre . 


62 


Ben chm ar ks~ Ad a 



RSD-12-88 


Number of I t ertt i om = 1000 



Dynamic Allocat 

ion with NEW a 1 locator 



Time |# 

( (microsec . ) j 

1 , 

Declared 

1 Type 

| Declared 

| Site of 

{ Ob j e c t 

230 | 

1 

| Integer 

1 

1 

230 i 

1 

| En ame ration 

1 

1 

2 4 0 | 

1 

| Record of Integer 

1 

1 

' 260 j 

1 

j Re co r d of Integer 

1 

5 

1 270 | 

1 

jRecord of Integer 

1 

1 0 

270 ' | 

1 

|Record of Integer 

1 

20 

310 | 

1 

{Record of Integer 

1 

50 

340 | 

1 

jRecord of Integer 

1 

100 

220 j 

1 

j S t r i a g 

1 

1 

230 | 

1 

j S t r i ng 

1 

1 0 

240 j 

1 

j Stri ag 

1 

100 

220 I 

1 

j Integer Array 

1 

1 

260 | 

1 

j Integer Array 

1 

1 0 

2 5 0 | 

1 

{integer Array 

1 

100 

270 j 

1 

{integer Array 

1 

1000 

200 j 

1 

jl-D Dynamically Bounded 

Array | 

1 

260 j 

1 

jl-D Dynamically Bounded 

Array | 

1 0 

280 | 

1 

j 2 - D Dynamically Bounded 

Array | 

1 

1140 | 

1 

j 2 - D Dynamically Bounded 

Array | 

100 

300 j 

1 

js-D Dynamically Bounded 

Array 1 

1 

3370 j 

1 

j a - D Dynamically Bounded 

Array j 

1000 


Note: The time* reported include the time required to deallocate objects. 
This Ten i od of the compiler does deallocate memory when 
UNCHECKED.DEAL LOCATION is called. 


i 


i 


i 


Benchmarks-Ada 


63 


RSD-12-88 


Number of Iterations = 10000 


Exception Handler Tests 


Exception raised and handled 


a block 

0 nSEC. User Defined, Not Raised 

315 nSEC. User Defined 

343 nSEC. Constraint Error, Implicitly Raised 

325 nSEC. Constraint Error, Explicitly Raised 

(1) Numeric Error, Implicitly Raised 

361 nSEC. Numeric Error, Explicitly Raised 

372 nSEC. Tasking Error, Explicitly Raised 

Exception raised in a procedure and handled in th< 

1 nSEC. User Defined, Not Raised 

544 nSEC. User Defined 

574 nSEC. Constraint Error, Implicitly Raised 

555 nSEC. Constraint Error, Explicitly Raised 

2551 nSEC. Numeric Error, Implicitly Raised 

590 nSEC. Numeric Error, Explicitly Raised 

613 nSEC. Tasking Error, Explicitly Raised 


- This case is not handled correctly 


the c omp i I e r 


Benchmarks- Ada 


RSD-12-88 


Task Elaborate, Activate, a ad Terminate Time: 
Number of Iteration* = 100 


Dec 


ared Object, No Type 


For test iamb e r 1 

Task elaborate, activate, terminate time: 


20.4 milliseconds. 


Task Elaborate, Activate, and Terminate Time: Declared Object, Task Type 
Number of Iterations =* 100 

For test numb e r 1 

Task elaborate, activate, terminate time: 20.5 milliseconds. 


Task Elaborate, Activate, and Terminate Time: NEW Object, Task Type 
Number of Iterations = 100 

For test nambe r 1 

Task elaborate, activate, terminate time: 17.5 milliseconds. 


Benchmarks-Ada 


05 


RSD-12-88 


RendeiYom Time: No Parameters Pasted 

Number of Iterations = 100 


Task Rendeirots Time: 3.4 milliseconds 


86 


Benchmarks* Ada 


RSD-12-86 


Number of Iterations = 10000 


Clock 

(net ion 

C ft II 

i ng 

oTerbetd 

3488 

mi croseconds 

Clock 

f nn c t ion 

C ft I I 

i ng 

ore rhead 

3554 

mi croseconds 

Clock 

f nn c t ion 

c & II 

i ng 

ore r head 

3588 

mi croseconds 

Clock 

f nn c t ion 

C ft 1 1 

i ng 

ore rhead 

3500 

mi croseconds 

Clock 

function 

C ft 1 1 

i ng 

orerhead 

3608 

mi croseconds 

Clock 

f nn c t ion 

C ft 1 1 

i ng 

ore rhead 

3560 

mi croseconds 

Clock 

function 

C ft 1 1 

i ng 

ore rhead 

3565 

mi croseconds 

Clock 

f un c t ion 

C ft 1 1 

i ng 

ore rhead 

3600 

mi croseconds 


Benchmarks-Ada 


87 



RSD-12-80 


Number of Iterations = 10000 • 10 


TIME »nd DURATION m» t h 

Microseconds Operntion 

716.0 Time := V*r_time + V»r_dnrntion 

750.0 Time := Var_time - Vsr.dont ion 

774.0 Time := V»r_dnr»tion + V»r_time 

756.1 Time :== V»r_time + Cosst.dsrst ion 

812.5 Time : = V»r_t ime • Const.dsrst ios 

770.3 Time := Const.dont ion + V»r_time 

40.6 Dnrntion : = Vsr.t ime - Vi r_t ime 

6.3 Dnrntion := Vnr_dnrition + Vnr_durntion 

0.0 Dnrntion := Vtr.dintion - Vir.dorit ion 

6.8 Duration := Vir.dintion + Const.dsrst i on 

6.3 Duration : =* Vir.dsrst ios - Coss t.dsnt i on 

6.3 Dsrtt i on :=» Const.dsrst ion + Vsr.dsrst i on 

7.3 Dsrstion ■,= Const.dsrst i on • Vsr.dsrst ion 

1.1 Dsrstion : = Const _dnrnt ion + Const.dsrst ion 

1.6 Dsrstion Const.dsrstion - Cosst.dsrst ios 


i 


68 


Benchmarks- Ada 


RSD-12-80 


Tike following milti ire cogiiittitvitb the a a i 1 y a i s given in the report. 
Reqneated delaya between lmilliaecondnnd leaa thin lOmilliaeconds roil ted 
inictml d e I i y a between lOmiliiaeconda ud 1.01 aeconda , thit ia, thevilne 
r emi ining in the 1 aecond time alieeplna lOmiliiaeconda. Ingenenl, i 
reqneated deluy of D aeconda real I t i intnictuil deity between D aeconda tnd 
D+l aeconda . In tl I ctaea the ictml deity ia tlwtya greater thin or eqntl to 
the reqneated deity, ta reqneated by the LRM. 


Deity Statement Teat 
Nnmber of Iterationa = 1 


For c a a e nnmb e r 
Deaired delay time: 
Actual delay time: 

1 

0 . 001037507656250 
0 . 039041408250000 

aeconda 

aeconda 

For c a a e nnmb e r 
Deaired delay time: 
Actual delay time: 

2 

0.002075195312500 
0 . 850073144531250 

aeconda 

aeconda 

For c a a e nnmb e r 
Deaired delay time: 
Actual delay ti me : 

3 

0.0031 1 2702088750 
0.670002675781250 

aeconda 

aeconda 

For caae n nmb e r 
Deaired delay time: 
Actual delay time: 

4 

0.004150390625000 
0 . 050907558503750 

aeconda 

aeconda 

For caae nnmb e r 
Deaired delay time: 
Actual delay time: 

5 

0 . 005187088281250 
0 . 550036523437500 

aeconda 

aeconda 

For caae nnmb e r 
Deaired delay time: 
Actual delay time: 

8 

0 . 006225585037500 
0 . 630053613281250 

aeconda 

aeconda 

For caae nnmb e r 
Deaired delay time: 
Aetna! delay time: 

7 

0 . 007263183503750 
0.770068261718750 

aeconda 

aeconda 

For caae nnmb e r 
Deaired delay time: 
Actual delay ti me : 

8 

0.008300781250000 
0 . 860034082031250 

aeconda 

aeconda 

For caae nnmb e r 
Deaired delay time: 
Actual delay time: 

0 

0.000338378006250 

0.650073144531250 

aeconda 

aeconda 

For caae nnmber 
Deaired delay ti me : 
Actual delay time: 

1 0 

0 . 01 0375076562500 
0. 400073144531250 

aeconda 

aeconda 

For caae nnmber 
Deaired delay time: 
Actual delay time: 

1 1 

0.011413574218750 
0 . 539078027343750 

aeconda 

aeconda 

For caae nnmbe r 
Deaired delay time: 
Aetna! delay time: 

1 2 

0.012451171875000 
0. 480090234375000 

aeconda 

aeconda 

For caae nnmb e r 
Deaired delay time: 
Actual delay time: 

1 3 

0.013488759531250 
0 . 700960037500000 

a e c o id a 
aeconda 

For caae nnmbe r 
Deaired delay time: 
Aetna) delay time: 

1 4 

0.014526367187500 
0 . 780078027343750 

aeconda 

aeconda 


Benchmarks-Ada 


69 


RSD-12-80 


Delay Statement Test 
Number of Iterations = 

1 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

1 

0 . 007656250000000 
0. 040002441406250 

For case n nmb e r 
Desired delay time: 
Aetna) delay ti me : 

2 

0 . 105312500000000 
0.660005214843750 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

3 

0 . 202068750000000 
0 . 600063476562500 

For case nnmber 
Desired delay time: 
Actual delay ti me : 

4 

0 . 300625000000000 
1.210083007812500 

For case nnmb e r 
Desired delay time: 
Actual delay ti me : 

5 

0. 488281250000000 
1.300048828125000 

For case numb e r 
Desired delay time: 
Actual delay time: 

6 

0 . 585037500000000 
0 . 640075683503750 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

7 

0 . 683503750000000 
0 . 700100007656250 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

8 

0.781250000000000 
0 . 880004882812500 

For case nnmb e r 
Desired delay time: 
Actual delay ti me : 

0 

0 . 878006250000000 
1 . 660005214843750 

For case n nmb e r 
Desired delay time: 
Actual delay ti me : 

1 0 

0 . 076562500000000 
1 . 420104080468750 

For case nnmb e r 
Desired delay ti me : 
Actual delay time: 

1 1 

1 . 074218750000000 
1 . 560058503750000 

For ease nnmbe r 
Desired delay ti me : 
Actual delay time: 

1 2 

1.171875000000000 
1 . 500061035156250 

For case n nmb e r 
Desired delay ti me : 
Actual delay ti me : 

1 3 

1 . 260531250000000 
1 . 720002773437500 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

1 4 

1 . 367187500000000 
1 . 810058503750000 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

1 5 

1 . 464843750000000 
1 . 530000332031250 

For case nnmb e r 
Desired delay time: 
Act ua 1 delay time: 

1 6 

1 . 562500000000000 
1 . 610046386718750 


seconds . 
seconds . 

seconds . 
seconds . 

seconds . 
seconds . 

seconds . 
seconds . 


seconds . 
seconds . 

seconds . 
seconds . 

seconds . 
seconds . 


seconds . 
seconds . 

seconds . 
seconds . 

seconds . 
seconds . 


seconds . 
seconds . 


seconds . 
seconds . 


seconds . 
seconds . 


seconds . 
seconds . 


seconds . 
seconds . 


seconds . 
seconds . 


70 


Benchmarks- Ada 


RSD-12-88 


Delay Statement Test 
Number of Iterations 

= 1 


For case n umb e r 
Desired delay time: 
Actual delay time: 

1 

0.213823046875000 
0. 950012207031250 

seconds . 
seconds . 

For case numb e r 
Desired delay time: 
Actual delay time: 

2 

0 . 4272 46003750000 
0 . 67999267578 1 250 

seconds . 
seconds . 

For case numb e r 
Desired delay time: 
Actual delay ti me : 

3 

0 . 6408 69140625000 
0. 7000 1220703 1250 

seconds . 
seconds . 

For case numb e r 
Desired delay time: 
Actual delay ti me : 

4 

0 . 8544 92187 500000 

1 . 229980468750000 

seconds . 
seconds . 

For case numbe r 
Desired delay time: 
Actual delay time: 

5 

1.0681 1 523437 5000 
1.299987792968750 

seconds . 
seconds . 

For case numb e r 
Desired delay time: 
Actual delay time: 

6 

1 . 2817 38281250000 
1 . 6500244 14062500 

seconds . 
seconds . 

For case n umb e r 
Desired delay time: 
Actual delay time: 

7 

1 . 495361 328 125000 
1.790087792968750 

seconds . 
seconds . 

For case numb e r 
Desired delay time: 
Actual delay time: 

8 

1.708984375000000 
1 . 88000488281 2500 

seconds . 
seconds . 

For case number 
Desired delay time: 
Actual delay time: 

9 

1 . 922607421875000 
2.669982910156250 

seconds . 
seconds . 

For case numb e r 
Desired delay ti me : 
Actual delay time: 

1 0 

2 . 136230468750000 
2 . 42999267578 1250 

seconds . 
seconds . 

For case numb e r 
Desired delay time: 
Actual delay time: 

1 1 

2.349853515625000 
2 . 55099755859 37 50 

seconds . 
seconds . 

For case numb e r 
Desired delay time: 
Actual delay time: 

1 2 

2 . 563476562500000 
3.510009765625000 

seconds . 
seconds . 

For case numb e r 
Desired delay time: 
Actual delay time: 

1 3 

2 . 77709960937 50 00 
2. 7 1 9970703 1 25000 

seconds . 
seconds . 

For case numb e r 
Desired delay time: 
Ac t ua 1 delay t i me : 

1 4 

2.990722856250000 

3.809997558593750 

seconds . 
seconds . 

For case n umb e r 
Desired delay time: 
Ac t ua 1 delay t i me : 

1 5 

3.204345703125000 

3.539978027343750 

seconds . 
seconds . 

For case numbe r 
Desired delay time: 
Actual delay time: 

1 6 

3 . 4 1 7968750000000 

4 . 22998046875 0000 

seconds . 
seconds . 


Benchmarks-Ada 


71 



RSD-12-88 


APPENDIX D 


The following pages contain result tables for all of the tests run. These results 
are for the Verdix Compiler Version 5.2 running with Unix 4.2 bsd on a Vax 11/780. 


72 


Bench marks- Ad a 



RSD-12-88 


Compiler Time Related Vi I aei 


System Tick= 0.000948730468750 Seconds 

Durst i os Smnll= 0.000061035X56250 Seconds 


Benchm&rks-Ada 


73 



RSD-12-88 


Subprogram Ore r he ad (non-generic) 
Number of Iterations — 10000 


T i me 

|Direction|# Passed| 

Type 

| Sire 

of | 

(microsec . 

) ] Passed jin Ca 1 i j 

Pa s s ed 

j Pa s s ed 

Var j 


1 

17 


1 

0 



1 

1 8 

I 

1 

1 

INTEGER i 


1 

20 

O 

1 

1 

INTEGER j 


1 

1 8 

1.0 

1 

1 

INTEGER j 


1 

20 

I 

1 

10 

INTEGER j 


1 

42 

o 

1 

1 0 

INTEGER j 



48 

i _o 

1 

1 0 

INTEGER j 


1 

160 

I 


100 

INTEGER j 


1 

336 

o 

1 

100 

INTEGER j 



461 

i _o 


100 

INTEGER j 


1 

1 6 

I 

1 

1 

ENUMERATION j 


1 

1 8 

o 

1 

1 

ENUMERATION | 


1 

1 0 

i _o 

1 

1 

ENUMERATION j 



30 

I 


10 

ENUMERATION j 



43 

o 

1 

10 

ENUMERATION j 



4 3 

1-0 

1 

1 0 

ENUMERATION j 


1 

17 1 

I 

1 

100 

ENUMERATION j 


1 

328 

o 


100 

ENUMERATION j 


! 

335 

1-0 


100 

ENUMERATION | 


1 

1 6 

I 


1 

ARRAY of INTEGER j 

1 

1 

20 

o 

1 

1 

ARRAY of INTEGER j 

1 

1 

1 0 

1.0 

1 

1 

ARRAY of INTEGER j 

1 

1 

1 0 

I 

1 

1 

ARRAY of INTEGER j 

1 0 


1 8 

o 

1 

1 

ARRAY of INTEGER j 

1 0 

1 

1 0 

i _o 

1 

1 

ARRAY of INTEGER j 

1 0 

1 

1 0 

I 

1 

1 

ARRAY of INTEGER j 

100 

1 

18 

o 


1 

ARRAY of INTEGER j 

100 

1 

1 0 

i_o 

1 

1 

ARRAY of INTEGER j 

100 

1 

1 8 

I 


1 

ARRAY of INTEGER j 

10000 


1 8 

o 


1 

ARRAY of INTEGER j 

10000 


1 0 

i _o 

1 

1 

ARRAY of INTEGER 

10000 


1 0 

I 

1 

1 

RECORD of INTEGER j 

1 

1 

1 0 

o 

1 

1 

RECORD of INTEGER j 

1 

1 

1 0 

i _o 

1 

1 

RECORD of INTEGER j 

1 

1 

1 7 

I 

1 

1 

RECORD of INTEGER j 

100 

1 

1 0 

o 


1 

RECORD of INTEGER j 

100 


1 8 

1-0 


1 

RECORD of INTEGER 

10 0 

1 

2 1 

I 

1 

1 

UNCONSTRAINED ARRAY j 

1 

1 

22 

o 

1 

1 

UNCONSTRAINED ARRAY | 

1 

1 

21 

i _o 

1 

1 

UNCONSTRAINED ARRAY j 

1 

1 

2 1 

I 

1 

1 

UNCONSTRAINED ARRAY j 

100 

1 

20 

o 

1 

1 

UNCONSTRAINED ARRAY j 

100 

1 

21 

1.0 

1 

1 

UNCONSTRAINED ARRAY j 

100 

1 

21 

I 

1 

1 

UNCONSTRAINED ARRAY | 

10000 

1 

2 1 

o 


1 

UNCONSTRAINED ARRAY j 

10000 

1 

22 

i_o 


1 

UNCONSTRAINED ARRAY j 

10000 

1 

1 0 

I 


1 

UNCONSTRAINED RECORD | 

1 

1 

1 0 

o 


1 

UNCONSTRAINED RECORD j 

1 

1 

2 1 

i _o 

1 

1 

UNCONSTRAINED RECORD | 

1 

1 

20 

I 

1 

1 

UNCONSTRAINED RECORD j 

100 

1 

1 0 

o 

1 

1 

UNCONSTRAINED RECORD j 

100 

1 

20 

1.0 

! 

1 

UNCONSTRAINED RECORD j 

100 


74 


Benchmarks- Ada 



RSD-12-86 


Subprogram Overhead (ialiae) 
Number of Iteration = 10000 


T i me 

(microsec.) 

D i r e c t i o a 
Passed 

# Passed 
i a Call 

Type | Siie o 

Passed IPassedV 

0 


0 

I 


1 

I 

1 

INTEGER j 


3 

O 

1 

INTEGER | 


3 

1-0 

1 

INTEGER j 


1 5 

I 

10 

INTEGER j 


30 

o 

1 0 

INTEGER j 


30 

I _o 

1 0 

INTEGER j 


ISO 

I 

100 

INTEGER | 


471 

o 

100 

INTEGER j 


310 

i _o 

100 

INTEGER j 


1 

I 

1 

ENUMERATION | 


2 

o 

1 

ENUMERATION j 


3 

i _o 

1 

ENUMERATION | 


1 4 

I 

10 

ENUMERATION | 


3 1 

o 

1 0 

ENUMERATION j 


3 1 

i _o 

1 0 

ENUMERATION | 


153 

I 

100 

ENUMERATION j 


3 1 S 

o 

100 

ENUMERATION j 


3 1 1 

1-0 

100 

ENUMERATION j 


0 

I 

1 

ARRAY of INTEGER | 

1 

1 

o 

1 

ARRAY of INTEGER | 

1 

0 

I.o 

1 

ARRAY of INTEGER j 

1 

1 

I 

1 

ARRAY of INTEGER j 

1 0 

1 

o 

1 

ARRAY of INTEGER j 

1 0 

0 

1.0 

1 

ARRAY of INTEGER | 

1 0 

1 

I 

1 

ARRAY of INTEGER j 

100 

1 

o 

1 

ARRAY of INTEGER j 

100 

1 

i_o 

1 

ARRAY of INTEGER | 

100 

0 

I 

1 

ARRAY of INTEGER | 

10000 

1 

o 

1 

ARRAY of INTEGER j 

10000 

2 

t _o 

1 

ARRAY of INTEGER | 

10000 

0 

I 

1 

RECORD of INTEGER j 

1 

1 

o 

1 

RECORD of INTEGER | 

1 

0 

i_o 

1 

RECORD of INTEGER j 

1 

0 

I 

1 

RECORD of INTEGER | 

100 

1 

o 

1 

RECORD of INTEGER | 

100 

1 

i _o 

1 

RECORD of INTEGER | 

100 

2 

I 

1 

UNCONSTRAINED ARRAY | 

1 

3 

o 

1 

UNCONSTRAINED ARRAY | 

1 

3 

i _o 

1 

UNCONSTRAINED ARRAY | 

1 

2 

I 

1 

UNCONSTRAINED ARRAY j 

100 

3 

o 

1 

UNCONSTRAINED ARRAY | 

100 

3 

i _o 

1 

UNCONSTRAINED ARRAY j 

100 

2 

I 

1 

UNCONSTRAINED ARRAY | 

10000 

1 

o 

1 

UNCONSTRAINED ARRAY j 

10000 

3 

i _o 

1 

UNCONSTRAINED ARRAY j 

10000 

3 

I 

1 

UNCONSTRAINED RECORD j 

1 

3 

o 

1 

UNCONSTRAINED RECORD j 

1 

3 

1-0 

1 

UNCONSTRAINED RECORD | 

1 

2 

I 

1 

UNCONSTRAINED RECORD | 

100 

3 

o 

1 

UNCONSTRAINED RECORD j 

100 

3 

1-0 

1 

UNCONSTRAINED RECORD | 

100 


Benchmarks-Ada 


75 


RSD-12-86 


Subprogram Orerheid (generic) 
Number of Iterations = 10000 


T i me 

(microsec.) 

| D i r e c t ion 
j Psssed 

# Pissed 
i n Ci I I 

1 Type 

| Pissed 

j Si 

j Pi s s 

t e of 
ed Vir 

T 

1 

20 

1 

0 

1 


1 


1 

2 1 

1 I 

1 

| INTEGER 


1 


1 

22 

i o 

1 

| INTEGER 


I 


1 

2 4 

! i_o 

1 

| INTEGER 


1 


I 

35 

1 i 

10 

1 INTEGER 


1 


1 

50 

! O 

1 0 

| INTEGER 


1 


1 

40 

1 1-0 

10 

! INTEGER 


1 


1 

173 

1 I 

100 

j INTEGER 


1 



347 

1 O 

100 

j INTEGER 





480 

1 1-0 

100 

j INTEGER 





2 1 

1 I 

1 

(ENUMERATION 

1 


I 

24 

i O 

1 

(ENUMERATION 

1 


1 

24 

1 1-0 

1 

(ENUMERATION 

1 


1 

35 

1 I 

1 0 

ENUMERATION 

! 


1 

40 

! o 

1 0 

| ENUMERAT I 

ON 

1 


1 

52 

! i-o 

1 0 

(ENUMERATION 

1 


1 

176 

1 i 

100 

(ENUMERATION 

1 


1 

538 

! o 

100 

(ENUMERATION 




3 1 8 

! i.o 

100 

ENUMERAT I ON 

1 


1 

24 

1 I 

1 

(ARRAY of 

INTEGER 

1 

1 

1 

23 

I o 

1 

(ARRAY of 

INTEGER 


1 

1 

23 

! i.o 

1 

(ARRAY of 

INTEGER 


1 

1 

22 

! I 

1 

j ARRAY of 

INTEGER 

1 

1 0 

1 

2 1 

1 o 

1 

j ARRAY of 

INTEGER 

I 

1 0 

1 

24 

1 1-0 

1 

j ARRAY of 

INTEGER 

1 

1 0 

1 

23 

1 i 

1 

j ARRAY of 

INTEGER 

1 

100 

1 

22 

1 O 

1 

(ARRAY of 

INTEGER 

1 

100 

1 

22 

1 1-0 

1 

(ARRAY of 

INTEGER 

1 

10 0 

1 

24 

1 I 

1 

j ARRAY of 

INTEGER 

! l 

0000 

1 

23 

i O 

1 

(ARRAY of 

INTEGER 

j l 

0000 

1 

2 1 

[ I o 

1 

(ARRAY of 

INTEGER 

( l 

0000 

1 

23 

! i 

1 

(RECORD of 

INTEGER 

1 

1 

1 

23 

! o 

1 

| RECORD of 

INTEGER 

1 

1 

1 

23 

1 1-0 

1 

(RECORD of 

INTEGER 

1 

1 

1 

23 

1 I 

1 

(RECORD of 

INTEGER 

1 

100 

1 

23 

i o 

1 

(RECORD of 

INTEGER 

I 

100 

1 

22 

1 1-0 

1 

(RECORD of 

INTEGER 

1 

100 

1 


76 


Benchmarks- Ada 



RSD-12-80 


Snbproghram Overhead (cross package, non-generic) 
Number of Iterations = 10000 


T i me 

(microsec.) 

D i r e c t i o n | 
Passed j 

# Passed 
in Call 

1 Type 

j Passed 

Site of | 
Passed Varj 

1 8 

1 

0 

1 


20 

I i 

1 

j INTEGER 


20 

•o i 

1 

j INTEGER 


20 

1.0 i 

1 

j INTEGER 


32 

I 1 

1 0 

| INTEGER 


47 

o I 

10 

j INTEGER 


48 

1-0 l 

1 0 

j INTEGER 


170 

I i 

100 

j INTEGER 


324 

o 

100 

j INTEGER 


323 

I_0 1 

100 

j INTEGER 


20 

I 1 

1 

j ENUMERATION 


2 1 

O I 

1 

| ENUMERATION 


20 

1-0 1 

1 

j ENUMERATION 


3 1 

I i 

1 0 

j ENUMERATION 


48 

O ! 

1 0 

j ENUMERATION 


46 

1-0 i 

1 0 

| ENUMERATION 


17 1 

I I 

100 

| ENUMERATION 


324 

o i 

100 

j ENUMERATION 


323 

1-0 1 

100 

j ENUMER AT I ON 


20 

I j 

1 

j ARRAY o f I NT EGER 

1 

2 1 

o | 

1 

| ARRAY of INTEGER 

1 

21 

1-0 | 

1 

j ARRAY of INTEGER 

1 

1 9 

I 1 

1 

j ARRAY of INTEGER 

1 0 

20 

o 1 

1 

j ARRAY of INTEGER 

1 0 

10 

1-0 i 

1 

j ARRAY of INTEGER 

10 

20 

1 i 

1 

| ARRAY of INTEGER 

100 

20 

o l 

1 

j ARRAY of INTEGER 

100 

1 0 

1-0 j 

1 

j ARRAY of INTEGER 

100 

19 

I 1 

1 

| ARRAY of INTEGER 

10000 

18 

o ( 

1 

| ARRAY of INTEGER 

10000 

1 8 

1-0 1 

1 

(ARRAY of INTEGER 

10000 

1 9 

I 1 

1 

j RECORD of INTEGER 

1 

2 l 

o I 

1 

(RECORD of INTEGER 

1 

20 

1-0 ! 

1 

j RECORD of INTEGER 

1 

1 9 

I I 

1 

(RECORD of INTEGER 

100 

1 9 

o 1 

1 

j RECORD of INTEGER 

100 

1 9 

1-0 1 

1 

(RECORD of INTEGER 

100 

22 

I 1 

1 

(UNCONSTRAINED ARRAY 

1 

2 1 

o j 

1 

(unconstrained ARRAY 

1 

21 

1-0 1 

1 

(unconstrained ARRAY 

1 

21 

I 1 

1 

(unconstrained array 

100 

20 

o 1 

1 

j UNCONSTRA 1 NED ARRAY 

100 

2 1 

1-0 1 

1 

(unconstrained ARRAY 

100 

21 

I 1 

1 

(UNCONSTRAINED ARRAY 

1 0000 

21 

o i 

1 

j UNCONSTRA I NED ARRAY 

10000 

2 1 

1-0 ! 

1 

(UNCONSTRAINED ARRAY 

10000 

20 

I i 

1 

(UNCONSTRAINED RECORD 

1 

2 1 

o i 

1 

(UNCONSTRAINED RECORD 

1 

21 

1-0 i 

1 

(UNCONSTRAINED RECORD 

1 

20 

1 i 

1 

(UNCONSTRAINED RECORD 

100 

20 

o i 

1 

( UNCONSTRA I NED RECORD 

100 

20 

1-0 i 

1 

(UNCONSTRAINED RECORD 

100 


Benchmarks-Ada 


77 


RSD-12-86 


Subprogram Ore r head (generic, cross package) 
Number of Iterations = 10000 


T i me 

(microsec . ) 

D i rect ion 
Passed 

# Passed 
in Call 

i Type 

i Pa s s ed 

S i i e of | 
Pa s s ed Va r ( 

1 8 


0 



27 

I 

1 

| INTEGER 


27 

O 

1 

j INTEGER 


27 

I _o 

1 

j INTEGER 


30 

1 

1 0 

j INTEGER 


54 

o 

1 0 

| INTEGER 


5 4 

r_o 

10 

j INTEGER 


178 

I 

100 

j INTEGER 


332 

o 

100 

j INTEGER 


334 

i _o 

100 

| INTEGER 


26 

I 

1 

| ENUMERATION 


27 

o 

1 

j ENUMERATION 


27 

i _o 

1 

| ENUMERATION 


38 

1 

1 0 

| ENUMERATION 


54 

o 

1 0 

(ENUMERATION 


53 

i _o 

1 0 

j ENUMERATION 


176 

1 

100 

j ENUMERATION 


320 

o 

100 

| ENUMERATION 


334 

i _o 

100 

(ENUMERATION 


27 

I 

1 

(ARRAY of INTEGER 

1 

27 

o 

1 

j ARRAY of INTEGER 

1 

27 

I o 

1 

| ARRAY of INTEGER 

1 

27 

I 

1 

| ARRAY of INTEGER 

1 0 

26 

o 

1 

j ARRAY of INTEGER 

1 0 

26 

I o 

1 

| ARRAY of INTEGER 

1 0 

27 

I 

1 

(ARRAY of INTEGER 

100 

26 

o 

1 

(ARRAY of INTEGER 

100 

26 

i_o 

1 

(ARRAY of INTEGER 

100 

20 

I 

1 

(ARRAY of INTEGER 

1 0000 

20 

o 

1 

(ARRAY of INTEGER 

10000 

20 

I _o 

1 

(ARRAY of INTEGER 

10000 

28 

I 

l 

| RECORD of INTEGER 

1 

28 

o 

1 

(RECORD of INTEGER 

1 

27 

1.0 

1 

(RECORD of INTEGER 

1 

27 

I 

1 

(RECORD of INTEGER 

100 

26 

o 

1 

(RECORD of INTEGER 

100 

26 

i _o 

1 

(RECORD of INTEGER 

100 


78 


Ben ch m ar ks- Ad a 



RSD-12-88 


Number of Iteration* = 10000 * 10 


Dynamic Allocation in a Declarative Region 



T i me 

(microsec.) 

# Declared 

Type 

Declared 


Sine of | 
Ob j e c t j 

1 

0 . 0 

1 

Integer 



1 

1 

-1.5 

10 

Integer 



1 

1 

208.0 

100 

Integer 



1 

1 

0 . 0 

1 

String 


1 


1 

-0.1 

1 

String 


1 0 

1 

1 

0 . 0 

1 

String 


100 

1 

1 

0 . 0 

1 

Enume rat ion 



1 


-1.6 

10 

En ume rat ion 



1 

1 

•0.5 

100 

Enume rat ion 



1 

1 

0 . 0 

1 

Integer Array 


1 

1 

1 

1 . 1 

1 

Integer Array 


1 0 

1 

1 

1 . 7 

1 

Integer Array 


100 

1 

1 

1 . 6 

1 

Integer Array 


1000 

1 

1 

0 . 8 

1 

Integer Array 


10000 

1 

i 

0 . 0 

X 

Integer Array 


100000 

1 

1 

10.5 

1 

1-D Dynamically bounded 

Array j 

1 

1 

1 

10.5 

1 

1-D Dynamically bounded 

Array j 

1 0 

! 

1 

3 1.4 

1 

2-D Dynamically bounded 

Array j 

1 

1 

1 

32.5 

1 

2-D Dynamically bounded 

Array | 

100 

1 

1 

46.5 

1 

3-D Dynamically bounded 

Array j 

1 

1 

1 

43.7 

1 

3-D Dynamically bounded 

Array j 

1000 

1 

1 

-1.3 

1 

Record of Integer 


1 

1 

1 

-0.4 

1 

Reco rd of Integer 


1 0 

1 

1 

•0.8 

1 

Record of Integer 


100 

1 

Note: Times reported include any deallocation required 

upon leaving the 

9 C O 


of the declared variables. 


Benchmarks-Ada 


79 


RSD-12-88 


Number of Iterations == 100 


Dynamic Allocation with NEW allocator 


Time |# Declared 

(microsec. ) | 

1 Type 

| Declared 


| Site of 

j Ob j e c t 

1 

1 30 

1 

| Integer 


1 

1 

1 

130 

1 

1 En ume rat ion 


1 

1 

1 

1 -to 

1 

{Record of Integer 

1 

1 


1 00 

1 

|Record of Integer 

1 

5 


1 00 

1 

jRecord of Integer 

1 

10 

1 

170 

1 

jRecord of Integer 

1 

20 

1 

200 

1 

jRecord of Integer 

1 

50 

! 

2 4 0 

1 

jRecord of Integer 

1 

100 

i 

130 

1 

| S t r i ng 


1 

1 

1 

1 40 

1 

[String 


7 1 

1 0 

1 

1 50 

1 

j S t r i ng 


1 

100 

1 

1 40 

1 

j Integer Array 


1 

1 

1 

140 

1 

j Integer Array 


1 

10 

1 

1 50 

1 

j Integer Array 


1 

100 

1 

170 

1 

j Integer Array 



1000 

1 

220 

1 

j 1 -D Dynami ca 1 1 y 

Bounded 

Array j 

1 

1 

280 

1 

j 1 - D Dy n ami c a 1 1 y 

Bounded 

Array | 

1 0 

1 

290 

1 

| 2 -D Dynami ca 1 1 y 

Bounded 

Array | 

1 

1 

1300 

1 

| 2 -D Dynami ca 1 1 y 

Bounded 

Array | 

1 00 


300 

1 

j 3 -D Dynami ca 1 1 y 

Bounded 

Array | 

1 

1 

3350 

1 

j 3 -D Dynami ca 1 1 y 

Bounded 

Array | 

1000 


80 


Ben ch m ar ks- Ad a 



RSD-12-80 


Number of Iterations = 10000 


Exception Handler Tests 


Except 

ion r a i 

sed and bandied in a bloc 

k 

- 1 

«SEC . 

User Defined, Not Rais 

ed 

300 

nSEC. 

User Defined 


423 

n S EO . 

Constraint Error, Impl 

i c i t 1 y Raised 

407 

nSEC. 

Constraint Error, Expl 

i c i t 1 y Raised 

2370 

nSEC. 

Numeric Error, Implici 

t 1 7 Raised 

44 1 

nSEC. 

Numeric Error, Explici 

t I 7 Ra i s e d 

448 

nSEC . 

Tasking Error, Explici 

t 1 7 Raised 

Except 

ion r a i 

sed in a procedure and bandied in the 

1 

n S EC . 

User Defined, Not Rais 

e d 

718 

nSEC. 

User Defined 


737 

nSEC. 

Constraint Error, Impl 

i c i t 1 7 Raised 

730 

nSEC. 

Constraint Error, Expl 

i c i t 1 7 Raised 

272 1 

n SEC . 

Numeric Error, Implici 

t 1 7 Ra i s e d 

7 S 4 

n S EC . 

Numeric Error, Explici 

t 1 7 Raised 

783 

nSEC. 

Tasking Error, Explici 

t 1 7 Raised 


unit 


Benchmarks- Ada 


81 



RSD-12-86 


Task Elaborate, Activate, lid Terminate Time: Declared Object, No Type 
Number of Iterations = 100 

For test nnmb e r 1 

Task elaborate, activate, terminate time: 3.6 milliseconds. 


Task Elaborate, Activate, and Terminate Time: Declared Object, Task Type 

Number of Iterations = 100 

For test n umb e r 1 

Task elaborate, activate, terminate time: 3.7 milliseconds. 


Task Elaborate, Activate, and Terminate Time: NEW Object, Task Type 
Nnmber of Iterations = 100 

For test nnmb e r 1 

Task elaborate, activate, terminate time: 3.1 milliseconds. 


82 


Benchmarks- Ada 



RSD-12-88 


ReideiTon Time: No Ptrtneten Pissed 

Number of Iterations = 10000 


Task Rendesvous Time: 838 microseconds. 


Benchmarks-Ada 


83 


RSD-12-86 


Number of Iterations = 10000 


Clock 

f met 

i o n 

c * 1 

i 

i n{ 

overhead 

3658 

Clock 

f met 

i o n 

c x I 

i 

i nj 

overhetd 

3672 

Clock 

f nnc t 

i o n 

c x 1 

i 

i a K 

orerheid 

3644 

Clock 

f nnc t ion 

c x 1 

i 

« »8 

o y e r b e »d 

3587 

Clock 

f nn c t 

i o n 

c x 1 

i 

i ns 

orerhesd 

368 1 


84 



mi croseconds 
mi croseconds 
mi croseconds 
mi croseconds 
mi croseconds 


Benchmarks- Ada 


RSD-12-8B 


Number of Iterations = 10000 


TIME and DURATION math 


Microseconds Operation 


858 

Time 

:=* 

Var_time + Var.dn rat ion 

87 4 

Time 

: = 

Var.time - Var.dnration 

889 

Time 

:=s 

Var.dnration + Var_time 

816 

Time 

: = 

Var.t ime - Const.dnrat ion 

75 

Du r a t 

i o n 


= Va r _ t i me - Var.time 

6 

Dnrat 

i o n 


= Var.dnration + Var_dnration 

6 

Dnrat 

i on 


=* Va r.dn rat i on - Var.dnrat ion 

6 

Dnrat 

i o n 


=- Var.dnration + Cons t.dnrat ion 

6 

Dnrat 

i o n 


= Var_dnration - Com t.dnrat i on 

6 

Dnrat 

i o n 


as Cons t.dnrat i on + Var.dnrat i on 

6 

Dnrat 

i o n 


,=» Cons t.dnrat i on - Var.dnrat ion 

1 

Dnrat 

i o n 


» Cons t.dnrat i on + Cons t.dnrat i 

2 

Dnrat 

i o n 


s> Const.dnrat ion - Cons t.dnrat i 


o n 
o n 


Benchm&rks-Ada 


85 


RSD-12-88 


Delay Statement Teat - Minimum Delay Valve 
Number of Iteration = 100 


For c a a e Bomb e r 
Desired delay ti me : 
Ac t oa 1 delay time: 

1 

0 . 00 006 1 0 35 1 5 62 SO 
0.010070800781250 

s e c o ad s . 
s e c o ad s . 

For case Bomb e r 
Desired delay time: 
Actual delay time: 

2 

0. 000122070312500 
0.010070800781250 

seconds . 
seconds . 

For case Bomb e r 
Desired delay time: 
Actual delay time: 

3 

0. 000183105468750 
0. 010070800781250 

seconds . 
seconds . 

For case uumb e r 
Desired delay time: 
Actual delay ti me : 

4 

0 . 000244140625000 
0 . 010070800781250 

seconds . 
seconds . 

For case Bomb e r 
Desired delay ti me : 
Actual delay time: 

5 

0.000305175781250 

0.010070800781250 

seconds . 
seconds . 

For case Bomb e r 
Desired delay time: 
Actual delay time: 

6 

0.000366210037500 

0.010070800781250 

seconds . 
seconds . 

For case sumb e r 
Desired delay time: 
Actual delay ti me : 

7 

0 . 000427246003750 
0. 010070800781250 

seconds . 
seconds . 

For case u umb e r 
Desired delay time: 
Actual delay ti me : 

8 

0 . 000488281 250000 
0. 010070800781250 

seconds . 
seconds . 

For case Bomb e r 
Desired delay time: 
Actual delay time: 

0 

0.000540316406250 
0 . 010070800781250 

seconds . 
seconds . 

For case Bomb e r 
Desired delay time: 
Ac t ua 1 delay time: 

1 0 

0 . 000610351562500 
0. 010070800781250 

seconds . 
seconds . 


8S 


Benchmarks* Ada 


RSD-12-80 


Delay Statement Teat 
Number of Iterations = 100 


For case numb e r 
Desired delay time: 
Aetna! delay time: 

For case umber 
Desired delay time: 
Actual delay time: 

For case numb e r 
Desired delay ti me : 
Actual delay time: 

For case numb e r 
Desired delay time: 
Actual delay time: 

For case numbe r 
Desired delay time: 
Actual delay time: 


1 

0 . 0061 03515025000 
0.010000766825000 

2 

0 .012207031250000 
0 . 020080566406250 

3 

0 .018310546875000 
0.020080566406250 

4 

0.024414062500000 
0 . 03002020687 5000 

5 

0. 030617578125000 
0.040100097656250 


seconds . 
seconds . 


seconds . 
seconds . 


seconds . 
seconds . 

seconds . 
seconds . 

seconds . 
seconds . 


Benchmarks-Ada 


RSD-12-88 


Delay Statement Teat 
Number of Iteration = 1 


For cue nombe r 
Desired delay time: 
Ac t <a I delay time: 

For case nombe r 
Deaired delay time: 
Ac t oa 1 delay time: 

For case nombe r 
Desired delay time: 
Actnal delay time: 

For cate n imb e r 
Desired delay time: 
Actual delay ti me : 

For case nomb e r 
Desired delay time: 
Ac t oa I delay time: 

For case nomb e r 
Desired delay time: 
Actoal delay time: 

For case nomb e r 
Desired delay time: 
Actoal delay time: 

For case nomb e r 
Desired delay time: 
Actoal delay time: 

For case n omb e r 
Desired delay time: 
Actoal delay time: 

For case nomb e r 
Desired delay time: 
Actoal delay time: 


1 

0 . 000061035156250 
0. 010000765625000 

2 

0. 000122070312500 
0. 010000765625000 

3 

0.000183105468750 
0. 010000765625000 

4 

0.000244140625000 
0 . 010000765625000 

5 

0 . 000305175781250 
0. 010000765625000 

6 

0 . 000366210037500 
0 . 000048730468750 

7 

0 . 000427246003750 
0 . 000048730468750 

8 

0.000488281250000 
0 . 010000765625000 

0 

0.000540316406250 
0. 000048730468750 

1 0 

0. 000610351562500 
0 . 000048730468750 


seconds . 
seconds . 

seconds . 
seconds . 


seconds . 
seconds . 

seconds . 
seconds . 

seconds . 
seconds . 

seconds . 
seconds . 

seconds . 
seconds . 


seconds . 
seconds . 


seconds . 
seconds . 

seconds . 
seconds . 


88 


Ben ch m ar ks- Ad a 


RSD-12-80 


Delay Statement Teat 
Number of Iterations = 1 


For case nnmbe r 
Desired delay time: 
Aetna! delay time: 

1 

0. 0061 03515625000 
0 . 010000765625000 

seconds . 
seconds . 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

2 

0 .012207031250000 
0. 010058406003750 

seconds . 
seconds . 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

3 

0 . 018310546875000 
0.010058406003750 

seconds, 
seconds . 

For case number 
Desired delay time: 
Actual delay time: 

4 

0.0244 14062500000 
0 . 030020206875000 

seconds . 
seconds . 

For case numb e r 
Desired delay t ime : 
Actual delay time: 

5 

0. 030517578125000 
0 . 030078027343750 

seconds . 
seconds . 

For case numb e r 
Desired delay time: 
Actual delay time: 

6 

0. 036621003750000 
0 . 030078027343750 

seconds . 
seconds . 

For case aumbe r 
Desired delay time: 
Actual delay time: 

7 

0 . 042724600375000 
0 .040087702068750 

seconds . 
seconds . 

For case numb e r 
Desired delay time: 
Actual delay ti me : 

8 

0. 048828125000000 
0 . 040087702068750 

seconds . 
seconds. 

For case numb e r 
Desired delay time: 
Actual delay time: 

0 

0 . 054031640625000 
0.050007558503750 

seconds . 
seconds . 

For case numb e r 
Desired delay t ime : 
Actual delay time: 

1 0 

0.061035156250000 
0 . 07000732421 8750 

seconds . 
seconds . 


Benchmarks-Ada 


RSD-12-88 


APPENDIX E 


The following pages contain result tables for all of the tests run. These results 
are for the Alsys Compiler Version 1.0 running with Aegis Version 9.2 on an Apollo 
DN660. Because of the coarse resolution of Alsys’ CLOCK function, an implementation 
dependent subprogram was written that provided a CLOCK function with a 4 
microsecond resolution. This finer resolution reduced the number of iterations necessary 
to achieve the desired precision. 


80 


Benchmarks- Ada 



RSD-12-88 


Sabprofrio Overhead (loa-(taeric) 
Member of Iterations = 100 

T i me 

D i r e c t i o n | 

# Pa s s ed 1 Type | 

Site of 

1 

(microsec. ) | Passed | 

in Call 

Passed |Passed Va 

rl 

1 2 

1 

0 

1 



1 0 

I ! 

1 

INTEGER ] 


1 

20 

o | 

1 

INTEGER | 


1 1 

18 

1.0 ( 

1 

INTEGER 1 


i 

53 

I j 

10 

INTEGER j 



12 

0 i 

1 0 

INTEGER 1 



103 

1-0 i 

10 

INTEGER j 



10 

I 1 

1 

ENUMERATION | 


I 

20 

o I 

1 

ENUMERATION j 


1 

18 

1-0 l 

1 

ENUMERATION | 



80 

I 1 

10 

ENUMERATION j 


1 

63 

o i 

10 

ENUMERATION | 


1 

116 

I.o 1 

1 0 

ENUMERATION ! 



1 2 

I i 

1 

ARRAY of INTEGER i 

1 

1 

32 

O | 

1 

ARRAY of INTEGER 1 

1 

1 

3 1 

I.o | 

1 

ARRAY of INTEGER j 

1 

1 

1 5 

I 1 

1 

ARRAY of INTEGER j 

1 0 


1 7 

o j 

1 

ARRAY of INTEGER « 

1 0 


1 6 

i_o I 

1 

ARRAY of INTEGER | 

1 0 


1 6 

I 1 

1 

ARRAY of INTEGER | 

100 

1 

1 7 

o i 

1 

ARRAY of INTEGER j 

1 0 0 


1 6 

1-0 1 

1 

ARRAY of INTEGER | 

1 0 0 


7 

I 1 

1 

ARRAY of INTEGER j 

1 0000 


8 

o ! 

1 

ARRAY of INTEGER j 

10000 


7 

1-0 [ 

1 

ARRAY of INTEGER i 

1 0000 

1 

1 3 

1 I 

1 

RECORD of INTEGER j 

1 

1 

32 

o j 

1 

RECORD of INTEGER | 

1 


3 1 

1-0 1 

1 

RECORD of INTEGER ] 

1 

1 

7 

I I 

1 

RECORD of INTEGER | 

100 

1 

7 

o i 

1 

RECORD of INTEGER | 

100 

1 

8 

1-0 1 

1 

RECORD of INTEGER ) 

100 

1 

38 

I I 

1 

UNCONSTRAINED ARRAY j 

1 

1 

37 

o i 

1 

UNCONSTRAINED ARRAY j 

1 

1 

37 

1-0 I 

1 

UNCONSTRAINED ARRAY j 

1 

1 

2 1 

i j 

1 

UNCONSTRAINED ARRAY j 

100 

! 

1 0 

o j 

1 

UNCONSTRAINED ARRAY | 

100 

1 

1 0 

1-0 1 

1 

UNCONSTRAINED ARRAY | 

100 

1 

31 

I j 

1 

UNCONSTRAINED ARRAY | 

1 0000 

1 

3 1 

o j 

1 

UNCONSTRAINED ARRAY j 

10000 

1 

31 

1-0 I 

1 

UNCONSTRAINED ARRAY j 

10000 

1 

1 6 

I I 

1 

UNCONSTRAINED RECORD | 

1 

1 

1 6 

o 1 

1 

UNCONSTRAINED RECORD j 

1 

1 

1 5 

1-0 I 

1 

UNCONSTRAINED RECORD | 

1 

1 

7 

I j 

1 

UNCONSTRAINED RECORD j 

100 

1 

1 2 

o i 

1 

UNCONSTRAINED RECORD j 

100 

1 

12 

1-0 1 

1 

UNCONSTRAINED RECORD | 

100 

1 


i 


Benchmarks- Ada 


91 


RSD-12-86 


Subprogram Orerleid (inline) 
Number of Iterations = 100 


T ime 

J5T 

rect 

i o n | # Passed] 

Type 

| Size 

o f | 

( mi c r o s e c . 

) I 

Pass 

e d jin Cali j 

Pas s e d 

j Pa s s e d 

Var j 


3 1 

1 1 

0 



2 5 

1 I 1 

1 

| INTEGER j 


3 1 

i O ! 

1 

j INTEGER j 


50 

i i-o i 

1 

| INTEGER i 


55 

i i i 

10 

j INTEGER | 


4 3 

1 o | 

10 

1 INTEGER j 


105 

1 1-0 i 

10 

j INTEGER | 


25 

1 I I 

1 

(enumeration 1 


32 

! O 1 

1 

(enumeration i 


SO 

i 1-0 i 

1 

(enumeration j 


85 

1 I 1 

1 0 

(enumeration | 


68 

1 O j 

1 0 

(enumeration ( 


152 

1 1-0 | 

1 0 

(ENUMERATION j 


26 

I I 1 

1 

(ARRAY of INTEGER ( 

1 

33 

1 O j 

1 

j ARRAY of INTEGER j 

1 

33 

1 1-0 I 

1 

(ARRAY of INTEGER j 

1 

33 

! I | 

1 

(ARRAY of INTEGER j 

1 0 

34 

1 O i 

1 

j ARRAY of INTEGER j 

1 0 

32 

1 1-0 I 

1 

(ARRAY of INTEGER ] 

1 0 

33 

1 1 I 

1 

(ARRAY of INTEGER j 

10 0 

3 3 

j o j 

1 

(ARRAY of INTEGER ! 

100 

23 

* 1-0 ! 

1 

(ARRAY of INTEGER ( 

100 

23 

1 I 1 

1 

j ARRAY of INTEGER 

10000 

23 

i o j 

1 

| ARRAY of INTEGER j 

1 0000 

23 

i 1-0 \ 

1 

(ARRAY of INTEGER j 

1 0000 

28 

I I j 

1 

(RECORD of INTEGER j 

1 

33 

1 O | 

1 

(RECORD of INTEGER j 

1 

S3 

! i_o | 

1 

(RECORD of INTEGER [ 

1 

22 

1 i . 1 

1 

(RECORD of INTEGER ! 

100 

22 

i O I 

1 

(RECORD of INTEGER j 

100 

24 

1 1-0 l 

1 

(RECORD of INTEGER j 

100 

55 

1 i ! 

1 

(unconstrained ARRAY j 

1 

55 

o ] 

1 

(unconstrained array ( 

1 

55 

1 1-0 ! 

1 

(unconstrained array ( 

1 

33 

1 I 1 

1 

(unconstrained array ( 

100 

33 

i O 1 

1 

(unconstrained array ( 

100 

3 2 

1 1-0 ! 

1 

(unconstrained array ( 

100 

33 

1 i 1 

1 

(unconstrained array ( 

10000 

32 

I o i 

1 

(unconstrained array j 

1 0000 

32 

1 1-0 i 

1 

(unconstrained array ( 

1 0000 

32 

1 I i 

1 

(unconstrained record ( 

1 

3 1 

j o | 

1 

(unconstrained RECORD ( 

1 

3 1 

! i-O ] 

1 

(unconstrained RECORD ( 

1 

22 

! i i 

1 

(unconstrained RECORD ( 

100 

20 

i o ] 

1 

(unconstrained RECORD j 

100 

20 

1 I-O 1 

1 

(UNCONSTRAINED RECORD j 

100 


92 


Benchmarks- Ada 


RSD-12-86 


Subprogram Or er head (generic) 
Number of Iterationa — 100 


(mi 

T i me 
c r o a e c . ) 

D i r e c t ion 
Pa a a e d 

# Pa a a ed 
in Call 

Type 
Paa a ed 

S i a e of 
Paa a ed Va 

"I 

r | 

1 

27 


0 



~T 

1 

28 

1 

1 

INTEGER 


1 

1 

1 7 

O 

1 

INTEGER 


1 

1 

37 

1-0 

1 

INTEGER 


1 

1 

80 

I 

1 0 

INTEGER 


1 

1 

73 

O 

10 

INTEGER 


1 

i 

154 

1-0 

1 0 

INTEGER 


1 

1 

24 

I 

1 

ENUMERATION 


1 

1 

14 

O 

1 

ENUMERATION 


] 

1 

38 

i_o 

1 

ENUMERATION 


1 

1 

80 

I 

10 

ENUMERATION 


1 

1 

85 

O 

1 0 

ENUMERATION 


1 

1 

147 

i_o 

10 

ENUMERATION 


1 

1 

30 

I 

1 

ARRAY of INTEGER 

1 

1 

1 

30 

O 

1 

ARRAY of INTEGER 

1 

1 

1 

30 

1-0 

1 

ARRAY of INTEGER 

1 

1 

1 

22 

I 

1 

ARRAY of INTEGER 

1 0 

1 

1 

5 

O 

1 

ARRAY of INTEGER 

1 0 

1 

1 

5 

I _o 

1 

ARRAY of INTEGER 

1 0 

1 

1 

4 

I 

1 

ARRAY of INTEGER 

100 

1 

1 

4 

O 

1 

ARRAY of INTEGER 

100 

1 

1 

4 

I _o 

1 

ARRAY of INTEGER 

100 

1 

1 

32 

I 

1 

ARRAY of INTEGER 

10000 

1 

1 

1 1 

O 

1 

ARRAY o f 1 NT EGER 

10000 

1 

1 

1 1 

1.0 

1 

ARRAY of INTEGER 

10000 

1 

1 

30 

I 

1 

RECORD of INTEGER 

1 

1 

1 

30 

o 

1 

RECORD of INTEGER 

1 

1 

1 

30 

i_o 

1 

RECORD of INTEGER 

1 

1 

1 

S3 

I 

1 

RECORD of INTEGER 

100 

1 

1 

12 

0 

1 

RECORD of INTEGER 

100 

1 

1 

12 

i_o 

1 

RECORD of INTEGER 

100 

1 


Benchmarks-Ada 


RSD-12-86 


Number of 


Sob pro ghr am Ore r be ad (cross package, non-generic) 
Iterations = 100 


T i me | D i r e c t ion 

(microsec. )| Passed 

# Passed 
in Call 

1 Type 1 

| Passed | 

Site of 
Passed Va 

1 

r | 

1 4 


0 

1 I 


1 

1 0 

I 

1 

j INTEGER | 


1 

2 1 

O 

1 

j INTEGER | 


1 

38 

I _o 

1 

j INTEGER | 


1 

50 

I 

1 0 

j INTEGER j 


1 

4 6 

O 

10 

j INTEGER | 



8 4 

1.0 

1 0 

j INTEGER j 


1 

1 8 

I 

1 

j ENUMERAT I ON j 


1 

2 1 

o 

1 

| ENUMERATION | 


1 

38 

i _o 

1 

j ENUMERAT I ON j 


1 

80 

I 

1 0 

j ENUMERAT I ON | 


1 

50 

o 

1 0 

j ENUMERAT I ON j 



108 

1-0 

1 0 

j ENUMERAT I ON j 


1 

20 

I 

1 

j ARRAY of INTEGER 

1 

1 

22 

o 

1 

(ARRAY of INTEGER j 

1 

! 

22 

i_o 

1 

(ARRAY of INTEGER j 

1 

1 

1 6 

I 

1 

j ARRAY of INTEGER j 

1 0 

1 

1 8 

O ' 

1 

j ARRAY of INTEGER ! 

1 0 


1 8 

i _o 

1 

(ARRAY of INTEGER j 

1 0 

1 

1 8 

I 

1 

(ARRAY of INTEGER i 

100 

1 

17 

o 

1 

(ARRAY of INTEGER | 

100 

1 

1 7 

i _o 

1 

(ARRAY of INTEGER j 

100 

1 

1 4 

I 

1 

(ARRAY of INTEGER j 

10000 

1 

1 4 

o 

1 

(ARRAY of INTEGER 1 

10000 

1 

1 4 

i _o 

1 

j ARRAY of INTEGER j 

1 0000 

1 

1 0 

I 

1 

j RECORD of INTEGER | 

1 

I 

22 

o 

1 

(RECORD of INTEGER | 

1 

! 

22 

i _o 

1 

(RECORD of INTEGER j 

1 

1 

1 3 

I 

1 

(RECORD of INTEGER ! 

100 

1 

1 4 

o 

1 

(RECORD of INTEGER i 

10 0 

1 

1 4 

1-0 

1 

(RECORD of INTEGER j 

100 

1 

48 

I 

1 

(UNCONSTRAINED ARRAY j 

1 

1 

46 

0 

1 

(UNCONSTRAINED ARRAY j 

1 

I 

46 

i _o 

1 

(UNCONSTRAINED ARRAY | 

1 

1 

37 

I 

1 

(UNCONSTRAINED ARRAY j 

100 

1 

37 

o 

1 

(UNCONSTRAINED ARRAY j 

100 

1 

37 

i_o 

1 

(UNCONSTRAINED ARRAY | 

100 

1 

38 

I 

1 

(UNCONSTRAINED ARRAY j 

10000 

1 

37 

o 

1 

(UNCONSTRAINED ARRAY | 

10000 

1 

37 

i_o 

1 

(UNCONSTRAINED ARRAY j 

10000 

1 

1 2 

I 

1 

(UNCONSTRAINED RECORD | 

1 

1 

1 7 

o 

1 

(UNCONSTRAINED RECORD | 

1 

1 

1 0 

1-0 

1 

(UNCONSTRAINED RECORD | 

1 

1 

0 

I 

1 

(UNCONSTRAINED RECORD ( 

100 

1 

0 

o 

1 

(UNCONSTRAINED RECORD | 

100 

1 

10 

i_o 

l 

(UNCONSTRAINED RECORD | 

100 

1 


C-^ 


94 


Benchmarks- Ada 



RSD-12-86 


S ubp r o g r am Or e r head (generic, cross package) 
Number of Iterst ioss = 100 


T i me j D i r e c t 

i 0 n | # Passed| 

Type 

| Site 

"of'T 

(microsec. )j Pass 

ed jin Ca 1 1 j 

Pa s s e d 

j Pa s s ed 

Var j 


1 

8 

1 

0 


1 


1 

1 3 

I j 

1 

INTEGER 

1 


1 

1 6 

O i 

1 

INTEGER 

1 


1 

22 

1-0 | 

1 

INTEGER 

1 


1 

59 

I j 

1 0 

INTEGER 

1 


1 

45 

O ' 

1 0 

INTEGER 

1 


1 

83 

1-0 1 

10 

INTEGER 

1 



4 

I 1 

1 

ENUMERATION 

1 


1 

7 

0 j 

1 

ENUMERATION 

1 


1 

1 1 

1-0 i 

1 

ENUMERATION 

1 


1 

57 

I I 

1 0 

ENUMERATION 

1 


1 

5 1 

0 i 

1 0 

ENUMERATION 

1 


1 

90 

1-0 j 

1 0 

ENUMERATION 

1 


1 

1 7 

I j 

1 

ARRAY of INTEGER 

1 

1 

1 

1 8 

0 

1 

ARRAY of INTEGER 

1 

1 

1 

1 8 

1-0 i 

1 

ARRAY of INTEGER 


1 

1 

9 

I j 

1 

ARRAY of INTEGER 

1 

1 0 

1 

9 

0 1 

1 

ARRAY of INTEGER 

1 

1 0 

1 

9 

1-0 I 

1 

ARRAY of INTEGER 

1 

1 0 

1 

9 

I 1 

1 

ARRAY of INTEGER 

1 

100 

1 

9 

0 i 

1 

ARRAY of INTEGER 

1 

100 

1 

9 

1-0 | 

1 

ARRAY of INTEGER 

1 

100 

1 

12 

I 1 

1 

ARRAY of INTEGER 

1 

10000 


1 3 

0 j 

1 

ARRAY of INTEGER 


10000 

1 

1 3 

1-0 1 

1 

ARRAY of INTEGER 

1 

10000 

1 

I 6 

I 1 

1 

RECORD of INTEGER 

1 

1 


18 

0 j 

1 

RECORD of INTEGER 

1 

1 

1 

1 8 

i_o ! 

1 

RECORD of INTEGER 

1 

1 

1 

1 1 

1 1 

1 

RECORD of INTEGER 

1 

100 


12 

0 j 

1 

RECORD of INTEGER 

1 

100 

1 

1 1 

1-0 1 

1 

RECORD of INTEGER 

1 

100 


Benchmarks- Ada 


95 


RSD-12-86 


Numb e r of Iterations = 100 



Dy nami c A 1 1 o c a t 

ion in a Declarative Regi 

o n 



Time 

| # Declared 

1 Type 

i 

Site of 


(microsec. ) 


j Declared 

i 

Ob j e c t 

1 

17 

I 1 

| Integer 

i 


1 

- 14 

| 10 

| Integer 

i 


1 

1 82 

j 100 

[Integer 

i 


1 

37 

i 1 

[String 

1 

1 

ll 

41 

j 1 

| S t r i ng 

i 

1 0 

jl 

-2 

1 1 

String 

1 

100 

1 

17 

1 1 

[ Bn nme rat ion 

i 


1 1 

59 

! 10 

{ Bn nme rat ion 

1 


I 

1 12 

j 100 

j Bn nme rat ion 

i 



12 

j l 

| Integer Array 

i 

1 


3 

j l 

j Integer Array 

i 

1 0 

1 

1 

i 1 

[Integer Array 

i 

100 

1 

8 

i i 

[Integer Array 

i 

1000 

1 

28 

i i 

[l-D Dynamically bounded 

Array | 

1 


41 

i i 

| 1 - D Dynamically bounded 

Array j 

1 0 

1 

84 

j i 

| 2 - D Dynamically bounded 

Array j 

1 

1 

74 

j i 

|2-D Dynamically bounded 

Array j 

100 

1 

145 

j l 

[3-D Dynamically bounded 

Array j 

1 

1 

1 88 

j l 

j3-D Dynamically bounded 

Array [ 

1 000 

1 

12 

! l 

[Record of Integer 

1 

1 

1 

27 

j 1 

|Record of Integer 

1 

1 0 

1 

1 

j l 

jRecord of Integer 

1 

100 

1 


Note: Times reported include any deallocation required npon leaving the sco 
of the declared variables. 


i 


98 


Benchmarks- Ada 



RSD-12-88 


Number of Iterations = 100 


Dynami e Allocation with NEW allocator 


Time |# 

(mi crosec. ) j 

Declared 

! Type 

| Declared 

| S i x e of 

{ Ob j e c t 

1 

1 

1 085 | 

1 

| Integer 

1 

1 

1 

1 078 i 

1 

j En nme rat ion 

1 

1 

1 

1 003 | 

1 

|Record of Integer 

1 

1 

1 

1 086 j 

1 

{Record of Integer 

1 

5 

1 

1080 j 

1 

{Record of Integer 

1 

1 0 

1 

1 080 j 

1 

|Record of Integer 

1 

20 

1 

1 072 I 

1 

{Record of Integer 

1 

50 

1 

10S5 j 

1 

{Record of Integer 

1 

100 

1 

1 050 j 

1 

j St r i ng 

1 

1 

1 

1 075 | 

1 

j St r i ng 

1 

10 

1 

1 000 ; 

1 

j St r i ng 

1 

100 

1 

1 0 6 4 j 

1 

j Integer Array 

1 

1 

1 

1 065 j 

1 

j Integer Array 

1 

1 0 

1 

2002 j 

1 

j Integer Array 

1 

100 

1 

2120 | 

1 

| Integer Array 


1000 

1 

2240 j 

1 

j 1 - D Dynamically Bounded 

Array | 

1 

1 

2185 j 

1 

jl-D Dynamically Bounded 

Array | 

10 

1 

2 101 j 

1 

{2-D Dynamically Bounded 

Array j 

1 

1 

2217 | 

1 

{ 2 - D Dynamically Bounded 

Array | 

100 

1 

2300 ! 

1 

jS-D Dynamically Bounded 

Array | 

1 

1 

2334 j 

1 

{3-D Dynamically Bounded 

Array j 

1000 

1 


Benchmarks- Ada 


97 


RSD-12-80 


Number of It tret i om 


1 0000 


y 

Exception Handler Teste 


Except ion 

0 

a SEC 

9270 

nSEC 

8876 

a SEC 

9760 

a SEC 

9350 

nSEC 

9780 

nSEC 

9784 

nSEC 


raised end bundled in a block 
User Defined, Not Raised 
User Defined 

Constrnint Error, Implicitly 
Constraint Error, Explicitly 
Numeric Error, Implicitly Ra i 
Numeric Error, Explicitly Ra i 
Tusking Error, Explicitly Ru i 


Ru i s ed 
Ru i s ed 
s e d 
s e d 
s e d 


Ex c e p t ion 

raised in a 

procedure 

and bandied 

in t b e 

0 

nSEC. 

User De f 

ined, 

Not 

R a i s e d 




1 9481 

nSEC . 

User De f 

i n e d 






1 9455 

nSEC . 

Constraint Error, 

1 mp 1 i c 

i 

* i y 

Raised 

1 8982 

nSEC . 

Co n s t r a i 

nt Error, 

Ex p 1 i c 

i 

tty 

Raised 

1 7954 

nSEC. 

Nome r i c 

Error 

, Imp licit! 

r 

Ra i 

s e d 

1 9008 

n S EC . 

Nome r i c 

Error 

, Explicit! 

y 

Ra i 

s e d 

1 9975 

nSEC . 

Tasking 

Error 

, Explicit! 

y 

Ra i 

s e d 


unit 


88 


Benchmarks- Ada 



RSD-12-86 


ORIGINAL RAGE IS 
OF POOR QUALITY 


Task Elaborate, Activate, and Terminate Time: Declared Object, No Type 
Number of iterations = 100 

For test anmb e r 1 

Task elaborate, activate, terminate time: 13.71 milliseconds. 


Task Elaborate, Activate, and Terminate Time: Declared Object, Task Type 
Number of Iterations = 100 

For test nnmb e r 1 

Task elaborate, activate, terminate time: 15.06 milliseconds. 


Task Elaborate, Activate, and Terminate Time: NEW Object, Task Type 
Number of Iterations = 100 

For test nnmb e r 1 

Task elaborate, activate, terminate time: 14.19 milliseconds. 


Benchm&rks-Ada 


99 


RSD-12-86 


Reidtiroi* Time: No Ptrtmeteri Pissed 

Number of Iterations = 100 


Task Rendeirous Time: 9.55 milliseconds 


100 


Benchmarks- Ada 


RSD-12-86 


Number of Iterations = 100 

Clock function culling orerbeid 


1158 microseconds 


Benchmarks-Ada 


101 


RSD-12-80 


Number of 1 1 «r it i on = 10000 • 10 


TIME n d DURATION ma t b 


Microseconds Operation 


90 

Time 

= 

Var_time + Vir.dirst ioo 

88 

T i me 

as 

Vir.t ime - Vir_dnntion 

10 5 

T i me 

— 

Vir.diratioi + Vir.t ime 

90 

Time 

= 

Vir.t ime + Const.dnrition 

89 

Time 

= 

Vir.t ime - Const.dnrition 

104 

Time 

= 

Const.dnrition + Var.time 

189 

Dirit ion 


= Vir.t ime - Vir.t ime 

2 

Dirat ion 


= Vir.dnrit ioi + Vir. duration 

2 

Dorit ion 


= Vir.dnrit ion - Vir.dnrit i on 

2 

Dirit 

o n 


=» Vir.dnrit ion + Cons t.dnrit ion 

2 

Dn rot ion 


s Vir.dnrit ion - Const.dnrition 

2 

Dint 

o n 


=* Const.dnrition + Vir.dnrit ion 

1 

Dint ion 


=* Const.dnrition - Vir.dnrit ion 

0 

Du r a t i 

o n 


=» Const.dnrition + Cons t.dnrit i 

0 

Dn rit ion 


=* Const.dnrition - Cons t.dnrit i 


o n 
o n 


102 


Benchmarks* Ada 



RSD-12-88 


APPENDIX F 


The following pages contain resalt tables for all of the tests run. These results 
are for the DEC VAX Ada Compiler Version V.1.1 running with Micro VMS 4.1 on a 
Microvax II. 


Benchmarks-Ada 


103 



RSD-12-88 


Subprogram Overhead ( no n - g e a e r i c ) 
Number of Iterations = 10000 * 10 


Time 
c r o s e c . ) 

D i red ion 
Passed 

# Passed 
in Call 

Type J S i i e o 

Passed j Pas s ed V 

2 . 9 
0 . 0 

I 

0 

1 

1 

INTEGER | 


1 . 3 

O 

1 

INTEGER j 


5 . 8 

1.0 

1 

INTEGER j 


0 . 0 

I 

1 0 

INTEGER j 


0 . 2 

O 

10 

INTEGER I 


14.0 

1.0 

10 

INTEGER | 


-6.2 

I 

100 

INTEGER j 


208.1 

O 

100 

INTEGER j 


311.7 

i_o 

100 

INTEGER j 


0 . 0 

I 

1 

ENUMERATION j 


1 . 2 

0 

1 

ENUMERATION j 


5 . 7 

1.0 

1 

ENUMERATION j 


0 . 5 

I 

1 0 

ENUMERATION j 


0 . 7 

o 

10 

ENUMERATION j 


13.3 

i _o 

10 

ENUMERATION | 


-5.7 

I 

100 

ENUMERATION j 


193.0 

o 

100 

ENUMERATION j 


301.4 

1-0 

100 

ENUMERATION j 


0 . 0 

I 

1 

ARRAY of INTEGER | 

1 

0 . 1 

O 

1 

ARRAY of INTEGER | 

1 

• 0.9 

i_o 

1 

ARRAY of INTEGER | 

1 

-1.4 

I 

1 

ARRAY of INTEGER ! 

1 0 

1 . 5 

o 

1 

ARRAY of INTEGER | 

1 0 

-0.4 

1-0 

1 

ARRAY of INTEGER | 

1 0 

-1.1 

I 

1 

ARRAY of INTEGER j 

100 

1 . 1 

o 

1 

ARRAY of INTEGER | 

100 

1 . 5 

1-0 

1 

ARRAY of INTEGER | 

100 

-0.9 

I 

1 

ARRAY of INTEGER \ 

10000 

1 . 0 

o 

1 

ARRAY of INTEGER | 

10000 

• 1.4 

1-0 

1 

ARRAY of INTEGER j 

10000 

-0.1 

I 

1 

RECORD of INTEGER | 

1 

-2.5 

o 

1 

RECORD of INTEGER | 

1 

-0.1 

i _o 

1 

RECORD of INTEGER | 

1 

0 . 0 

I 

1 

RECORD of INTEGER | 

100 

0 . 0 

o 

1 

RECORD of INTEGER j 

100 

0 . 0 

i _o 

1 

RECORD of INTEGER | 

100 

-1.3 

I 

1 

UNCONSTRAINED ARRAY | 

1 

-0.9 

o 

1 

UNCONSTRAINED ARRAY j 

1 

0 . 2 

1.0 

1 

UNCONSTRAINED ARRAY | 

1 

-1.1 

I 

1 

UNCONSTRAINED ARRAY | 

100 

-1.0 

o 

1 

UNCONSTRAINED ARRAY j 

100 

0 . 0 

1-0 

1 

UNCONSTRAINED ARRAY j 

100 

-2.0 

I 

1 

UNCONSTRAINED ARRAY | 

10000 

-1.4 

o 

1 

UNCONSTRAINED ARRAY j 

10000 

-0.7 

1.0 

1 

UNCONSTRAINED ARRAY j 

10000 

0 . 0 

I 

1 

UNCONSTRAINED RECORD | 

1 

0 . 2 

o 

1 

UNCONSTRAINED RECORD j 

1 

0 . 0 

1-0 

1 

UNCONSTRAINED RECORD j 

1 

•1.0 

I 

1 

UNCONSTRAINED RECORD j 

100 

0 . 0 

o 

1 

UNCONSTRAINED RECORD | 

100 

0 . 0 

1.0 

1 

UNCONSTRAINED RECORD j 

100 


*** 


Benchmarks- Ada 


105 


RSD-12-80 


' . Subprog rim 

Number of Itentions = 10000 * 

Or e r ii e id (inline) 
1 0 


T i me 

D i reel i o a | 

# Pissed 

1 Type | 

Site o 

(microsec. ) 

Pissed | 

in Ci 1 1 

| Pissed |PissedV 

3 . 0 
0 . 0 

1 

i [ 

0 

1 

1 1 

j INTEGER j 


1 . 2 

o 

1 

j INTEGER | 


5 . 9 

i_o 1 

1 

| INTEGER i 


0 . 0 

I 1 

1 0 

| INTEGER j 


0 . 3 

O | 

1 0 

j INTEGER j 


14.0 

1-0 1 

10 

1 INTEGER j 


-8.2 

I 1 

100 

j INTEGER j 


208.2 

o i 

100 

j INTEGER j 


311.6 

1-0 1 

100 

i INTEGER j 


0 . 0 

I 1 

1 

| ENUMERATION j 


1 . 3 

o 

1 

| ENUMERATION | 


5 . 7 

1-0 | 

1 

[ENUMERATION 


0 . 6 

1 1 

1 0 

| ENUMERAT I ON | 


0 . 7 

o 1 

1 0 

j ENUMERAT I ON 1 


13.2 

1-0 1 

1 0 

| ENUMERAT I ON j 


-5.7 

I i 

100 

| ENUMERAT I ON | 


192.9 

O I 

100 

j ENUMERATION j 


301.5 

1-0 i 

100 

| ENUMERAT I ON i 


0 . 0 

I I 

1 

j ARRAY of INTEGER j 

1 

0 . 1 

o 1 

1 

| ARRAY of INTEGER ] 

1 

-0.8 

1-0 ! 

1 

j ARRAY of INTEGER 1 

1 

-1.5 

i ! 

1 

j ARRAY of INTEGER j 

1 0 

1 . 5 

o 

1 

) ARRAY of INTEGER | 

1 0 

-0.4 

1-0 ! 

1 

[ARRAY of INTEGER j 

1 0 

-1.0 

I 1 

1 

j ARRAY of INTEGER j 

100 

1 . 1 

o i 

1 

| ARRAY of INTEGER j 

100 

1 . 5 

1-0 I 

1 

j ARRAY of INTEGER j 

100 

-1.1 

1 i 

1 

j ARRAY of INTEGER i 

1 0000 

1.1' 

o ! 

1 

j ARRAY of INTEGER j 

10000 

-1.5 

1-0 I 

1 

[ARRAY of INTEGER | 

10000 

0 . 0 

I 1 

1 

[RECORD of INTEGER j 

1 

-2.4 

O i 

1 

j RECORD of INTEGER j 

1 

0 . 0 

1-0 1 

1 

j RECORD of INTEGER | 

1 

0 . 1 

i ! 

1 

(RECORD of INTEGER j 

100 

0 . 0 

o ! 

1 

[RECORD of INTEGER j 

100 

-0.1 

i_o j 

1 

| RECORD of INTEGER j 

100 

-1.3 

i l 

1 

[UNCONSTRAINED ARRAY j 

1 

-0.7 

o i 

1 

[UNCONSTRAINED ARRAY j 

1 

0 . 3 

1-0 I 

1 

[UNCONSTRAINED ARRAY j 

1 

-1.0 

i 1 

1 

| UNCONSTRAINED ARRAY | 

100 

-1.0 

o 1 

1 

[UNCONSTRAINED ARRAY | 

100 

0 . 0 

1-0 ! 

1 

[UNCONSTRAINED ARRAY j 

100 

-2.1 

i j 

1 

[UNCONSTRAINED ARRAY j 

10000 

-1.5 

o i 

1 

[UNCONSTRAINED ARRAY j 

10000 

-0.8 

1.0 | 

1 

[UNCONSTRAINED ARRAY j 

10000 

0 . 1 

I i 

1 

[UNCONSTRAINED RECORD | 

1 

0 . 1 

O i 

1 

[UNCONSTRAINED RECORD | 

1 

-0.1 

1-0 i 

1 

[UNCONSTRAINED RECORD j 

1 

-0.9 

I j 

1 

[UNCONSTRAINED RECORD | 

100 

-0.1 

o 

1 

[UNCONSTRAINED RECORD | 

100 

0 . 0 

1-0 1 

1 

[UNCONSTRAINED RECORD j 

100 


108 


Benchmarks' Ada 


RSD-12-86 


ORIGINAL PACE 
OF POOR 0".«5i 


Subprogram Orerkeid (generic) 
Number of Iteration) — 10000 * 10 


T i me 

(microsec.) 

D i r e c t ion 
Passed 

# Passed 
in Call 

! Type | 

| Passed ] 

S i i e o 
Pa s s ed V 

0 . 1 


0 

1 I 


1 . 1 

I 

1 

| INTEGER | 


0 . 5 

O 

1 

1 INTEGER j 


-0.1 

1-0 

1 

| INTEGER j 


0 . 1 

I 

1 0 

| INTEGER | 


0 . 0 

O 

1 0 

| INTEGER | 


11.7 

i_o 

10 

j INTEGER j 


-0.1 

1 

100 

j INTEGER | 


14 9.1 

o 

100 

| INTEGER ! 


312.0 

1.0 

100 

| INTEGER | 


1 . 5 

I 

1 

| ENUMERATION i 


0 . 4 

o 

1 

| ENUMERATION | 


-0.1 

i_o 

1 

(ENUMERATION | 


0 . 0 

I 

1 0 

(ENUMERATION 


0 . 0 

o 

1 0 

(ENUMERATION j 


0 . 1 

i_o 

1 0 

(ENUMERATION | 


-2.3 

I 

100 

(ENUMERATION 


153.7 

o 

100 

(ENUMERATION i 


308.3 

i_o 

100 

(ENUMERATION j 


-2.0 

I 

1 

(ARRAY of INTEGER j 

1 

0 . 0 

o 

1 

(ARRAY of INTEGER | 

1 

0 . 2 

i _o 

1 

| ARRAY of INTEGER | 

1 

-2.6 

I 

1 

(ARRAY of INTEGER j 

1 0 

0 . 2 

o 

1 

j ARRAY of INTEGER j 

1 0 

-0.7 

i_o 

1 

| ARRAY of INTEGER | 

1 0 

-6.4 

I 

1 

j ARRAY of INTEGER | 

100 

0 . 6 

o 

1 

j ARRAY of INTEGER | 

100 

0 . 4 

1-0 

1 

| ARRAY of INTEGER j 

100 

-1.3 

I 

1 

j ARRAY of INTEGER | 

10000 

0 . 1 

o 

1 

| ARRAY of INTEGER j 

10000 

0 . 0 

i_o 

1 

j ARRAY of INTEGER j 

10000 

0 . 5 

I 

1 

j RECORD of INTEGER ! 

1 

-0.2 

o 

1 

j RECORD of INTEGER I 

1 

0 . 1 

1-0 

1 

(RECORD of INTEGER | 

1 

-0.4 

I 

1 

| RECORD of INTEGER | 

100 

0 . 2 

o 

1 

(RECORD of INTEGER j 

100 

-4.0 

i_o 

1 

(RECORD of INTEGER i 

100 


Benchmarks-Ada 107 


RSD-12-80 


Subprojhrim OTerbetd (cross package, non-generic) 
Number of Itersi ions = 10000 • 10 


T i me 

(microsec.) 

Direction 
Pa s s ed 

# Passed 
in Call 

! Type | Site o 

1 Passed jPassedV 

46.1 


o 

1 I 


52 . S 

I 

1 

| INTEGER j 


54.5 

O 

1 

| INTEGER i 


40.6 

I _o 

1 

j INTEGER | 


60.1 

I 

1 0 

| INTEGER | 


7 0.6 

O 

1 0 

j INTEGER 


116.0 

!_0 

1 0 

j INTEGER j 


418.8 

1 

100 

j INTEGER j. 


470.0 

O 

100 

j INTEGER j 


87 4.5 

1-0 

100 

j INTEGER j 


52.7 

I 

1 

[ENUMERATION i 


54.5 

O 

1 

[ENUMERATION 1 


4 0.3 

i _o 

1 

[ENUMERATION i 


50.0 

1 

1 0 

[ENUMERATION ! 


70.6 

o 

1 0 

j ENUMER AT I ON ! 


115.0 

I _0 

1 0 

[ENUMERATION j 


403.7 

1 

100 

[ENUMERATION [ 


453.0 

o 

100 

[ENUMERATION | 


842.3 

i _o 

100 

[ENUMERATION j 


52.6 

I 

1 

[ARRAY of INTEGER j 

1 

52.5 

o 

1 

[ARRAY of INTEGER | 

1 

47.3 

i_o 

1 

| ARRAY of INTEGER [ 

1 

48.5 

1 

1 

| ARRAY of INTEGER | 

1 0 

50.0 

o 

1 

j ARRAY of INTEGER j 

1 0 

44.7 

i_o 

1 

j ARRAY of INTEGER [ 

1 0 

5 1.5 

1 

1 

j ARRAY of INTEGER 

100 

52.5 

o 

1 

j ARRAY of INTEGER [ 

100 

48.0 

i _o 

1 

j ARRAY of INTEGER [ 

100 

5 1.5 

1 

1 

[ARRAY of INTEGER ! 

10000 

52.6 

o 

1 

[ARRAY of INTEGER j 

10000 

4 0.2 

1-0 

1 

[ARRAY of INTEGER j 

1 0000 

5 1.1 

I 

1 

j RECORD of INTEGER ! 

1 

5 1.1 

o 

1 

j RECORD of INTEGER j 

1 

52.6 

I _o 

1 

| RECORD of INTEGER [ 

1 

52.6 

I 

1 

j RECORD of INTEGER | 

100 

52.6 

o 

1 

[RECORD of INTEGER 1 

100 

50.4 

1-0 

1 

[RECORD of INTEGER j 

100 

85.4 

I 

1 

[UNCONSTRAINED ARRAY j 

1 

78.1 

o 

1 

[UNCONSTRAINED ARRAY j 

1 

7 3.8 

1-0 

1 

[UNCONSTRAINED ARRAY j 

1 

00.2 

I 

1 

[UNCONSTRAINED ARRAY j 

100 

82.6 

o 

1 

| UNCONSTRAINED ARRAY | 

100 

78.0 

i _o 

1 

[UNCONSTRAINED ARRAY j 

100 

00.2 

I 

1 

[UNCONSTRAINED ARRAY | 

10000 

8 1.1 

o 

1 

[UNCONSTRAINED ARRAY j 

10000 

78.1 

i_o 

1 

[UNCONSTRAINED ARRAY | 

10000 

52.6 

I 

1 

[UNCONSTRAINED RECORD | 

1 

57.0 

o 

1 

[UNCONSTRAINED RECORD | 

1 

4 8.2 

1-0 

1 

[UNCONSTRAINED RECORD | 

1 

52.6 

1 

1 

[UNCONSTRAINED RECORD j 

10 0 

57.0 

o 

1 

[UNCONSTRAINED RECORD j 

100 

48.2 

i _o 

1 

[UNCONSTRAINED RECORD j 

100 


108 


Benchmarks- Ada 


RSD-12-88 


Subprogram Overhead (generic, crosa package) 
Number of Iteration — 1 0000 • 10 


Time 

(microsec.) 

D i r e c t ion 
Passed 

# Passed 
in Call 

Type 

Passed 

S i s e of | 
Passed Var| 

45.0 
2 1.0 

I 

0 

1 

INTEGER 

1 

1 

23.1 

O 

1 

INTEGER 

1 

28.3 

I _o 

1 

INTEGER 

1 

77.0 

I 

1 0 

INTEGER 

1 

8 1.0 

O 

1 0 

INTEGER 

1 

104.2 

1.0 

1 0 

INTEGER 

1 

843.2 

I 

100 

INTEGER 

1 

652.7 

O 

100 

INTEGER 

1 

1164.8 

1-0 

100 

INTEGER 

1 

21.0 

I 

1 

ENUMERATION 

1 

23.0 

o 

1 

ENUMERATION 

I 

26.3 

1-0 

1 

ENUMERATION 

1 

72.4 

1 

1 0 

ENUMERATION 

1 

7 4.6 

o 

10 

ENUMERATION 

1 

06.5 

1.0 

1 0 

ENUMERATION 

1 

602.1 

1 

100 

ENUMERATION 

1 

600.8 

o 

100 

ENUMERATION 

1 

1085.8 

1.0 

100 

ENUMERATION 

1 

20.6 

1 

1 

ARRAY of INTEGER 

1 | 

21.0 

o 

1 

ARRAY of INTEGER 

1 | 

25.0 

1.0 

1 

ARRAY of INTEGER 

1 1 

45.7 

I 

1 

ARRAY of INTEGER 

1 0 

45.7 

o 

1 

ARRAY of INTEGER 

1 0 

64.7 

i_o 

1 

ARRAY of INTEGER 

10 1 

161.1 

1 

1 

ARRAY of INTEGER 

100 1 

145.8 

0 

1 

ARRAY of INTEGER 

100 j 

262.5 

1.0 

1 

ARRAY of INTEGER 

100 j 

12507 . 8 

I 

1 

ARRAY of INTEGER 

10000 1 

10756.0 

o 

1 

ARRAY of INTEGER 

10000 I 

21481 .0 

1.0 

1 

ARRAY of INTEGER 

10000 j 

12.8 

I 

1 

RECORD of INTEGER 

1 I 

14.6 

o 

1 

RECORD of INTEGER 

1 j 

16.0 

1.0 

1 

RECORD of INTEGER 

l ! 

164.0 

1 

1 

RECORD of INTEGER 

100 I 

153.6 

o 

1 

RECORD of INTEGER 

100 1 

263.2 

1.0 

1 

RECORD of INTEGER 

100 1 


Benchmarks-Ada 


109 



RSD-12-88 


Number of Iterations = 10000 * 10 


Dynamic Allocation in a Declarative Region 


Time 

(microsec.) 


# Declared 



Type 

Declared 


Integer 

Integer 

Integer 

String 

String 

String 

En ume ration 

En nme ration 

En nme rat ion 

Integer Array 


-3.3 i 

1 

j Integer Array 

I 

1 0 

-2.1 j 

1 

[Integer Array 

i 

100 

0.1 | 

1 

j Integer Array 

1 

1000 

18.6 j 

1 

j 1 -D Dynamically bounded 

Array | 

1 

9.5 j 

1 

[l-D Dynamically bounded 

Array | 

1 0 

25.1 | 

1 

j 2 - D Dynamically bounded 

Array j 

1 

22.4 ! 

1 

j 2 - D Dynamically bounded 

Array j 

100 

37.7 | 

1 

|3-D Dynamically bounded 

Array j 

1 

38.4 | 

1 

js-D Dynamically bounded 

Array j 

1000 

-3.8 j 

1 

jRecord of Integer 

1 

1 

-3.7 i 

1 

jRecord of Integer 

1 

1 0 

2.8 j 

1 

[Record of Integer 

1 

100 

: Times reported include any deallocation required 

upon leaving t 


declared variables. 


Benchmarks- Ada 



RSD-12-86 


Number of Iterations = 1000 


Dynamic Allocation with NEW tl locitor 



Time |# 

(microsec. ) j 

Declared 

Type 

Declared 

i S i i e of 

j Ob j e c t 

1 

1 

1 

3 10 [ 

1 

I Bt ege r 

1 

1 

1 

1 

310 | 

1 

Ennme rat ion 

1 

1 

1 

1 

3 10 j 

1 

Record of Integer 

1 

1 

[ 

1 

320 j 

1 

Record of Integer 

1 

5 

1 

1 

320 | 

1 

Record of Integer 

1 

1 0 

1 

1 

3 40 j 

1 

Record of Integer 

1 

20 

1 

1 

400 j 

1 

Record of Integer 

1 

50 

1 

1 

5 10 j 

1 

Record of Integer 

1 

100 

1 


3 10 j 

1 

String 

1 

1 

1 

1 

3 10 j 

1 

String 

1 

10 

1 

i 

3 0 0 | 

1 

String 

1 

100 

1 

1 

3 10 | 

1 

Integer Array 

1 

1 

1 

1 

330 j 

1 

Integer Array 

1 

10 

I 

1 

5 10 j 

1 

Integer Array 

1 

100 

1 

1 

2300 j 

1 

Integer Array 

1 

1000 

1 

1 

4 10 | 

1 

1-D Dynamically Bounded 

Array | 

1 

1 

1 

450 j 

1 

1-D Dynamically Bounded 

Array | 

10 

1 


4 30 j 

1 

2-D Dynamically Bounded 

Array j 

1 

1 

1 

870 | 

1 

2-D Dynamically Bounded 

Array j 

100 

1 

1 

400 1 

1 

3-D Dynamically Bounded 

Array j 

1 

1 

1 

4830 j 

1 

3-D Dynamically Bounded 

Array j 

1000 

1 


Benchmarks-Ada 


111 


RSD-12-86 


Numb e r 


of Iterations = 10000 


Exception Handler Tests 


Ex c e p t i 

ion r a i 

ised and bandied 

in a block 


4 

n SEC . 

User Defined, 

No t Raised 


567 

nSEC . 

User Defined 




836 

nSEC . 

Co nstraint Er 

ro r , Imp 1 

icitly 

Ra ised 

821 

nSEC . 

Constraint Er 

ror, Exp 1 

icitly 

Raised 

0 12 

nSEC . 

Nnme r i c Error 

, Imp 1 i c i 

t 1 y Ra i 

ised 

826 

nSEC . 

Nome r i c Error 

, Ex p 1 i c i 

t 1 y Ra i 

ised 

8 10 

n S EC . 

Tasking Error 

, Exp 1 i c i 

t 1 y Ra i 

ised 

Except i 

ion r a i 

ised i.n a procedn 

re and band led i 

in tbe calling 

16 

a SEC . 

User Defined, 

Not Rais 

e d 

736 

nSEC . 

User Defined 




000 

nSEC . 

Constraint Error, Irnpl 

icitly 

Ra ised 

886 

nSEC. 

Constraint Er 

ror, Exp 1 

icitly 

Ra ised 

801 

nSEC . 

Nnme r i c Error 

, I mp 1 i c i 

t 1 y Ra i 

ised 

804 

nSEC. 

Nnme r i c Error 

, Ex p 1 i c i 

t 1 y Ra i 

ised 

883 

nSEC . 

Tasking Error 

, Ex p 1 i c i 

t 1 y Ra i 

ised 


t 


a n i t 


112 


Benchmarks- Ada 



RSD-12-8B 


Task Elaborate, Activate, and Terminate Time: Dec 
Number of Iteration* = 100 


ared Ob j e c t , 


No Type 


For test number 1 

Task elaborate, activate, terminate time: 


8.2 milliseconds. 


Task Elaborate, Activate, and Terminate Time: Declared Object, Task Type 
Number of Iterations = 100 

For test numb e r 1 

Task elaborate, activate, terminate time: 8.2 milliseconds. 


Task Elaborate, Activate, and Terminate Time: NEW Object, Task Type 
Number of Iteration* =* 100 

For test numb e r 1 

Task elaborate, activate, terminate time: 8.0 milliseconds. 


Benchmarks-Ada 


113 


RSD- 12-86 


RendesTons Time: No Perimeters Pissed 

Number of Itentiois = X00 


Tisk Reidetroos Time: 1.8 milliseconds 


114 


Benchmarks- Ada 


RSD-12-88 


Number of Iteratian = 10000 

Clock function calling overhead 05 mi croiecondi . 


Benchmarks-Ada 


115 


RSD-12-88 


Number of Iterations = 20000 • S 


TIME and DURATION ma t b 


Microseconds 


Ope r » t 
Var 


101.8 

Time := 

90 . 1 

T i me :=* 

99.2 

Time := 

108.4 

Time := 

108.8 

Time := 

108.4 

Time := 

118.1 

Durat ion 

0 . S 

Durat ion 

0 . 5 

Du rat ion 

0 . 6 

Durat ion 

0 . 8 

Durat ion 

0 . 6 

Durat ion 

0 . 0 

Durat ion 

0 . 2 

Durat ion 

0 . 5 

Durat ion 


i o n 

_t ime + Vir.dirat ion 
_t i me - Var.duration 
.duration + Var.time 
.time - Co n s t _do r a t i on 
.time + Co n s t _d n r a t i o n 
st.dnration + Var.time 
■Var.time - Var.time 
■Var.duration +Var_duration 
r Var .duration - 
Var .duration + 

Var.duration - 
Co nst.durat ion 
c Const .durat ion 
= Co nst .duration 
■ Coni t.durst i on 


Var.durat i on 
Co nst.durat ion 
Cons t .durat i on 
+ Var.duration 

- Var _d u r a t i o n 
+ Const .durat i 

- Co nst.durat i 


o n 
o n 


116 


Benchmarks- Ad a 


RSD-12-88 


Delay Statement Test - Minimum Delay Value 
Number of Iterations = 100 


For case numb e r 
Desired delay time: 
Actual delay time: 

1 

0 . 000061035158250 
0 . 019958496093750 

seconds 

seconds 

For case numbe r 
Desired delay time: 
Actual delay time: 

2 

0 . 000122070312500 
0.010958496003750 

seconds 

seconds 

For case numb e r 
Desired delay t ime : 
Actual delay time: 

3 

0 . 000183105468750 
0 .019958496093750 

seconds 

seconds 

For case number 
Desired delay time: 
Actual delay time: 

4 

0.0002441 40625000 
0.019058496003750 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

5 

0 . 000305175781250 
0.019958496093750 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

6 

0.000366210937500 
0 . 019958496093750 

seconds 

seconds 

For case numbe r 
Desired delay time: 
Actual delay time: 

7 

0.000427246093750 
0. 019058496003750 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

8 

0.000488281 250000 
0 . 019058496093750 

seconds 

seconds 

For case n umb e r 
Desired delay t ime : 
Actual delay time: 

9 

0 . 000549316406250 
0.019958496093750 

seconds 

seconds 

For case numb e r 
Desired delay t ime : 
Actual delay time: 

1 0 

0 . 000610351562500 
0.019958496093750 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

1 1 

0 . 000671386718750 
0 . 019958496093750 

seconds 

seconds 

For case numb e r 
Desired delay ti me : 
Actual delay time: 

1 2 

0 . 000732421875000 
0 . 019058496093750 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

1 3 

0 . 000793457031250 
0 . 010958496093750 

seconds 

seconds 

For case number 
Desired delay time: 
Actual delay time: 

14 

0 . 000854492187500 
0 .019058496003750 

seconds 

seconds 

For case number 
Desired delay time: 
Actual delay time: 

1 5 

0 . 000915527343750 
0.010958496003750 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

1 6 

0.000976562500000 
0 . 010958496093750 

seconds 

seconds 


Benchmarks-Ada 


117 


RSD-12-88 


Delay Statement Teat 
Number of Iterations = 100 


For case numb e r 
Deaired delay time: 
Aetna! delay time: 

1 

0 . 003051 75781 2500 
0 . 010958496093750 

a e c o nd a 
a e c o nd a 

For c a a e nnmb e r 
Deaired delay time: 
Actual delay time: 

2 

0 . 003662 1 09375000 
0 . 019058496003750 

a e c o nd a 
a e c o n d a 

For c a a e numb e r 
Deaired delay ti me : 
Aetna) delay time: 

3 

0 . 004272460037500 
0 . 010958496003750 

a e c o nd a 
a e c o nd a 

For c a a e nnmb e r 
Deaired delay ti me : 
Actual delay time: 

4 

0 . 004882812500000 
0.01 9958406003750 

seconds 

seconds 

For cat e nnmbe r 
Deaired delay ti me : 
Ac tna 1 delay t i me : 

5 

0. 005493164062500 
0.01 9958406003750 

seconds 

seconds 

For c a a e nnmb e r 
Deaired delay time: 
Actual delay time: 

6 

0 . 00610351562S000 
0 . 019958406093750 

seconds 

seconds 

For c a a e nnmb e r 
Deaired delay time: 
Actual delay ti me : 

7 

0 . 006713867187500 
0 . 019958496003750 

seconds 

seconds 

For case nnmbe r 
Deaired delay ti me : 
Actual delay time: 

8 

0. 007324218750000 
0.019958496093750 

seconds 

seconds 

For case nnmbe r 
Deaired delay time: 
Actual delay ti me : 

9 

0 . 007934570312500 
0. 010958406093750 

seconds 

seconds 

For c a a e nnmb e r 
Deaired delay time: 
Actual delay time: 

1 0 

0 . 008544921875000 
0 . 019958496003750 

seconds 

seconds 

For caae number 
Deaired delay time: 
Actual delay time: 

1 1 

0.009155273437500 
0 . 019958496093750 

seconds 

seconds 

For caae nnmb e r 
Deaired delay time: 
Actual delay time: 

12 

0.009765625000000 

0.019958496093750 

seconds 

aeconda 

For caae nnmb e r 
Deaired delay time: 
Actual delay time: 

1 3 

0.010375976562500 
0 . 029968261718750 

seconds 

seconds 

For caae nnmb e r 
Deaired delay time: 
Actual delay time: 

1 4 

0 . 010986328125000 
0 . 029968261718750 

seconds 

seconds 

For caae nnmb e r 
Deaired delay time: 
Actual delay time: 

1 5 

0.011596679687500 
0 . 029988261718750 

seconds 

seconds 

For caae nnmb e r 
Deaired delay t ime : 
Actual delay time: 

1 6 

0 . 012207031250000 
0 . 029968261718750 

seconds 

seconds 


118 


Benchmarks- Ada 



RSD-12-88 


De 1 ay Statement Test 
Nimber of Iterations 

= 100 


For ctse numb e r 
Desired del*? time: 
Actnnl d e 1 ay time: 

1 

0 . 030517578125000 
0 . 01 99877929687 50 

seconds 

seconds 

For esse numb e r 
Desired de 1 ay time: 
Actnnl delay time: 

2 

0 . 03682 1 093750000 
0 . 019987 792968750 

seconds 

seconds 

For ense anmber 
Desired delay t ime : 
Actnnl delay time: 

3 

0 . 012721609375000 
0 . 059997558593750 

seconds 

seconds 

For case number 
Desired delay time: 
Actual delay time: 

1 

0 . 018828 1 25000000 
0 . 050997 558593750 

seconds 

seconds 

For case nnmb e r 
Desired delay time: 
Actual delay time: 

5 

0 . 05193 1 640625000 
0 . 06991628906 2500 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

6 

0.061035156250000 
0 . 079956051687500 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

7 

0 . 067 138671 87 5000 
0 .079956051687500 

seconds 

seconds 

For case numb e r 
Desired delay t ime : 
Actual delay time: 

8 

0 . 073212187500000 
0. 08096582031 2500 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

9 

0 .079315703 125000 
0 . 08906582031 2500 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

1 0 

0 . 0851102 18750000 
0 . 099075585937500 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

1 1 

0 . 09 1 55273137 5000 
0.100985351562500 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

1 2 

0.007656250000000 
0. 1 09985351 562500 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Actual delay time: 

1 3 

0 . 103750765625000 
0. 1 1 99961 17187500 

seconds 

seconds 

For case number 
Desired delay time: 
Actual delay time: 

1 1 

0 . 109863281 250000 
0 . 1 1 9996 1 17 187500 

seconds 

seconds 

For case number 
Desired delay time: 
Actual delay time: 

1 5 

0 . 1 1 596679687 5000 
0. 1 20913817656250 

seconds 

seconds 

For case numb e r 
Desired delay time: 
Ac t ua 1 delay time: 

1 6 

0 . 1 220703 12500000 
0 . 1 399536 1328 1 250 

seconds 

seconds 


Bench marks- Ad a 


119 


RSD-12-88 


APPENDIX G 


The following pages contain result tables for all of the tests run. These results 
are for the DEC VAX Ada Compiler Version V.1.3 running with VMS 4.4 on a Vax 
11/780. Since the results for the delay test are the same for this compiler as they are for 
V.1.1, please refer to Appendix F for those results. 


120 


Benchmarks- Ada 



RSD-12-86 


Compiler Time Related Values: 


System Tick= 0.000948730468750 Seconds 

Duration Small= 0.000061035156250 Seconds 


Benchmarks-Ada 



RSD-12-80 


Snbprognm Orerheid (i«i- (eier i c ) 
Number of Iterations = 10000 • 10 


T i me | D i reet ion 

(microsec. )| Pissed 

# Pissed 
in Ci t I 

Tjpe 

Pissed 

Site of | 
Pissed Virj 

-0.8 
0 . 3 

I 

0 

1 

INTEGER 

1 

1 

-0.8 

O 

1 

INTEGER 

1 

-0.8 

I _0 

1 

INTEGER 

1 

2 . 8 

I 

1 0 

INTEGER 

1 

12.8 

O 

1 0 

INTEGER 

1 

17.9 

1.0 

1 0 

INTEGER 

1 

0 . 8 

I 

1 

ENUMERATION 

1 

-0.1 

o 

1 

ENUMERATION 

1 

-0.6 

l.o 

1 

ENUMERATION 

1 

2 . 3 

I 

1 0 

ENUMERATION 

1 

-0.1 

o 

1 0 

ENUMERAT I ON 

1 

17.6 

l.o 

1 0 

ENUMER AT I ON 

1 

•0.8 

I 


ARRAY of INTEGER 

1 | 

-0.2 

o 

1 

ARRAY of INTEGER 

1 j 

0 . 1 

1.0 

1 

ARRAY of INTEGER 

1 

0 . 4 

I 

1 

ARRAY of INTEGER 

1 0 

-0.1 

o 

1 

ARRAY of INTEGER 

10 j 

-0.2 

1.0 

1 

ARRAY of INTEGER 

1 0 j 

-0.2 

I 

1 

ARRAY of INTEGER 

100 1 

-0.5 

o 

1 

ARRAY of INTEGER 

100 1 

0 . 6 

l.o 

1 

ARRAY of INTEGER 

100 I 

-0.1 

I 

1 

ARRAY of INTEGER 

10000 j 

0 . 0 

o 

1 

ARRAY of INTEGER 

10000 j 

0 . 3 

I o 

1 

ARRAY of INTEGER 

10000 i 

0 . 1 

I 

1 

RECORD of INTEGER 

1 i 

-0.1 

o 

1 

RECORD of INTEGER 

1 1 

0 . 2 

1-0 

1 

RECORD of INTEGER 

1 1 

-0.2 

I 

1 

RECORD of INTEGER 

100 I 

0 . 4 

o 

1 

RECORD of INTEGER 

100 I 

-0.9 

l.o 

1 

RECORD o f I NTEGER 

100 j 

0 . 2 

I 

1 

UNCONSTRAINED ARRAY 

1 1 

0 . 1 

o 

1 

UNCONSTRAINED ARRAY 

1 1 

0 . 1 

1-0 

1 

UNCONSTRAINED ARRAY 

i i 

-1.8 

I 

1 

UNCONSTRAINED ARRAY 

100 j 

0 . 2 

O 

1 

UNCONSTRAINED ARRAY 

100 1 

-1.4 

1-0 

1 

UNCONSTRAINED ARRAY 

100 1 

0 . S 

I 

1 

UNCONSTRAINED ARRAY 

10000 1 

1 . 1 

6 

1 

UNCONSTRAINED ARRAY 

10000 1 

0 . 3 

1.0 

1 

UNCONSTRAINED ARRAY 

10000 1 

0 . 5 

I 

1 

UNCONSTRAINED RECORD 

1 I 

-0.7 

o 


UNCONSTRAINED RECORD 

1 1 

-0.4 

l.o 

* 

UNCONSTRAINED RECORD 

1 i 

0 . 6 

I 


UNCONSTRAINED RECORD 

100 j 

-0.6 

o 


UNCONSTRAINED RECORD 

100 1 

0 . 0 

l.o 

1 

UNCONSTRAINED RECORD 

100 j 


122 


Benchmarks- Ada 



RSD-12-86 


Subprogram Overhead (inline) 
Number of Iteration* =■ 10000 • 10 


Time 

(microsec. ) 

D i reel ion 
Passed 

# Passed) Type 

inCall j Passed 

Site of ( 
Passed Varj 

- 0 . 4 


0 



1 . 0 

I 

1 

INTEGER 

1 

-0.2 

O 

1 

INTEGER 

1 

-0.1 

1.0 

1 

INTEGER 

1 

2 . 4 

I 

10 

INTEGER 

1 

10.0 

O 

10 

INTEGER 

1 

18.5 

I _o 

1 0 

INTEGER 

i 

0 . 0 

I 

1 

ENUMERATION 

1 

-1.3 

O 

1 

ENUMERATION 

1 

-0.0 

I _o 

1 

ENUMERATION 

1 

2 . 1 

I 

1 0 

ENUMERATION 

1 

0 . 4 

O 

1 0 

ENUMERATION 


18.0 

1.0 

10 

ENUMERATION 

1 

-0 . & 

I 

1 

ARRAY of INTEGER 

1 | 

-0.2 

O 

1 

ARRAY of INTEGER 

1 | 

0 . 2 

1-0 

1 

ARRAY of INTEGER 

1 

0 . 0 

I 

1 

ARRAY of INTEGER 

1 0 | 

-0.8 

O 

1 

ARRAY of INTEGER 

1 0 j 

0 . 0 

i_o 

1 

ARRAY of INTEGER 

1 0 1 

-0 . S 

I 

1 

ARRAY of INTEGER 

100 1 

-0.4 

o 

1 

ARRAY o f I NTEGER 

100 1 

0 . 4 

i _o 

1 

ARRAY of INTEGER 

100 j 

-0.3 

I 

1 

ARRAY of INTEGER 

10000 j 

0 . 2 

o 

1 

ARRAY of INTEGER 

10000 j 

0 . 5 

1-0 

1 

ARRAY of INTEGER 

10000 1 

-0 . T 

I 

1 

RECORD of INTEGER 

1 1 

-0.1 

o 

1 

RECORD of INTEGER 

1 1 

0 . 5 

i_o 

1 

RECORD of INTEGER 

1 j 

0 . 1 

I 

1 

RECORD of INTEGER 

100 I 

0 . 5 

o 

1 

RECORD of INTEGER 

100 j 

-1.3 

1.0 

1 

RECORD of INTEGER 

100 1 

-0.2 

I 

1 

UNCONSTRAINED ARRAY 

1 I 

• 1.8 

o 

1 

UNCONSTRAINED ARRAY 

1 j 

0 . S 

i_o 

1 

UNCONSTRAINED ARRAY 

1 1 

• 0.0 

I 

1 

UNCONSTRAINED ARRAY 

100 j 

-0.4 

o 

1 

UNCONSTRAINED ARRAY 

loo ; 

-1.0 

1.0 

1 

UNCONSTRAINED ARRAY 

100 j 

- 1 . 1 

I 

1 

UNCONSTRAINED ARRAY 

10000 I 

0 . 3 

o 

1 

UNCONSTRAINED ARRAY 

10000 j 

0 . 7 

i_o 

1 

UNCONSTRAINED ARRAY 

10000 j 

1 . 5 

1 

1 

UNCONSTRAINED RECORD 

1 1 

0 . 5 

o 

1 

UNCONSTRAINED RECORD 

1 j 

• 0.8 

1-0 

1 

UNCONSTRAINED RECORD 

1 i 

1 . 7 

I 

1 

UNCONSTRAINED RECORD 

too j 

-0.1 

0 

1 

UNCONSTRAINED RECORD 

100 1 

-1.8 

I _0 

1 

UNCONSTRAINED RECORD 

100 j 


Benchmarks- Ada 


123 


RSD-12-88 


Subprogram Overhead (generic) 
Number of Iterations = 10000 • 10 


( 

T i me 

microsec.) 

D i r e c t ion 

Passed 

# Passed 
in Call 

! Type 

| Passed 

| Size of 

IPassed Var 

I 

1 

1 

0 . 0 


0 

1 

1 

1 


0 . 2 

I 

1 

j INTEGER 

1 

1 


1 . 1 

O 

1 

j INTEGER 

( 

1 

1 

2 . 3 

1 _0 

1 

| INTEGER 

1 

1 

1 

7 . S 

I 

1 0 

| INTEGER 

1 

1 

1 

8 . 5 

O 

1 0 

j INTEGER 

I 

1 

1 

15.7 

i_o 

1 0 

| INTEGER 

1 

1 

1 

-0.1 

1 

1 

(ENUMERATION 

1 

1 

1 

0 . 1 

o 

1 

(ENUMERATION 

I 

1 

1 

0 . 2 

i_o 

1 

(ENUMERATION 

1 

1 

1 

7 . 4 

I 

10 

(ENUMERATION 

1 

1 


8 . 9 

o 

10 

(ENUMERATION 



1 

15.9 

i_o 

10 

(ENUMERATION 

1 


1 

-0.5 

I 

1 

| ARRAY of INTEGER 

j 1 

1 

1 

0 . 0 

o 

1 

j ARRAY of INTEGER 

i 1 

1 

1 

0 . 4 

1-0 

1 

j ARRAY of INTEGER 

1 1 

1 

1 

- 1.2 

I 

1 

| ARRAY of INTEGER 

i 1 0 

1 

1 

0 . 1 

o 

1 

| ARRAY of INTEGER 

[ 1 0 

1 

1 

0 . 2 

I _o 

1 

| ARRAY of INTEGER 

1 1 0 

1 

1 

- 0.1 

I 

1 

j ARRAY of INTEGER 

j 100 

1 

1 

- 0.1 

o 

1 

j ARRAY of INTEGER 

i 100 


1 

- 0.1 

i_o 

1 

| ARRAY of INTEGER 

| 100 

1 

1 

- 0 . s 

I 

1 

j RECORD of INTEGER 

1 1 

I 


-0.5 

o 

1 

| RECORD of INTEGER 

i 1 

1 

1 

• 0.2 

i _o 

1 

| RECORD of INTEGER 

! 1 

1 

1 

- 0.1 

1 

1 

| RECORD of INTEGER 

) 100 

1 

1 

0 . 0 

o 

1 

| RECORD of INTEGER 

! ioo 

1 

1 

0 . 9 

i _o 

1 

| RECORD of INTEGER 

| 100 

1 


124 


Benchmarks* Ada 



RSD-12-86 


Snbproghram Overhead (cron package, non-generic) 
Number of Iterations = 10000 • 10 


Time 

|Direction|# Passed) 

Type 

j Site 

o f | 

(microsec.) 

| Passed | i n Ca 1 I | 

Passed 

[Passed 

Var | 


2 7.0 


0 

1 


30.3 

I 

1 

INTEGER j 


33.3 

O 

1 

INTEGER | 


30.8 

i_o 

1 

INTEGER j 


41.4 

I 

10 

INTEGER j 


72.0 

O 

1 0 

INTEGER | 


105.0 

1.0 

1 0 

INTEGER j 


30.3 

I 

1 

ENUMERATION j 


33.4 

o 

1 

ENUMERATION | 


28.8 

i _o 

1 

ENUMERATION i 


4 1.5 

I 

1 0 

ENUMERATION | 


72.1 

o 

1 0 

ENUMERATION | 


108.1 

1-0 

1 0 

ENUMERATION [ 


30.7 

I 

1 

ARRAY of INTEGER j 

l 

30.0 

o 

1 

ARRAY of INTEGER | 

1 

27.3 

i_o 

1 

ARRAY of INTEGER j 

1 

30.3 

I 

1 

ARRAY of INTEGER j 

10 

30.7 

o 

1 

ARRAY of INTEGER | 

1 0 

27.8 

i_o 

1 

ARRAY of INTEGER 1 

1 0 

30.0 

I 

1 

ARRAY of INTEGER | 

100 

3 1.2 

o 

1 

ARRAY of INTEGER | 

100 

28.0 

1-0 

1 

ARRAY of INTEGER j 

100 

3 1.3 

I 

1 

ARRAY of INTEGER | 

10000 

3 1.6 

o 

1 

ARRAY of INTEGER I 

10000 

27.6 

1-0 

1 

ARRAY of INTEGER j 

10000 

3 1.8 

I 

1 

RECORD of INTEGER | 

1 

32.1 

o 

1 

RECORD of INTEGER 1 

1 

20.2 

i _o 

1 

RECOftD of INTEGER ' 

1 

32.1 

I 

1 

RECORD of INTEGER | 

100 

3 1.8 

o 

1 

RECORD of INTEGER | 

100 

28.0 

1.0 

1 

RECORD of INTEGER j 

100 

42.0 

I 

1 

UNCONSTRAINED ARRAY | 

1 

42.6 

o 

1 

UNCONSTRAINED ARRAY j 

1 

30.4 

1-0 

1 

UNCONSTRAINED ARRAY | 

1 

42.2 

I 

1 

UNCONSTRAINED ARRAY | 

100 

42.2 

o 

1 

UNCONSTRAINED ARRAY j 

100 

30.5 

i _o 

1 

UNCONSTRAINED ARRAY j 

100 

42.3 

I 

1 

UNCONSTRAINED ARRAY | 

10000 

42.3 

o 

1 

UNCONSTRAINED ARRAY j 

10000 

30.5 

1.0 

1 

UNCONSTRAINED ARRAY | 

10000 

34.0 

I 

1 

UNCONSTRAINED RECORD j 

1 

31.7 

o 

I 

UNCONSTRAINED RECORD | 

1 

28 . 4 

1.0 

1 

UNCONSTRAINED RECORD | 

1 

30 .7 

I 

1 

UNCONSTRAINED RECORD | 

100 

3 1.2 

o 

1 

UNCONSTRAINED RECORD j 

100 

28.4 

i _o 

1 

UNCONSTRAINED RECORD | 

100 


Benchmarks-Ada 


125 


RSD- 12-88 


Subprogram Overhead (geaeric, cross package) 
Number o{ Iterations = 10000 • 10 


Time 

(microsec.) 

Direction!# Passed 
Pas s ed jin Ca 1 t 

S Type 

| Passed 

( S i t e o f [ 

j Pa seed Varj 

15.0 

1 

0 

1 


1 

20.3 

I ! 

1 

j INTEGER 


1 

22.7 

O i 

1 

j INTEGER 


I 

24 .4 

i_o | 

1 

j INTEGER 


1 

84.4 

i : 

1 0 

j INTEGER 


1 

79.4 

o ! 

1 0 

j INTEGER 



104.4 

i.o | 

1 0 

j INTEGER 



20.3 

i i 

1 

| ENUMERATION 

1 

22.8 

o 1 

1 

j ENUMERATION 

1 

24.0 

1-0 i 

1 

j ENUMERATION 

1 

64.6 

I 1 

10 

j ENUMERATION 

1 

79.8 

o ! 

1 0 

j ENUMERATION 

1 

103.6 

1-0 I 

1 0 

ENUMERATION 

1 

20.0 

I i 

1 

| ARRAY of 

INTEGER 

j 1 

2 1.1 

o j 

1 

j ARRAY of 

INTEGER 

j 1 

2 4.0 

i.o ! 

1 

j ARRAY of 

INTEGER 

1 

45.2 

i 1 

1 

j ARRAY of 

INTEGER 

! 1 0 

43.3 

o i 

1 

[ARRAY of 

INTEGER 

i i o 

6 1.0 

1-0 I 

1 

[ARRAY of 

INTEGER 

| 1 0 

157.6 

I 1 

1 

[ARRAY of 

INTEGER 

j 100 

159.7 

o j 

1 

[ARRAY of 

INTEGER 

i 100 

288.2 

1-0 ! 

1 

[ARRAY of 

INTEGER 

j 100 

21585.6 

i ! 

1 

j ARRAY of 

INTEGER 

i 10000 

21552.2 

o j 

1 

j ARRAY of 

INTEGER 

! ioooo 

42904 . 3 

i.o j 

1 

j ARRAY of 

INTEGER 

j 10000 

20.8 

i j 

1 

[RECORD of 

INTEGER 

j 1 

22.0 

o 1 

1 

j RECORD of 

INTEGER 

1 1 

25.2 

1-0 I 

1 

j RECORD of 

INTEGER 

! i 

153.8 

I j 

1 

j RECORD of 

INTEGER 

1 100 

153.3 

o 1 

1 

j RECORD of 

INTEGER 

j 100 

282.5 

J-O I 

1 

j RECORD of 

INTEGER 

j 100 


128 


Benchmarks* Ada 



RSD-12-8B 


Number of Iteration* = 10000 • 10 


Dynamic Allocation ia a Declarative Region 


Time ! 

(mi croiec . } | 

# Declared 

Type 

Declared 


Site of 
Ob j e c t 

1 

1 

0 . s i 

1 

Integer 



1 

1.5 | 

10 

Integer 



1 

1.0 j 

1 

String 


1 

1 

0.4 | 

1 

String 


1 0 

1 

1.6 | 

1 

String 


100 

1 

4.0 | 

1 

Enume ration 



1 

1.0 i 

10 

Ennme ration 



1 

1.1 | 

1 

Integer Array 


1 


1.1 j 

1 

Integer Array 


1 0 

1 

0 . 5 | 

1 

Integer Array 


100 

1 

1.7 | 

1 

Integer Array 


1000 

1 

1.5 | 

1 

Integer Array 


10 000 

1 

8 . s ; 

1 

Integer Array 


100000 

1 

17.8 j 

1 

1-D Dynamically bounded 

Array 

1 

1 

15.2 j 

1 

1-D Dynamically bounded 

Array 

1 0 

1 

30.0 ( 

1 

2-D Dynamically bounded 

Array 

1 

1 

2 1.1 j 

1 

2 - D Dynamically bounded 

Array 

100 

1 

47.7 j 

1 

3-D Dynamically bounded 

Array 

1 

1 

45.8 j 

1 

3-D Dynamically bounded 

Array 

1000 

1 

0.0 j 

1 

Record of Integer 


1 

1 

0.7 i 

1 

Record of Integer 


1 0 

1 

1.8 j 

1 

Record of Integer 


100 

1 


Note: Time* reported include any deallocation required upon leaving tbe acope 
of tbe declared variable*. 


Benchmarks-Ada 


127 


RSD-12-80 


Number of Iterations — 1000 


Dynamic Allocation with NEW allocator 



Time |# 

(microsec. )j 

Declared 

1 Type 

| Declared 

| Site of 

j Ob j e c t 

» 4 

i 

1 

2 5 0 

1 

Integer 

1 

1 


1 

240 

1 

En nme ration 

1 

1 


1 

250 . 

1 

Record of Integer 

1 

1 

ii 

1 

240 

1 

Record of Integer 

1 

5 

|l 

1 

250 

1 

Record of Integer 

1 

10 


1 

250 

1 

Record of Integer 

1 

20 


1 

250 

1 

Record of Integer 

1 

50 


1 

250 

1 

Record of Integer 

1 

100 


1 

260 

1 

String 

1 

1 


1 

260 

1 

String 

1 

10 


1 

260 

1 

String 

1 

100 


1 

250 

1 

Integer Array 

1 

1 


1 

250 

1 

Integer Array 

1 

10 


1 

2 4 0 

1 

Integer Array 

1 

100 


1 

230 

1 

Integer Array 

1 

1000 


1 

200 

1 

1-D Dynamically Bounded 

Array | 

1 


1 

300 

1 

1-D Dynamically Bounded 

Array | 

10 


1 

300 

1 

2 -D Dynamically Bounded 

Array | 

1 


1 

280 

1 

2-D Dynamically Bounded 

Array j 

100 


1 

370 

1 

3-D Dynamically Bounded 

Array | 

1 


1 

370 

1 

3-D Dynamically Bounded 

Array j 

1000 



128 


Bench marks* Ad a 



RSD-12-80 


Numb e r 


of Iteration! =» 1 0000 


Exception Handler Tests 

! ' •' ■ ■ - PI Hill" — — M I .'..II' 


Exception raised 
3 oSEC. 

414 uSEC. 

532 nSEC. 

541 nSEC. 

500 nSEC. 

541 nSEC. 

524 nSEC. 


and bandied in a block 
User Defined, Not Raised 
User Defined 

Constraint Error, Implici 
Constraint Error, Explici 
Numeric Error, Implicitly 
Numeric Error, Explicitly 
Tasking Error, Explicitly 


t 

t 


I J 

I y 

Ra i 
Ra i 
Rai 


Ra i s 
Ra i s 
s ed 
s ed 
s e d 


e d 
ed 


Except 
1 2 
482 
810 
508 
507 
605 
503 


ion raised La a procedure and bandied 


nSEC. 

User Def 

i n ed , 

No t 

Ra i s 

e d 

nSEC. 

User Def 

i n ed 




nSEC . 

Constraint Error, 

Imp 1 

i c i t 1 y 

nSEC . 

Co n s t r a i 

n t Error, 

Exp 1 

i c i t 1 y 

uSEC . 

Nume r i c 

Error 

Imp 1 i c i 

t ly Ra 

uSEC . 

Nume r i c 

Error 

Exp 1 i c i 

t ly Ra 

u S EC . 

Tasking 

Error 

Exp 1 i c i 

t ly Ra 


in tbe calling 


Raised 
Raised 
i s e d 
i s e d 
i s ed 


unit 


Benchmarks- Ads 


129 



RSD-12-86 


Task Elaborate, Ac t i t» t e , and Terminate Time: Declared Object, No Type 
Number of Iterations = 100 

For test n imb e r 1 

Task elaborate, activate, terminate time: 6.4 milliseconds. 


Task Elaborate, Activate, and Terminate Time: Declared Object, Task Type 
Number of Iterations = 100 

For test nnmb e r 1 

Task elaborate, activate, terminate time: 6.6 milliseconds. 


Task Elaborate, Activate, and Terminate Time: NEW Object, Task Type 
Number of Iterations = 100 

For test numb e r 1 

Task elaborate, activate, terminate time: 7.8 milliseconds. 




130 


Benchmarks- Ada 


RSD-12-80 


Rendezvous Time: No Pirtmeteri Pissed 

Number of Iterttiois =* 100 


Tnzk ReidtiTogg Time: 1.1 mi 1 I i t econds 


Benchmarks- Ad a 


131 


RSD-12-83 


Number of Iterations = 10000 

Clock foactioa calling overhead 89 microseconds. 


132 


Benchmarks- Ada 


RSD-12-88 


Number of I t erat i om = 1 0000 * 1 0 


TIME and DURATION math 


Microseconds Operation 


91.2 

Time 

:=e 

Var.t ine + Va r_d u ra t i o n 

91.6 

Time 

: = 

Var.t ime - Var.durat ion 

90 . 8 

Time 

:=» 

Var_duration + Var_t ime 

02.0 

Time 

:» 

Var.t ime - Coist.durat ioa 

94 . 3 

Di rat 

I OB 


=*Var_iime - Var.t i me 

0 . 4 

Du r at 

1 OB 


=» Var.durat i on + Var.durat i on 

0 . 8 

Durat 

i O B 


=• Var.durat i oa - Var.durat ion 

0 . 9 

Du r a t 

i O B 


=■ Var.dnration + Cons t_du rat i on 

0 . 8 

Durat 

i O A 


=* Var.durat i oa - Consideration 

0 . 0 

Durat 

i o ■ 


= Consideration + Var.durat ion 

1 . 1 

Durat 

i OB 


=* Consideration - Var.duration 

0 . 9 

Durat 

i O B 


Co n s t _d u r a t i o n + Coos t.durat i 

0 . 8 

Durat 

i O B 


=* Co n s t _da r a t i o n • Const.durati 


o n 
o n 


Benchmarks-Ada 


133 


