VERY HIGH SPEED INTEGRATED CIRCUITS (VffilC) 
HARDWARE DESCRIPTION LANGUAGE (VHDL) 

SYNTAX AND SEMANTICS SUMMARY 



Michael T. Mills 
Design Branch 
Microelectronics Division 


January 15, 1991 


Final Report for Period June 1990 to June 1991 



Approved for public release; distribution unlimited. 


SOLID STATE ELECTRONICS DIRECTORATE 

WRIGHT LABORATORY 

AIR FORCE SYSTEMS COMMAND 

WRIGHT-PATTERSON AIR FORCE BASE, OHIO A5433-6543 


92-07717 







NOTICE 


When Government drawings, specifications, or other data are used for any purpose 
other than in connection with a definitely related Government procurement operation, 
the United States Government thereby incurs no responsibility nor any obligation 
whatsoever; and the fact that the government may have formulated, furnished, or in 
any way supplied the said drawings, specifications, or other data, is not to be re¬ 
garded by implication or otherwise as in any manner licensing the holder or any 
other person or corporation, or conveying any rights or permission to manufacture 
use, or sell any patented invention that may in any way be related thereto. 


This report has been reviewed by the Office of Public Affairs (ASD/PA) and is 
releasable to the National Technical Information Service (NTIS). At NTIS, it will 
be available to the general public, including foreign nations. 


This technical report has been reviewed and is approved for publication. 


7 , 

MICHAEL T. MILLS, LtCol, USAFR 
Design Branch 
Microelectronics Division 


-If 






JOHN W, HINES, Chief 
Design Branch 
Microelectronics Division 


FOR THE COMMANDER 


[ANLEY E./WAGNER< Chief 


STANLEY EyWAGNERif Chief 
Microelectronics Division 
Solid State Electronics Directorate 


If your address has changed, if you wish to be removed from our mailing list, or 
if the addressee is no longer employed by your organization please notify WL/ELED 
W-PAFB, OH 45433 to help us maintain a current mailing list. 


Copies of this report should not be returned unless return is required by security 
considerations, contractual obligations, or notice on a specific document. 




REPORT DOCUMENTATION PAGE 


Form Approved 
0MB No. 0704-0188 


Public reporting burden for thi) collection of information is estimated to average t hour per response, including the time for reviewing instruaions. searching existing data sources, 
gathering and maintaining the data needed, and completing and reviewing the colleaton of information. Send comments regarding this burden estimate or any other aspea of this 
collection of information, including suggestions for reducing this burden, to Washington Headquarters Services, Directorate for information Operations and Reports, 121S iefferson 
Oavis Highway, Suite 1204. Arlington, VA 22202-4302, and to the Office of Management and Budget. Paperwork Reduction Project (0704-0188), Washington, DC 20S03. 


AGENCY USE ONLY (Leave blank) 


2. REPORT OATE 

15 January 1991 


4. TITLE AND SUBTITLE 

very High Speed Integrated Circuits (VHSIC) Hardware 
Description Language (VHDL) Syntax and Semantics 
Sunmary 


6. AUTHOR(S) 

Mills, Michael T. 


3. REPORT TYPE AND DATES COVERED 

FINAL June 1990 - June 1991 


5. FUNDING NUMBERS 

PE 62204F 
PR 6096 
TA 4 0 
WU 18 


7. PERFORMING ORGANIZATION NAME(S) AND ADORESS(ES) 

Darrell Barker, (513) 255-4448 

Solid State Electronics Directorate (WL/ELED) 

Wright-Patterson AFB OH 45433-6543 


B. PERFORMING ORGANIZATION 
REPORT NUMBER 


WL-TR-91-5030 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 


10. SPONSORING/MONITORING 
AGENCY REPORT NUMBER 


111. SUPPLEMENT /NOTES 


The co; uter code contained herein are theoretical 

and/or references that 

in no way reflect Air Force-owned or -developed computer software. 

12a. DISTRIBUTION/AVAILABILITY STATEMENT 

12b. DISTRIBUTION CODE 

Approved for public release; distribution is 
unlimited 


13. ABSTRACT (Maximum 200 words) 


This is a depth-first ordered VHDL syntax summary with annotated 
semantics and corresponding paragraph numbers to VHDL and Ada Reference 
Manuals. The BNF representation of VHDL is cross-referrenced to 
comparable VHDL and Ada syntax and semantic descriptions within the VHDL 

and Ada language reference manuals (LRM). 



14. SUBJECT TERMS 

VHDL-IEEE 1076-Design Language-Hardware Description 
Language Ada 


16. PRICE CODE 


17. SECURITY CLASSIFICATION 118. SECURITY CLASSIFICATION 119. SECURITY CLASSIFICATION I 20. LIMITATION OF ABSTRACT 

OF REPORT I OF THIS PAGE I OF ABSTRACT I 


UNCLASSIFIED 


MSN 7540-01-280-5500 


UNCLASSIFIED 


UNCLASSIFIED 


5tandard Form 298 (Rev 2-89) 

Prev:r»bed by ANSi Sto 239-18 



























Table of Contents 


i’ag<' 


I. liil roduclioii . I 

II. VHDL Syntax and Semantics Summary. 


iii 


iooeaslon For 


NTIS GKAftI 


DTIC tab 

□ 

Uimnnovnced 

□ 

J’j 3i " 0 >1L1 on_ 


Bv__ 

Dliitr Ibiit. Ion/ 

ability CodoB 
jAvall snd/or' 
t'lst j Special 

.1 








/. Introduction 


riiis product, ri'sultinl from the first step of developing a VH 1)L to Ada iiitcrfac<'. 'I'liis ordering 
(jf tlie BNF representation of VHDL should help reduce the time for new VHDL implementors and 
programmers to overcome the robustness of the VHDL syntax and semantics. It could serve as an 
im[)lementor’s guide for dcvelopitig VHDL software tools and help VHDL progranmuMS remcmlu'r 
rhe details of the V'HDL syntax and semantics without having to thumb through the scattered 
bits and i)ieres of syntax scattered in the syntax summary of the reference' manual. 'I’liis VHDL 
Summary could also help insure validation test coverage by jiiiiing the validat ion test writi r to kee p 
track of each detail incorporated in the VHDL language. The annotated .semantics consist of brii-f 
d< script ions to serve as reminders. It is not meant to take the place of the ilet aih'd ti'xt in the 
\’HDL re'h'rence manual. Also, the behavioral portions of the VHDL syntax incliule commented 
.\da Fteference Manual paragraph numbers when corresponding Ada functionality i-xists. .All VHDL 
syntax and semantics included in this product are taken from the VHDL reference man'ed but are 
reordered for clarity, d'he s('mantics in this summary is not completely defined, but includes enough 
detail to guide the programmer or implementor. 


1 





II. VHDL Syntax and Semantics Sunnnary 


Note: and "<>" are terminals and should be distinguished 

irom the non-terminal <text>. 

Non-terminals are represented by enclosing "<" and 

Itallic portions of non-terminals in the reference manual 

are designated by enclosing them in quotes <"text"_more_text>. 

All comments axe preceded by double dashes — . 

Everything except VHDL syntax is in comments, preceded by — . 
Therefore, the reordered BNF description of the VHDL syntax cam 
be used to drive a VHDL parser for automated tools. 

VHDL paragraph numbers are preceded by "— VHDL". When they 
exist, corresponding Ada paragraph numbers are preceded by 
"— Ada". (Where feasible, parts of productions with 
corresponding Ada equivalence are followed by "—a". 

Note: <underline> is equivalent to the terminal 

The symbol "'" refers to the line above the current one. 

Semamtic annotations (comments) are preceded by "— SEM:". 

Most up-level references are symbolized by "-"". 


<design_file> ::= <design_unit> { <design_unit> } —:2,2: — VHDL 11.1 

— SEM: Design units may be independently analyzed and inserted into 
design library. They are analyzed in textual order. 

A design library is an implementation dependent storage of 
previously analyzed design units. 


<design_unit> ::= <context_clause> <library_unit> — VHDL 11.1 

—:3,8: 




--:*4: 


— ;»S; 




<context_clause> ::= <context_item> —:4: — VHDL 11.3 


<context_item> ::= <library_clause> I <use_clause> — VHDL 11.3 

—:5,180: 

<library_clause> ::= library <logical_name_list> ; — VHDL 11.2 

— : 6 : 

— SEM: This defines logical names for design libraries. 
Scope extends to end of declarative region 
associated with design unit. 

Each library ncune denotes a design library. 

Two classes of design libraries: (See 11.2) 
Working libraries and resource libraries. 

<logical_name_list> ::= <logical_name> •( , <logical_neune> } 

—:6,6: — VHDL 11.2 


2 




; ♦7: 


<logical_nanie> ::= <identifier> —:49: — VHDL 11.2 

— SEM: STD denotes library where package STANDARD 
and package TEXTIO reside. (See Chapt 14). 

— <use_clause> ;:= —:180: (see below) — VHDL 11.2 Ada 8.4 

— SEM: This makes declarations visible in design unit 
and defines dependencies among design units. 


;* 8 : 

<library_unit> ;;= <primary_unit> I <secondary_unit> 

“:9,10: — VHDL 11.1 Ada 10.1 

— SEM: Secondary unit is a separately emalyzed body of primary unit. 


:*9: 


:* 10 : 


<primary_unit> : : = 

— VHDL 

<entity_declzLration> 

—: 11 

1 <configuration_declaration> 

— :56 

1 <package_declaration> 

— :63 


<secondary_unit> ::= 

— VHDL 

<architecture_body> 

— :66 

1 <package_body> 

— :71 


Ada 10.1 


Ada 10.1 


— SEM: Of secondary units, only architecture bodies are named. 
Primary units within library cind architecture bodies 
associated with a given entity must have unique names. 
Must analyze all primary units before Malyzing design 
unit which uses (or references) them and before 
corresponding secondary units. 


— Note: A design entity is the primary hardweure abstraction in VHDL. 

A collection of design entities form a design hierarchy. An 
<entity decleLration> can potentially represent a "class" of 
design entities, each with the seune "interface". 

<configuration_declaration> describes how design entities are 
put together. 


<entity_declaration> ::= 
entity <identifier> is 
<entity_header> 


— VHDL 1.1 

— :49: 

—: 12 : 


3 








<entity_declarative_part> —;52: 

[ begin <entity_statement_part> ] —:54: 

end [ <"entity"_siinple_name> —;178: 


♦ 12 : 

<entity_header> ::= 

[ <"formal"_geneTic_clause> ] 
[ <"formal"_port_clause> ] 


— VHDL 1.1.1 

— :13: 

— :14: 


— SEM: declares "objects" for conununieating with environment. 


♦ 13: 

<generic_clause> ::= — VHDL 1.1.1 

generic ( <generic_list> ); — Note: Completely different 

—:15: — from Ada generic. 

— SEM: values (constants) may be determined by environment 

via <"generic"_association_list> of a component instant. 
Generics may control structural, dataflow, or behavioral 
characteristics of block or simply document. 

— SEM: ERROR if no actual or no default is specified. 


♦ 14: 


<port_clause> ::= 

port ( <port_list> ); 


— :16: 


— VHDL 1.1.1 


— SEM: defines I/O ports of design entity. 


-- SEM: Both can be visible outside of design entity. 


♦ 15: 


<generic_list> ::= <"generic"_interface_list> 

— :17: — VHDL 1.1.1.1 

— SEM: defines generics of a block. Each interface 
element declao'es a formal generic. 


♦ 16: 


<port_list> ::= <"port"_interface_list> 

— :17: — VHDL 1.1.1.2 

— SEM: defines communication channels between 

block and environment. Ports are signals. 
The actual (or calling) paraoneter must be 
a static naune. 

See 1.1.1.2 for list of restrictions. 


♦ 17 : 


<interfaco_list> :;= 

<interface_element> { <interface_element> } 
—:18,18: — VHDL 4.3.3.1 

— SEM: "Generic" interface list consist 
entirely of interface "constant" 






declarations. 

"Port" interlace list consists 
entirely of interface "signal" 
declarations. 

"Paurameter" interface list may contain 
interface "constant", "signal", or 
"variable" declarations. 

These are interface "objects" required 
by a subprogreun, component, design 
entity, or block statement. 

(See pages 2-2 thru 2-4 on parauneters.) 


♦ 18; 


<interface_element> :;= <interface_declaration> 
—:19; — VHDL 4.3.3.1 


♦ 19; 


<inteTface_declairation> ;;= — VHDL 4.3.3 

<interface_constcint_declaration> —;20 
1 <interface_signal_declaration> —;21 
I <interface_variable_declaration> —;22 


* 20 ; 

<interface_constant_declaration> ;:= — VHDL 4.3.3 

[constant] <identifier_list> : [in] <subtype_indication> —;17,23; 

[:= <"static"_expression> ] --;27; 

— SEM; Subtype cannot be file type or access type. 


♦ 21 ; 

<interface_signal_declaration> : 
[signal] <identifier_list> 


;= — VHDL 4.3.3 

: [mode] <subtype_indication> [bus] 
[:= <"static"_expression> ] 

— ; 17,23,27; 


— SEM; Subtype cannot be file type or access type. 

"Bus" meams signal is guarded and of signal kind bus. 
See pg. 4-9 amd 4-10 for more detailed restrictions. 


♦ 22 : 

<interface_variaDle_declaration> ::= — VHDL 4.3.3 

[variable] <identifier_list> ; [mode] <subtype_indication> —;17,23; 

[;= <"static"_expression> ] --;27; 


♦ 23; 


<subtype_indication> ::= 


— VHDL 4.2 Ada 3.3.2 


.5 









[ <"resolution_fimction"_naine> ] <type_mark> [<constraint>] 

—:34, 4,25: 

— SEM: Resolution function means signal of that 
subtype is resolved by named function 
(see 2.4). It defines how values of multiple 
sources of a signal are resolved into a 
single value. 

Subtype indication denoting access type or 
file type cannot contain resolution function. 
(See both 2.4, 4.2 and 4.3.1.2 on resolution 
function.) 


:*24; 


:*25; 




<type_mark> ::= <"type"_ncime> I <"subtype"_name> — 

—:34,34: — VHDL 4.2 Ada 3.3.2 

<constraint> ;:= <range_constraint> I <index_constraint> 
— : 140,159; — VHDL 4.2 Ada 3.3.2 


<identifier_list> ::= <identifier> [, <identifier> ] —: 

--:49,49: — VHDL 3.2.2 Ada 3.2 


Here are some low level definitions 

:*27; 

<expression> ::= 

<relation> { and <relation> } 

I <relation> { or <relation> } 

I <relation> { xor <relation> } 

I <relation> { nand <relation> } 
I <relation> •( nor <rolation> } 


before we go on; 

— VHDL 7.1 Ada 4.4 
—a 
—a 
—a 

— :28,. 

• Note: ... means repeat reference. 


: *28: 


: *29: 


<relation> ::= — VHDL 7.1 Ada 4.4 

<simple_expression> [ <relational_operator> <simple_expression> ] 

—:29,48,29: 

<simple_expre3sion> : := — VHDL 7.1 Ada 4.4 

[ <sign> ] <term> { <adding_operator> <term> } —;30,47,31: 


: *30; 


<sign> :;= + 


— VHDL 7.2 


: *31 : 


<term> ::= — VHDL 7.1 Ada 4.4 

<factor> { <multiplying_operator> <factor> } 

—:32,46,32: 


6 





*32; 


*33: 


*34; 


<factor> ;:= — VHDL 7.1 Ada 4.4 

<primary> [ *♦ <primary> 3 
I abs <primary> —:33; 

I not <priinary> —:33; 


<primary> :;= — VHDL 7.1 

Ada 4 

4 

<naine> 

-- 

34: 

1 <literal> 

— 

37 

1 <aggregate> 

— 

89 

1 <function_call> 

— 

87 

1 <qualified_expression> 

-- 

43 

1 <type_conversion> 

— 

44 

1 <allocator> 

— 

45 

1 ( <expression> ) 

— 

27 


<naine> ::= — VHDL 6.1 Ada 4.1 


<simple_neune> —: 178 

1 <operator_symbol> —:126 

t <selected_naine> —:181 

I <indexed_nanie> —:35: 

I <slice_naaie> —:36: 

I <attribute_naine> —:95: 


*35: 


♦ 36: 


*37 : 


• 38 : 


<inQexed_naine> ::= — VHDL 6.4 Ada 4.1.1 

<prelix> ( <expression> { , <expression> } ) 

— ; 96,27,27; 

<slice_najne> ::= <prefix> ( <discrete_range> ) 


<literal> 

<nunier:' c_literal> 

I <onuineration_literal> 
I <string_literal> 

! <bit_string_literal> 

I null 


<nuineric_literal> :: = 
<abstract_literal> 

I <physical_literal> 


— VHDL 6.5 Ada 4.1 

—:96,93: 


— VHDL 7.3.1 Ada (4.4) 
—a --:38: 

—:135: 
--a —:39: 
— :40: 

—a 


Ada 2.4 
—;146: 
145: 


VHDL 7.3.1 














*39: 


*40: 


<string_literal> ::= " { <graphic_character> } " 

—:137: — VHDL 13.6 Ada 2.6 


<bit_3tring_literal> ::= — VHDL 13.7 

<base_apecifier> " <bit_value> " --:41,42: 


*41: 


<base_specifier> ::= B I 0 I X — VHDL 13.7 


*42: 


<bit_value> ::= — VHDL 13.7 

<extended_digit> —:153: 

{ [ <underline> ] <extended_digit> > 

—:_,153: 

— Note: <underline> is a lexical 
— representation of terminal . 


*43: 


<qualilied_expression> ::= — VHDL 7.3.4 Ada 4.7 

<type_mark> ’ ( <expression> ) —:24,27: 

I <type_mark> ’ <aggregate> —:24,89: 


*44: 


*45: 


♦46: 


<type_conversion> ::= <type_mark> C <expression> ) 

—:24.27: — VHDL 7.3.5 Ada 4.6 


<allocator> ::= 

new <subtype_indication> 

I new <qualified_expression> 


— VHDL 7.3.6 
-- —:23: 

-- --;43; 


<inultiplying_operator> ::= ♦ | \ | mod I rem — VHDL 7.2 Ada 4.5 


*47: 


<adding_operator> ::= + I - I ft 


— VHDL 7.2 


*48: 


<relational_operator> ::= = I /= I < I <= I > I >= 

— VHDL 7.2 Ada 4.5 


(end of <expression>) 


*49: 

<identifier> ::= -- VHDL 13.3 Ada 2.3 

<letter> { [ <underline> ] <letter_or_digit> } —:50,_,51: 

— <underline> is a lexical element. 


*50: 


8 






<letter> 


:*51: 


::= <upper_ca8e_letter> I <lower_case_letter> — See Note 

— VHDL 13.3 Ada 2.3 

<letter_or_digit> ::= <letter> I <digit> — VHDL 13.3 Ada 2.3 

—:50: — <digit> is a lexical element. 

— Note; <underline>, <upper_case_letter>, cind 

<lower_ca3e_letter> are lexical representations ot 
terminals. 

- (end of <identifier>) 


:*52: 


<entity_declarative_part> ;= {<entity_declarative_item>} — VHDL 1.1.2 

— :53: 

— SEM; Declarations are common to all design entities whose 
interfaces are defined by entity declaration. 


:*53: 


<entity_declarative_item> 
<subprogram_declaration> 
<3ubprogram_body> 
<type_declaration> 
<subtype_declaration> 
<constant_declaration> 
<signal_declaration> 

<file_declaration> 
<alias_declaration> 
<attribute_declaration> 

<attribute.specification> 
<disconnection_specification> 
<use_clause> 


— VHDL 1.1.2 


122 

127 

130 

166 

167 

184 

169 

172 

173 

174 
186 
180 


: ♦54; 


<entity_statement_part> ::= ■{ <entity_statement> } 


VHDL 1.1.3 —:55; 


:^55: 

<entity_statement> ::= <concurrent_assertion_statement> -- VHDL 1.1.3 

I <"passive"_concurrent_procedure_call> 

I <"passive"_process_statement> 

—;74,77,166:- 


— SEM: All such statements are passive (see 9.2). 


9 












They may monitor operating conditions or characteristics 
of design entity. 


—:*56: 

<configuration_declaration> : := — VHDL 1.3 

configuration <identifier> of <"entity"_name> is —:49,34: 

<conf iguration_declarative_p 2 irt> —:57: 

<block_configuration> —:58: 

end [ <"configuration"_simple_name> ] ; —:178: 


— SEM: Specifies deferred bindings of component instances of 
design entities. Must reside is same library as it' 
corresponding entity declaration. <entity_naine> is 
apex of design hierarchy. Elaboration achieves effect. 
Used to build more complex configurations. 


--;*57: 

<configuration_declarative_part> ::= 

{ <configuration_declarative_item> } 


— VHDL 1.3 
— :57a: 


--:*S7a: 

<configuration_daclarative_item> : : = 
<use_clause> 

1 <attribute_3pecification> 


— VHDL 1.3 
—:180: 
—:174: 


—:*58: 

<block_configuration> 

for <block_specification> 

{ <use_clause> } 

{ <configuration_item> } 
end for; 


— VHDL 1.3.1 

— :59 
—:180: 

— :61: 


--:*59: 


<block_specification> ;:= 
<"architecture"_name> 

I <"block_statement"_label> 

I <"generate_8tatement"_label> [ ( 


— VHDL 1.3.1 
— :34: 

— :75: 

<index_specification> 
—:7S.60: 


] 


— SEM: identifies internal or external block to which 
block configuration applies. 

See 1.3.1 for detailed restrictions. 


--:*60: 


--:*61: 


<index_specification> ::= 
<discrete_range> 

I <"8tatic"_expression> 


— VHDL 1.3.1 

— :93: 

— :27: 


10 








<configuration_itein> :: = 
<block_conliguration> 

I <component_conliguration> 


— VHDL 1.3.1 

— :58: 

— :62: 


<component_configuration ;:= — VHDL 1.3.2 

lor <component_specilicatioii> —:191: 

[ use <binding_indication> ; ] —:193; 

[ <block_conliguration> ] —:58: 

end lor ; 

— SEM: defines configuration of one or more 
component instances in block. 

— SEM: applies to component instances within block. 

— SEM: ERROR if explicit configuration specification 

(in aurchitecture body) and component 
configuration containing binding indication 
apply to saime component instance. 

(More details on pages 1-12 and 1-13.) 

— Mote' <block_configuration> is recursive. 


--:*63: 

<package_declaration> ::= 
package <identifier> is 

<package_declarative_part> 
end [ <"package"_simple_name> ] 


— VHDL 2.5 Ada 7.1 

— :49: —a 

— :64: 

— :178: —a 


— SEM: A subprogram written in amother language can be made 
available by defining its interface via a subprograun 
declauration within a package declaration with no body. 
Built-in functions of simulator can use this. 


--:*64: 

<package_declarative_part> ::= 

{ <package_declarative_item> } 


— VHDL 2.6 Ada 7.1 

— :65: —a 


♦65: 

<package_declarative_item> ::= 
<subprogram_declaration> 

I <type_declaration> 

I <subtype_declauration> 

I <constaLnt_declairation> 

I <signal_declaration> 

I <file_declaration> 

I <alias_declaration> 

I <component_declaration> 


— VHDL 2.5 

— :122: —a 

—:130: 

—:166: 

—:167: 

—:184: 

—:169: 

—:172: 

—:189: 


11 










<attribute_declaration> 

—: 173: 


<attribute_specification> 

—:174: 


<disconnection_specification> 

—: 186: 


<use_clause> 

—:180: 

—a 


—:* 66 : 

<architecture_body> ::= — VHDL 1.2 

architecture <identifier> ol <"entity"_name> is —;34: 

<architecture_declarative_part> —:67: 

begin 

<architecture_statement-part> —:69: 

end C <"architecture"_simple_ncune>; —:178; 


— SEM: defines body of design entity. It specifies relationships 

between inputs and outputs of design entity, emd may express 
structure, dataflow, or behavior. It must reside in same 
design library as its associated entity declaration. Can 
have more than one architecture body per entity. 


—:*67: 

<architecture_declarative_part> ::= { <block_declarative_item> } 

— VHDL 1.2.1 —:68: 

— SEM: Declarations are available to block defined by design 
entity. 


—:* 68 : 

<block_decl 2 urative_item> ::= 
<subprograni_declaration> 

I <subprograjn_body> 

I <type_declaration> 

I <subtype_declaration> 

I <constant_declaration> 

I <signal_declaration> 

I <file_decleuration> 

1 <alias_declaration> 

I <component_declaration> 

I <attribute_declaration> 

I <attribute_specification> 

I <configuration_specification> 
I <disconnection_specification> 
I <use_clause> 


— VHDL 1.2.1 
—: 122 : 

—:127: 

—:130: 

—:166: 

—:167: 

—:184: 

—:169: 

—:172: 

—:189: 

—:173: 

—:174: 

—:190: 

—:186: 

—:180: 


--:*69: 

<architecture_statement_part> ::= { <concurrent_statement> )• —:70: 

— VHDL 1.2.2 

— SEM: These statements describe internal organization and/or 
operation of block defined by design entity. 


12 













-:*70: 


<concurrent_statement> ::= — VHDL 9 

<block_statement> 

I <process_statement> 

I <concurrent_procedure_call> 

I <concurrent_as8ertion_statement> 

I <concurrent_signal_a3sigiment_statement> 

I <componant_instantiation_statement> 

I <generate_statement> 


112 : 

166: 

77: 

74: 

86 : 

106: 

109: 


— SEM: define interconnected blocks 2 md processes that 
jointly describe the overall behavior or 
structure of a design. Concurrent statements 
execute asynchronously with respect to each 
other. 


Note: <generate_statement> includes the nonterminal 
<concurrent_.statement> which is recursive. 


--:»71: 

<package_body> ::= 

package body <"package"_simple_name> is 
<package_body_declarative_part> 
end [ <"package"_simple_nanie> ] ; 


— VHDL 2.6 Ada 7.1 
—:178: 

— :72: 

—:178: 


— SEM: Package body is unnecessary if no subprograms or deferred 
constants are declared in package declaration. 


—:*72: 

<package_body_declarative_part> : : = 

{ <package_body_declaLrative_item> )• 


— VHDL 2.6 Ada 7.1 

— :73: 


--:*73: 

<package_body_decl 2 Lrative_item> : : = 
<3ubprograni_declaration> 

I <subprograni_body> 

I <type_declaration> 

I <subtype_declaration> 

I <constant_declaration> 

I <file_declaration> 

I <alias_declaration> 

I <u3e_clause> 


— VHDL 2.6 

— :122: —a 

—:127: 

—:130: 

—:166: 

—:167: 

—:169: 

—:172: 

— :180: —a 


-- How, continue breaking down architecture body definition: 
-- Note; The following make up <concurrent_statement>. 


13 












:*74: 


;’*75: 


:*75a: 


<concurrent_assertion_statment> ::= — VHDL 9.4 

[ <label> :] <assertion_statement> —:75,75a: 

— SEM: represents a passive process statement 

containing the specified assertion statement. 
For every concurrent assertion statement, there 
is an equivalent process (assertion) statement. 

<label> ::= <identifier> —:49: — VHDL 9.7 Ada 5.1 


<assertion_statement> ::= 
assert <condition> 

[report <expression> ] 
[severity <expression> ] 


— VHDL 8.2 

— :76: 

— :27: 

— :27: 


:*76: 


<condition> ::= <"boolean"_expression> —:27: 

— VHDL 8.1 Ada 5.3 


:*77: 


<concurrent_procedure_call> ::= — VHDL 9.3 

[ <label> :] <procedure_call_statement> —:75,78: 

— SEM: represents a process containing the 

corresponding sequential procedure call. 
For every concurrent procedure call, there 
is au equivalent process statement. 


:*78: 


<procedure_call_statement> ::= — VHDL 8.5 Ada 6.4 

<"procedure"_n 2 UBe> [( <actual_parajneter_part> )] 

—:34,79: 


— SEM: invokes the execution of a 
procedure body. 

Execution of a procedure call 
includes evaluating actual 
parameters and expressions 
associated with formal parameters. 


:*79: 

<actual_parameter_part> ::= 

<"par 2 uaeter"_association_list> —:80: 

— VHDL 7.3.3 Ada 6.4 


14 






-:*80: 


<association_list> — VHDL 4.3.3.2 Ada 6.4 

<a3sociation_element> {, <association_element> } 

“:81,81: 


— SEM: Corresponds formal generic, port, or 
pareineter naunes with actual names or 
expressions. 


—:*81: 


<association_element> ::= — VHDL 4.3.3.2 Ada 6.4 

[ <formal_part> => ] <actual_part> —:82,84: 

— SEM: Associates actual part with 

interface element in subprograun, 
component, entity, or block decl. 
See pg. 4-12 for details. 


--:*82: 


— •.♦83; 


--■.♦84: 


<formal_part> ::= — VHDL 4.3.3.2 Ada 6.1 

<formal_designator> 

I <"function"_name> ( <formal_designator> 

—:83,34,83: 

<formal_designator> ::= <"generic’’_name> 

I <"port"_name> 

I <"parameter"_naune> 
— : 34,34,34:* — VHDL 4.3.3.2 

<actual_part> - VHDL 4.3.3.2 

<actual_designator> 

I <"function"_name> ( <actual_designator> ) 

—:85,34,85: 


--:^85: 


<actual_designator> ::= <expression> 

I <"signal"_naime> 

I <"variable"_name> 
I open 

— ;27,34:,34;* -- VHDL 4.3.3.2 


— * 86 : 


<concurrent_signal_assignment_statement> ::= 

[ <label> :] <conditional_signal_assignraent> 
I [ <label> :] <solected_signal_assignment> 


VHDL 9.5 
— ;75,87; 
—:75,104: 


15 






SEM: represents an equivalent process statement that 
assigns values to signals. See pgs 9-6 and 9-7. 


♦87: 


♦ 88 : 


<conditional_signal_assigninent> :;= — VHDL 9.5.1 

<target> <= <options> <conditional_waveforms> 

— : 88 , 100 , 101 : 


— SEM; represents a process statement in which the 
signal transform is an "if statement". 

See example on page 9-9. 


<target> ;;= <name> I <aggregate> — VHDL 8.3 

—:34,89; 


♦89: 


<aggregate> ::= — VHDL 7.3.2 Ada 4,3 

( <element_association> —:90: 

<element_association> >) --:90: 


♦ 90: 


<element_association> ::= 

[ <choices> => ] <expression> —-.91,27: 

— VHDL 7.3.2 Ada 4.3 


♦91: 


<choices> ::= <choice> i I <choice> } 
— VHDL 7.3.2 Ada 4.3 
—:92,92: 


♦92: 


♦93: 


<choice> :;= <simple_expression> 

I <discrete_rcinge> 

1 <"element"_simple_ncune> 
I others 

—:29,93,178:‘ 

— VHDL 7.3.2 Ada 3.7.3 


<discrete_rauige> :;= — VHDL 3.2.1 

<"discrete"_subtype_indication> 

I <rsuige> 

—:23,94: 


♦94: 


<r 2 mge> ::= <"r 2 inge"_attribute_namo> — VHDL 3.1 Ada 3.5 

I <simple_exprossion> <direction> <simple_expression> 

— : 29,99,29: 


♦95; 


16 






*96: 


<attribute_naae> ::= — VHDL 6.6 Ada 4.1.4 

<prefix> ’ <attribute_designator> 

[( "static"_expression> )] 

—:96.98,27; 


<prefix> ;:= <neLflie> I <fuiiction_call> —:34,97: 

— VHDL 6.1 Ada 4.1 


♦97: 


<lunction_call> ::= — VHDL 7.3.3 Ada 6.4 

<*'lunction"_najne> [( <actual_paraineter_part> )] 

—:34,79: 


♦ 98: 


<attribute_designator> ::= <"attribute"_simple_ncune> 
—:178: — VHDL 6.6 Ada 4.1.4 


♦ 99: 


<direction> ::= to I downto — VHDL 3.1 


♦ 100 : 

<option3> ::= [ guarded ][ transport ] — VHDL 9.5 

— SEM; "Guarded" specifies that the signal assignment 

statement executes when a signal guard changes from 
FALSE to TRUE, or when an event occurs on one of its 
while the signal is TRUE. 

"Transport"'specifies that the signal assignment has 
transport delay. 


♦ 101 : 


♦ 102 : 


♦103: 


<conditional_waveforms> ::= { <waveform> when <condition> else } 

<wavefoim> 

— VHDL 9.5.1 —: 102,76,102: 

<waveform> ::= <waveform_element> {, <waveform_element> 

— VHDL 8.3 103.103: 

<waveform_element> ::= — VHDL 8.3.1 

<"value"_expression> [ after <"time"_expression> ] 

I null [ after <"time"_expression> ] —:27,27,27: 

<condition> ::= -' —:76: 


♦ 104 : 


<selected_signal_as8ignaent> ::= — VHDL 9.5.2 

with <expression> select 

<target> <= <option8> <selected_waveforms> ; 


— ■. 21 : 








-:88,100,105: 




<selected_Havefonns> ::= 

{ <wavelorm> whan <choicos> 
<waveform> when <choices> 


— VHDL 9.5.2 
} —:102,91; 

—:102,91; 




<component_instantiation_statemont> : : = 

— VHDL 

<"in8tantiation"_label> : 

— :75: 

<"component"_name> 

— :34: 

C <generic_map_a8pect> ] 

—:107: 

[ <port_map_aspect> ] 

—:108: 


— SEM; defines a subcomponent of the design entity in 

which it appears and associates signals with the 
ports of that subcomponent. This subcomponent 
is one .nstauice of a class of components defined 
by a corresponding component declaration. 
"Component name" must be saune as naune declared 
in component declaration. 




<generic_map_aspect> ::= — VHDL 5.2.1.2 

generic map ( <"generic"_association_list> ) —:80: 

— SEM: can specify value of generic constant in 
<"goneric"_intorface_list>. 

Generic map aspect associates a single actual 
with each local generic in corresponding 
component declaration. 


-:*108: 


<port_map_aspect> :;= — VHDL 5.2.1.2 

port map ( <"port"_association_list> ) —:80: 

— SEN: associates a single actual with each local 

port in corresponding component declaration. 

— Mote: A configuration specification can bind a 
component instamce to a design entity and 
associate local generics emd ports of the 
component with formal generics and ports 
of that entity. 


-:* 109 : 


18 











— VHDL 9.7 


<generate_statement> :;= 

<"generate"_label> ; --:75: 

<generation_scheme> generate 

C <concurrent_statement> ] --:70: 

end generate [ <"generate"_label> ] —:75: 


— SIM: provides iterative or conditional elaboration 

of a portion of the description. 

— Note: <concurrent_8tatement> is a recursive 

nonterminal. -* —:70: 


:* 110 : 


: *111 : 


<generation_scheme> ::= — VHDL 9.7 

for <"generate‘*_parauneter_specification> —:111: 
I if <condition> —:76: 


<parameter_specification> ::= — VHDL 8.8 

<identifier> in <discrete_range> —:49,93: 

— Note: A specification associates additional 
information with a previously declared 
entity. 






: * 114 : 


<block_statement> ::= — VHDL 9.1 Ada 5.6 


<"block"_label> : 

--a --:75: 

block [ <"guard"_expression> 

--:27: 

<block_header> 

113 

<block_declarative_part> 

—a —:114 

begin 

—a 

<block_statement_part> 

—a —: 115 

end block [ <"block"_label> ] ; 

—a — :75: 


— SEM: defines an internal block representing a portion 
of the design ^md may be hierarchically nested. 


<block_header> •:= — VHDL 9.1 

[ <generic_clause> —:13: 

[ <generic_map_aspect> ;]] —:107: 

<block_declarative_part> ::= — VHDL 9.1 

{ <block_declarative_item> }• —:68: 

— Note: <block_declarative_item> is 


recursive. 










<bloclc_8tatem«nt_part> ::= — VHDL 9.1 

{ <concurrent_statement> > —:70; 

— Vote; this is another recursive part of 

nonterminal <concurrent_statement>. 


<process_statement> — VHDL 9.2 


[ <"process"_label> :] —:75: 

process [( <sensitivity_list> )] —;117: 

<proce88_declarative_peLrt> — :118: 

begin 

<process_statement_part> —:120: 

end process [ <"process"_label> ]; —:75; 


— SEM: defines an independent sequential 

process representing behavior of 
a portion of the design. 

— SEM: A passive process contains no 

signal assignment statement and 
may appear in an entity statement, 
part of em entity declaration. 


:*117: 


<sensitivity_list> — VHDL 8.1 

<"signal"_najne> {, <’'signal‘'_name> } 

—;34,34: 

— SEM: If <sensitivity_list> follows 

"process", then process statement 
contains an implicit wait 
statement as its last statement 
of the form: 

wait on <sensitivity_list>; 

Only static signal names may 
appear in sensitivity list. 


;*118: 


<process_declarative_part> ::= 

{ <process_declarative_item> > 


VHDL 9.2 
—:119: 


<process_declarative_item> ::= 

— VHDL 

<3ubprogrcUB_declaration> 

—: 122: 

1 <subprogram_body> 

—:127: 

1 <type_declaration> 

—:130: 


20 









I <subtype_declaration> 

I <constant_declaration> 

I <variable_declaration> 

I <file_declaration> 

I <alias_declaration> 

1 <attribute_declaration> 

I <attribute_specification> 

I <use_clause> 

<process_statement_part> ::= — VHDL 9.2 

{ <sequential_statement> } —;121; 

♦♦♦ Important point ♦♦♦ 

— SEM: This group of sequential statements 
executes repetitively. Immediately 
after the last statement executes, 
the first statement starts 
executing again. 


167 

168 
169 

172 

173 

174 
180 


--:* 121 : 


<sequential_statement> ::= — VHDL 8 Ada 5.1 
<wait_statement> —:196: 

I <assertion_statement> —:75a; 

I <signal_assignment_statement> —:200: 
I <variable_assignment_statement> —:201 
I <procedure_cali_statement> —:78: 
I <if_statement> —:202; —a,a‘,a‘ 

I <case_statement> —:204 —a 
I <loop_statement> —:206: --a 
I <next_statement> --:208: 

I <exit_statement> —:209: --a 
I <return_statement> —:210: --a 
I <null_statement> —:211; —a 


♦*♦ Important Note on Implicit Wait Statement of a Process. *** 

-- Note: A process that has an explicit sensitivity list always has exactly 

one (implicit) wait statement in it, and that wait statement appears 
at the end of the sequence of statements in the process statement 
part. Thus, a process with a sensitivity list always waits at the 
end of its statement part; any event on a signal named in the 
sensitivity list will cause such a process to execute from the 
beginning of its statement part down to the end, where it will wait 
again. Such a process executes once through at the beginning of 
simulation, suspending for the first time when it executes the 
implicit wait statement. 

SIM: Every signal assignment statement in a process statement defines a 

set of "drivers" for certain scaler signals. There is a single 
driver for a given scalar signal S in a process statement provided 


21 











that there is at least one signal assignment statement in that 
process statement, auid the longest static prefix of the target 
signal of that signal assignment statement denotes S, or denotes 
a composite signal of which S is a subelement. Each such signal 
assignment statement is said to be associated with that driver. 
Execution of a signal assignment statement affects only the 
associated driver(s). 

(The above is quoted from page 9-4 of the VHDL Reference Manual. 
Overlooking these details can cause lots of waisted time trying 
to get process statements to work right.) 


-- Note: The following defines the subprogram structure. 
(All subprograms can be called recursively.) 


:* 122 : 

<subprogr 2 un_dec]aration> ::= <subprogr 2 un_specification> ; 

—:123: — VHDL 2.1 Ada 6.1 

— SEM: defines subprogr 2 im’s calling conventions. 

A subprogram can be a procedure or a function. 


*123: 

<subprogrcun_specification> ::= — VHDL 2.1 Ada 6.1 

procedure <de3ignator> [( <formal_parameter_list> )] 

I function <designator> [( <formal_parameter_list> )] 
return <type_mark> 

—:124,125,124,125,24: 


:*124: 


<designator> ::= <identifier> I <operator_symbol> 

—:49,126: — VHDL 2.1 Ada 6.1 

— SEM: A "procedure" designator is "always" 
eui <identifier>. 

A "function" designator is either an 
<identifier> or an <operator symbol>. 

— Note: Next revision of VHDL should consider 

distinguishing <"procedure"_designator> 
from <"function"_designator> to capture 
more semamtic information in the B.N.F. 
representation of the VHDL language. 


:* 125 : 


<formal_parameter_list> ::= "parcimeter"_interface_list 

—:17: — VHDL 2.1.1 Ada 6.4 

— SEM: may be constemts, variables, or signals. 

Mode of parameter determines how it may be 
accessed. Only in, inout, cind out modes 


22 





are allowed. 

(Mode zmd class may determine how access 
is implemented. See p. 2-2 lor details.) 
It mode in 2 md no object class, then signal 
If mode inout or out and no object class, 
then pareuneter is a variable. 

— Mote: <interface_list> ::= -‘ —: 17; 

— Note: <type_mcirk> ::= -‘ —:24: 

(This is the subtype of the returned value) 


:*126: 


<operator_symbol> ::= <string_literal> —:39: 

— VHDL 2.1 Ada 6.1 


:*127: 


:'H28: 


:*129; 


<subprogram_body> ::= 

<subprogram_specification> is 

<subprogram_declarative_par'''' 

begin 

<subprogram_statt.;m.t_part> 
end C <de8ignator> .] ; 


— VHDL 2.2 Ada 6.3 

— :123: —a 
— :128: —a 

—a 

— :195: —a 

— :124- —a 


— SEM: defines subprogram's execjti^n. 
— Note: <subprogram_specification> :: -* 


123: 


<subprogrcun_declarative_part> : : = 

{ <subprogram_declarative_itera> > 


— VHDL 2.2 
—:129: 


<subprogrcun_declarative_item> ::= 
<subprogram_declaration> 

I <subprogram_body> 

I <type_declaration> 

I <subtype_declaration> 

I <constant_declaration> 

I <variable_declaration> 

I <file_declaration> 

I <alias_declaration> 

I <attribute_declaration> 

I <attribute_specification> 

I <uso_clause> 


— VHDL 2.2 
122 : 

—:127: 

—:130: 

—:166: 

—:167: 

--:168: 

—:169: 

--:172: 

—:173: 

— : 174: 

—:180: 


— Note: <subprogram_body> is recursive. 


-- Note: See pages 2-5 2 md 2-6 on subprogram amd operator overloading. 


23 








— Note: The lolloping make up the above <subprograun_declarative_item> 

and <process_declarative_item>. 

— Note: <entity_declarative_item> aind <block_declarative_item> consist 

of the following (plus some others listed after the following). 


:*130: 


<type_declaration> ::= — VHDL 4.1 Ada 3.3.1 

<-j;ull_type_decl 2 a'ation> I <incomplete_type_declaration> 

— : 131,165: 


:*131: 


: *132: 


:*133: 


:+134: 


:*135: 


:*136: 


:»137: 


<full_type_declaration> — VHDL 4.1 Ada 3.3.1 

type <identifier> is <type_definition> —:49,132: 


<type_definition> ::= 

— VHDL 4.1 Ada 

<scalar_type_definition> 

—: 133: 

1 <composite_type_definition> 

— :154: 

1 <access_type_definition> 

—: 163: 

1 <file_type_definition> 

—: 164: 


<scalar_type_definition> ::= — VHDL 3.1 

<enumeration_type_definition> I <integer_type_definition> 
<floating_type_definition> I <physical_type_definition> 

—:134,139,141,142: 


<enumeration_type_definition> ::= — VHDL 3.3.1 Ada 3.5.1 

( <enumeration_literal> {, <enumeration_lit<,ral> >] 

-:135,135: 

— SEN: Predefined Enumeration Types are 
CHARACTER, BIT, BOOLEAN, and 
SEVERITY.LEVEL in package STANDARD. 

<enumeration_literal> ::= — VHDL 3.3.1 Ada 3.5.1 

<identifier> I <character_literal> —:49,136: 


<character_literal> ::= ’ <graphic_character> ’ 
—:137: — VHDL 13.5 Ada 2.5 


<graphic_character> ::= — VHDL 13.1 Ada 2.1 

<basic_graphic_character> —:138: 

<lower_case_letter> — See note. 

<other_special_character> — See note. 


24 






— note; <lower_case_letter> and 

— <other_special_character> are 

— lexical representations of 

— terminals. 


♦ 138: 


<ba3ic_graphic_character> 

<upper_case_letter> I <digit> 

I <special_character> I <space_character> 
— VHDL 13.1 Ada 2.1 

— Hote: <upper_case_letter>, <digit>, 

— cmd <special_character> are lexical 

— representations of terminals. 

— Hote; Further breeikdoun of 

— <graphic_character> is done by lexical 

— processing (not in this syntax summary) 


♦ 139: 


<integer_type_definition> ;:= <range_constraint> 

":140: — VHDL 3.1.2 Ada 3.6.4 

— SEM: INTEGER is the only predefined integer 
type. 

Integer literals are of type 
universal_integer. 


♦ 140: 


<r^Lnge_constraint> ;;= range <range> —:94: 

— VHDL 3.2.2 Ada 3.7 


♦ 141 : 


<floating_type_definition> ::= <range, ■onstraint> -" 

— VHDL 3.1.4 

— SEM: Type REAL is the only predefined floating 
point type. Guaranteed reinge is -1E38 to 
+1E38. 


♦ 142: 


<physical_type_definition> ::= — VHDL 3.1.3 

<range_constraint> --:140: 

units 

<base_unit_declaration> --:143: 

{ <secondary_unit_declaration> } —:144: 

end units 

— Hote: No ";” after end units. 

This is different from normal. 

— SEM: TIME is the only predefined 

physical type with a default base 




unit of 1 femtosecond (lE-15). 
Guaranteed rcinge is -2147483647 
to +2147483467 ascending. 


♦ 143: 


♦ 144: 


♦ 145: 


♦ 146: 


<base_unit_declaration> ::= <ident'’fier> 

— VHDL 3.1.3 —:49: 


<secondary_unit_declaration> ::= 

<identifier> = <physical_literal>; 

— VHDL 3.1.3 —:49,145: 


<physical_literal> ::= — VHDL 3.1.3 

C <abstract_literal> ] <"unit"_name> 

— : 146,34: 

<abstract_literal> ::= — VHDL 13.4 

<decimal_literal> I <based_literal> 
— : 147,150: — 


♦ 147: 


<decimal_literal> ::= <integer> C , <integer> ][ <exponent> ] 

—:148,148,149: -- VHDL 13.4.1 Ada 2.4.1 


♦ 148: 


<integer> ::= <digit> { [ <underline> ] <digit> > 

— VHDL 13.4.1 Ada 2.4.1 

— Note: <digit> emd <underline> are lexical 
— terminals. 


♦ 149: 


♦ 150: 


<exponent> ::= E [ + ] <integer> 1 E - <integer> 

—;148,148: — VHDL 13.4.1 

— Not; <integer> is recursive. 

<based_litoral> ::= — VHDL 13.4.2 Ada 2.4.2 

<base> # <based_literal> [ . <based_integer> ] # [ <exponent> ] 

—:151.150,150,149: 


— Note; <based_literal> is recursive. 


♦ 151; 


<base> :;= <integer> —:148; — VHDL 13.4.2 Ada 2.4.2 


♦ 152: 


<based_integer> ::= — VHDL 13.4.2 Ada 2.4.2 

<extended_digit> { [ <underline> ] <extended_digit> ] 


26 







-:153,_,153: 


;*153: 


<extended_digit> ::= <digit> I <letter> 

— VHDL 13.4.2 Ada 2.4.2 

— Mote: <digit> and <letter> are 
— lexical representations of terminals. 


:*154; 


<composite_type_definition> ::= — VHDL 3.2 

<array_type_definition> I <record_type_definition> 
—:155,160: 


: *155: 


<array_type_definition> ::= — VHDL 3.2.1 Ada 3.6 

<unccnstrained_array_definition> —:156: 

I <constrained_array_definition> —:158: 

— SEM; Predefined array types are STRING and 
BIT_VECTOR in package standard. 


:*156: 


:'»157: 


:*158: 


<unconstrained_array_definition> : : = 
array ( <indox_subtype_definition> 

{ , <index_subtype_definition> >) 

of <"eleinent"_subtype_indication> -“ 

— : 157,157,23: — VHDL 3.2.1 Ada 3.6 


<index_subtype_definition> ::= 
<type_inark> rauige <> 

— VHDL 

— Note: Maike sure you 

— between <> terminal 

— nonterminal in your 


—: 24 : 

3.2.1 Ada 3.6 
differentiate 
and <text> 
parser. 


<constrained_array_definition> : : = 

array <index_constraint> of —:159: 

<"element"_subtype_indication> — : 23: 

— VHDL 3.2.1 Ada 3.6 


:*159: 

<index_constraint> ::= 

( <di8crete_range> { , <discrete_range> }) 
—:93,93: 

— VHDL 3.2.1 Ada 3.6 
— SEM: determines array bounds. 


27 







: *160: 


<record_typa_definition> ::= — VHDL 3.2.2 Ada 3.7 

record 

<element_declaration> —;161: 

{ <element_declaration> > —:161: 

end record 

— Hote: No alter "end record". 


; *161; 


;*162: 


<element_declaration> ::= — VHDL 3.2.2 

<identilier_list> : <element_subtype_definition> ; 

—:162: 


<element_subtype_delinition> ::= — VHDL 3.2.2 

<subtype_indication> —:23: 


:*163: 


:*164; 


<access_type_definition> ::= access <subtype_indication> 

— :23: 

— VHDL 3.3 Ada 3.8 
— SEM: Access to objects created by evaluation of 
allocators is achieved by an access value 
returned by an allocator. The access value 
designates the object. (See 3.3.2 and 7.3.6 
on allocators.) 

For each access type, a deallocation operation 
is "implicitly" declared immediately following 
the full type declaration for the type. (Thus, 
the storage occupied by a designated object can 
be explicitly deallocated.) 


<file_type_definition> ::= file of <type_mark> --:24; 

— VHDL 3.4 

— SEM: define objects representing files in the host 

envir'^nment. The value of a file object is the 
sequence of values contained in the host system 
environment. 

<type_mark> defines the subtype of values in the 
file. Base type of this subtype must not be a 
file type or an access type. If the base type 
is a composite type, it must not contain a 
subelement of an access type. If the base type 
is am airray type, it must be a one-dimensional 
aurray type. 

File operations for objects of file type include 
procedure READ (F: in FT; VALUE: out TM); 


2 « 





procedure WRITE (F: out FT; VALUE: in TM); 
function EHDFILE (F: in FT) return BOOLEAN; 


:*165: 


<incomplete_type_definition> ;:= type <identifier> ; —:49: 

— VHDL 3.3.1 Ada 3.8.1 
— SEM: For each incomplete type declaration there must be 
a corresponding full type declaration with the 
same identifier (which occurs later and immediately 
within the same declarative part). 


: *166: 


<subtype_declaxation> ::= — VHDL 4.2 Ada 3.3.2 

subtype <identifier> is <subtype_indication> —:49,23: 


:*167: 


<constant_declaration> 

constant <identifier_list> 


— VHDL 4.3.1.1 Ada 3.2 
<subtype_indication> —:26,23; 

[ := <expression> ] ; —:27: 


— SEM: If no default value for consteuit declaration in 

package declaration is present, then corresponding 
full constant declaration must appear in body of 
package. 


; *168: 

<variable_declaration> ::= — VHDL 4.3.1.3 

variable <identifier_list> : <subtype_indication> —:26,23: 

C := <expression> ] ; 


-- SEM: If initial value exists, then the initial 

value of the expression is determined each time the 
variable declaration is elaborated. 

Default initial value for a variable of scalar type 
has value T’Left. 

Default initial value of a variable of an access type 
has value null for that type. 


: *169: 


<file_declaration> ::= — VHDL 4.3.2 

file <identifier> : <8ubtype_indication> is [ mode ] 

<file_logical_name> ; 


—:49,23: 
—:171: 


: * 170 ; 


<mode> ::= in I out I inout I buffer I linkage 

— VHDL 4.3.3 Ada 6.1 

-- SEM: If no mode explicitly given in interface 


29 










declaration, then mode is "in". 


*171 : 


*172: 


<lile_logical_name> ::= <"string"_expression> — VHDL 4.3.2 

— :27: 

— Mote: <subtype_indication> ::=-* —:23: 


<alias_declaration> ::= — VHDL 4.3.4 

alias <identiiier> : <subtype_indication> is <nzune> ; - 

—;49.23.34: 


SEM: declares an alternate name for an existing object 
<name> must be a static naune (6.1). 


*173: 

<attribute_declaration> ::= — VHDL 4.4 

attribute <identifier> : <type_mark> ; —:49,24: 

— SEM: An attribute is a value, function, type, range, 

signal, or constant that may be associated with one 
or more entities in a description. Attributes can 
be predefined or user-defined. (See Chapt 14.) 
Predefined attribute signals cannot be updated. 
User-defined attributes are constants of arbitrary 
type. 

An attribute may be associated with an entity, 
eurchitecture, configuration, procedure, function, 
package, type, subtype, constant, signal, variable, 
component, or label. 

<type_mark> cannot be access or file type. 


*174: 

<attribute_specification> ::= — VHDL 5.1 

attribute <attribute_designator> of <entity_specification> is 

<expression> ; 

— :98,175,27: 


-- SEM: associates a user-defined attribute with one or more 
entities and defines the value of that attribute for 
those entities. 

— SEM: ERROR if attribute associates more than once with 
a given entity. 


*175: 


<entity_specification> ::= — VHDL 5.1 

<entity_nauBe_li8t> : <ent.ity_class> —: 176,179: 


.10 





:*176: 


<entity_naaie_list> ::= — VHDL 5.1 

<entity_designator> ■{, <entity_designator> } 
I others 
I all 

— : 177,177:* 


:*177: 

<entity_designator> ::= <simple_n2Lme> I <operator_symbol> 

—:178.126: 


— SEM; An entity designator that is an operator 
symbol is used to associate an attribute 
uith am overloaded operator. 

— VHDL 5.1 


♦178: 


<simple_naune> ::= <identifier> — VHDL 6.2 Ada 4.1 

— ;49: 


: ♦179: 


<entity_class> 
entity 
I procedure 
I type 
I signal 
I label 


i architecture 
I function 
I subtype 
I variable 


VHDL 5.1 
I configuration 
I package 
I constamt 
I component 


: ♦180 : 

<use_clause> ; ; = 

use <selected_naunc> { 


— VHDL 10.4 Ada 8.4 
<selected_naune> } ; —;181,181: 


: *181 : 


<selected_naune> ::= <prefix> . <suffix> --:96,182; 


— VHDL 6.3 Ada 4.1.3 


♦ 182: 


<suffix> ::= <simple_naune> —:178:- 
I <chamacter_literal> 

I <oporator_symbol> 

I all 


VHDL 6.3 Ada 4.1.3 
—: 136: 

— : 126: 


Note: (Number 183 has beed deleted on purpose.) 

<character_literal> -* --:136: 

-- VHDL 13.5 Ada 2.5 


-- Note: The following make up the rest of <entity_declarative_item>. 


31 











;*184; 


<signal_declaration> ::= — VHDL 4.3.1.2 

signal <identiiier_list> : <subtype_indication> —:26,23: 

[ <signal_kind> ] [ := <expression> ] ; 

— : 185,27; 


— SEM: If resolution function appears in subtype indication 
of signal declaration, then signal is called a 
resolved signal. 


A 


:*185: 


<signal_kind> ::= register I bus — VHDL 4.3.1.2 

— SEM: means declared signals are guarded by signal kind. 


:*186: 


<disconnection_specification> ::= — VHDL 5.3 

disconnect <guarded_signal_specification> after 

<"time"_expression> ; 

— : 187,27: 


— SEM: defines the time delay used in the implicit 

disconnection of drivers of a guarded signal within 
a guarded signal assignment. 

Time expression must be static cin non-negative. 


;*187; 


<guarded_signal_specification> ::= — VHDL 5.3 

<"guarded"_signal_li8t> : <type_mark> —;188,24: 


:*188: 


<signal_list> ::= — VHDL 5.3 

<"signal"_name> { , <"signal"_neune> )• —:34,34: 

I others 
I all 


— SEM: identifies signals for which implicit 

disconnection delay is to be defined. 
(See details on page 5-7.) 

— SEM: ERROR if more than one disconnection 

specification applies to drivers of the 
same signal. 

— Note; Define <n 2 u»e> later. 


32 







-- Note: The following malte up the rest of <block_declarative_item>. 


*189: 

<component_declaration> :;= — VHDL 4.5 

component <identifier> —:49: 

[ <"local"_generic_clause> ] -" —:13: 

[ <"local"_port_clause> ] -‘ —:14: 

end component ; 


— SEM: defines a virtual design entity interface that may be 
used in a component instamtiation statement. 

A component configuration or configuration 
specification can associate a component instance with 
a design entity that resides in a library. 


*190: 


<conf iguration_sp<-o’*ication> ::= — VHDL 5.2 

for <comP'‘:' it_apecification> use <binding_indication> ; 

—:191,193: 


*191: 


*192; 


— SEM: associates binding information with component 
labels representing instamces of a given 
component. 

<component_3pecification> ::= — VHDL 5.3 

<instaLntiation_list> : <"component"_naune> 192,34: 

-- SEM: identifies component instamces. 

<instantiation_list> ;:= — VHDL 5.2 

<"inst<mtiation"_label> { , <"instantiation"_label> } 
I others —:75,75:‘ 

I all 


*193: 


— SEM: identifies those entities with which 

binding information is to be associated, 
(as defined at bottom of page 5-3) . 

<binding_indication> :;= — VHDL 5.2.1 

<entity_aspoct> —:194; 

[ <generic_map_aspect> ] -* —:107; 

[ <port_map_aspect> ] -* —:108: 

-- SEM: associates component instamces with a 
particular design entity. 


33 

















<entity_aspect> ::= — VHDL 5.2.1.1 

entity <"entity'*_naaie> [( <"architecture"_identifier> )] 
I configuration <"con£iguration"_naine> ;34,49,34:‘ 

I open 


— SEM: identifies design entity to be associated 
with component instcinces. It may also 
specify which binding is to be deferred. 


-- Note: End of declarations. 


-- Note: The following make up the <subprograun_statement_part> of 
<subprogram_body>. 


-:*195: 

<subprogram_statement_part> ::= 
{ <sequential_statement> )■ 


— VHDL 2.2 
— :121 ; 


— Note: The following maJce up <sequential_statement> which can be found 
embedded in the <process_statement> and <subprogram_body>. 


-:*196: 


<wait_statement> ::= — VHDL 8.i 

wait [ <sen3itivity_clause> ] [ <condition_clause> ] 
[ <tiraeout_clause> ] ; 

—:197,198,199: 


SEM: causes suspension of a process statement or a 
procedure. 


-:*197: 


<sensitivity_clause> on <sensitivity_list> --:117: 

— VHDL 8.1 

— SEM: defines the set of signals to which the wait 
statement is sensitive. Each signal name 
must be a static signal name. 


-:*198: 


<condition_clause> ::= until <condition> —:76: 

— VHDL 8.1 

— SEM: specifies condition that must be met for 
for process to continue execution. 


A- 


* 


-:*199: 


<timeout_clause> ::= for <"time"_expression> —:27: 

— VHDL 8.1 

— SEM: specifies maximum time that process will remain 


34 







suspended at this wait statement. 


— SEM: ERROR ii time expression evaluates to negative. 


<assertion_statement> :;= -" —:75a: 

-- SEM: checks that a specified condition is true and reports an 
error if it is not. 


--:* 200 : 

<signal_assignment_statement> ::= — VHDL 8.3 

<target> <= [ transport ] <waveform> ; —:88,102: 

-- SEM: modifies the projected output waveforms contained in the 
drivers of one or more signals. (See also 9.2.1). 

If <target> is a name, then neone must denote a signal. 

If <target> is an aggregate, then type of aggregate must 
be determinable from the context. 

Transport specifies that the delay associated with the 
first waveform element is tremsport delay. 

If transport is absent, then delay is inertial delay (a 
characteristic of switching circuits). 


:*201 : 

<variable_assignraent_statement> ::= — VHDL 8.4 Ada 5.2 

<target> <= <expression> ; -‘ —:88,27: --**♦ 

-- SEM: replaces current value of variable with new value specified 
by expression. (It must be the same type.) 


<procedure_call_statement> ::= -" —:78: — VHDL 8.5 Ada 6.4 


--:* 202 : 


statement> ::= 

-- VHDL 8.1 

if <condition> then 

-- —: 76 : 

<sequence_of_statements> 

--:203 

{ elsif <condition> then 

--:76: 

<sequence_of_statements> } 

— :203 

[ else 


<sequence_of_statements> ] 

— :203 


end if ; 













SEM: <condition> must be of type BOOLEAK. 


-:*203; 


<sequence_of_statements> ::= -- VHDL 8 Ada 5.1 

{ <sequential_statement> } --:121' 

-- Note: <sequential_statement> is recursive. 


* 


-:*204: 

<case_statement> ::= 

case <expression> is 

<case_statement_alternative> 

{ <case_statement_alternative> } 
end case ; 


— VHDL 8.7 Ada 5.4 
— :27: 

—:205: 

—:205; 


:*705: 


-- SEM: <expression> must be of a discrete type. 


<case_statement_al*'9rnative> ;:= — VHDL 8.7 Ada 5.4 

when <choices> => -‘ --:91: 

<sequence_of_statements> -‘ --:203: 


— Note: Another place where <sequential_statement> 
is recursive. 


-:*206: 

<loop_statement> ::= 

[ <"loop"_label> : ] 

[ <iteration_scheme> ] loop 

<sequence_of_statements> 
end loop [ <"loop"_label> ] ; 


-- VHDL 8,8 Ada 5.5 
— :75: 
--:207: 

-- —: 203 : 

--:75: 


-:*207: 


<iteration_scheme> ::= — VHDL 8.8 Ada 5.5 

while <condition> -“ —:76: 

I for <"loop"_parameter_specification> -‘ —:111: 

-- SEM: A "while" iteration scheme evaluates 


before each execution of sequence of 
statements. 

A "for" iteration scheme 
after each evaluation of 
range. 


* 


36 


executes 
the discrete 












-:*208: 


<next_statement> ::= — VHDL 8.9 

next [ <"loop"_label> ] [ when <condition> ] ; 

-- —.jsje: 

— SEM: used to complete execution of one of the iterations of 
an enclosing loop statement. 




--:*209: 

<exit_statement> ;:= — VHDL 8.10 Ada 5.7 

exit C <"loop"_label> ] [ when <condition> ] ; 

-- —. 75 ^ 76 : 

— SEM: used to complete execution of an enclosing loop 
statement. Only allowed within a labeled loop. 


<return_statement> :;= 

return [ <expression> ] ; 


— VHDL 8.11 Ada 5.8 
—: 27; 


— SEM: used to complete execution of innermost enclosing 
function or procedure body. 


--:* 211 : 

<null_statement> ::= null ; 


— VHDL 8.12 Ada 5.1 


— SEM: performs no action, (like a noop.) 


— Note: The following non-terminals from Appendix A (Syntax Summary) 

of the VHDL Reference Manual (IEEE Standard 1076-1987) contains 
the following dauigling non-terminals (i.e. they have no roots 
within the rest of the VHDL syntax summary). 

--:* 212 : 

<basic_character> ::= — VHDL 13.1 Ada 2.1 

<basic_graphic_ch 2 a:acter> I <format_effector> —:138,.: —See note. 

-- Note: <format_effector> is the lexical representation of a 

-- terminal. 

-- SEM: Each grap character corresponds to ISO seven-bit coded 
character t (ISO 646-1983). 

-- NOTE: As in Ada 9X, the next revision of VHDL should consider 
extending the character set to include international 


37 











cheoractexs (corresponding to how Ada 9X decides to do it). 


—:*213: 

<declaLration> :: = 

<type_declaration> 

I < 3 'ubtype_declaration> 

I <objoct_declaration> -v 

I <lilo_decl2uration> 

I <interlace_declaration> 

I <alias_declcuration> 

I <attrib'ute_declaration> 

I <component_decl2Lration> 

I <entity_declaration> 

I <configuration_docl2u:ation> 

I <subprograin_declaration> 

1 <package_declaration> 


— VHDL 4 


Ada 3.1 
—a — :130: 
—a — :166: 
—a —:216: 

—:169: 

— :19: 

—:172: 

—:173: 

—:189: 

—; :11 

— :56: 
—a — :122: 
—a — :63: 


—:*214: 

<logical_operator> ::= and I or I nand I nor I xor — VHDL 7.2 Ada 4.5 


— •.*215; 

<miscellaneous_operator> :;= ** I abs I not — VHDL 7.2 


—:*216: 

<object_declaration> :;= 

<constant_declaration> 

I <signal_declaration> 

I <V 2 U’iable_declaration> 


— VHDL 4.3.1 (Ada 3.2) 
—:167; 

—:184: 
“:168: 


— SEM: An object is an entity that contains a value of a given type. 
- (End of VHDL Syntax Summary) - 


u s Government Pr nting Office 1992—648-127/62170 


38 














