REPORT DOCUMENTATION PAGE 


Form Approved 
OPM No. 0704 0183 


AD-A240 784 


I hour oer '’esoonM tnctudinQ m« dm* lot reviewing rwnxtioot. sMrcfing Oau unjrcm gnhtnnQ and marttirvngfftT^tt 

he Durden estimate or any other aspect ot m^ cotlectiDn of rtormmoo. including suggeetone for '•duang Durden, to Waehngt>n 
3 Jefferson Dave Hignwav Suae ^204 Arlington VA 22202-4X2 and to the Office of irdormaaon and Reguaory AKan. Office of 


PORT DATE 




3 REPORT TTPE AND DATES COVERED 

Final: 30 Jul 1991 to 01 Jun 1993 


4 TITLE AND SUBTITLE 

Ada Compiler Validation Summary ReportiU.S. NAVY, Ada/L, Version 4.0 
('OPTIMIZE). VAX 8550(Host) to AN/UYK-43 (Single CPU)(Bare Board)(Target), 
910626S1 11172 


5 AUTHORiS.i 

National Institute of Standards and Technology 

Gaithersburg, MD 

USA 


7 PERFORM NG ORGANIZATION NAME(S) AND ADDRESS,ES) 

National Institute of Standards and Technology 
National Computer Systems Laboratory 
Bldg. 255, Rm A266 
Gaithersburg, MD 20899 USA 


9 SPONSORING-MONITORING AGENCY NAMEiS) AND ADDRESS(ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, RM 3E114 
Washington, D C. 20301-3081 


I 5 FUNDING NUMBERS 


8 PERFORMING ORGANIZATION 
REPORT NUMBER 

NIST90USN510 5 1.11 


10 SPONSORINGA^ONITORING AGENCY 
REPORT NUMBER 



12a DISTRIBUTION-AVAILABILITY STATEMENT 

Approved for public release; distribution unlimited. 


12b DISTRIBUTION CODE 


13 ABSTRACT : Maximum 200 woras) 

U S. NAVY, Ada'L, Version 4.0 (OPTIMIZE) Gaithersburg, MD. VAX 8550. running VAX/VMS Version 5.3 (Host) to 
AN/UYK-43 (Single CPU){Bare Board)(Target), ACVC 1.11. 


.T.,^ .1 I tL..,. 

■ --- CTE 

Ik SEP 19 1391 a g 




14 SoB,.ECT *ERMS 


Ada programming language. Ada Compiler Val. Summary Report. Ada Compiler Val. 
Capability, Val Testing. Ada Val. Office. Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17 SECURlTv CLASSIFiCATiON 
OF REPORT 

UNCLASSIFIED 


18 SECURITY CLASSIFICATION 


UNCLASSIFED 


19. S«-CURiTY CLAooirtCATION 
OF ABSTRACT 

UNCLASSIFIED 


15 NUMBER OF PAGES 


16 PRICE CODE 


20 LIMITATION OF ABSTRACT 


NSN 7540 01 2S0 550 


“ Standard Form 298, (R«v 2-89) 
Prescribed by ANSI Std 239-128 











THIS DOCUMENT IS BEST 
QUALITY AVAILABLE. THE COPY 
FURNISHED TO DTIC CONTAINED 
A SIGNIFICANT NUMBER OF 
PAGES WHICH DO NOT 
REPRODUCE LEGIBLY. 








AVF Control Number: NIST90USN510_5_1.11 
DATE COMPLETED 

BEFORE ON-SITE: 1991-04-05 
AFTER ON-SITE: 1991-06-26 
REVISIONS: 1991-07-30 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 910626S1.11172 
U.S. NAVY 

Ada/L, Version 4.0 (/OPTIMIZE) 

VAX 8550 => AN/UYK-43 (Single CPU) (Bare Board) 


Prepared By: 

Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


Acc?sjori rcir 

'••'Tis C,7/.F! 

0 T..,5 

J - tl! Zd'.J-,, 

By 


I ■ 


u;: t 





1 




AVF Control Number: NIST90USN510_5_1.11 
Certificate Information 


The following Ada implementation was tested and determined to pass 
ACVC 1.11. Testing was completed on 1991-06-26. 

Compiler Name and Version: Ada/L, Version 4.0 (/OPTIMIZE) 

Host Computer System: VAX 8550, running VAX/VMS Version 

5.3 

Target Computer System: AN/UYK-43 (Single CPU) (Bare Board) 

A more detailed description of this Ada implementation is found in 
section 3.1 of this report. 

As a result of this validation effort, Validation Certificate 
910626S1.11172 is awarded to U.S. NAVY. This certificate expires 
on 01 March 1993. 


This report has been reviewed and is approved. 





Adk Validation Mpiljlty Ada Validation Facility 

Dr. David K. Jel^ErdWnU Mr. L. Arnold.^-J'ohnson 

Chief, Information SysTCms Manager, Software Standards 

Engineering Division (ISED) Validation Group 

Computer Systems Laboratory (CLS) 

National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 




Itn 


Ada^alidVtion Organization 
Directory Computer & Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 



-^Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 








DECLARATION OF CONFORMANCE 


The following declaration of conformance was supplied by the 
customer. 


Customer: 

Certix-xcate Awardee: 


DECLARATION OF CONFORMANCE 

U.S. NAVY 
U.S. NAVY 


Ada Validation Facility: 


National Institute of Standards and 
Technology 

Computer Systems Laboratory (CSL) 
Software Validation Group 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


ACVC Version: 


1.11 


Ada Implementation: 

Compiler Name and Version: 
Host Computer System: 

Target Computer System; 
Declaration: 


Ada/L, Version 4.0 (/OPTIMIZE) 

VAX 8550, running VAX/VMS Version 
5.3 

AN/UYK-43 (Single CPU) (Bare Board) 


I the undersigned, declare that I have no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STD-1815A ISO 
3652-1937 in the implementation listed above. 




f T 


L' 


/1 . 


Customer Signature 
Company U.S. Navy. 
Title- , 


Date 






Certificate Awardee Signature 

Company U.S. Navy 

Title 


Date 






TABLE OF CONTENTS 


CHAPTER 1 . 

INTRODUCTION . 

1.1 USE OF THIS VALIDATION SUMMARY REPORT 


1.2 REFERENCES.1-1 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 


CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES . 2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 


CHAPTER 3.3-1 

PROCESSING INFORMATION . 3-1 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A.A-1 

MACRO PARAMETERS.A-1 


APPENDIX B.B-1 

COMPILATION SYSTEM OPTIONS . B-1 

LINKER OPTIONS . B-2 

APPENDIX C.C-1 

APPENDIX F OF THE Ada STANDARD.C-1 


























CHAPTER 1 
INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro90] against the Ada Standard [Ada83: 
using the current Ada Oomciler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to [Pro90]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG39). 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. 4552) . The results 
of this validation apply only' to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 


Ada Validation - Organization 
Computer and Software Engineering Division 
Institute for Defense Analyses 
1301 North Beauregard Street 
Alexandria VA 22311-1772 


1.2 REFERENCES 

■Ada33j Reference Manual for the Ada Programming Language , 

ANSI/MIL-STD-1315A, February 1983 and ISO 8652-1987. 


1-1 







'Prc90: Ada Compiler Validation Procedures . Version 2 . 1 , Ada Joint 
Program OffToS*, August 1990. 

;UGS9] Ada Compiler Validation Capability User's Guide , 21 June 
1989 . " 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
■uame identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner a.nd 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK_FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. Class B 
tests check that a compiler detects illegal language usage. Class 
3 tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that 
all violations of the Ada Standard are detected. Some of the class 
3 tests contain legal Ada code which must not be flagged illegal by 
“he compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separate ly 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values — for example, the 
largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 


1-2 




the AVF. Thij customization consists of making the modifications 
dcccjibed iTT^'he preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [UG89]) . 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler 


Ada Compiler 
Validation 
Capability 
(ACVC) 


Ada 

Implementation 

.Ada 

Validation 
Facility (AVF) 

Ada 

Validation 

Organization 

(AVO) 

Compliance of 
an Ada 

Implementation 


Computer 

System 


The software and any needed hardware that have to 
be added to a given host and target computer 
system to allow transformation of Ada programs 
into executaole form and execution thereof. 

The means for testing compliance of Ada 
implementations. Validation consisting of the 
test suite, the support programs, the ACVC 
Capability user's guide and the template for 
the validation summary (ACVC) report. 

An Ada compiler with its host computer system and 
its target computer system. 

The part of the certification body which carries 
out the procedures required to establish the 
compliance of an Ada implementation. 

The part of the certification tody that provides 
technical guidance for operations of the Ada 
certification system. 

The ability of the implementation to pass an ACVC 
version. 


A functional unit, consisting of one or more 
computers and associated software, that uses 
common storage for all or part of a program and 
also for all or part of the data necessary for 
the cxecurion of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including 
arithmetic operations and logic operations; and 
that can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 


1-3 




Conf omity 


Custoraer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 


Operating 

System 


Target 

Computer 

Sysrem 

Validated Ada 
Compiler 

Validated Ada 
Implementation 


Validation 


','Jithdrawn 

test 


Fulfillment by a product, process or ser’/ice of 
all requirements specified. 

An individual or corporate entity who enters into 
an agreement with an AVF which specifies the terms 
and conditions for AVF services (of any kind) to 
be performed. 

A formal statement from a customer assuring that 
conformity is realized or attainable on the Ada 
implementation for which validation status is 
realized. 

A computer system where Ada source programs are 
transformed into executable form. 

A test that contains one or more test objectives 
found to be irrelevant for the given Ada 
im.p lamentation. 

Software that controls the execution of programs 
and that provides services such as resource 
allocation, scheduling, input/output control, 
and data management. Usually, operating systems 
are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada 
programs are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated 
successfully either by AVF testing or by 
registration [Pro90]. 

The process of checking the conformity of an Ada 
compiler to the Ada programming language and of 
issuing a certificate for this implementation. 

A test found to be incorrect and not used in 
conformity testing. A test may be incorrect 
because it has an invalid test objective, fails 
to meet its test objective, or contains erroneous 
or illegal use of the Ada programming language. 


i-4 






CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 


Some tests 

are withdrawn by the 

AVO from 

the ACVC 

because they do 

not conform 

to the 

Ada Standard 

The following 94 

tests had been 

withdrawn b 

v the Ada Validation 

Organization (AVO) 

at the time of 

validation 

testing. 

The ratio 

nale for 

withdrawing each test is 

available f 
rhis list o 

rom either the AVO or 
f withdrawn tests is 

■ the AVF. 
91-05-03 

The publication date for 

E23005C 

B28006C 

C34006D 

C3 5 5081 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C4 5 3 4 6A 

C45612A 

C456123 

C45612C 

C45651A 

C46022A 

B49003A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

3320253 

B83025D 

B83026B 

C33026A 

C83041A 

B35001L 

C36001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

C370013 

C37004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

3D1302B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

3D4003A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4 0 3lA 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7205A 

3D8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3607D 

C£31i5A 

CE3812A 

CE3411B 

CE3814A 

CE3412B 

CE3902B 

CE3607B 

CE3607C 


n y^-nr -r^ n 

^ v^r\0 i^i-i I wO 1 O 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementatiun. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Issues and commonly referenced in the 
format Al-dddd. For this implementation, the following tests were 
inapplicable for the reasons indicated; references to Ada Issues 
are included as appropriate. 

The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM,MAX_DIGITS: 

C35705L..Y (14 tests) 

C35707L..Y (14 tests) 

C35302L..Z (15 tests) 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35703L,.Y (14 rests) 




C 4 

3241L. 

. 

/ 1 ’ 

1. .fc. 

tests) 

C45321L. 

. Y 

( 

1 i 

X. -t 

tests) 


54211. 

. Y 

/ j ’ 

, t 

tests) 

C4552IL. 

•7 

( 

1 5 

tests; 

^ -t 

c. 3 ^ 4 .w. 



tests) 


7 

( 

15 

tests; 

-t 

— r 

0 O ‘t . 

. 'l 

'v "t 

tests) 

C46012L. 


( 

1 5 

0 S S ) 


T '4 


tests) 


ise a 


.me 


.engl 


greater 


t.tan .'-lAX 


C35~133, 0454233, 336001T, and C36006H check for the predefined 

f/pe SHCRT_FL0AT; for this inplenentation, there is no such type. 


The following 2 1 tests check for the predefined type SHCRT_IhTZGr.3 ; 
for this inplenentation, there is no such type: 


C354043 
C4 54 12 B 
C456113 
352004E 
CD~101E 


336105C 
C4 5 5 02 B 
C45613B 
C55B07B 


C45231B 

C45503B 

C45614B 

B55B09D 


C45304B 
C4 5 5 C 4 B 
C4563IB 
B86001V 


0 : 5411 =! 

C45504E 

C456323 

C360C6D 


C35404D, 
predefin 
LCNG_] 
no sue 


’4 523 1D, 336301X, C36006E, and 

integer type with a name 


:eger, 

tvte. 


or 


CD7101G check for a 
other than INTEGER, 
ilGER; for this implementation, there is 


G35712D and 3360012 check for a predefined floating-point type with 
a name ocher than FLOAT, L0NG_FL0AT, or SH0RT_FL0AT; for this 
implementation, there is no such type. 

C45531M..P and C45532M..? (3 tests) check fixed-point operations 
for types t.hat require a SYSTEM.MAX_.MANTISSA of 47 or greater; for 
this implementation, there is no such type. 

C45624A..3 (2 tests) check that the proper exception is raised if 
:iACHINE_OVERFLCWS is FALSE for floating point types; for this 
implementation, MACHINE_OVERFLOWS is TRUE. 

336001Y uses the name of a predefined fixed-point type other than 
3URATICN; for this implementation, there is no such type. 

CD1009C c.hecks whether a length clause can specify a non-default 
size for a floating-point type; this implementation does not 
support such sizes. 


GD2A34A, C02A34E, CD2A34I..J (2 tests), and CD2A340 use length 
clauses to specify non-d«=fauIt sizes for access types; this 
im.plementation does not support such sizes. 

AE2101C and EE2201D..E (2 tests) use instantiations of package 
SEQUENTIAL_10 with unconstrained array types and record types with 
discriminants without defaults; these instantiations are rejected 
cv this compiler. 


2-2 




AE2101H, EEZ401D, and EE2401G use instantiations of package 
EIRECT_IO unconstrained array types and record types witn 
discrininants vithcut defaults; these instantlaticns are reiected 
cy rhis ccnpiler. 


33'CS d..I.5tI3Ci 

1 y^, "tl 0 

followi.ng table 

are not applicable because 

'id'0n c 

perations are supported 

for t.he given 

combination 

■da and file 

access 

method. 



T S S tl r 

lie Operation Mode 

File Access 

Method 

'•>, z. Z 2. 0 z z. 

CREATE 

OUT FILE 

SEQUENTIAL 

10 

CE 210 2 F 

CREATE 

INCUT FILE 

DIRECT 10 


CE2102J 

CREATE 

CUT FILE 

DIRECT 10 


CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 

10 

CE21020 

RESET 

IN FILE 

SEQUENTIAL 

10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 

10 

CEO 102Q 

RESET 

OUT FILE 

SEQUENTIAL 

10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 


CE21Q2S 

RESET 

INOUT FILE 

DIRECT 10 


C z- 2 1 j 2 T 

OPEN 

IN FILE 

DIRECT 10 


CE2102U 

RESET 

IN FILE 

DIRECT 10 


CE21D2T 

OPEN 

OUT FILE 

DIRECT 10 


'w Z. Z * Z tV 

RESET 

GUT FILE 

DIRECT 10 


r* T “J h '"h IT 

^ ^ ^ Z 

RESET 

Any Mode 

TEXT 10 



DELETE 


TEXT 10 


/-«tr rv o T* 

M V . -J ^ X 

CREATE 

OUT FILE 

TEXT 10 


CE3102J 

OPEN 

IN FILE 

TEXT 10 


CE3102K 

OPEN 

0UT_FILE 

TEXT 10 


ests listed 

in the 

following table 

are not applicable because 

given file 

operat 

ions are not 

supported for the given 

.nation of mode and 

file access method. 


Test F 

ile Operation Mode 

File Access 

Method 

CE2 1C5A 

CREATE 

IN FILE 

SEQUENTIAL 

10 

CE21053 

CREATE 

IN FILE 

DIRECT 10 


CE3 109A 

CREATE 

IN FILE 

TEXT 10 



The following 19 tests check operations on sequential, direct, and 
text files when multiple internal files are associated with the 
same external file; USE_ERRCR is raised when this association is 
attempted. 

CE2107A..H CE2107L CE2110B CE2110D CE2111D 
CE2111H CE3111A..B CE3111D..E CE3114B CE3115A 


TE2201A checks that WRITE raises USE_ERROR if the capacity of an 
external seq'uentiai file is exceeded; this implementation cannot 
restrict file capacity. 


2-3 



CE2403A checks that WRITE raises USE_ERROR if the capacity of an 
external dfr^t file is exceeded; this implementation cannot 
restrict file capacity, 

CE3304A checks that SET_LINE_LENGTH and SET_PAGE_LENGTH raise 
USE ERROR if they specify an inappropriate value for the external 
file; there ar 2 no inappropriate values for this implementation. 

CE3413B checks that PAGE raises LAy0UT_ERR0R when the value of the 
page number exceeds COUNT'LAST. For this implementation, the value 
of COUNT'LAST is greater than 150000 making the checking of this 
objective impractical. 


2.3 TEST MODIFICATIONS 

Modifications (.’see section 1.3) were required for 44 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in 
the way expected by the original tests. 

B22003A B22004A B23004A B24005A B24005B B28003A 
B33201C B33202C B33203C B33301B B37106A B37301I 
B33003A B38003B B38009A B38009B B44001A B44004A 
B54A01L B55A01A B61005A B85008G B85008H B95063A 
B97103E BB1006B BC1102A BC1109A BC1109B BC1109C 
BC1109D BC1201F BC1201G BC1201H BC1201I BC1201J 
BC1201L BC3013A BE2210A BE2413A 

C83030C and C86007A were graded passed by Test Modification as 
directed by the AVO. These tests were modified by inserting 
"PRAGMA ELABORATE (REPORT);" before the package declarations at 
lines 13 and 11, respectively. Without the pragma, the packages 
may be elaborated prior to package Report's body, and thus the 
packages' calls to function REPORT.IDENT_INT at lines 14 and 13, 
respectively, will raise PR0GRAM_ERR0R. 

C34005P and C34005S were graded passed by Test Modification as 
directed by the AVO. These tests contain expressions of the form 
"I - X'FIRST + Y'FIRST", where X and Y are of an array type with a 
lower bound of INTEGER'FIRST; this implementation recognizes that 
"X'FIRST + Y'FIRST" is a loop invariant and so evaluates this part 
of the expression separately, which raises NUMERIC_ERROR. These 
tests were modified by inserting parens to force a different order 
of evaluation (i.p., to force the subtraction to be evaluated 
^irst) at lines 187 and 262/263, respectively; those modified lines 


;C34005P, line 187] 


2-4 









CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is 
described adequately by the information given in the initial 
pages of this report. 

For a point of contact for technical information about tliis 
Ada implementation system, see: 

Mr. Christopher T. Geyer 

Fleet Combat Directions Systems Support Activity 
Code 81, Room 30ID 
200 Catalina Blvd. 

San Diego, California 92147 
619-553-9447 


For a point of contact for sales information about this Ada 
implementation system, see: 

NOT APPLICABLE FOR THIS IMPLEMENTATION 

Testing of this Ada implementation was conducted at the 
customer's site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
:Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


a) Total Number of Applicable Tests 3772 

b) Total Number of Withdrawn Tests 94 

c) Processed Inapplicable Tests 304 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 0 


3-1 




fT'l^tal Number of Inapplicable Tests 304 
g) Total Number of Tests for ACVC 1.11 4170 


(c4-d+e) 
(a''"b+ f) 


en this im.plementation was tested, the tests listed in section 
1 had been withdrawn because of test errors. 


3 TEST EXECUTION 

Version 1.11 of the ACVC comprises 4170 tests. When this 
compiler was tested, the tests listed in section 2.1 had been 
withdrawn because of test errors. The AVF determined that 304 
tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing. 
In addition, the modified tests mentioned in section 2.3 were 
also processed. 

A magnetic tape containing the customized test suite (see 
section 1.3) was taken on-site by the validation team for 
processing. The contents of the magnetic tape were loaded 
directly onto the host computer. 

After the test files were loaded onto the host computer, the 
full set of tests was processed by the Ada implementation. 

The tests were compiled and linked on the host computer system 
and executed on the target computer system. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B 
for a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this 
test were: 


FOR /OPTIMIZE the options were: 

/SUMMARY /OPTIMIZE /SOURCE /OUT=<filename> 


The options invoked by default for validation testing during 
this test were: 


FOR /OPTIMIZE the options were: 

N0_MACHINE_C0DE NO_ATTRIBUTE NO_CROSS_REFERENCE 

NO DIAGNOSTICS NO NOTES PRIVATE LIST CONTAINER GENERATION 


3-2 



CODE_ON_WARNING NO_MEASURE DEBUG CHECKS NO_EXECUTIVE 
NO_RTEf0ltLY TRACE_BACK /NO_EMR 

Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. Selected 
listings examined on-site by the validation team were also 
archived. 



APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for 
customizing the ACVC. The meaning and purpose of these 
parameters are explained in [UG89]. The parameter values are 
presented in two tables. The first table lists the values 
that are defined in terms of the maximum input-line length, 
which is I the value for $MAX_IN_LEN—also listed here. 
These values are expressed here as Ada string aggregates, 
where "V" represents the maximum input-line length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 120 

$BIG_ID1 (1..V-1 => 'A', V => '1') 

$BIG_ID2 (1..V-1 => 'A', V => '2') 

$BIG_ID3 (1..V/2 => 'A') & '3' & (1..V-1-V/2 => 'A') 

$BIG_ID4 (1..V/2 => 'A') & '4' & (1..V-1-V/2 => 'A') 

$BIG_INT_LIT (1..V-3 => '0') & "298" 

$BIG_REAL_LIT (1..V-5 => '0') & "690.0" 

$BIG_STRING1 "" & (1..V/2 => 'A') & "" 

$BIG_STRING2 "" & (1..V-1-V/2 => 'A') & '1' & "" 

$BLANKS (1..V-20 => ' ') 

$MAX_LEN_INT_BASED_LITERAL 

"2:" & (1..V-5 => '0') & "11:" 

$MAiX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => '0') & "F.E:" 

$MAX_STRING_LITERAL & (1..V-2 => 'A') & "" 


A-1 






The foTlSVing table contains the values for the remaining 
macro parameters. 

Macro Parameter Macro Value 


$ACC_SIZE 

$ALIGNMENT 

$COUNT_LAST 

$ DEFAULT_MEM_SIZ E 

$DEFAULT_STOR_UNIT 

$DEFAULT_SYS_NAME 

$DELTA_DOC 

$ENTRy_ADDRESS 

$ENTRY_ADDRESS1 

$ENTRY_ADDRESS2 

$FIELD_LAST 

$FILE_TERMINATOR 

$FIXED_NAME 

$FLOAT_NAME 

$FORM_STRING 

$F0RM_STRING2 

$GREATER_THAN_DURATION 

$GREATER_THAN_DURATION_BASE 

$GREATER THAN FLOAT BASE_LA, 


32 
4 

2_147_483_647 
1_048_576 
32 

ANUYK4 3 

240 . 0000_0000_0000_0000_0000_0 
000 _ 0000 _ 001 # 

SYSTEM.CLASS_I_UNHANDLED_ADDRE 
SS 

SYSTEM.CLASS_II_UNHANDLED_ADDR 
ESS 

SYSTEM.CLASS_III_UNHANDLED_ADD 
RESS 

2_147_483_647 

I I 

NO_SUCH_FIXED_TYPE 
NO_SUCH_FLOAT_TYPE 

IIII 

"CANNOT_RESTRICT_FILE_CAPACITY" 
131071.5 
LAST 131_073.0 
T 7.5E+75 


SGREATER THAN FLOAT SAFE LARGE 7.5E+75 


A-2 






$GREATSg_TKAN_SHORT_FLOAT_SAFE_LARGE 0.OEO 

$HIGH_PRIORITY 15 

• 

$ILLEGAL_EXTERNAL_FILE_NAME1 

\NODIRECTORY\FILENANE\ 


$ILLEGAL_EXTERNAL_FIL£_NAME2 

THIS-FILE-NAME-IS-TOO-LONG-FQR- 

MY-SYSTEM 


$INAPPROPRIATE_LINE_LENGTH 

-1 


$INAPPROPRIATE_PAGE_LENGTH 

-1 


$INCLUDE_PRAGMA1 

PRAGMA INCLUDE ( "A28006D1.TST" ) 


$INCLUDE_PRAGMA2 

PRAGMA INCLUDE ( "B23006F1.TST") 


$INTEGER_FIRST 

-2147483647 


$INTEGER_LAST 

2147483647 


$INTEGER_LAST_PLUS_1 

2147483648 


$INTERFACE_LANGUAGE 

MACRO_NORMAL 


$LESS_THAN_DURATION -131071.5 

$LESS_THAN_DURATION_BASE_FIRST -131_073.0 

• 

$LINE_TERMINATOR 

ASCII.LF 


$LOW_PRIORITY 

0 


$MACHINE_CODE_STATEMENT 

format!'(f_lb,0,0,0,0,0,0) 


$I1ACHINE_C0DE_TYPE 

format! 


$MANTISSA_DOC 

31 


$MAX_DIGITS 

15 


$MAX_INT 

9223372036854775807 


$MAX_INT_PLUS_1 

9223372036854775808 


$MIN_INT 

-9223372036854775807 


$NAME 

NO_SUCH_TYPE_AVAILABLE 


$NAME_LIST 

ANUYK43 


A-3 

- 

• 





$ N A.ME_S PECIFICATIONl 

X212CA 


$NAiME_3PECIFICATION2 

X2120B 


$NAME_SPECIFICATION3 

X3119A 


$NEG_BASED_INT 

16#FFFFFFFFFFFFFFFD# 


$NT^W_MEM_SI2E 

1_048_576 


$NEW_STOR_UNIT 

32 


$NEW_SYS_NAME 

ANUYK43 


$PAGE_TERMINATOR 

ASCII.FF 


$RECORD_DEFINITION 

record f:i6_bit; a: 

i3_bit; 


k:i3_bit; b:i3 bit; i: 

il_bit; 


s:i3_bit; y:il3_bit; 

record; 

end 

$RECORD _NAME 

format!i 


$TASK_SI2E 

32 


$TASK_STORAGE_SIZE 

1024 


$TICK 

0.000048828125 


$VARIABLE_ADDRESS 

16#0020# 


$VARIABLE_ADDRESS1 

16#0021# 


$VARIABLE_ADD?.ESS2 

16#0023# 


$YOUR_PRAGMA 

EXECUTIVE 



A-4 




rt H 


APPENDIX B 


COMPILATION SYSTEM OPTIONS 


he compiler options of this Ada implementation, as 
his Appendix, are provided by the customer. Unless 
noted otherwise, references in this appendix are 
documentation and not to this report. 


z. 


I 


described i 
specificall 
to compile 




LINKER OPTIONS 


The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation 
and not to this report. 


B-2 



rt ft 


APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond 
implementation-dependent pragmas, to certain machine-depende 
conventions as mentioned in Chapter 13 of the Ada Standard, and 
certain allowed restrictions on representation clauses. T 
implementation-dependent characteristics of this Ada implementatio 
as described in this Appendix, are provided by the customer. Unle 
specifically noted otherwise, references in this Appendix are 
compiler documentation and not to this repor 
Implementation-specific portions of the package STANDARD, which a 
not a part of Appendix F, are: 

package STANDARD is 

ype INTEGER is range -2_147_433__647 .. 2_147_433_647 ; 
ype LONG_INTEGER is range 

-9_223_372_036_354_775_307 .. 9_223_372_036_854 775 30" 
type FLOAT is digits 6 range - _ _ _ 

-(16:fO.FF_FFF34E63) .. (16#0 . FF_FFF8 #E63 ) ; 

type LONG_FLOAT is digits 15 range 

- (16=f0 . FF_FFFF_FFFF_FFE0#E63) .. (16#0 . FF_FFFF_FFFF_FFE0:fE63 ) 
type DURATION is delta 2.0 ** (-14) range 
-131 071.0 .. 131 071.0; 


end STANDARD; 



Ada/L ?SE 


Har.dbocK 


Ve r s 1 or. 
2 9 .Marcr 


j . 3 


991 


Appendix F 

The Ada Language for the AN/UYK-43 Target 


The 3corc9 language accepted by the compiler is .Ada, as 
descnoed ir the .Military Standard, .Ada ProgratTumirg language, 
.ANSI/MI1-STD-1315A-1933, * 17 February 1983 (''.Ada language 
Reference Manual"). 

The .Ada definition permits certain i.mplementation 
dependencies. Eac.h .Ada i.mple.mentacion is required to supply a 
complete description of its dependencies, to be thought of as 
.Appendi.'C E to tne Ada language Reference .Manual. This section is 
that description for tne AN/EVK-43 target. 


F.l Options 

There are several com.piler options provided by all .AIS/N 
Co.mpilers mat directly affect the pragmas defined in tne .Ada 
language Reference .Manual. These compiler options currently 
inc-ude tne CHECKS and OPTI.MIZE options which affect the SUPPRESS 
and OPTIMIZE pragmas, respectively. A complete list of ALS. N 
Compiler options can be found in Section 9. 

The CHECKS option enables all run-time error checking for tne 
source file being compiled, which can contain one or .more 
compilation units. This allows the SUPPRESS pragma to be used in 
suppressing tne run-ti.me c.necks discussed in the Ada Language 
Reference .Manual, but note that the SUPPRESS pragma! s) must be 
applied to each compilation unit. The NO_CHECKS option disables 
all run-ti.me error checking for all compilation units within the 
source file and is equivalent to SUPPRESSing all run-ti.me checks 
witnin every compilation unit. 

The OPTIMIZE option enables all compile-time opti.mizations 
for the source file being compiled, which can contain one or more 
compilation units. This allows the OPTIMIZE pragma to request 
either TIME-oriented or SPACE-oriented optimizations be 
performed, but note that the OPTIMIZE pragma must be applied to 
each compilation unit. If the OPTIMIZE oraama is not present, 
the ALS/N Compiler's Global Optimizer tends to optimize for TI.ME 
over SPACE. The NO_OPTIMIZE option disables all compile-ti.me 
opti.mizations for all compilation units within the source file 
regardless of whether or not the OPTIMIZE pragma is present. 

In addition to t.hose co.mpiler options normally provided by 
the ALS/N Common Ada Baseline compilers, the Ada/L compiler also 
implements the EXECUTIVE, DEBUG, and MEASURE options. 


F 


Opt ions 


F-01 



?SE Har.dbcoK 


Version 3.o Ada/L 

2 9 Mar on 1991 



EXZC'J?fV-E compiler opcicn enables processing 
E and allows WITH of cnics compiled winh one 
If N'0_ZXEC1:TIVE is specified on one comjnand 
ill be ignored and will nave no effecn on one 


of PRAGMA 
RTE ONLY 


-me, me 
generated 


T'ne DEBUG ccmoiler option enaoles processing of PRAGMA DEBUG 
to provide deaugging support. If NO_DEBUG is specified, tine 
DEBUG pragmas snail nave no effect. Program un-ts containing 
DEBUG pragmas and compiled with the DEBUG compiler option Tiay oe 
l-n<ed wirn program units containing DEBUG pragmas and compiled 
witn me NO_DE3UG option; only those program units compiled wim 
me DEBUG option snail have additional DEBUG support. 

The MEASURE compiler option enables run-time calls to 
Run-Time Performance Measurement Aids (RTAids) to record the 
entrance into all subprograms whose bodies are in the 
com.pilat 1 on . Program units compiled with the /MEASURE option m.ay 
oe lin<ed wim program units not compiled with the /MEASURE 
option: at run-time, only those subprograms in program units 
comoi-ed witn tne /MEASURE ootion snail have this additional 
MEASURE support. 




E-0 2 


F.l Ootions 






V 


Ada/ L ?SE :-iandbco< 


Version :.5 
2 9 Marcr. 19 91 


F.2 Pragmas 

3oth impiementacion-defined and Ada language-defined pragmas 
are provided by all ALS/N compilers. These paragraphs descrioe 
one pragmas recognized and processed by the Ada/L compiler. The 
synoa.x defined in Section 2.3 of the Ada -anguage Reference 
Manual allows a pragma as the only element in a compilation unit, 
before a compilation unit, at defined places within a compilation 
unit, or following a compilation unit. Ada/L associates pragmas 
with compilation units as follows; 

a. If a pragma appears before any compilation unit in a 
compilation, it will affect all following compilation units, 
as specified below and in section 10.1 of the Ada Language 
Reference Manual. 

b. If a pragma appears inside a compilation unit, it will be 
associated wit.h that compilation unit, and with the listings 
associated with that compilation unit, as described in the 
Ada Language Reference Manual, or below. 

c. If a pragma follows a compilation unit, it will be associated 
with the preceding compilation unit, and effects of the 
pragma will be found in the container of that compilation 
unit and in the listings associated with that container. 

The pragmas MEMORY_SI2£, STORAGEJJNIT, and SYSTEM_NAME are 
described in Section 13.7 of the Ada Language Reference Manual, 
hey may appear only at the start of the first compilation when 
reating a program library. In the ALS/N, however, since program 
libraries are created by the Program Library Manager and not by 
the compiler, the use of these pragmas is obviated. If they 
appear anywhere, a diagnostic of severity level WARNING is 
generated. 


F.2 Pragmas 


F-03 









Version 3.5 
29 Marc.^ 1991 


Ada/L ?SE Handbook 


F.2.1 Languaf«^efined Pragmas 

The following notes specify imple-mentation-specific changes 
to those pragmas described in Appendix 3 of the Ada Language 
Reference Manual. Unmentioned pragmas are i.mpie.mented as defined 
in the .Ada Language Reference Manual. 

pragma INLINE (arg {,arg}); 

The arguments designate subprograms. There are three 
instances in which the INLINE pragma is ignored. Each 
of these cases produces a warning message which states 
that the INLINE did not occur. 

a. If the compilation unit containing the INLINEd 
subprogram depends on the compilation unit of its 
caller, a routine call is made instead. 

b. If the INLINEd subprogram’s compilation unit 
depends on the compilation unit of its caller (a 
routine call is made instead). 

c. If an immediately recursive subprogram call is made 
within the body of the INLINEd subprogram (the 
pragma INLINE is ignored entirely). 

pragma INTERFACE {language_name, subprogram_name); 

The Ianguage_name specifies the language and type of 
interface to be used in calls used to the externally 
supplied subprogram specified by subprogram_name. The 
allowed values for language name are MACRO^NOEIMAL and 
MACRO_OUICK. MACRO_NORMAL Indicates that parameters 
will be passed on the stack and the calling conventions 
used for normal Ada subprogram calls will apply. 

MACRO_QUICK is used in RTLIB routines to indicate that 
parameters are passed in registers. See Section 7 
"Parameter Passing" for details on the space required 
to pass various types of parameters. 

You must ensure that an assembly-language body 
container will exist in the program library before 
linking. 


F-04 


F.2.1 


Language-Defined Pragmas 


Ada/L ?SE HandbooK 


^ers-OPi 3.5 
29 .Marc.". 19 91 


pragma OME^MIZE (arg. 


The argument is either TI.ME or SPACE. If TIME is 
specified, the optimizer concentrates on optimizing 
code e.xecution ti.me. If SPACE is specified, the 
optimizer concentrates on opti.mizing code size. The 
default is If the OPTIMIZE option is enabled and pragma 
OPTI.MIZE is not present, global optimization is still 
performed with the default argument, SPACE. Progra.m 
units containing OPTIMIZE pragmas and compiled with the 
OPTI.MIZE option may be li.nked with program u.nits 
containing OPTI.MIZE pragmas and compiled with the 
NO_OPTI.MIZS option; but only those program units 
compiled wic.h the OPTI.MIZE option will have global 
opti.mization support. 


pragma PRIORITY (arg); 


The argu.me 
range 0..1 
priority a 
argu.ment i 
effect cth 
value of z 
The pragma 
task (type 
part of a 
declarativ 
effect uni 
subprogram 


nc IS an integer static expression in the 
5, where 0 is the lowest use-specifiable task 
nd 15 is the highest. If the value of the 
s out of range, the pragma will have no 
er than to generate a WARNING diagnostic. .A 
ero will be used if priority is not defined, 
will have no effect when not specified in a 
) specification or the outermost declarative 
subprogram. If the pragma appears in the 
e part of a subprogram, it will have no 
ess that subprogram is designated as the main 
at link time. 


pragma SUPPRESS (arg {,arg}); 


This pragma is unchanged with the following exceptions: 


Suppression of OVERFLOW_CHECK applies only to integer 
operations; and PRAGMA SUPPRESS has effect only within 
the compilation unit in which it appears, except that 
suppression of ELABORATION_CHECK applied at the 
declaration of a subprogram or task unit applies to all 
calls or activations. 



E.2.1 


Language-Defined Pragmas 


F-05 




Version 3.5 
29 March 1991 


Ada/L ?S£ HandbccK 


F.2.2 Implefflenfation-Defined Pragmas 

This paragraph describes the use and meaning of those pragmas 

recognized by Ada/L which are not specified in Appendix 3 of me 

Ada Language Reference Manual. 

pragma DEBUG; 

This pragma enables the inclusion of full symbolic 
information and support for the Embedded Target 
Debugger. The DEBUG PRAGMA is enabled by the /DEBUG 
command line option and has no effect if this option is 
not provided. This pragma must appear within a 
compilation unit, before the first declaration or 
statement. 

pragm.a EXECUTIVE [ (arg) ] ; 

This pragma allows you to specify that a compilation 
unit is to run in the executive state of the machine 
and/or utilize privileged instructions. The pragma has 
no effect if the Compiler option NO_EXECUTrVE is 
enabled, either explicitly or by default. 

If PRAGMA EXECUTIVE is specified without an argument, 
executive state is in effect for the compilation unit 
and the code generator does not generate privileged 
instructions for the compilation unit. If PRAGMA 
EXECUTIVE (INHERIT) is specified, a subprogram in the 
compilation unit inherits the state of its caller and 
the code generator does not generate privileged 
instructions for the compilation unit. If PRAGMA 
EXECUTIVE (PRIVILEGED) is specified, the executive 
state is in effect and the code generator may generate 
privileged instructions for the compilation unit. 

Currently, the Ada/L compiler does not generate such 
instructions. In the absence of PRAGMA EXECUTIVE, the 
compilation unit executes in task state and the code 
generator does not generate privileged instructions. 

If PRAGMA EXECUTIVE (INTERRUPT_CMR) is specified, the 
Ada/L compiler generates code which uses executive 
state registers instead of task state registers (i.e. 

SCI instead of SCT). 

PRAGMA EXECUTIVE is applied once per compilation unit, 
so its scope is the entire compilation unit. PRAGMA 
EXECUTIVE may appear between the context clause and the 
outermost unit. If there is no context clause, PRAGMA 
EXECUTIVE must appear within that unit before the first 
declaration or statement. The placement of the pragma 
before the context clause has no effect on any or all 
following compilation units. If PRAGMA EXECUTIVE 
appears in the specification of a compilation unit, it 


F-06 


F.2.2 Implementation-Defined Pragmas 




Ada/L ?SE Handbook 


Version 3.5 
29 .March 1991 


mus-e:^^±^o appear in the body of that unit, and vice 
versa. If the pragma appears in a specification but is 
absent from the body, you are warned and the pragma is 
effective. If the pragma appears in the body of a 
compilation unit, but is absent from the corresponding 
specification, you are warned and the pragma has no 
effect. PRAGMA EXECUTIVE does not propagate to 
subunits. If a subunit is compiled without PRAGMA 
EXECUTIVE and the parent of the subunit is compiled 
with PRAGMA EXECUTIVE, you are warned and PRAGMA 
EXECUTIVE has no effect on the subunit. 

pragma FAST_INTERRUPT_ENTRY (entry_name, IMMEDIATE); 

This pragma provides for situations of high interrupt 
rates with simple processing per interrupt, (such as 
adding data to a buffer), and where complex processing 
occurs only after large numbers of these interrupts 
(such as when che buffer is full). This allows for 
lower overhead and faster response capability by 
restricting you to disciplines that are commensurate 
with limitations normally found in machine level 
interrupt service routine processing. 

pragma MEASURE (extraction_set, (arg {,arg}]); 

This pragma enables one or more performance measurement 
features. Pragma MEASURE specifies a user-defined 
extraction set for the Run-Time Performance Measurement 
Aids and Embedded Target Profiler. The user-defined 
extraction set consists of all occurences pragma 
MEASURE throughout the program. Extraction_set is a 
numeric literal, which is an index into a user-supplied 
table. Arg is a variable or a list of variables whose 
values are reported at this point in the execution. 
These values describe the nature (TYPE) of the values 
collected to an independent data reduction program. 
Pragma MEASURE is enabled by the /MEASURE command line 
option and has no effect if this option is not 
provided. This pragma should be applied to a package 
body rather than a package specification. 

pragma STATIC (INTERRUPT_HANDLER_TASK); 

The pragma STATIC is only allowed immediately after the 
declaration of a task body containing an immediate 
interrupt entry. The argument is 

INTERRUPT_HANDLER_TASK. The effect of this pragma will 
be to allow generation of nonreentrant and nonrecursive 
code in a compilation unit, and to allow static 
allocation of all data in a compilation unit. This 
pragma shall be used to allow for procedures within 
immediate (fast) interrupt entries. The effect will be 


F.2.2 Implementation-Defined Pragmas 


F-07 



Version 3.5 
29 March 1991 


Ada/L ?SE Handbcc*^ 


for che-«9fflpiler to generate nonreentrant code for the 
affected procedure bodies. If a STATIC procedure is 
called recursively, the program is erroneous. 

pragma TITLE (arg); 

This is a listing control pragma. It takes a single 
argument of type string. The string specified will 
appear on the second line of each page of the source 
listing produced for the compilation unit within which 
it appears. The pragma should be the first lexical 
unit to appear within a compilation unit (excluding 
comments). If it is not, a warning message is issued. 

pragma TRIVIAL_ENTRY (NAME: entry_simple_name); 

This pragma is only allowed within a task specification 
after an entry declaration and identifies a 
Trivial_Entry to the system. A trivial entry 
represents a synchroni 2 ation point, contained in a 
normal Ada task, for rendezvous with a fast interrupt 
entry body. The body of a trivial entry must be null. 

pragma UNMAPPED (arg {,arg}); 

The effect of this pragma is for unmapped (i.e., not 
consistently mapped within the virtual space) 
allocation of data in a compilation unit. The 
arguments of this pragma are access types to be 
unmapped. If a program tries to allocate more UNMAPPED 
space than is available in the physical configuration, 
STORAGE_ERROR will be raised at run-time. PRAGMA 
UNMAPPED must appear in the same declarative region as 
the type and after the type declaration. 


F-08 


F.2.2 Implementation-Detined Pragmas 




Ada/L PSE Handboox 


Version 3.5 
29 March 1991 


P.2.3 of Pragmas 

The scope for each pragma previously described as differing 

from rhe Ada Language Reference Manual is given below: 

DE3CG Applies to che compilation unit in which the prac-ma 

appears. 

EXECUTIVE Applies to the compilation unit in which the pragma 
appears, i.e., to ail subprograms and tasio wirhin 
the unit. Elaboration code is not affected. 

The pragma is not propagated from specifications 
to bodies, or from bodies to subunits. The prag.ma 
must appear consistently in the specification, 
body, and subunits associated with a library unit. 

F.AST_INTERRUPT_ENTRY 

Applies to the compilation unit in which the pragma 
appears. 

INLINE Applies only to subprogram names in its 

arguments. If the argument is an overloaded 
subprogram name, the INLINE pragma applies to 
all definitions of that subprogram name which 
appear in the same declarative part as the 
INLINE pragma. 

INTERFACE Applies to all invocations of the named 
imported subprogram. 

MEASURE No scope, but a WARNING diagnostic is 

generated. 

MEMORY_SIZE No scope, but a WARNING diagnostic is 
generated. 

OPTIMIZE Applies to the entire compilation unit in 

which the pragma appears. 

PRIORITY Applies to the task specification in which it 

appears, or to the environment task if it 
appears in the main subprogram. 

STATIC Applies to the compilation unit in which the pragma 

appears. 

STORAGE_UNIT No scope, but a WARNING diagnostic is 
generated. 

SUPPRESS Applies to the block or body that contains 

the declarative part in which the pragma 
appears. 


F.2.3 Scope of Pragmas 


F-09 






Version 3.5 
29 Marc.^ 1991 


Ada/L ?SE Handbook 


SYSTEM_NAME scope, but a WARNING diagnostic is 

generated. 

TITLE Tbe compilation unit within which the pragma 

occurs. 

TRIVI.AL_ENTRY Applies to the compilation unit in which the pragma 
appears. 

UNMAPPED Applies to all objects of the access type 

named as arguments. 


F-10 


F.2.3 Scope of Pragmas 






Ada/L ?SE Handbook 


Version 3.5 
29 March 1991 

F.3 AttrTbtrtes 

The following notes augment the language-required definioions 
of “he predefined attributes found in Appendix A of the Ada 
language Reference Manual. 

T'MACHINE_EMAX is 63. 

T’MACHINE_EMIN is -64. 

T'MACHINE_MANTISSA is 6. 

T'MACHI.NZ_OVERFLOWS is TRUE. 

T‘MACHINE_RADIX is 16. 

T'MACHINE ROUNDS is FALSE. 


F.3 Attributes 


F-li 



Version 3.5 
29 March 1991 


Ada/Li ?SE Handboc< 


F.4 Predefinwi^anguage Environment 

The predefined Ada language environ.Tient consists of the 
packages STANDARD and SYSTEM, which are described below. 


F.4.1 Package STANDARD 

The package STANDARD contains the following definitions in 
addition to those specified in Appendix C of the Ada Language 
Reference Manual. 

TYPE boolean IS (false, true); 

FOR boolean'SIZE USE 1; 

TYPE integer IS RANGE -2_147_483_647 .. 2_147_483_647; 

TYPE long_integer IS RANGE 

-9_223_372_036_854_775_807 .. 9_223_3'^2_Q 36_854_775_807 ; 

TYPE float IS DIGITS 6 RANGE 

-(16#0.FF_FFF8#E63) .. (16#0.FF_FFF3#E63); 
TYPE lcng_flcat IS DIGITS 15 RANGE 

-(16#0.FF_FFFF_FFFF_FFE0#E63) .. 

(16#0.FF_rrFF_FFFF_FFE0#E6 3) ; 

SUBTYPE natural IS integer RANGE 0 .. integer’LAST; 

SUBTYPE positive IS integer RANGE 1 .. integer’LAST; 

SUBTYPE long_natural IS long_integer 

RANGE 0 .. long_integer'LAST; 

SUBTYPE long_positive IS iong_integer 

RANGE 1 .. long_integer'LAST; 

FOR character'SIZE USE 8; 

TYPE string IS ARRAY (positive RANGE <>) OF character; 
PRAGMA PACK(string); 

TYPE duration IS DELTA 2.0 ** (-14) 

RANGE -i31_07i.0 .. 131_071.0; 

— The predefined exceptions: 

constraint_error : exception; 

numeric_error : exception; 

program_error : exception; 

storage_error : exception; 

tasking_error : exception; 


F-12 


F.4.1 Package STANDARD 







Ada/L ?SE Handbook 


Ve r s’on 
Maron I 


F.4.2 EWrtage SYSTEM 

The package SYSTEM for Ada/L is as follows: 

TYPE name IS {anuyk43); 

5yscem_name : CONSTANT syscem.name := systern.anuyk43; 
st:orage_unir : CONSTANT := 32; 

memory_si 2 e : CONSTANT := 1_048_576; 

TYPE address IS RANGE 0..system.memory_size - 1; 

— System Dependent Named Numbers 

min_int : CONSTANT := -((2**63)-1); 

max_int : CONSTANT := (2**63)-!; 

max_digits ; CONSTANT := 15; 

max_manti3sa : CONSTANT := 31; 

fine_delta : CONSTANT 

:= 2 # 0 . 0000 _ 0000 _ 0000 _ 0000 _ 0000 _ 0000 _ 0000 _ 001 #; 

tick : CONSTANT := 4.8828125e-05; 

— 1/20480 seconds is the basic clock period. 
nuil_addr : CONSTANT address := 0; 

— Other System Dependent Declarations 

SUBTYPE smaller_integer IS 

integer RANGE (integer’FIRST/64)..(integer'LAST/64); 

SUBTYPE priority IS integer RANGE 0..15; 

TYPE entry_kind is (normal, immediate); 

physical_memory_size : CONSTANT := 2**31; 

TYPE physical_address IS 

ElANGE 0 .. system. physical_memory_3ize - 1 ; 

null_phys_addr : CONSTANT physical_address := 0; 

TYPE word IS NEW INTEGER; 


— Address clause (interrupt) addresses 

Class_I_Unhandled_address : CONSTANT 

address := 16#0800#: 

Clas3_II_Unhandled_addres3 : CONSTANT 

address := 16#1800#; 

CP_Operand_Memory_Resume_address : CONSTANT 

address := 16#1000#; 

CP_IOC_Command_Resume_address : CONSTANT 

address := 16#1100#: 

CP_Instruction_Memory_Resume_aduress : CONSTANT 

address := 16#1200#; 

CP_IOC_Interrupt_Code_Resume address : CONSTANT 

address := 16#1300#; 

CP_Operand_Memory_Error_address : CONSTANT 


F.4.2 Package SYSTEM 









Version 3.3 
29 .March 1991 


Ada/L ?SE Har.dbcoK 


C?_Inscruction_Memory_Er ror_address 

C?_IOC_Command_Operar.d_Er ror_address 

IOC_Me.Tiory_Er ror_address 

I?I_rault_addres3 

IOC_Memory_.Resume_address 

Inter computer _Ti.’neouc_addr ess 

Confidence_Test_Fault_address 

C?U_IOC_Microprocessor_Stop_address 

Module_Inter rupt_address 

?ower_Tolerance_Inter rupt_address 

Class_III_Unhandled address 

C?_Illegal_:nstruction_Er ror_address 

?rivileged_Instruction_Er ror_address 

Dat3_Pattern_3reakpoint_address 

0perand_8reakpoint_Match_address 

Operand_Read_address 

DCU_Status_Interrupt_address 

Operand_Write_Protection_addres3 

0perand_Limit_Protection_addres3 

Instruction__Breakpoint_Match_addre3S 


address := 

: CONST.ANT 
address := 

: CONST.A.MT 
addresc := 

: CONSTANT 
address := 

: CONSTANT 
address := 

: CONSTANT 
address := 

: CONSTANT 
address := 

; CONSTANT 
address := 
: CONSTANT 
address := 
: CONSTANT 
address := 
: CONSTANT 
address := 
: CONSTANT 
address := 
: CONSTANT 
address := 
: CONSTANT 
address := 
: CONSTANT 
address := 
: CONSTANT 
ter" * ■■ 
: CONSTANT 
address := 
: CONSTANT 
address := 
: CONSTANT 
address := 
; CONSTANT 
address := 
; CONSTANT 
address := 


16#1400#; 
16#1500i^; 
16#1600#; 
16#170C#; 
16#1900# ; 
16#1A00# ; 
I6itl300# ; 
16#1C00#; 
I6#1DOO#; 
16#1E0C#; 
16#IF00»; 
16#2800#; 
I6#2200#; 
16#2300#; 

16#2400#; 

’ £. i') c. r\r\ * . 

i6#2600#; 

16#2700#; 

L6#2900#; 

L6#2A00#; 

16#2B00#; 


F-14 


F.4.2 Package SYSTEM 








Ada/ 


?SE -iar.dbocK 


■/er s lor. ^ . d 
2 9 Marcr. 1991 


-- R'TftS— inter rupc addresses (16#2301# .. I6#2B1"#) 

rtdeDug_pseudo_rnterrupc : CONSTANT address := 16#23014: 

?MAids_pseudo_address : CONSTANT address := 1642310#; 

R?0_Tnderfl3w_addres3 : CONSTANT 

address := 1542C00#; 

Instruct:3n_Execute_?rotection_address : CONSTANT 

address := 16#2000#; 

:nstructi3n_Li.'nit_?rotection_address : CONSTANT 

address := 1542E00#; 

?recisely_Ti.ted_Interrupcs_address : CONSTANT 

address := 1542rQ0#; 


cnce_cnly_pti : CONSTANT duration := 0.0; 

— Used CO indicate that a ?TI is not to be periodic. 
SU3TYPE pci_address IS address RANGE 15#2F01#..1542E1E4; 
TYPE pti_scate IS (active,inactive,unregistered); 


IOC_11legal_CAR_Ins cruet ion 
IOC_Memory_?rocection 
IOC_C.bannel_r unct ion_Er ror 
IOC_Iliegal_Cbain_Instruction 
IOC_Confidence_Test_Eauit 
IOC_3rea<poinc_Matc.b 
IOC_CP_Interrupc 
IOC_External_Inter rupc_Monitor 
IOC_Externai_r unct ion_.Monitor 
IOC_Oucput_Data_.Moni tor 
IOC_Input Data_Monitor 


CONSTANT address 

= 1543 COO# 

CONSTANT address 

= 15#2*00# 

CONSTANT address 

= 16433004 

CONSTANT address 

= 16434004 

CONSTANT address 

= 16423004 

CONSTANT address 

= 16439004 

CONSTANT address 

= 16433004 

CONSTANT address 

= 1643C00# 

CONSTANT address 

= 1642000 * 

CONSTANT address 

= 1643E004 

CONSTANT address 

= 1643F004 


SUBTYPE IO_interrupts IS address RANGE 

IOC_Illegal_CAR_Instruction..IOC_Input_Data_Monitor; 
SUBTYPE channel numbers IS INTEGER RANGE 0..63; 


— The Collowing exceptions are provided as a "convention" 

— whereby the Ada program can be compiled with all implicit 

— checks suppressed (i.e. pragma SUPPRESS or equivalent), 

— explicit checks included as necessary, the appropriate 

— exception raised when required, and then the exception is 

— either handled or the Ada program terminates. 


ACCESS_CHECK 

DISCRIMINANT_CHECK 

INDEX_CHECK 

LENGTH_CHECK 

RANGE_CHECK 

OIVISION_CHECK 

OVERFLOW_CHECK 

ELABORATION_CHECK 

STORAGE CHECK 


EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 


r - ^ 0 


F.4.2 Package SYSTEM 









Ada/L ?SE Har.dbcc< 


Version 3.5 
29 Marcn 19S1 


-- imoiem^fftation-defined exceptions. 

■JNRZS6lVED_R£?ERZNCE : EXCEPTION; 

SY3TEM_ERROR : EXCEPTION; 

CAPAC:TY_ERR0R : EXCEPTION; 

-- The exception CAPACITY_ERROR is raised oy the RTExec wner. 
-- Pre-Rur.Ti.te specified resource limits are exceeded. 

EYNCTION ADDRESS_OF 

-- returns the system.address of the given Class III 
-- interrupt for the specified channel 
(interrupt : IN IO_incerrupcs; 

for_channel : IN channei_numbers 
) RETURN address; 

-- The address to be used in the 
-- representation (address) clause. 

PRAG.MA INTERFACE (MACRO NORMAL, ADDRESS OF); 


FUNCTION "AND” 

— returns the logical 32 bit 'AND* between two integers. 
(operand_a ; IN integer; 

operand_b ; IN integer 
) RETURN integer; 

PRAG.MA INTERFACE (.MACRO_NO.RMAL, "AND"); 

FUNCTION "NOT” 

— returns fe logical 32 bit 'NOT' of an integer. 
(operand_a : IN integer 

) RETURN integer; 

PRAGMA INTERFACE (.MACRO_NORMAL, "NOT"); 

FUNCTION "OR" 

— returns the logical 32 bit 'OR' between two integers. 
(operand_a ; IN integer; 

operand_b : IN integer 
) RETURN integer; 

PRAGMA INTERFACE (MACRO NORMAL, "OR"); 


F-15 


F.4.2 Package SYSTEM 





Ada/L ?SE HandbcGK 


Versicp. 2 . 
29 March 199 


F.5 Set 

Ada compilations may be expressed using the following 
characters in addition to the basic character set: 

lower case letters: 

abcdefghijklmnopqrstuvwxyz 
special characters: 

!$%?§[ ] ^ ' 

The follo'’ing transliterations are permitted: 

a. Exclamation point for vertical bar, 

b. Colon for sharp, and 

c. Percent for double-quote. 




5 Character Set 








Version 3.5 
29 Marc.n 1991 


Ada/L ?SE Handbcc< 


F.6 Declaratitm- and Representation Restrictions 

Declarations are described in Section 3 of the Ada Languaqe 
Reference Manual, and representation specifications are descrroed 
in Section 13 of the Ada Language Reference Manual and discussed 
here. 


In the following specifications, the capitalized word SIZE 
indicates the number of bits used to represent an ooject of the 
type under discussion. The upper case symbols D, L, R, 
correspond to those discussed in Section 3.5.9 of the Ada 
Language Reference .Manual. 


F.6.1 Integer Types 

Integer types are specified with constraints of the form: 
.RANGE L . . R 


where: 


R <= SYSTEM..MAX_INT & L >= SYSTEM.MIN_INT 

For a prefix "t" denoting an integer type, length specifications 
of the form: 

FOR t'SIZE USE n ; 

may specify integer values n such that n in 2..64, 

R <= 2**(n-l)-l & L >= -(2**(n-l)-l) 
or else such that 

R <= (2**n)-l & L >= 0 
and 1 < n <= 31. 

For a stand-alone object of integer type, a default SIZE of 32 is 
used when: 

R <= 2**31 - 1 & L >= -(2**31 - 1) 

Otherwise, a SIZE of 64 is used. 

For components of integer types within packed composite 
objects, the smaller of the default stand-alone SIZE and the SIZE 
from a length specification is used. 


F-18 


F.6.1 Integer Types 



Ada/L PSE Handbook 


Version 2.5 
29 .'^arcn 1991 


F.6.2 Ei«*ting Types 

Floating types are specified with constraints of the form: 
DIGITS D 

where D is an integer in the range 1 through 15. 

For a prefix "t" denoting a floating point type, length 
specifications of the form: 

FOR t’SIZE USE n; 

are permitted only when the integer value n = 32 for D <= 5 or M 
= 64 for 7 <= D <= 15. 

F.6.3 Fixed Types 

Fixed types are specified with constraints of the form: 

DELTA D RANGE L..R 

where: 


MAX (ABS(R), ABS{L)) 

- < = 

actual delta 


2**31 


1 . 


The actual delta defaults to the largest integral power of 2 less 
than or equal to the specified delta D. (This implies that fixed 
values are stored right-aligned.) 


For fixed point types, length specifications of the form: 
for T'SIZE use N; 

are permitted only when N in 1 .. 32, if: 

R - actual_delta <= 2**(N-1)-1 * actual delta, and 
L + actual_delta >= -2**(n-l) * actual)3elta 

or 


R - actual_delta <= 2**(N)-1 * actual_delta, and 
L >= 0 


F.6.3 Fixed Types 


F-19 







Version 3.5 
29 March 1991 


Ada/L PSE Handbook 


For stand-al'orTff'objects of fixed point type, a default size of 32 
is used. For components of fixed point types within packed 
composite objects, the size from the length specification will be 
used. 

For specifications of the form: 

FOR t'SMALL USE n; 

are permitted for any value of X, such that X <= D. X must be 
specified either as a base 2 value or as a base 10 value. Mete 
that when X is specified as other than a power of 2, actual_delta 
will still be the largest integreal power of two less than X. 


F.6.4 Enumeration Types 

In the absence of a representation specification for an 
enumeration type "t,” the internal representation of t'FIRST is 
0. The default size for a stand-alone object of enumeration type 
"t" is 32, so the internal representations of t’FIRST and t'LAST 
both fall within the range: 

-(2**31 - 1) .. 2**31 - 1. 

For enumeration types, length specifications of the form: 

FOR t’SIZE USE n; 

and/or enumeration representations of the form: 

FOR t USE <aggregate>; 

are permitted for n in 2..32, provided the representations 
and the SIZE conform to the relationship specified above. 

Or else for n in 1..32, is supported for enumeration 
types and provides an internal representation of; 

t'FIRST >= 0 .. t'LAST <= 2**(t'SIZE) - 1. 

For components of enumeration types within packed composite 
objects, the smaller of the default stand-alone SIZE or the SIZE 
from a length specification is used. 

Enumeration representations for types derived from the 
predefined type STANDARD.BOOLEAN will not be accepted, but length 
specifications will be accepted. 


F-20 


F.6.4 Enumeration Types 






Ada/L PSE Handbook 


Version j.5 
29 March 1991 


?.6.5 Aeoefis Types 

For access type, "t,” length specifications of the forti: 

FOR t'SIZE USE n; 

will not affect the runtime implementation of "t," therefore n = 
32 is the only value permitted for SIZE, which is the value 
returned by the attribute. 

For collection size specifications of the form: 

FOR t'STORAGE_SIZE USE n; 

for any value of "n” is permitted for STORAGE_SIZE (and tnat 
value will be returned by the attribute call). The collection 
size specification will affect the implementation of "t" and its 
collection at runtime by limiting the number of objects for type 
"t" that can be allocated. 

The value of t'STORAGE_SIZE for an access type "t" specifies 
the maximum number of storage_units used for all objects in tne 
collection for type "t,” This includes all space used by the 
allocated objects, plus any additional storage required to 
maintain the collection. 


F.6.6 Arrays and Records 

For arrays and records, a length specification of the form: 

FOR t'size USE n; 

may cause arrays and records to be packed, if required, to 
accommodate the length specification. If the size specified is 
not large enough to contain any value of the type, a diagnostic 
message of severity ERROR is generated. 

The PACK pragma may be used to minimize wasted space between 
components of arrays and records. The pragma causes the type 
representation to be chosen such that the storage space 
requirements are minimized at the possible expense of data access 
ti.me and code space. 

A record type representation specification may be used to 
describe the allocation of components in a record. Bits are 
numbered 0..il from the right. Bit 32 starts at the right of the 
next higher numbered word. Each location specification must 
allow at least n bits of range, where n is large enough to hold 
any value of the subtype of the component being allocated. 
Otherwise, a diagnostic message of severity ERROR is generated. 
Components that are arrays, records, tasks, or access variables 
may not be allocated to specified locations. If a specification 


F.6.6 Arrays and Records 


F-21 



Version 3.5 
29 March L991 


Ada/L PSE HandbccK 


of this form^^T^entered, a diagnostic message of severity ERROR 
is generated. 

For records, an alignment clause of the form: 

AT MOD n 

specify alignments of 1 word (word alignment) or 2 words 
(doubleword alignment). 

If it is determinable at compile time that the SIZE of a 
record or array type or subtype is outside the range of 
STANDARD.INTEGER, a diagnostic of severity WARNING is generated. 
Declaration of such a type or subtype would raise NUMERIC_ERROR 
when elaborated. 


F.6.7 Other Length Specifications 

Length Specifications are described in Section 13.2 of the 
Ada Language Reference Manual. 

A length specification for a task type "t," of the form: 

FOR t'STORAG£_SIZE USE n; 

specifies the number of SYSTEM.STORAGE_UNITS that are allocated 
for the execution of each task object of type "t." This includes 
the runtime stack for the task object but does not include 
objects allocated at runtime by the task object. If a 
t'STORAGE_SIZE is not specified for a task type "t," the default 
value is 2K (words). 

A length specification for a task type "t" of the form; 

FOR t'SIZE USE n; 
is allowable only for n = 32. 


F-22 


F.6.7 Other Length Specifications 



Ada/L PSE Handbook 


Version 3.5 
29 Marc.b 1991 


P.7 Syaie»-Generated Names 

Pefer to Section 13.7 of the Ada Language Reference Manual 
ana cne section above on the Predefined Language Environment for 
a discussion of package SYSTEM. 

The system name is chosen based on the target(s) supported, 
but it cannot be changed. In the case of Ada/L, the system, na.me 
is ANUYK43. 


F.3 Address Clauses 

.Refer to Section 13.5 of the Ada Language Reference Manual 
for a description of address clauses. All rules and restrictions 
described there apply. In addition, the following restrictions 
apply. 

An address clause may designate a single task entry. Such an 
address clause is allowed only within a task specification 
compiled with the EXECUTIVE compiler option. The meaningful 
values of the simple__expression are the allowable interrupt entry 
addresses as defined in Table F-1. The use of other values will 
result in the raising of a PROGRAM_ERROR exception upon creation 
of the task. 

If more than one task entry is equated to the same interrupt 
entry address, the most recently executed interrupt entry 
registration permanently overrides any previous registrations. 

At most one address clause is allowed for a single task 
entry. Specification of more than one interrupt address for a 
task entry is erroneous. 

Address clauses for objects and code other than task entries 
are allowed by the Ada/L target, but they have no effect beyond 
changing the value returned by the 'ADDRESS attribute call. 


F.8 Address Clauses 


F-23 




Version 3.5 
29 March 1991 


Ada/L PSE HandbooK 


AN/UYK-43(V) Interrupt 

Summary 

1 


ISC 

Inter rupc 


Target-Computer Interrupt 

CODE 

Entry Address 

Registration 

CLASS 

0 



Class I Unhandled Interrupt 

None 

16#0800» 


CLASS 

I 



Class II Unhandled Interrupt 

None 

i6#iaoo# 


C?-Operand Memory Resume 

16#0# 

16#1000# 


CP-IOC Command Resume 

I6#l# 

16#1100# 

; 

CP-Instruction Memory Resume 

i6#2# 

16#1200# 


CP-IOC Interrupt Code Resume 

i6#3# 

16#1300# 

i 

C?-Operand Memory Error 

16#4# 

16#1400# 

1 

i 

CP-Instruction Memory Error 

I6#5# 

16#1500# 


CP-IOC Command/Operand Error 

i6#6# 

16#1600# 


IOC Memory Error 

16#7# 

16#1700# 

1 

I?I Fault 

16#9# 

16#1900# 

i 

IOC Memory Resume 

16#A# 

16#1A00# 


Intercomputer Timeout 

16#B# 

16#1B00» 


C? Confidence Test Fault 

16#C# 

16#1C00# 

1 

CPU/IOC Microprocessor Stop 

i6#D# 

16#1D00# 

i 

Module Interrupt 

16#E# 

16#1E00# 


Power Tolerance 

16#F# 

16#1F00# 


CLASS 

II 


i 

Class III Unhandled Interrupt 

None 

16#2800# 


Interprocessor Interrupt 

16#0# 

16#2000# 

UNDEFINABLE 

Floating Point Error 

16#1# 

16#2100# 

UNDEFINABLE 

Illegal Instruction 

16#2# 

1612200# 


Privileged Instruction Error 

16#3# 

16#2300# 


Data Pattern Breakpoint 

16#4# 

16#2400# 


Operand Address Breakpoint 

16#5# 

16#2500# 


Operand Read or 




Indirect Addressing 

16#6# 

16#2600« 


DCU Status Interrupt 

16#7# 

16#2700# 


Operand Write 

16#9# 

16#2900# 

1 

Operand Limit 

I6#A# 

16#2A00# 


Instruction Address Breakpoint 

16#B# 

16#2B00# 


RPD Underflow 

16#C# 

16#2C00# 


Instruction Execute 

16#D# 

16#2D00# 


Instruction Limit 

16#E# 

16#2E00# 


Monitor Clock 

16#F# 

16#2F00# 

UNDEFINABLE 

PTI 

None 

16#2F01# .. 

16#2F1F# i 


Table F-la - Interrupt Entry Addresses 


F-24 


F.8 Address Clauses 















Ada/L PSE Handbook 


Version 3.5 
29 March 1991 


AN/UYK-43(V) Interrupt Summary 


ISC Interrupt 

Target-Compucer Interrupt CODE Entry Address Registrar ion 


CLASS III 


IOC Illegal CAR Instruction 16#0# 16#30I0# t 

IOC Memory Protection 16#1# 16#31IC# 

If the above interrupt is generated during CAR execution, no 
channel number is available. The interrupt will be j 

translated to Class II Unhandled. 

UNDEFINED 16#2# 16#3200# UNDEFINA3LE | 

Channel Function Error 16#3# io#33IC# 

IOC Illegal Chain Instruction 16#4#.. 16#34IC# ! 

16 #7# 

IOC Confidence Test Fault 16#8# 16#38IC# 

j 

If the above interrupt is generated during CAR execution, no | 
channel number is available. The interrupt will be 
translated to Class II Unhandled. 

IOC Breakpoint Match 16#9# 16#39IC# ! 

If the above interrupt is generated during CAR execution, no 
channel number is available. The interrupt will be j 

translated to Class II Unhandled. j 

IOC .Monitor Clock 16#A# 16#3AI0# UNDEFINABLE 

IOC Processor Interrupt 16#B# 16#3BIC# 

External Interrupt Monitor 16#C# 16#3CIC# 

External Function Monitor 16#D# 16#3DIC# 

Output Data Monitor 16#E# 16#3EIC# 

Input Data Monitor 16#F# 16#3FIC# 

For class III interrupts, the following interpretations apply: 

IC => IOC, channel number where 

16#00#..16#1F# indicates IOC 0, channel 16#00..16#1F#, 
16#20#..16#3F# indicates IOC 1, channel 16#00..16#1F# 


Table F-lb - Interrupt Entry Addresses (Continued) 


F.8 Address Clauses 


F-25 










Version 3.5 
29 March 1991 


Ada/L PSE Har.dbocK 


F.9 Dnchecked. Conversions 

Refer to Section 13.10.2 of the Ada Language Reference Manual 
iIoL a uescij-pcion of LL'iCH£CK£u_CONVc,RSIuN. it is erroneous if 
your Ada program performs UNCHECKED_CONVERSION when the source 
and target objects nave different sizes. 


F.IO Restrictions on the Main Subprogram 

Refer to Section 10.1 (8) of the Ada Language Reference 
Manual for a description of the main subprogra.m. The sutpiogram 
designated as the main subprogram cannot have parameters. The 
designation as the main subprogram of a subprogram whose 
specification contains a formal_part results in a diagnostic of 
severity ERROR at link time. 

The main subprogram can be o function, but the return value 
will not be available upon completion of the main subprogram's 
execution. The main subprogram may not be an import unit. 


F-26 


F.IO 


Restrictions on the Main^ Subprogram 






Ada/L PSE Handbook 


Version 3.5 
29 March 1991 


P.ll InEui/^utput 

Refer to Section 14 of the Ada Language Reference Manual for 
a discussion of Ada Ir.pu-/Output and to Section 12 of the Ada/L 
Run Time Environment Handbook for more specifics on the Ada/L 
Input/Output subsystem. 

The Ada/L Input/Output subsystem provides the following 
packages: TEXT_IO, SEQUENTIAL_rO, DIRECT_IO, and L0W_LE7EL_:0. 
These packages execute in the context of the user-written Ada 
program tasx making the I/O request. Consequently, all of the 
code that processes an I/O request on behalf of the user-written 
Ada program executes sequentially. The package IO_EXCE?TIONS 
defines ail of the exceptions needed by the packages 
SEQUENTIAL_IO, □IRECT_IO, and TEXT_IO. The specification of this 
package is given in Section 14.5 of the Ada Language Reference 
.Manual. This package is visible to all of the constituent 
packages of the Ada/L I/O subsystem so that appropriate exception 
handlers can be inserted. 

I/O in Ada/L is performed solely on external files. No 
allowance is provided in cho I/O subsystem for memory resident 
files (i.e., files which do not reside on a peripheral device). 
This is true even in the case of temporary files. With the 
external files residing on the peripheral devices, Aaa/L .makes 
the further restriction on the number of files that may be onen 
on an individual peripheral device. 

Section 14.1 of the Ada Language Reference Manual states that 
all I/O operations are expressed as operations on objects of some 
file type, rather than in terms of an external file. File 
objects are implemented in Ada/L as access objects which point to 
a data structure called the File Control Block. This File 
Control Block is defined internally to each of the high-level I/O 
packages; its purpose is to represent an external file. The File 
Control Block contains all of the I/O-specific information abour 
an external file needed by the high-level I/O packages to 
accomplish requested I/O operations. 


F.11.1 Naming External Files 

The naming conventions for external files in Ada/L are of 
particular importance to you. All of the system-dependent 
information needed by the I/O subsystem about an external file is 
contained in the file name. External files may be named using 
one of three file naming conventions: standard, temporary, and 
user-derived. 


F.11.1 Naming External Files 


F-27 




Version 3.5 
29 Marc.n 1991 


Ada/L PSE Haadbeck 


P.Il.l.I Staoda^Cd File Names 

The standard external file naming convention used in Ada/L 
identifies the specific location of the external file in terms cf 
the physical device on which it is stored. For this reason, you 
should be aware of the configuration of the peripheral devices on 
the AN/lIYK- 43 at your particular site. 


Standard file names consist of a six character prefix and a 
file name of up to twenty characters. The six character prefix 
has a predefined format. The first and second characters must be 
either "DK," "MT," or '’tt,” designating an AN/UYH-3(V) 
Hecorder/Reproducer Set Magnetic Disk, the RD-353 Magnetic Tape 
Subsystem, or the AN/USQ-69 Data Terminal Set, respectively. 

The third and fourth characters specify the channel on which 
the peripheral device is connected. Since there are sixty-four 
channels on the AN/UYK-43, the values for the third and fourth 
positions must lie in the range "00" to "63." 


The range of values for the fifth position in the prefix (the 
unit number) depends upon the device specified by the characters 
in the first and second positions of the external file name. If 
the specified peripheral device is the AN/UYH-3 magnetic disk 
drive, the character in the fifth position must be one of th> 
characrers "0," "1," "2," or "3." This value determines which of 
the four disk units avaiiaule on the .AN/UYH-3 is to be accessed. 
If the specified peripheral device is the RD-358 magnetic tape 
drive, the character in the fifth position must be one of the 
characters "0," "1," "2," or "3." This value determines which of 


the four tape units available on the RD-358 is to be accessed. 

If the specified peripheral device is the AN/USQ-69 militarized 
display terminal, the character in the fifth position depends on 
the channel type. If the channel type is parallel then this 
character must be a "0." This is the only allowable value for 
the unit number when the AN/USQ-69 is connected to a parallel I/O 
channel. This is because the AN/USQ-69 may have only one unit on 
a parallel channel. If the channel type is serial then the 
character in the fifth position must be one of the characters 


"0," "I," "2," "3," "4," "5," "6," "7," or "8" (the character 


will be used to specify a broadcast mode transmission). The 


AN/USQ-69 allows up to eight terminals to be daisy chained 


together when running on a serial channel. 


The colon (":") is the only character allowed in the sixth 
position. If any character other than the colon is in this 
position, the file name will be considered non-standard and the 
file will reside on the default device defined during the 
elaboration of CONFIGURE 10. 


Positions seven through twenty-six are optional to your Ada 
program and may be used as desired. These positions may contain 
any printable character you choose in order to make the file name 


F-28 


F.11.1.1 Standard File Names 




Ada/L ?SE Handboc.< 


Vers :.cn 3.5 
29 Marcn 1991 


more int^J^igible. Embedded blanks, .nowever, are not allowed. 

T'-e location of an external file on a peripheral device is 
thus a function of the first six characters of the file name 
regardless of the characters that .might follow. For example, if 
the external file ".MTOOO :01d_Data" has been created and not 
suDsequently closed, an attempt to create the external file 
".MTOOO: New_Data" will cause the exception DEVICE_ERROR (rat; ?r 
than NAME_ERROR or USE_ERROR) to be raised because the peripheral 
device on channel "00" and cartridge "0" is already in use. 

You are advised that any file name beginning with "xxxxx:" 
(where x denotes any printable character) is assumed to oe a 
standard external file name. If this external file nam.e does net 
conform to the Ada/L standard file naming conventions, the 
exception NAME_ERROR will be raised. 


F. 11.1.2 Temporary File Names 

Section 14.2.1 of the Ada Language Reference Manual defines a 
temporary fil<=* to be an external file that is not accessible 
after completion of the main subprogram.. If the null string is 
supplied for tne external file name, the external file is 
considered temporary. In this case, the high level I/O packages 
internally create an external file name to be used by the lower 
level I/'O packages. The internal naming scheme used by the I/O 
subsystem is a function of the type of file to be created (t3xt, 
direct or sequential) and the current date and time. This scheme 
is consistent with the requirement specified in the Ada Language 
Reference Manual that all external file names be unique. 

The first two characters of the file name are "TX," "D_," n 
"S_." The next eight characters are the date (four characters 
for the year, two characters for the month, and two characters 
for the day). The remaining ten characters are the time (five 
for seconds and five for the fraction part of a second). For 
instance, the temporary external file name "D_19880331123459876 
would be a DIRECT_IO file created March 31, 1988 at 12,345.9876 
seconds. 


F.11.1.3 Oser-Derived File Names 

A random string containing a sequence of characters of length 
one to twenty may also be used to name an external file. 

External files with names of this nature are considered to be 
permanent external files. You are cautioned from using names 
which conform to the scheme used by the I/O subsystem to name 
temporary external files (see list item "b"). 

It is not possible to associate two or more internal files 
with the same external file. The exception USE_ERROR will be 


F.11.1.3 User-Derived File Names 


F-29 


in in 



Version 3.5 
29 .Maron 1991 


Ada/L ?SE HandDOCK 


raised if _restricrion is violated. 


F. 11.2 The FOEIM Specification for External Files 

Section 14.2.1 of the .Ada Language .Reference .Manual defines a 
string argument called the FORM, wnic.h supplies system-dependent 
information chat is someti.mes required to correctly process a 
request to create or open a file. In Ada/L, the string argument 
supplied to tne FORM parameter on calls to CREATE and OPEN is 
retained while the file is open, so that calls to the function 
FORM can return the string to your Ada program. FORM options 
specified on calls to CREATE have the effects stated below. FORM 
options specified on calls to OPEN have no effect. 

•Ada/L only allows a FOR.M parameter when a file is open or 
created on the RD-358 tape drive. A USE_ERROR will be raised 
when a FOEIM parameter is associated with any other Ada/L system 
device. The FORM parameter specifically controls the positioning 
and formatting of the tape prior to tape I/'O operations. This 
section identifies the arguments of the FOEIM parameter. Refer to 
Section 14.2.1 of the .Ada Language Reference .Manual and to 
Section 12 of the Ada/L Run-Ti.me Environment Elandbook for more 
detail on the use of the FOEIM parameter. 

The FOR.M parameter is a string literal of which a maximum of 
twenty characters is processed. If the supplied FOEIM string is 
longer than tne maximu.m allowed (20 characters), the exception 
CJSE_ERROR will be raised. The striiig literal is interpreted as a 
sequence of argu.ments. If you wish to utilize the default 
arguments, a FOEIM parameter need not be supplied. 

Only the first two arguments within the string are processed. 
All following characters or arguments will cause the USE_ERROR to 
oe raised. The arguments are not case sensitive. The argu.ment3 
must be separated by at least one delimiter. A legal delimiter 
consists of a comma or blank. Extra delimiters are ignored. Of 
the recognized arguments, at most one formatting and one 
positioning argument are allowed. If conflicting arguments are 
used, the exception USE_ERROR will be raised. 

Positioning arguments allow control of tape before its use. 
The following positioning arguments are available; 

a. REWIND - specifies that a rewind will be performed prior to 
the requested operation. 

o. NOREWIND - specifies that the tape remains positioned as is. 

G. APPEND - specifies that the tape be positioned at the logical 
end of tape (LZOT) prior to the requested operation. The 
LEOT IS denoted by two consecutive tape_marks. 


The FOEIM Specification for External Files 


F-30 


F.11.2 




Ada/L ?5E HandbooK Version 3.5 

29 Marcn 1991 


The ^^niatting argument specifies information about tape 
mat. If a formatting argument is not supplied, the fi.’e is 
a su.nied to contain a format header record determined by the AL3/N 
I/O system. The following formatting arguments are available: 

a. N’CHEAO - specifies char tne designated file has no header 
record. This argument allows the reading and writing of 
tapes used on computer systems using different header 
formats. 

b. DENSITY_800 - specifies that the cape is vritten/read with a 
density of 800 B?I. This is the default density. Attempcinc 
to write/read files of different density on the same tape 
will cause unpredictable results. 

c. DEMSITY_1600 - specifies that the tape is written/read witn a 
density of 1600 BPI. Attempting to write/read files of 
different density on the same tape will cause unpredictable 
results. 


F.11.3 File Processing 

Processing allowed on Ada/L files is influenced by the 
characteristics of the underlying device. The following 
restrictions apply: 

a. Only one file may be open on an individual RD-358 tape drive 
at a time. 

b. The attempt to CREATE a file with the mode IN_FILE is not 
supported since there will be no data in the file to read. 


F.11.3 File Processing 


F-31 







Version 3.5 
29 March 199L 


Ada/L PSE Handbook 


F.11.4 Text^nput/Output 

TEXT_IO is invoked by your Ada program ro perform sequentriai 
access I/O operacions on text files (i.e., files whose content is 
in human-readable form). TEXT_ro is not a generic package and, 
thus, its subprograms may be invoked directly from your program, 
using objects wion base cype or parent type in the 
language-defined type character. TEXT_IO also provides the 
generic packages INTEGER_IO, FLOAT_IO, FIXED_IO, and 
ENUMERATION_IO for the reading and writing of numeric values and 
enumeration values. The generic packages within TEXT_IO require 
an instantiation for a given element type before any cf their 
subprograms are invoked. The specification of this package is 
given in Section 14.3.10 of the Ada Language Reference Manual. 

The implementation-defined type COUNT that appears in Section 
14.3.10 of the Ada Language Reference Manual is defined as 
follows: 

type COUNT is range 0 ... INTEGER'LAST; 

The implementation-defined subtype FIELD that appears in Section 
14.3.10 of the Ada Language Reference Manual is defined as 
follows: 


subtype FIELD is INTEGER range 0 ... INTEGER’LAST; 

At the beginning of program execution, the STANDARD_rNPUT 
file and the STANDARD_OUTPUT file are open, and associated with 
the files specified by you at export time. Additionally, if a 
program terminates before an open file is closed (except for 
STANDARD_rNPUT and STANDARD_OUTPUT), the last line you added to 
the file may be lost; if the file is on magnetic tape, the file 
structure on the tape may be inconsistent. 

A program is erroneous if concurrently executing tasks 
attempt to perform overlapping GET and/or PUT operations on the 
same terminal. The semantics of text layout as specified in the 
Ada Language Reference Manual, Section 14.3.2, (especially the 
concepts of current column number and current line) cannot be 
guaranteed when GET operations are interweaved with PUT 
operations. A program which relies on the semantics of text 
layout under those circumstances is erroneous. 

For TEXT_IO processing, the line length can be no longer than 
1022 characters. An attempt to set the line length through 
SET_LINE_LENGTH to a length greater than 1022 will result in 
USE ERROR. 


F-3 2 


F.11.4 Text Tnput/Output 




Ada/^L ?SS HandbocK 


Version 3 . 5 
29 March 1991 


F.11.5 Sequential Input/Output 

SEQUENTIAL_IO is invoked by your Ada program to perform I/O 
on the records of a file in sequential order. The SEQUENTIAL_:o 
package also requires a generic instantiation for a given elemenr 
type before any of its subprograms may be invoked. Once the 
package SEQUENTIAL_IO is made visible, it will perform any 
service defined by the subprograms declared in its specification. 
The specification of this package is given in Section 14.2.3 of 
the Ada Language Reference Manual. 

The following restrictions are imposed on the use of the 
package SEQUENTIAL_IO: 

a. SEQUENTIAL_IO cannoc be instantiated with an unconstrained 
array type. 

b. SEQUENTIAL_IO cannot be instantiated with a record tyoe wirn 
discriminants with no default values. 

c. Ada/L does not raise DATA_ERROR on a read operation if tne 
data input from the external file is not of the instantiating 
type (see the Ada Language Reference Manual, Section 14.2.2). 


F.11.6 Direct Input/Output 

DIRECT_IO is invoked by your Ada program to perform I/O of 
the records of a file in an arbitrary order. The package 
DIRECT_IO requires a generic instantiation for a given element 
type before any of its subprograms may be invoked. Once the 
package DIRECT_IO is made visible, it will perform any service 
defined by the subprograms declared in its specification. The 
specification of this package is given in Section 14.2.5 of the 
Ada Language Reference Manual. 

The following restrictions are imposed on the use of the 
package DIRECT_IO: 

a. DIRECT_IO cannot be instantiated with an unconstrained array 
type. 

b. DIRECT_IO cannot be instantiated with a record type with 
discriminants with no default values. 

c. Ada/L does not raise DATA_ERROR on a read operation if the 
data input from the external file is not of the instantiating 
type (see the Ada Language Reference Manual, Section 14.2.4). 


F.11.6 Direct Input/Output 


F-33 




Version 3.5 
29 March 1991 


Ada/'L ?SE Handbco< 


F.11.7 Low L^el Input/Output 

10W_LEVEL_I0 is invoked by your Ada program to initiate 
physical operations on peripheral devices, and thus executes as 
part of a program task. Requests made to LOW_LEVEL_IO from your 
program are passed through the RTEXEC_GATEWAy co the channel 
programs in CHANNEL_IO. Any status check or result information 
is the responsibility of the invoking subprogram and can be 
ODtained from the subprogram RECEI7E_C0NTR0L within LOW_LEVEL_IO. 

The package LOW_LEVEL_IO allows your Ada program to send I/'O 
commands to the I/O devices (using SEND_C0 NTr6l) and to receive 
status information from the I/O devices (using RECEIVE_CONTROL). 

A program is erroneous if it uses LOW LEVEL_IO to access a device 
that is also accessed by high-level l/O packages such as 
SEQUENTIAL_IO and TEXT_IO. The following is excerpted from the 
pacxage LOW_LEVEL_IO. 

SUBTYPE channel_range IS INTEGER RANGE 0..53; 

— Range of values allowed for channel number. 

SUBTYPE device_str IS STRING; 

-- To be passed to CI-1ANNEL_I0 for future implementations 

— of logical path name. The string will be ignored until 

— logical path name support is added. 

SUBTYPE btc_int IS INTEGER RANGE 0..16383; 

— Passes transfer counts to/from IO_MANAGEMENT/RTEXEC. 

SUBTYPE io_functions IS INTEGER RANGE 0..20; 

— Specifies the I/O function to be performed by LOW_LEVEL_IO. 

— The followinn table shows the values associated with device 

— and device functions available. 


F-3 4 


F.11.7 Low Level Input/Output 




Ada/L ?SE Handbook 


Version 3.5 
29 March 1991 


— VALQEr-^ DEVICE — FUNCTION 


0 RD-358 Normal Read 

1 RD-358 Read with Search data 

2 RD-358 Normal Write 

3 RD-358 Send EF Command 

4 RD-358 Initialize Channel 

0 UYH-3 Read with 2 word EF 

1 UYH-3 Read with 1 word EF 

2 UYH-3 Write 

3 UYH-3 Send 1 word EF Command 

4 UYH-3 Send 2 word EF Command 

5 UYH-3 Send 1 word EF Command (Same as function 3) 

6 UYH-3 Initialize Channel 

0 USQ-69 Rea^ 

1 USQ-69 Write 

2 USQ-69 Write (Same as function 1) 

3 USQ-69 Send Command 

4 USQ-69 Initialize Channel 


TYPE cap_blcck IS 

— Information that can be found in IOC control memory on 
— a per channel/ per function basis. 


RECORD 

cap : INTEGER 

instruct_base ; INTEGER 
index : INTEGER 

accumulator : INTEGER 
status : INTEGER 

buffer_ba3e : INTEGER 
bcw ; INTEGER 

ODerand_ba3e : INTEGER 
END RECORD; 


— CAP register. 

— CAP instruction base. 

— CAP index register. 

— CAP accumulator register. 

— CAP status register. 

— CAP buffer base. 

— CAP buffer control word. 

— CAP operand base. 


TYPE short_rec_control_block IS 

— I/O control block sent to LOW_LEVEL_IO as a parameter 
— when calling subprogram RECEIVE_REQUEST. 

RECORD 

channel : low_level_io.channel_range; 

— Specifies channel of interest, 
ei word ; INTEGER; 


— External interrupt returned by the peripheral device. 
END RECORD; 


F.il.7 Low Level Input/Output 


F-35 









Version 3.5 
29 March 1991 


Ada/L PSE Handboort 


TYPE receive_^a£rol_block IS 

— I/O control block sent to LOW_L£VEL_IO as a parameter 

— when calling subprogram RECEIVE_REQUEST. 

RECORD 

daca : low_level_io.short_rec_control_block; 

— Channel and ei_word. 
ef : Iow_level__io.cap_block; 

— External Function CAP information, 
output : low_level_io.cap_block; 

— Output CAP information, 
ei : low_level_io.cap_block; 

— External Interrupt CAP information, 
input : low_Ievel_io.cap_block; 

— Inout CAP information. 

END RECORD;' 

TYPE send_control_block IS 

— I/O control block sent to LOW_LEVEL_IO as a parameter 

— when calling subprogram SEND_REQUEST. 

RECORD 

function_pos : low_level_io.io_functions; 

— Indicates which I/O function is to be requested 

— of LOW_LF.VEL_IO. 

channel : low_level_io.channel_range; 

— Specifies channel number, 
transfer_count : low_level_io.btc int; 

— Suffer transfer count for l/O operation. 
buffer_addr ; system.address; 

— Address of data buffer. 

command_l : INTEGER; 

— Holds the first word of the external 

— function for the device. 

command_2 ; INTEGER; 

— Holds the second word of the external 

— function for the device. 

filler_l ; INTEGER; 

— Passes additional information to 
— CHANNEL__IO (such as the terrainal_address 

— for the~'USQ-69 device). 

END RECORD; 


F-36 


F.11.7 Low Level Lnput/Output 




Ada/L PSE Handbook 


Version 3.5 
29 March 1991 


PROCEOeRE SEND_CONTROL 

— Passes I/O control information to a procedure in 

— IO_MANAGEMENT/RTEXEC in order to send data to the 

— specified device. 

(device : IN low_level_io.device_str := 

— This string will be ignored until 
— logical path names are implemented, 
data : IN low_level_io.send_control_block 

— I/O control block for send request. 

) ; 


PROCEDURE RECEIVE_CONTROL 

— Passes I/O control information to a procedure in 

— IO_MANAGEMENT/RTEXEC in order to obtain the status of 

— the I/O operation. 

(device : IN low_level_io.device_str := ""; 

— This string will be ignored until 
— logical path names are implemented, 
data : IN OUT low_level_io.receive_control_block 
— I/O control block for receive request. 

) ; 


PROCEDURE R£CEIVE_CONTROL 

— Passes I/O control information to a procedure in 

— IO_MANAGEMENT/RTEXEC in order to obtain the status of 

— the I/O operation. 

(device : IN low_level io.device_str ;= 

— This string will be ignored until 
— logical path names are implemented, 
data : IN OUT low_level_io.short_rec control_block 
— I/O control block for receive request. 

); 


F.12 System Defined Exceptions 

In addition to the exceptions defined in the Ada Language 
Reference Manual, this implementation pre-defines the exceptions 
shown in Table F-2 below. 


F.12 System Defined Exceptions 


F-37 



Version 3.5 
29 March 1991 


Ada/L PSE Handbook 


Marne 


Significance 


CAPAC:Ty_ERROR 

?AST_?TI_TIME 

SYSTEM_ERROR 

aNREGrSTERED_PTI 

UNRESOLVED REFERENCE 


Raised by the Run-Time Executive wr,er. 
Pre-Runtime specified resource limits 
are exceeded. 

Raised by the PTI support package if 
the PTI start time is greater than the 
current CALENDAR.CLOCK. 

Serious error detected in underlying 
AN/UYK-43 operating system. 

Raised by the PTI support package if 
the PTI's state is returned as 
"unregistered”. 

Attempted call to a subprogram whose 
body is not linked into the executaole 
program image. 


Table F-2 - System Defined Exceptions 


F-38 


F.12 System Defined Exceptions 









Ada/L PSE Handbootc 


Version 3.5 
29 March L991 


F.13 M^hine Code Insertions 

The Ada language permits machine code insertions as defined 
in Section 13.8 of the Ada Language Reference Manual. This 
section describes the specific derails for writing machine code 
insertions as provided by the predefined package MACHINE_CODE. 

You may, if desired, include AN/UYK-43 instructions within an 
Ada program. This is done by including a procedure in the 
program which contains only record aggregates defining machine 
instructions. The package MACHINE_CODE, included in t.he system 
program library, contains type, record, and constant declarations 
which are used to form the instructions. Each field of the 
aggregate contains a field of the resulting machine instruction. 
These fields are specified in the order in which they appear in 
the actual instruction. Since the AN/UYK-43 has several 
different formats for instructions, package MACHINE_CODE defines 
different types for each of these formats. For each of the 
fields which must have a certain value for a given instruction 
(i.e., part of the opcode), package MACHINE_CODE defines a 
constant to use for that field. 

The following procedure implements a floating point 
exponential. Note that this actual procedure would not be used, 
because package MATH_PACK implements the same operation in a more 
efficient manner. 

with machine_code; use machine_code; 
procedure floating_point_exponential 
(X : FLOAT; 
ex : OUT FLOAT) is 


BEGIN 

formatI'(£ LA,1,3,6,0,0,0); 

— LA Al,B6+0 

formatV(f FEX,l,f2_FEX,2,0,0,0,f6_FEX); 

— FEX A1,A2 

formatl'{f=>f_SA,a=>2,k=>3,b=>6,i=>0,3=>0,y=>l); 

— SA A2,B6+1 

END; 

Note that either positional or names aggregates may be used. 
Whenever a field does not appear in the MACRO/L instruction, it 
must be filled in with 0, since no missing fields are allowed. 

For formatl instructions, when k=0, the s and y field are 
collapsed and used together. For your convenience, an additional 
record type, formatli, for immediate, can be used to define t.he s 
and y fields as a single 16-bit quantity. This quantity is 
defined as an unsigned integer, so if a negative number x is 
desired, one should instead put the number x + 65535. 


F.13 Machine Code Insertions 


F-39 




Version 3.5 
29 March 1991 


Ada/L PSE Handbook 


Table F-i^^ntains a list of MACRO/L instructions and their 
Ada/L machine code equivalents, sorted by MACRO/L mnemonic. 


F-40 


F.13 Machine Code Insertions 







Ada/L PSE Handbook 


Versicp. 3.5 
29 Marc.b 1991 


i .MACRO/L 

Ada/L i 

j AA 

a,y,)<,b,s 

formatI’(f AA,a,k,b,i,s,y); 

AS 

a,y,k,b,s 

formatI'(f A3,a,k,b,i,s,y); j 

! AEI 

a, sy, b 

formatIi'(A AEI,a,k AEI,b,i,3y); i 

i .ALP 

a,y,b,3 

formatI'(f ALP,a,k ALP,b,i,3,y); i 

1 ANA 

a, y, , b, s 

formatI’(f ANA,a,k,b,i,s,y); 

ANB 

a,y,k,b,s 

formatI'(f ANB,a,k,b,i,s,y); 

ATSF 

a, b 

£ormatV'(f ATSF,a,f2 ATSF,b,0,0,0,f6 ATSF); 

3C 

ai<,y,b,s 

forrnatIa'(f BC, a, k , b, i , s , y) ; 

3S 

ak,y,b,s 

formatIa'{f 3S,a,k,b,i,s,y); 

3Z 

ak,y,b,s 

formatIa'(f BZ,a,k,b,i,3,y); 

C 

a,y,k,b,3 

formatI’(f C,a,k,b,i,s,y); 

CB 


formatlVA’ie CB,a CB,0,i CB ); 

CBN 

a,n 

formative(f CBN,a,f4 CBN,n); 

CBR 

a, b 

formatV'(£ C3R,a,f2 CBR,b,0,0,0,f6 CBR ); ! 

CCT 

a, b 

formatIVA*(f CCT,a,b,i CCT); ! 

CE 


formatIVA‘(e CE,a CE,0,i CE ); 

CG 

a,y,k,b,s 

formatI’(f CG,a,k,b,i,s,y); 1 

1 CHCL 

a, y, b, 3 

formatI'(f CHCL,a,k CHCL,b,i CHCL,s,y); | 

1 W 

a, y, A , Li , 3 

fcrmatl'(f CL,a,k,b,i,s,y); 

CM 

a, y, k , b, 3 

formatI'(f CM,a,k,b,i,s,y); j 

CMPS 

a,b 

formatV'(f CMPS,a,f2 CMPS,b,0,0,0,f6 CMPS ); , 

CNT 

a,y,b,s 

£ormatI’(f CNT,a,k CNT,b,i,3,y); " ! 

CRB 

a, b 

formatV’(f CRB,a,f2 CRB,b,0,0,0,f6 CRB ); j 

CXI 

a,y,k,b,s 

formatI'(f CXI,a,k,b,i,s,y); ! 

D 

a,y,k,b,s 

formatI'(f D,a,k,b,i,s,y); 

DA 

a,y,b,s 

formatI'(f DA,a,k DA,b,i,s,y); i 

DAN 

a,y,b,3 

formatI'(f DAN,a,k DAN,b,i,3,y); 1 

DC 

a,y,b,s 

formatI'(f DC,a,k DC,b,i,3,y); 

DJNZ 

a,y,k,b,s 

formatIII'(£ DJNZ,a,f3 DJNZ,k,b,i,s,y); 

DJZ 

a,y,k,b,3 

formatIII'(f DJZ,a,f3 DJZ,k,b,i,s,y); 

DL 

a,y,b,s 

formatI'(f DL,a,k DL,b,i,3,y); 

DS 

a,y,b,s 

formatI’{f DS,a,k DS,b,i,3,y); 

DSP 

3 f 0 f m 

eormatV'{f DSP,a,F2 DSP,b,0,0,m,f6 DSP ); 

EECM 


formatIVAMf EECM,a EECM,0,i EECM ); 

ESCM 


formatIVA'(f ESCM,a ESCM,0,i ESCM ); 

ETCM 


formatlVA’ce ETCM,a ETCM,0,i ETCM ); 

FA 

a,y,b,3 

formatI'(f FA,a,k FA,b,i,s,y); 

FAC 

a,b 

formatV'(f FAC,a,l2 FAC,b,0,0,0,f6 FAC ); 

FAN 

a,y,b,3 

formatI'(f FAN,a,k FAN,b,i,s,y); 

FANR 

a,y,b, 3 

formatI'(f FANR,a,k FANR,b,i,s,y); i 

FAR 

a,y,b,s 

formatI’(f FAR,a,k FAR,b,i,s,y); j 

FAS 

a,b 

formatV'(f FAS,a,f2 FAS,b,0,0,0,f6 FAS ); 

FAT 

a, b 

formatV'ce FAT,a,f2 FAT,b,0,0,0,f6 FAT ); | 

FD 

a,y,b,s 

formatI’(f FD,a,k FD,b,i,s,y); i 

FDR 

a,y,b,3 

formatI'{£_FDR,a,k_FDR,b,i,s,y); 1 


Table F-3a - Machine Code Tnstmctions 


F.13 Machine Code Insertions 


F-41 








Version 3.5 
29 March 1991 


Ada/L PSE HandbooK 


I MACRO/L Ada/L 


FEX 

a, b 


formatV’(f FEX,a,f2 FEX,b,0,0,0,f6 FEX ); 

FLN 

a, b 


formatV'(f FLN,a,f2 FLN,b,0,0,0,f6 FLN ); 

FLTF 

a, n 


£ormacV{f FLTF,a,f2 FLTF, n, 0,0,0 , f 6 FLTF); 

FM 

a,y, 

b,s 

formatlMt FM,a,k FM,b, i,s,y) ; 

FMR 

a,y, 

b, s 

formatI'(f FMR,a,k FMR,b,i,s,y); 

FPA 

a, b 


eormatV'(f F?A,a,f2 FPA,b,0,0,0,f6 FPA); 

FPD 

a,b 


formatVMf FPD,a,£2 FPD, b, 0,0,0 , f 6 FPD); 

FPM 

a,b 


eormatV{f FPM,a,f2 FPM, b , 0,0,0 , f 6 FPM ); 

FPS 

a, b 


formatV'ff FPS,a,f2 FPS,b,0,0,0,f6 FPS ); 

FSA 

a, b 


formatV'Cf FSA,a,f2 FSA,b,0,0,0,f6 FSA); 

FSC 

a,b 


farmatV'(f FSC,a,f2 FSC,b,0,0,0,f6 FSC ); 

FSD 

a, b 


formatV(f FSD,a,f2 FSD,b, 0,0,0 , f 6 FSD); 

FSM 

a,b 


formatV'(f FSM,a,f2 FSM,b,0,0,0,f6 FSM); 

FSS 

a, b 


formatV'(f FSS,a,f2 FSS,b,0,0,0,f6 FSS); 

FTSL 

a, b 


formatVff FTSL,a,f2 FTSL, b, 0,0,0 , f 6 FTSL); 

HA 

a, b 


formatlVA*(f HA,a,b,0); 

HAEI 

a, b 


formatIVA'(f HAEI,a,b,i HAEI ); 

HAI 



fcrnacIVA’{f HAI,0,0,0); 

HALT 



formatIVA'(f HALT,0,0,i HALT ); 

HAN 

cr 


formatIVA'tf HAN,a,b,0); 

HAND 

a , b 


eormatIVA'(f HAND,a,b,i HAND ); 

HC 

a,b 


formatlVA’(f HC,a,b,0); 

HCB 

a,b 


£ormatIVA'(f HCB,a,b,0); 

HCL 

a, b 


eormatIVA'(f HCL,a,b,0); 

HCM 

a,b 


eormatIVA'(£ HCM,a,b,0); 

HCP 

a 


eormatIVA’(f HCP,a,0,0); 

HCRC 

a, b 


eormatIVA'(e HCRC,a,b,i HCRC ); 

HD 

a,b 


formatIVA’(e aD,a,b,0); 

HDCP 

a 


eormatIVA’(e HDCP,a,0,0); 

HDLC 

a,m 


eormatIVB'(e HDLC,a,m); 

HDRS 

a,m 


eormatIVB’(e HDRS,a,m); 

HDRZ 

a,m 


eormatIVB'(e HDRZ,a,m); 

HDSF 

a, b 


eormatIVA'(e HDSF,a,b,0); 

HLB 

a,b 


eormatIVA’(e HLB,a,b,0); 

HLC 

a,in 


eormatIVB’(e HLC,a,m); 

HLCA 

a,b 


eormatIVA’(e aLCA,a,b,i HLCA ); 

HLC I 

a£4. 

b 

eormatIVA !'(£ HLCI,ae4,b,i HLCI); 

HLCT 

a£4, 

b 

eormatIVA l'(f HLCT,ae4,b,i HLCT); 

HLTC 

a,b 


eormatIVA'(e HLTC,a,b,i HLTC ); 

HM 

a, b 


eormatIVA’(e HM,a,b,0); 

HOR 

a,b 


eormatIVA'(e HOR,a,b,0); 

HPEI 

a,b 


eormatIVA’(e HPEI,a,b,i HPEI ); 

HP I 



eormatIVA'(e HPI,0,C,0); 

HR 

a,b 


eormatV’(e HR,a,£2 HR,b,0,0,0,£6 HR); 

HRS 

a ,in 


eormatIVB’(e_HRS,a,m); 


Table F-3b - Machine Code Instructions (Continued) 


F-42 


F.13 Machine Code- Insertions 





Ada/L PSE Handbooic 


Version 3.5 
29 March 1991 


MACRO/L 

Ada/L 


HRT 

a,b 

formatlVA'(f HRT,a,b,0); 


HRZ 

a,iii 

formatIVB'(f HRZ,a,m); 

1 

HSCA 

a, b 

formatlVA'(f HSCA,a,b,i HSCA ); 


HSCI 

af 4 ,b 

formatlVA l'(f HSCI,af4,b,i HSCI); 

j 

1 

HSCT 

af 4, b 

formatlVA l'(f HSCT,af4,b,i HSCT); 

1 

HSF 

a, b 

formatlVA'(f HSF,a,b,0); 

1 

HSIM 

a, b 

formatlVA'(f HSIM,a,b,i HSIM ); 

i 

HSTC 

HSTl 

HST2 

HST3 

HST4 

a, b 

formatlVA'(f HSTC,a,b,i HSTC ); 
formatlVA'(f HSTl,a HSTl,b HSTl,i HSTl); 
formatlVA'(f HST2,a HST2,b HST2,i HST2); 
formatlVA'(f HST3,a HST3,b HST3,i HST3); 
formatlVA'(£ HST4,a HST4,b HST4,i HST4); 

! 

HSTD 

a, b 

formatlVA'(f HSTD,a,b,i HSTD ); 

1 

HSTV 

a, b 

formatlVA'(f HSTV,a,b,i HSTV ); 


HV 

HWFI 

a, b 

formatV'(f HV,a,f2 HV,b,0,0,0,f6 HV); 
formatlVA'(f HWFI,0,0,i HWFI ); 

j 

HXOR 

a, b 

formatlVA'(f HXOR,a,b,0); 

1 

IBSC 

a 

formatlVA'(f IBSC,a,0,i IBSC ); 

) 

1 

IILM 

a 

PormatIVA'(f IILM,a,0,i IILM ); 

1 

! 

ro 

a,y,b,3 

formatI'(f 10,a,k IO,b,i,s,y); 

i 

rocL 

a 

formatlVA'(f IOCL,a,0,i lOCL ); 


I OCR 

a 

formatlVA'(f'lOCR,a,0,i lOCR ); 


rocs 

a 

formatlVA'(f IOCS,a,0,i IOCS ); 

i 

roT 

/ 1) r rti 

£ormatV'{f I0T,a,f2 lOT,b,0,0,m,f6 lOT ); 

1 

ipi 

IR 

y,b,s 

formatI’(f IPI,a IPI,k IPI,b,i,s,y); 
formatI'{f IR,0,k IR,0,0,0,0); 

1 

IRMMS 

a , b 

formatIVA'Te IRMMS,a,b,i IRMMS); 


IRMSR 

a,b 

formatlVA'(f IRMSR,a,b,i IRMSR ); 


ISMSR 

a, b 

formatlVA’(f ISMSR,a,b,i“lSMSR ); 


ISP 


formatV'(e ISP,a,f2 ISP,b,0,0,m,f6 ISP ); 


J 

y,k,b,a 

formatIir'(f J,a J,r3 J,k,b,i,3,y); 


JBNZ 

a,y,k,b,s 

formatIII'(f JBNZ,a,f3 JBNZ,k,b,i,s,y); 


JC 

a,y,k,b,a 

formatIII'(f JC,a,f3 JC,k,b,i,s,y); 


JE 

yfk,b,s 

formatlll'(f JE,a JE,f3 JE,k,b,i,3,y); 


JEP 

a,y,k,b,3 

forraatlll'(f JEP,a,f3 JEP,k,b,i,3,y); 


JG 

y»lc,b,s 

formatin'{f JG,a JG,r3 JG,k,b,i,3,y); 


JGE 

yfk,b,s 

formatin’(f JGE,a JGE,?’3 JGE, k ,b, i , s ,y) ; 


JL 

yric,b,s 

formatin' {f~’JL,a,?’3 JL,k,b,i,3,y); 


JLE 

yfk,b,s 

formatin'(f JLE,a JLE,f3 JLE, k, b, i , s ,y) ; 


JLT 

y,k,b,s 

formatin'(f JLT,a JLT,f3 JLT, k, b, i, s, y); 


JN 

a,y,ICfb,s 

formatin'(f JN,a,r3 JN,k,b, i,3,y); 


JNE 

y f k f ii f a 

formatin’(f JNE,a JNE.f3 JNE,k,b, i,s,y) ; 


JNF 

y/k,b,s 

formatin'(f JNF,a JNF,f3 JNF,k,b,i,s,y); 


JNW 

y,k,b,s 

formatni'(f JNW,a JNW,f3 JNW, k, b, i , s, y); 


JNZ 

a,y,k,b,s 

formatin' ( f_JNZ,a, f3_JNZ,k,b, i,s,y); 



Table F-3c - Machine Code Instructions (Continued) 


F.13 Machine Code Insertions 


F-43 








Version 3.5 
29 March 1991 


Ada/L ?SE Handbco< 


+. - 

I MACRO/L 


Ada/L 


i 


I 


JOF 

y,k,b,3 

JOP 

a, y, k , b, 3 

J? 

a,y,k,b,s 

JS 

sy,k,b 

JSC 

a,y,k,b,s 

JW 

y,k,b,s 

JZ 

a,y,k,b,s 

LA 

a,y,k,b,s 

LB 

a, y, k , b, 3 

LBJ 

a,y,k,b,s 

LBMP 

a, y, b, 3 

LCI 

ak,y,b,s 

LCMl 

y,b,s 

LCM2 

y,b,s 

LCM3 

y,b,s 

LCM4 

y,b,s 

LCMA 

y,b,3 

LCMP 

y,b,3 

LCMT 

y,b,3 

LCPA 

a,y,D,s 

LCRA 

a,y,b,s 

LCT 

ak,y,b,s 

LDI? 

a, y, k , b, 3 

LECM 


LIBP 

a,y,b,s 

LIM 

a,sy,b 

LIMP 

a,y,b,s 

LISR 

a,b 

LLP 

a,y ,b,3 

LLPN 

a,y,b,3 

LM 

a,y,k,b,3 

LNA 

a,y,k,b,3 

LRR 

a ,m 

LRRA 

a,b, i 

LSCM 


LSDM 

a,y,k,b,s 

LTCM 


LXB 

a,y,k,b,3 

M 

a,y,k,b,3 

MS 

a,y,b,3 

NLP 

a,y ,b,3 

OR 

a,Y,b,3 

PEI 

a,sy ,b 


PFCD 

PFCE 


formatin' ( f _JOF,a_JOF, f 3_JOF, k , b , i , s , y ) ; ' 

format III ’ ( E_JOP ,a, E3_JOP,l<,b,i,s,y); 
formatIII’(f_JP,a,f3_JP,k,b,i,3,y); | 

format III ’{ f_JS,0,f3_JS,k,b,ifS,y); I 

format III'(f_JSC,a,f3_JSC,k,b,i/s,y) ; “ 

format III'(f_JW,a_JW,f3_JW,k,b,ir s,y); 
format III'{f_JZ,a,f3_JZ,k,b,i,3,y); ' 

formatI '( f_LA,a, k ,b,i f 3,y ) ; i 

formatl'(f_LB,a,k,b,if3,y); 
format III'(f_L3J,a,f3_Laj,k,b,i,s,y); 
formatI’(f_LBMP,a,k_LBMP,b,i,s,y); I 

format la'(f_LCI,ak,b,i,s,y); i 

format I'(f_LCMl,a_LCMl,k_LCMl,b,i_LCMl,s,y); 
formatl'(f_LCM2,a_LCM2,k_LCM2,b,i_LCM2,s,y); 
formatI'(f_LCM3,a_LCM3,k_LCM3,b,i_LCM3,s,y); 
formatl'(f_LCM4,a_LCM4,k_LCM4,b,i_LCM4,s,y); ^ 

formatl'(f_LCMA,a_LCMA,k_LCMA,b,i_LCMA,s,v); ! 

formatl' ( f_LCMP,a_LCMP,k_LCMP,b,i,s,y ); i 

formatl'(f_LCMT,a_LCMT,k_LCMT,b,i_LCMT,s,y); | 

formatl'(f_LCPA,a,k_LC?A,b,i,s,y); ! 

formatl'(f_LCRA,a,k_LCRA,b,i,s,y); 
formatia'(f_LCT,ak,b,i,s,y); 

formatl'(f_LDir,a,k,b,i,s,y); j 

formatIVA'(f_LECM,a_LECM,0,i_LECM ); 

formatl'(f LIBP,a,k_LI3P,b,i,s,y); 

formatli' (F_LIM,a,k__LIM,b,i,sy); 

formatl'(f_LIMP,a,k~LIMP,b,i,s,y); 

formatIVA'{f_LISR,a,b,i_LISR ); 

formatl'(f_LLP,a,k_LLP,b,i,3,y ); 

formatl'(f_LLPN,a,k_LLPN,b ,i,3,y ); 

formatl’(f_LM,a,k,b,i,s,y); 

formatl'(f_LNA,a,k,b,i,3,y); 

formatV(f_LRR,a,f2_LRR,0,0,0,ra,f6_LRR); 

formatIVA'(f_LRRA,a,b,i); 

formatIVA'(f_LSCM,a_LSCM,0,i_LSCM); 

formatl'(f_LSUM,a,k,b,i,s,y); 

formatIVA'{f_LTCM,a_LTCM,0,i_LTCM ); 

formatl'(E_LXB,a,k,b,i,3,y); 

formatl'{f_M,a,k,b,i,s,y); 

formatl'(f_MS,a,k_MS,b,i,3,y); 

formatl'(f_NLP,a,k_NLP,b,i,3,y); 

formatI'(f OR,a,k_OR,b,i,s,y); 

formatli'(F PEI,a,k_PEI,b,i,sy); 

formatIVA'(F_PFCD,0,0,i_PFCD ); 

formatIVA'(f PFCE,0,0,i PFCE ); 


Table F-3d - Machine Code Instructions (Continued) 


F-44 


F.13 Machine Code Insertions 








Ada/L PSE Handbook 


Version 3.5 
29 March L991 


MACRO/L Ada/L 


PFR 

PIE 

a,y,b,s 

PMM 

y,b,3 

PMR 

y,b,s 

POP 

a, b 

PUSH 

a, b 

RA 

a,y,k,b,s 

RALP 

a, y , b, 3 

RAN 

a, y, k , b, s 

RCCR 

y,b,3 

RD 

a, y, k , b, 3 

RI 

a,y,k,b,3 

RIOAS 

a, b 

RISR 

a, b 

RJ 

y,k,b,s 

RJC 

a, y, k , b, 3 

RJSC 

a,y,k,b,3 

RLP 

a , y, b, 3 

RMMS 

a, bi 

RMS 

a, y, b, 3 

RMSR 

y ,b,3 

RNLP 

a,y,b,3 

ROR 

a, y, b, 3 

RP 

a,sy,b 

RPD 

y,k,b,s 

RRR 

a ,m 

RSC 

a,y,b,s 

RSD 

a 

RXOR 

a,y,b,3 

SA 

a,y,k,b,3 

SB 

a,y,k,b,3 

SBN 

a, n 

SBPC 

a,y,k,b,3 

SC 

a,y,b.3 

SCI 

ak,y,b,3 

SCMA 

y/b,3 

SCMP 

yr b,3 

SCMT 

y,b,3 

SCMl 

y/b,3 

SCM2 

yf b,3 

SCM3 

y, b,3 

SCM4 

y/b,3 

SCPA 

a,y,b,3 

SCRA 

a,y,b,3 

SCSR 

y, b, 3 


formatl’ ( e_?FR, a , l<_?FR, b, i_?FR, s , y) ; 

formatIVA'(f_PI£,0,0,i_PIE) ; 

formatl’(f_PMM,a_PMM,k_PMM,b,i,s,y); 

formatl' ( f_PMR,a_PMR, 1<_PMR, b, i , s , y) ; 

formatV ( f_POP, a , f 2_POP, b, 0,0,0 , f 6_POP) ; 

formatv(f_PUSH,a,f2^PUSH,b,0,0,0,f6_?USH ); 

formatl'(f_RA,a,k,b,I,s,y); 

formatl'(f_RALP,a,k_RALP,b,i,s,y); 

formatl’(f_RAN,a,k,b,i,s,y); 

formatl’(f_RCCR,a_RCCR,k_RCCR,b,i,3,y); 

formatl'(f_RD,a,k,b,i,s,y): 

formatl'(£_RI,a,k,b,i,s,y); 

formatIVA'v f_RIOAS,a,b,i_RIOAS); 

formatlVA’(f_RISR,a,b,i_RISR ); 

formatIII’(f_RJ,a_RJ,f3_RJ,k,b,i,s,y); 

format III'(f_RJC,a,f3_RJC,k,b,i,s,y); 

formatin' ( f_RJSC, a , f 3_RJSC , k , b , i , s , y) ; 

formatl’{f_RLP,a,k_RLP,b,i,s,y) ; 

formatIVA'(f_RMMS,a,b,i); 

formatl'{f_RMS,a,k_RMS,b,i,s,y) ; 

formatl'(f_RMSR,a_RMSR,k_RMSR,b,i,s,y); 

formatl'(f_RNLP,a,k_RNLP,b 

formatl'(f_ROR,a,k_ROR,b,i,s,y); 

format Ii'(f_RP,a,k_RP,b,i,sy); 

formatl'{f_RPD,a_RPD,k,b,i,s,y); 

formatV{f_RRR,a,f2_RRR,0,0,0,m,f6_RRR ); 

formatl' ( f __RSC,a, k_RSC, b, i , s , y); 

formatIVA'(f_RSD,a,0,i_RSD); 

formatl'(f_RXOR,a,k_RXOR,b,i> s,y); 

formatl'(£_SA,a,k,b,i,s,y); 

formatl'(f_SB,a,k,b,i»s,y); 

formative(f_SaN,a,f4_SBN,n); 

formatl'(f_SBPC,a,kfb,i,3,y); 

formatl'(f SC,a,k_SC,b,i^sfy); 

formatla'(?_SCI,ak,b,i,s,y); 

formatl'{f_SCMA,a_SCMA,k_SCMA,b,i_SCMA,s,y); 
formatl'(f_SCMP,a_SCMP,k SCMP,b,i,3,y); 
formatl'(f_SCMT,a_SCMT,k“SCMT,b,i_SCMT,s,y); 
formatl’{f_SCM1,a_SCMl,k_SCMl,b,i_SCMl,s,y); 
formatl'{f_SCM2,a_SCM2,k_SCM2,b,i_SCM2,s,y); 
formatl’(f_SCM3,a_SCM3,k_SCM3,b,i_SCM3,s,y); 
formatl'{f_SCM4,a_SCM4,k_SCM4,b,i_SCM4,s,y); 
formatl’(f_SCPA,a,k_SCPA,b,i,s,y); 
formatl'(f_SCRA,a,k_SCRA,b,i,3,y); 
formatl’(f SCSR,a SCSR,k_SCSR,b,i,s,y); 


Table F-3e - Machine Code Instructiona (Continued) 


F.13 Machine Code Inaertions 


F-45 





Version 3.3 

29 March L991 


Ada/L PSE HandbcoK 


MACRO/ 


SCT 

ak,y,b,3 

SDIF 

a,y,b,3 

SDMC 

a 

SI3P 

a,y,b,3 

SI.MC 

a, b 

SI.MP 

a,y,b,3 

SIRC 

a, b 

SITC 

a, b 

SL? 

a,y,b,3 

SM 

a,y,k,b,3 

SMCC 

a 

SMSR 

y,b,3 

SNA 

a,y,k,b,3 

SRRA 

a,b, i 

SSUM 

a,y,b,3 

STAF 

a, b 

STSa 

ak,y,b,3 

SXB 

a,y,k,b,3 

TBN 

a, n 


a, b 

TSBN 

a, n 

TSF 

y, b, 3 

TSM 

bi 

r/ 

a,b 

WFBP 

a,y,b,3 

WFM 

a,y,b,3 

XOR 

a,y,b,3 

XR 

y f b, 3 

XRL 

y^ b,3 

xs 

3y,b 


Ada/L 


formatla'(f_SCT,ak ,b, i,3,y) ; 

format I' ( f_SDIF,a,l< SDIF,b,i,s,y); 

formatIVA'(f_SDMC,a7o,i_SDMC ); 

format I' ( f_SIBP,a,)<_SIBP,b, i,3,y) ; 

formatIVA'{f_SIMC,a,b,i_SIMC ); 

format I' ( f_SIMP,a, ic SIMP, b, i,3,y); 

formatIVA*(f_SiaC,a7b,i_SIRC ); 

formatIVA’(f_SITC,a,b,i_SITC ); 

format I ’ ( f_SLP,a,l<_SLP,b,i,3,y); 

format I'(f_SM,a,k,b,i,3,y); 

formatIVA’(e_SMCC,a,0,i_SMCC ); 

formatI'(f_SMSR,a_SMSR,k_SMSR,b,i,3,y); 

formatI'(f_SNA,a,k,b,i,3,y); 

formatIVA'(f_SRRA,a,b,i); 

formatI'(f_SSUM,a,k_SSUM,b,i,3,y); 

formatv (f STAF,a, f 2_STAF, b, 0,0,0 , f 6_STAF ^ : 

formatla'(F_STSa,ak,b,i,3,y); 

format I'(f_SXB,a,k,b,i,3, y) ; 

formative ( f_TBN,a,f 4__TBN,n) ; 

formatv(f_TR,a,f2_TR7b,0,0,0,f6_TH); 

formative(f_TSBN,a,f4_TSBN,n); 

formatI'{f TSF,0,k TSF,b,i,3,y); 

formatlVA'Tf TSM ,a TSM,b,i); 

formatv(f_TV,a,f2 fv,b,0,0,0,f6 TV) ; 

formatI'(f WFBP,a,k WFBP,b,i WFBP,3,y); 

formatl'(f"WFM,a,k_wrM,b,i_WFM,s,y); 

formatI'(f~XOR,a,k~XOR,b,i73fy); 

formatl'(f“XR,0,k_XR,b,i,3,y); 

formatX ' ( f_XRI,,0,k_XRL,b,i,3,y} j 

formatl'(f XS,a XS7k XS,b,i,3y); 


Table F-3f - Machine Code Instructions (Continued) 


F-46 


F.13 Machine Code Insertions 









Ada/L ?SE Handbook 


Version 3.5 
29 March 1991 



I Option Function i 

+-- 


I 

I 


+ 


EXECUTIVE 


MEASURE 


NO CHECKS 


Enables pragma EXECUTIVE and allows ! 
visibility to units which have been i 
compiled with the RTE_ONLY option. i 
Default: NO_EXECUTIVE ' I 

Generates code to monitor execution i 
frequency at the subprogram level for i 
rhe current unit. Default: NO_MEASURE i 

NO_CHECKS suppresses all run-time i 
error checking. CHECKS provides i 
run-time error checking. | 
Default: CHECKS I 


NO_CODE_ON_WARNING 

NO_CODE_ON_WARNING means no code is 
generated when there is a diagnostic 
of severity WARNING or higher. 
CODE_ON_WARNING generates code 
only if there are no diagnostics 
of a severity higher than WARNING. 
Default: CODE_ON_WARNING 

NO_CONTAINER_GENERATION 

NO_CONTAINER_GENERATION means that no 
container is produced even if there 
are nc diagnostics. 
CONTAINER_GENERATION produces a 
container if diagnostic serverity 
permits. 

Default: CONTAINER GENERATION 



+ 


Table F-4a 


Special Processing Options 


.14 Compiler Options 


F-47 







Version 3.5 Ada/L PSE Handbook 

29 March 1991 


+-- 

i Option Function 


I NO_DEBUG If NO_DE3UG is specified, only that 

j information needed to link, export 

and execute the current unit is 
1 included in the compiler output. 

With the DEBUG option in effect, 

I internal representations and 

additional symbolic information are 
i stored in the container. 

! Default: DEBUG 

I NO_TRACE_3ACX Disables the location of source 

1 exceptions that are not handled by 

i built-in exception handlers, 

i Default: TRACE BACK 

i 

i OPTI.MIZE Enables global optimizations in 

! accordance with the optimization 

i pragmas specified in the source 

! program. If the pragma OPTIMIZE is 

i not included, the optimizations 

i emphasize TIME over SPACE. 

I When NO_OPTIMIZE is in effect, no 

I global optimizations are performed, 

I regardless of the pragmas specified, 

j Default: NO_OPTIMIZE 

j 

I RTE_ONLY Restricts visibility of this unit 

i only to those units compiled with 

I the EXECUTIVE option. 

1 Default: NO RTE ONLY 


Table F-5b - Special Processing Options (Continued) 


F-48 


F,14 Compiler Options 








Ada/L PSE Handbook 


Version 3.5 
29 March 1991 


1 Option Function | 


ATTRIBUTE 


I CROSS_REFERENCE 

! 


DIAGNOSTICS 

MACHINE CODE 


I 

I NOTES 


SOURCE 

SUMMARY 


Produces a Symbol Attribute Listing. 
(Produces an attribute cross-reference 
listing when both ATTRIBUTE and 
CROSS_REFERENCE are specified.) 
Default: NO_ATTRiaUTE. 

Produces a Cross-Reference Listing. 
(Produces an attribute cross-reference 
listing when both ATTRIBUTE ahd 
CROSS_REFERENCE are soecified.) 
Default: NO_CROSS_REFERENCE. 

Produces a Diagnostic Summary Listing. 
Default: NO DIAGNOSTICS. 


Produces a Machine Code Listing if 
code is generated. Code is generated 
when CONTAINER_GENERATION option is 
in effect and (1) there are no 
diagnostics of severity ERROR, SYSTEM, 
or FATAL, and/or (2) NO_CODE_ON_WARNING 
option is in effect and there are no 
diagnostics of severity higher than 
NOTE. A diagnostic of severity NOTE 
is reported when a Machine Code 
Listing is requested and no code is 
generated. OCTAL is an additional 
option that may be used with 
MACHINE_CODE to output ocatal values 
on the listing instead of hex values. 
Default: NO MACHINE CODE. 


Includes diagnostics of NOTE severity 
level in the Source Listing. 

Default: NO NOTES. 


Produces listing of Ada source 
statements. Default: NO SOURCE. 


Produces a Summary Listing; always 
produced when there are errors in the 
compilation. Default: NO_SUMMARY. 


I 

( 


i 


I 




Table F-6 - Ada/L Listing Control Options 


F.14 Compiler Options 


F-49 








Version 3.5 
29 March 1991 


Ada/L PSE Handbook 


Option 

Function 

MSG 

Sends error messages and the 

Diagnostic Summary Listing to the 
file specified. The default is to 
send error messages and the Diagnostic 
Summary Listing to Message Output 
(usually the terminal). 

OUT 

j 

Sends all selected listings to a 
single file specified. The default 
is to send listings to Standard 

Output (ususally the terminal). 


Table F-7 - Control_Part (Redirection) Options 


F-50 


F. 14 


Compilg'r Options 









n^rl 7 c: nFTTRRATELY LEFT BLANK NOT 
EfsMT?AL ?0 REPORT PER TELECOM 

/“vn/^ TT\A 


dan LEHMANN ADA OFC IDA 

^ 1 n /OO /Q1 


I 


F-52 


PAGES DELIBRATELY LEFT BLANK NOT 
ESSENTIAL TO REPORT PER TELECON 
DAN LEHMANN ADA OFC IDA 
DC 10/29/91 


F-51 


Ada/L ?SE Handbook 


Version 3.5 
29 March 1991 


F.16 LinJref'Options 


Option 

Function 

DEBUG 

Produces a linked container to be 
debugged. Default: NO DEBUG. 

MEASURE 

Produces a linked container to be 
analyzed. Default: NO MEASURE. 

PARTIAL 

Produces an incomplete linked 
container with unresolved references. 
Default: NO_PARTIAL. 

RTL_SELECTIVE 

Similar to the SELECTIVE option 
except that is only refers to RTLIB 
units. This option is not supported 
during phase links. 

Default: NO_RTL_SELECTIVE. 

SEARCH 

Explicitly searches for the units to 
be included in the linked container. 
Default: SEARCH for final links; 
NO_SEARCH for phase links. 

SELECTIVE 

Maps into the program only the 
subprograms called by the main 
subprogram. Default: SELECTIVE 
for final links; NO_SELECTIVE 
for phase links. 


Table ?-10 - Ada/L Linker Special Processing Options 


F.16 Linker Options 


F-53 







Version 3.5 
29 March 1991 


Ada/L PSE Handbook 


Option 

Function 

No option 

Linker summary listing always 
produced. 

DE3UGMA? 

Generates a debugmap listing. 
Default: NO_DEBUGMAP. 

ELAB_LIST 

Generates an elaboration order 
listing. Default: NO_ELAB_LIST. 

LOADMAP 

Generates a loadmap listing. 

Default:NO_LOADMAP. 

LOCAL_SYMBOLS 

Generates a symbols listing with 
all internal as well as external 
definitions in the program. 
LOCAL_SYMBOL3 is to be used in 
conjunction with the SYMBOLS 
option. If LOCAL_SYMBOLS is 
specified with NO_SYMBOLS, a 

WARNING is produced and the SYMBOLS 
option is activated. 

Default: NO_LOCAL_SYMBOLS 

SYMBOLS 

Produces a Linker symbols listing. 
Default: NO_SYMBOLS. 

UNITS 

Produces a Linker units listing. 
Default: NO_UNITS. 


Table F-11 - Linker Listings Options 


F-54 


F.16 Linker Options 









Ada/L 

?SE Handbook 

Version 
29 March 


Option 

Function 

1 

1 

i 

i 

1 

1 

MSG 

Sends error messages to the file 
specified. The default is to send 

i 

1 

1 

1 


error messages to Message Output 
(usually the terminal). 

1 

! 

i 

1 

1 

OUT 

Sends all selected listings to the 
single file specified. The default 
is to send listings to Standard 

Output (usually the terminal). 


Table F-12 

- Control Part (Redirection) Options 


3 . 5 
1991 





F.16 Linker Options 


F-55 









Version 3.5 
29 March 1991 


Ada/L PSE Handbook 


F.17 Exporter Onions 


Option 

Function 

DEBUG 

i 

i 

Permits the generation of a load 
module with all debugging facilities 
available. When NO DEBUG is 
specified or is in effect by default, 
no debugging facilities are made 
available. Export the program for 
debugging with either the Run-Time 
Debugger (RTD) or the Embedded Target 
Debugger (ETD). 

Default; NO_DE3UG. 

i DYNAMIC 

Deferred. 

LOAD 

Deferred. 

MEASURE 

I 

i 

! 

1 

1 

1 

1 

Permits the generation of a load 
module with all performance 
measurement facilities available. 

When NO_MEASURE is specified or is in 
effect by default, no performance 
measurement facilities are made 
available. Default: NO_MEASURE 

i 

; REVO 

In conjunction with the SIM IMAGE 
argument to the IMAGE named parameter, 
this option specifies production of a 
Target System File suitable for input 
to Revision 0 of SI.M/L and PORTAL/43. 


Table F-13 - Ada/L Special Processing Options 


F-56 


F.17 


Exporter Options 









Ada/L PSE Handbook 


Version 3.5 
29 March 1991 


Option Function 


I MSG Sends error messages to the file 

i specified. The default is to send 

I error messages to Message Output 

I (usually Che terminal). 

i 

1 OUT Sends all selected listings to the 

i singlefilespecified. The default 

j is to send listings to Standard 

i Output (usually the terminal). 


Table F-14 - Control_Part (Redirection) Options 


F.17 Exporter Options 


F-57 







Vers ion 3.5 
29 March 1991 


Ada/L PGE Handboo< 


Ootion 


Function 


DE3UGMAP Generates a segment-by-segment listing I 

tnat describes how the units are mapped i 
onto hardware. Default: N0_DE3UGMJ^P. i 

LOADMA? Generates a listings that describes how 

the units are mapped onto the hardware. 
Default: NO_LOADMAP. 

10C.2iL_SYMB0LS As an option in addition to SYMBOLS 

listing, causes the symbols listing to i 
include all internal as well as external j 
definitions in the program. | 

Default: NO LOCAL SYMBOLS I 


i NO DETAILED 


-PTEXEC 


i 

! SYMBOLS 


UNITS 


Suppresses the listing of subprograms ! 

contained within each EXEC psect in I 

the DEBUGMA? and LOADMAP listings. ! 

Default: DETAILED. i 

] 

Produces executive listings instead i 

of application listings. It can only I 

be used with the LOADMAP and DEBUGMAP I 

options (e.g., /LOADMAP/RTEXEC). ! 

Default: NO_.RTEXEC i 

Generates a symbols listing of all 1 

external definitions in the program. 1 

Default: NO SY.MBOLS. I 

~ I 

I 

Generates a listing of all units. i 

Default: NO UNITS. ! 


Table F-15 - Ada/L Exporter Listing Options 


i. 


F-58 


17 


Exporter Options 







