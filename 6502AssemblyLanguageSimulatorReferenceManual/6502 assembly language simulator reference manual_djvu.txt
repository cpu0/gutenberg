I would like to thank Dr. James Burnside, Mr. Glenn 
Wiggins, Mr. Alan Klick, and my mother, for without their 
help this work would not have been possible. 


TABLE OF CONTENTS 


Preface iii 
The Simulator 1 

Memory Locations 1 
The Accumulator 1 
The X- and Y-Registers 2 
The Stack 2 
The Status Register 4 
The Overflow Flag 4 
The Positive Flag 5 
The Zero Flag 5 
The Negative Flag 5 
The Program Counter 5 
Labels and Variables 6 
Variables 6 

Labels 6 „ n 

Declaring Variables and Labels 7 

Syntax and Addressing Techniques 8 
Syntax 8 

Addressing Techniques 9 
Implied Addressing 9 
Immediate Addressing 9 
Absolute Addressing 10 
Absolute-X and -Y Addressing 10 
Variable Addressing 11 
Direct Addressing 11 
Labeled Addressing 11 
Indirect Addressing 12 . 

Indirect Variable Addressing 12 
Examples of Syntax 13 


Execution and Operators 14 


Operators 14 

Execution of the Simulator 24 
Disclaimer 25 
Bibliography 26 

Appendix A: Addressing Techniques 27 
Appendix B: Operators 28 



Appendix C: Error Messages and Recovery 30 
Appendix D: Source Listing 32 

Appendix E: Supplementary Material for use with 
this System 47 

The Nature of the System 47 
The Source Code 49 
Variable List 51 
Increasing Memory Capability 53 

Appendix F: Sample Programs 55 

ASCII Code Generation Program 56 
Multiplication Program 59 


li 



PREFACE 


This manual and accompaning assembly language 
simulator is to be used as a teaching tool in a beginning 
assembly language course. It will help the student grasp 
the concepts behind machine-oriented commands, stack 
functions, branching procedures, and addressing techniques. 

Because of the purpose that the simulator serves, 
simplicity was stressed over actual overall usefulness of 
the language in a business type environment. The number of 
operators have been decreased compared to other assemblers. 
Also, input-output control is limited. However, these 
shortcomings are outweighed in an academic environment by 
the simplicity and speed by which the simulator is used. 
The student still has access to conditional and uncondi¬ 
tional branching, subroutines, stack manipulation, 
alphanumeric variable and label addressing, simple integer 
and label addressing, simple integer and character 
input/output, and arrays. 

The text is written in a reference manual fashion, 
rather than a textbook fashion. Some attempt has been made 
to explain the underlying concepts behind assembly language 
programming and addressing techniques; however, it is 
recommended that the user either be familiar with some form 


iii 



of assembly language already or be under an instructor's 
supervision before trying to understand the concepts 
presented here. 


IV 



6502 ASSEMBLY LANGUAGE SIMULATOR REFERENCE MANUAL 


PART I: THE SIMULATOR 

This manual serves as an introduction to programming 
in assembly language using modified 6502 microprocessor code 
and the assembly language simulator programmed for use on 
the HP-3000. The language includes 49 mnemonics, including 
6 mnemonics not included in the 6502 instruction set (CCT, 
PRT, PRA, INP, INA, and STP) . The simulator can accept 
implied, immediate, absolute indexed, indirect, variable, or 
labeled addressing techniques. These will be discussed in 
detail in Part II. 

The system is set up with limited memory space; 
however, the simulator is easily modified to accommodate 
larger storage for variables, labels, and memory locations. 

MEMORY LOCATIONS 

Memory locations available to the programmer include 
the accumulator, the X- and Y-registers, the program stack, 
the status register, and the program counter. 

THE ACCUMULATOR 

The accumulator is nothing more than an eight-bit 
word stored in main memory. However, many operations depend 
on the accumulator, especially branch statements and logical 


1 



2 


operations. Also, the status register is set based on what 
is stored in the accumulator at the time. The accumulator 
can be loaded from memory (LDA), stored in to another 
location (STA), be added to (ADC) or subtracted from (SBC), 
or be operated on by logical operators (AND, EOR, ORA). The 
uses of the accumulator will be discussed throughout the 
text. 

THE X- AND Y-REGISTERS 

The X- and Y-registers are locations similar to the 
accumulator; however, their functions are more limited. 
They can be loaded from memory (LDX, LDY), stored into 
memory (STX, STY), or they can be incremented or decremented 
(INX, INY, DEX, DEY). These registers are also used in X- 
and Y-indexed addressing. Indexed addressing is described 
in Part II. 

THE STACK 

The program stack is an array of 100* bytes in main 
memory, which can be stored into, changed, or output as 
desired by the programmer. The zero position in the stack 
is the accumulator. Therefore, a call to the zero position 
in the stack is the same as a call to the accumulator. If 
any variables are defined in a program, they are assigned 
memory locations starting at position 1 in the stack (see 
Figure 1). 

* can be expanded 



3 


There are commands which 
"push" or "pop" data from the 
top of the stack. At the 
beginning of the program the top 
of the stack is located at 
position 100*. Any call to push 
data onto the stack would result 
in the number being stored 
at the top of the stack, the stack pointer being decremented 
by one, and the number being pulled from the top of the 
stack (Figure 2). 

The stack limit is 100*, therefore the total number 
of variables in a particular program plus the total number 
of locations used by the stack must not exceed 100*. Also 
calls to subroutines use the stack, so leaving any pending 
calls to the stack when returning from a subroutine or 
trying to pop a value from a subroutine that is pushed from 
another procedure will result in an error. 




Direct calls can be made 
from the stack. (For instance, 
INP $0023 would input a number 
from a terminal or other input 
device and store it in the 23rd 
position in the program stack.) 
However, care must be taken to 
insure that the memory location 





4 

has not already been used, as a variable or as a location 
pushed onto the stack. 

THE STATUS REGISTER 

The status register consists of "flags" which tell 
the programmer the status of the accumulator at any 
particular time. These flags are used in all conditional 
branching. The flags used by the programmer are the 
overflow flag (V), the positive flag (P), the zero flag (Z), 
and the negative flag (N). 


The Overflow Flag 

Every time the accumulator is changed to a 
value greater than 255 or less than -255 , the 
accumulator is "rolled over" and the overflow flag is 
changed. Figure 3 shows the effect of addition and 
subtraction on the accumulator and overflow flags. 


Notice that if the overflow flag is already set, a 
second overflow will clear it. Therefore, it may be a 


good idea in some applications to clear the overflow 



57 #oz £5 /?C£i*occZ 58C #oca 


Figure 3: Effects of addition and 
subtraction on the accumulator and 
overflow flags. 


flag (CLV) immediately after it 
is found to be set. The CLV 
command sets the overflow flag 
to zero. The BVC command 
branches on V=0. The BVS 
command branches on V=1. 








5 


The Positive Flag 

The positive flag is set whenever the value is 
the accumulator is greater than zero. The BPL command 
branches on P=l. 

The Zero Flag 

The zero flag is set whenever the value in the 
accumulator is equal to zero. The BEQ command branches 
on Z=1. The BNE command branches on Z=0. 

The Negative Flag 

The negative flag is set whenever the value in 
the accumulator is less than zero. The BMI command 
branches on N=l. 

THE PROGRAM COUNTER 

The program counter stores the value of the line 
number that the program is currently executing. The line 
number of the first executable line in a program (any line 
other than LAB or VAR) has a line number of 1. All other 
executable lines of code are numbered relative to that. 
(Line numbers are printed on the source listing as an aid to 
debugging). 

The program counter is changed by conditional or 
unconditional branching. It is also changed by calling a 
subroutine, with the added feature that the original value 



of the counter is stored in the stack to be retrieved when 
returning from that subroutine. 


6 


LABELS AND VARIABLES 

Labels and variables are used as aids in 
programming. They enable the programmer to substitute 
alphanumeric character strings in place of numbers when 
referencing memory locations or line numbers. Labels and 
variables can be of any length, but the system only 
recognizes up to the first ten characters as significant. 


VARIABLES 

Variables can be declared in place of memory 
location numbers on the program stack. Variables are 
assigned starting at location $0001 on the stack. For 
instance, declaring VI, V2, and V3 to be variables would 
assign locations $0001, $0002, and $0003 on the program 

stack to those variables, respectively. So a call to VI 
would be the same as a call to location $0001 on the stack, 
V2 the same as $0002, and V3 the same as $0003. 

LABELS 

Labels identify line numbers in a program. Labels 
must be declared before they can be used. If a statement is 
labeled, then any branch to that label is the same as a 
branch to the corresponding line number. For instance, if 



7 


line number 14 has a label of "LABEL1” then any reference to 
LABELl is the same as a reference to line number 14. 
Labeled addressing techniques are discussed in Part II. 


DECLARING VARIABLES AND LABELS 

Variables and labels must be declared before they 
can be used. Labels are declared using the LAB command, 
while variables are declared using the VAR command. LAB and 
VAR commands are non-executable statements, therefore, they 
do not receive a line number, nor are they part of the 
object module. The only purpose that the VAR and LAB 
statements serve is to set up a table in main memory to keep 
track of variables and label locations. Variables and 
labels should be declared as soon as possible to avoid 
trying to reference a variable or label before it is 


declared. 



8 


PART II: SYNTAX AND ADDRESSING TECHNIQUES 

SYNTAX 

Every line of a program consists of an operator, an 
addressing technique, and an operand. Optional elements 
include labels and comments. 

GENERAL SYNTAX REQUIREMENTS 

A line must be no more than 72 characters long. It 
can start anywhere on the line, but must not run onto the 
next line. Blank lines are not allowed. Here is the 
general form of a line: 

[LABEL:] OPERATOR TECHNIQUE OPERAND [COMMENT] 

LABEL (Optional)- A label can contain any 
alphanumeric characters, except colons and spaces. It must 
be followed immediately by a colon. There may be any number 
of spaces following the colon. 

OPERATOR- An operator consists of a three letter 
mnemonic which the system can understand. A list of 
operators are included in the next section. The operator 
must be followed by one or more spaces. 

ADDRESSING TECHNIQUE- A one character code which the 
system recognizes. Specific addressing techniques are 
discussed later in this section. A space or spaces after 
the addressing technique character are optional. 



9 


OPERAND- May be a four digit number, a variable, or 
a label, depending on the addressing technique. The operand 


must be followed by at least one space. 

COMMENT (Optional)- After reading the space after 
the last character in the operand, the system ignores any 
other data on the line. Therefore, comments can be inserted 
up to the 72 character limit (end of line). 

ADDRESSING TECHNIQUES 

Addressing techniques allow the programmer the 
flexibility to access data in many different ways. The 
addressing techniques offered by the system include implied, 
immediate, absolute, absolute-X, absolute-Y, variable, 
direct label, indirect, and indirect variable. 

IMPLIED ADDRESSING 
LABEL:TXA -0000 (COMMENT) 

Implied addressing is used when the operator does 
not need an operand. In the line above, transfer X-register 
to accumulator does not need any operand. A dash is used as 
the addressing technique, and any four-digit number is used 
as the operand. 

IMMEDIATE ADDRESSING 
LABEL: LDA #0521 (COMMENT) 

Immediate addressing is used when the data to be 
used is in the instruction itself. In the line above, the 



10 


accumulator is loaded with the value 521. A "#" is used as 
the addressing technique, and any four digit number is used 
as the operand. 

ABSOLUTE ADDRESSING 
LABEL: LDA $0065 (Comment) 

In absolute addressing, the system takes the value 
of the stack location specified by the operand. In the line 
above, the accumulator is loaded with the contents of stack 
location 65. A dollar sign is used as the addressing 
technique, and any four digit number is used as the operand, 
as long as the number does not exceed the stack limit. 

ABSOLUTE-X and -Y ADDRESSING 
LABEL: LDA X0065 (Comment) 

In absolute-X addressing, the value of the operand 
is added to the value in the X-register, and that value in 
turn is used as the value of the stack location to be used. 
In the above line, the accumulator is loaded with the 
contents of stack location (65 + X) , where X is the value 
stored in the X-register. Absolute-Y addressing uses the 
same procedure, except the Y-register is used rather than 
the X-register. An X and Y is used for the X-and Y- 
addressing technique, respectively. The operand is any 
four-digit number. 



11 


VARIABLE ADDRESSING 
LABEL: LDA V VAR1 (Comment) 

Variable addressing is similar to absolute 
addressing, the one change being that a variable, rather 
than a stack address, is used as the operand. A "V" is used 
as the addressing technique. A variable name is used as the 
operand. 

DIRECT ADDRESSING 
LABEL: BNE $0015 (Comment) 

In direct addressing, the operand signifies a 
specific line number to be loaded into the program counter. 
In the above example, if the accumulator is not equal to 
zero, the program counter is loaded with the value 15, and 
the program will jump to line 15. (This is not the EDITOR 
generated number, but the 15th significant line of the 
program.) Like absolute addressing, a dollar sign is used 
as the addressing technique, and any four-digit number can 
be used as the operand. 

LABELED ADDRESSING 
LABEL: BNE L LABI (Comment) 

Labeled addressing is the same as direct addressing, 
except that the label of a line is used instead of a line 
number. In the above line, if the accumulator is not equal 
to zero, the program counter is loaded with the line number 



labeled LABI. An "L" is used as the addressing technique, 
and a label name is used as the operand. 


12 


INDIRECT ADDRESSING 
LABEL: LDA I 0034 (Comment) 

Indirect addressing uses one memory location as a 
pointer to another memory location. The second memory 
location is then used as the operand. In the example, the 
accumulator is loaded with the value stored in stack 
location D(34), where D(x) is the contents of stack location 
x. Therefore, if stack location 34 contains a value of, say 
48, then the system would load the contents of stack 
location 48 into the accumulator. An "I" is used as the 
addressing technique, and the operand is any four digit 
number which does not go beyond the stack limit. 

INDIRECT VARIABLE ADDRESSING 
LABEL: LDA P VARl (Comment) 

Indirect variable addressing is the same as indirect 
addressing, except that a variable location is used, rather 
than an literal stack position. In the example above, VARl 
is used as a pointer to another position on the stack, say 
48. The contents of stack location 48 would then be loaded 
into the accumulator. A "P" is used as the addressing 
technique, and the operand can be any variable name. 



13 


EXAMPLES OF SYNTAX 


The following are correct statements: 

LDA WARIABLESl 

STA $ 0002 (Comment) 

END:BRK -0000 
1234: INP $0000 

The following are incorrect: 

(No space after operator) 

(Space between label and colon) 

(No addressing technique or operand) 
(Variable name required as operand) 

(No space between operand and comment) 


LDA$0001 

LABEL5 :ADC $0001 
BRK 


START:ADC V 0001 
BNE $0001(START) 



14 


PART III: EXECUTION AND OPERATORS 

OPERATORS 

The execution of any program is principally 
dependent on the operators. Once the simulator retreives 
the proper operand, the operator determines what is done 
with it. The following is a list of the operators available 
to the user: 

ADD ACCUMULATOR (ADC) ADDRESSING: #,$,X,Y,V,I,P 

This function adds the value of the operand to the 
accumulator. If the result is greater than 256 , the 
accumulator "rolls over", and the overflow flag is changed. 

AND ACCUMULATOR (AND) ADDRESSING: #,$,X,Y,V,I,P 

This function takes the binary value of both the 
operand and the accumulator, and performs a logical "AND" 
operation on each corresponding bit. The result is stored 
into the accumulator. 

ARITHMETIC SHIFT LEFT (ASL) ADDRESSING:$,X,Y,V,I,P 

This function takes the binary value of the memory 
location specified by the operand, and shifts each bit to 
the left one position. The leftmost bit is shifted out, and 
a zero is shifted in to the right. 



15 


BRANCH EQUAL TO ZERO (BEQ) ADDRESSING:#,L 

This function loads the program counter with the 
value specified by the operand, but only if the zero flag is 
set (Z=l) . If the zero flag is not set, then the program 
continues to the next line. 

l 

BRANCH RESULT MINUS (BMI) ADDRESSING: #,L 

This function loads the program counter with the 
value specified by the operand, but only if the negative 
flag is set (N=l). Otherwise, the program continues to the 
next line. 

BRANCH NOT EQUAL TO ZERO (BNE) ADDRESSING: #,L 

This function loads the program counter with the 
value specified by the operand, but only if the zero flag is 
not set (Z=0). Otherwise, the program continues with the 
next line. 

BRANCH RESULT PLUS (BPL) ADDRESSING:#,L 

This function loads the program counter with the 
value specified by the operand, but only if the positive 
flag is set (P=l). Otherwise, the program continues with 
the next line. 

BREAK (BRK) ADDRESSING: - 

This function stops the execution of the program and 
returns the user to the MPE operating system. From there, 



16 


the user can abort the program, or use the -.RESUME command 
to continue. 


BRANCH OVERFLOW CLEAR (BVC) 


ADDRESSING: #,L 


This function loads the program counter with the 
value specified by the operand, but only if the overflow 
flag is clear (V=0). Otherwise, the program continues with 
the next line. 


BRANCH OVERFLOW SET (BVS) 


ADDRESSING: #,L 


This function loads the program counter with the 
value specified by the operand, but only if the overflow 
flag is set (V=l) . Otherwise, the program continues with 
the next line. 


CARRIAGE CONTROL SET (CCT) ADDRESSING: #,$,X,Y,V,I,P 

This function changes the carriage control for the 
PRT and PRA commands. The value in the operand specifies 
the number of carriage returns to be executed after any 
subsequent output statements as follows: 

0-No carriage return/or line feed 

1- Carriage return and one line feed 

2- Carriage return and two line feeds 

3- Carriage return and skip to the next page 
The default value is 1. 



17 


CLEAR OVERFLOW FLAG (CLV) ADDRESSING: 

This function sets the overflow flag to zero (V—0). 

DECREMENT MEMORY (DEC) ADDRESSING: $,X,Y f V,I,P 

This function subtracts 1 from the stack location 

specified by the operand. 

DECREMENT X-REGISTER (DEX) ADDRESSING: 

This function subtracts 1 from the X-register. 

DECREMENT Y-REGISTER (DEY) ADDRESSING: 

This function subtracts 1 from the Y-register. 

EXECUTIVE OR ACCUMULATOR (EOR) ADDRESSING: #,$,X,Y,V,I,P 

This function takes the binary value of both the 
accumulator and the operand, and performs a logical 
exclusive "OR" operation on each corresponding bit. The 
result is stored into the accumulator. 


INPUT ASCII CHARACTER (INA) ADDRESSING: $,X,Y,V,I,P 

This function accepts a value from the standard 
input device (usually a terminal) and stores its ASCII code 
into the stack location specified by the operand. 

INCREMENT MEMORY (INC) ADDRESSING: $,X,Y,V,I,P 

This function adds 1 to the stack location specified 

by the operand. 



18 


INPUT NUMERICAL VALUE (INP) ADDRESSING: $,X,Y,V,I,P 

This function accepts a numerical value from the 
standard input device (usually a terminal), and stores it 
into the stack location specified by the operand. 

INCREMENT X-REGISTER (INX) ADDRESSING: - 

This function adds 1 to the X-register. 

INCREMENT Y-REGISTER (INY) ADDRESSING: - 

This function adds 1 to the Y-register. 

JUMP (JMP) ADDRESSING: #,L 

This function loads the program counter with the 
value specified by the operand. 

JUMP SAVING RETURN ADDRESS (JSR) ADDRESSING: #,L 

This function "pushes" the value of the program 
counter onto the stack, then loads the program counter with 
the value specified by the operand. This allows the use of 
subroutines. 

LABEL DECLARATION (LAB) ADDRESSING: L 

This function declares the operand to be a label. 
This operator is not executable, but is simply a declaration 
which must be made before the label is referred to in any 


way. 



19 


LOAD ACCUMULATOR (LDA) ADDRESSING: #,$,X,Y,V,I,P 

This function takes the value specified by the 

operand and stores it into the accumulator. 

LOAD X-REGISTER (LDX) ADDRESSING: #,$,V,I,P 

This function takes the value specified by the 
operand and stores it into the X-register. 

LOAD Y-REGISTER (LDY) ADDRESSING: #,$,V,I,P 

This function takes the value specified by the 

operand and stores it into the Y-register. 

LOGICAL SHIFT RIGHT (LSR) ADDRESSING: $,X,Y,V,I,P 

This function takes the binary value of the stack 

location specified by the operand, and shifts each bit by 1 

to the right. The rightmost bit is shifted out, and a zero 
is shifted in to the left. 

NO OPERATION (NOP) ADDRESSING: - 

This function specifies that no operation is to be 
executed. The program simply goes on to the next line. 

OR ACCUMULATOR (ORA) ADDRESSING: #,$,X,Y,V,I,P 

This function takes the binary values of both the 
accumulator and the value specified by the operand, and 
performs a logical "OR” operation. The result is stored 
into the accumulator. 



20 


PUSH ACCUMULATOR ONTO STACK (PHA) ADDRESSING: - 

This function "pushes" the accumulator onto the top 
of the stack, and decrements the top-of-stack pointer. 

PUSH PROGRAM STATUS ONTO STACK (PHP) ADDRESSING: - 

This function "pushes" the status register onto the 
top of the stack, and decrements the top-of-stack pointer. 

PULL ACCUMULATOR FROM STACK (PLA) ADDRESSING: - 

This function "pops" a value from the top of the 
stack, stores it into the accumulator, and increments the 
top-of-stack pointer. 


PULL PROGRAM STATUS FROM STACK (PLP) ADDRESSING: - 

This function "pops" a value from the top of the 
stack, stores it into the status register, and increments 
the top-of-stack pointer. 

PRINT ASCII CHARACTER (PRA) ADDRESSING: $,X,Y,V,I,P 

This function takes the value specified by the 
operand, and prints its ASCII equivalent onto the standard 
listing device. 

PRINT NUMERICAL VALUE (PRT) ADDRESSING: $,X,Y,V,I,P 

This function takes the value specified by the 
operand, and prints it onto the standard listing device. 



21 


RETURN FROM SUBROUTINE (RTS) ADDRESSING: - 

This function takes the value from the top of the 
stack (previously pushed by a JSR command) , and stores it 
into the program counter. This allows the user to return 
from a subroutine. 

SUBTRACT FROM ACCUMULATOR (SBC) ADDRESSING: #,$,X,Y,V,I ,P 
This function takes the value specified by the 
operand and subtracts it from the accumulator. If the 
result is less than -255, then the accumulator "rolls over" 
and the overflow flag is changed. 

STORE INTO ACCUMULATOR (STA) ADDRESSING: #,$,X,Y,V,I,P 

This function takes the value specified by the 
operand and stores it into the accumulator. 

STOP (STP) ADDRESSING: — 

This function stops execution of a program and 
returns the user to the MPE operation system. 

STORE INTO X-REGISTER (STX) ADDRESSING: #,$,V,I,P 

This function takes the value specified by the 
operand, and stores it into the X-register. 

STORE INTO Y-REGISTER (STY) ADDRESSING: #,$,V,I,P 

This function takes the value specified by the 
operand, and stores it into the Y-register. 



22 


TRANSFER ACCUMULATOR TO X-REGISTER (TAX) ADDRESSING: - 

This function transfers the contents of the 
accumulator into the X-register. The contents of the 

accumulator are unaffected. 

TRANSFER ACCUMULATOR TO Y-REGISTER (TAY) ADDRESSING: - 

This function transfers the contents of the 
accumulator into the Y—register. The contents of the 

accumulator are unaffected. 

TRANSFER STATUS REGISTER TO X-REGISTER (TSX) ADDRESSING: - 
This function transfers the contents of the program 
status register to the X-register. The status register 
remains the same. 

TRANSFER X-REGISTER TO ACCUMULATOR (TXA) ADDRESSING: - 

This function transfers the contents of the 

X-register to the accumulator. The X-register remains the 
same. 

TRANSFER X-REGISTER TO STATUS REGISTER (TXS) ADDRESSING: - 
This function transfers the contents of the 

X-register to the status register. The contents of the 
X-register remains the same. 



23 


TRANSFER Y-REGISTER TO ACCUMULATOR (TYA) ADDRESSING: - 

This function transfers the contents of the 
Y-register to the accumulator. The contents of the 
Y-register are unaffected. 

VARIABLE DECLARATION (VAR) ADDRESSING: V 

This function declares the operand to be a variable. 
This operand is not executable, but is simply a declaration 
which must be made before the variable is referred to in any 
way. 



24 


PART IV: EXECUTION OF THE SIMULATOR 

The simulator is stored in object form on the disk. 
It takes an EDITOR-created file of source code, parses the 
code, then puts it into a form that it can execute quickly. 
This code is stored in a job-temporary file, so the contents 
of the original source file remains unchanged. If the 
simulator has detected no syntax arrors, then it uses this 
temporary "object" file to execute the program. After 
inputting the program onto an EDITOR file, the user 
activates the simulator from the main operating system by 
using the following command: 

:ASSEMBLEGO progname 

Where progname is the EDITOR-file which contains the 
source code. Remember, there should be no blank lines in 
this file, and no line should exceed 72 characters. The 
simulator will print out the source listing, including the 
line numbers. These line numbers are not the EDITOR line 
numbers, but an ordinal value signifying the nth significant 
line in the program. LAB and VAR commands are not 
considered significant. 

After the source listing the simulator prints the 
number of errors and warnings detected. If no errors are 
detected, then the simulator prepares the program for 
execution. If no errors are yet detected, the program 
executes. 

Appendix C shows a list of all error and warning 
messages. Appendix D shows a sample run. 



25 


DISCLAIMER 

This simulator and manual fulfills, in part, the 
requirements for a three-semester honors course. In 
preparing this project, I had to always weigh the relative 
advantages to the amount of time it would take to accomplish 
a certain goal. I did not have the time to implement 
everything that I wished to see in an assembly language; 
however, I believe I have created a useful and functional 
system which achieves what I had hoped to accomplish. 

One aspect of this project which I was not able to 
accomplish to my satisfaction was the debugging procedure. 
It is impossible to test this simulator under every possible 
situation. No doubt the user will find errors. I will make 
every reasonable effort to correct those errors up through 
May, 1983. After that, it may be a good idea to devote 
another honors project or applied programming course to the 
upkeep and expansion of this system. 



26 


BIBLIOGRAPHY 


Abrams, Marshall and Stein, Phillip. Computer Hardware and 
Software; An Interdisciplinary Introduction . 
Reading, Mass.; Wesley Publishing Company, 1973. 

Camp, R. C., Smay, T. A., and Triska, C. J. Microprocessor 
System Engineering . Beaverton, Oregon: Matrix 
Publishers, 1979. 

Machine Introduction Set Reference Manual . Santa Clara, 
California: Hewlett-Packard Company, 1976. 

MPE Intrinsics Reference Manual . Santa Clara, California: 
Hewlett-Packard Company, 1978. 

Systems Programming Language Reference Manual . Santa Clara 
California: Hewlett-Packard Company, 1976. 

Systems Programming Language Textbook . Santa Clara, 
California: Hewlett-Packard”Company , 1976. 



27 


APPENDIX A: 

ADDRESSING TECHNIQUES 


SYMBOL 

TECHNIQUE 

OPERAND TYPE 

- 

Implied 

Numerical 

# 

Immediate, direct 

Numerical 

$ 

Absolute 

Numerical 

X 

Absolute-X 

Numerical 

Y 

Absolute-Y 

Numerical 

V 

Variable 

Variable 

L 

Labeled 

Label 

I 

Indirect 

Numerical 

P 

Variable Indirect 

Variable 



28 


APPENDIX B: OPERATORS 

Addressing 

Operator Function Technique System Code 




_ 

# 

$ 

X 

Y 

V 

L 

I 

_p 


ADC 

A + M -) A 


X 

X 

X 

X 

X 


X 

X 

70 

AND 

A AND M -) A 


X 

X 

X 

X 

X 


X 

X 

71 

ASL 

0 (- M (- 0 



X 

X 

X 

X 


X 

X 

60 

BEQ 

BRANCH Z = 1 


X 





X 



32 

BMI 

BRANCH N = 1 


X 





X 



33 

BNE 

BRANCH Z = 0 


X 





X 



34 

BPL 

BRANCH P = 1 


X 





X 



35 

BRK 

BREAK 

X 









1 

BVC 

BRANCH V = 0 


X 





X 



36 

BVS 

BRANCH V = 1 


X 





X 



37 

CCT 

CARRIAGE CONTROL 


X 

X 

X 

X 

X 

X 

X 

X 

76 

CLV 

0 -) V 

X 









3 

DEC 

M - 1 -) M 



X 

X 

X 

X 


X 

X 

63 

DEX 

X - 1 -) X 

X 









4 

DEY 

Y - 1 -) Y 

X 









5 

EOR 

A EOR M -) A 


X 

X 

X 

X 

X 


X 

X 

72 

INA 

$STDIN -) M 



X 

X 

X 

X 


X 

X 

68 

INC 

M + 1 -) M 



X 

X 

X 

X 


X 

X 

61 

INP 

$STDIN -) M 



X 

X 

X 

X 


X 

X 

66 

INX 

X + 1 -) X 

X 









6 

INY 

Y + 1 -) Y 

X 









7 

JMP 

M -) PC 


X 





X 



40 

JSR 

M -) PC -) ST 


X 





X 



41 


LAB DECLARATION 


X X X X X 


X X 


80 



29 


Operator 


Function 


Addressing 

Technique System Code 





- 

# 

$ 

X 

Y 

V L 

I 

_p 


LDA 

M -) 

A 


X 

X 



X 

X 

X 

73 

LDX 

M -) 

X 


X 

X 



X 

X 

X 

50 

LDY 

M -) 

Y 


X 

X 



X 

X 

X 

51 

LSR 

0 -) 

M -) 0 



X 

X 

X 

X 

X 

X 

62 

NOP 

NO OPERATION 

X 








8 

ORA 

M OR 

A -) A 


X 

X 

X 

X 

X 

X 

X 

74 

PHA 

A -) 

ST 

X 








9 

PHP 

PC - 

) ST 

X 








10 

PLA 

ST - 

) A 

X 








11 

PLP 

ST - 

) PC 

X 








12 

PRA 

M -) 

$STDLIST 



X 

X 

X 

X 

X 

X 

67 

PRT 

M -) 

$STDLIST 



X 

X 

X 

X 

X 

X 

65 

RTS 

ST - 

) PC 

X 








13 

SBC 

A - 

M -) A 


X 

X 

X 

X 

X 

X 

X 

75 

STA 

A -) 

M 


X 

X 

X 

X 

X 

X 

X 

64 

STP 

STOP 


X 








21 

STX 

X -) 

M 


X 

X 



X 

X 

X 

52 

STY 

Y -) 

M 


X 

X 



X 

X 

X 

53 

TAX 

A -) 

X 

X 








15 

TAY 

A-) 

Y 

X 








16 

TSX 

S -) 

X 

X 








17 

TXA 

X-) 

A 

X 








18 

TXS 

X -) 

S 

X 








19 

TYA 

Y -) 

A 

X 








20 

VAR 

DECLARATION 






X 



81 



30 


APPENDIX C: ERROR MESSAGES AND RECOVERY 
Error 

No. Message 

0 System simulator error - see instructor 

1 Operator less than 3 Characters - check spacing 

2 Operand less than 4 Characters - check spacing 

3 Unrecognized operator - check Appendix B 

4 Undefined variable name - VAR command needed 

5 Undefined label name - LAB command needed 

6 Unrecognizable Data - ??? 

7 End-of-line detected after label read 

8 End-of-line detected after operator read 

9 End-of-line detected before operand read 

10 Implied (-) addressing only 

11 Labeled (L) or direct (#) addressing only 

12 Labeled (L) or direct (#) addressing only 

13 Improper addressing technique - see Appendix A 

14 Duplicate label name — label already defined 

15 Duplicate variable name - variable already defined 

16 Missing label - branch to label not associated with a line 

17 Branch to non-existent statement 

18 Improper operand - see addressing techniques 



31 


Warning 

No. Message 

0 System simulator error - see instructor 

1 Operator greater than 3 Characters - check spacing 

2 Operand greater than 4 Characters - check spacing 

3 Carriage control number greater than 3 

-single spacing assumed 



APPENDIX D: SOURCE LISTING 


32 


PAGE 1 


HEW-ETT-PACKARO 322Q1A-7-12 EDIT/3000 WED, MAR 30* 1983* 5:30 PM (C) HE 


1 

2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 

16 

17 

18 

19 

20 
21 
22 

23 

24 

25 

26 

27 

28 

29 

30 

31 

32 

33 

34 

35 

36 

37 

38 

39 

40 

41 

42 

43 

44 

45 

46 

47 

48 

49 

50 

51 

52 

53 

54 

55 

56 

57 


SCDNTROL USLINIT,NO WARN 

INTRINSIC FOPEN»FCLOSE »PRINT ,FR£AD,FWRITEDIR »READ* BINARY * ASCII *D ATE LI 
INTRINSIC 


INTESER 


LINENUHBER* CC PROGRAM COUNTER >> 


LIST » 


INTESER 

DOUBLE 

INTEGER 


ERROR* CC 
ERRORS* « 
WARNING* « 
WARNINGS, CC 
SOURCENUMBER* <C 
OBJECTNUHBER* « 
LOOP, CC 
LOOP1* 

STACKPOINTER* CC 
XRES, CC 
TREG, << 
STATUS, CC 
COUNTER* CC 
OPERAND* « 
CURSOR, CC 
LENGTH, CC 

addressing; <c 
oplimit:=ioo; « 
doublenumber; cc 

ARRAY 

stackco:ioii, 

« 


CURRENT ERROR NUMBER » 

TOTAL NUMBER OF ERRORS >> 

CURRENT WARNING NUMBERl >> 

TOTAL NUMBER 0- WARNINGS >> 

SOURCEFILE NUMBER » 

UBJECTFILE NUMBER » 

PROGRAM LOOPS » 

PROGRAM STACK POINTER >> 

X-REGISTER >> 

Y-REGISTEP. >> 

CURRENT R LINE T NUM9ER DURING EXECUTION » 
OPERAND DURING EXECUTION >> 

POINTER USED TO PARSE LINE » 

LENGTH OF 1-0 STRINGS » 

ADDRESSING OBJECT CODE >> 

DOUBLE^INTEGER^BUFFER FOR FWRITEDIR » 


« PROGRAM STACK » 
•OBJECT• CODE » 

- reference stack>> 


BYTE 

BYTE 

BYTE 


IN » 


LOGICAL 

LOGICAL 


CODECO:2>, 

LABELREFCO : 191 ;«LABEL 
ARRAY 

sourcefileco:7):=*30urce •; 

ARRAY 

OBJECTFILE l 0:7>: = *OBJECT •; 

ARR LINEf0S72)* « SOURCELINE 

LABELSC0I1991, CC LABEL LIST 
VARIABLESCO:199>,CC VARIABLE 
OPERATORCO:3), « PARSED 
OPBYTE(0:3)* CC PARSED 

OPLABEL CO I 9 ) * CC PARSED 
0PVARIABLEC0:9)*CCPARSED 
TECHNIQUE(0:0),CC PARSED 

DISPLAYLINEC0:79);CC DISPLAY LINE >> 

FOF*= FALSE; CC END OF FILE TEST >> 

TESTVAR IABLE, CCTEST AREA FOR VARIABLES>> 

testlabel; cc test area for labels» 


CC SOURCEFILE NAME » 

cc objectfile name » 


READ 

» 

LIST 


» 

OPERATOR » „ ^ 
OPERAND IN DECIMAL FORM >> 
OPERAND IN LABEL FORMAT >> 
OPERAND IN VARIABLE FORMAT 
TECHNIQUE CODE >> 


» 


.usiSIVcaIeStS?!?^™ ?r?S2‘ilpcJ8i 

IS UNRECOGNIZABLE, THE PROCEDURE RETURNS A ZERO- » 

BYTE ARRAY OPERATOR; 

BEGIN 

INTEGER CODE; 



33 


PAGE 2 HEWLETT-PACKARD 32201A.7.12 EOIT/3300 WED* MAR 30, 1933, 5230 PM CC 


58 

59 
GO 
61 
62 

63 

64 

65 

66 

67 

68 

69 

70 

71 

72 

73 

74 

75 

76 

77 

78 

79 

80 
81 
82 

83 

84 

85 
36 

87 

88 

89 

90 

91 

92 

93 

94 

95 

96 

97 

98 

99 
103 
101 
102 

103 

104 

105 

106 

107 

108 

109 

110 
111 
112 

113 

114 


cqoe:=o; 
operator<3>:=’ 

<<0P COOES THAT CAM 
IF OPERATOR = " 
OPERATOR = ■ 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
<<OP COOES THAT 
IF OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
«OP CODES THAT 
IF OPERATOR 
IF OPERATOR 
<< CAN USE IMMEDIATE, 

IF OPERATOR = "LDX 
IF OPERATOR = "LOY 
IF OPERATOR = "STX 
IF OPERATOR = "STY 
«CAN USE A8S0LUTE, ABS 


IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 


IF 

IF 

IF 

IF 

IF 


ONLY 
BRK 
= "CLV 
= "OEX 
= ■OEY 
= * INX 
= * INY 
= "NOP 
= "PHA 
= ■ PHP 
= *PLA 
= " PLP 
= -RTS 
= -TAX 
= "TAY 
= * TSX 
= *TXA 
= *TXS 
= *TY A 
= *STP 
CAN ONLY 
= "BEQ 
= "BMI 
= “ 8NE 
= “ BPL 
= ■ BVC 
= -BVS 
CAN ONLY 
= *JMP 
JSR 


IF OPERATOR 
IF OPERATOR 
IF OPERATOR 
IF OPERATOR 
IF OPERATOR 
IF OPERATOR 
IF OPERATOR 
IF OPERATOR 
IF OPERATOR 
<<IMMEOTATE »ABSOLUTE*ABS 
IF OPERATOR = "ADC ~ 
OPERATOR = * AND 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 
OPERATOR 


' ASL 
= -INC 
= " LSR 
= -DEC 
= " ST A 
= * PR T 
= * INP 
= "PR A 
= ■ INA 


IF 
IF 
IF 
IF 
IF 

<<LA3EL’AND VARIABLE DECLARATIONS 0NLY>> 
IF OPERATOR = "LAB • THEN C0DE:=8Q* 


■EOR 
" LDA 
"ORA 
•SBC 
'CCT 


USE IMPLIED AOORE3SINS>> 

THEN COoe:=i; 
code:=3; 
cooe:=4; 
cooe:=5; 
code:=6? 
code:=7; 
code:=s; 
cooe:=9; 
cooe:=io; 
cod£:=ii; 
code:=12? 
code:=13? 
code:=is; 
cooe:=16j 

CODE2=17i 

cooe:=18; 
code:=19? 
code:=20; 
code:=21? 

USE LABEL OR RELATIVE ADORESSIMG» 
THEN cooe:=32; 
cooe:=33; 
code 2 = 34 ; 
code:-35; 

C0DE2=36J 
CODE2=37» 

LABEL OR ABSOLUTE A00RES5ING>> 


THEN 

THEN 

THEN 

THEN 

THEN 

THEN 

THEN 

THEN 

THEN 

THEN 

THEN 

THEN 

THEN 

THEN 

THEN 

THEN 

THEN 

THEN 


THEN 

THEN 

THEN 

THEN 

THEN 

USE 


OR INDIRECT» 


THEN code:=4o; 

ABSOLUTELY ARABLE* OR INDIRECT AODRESSI MG» 
THEN code:=5o; 

THEN code:=5i; 

THEN C0QE:=52i 
THEN C00E:=53? 

X OR Y, VARIABLE, 

THEN CODE 2=60J 
THEN C0DE:=6i; 

THEN CODE I=62» 

THEN CODE:=63? 

THEN CODE 2=64i 
THEN COOe:=65; 

THEN C00E:=66? 

THEN cooe:=67; 

THEN C0DE2=68? 

X OR Y, VARIABLE, 

THEN CODE:=70; 

THEN C0DE:=7i; 

THEN C00E:=72» 

THEN C00E:=73; 

THEN C00E:=74; 

THEN CODE:=75; 

THEN CD3E:=76J 


OR INDIRECT» 




34 


PAGE 3 


HEWLETT-PACKARD 32201A.7.12 EDIT/3GQ0 WED* MAR 30, 1983, 5:30 PM (C) 


115 
11 & 
117 
113 

119 

120 
121 
122 
123 
12 * 

125 

126 

127 

128 

129 

130 

131 

132 

133 

134 

135 

136 

137 

138 

139 

140 

141 

142 

143 

144 

145 

146 

147 

148 

149 

150 

151 

152 

153 

154 

155 

156 

157 

158 

159 

160 
161 
162 
153 

164 

165 

166 

167 

168 

169 

170 

171 


AND 


IF OPERATOR = *VAR * THEM C33E:=81J 

opcooe:=code 

end; 

PROCFOURF PARSER<LINENUMBER,LINE,LABELS»LA3ELNUMBER*OPERATOR, 

TECHNIQUE,OPBTTE,OPLABEL,OPVARIABLE,VARIABLES,ERROR,WARNING!? 
INTEGER LINENUM8ER*LABELNUMBER*ERR0R,WARNING? 

BYTE ARRAY LINE,LABELS,OPERATOR,TECHNIQUE,OPBYTE, 

BYTE ARRAY OPLABEL,OPVARIABLE,VARIABLES, 

BEGIN 

INTEGER LAST? 

INTEGER LOOP; 

error:=o; 

uarning:=q; 

last:=o; 

move operator:=4(« *); 

while 1 (line(Cast**= » »> and clast < 721 do last:=last*i; 

IF LAST S 72 THEN 
BEGIN 

ERROR:=6; 

RETURN 

end; 

r ija cnp “tsLAST; 

WHILE CLINECCURSOR)<>* *) AND CLINECCURSOR)O *Z •) 

CCURS0R<72) DO CURS0R:=CURS0R*1i 
IF CURSOR = 72 THEN 

BEGIN 

error:=6« 

RETURN 

« EXTRACT LABEL IF IT EXISTS » 

IF LINECCURSOR) = THEN 

BEGIN 

IF CURSOR-LAST > 10 THEM 
FOR L0OP:=0 UNTIL 9 DO 

OPLABELCLOOP):=Ll Me. CLAST+LOOP) 

ELSE BEGIN 

FOR LOOPI=0 UNTIL 9 00 

oplabelcloop):=■ *; _ 

FOR LOOP:=a UNTIL CCURSOR-LASTI-l 00 
OPLABELCLOOP):=LINECLA3T*L00P) 

FOR*LOOP:=Q STEP 10 UNTIL LABELNUMBER 00 
BEGIN 

testlabel:= true; 

FOR ^J2 0 £Jg^L3CLOOP*LOOPl)OOPLABELCLOOPl) THEN 

testlabel:= false; 

IF testlabel then 

LABELREFCLOOP/13):=LINENUMBER 

end; 

cursor:=cursor+i; 

LAST * —CURSOR* 

UHILE~CLINE(LAST)=* ■> AND CLASTC72) DO LAST:=LAST+1* 

IF LAST = 72 THEN 
BEGIN 



35 


PAGE 4 


HEWLETT-PACKARD 32201A.7.12 EDIT/3300 WED* MAR 30* 1983» 5:30 PM 


172 

173 

174 

175 

176 

177 

178 

179 

180 

iai 

132 

183 

184 

185 

186 
187 
138 

189 

190 

191 

192 

193 

194 

195 

196 

197 

198 

199 

200 
201 
202 

203 

204 

205 

206 

207 

208 

209 

210 
211 
212 

213 

214 

215 

216 

217 

218 

219 

220 
221 
222 

223 

224 

225 

226 

227 

228 


■) AMO (CUR30R<72) DO 


warming :=i; 


ERROR:=7» 

RETURN 

END? 

cursor:=last; 

WHILE ( line (CuR30R)o■ 
cuRS0R:=cuRS0R♦l; 

IF CURSOR = 72 THEN 
BEGIN 

error:=t; 

RETURN 

end; 

end; 

<< EXTRACT OPERATOR » 

IF CURSOR-LAST > 3 THEN 
IF CURSOR-LAST < 3 THEN 
BEGIN 

error:=i; 

RETURN 

end; 

for loop:=o until 2 00 

OPERATORCLDOP):=LINE(LA3T*L00P); 

cursor:=cursor*i; 

WHILE~tLINECLAST)=* ■) AND (LAST<72) DO LA3T:=LAST+li 

IF LAST = 72 THEN 

BEGIN 

error:=8 J 

# RETURN 

<C EXTRACT ADDRESSING TECHNIQUE>> 

TECHNIQUE:=LINECLAST); 

last:=last+i; 

WHILE CLINE (LAS T)=■ *) AND (LASTC72) 

IF LAST =72 THEN 
BEGIN 

error:=9; 

RETURN 

end; 

cursor:=last; 

WHILE (LINECCURSOR)O* •> AND CCURS0R<72) 

cursor:=cursor+i; 

IF CURSOR = 72 THEN 
BEGIN 

error:=9; 

RETURN 

end; 

<< FIND APPROPRIATE 

IF QR T (TECHNIQUE = ” "T*) OR (TECHNIQUE = “I") THEN 
BEGIN 

IF CURSOR-LAST > 

IF CURSOR-LAST < 

BEGIN 

error:=2 ; 

RETURN 

end; 

for loop:=o until 


do last:=last*i; 


DO 


OPERAND FOR ADDRESSING TECHNIQUE >> 

■#■) OR (TECHNIQUE = OR (TECHNIQUE = *X«) 


THEN 

THEN 


warning:=2 ; 


3 DO 


(C) 



36 


HEWLETT-PACKARD 32201A.7.12 EDIT/30G0 WED* MAR 33# 1983* 5:30 PH (C) 


229 

230 

231 

232 

233 

234 
2 35 
236 
2 37 

238 

239 

240 

241 

242 

243 

244 

245 

246 

247 

248 

249 

250 

251 

252 

253 

254 

255 

256 

257 

258 

259 

260 
261 
262 

263 

264 

265 

266 

267 

268 

269 

270 

271 

272 

273 

274 

275 

276 

277 

278 
2 79 
280 
281 
282 

283 

284 

285 


QPBYTE(LOOP):=LIME CLAST +LOQP) 

~ mo ; 

IF (TECHNIQUE = -V") OR (TECHNIQUE = -°-J THEN 
IF CURSOR-LAST > 10 THEN 
FOR LOOP:=0 UNTIL 9 DO 

OPVARIABLE(LOOP):=LIME(LAST+LODP) 
ELSE BEGIN 

FOR lqop:=o UNTIL 9 00 

OPV AR IABLE(LOOP): = " •? 

FOR LOOP:=0 UNTIL CURSOR-LAST 00 

OPVARIABLE(LOOP):=LINE(LAST+LOOP) 

end; 

IF TECHNIQUE = "L* THEN 

IF CURSOR-LAST > 10 THEN 
FOR loop:=o UNTIL 9 00 

OPLABEL(LOOP I:=LIME CLAST>LOOP) 

ELSE BEGIN 

FOR loop:=o UNTIL 9 00 

0PLABEL(L00Pl:= - "? „ 

FOR loop:=o UNTIL CURSOR-LAST 00 
OPLABEL(LOOP >:=LI NE (LAST-H.OO® ) 


end; 


end; 


PROCEDURE PRINTERROR(ERROR»ERRORS 
INTEGER ERRORfERRORS* 

BEGIN 

3YTE ARRAY ERRORLINE(0:71); 
MOVE ERRORLINE:=72(" •)» 

CASE ERROR OF BEGIN 


) 


MOVE ERRORLINE:=*SYSTEM s 

move errorline:=*error i: 
move erporline:=-error 2 : 

MOVE errorline:=*error 3: 

MOVE errorline:= b error 4: 
move errorline:--error 5: 
move errorline:= - error 6 : 

MOVE ERRORLINE:="ERROR 7: 

move errorline:=-errqr 3: 

MOVE errorline:=*error 9: 

MOVE errorline:=*error 10 
MOVE ERRORLINE:=*ERROR 11 
MOVE ERRORLINE:=*ERROR 12 
MOVE ERRORLINE:="ERROR 13 
MOVE ERRORLINE:="ERROR 14 
MOVE ERRORLINE:=*ERROR 15 
MOVE ERROP.LINE:="ERROR 16 
MOVE ERRORLINE:="ERROR 17 
MOVE ERRORLINE:="ERROR 18 

end; 

PRINT (ERR OR LINE »-72 *-0")* 
ERRORS:=ERRORS*i; 

ERROR :=o; 
end; 

PROCEDURE PRI NTWARNING(WARNING*WARNINGS)* 
INTEGER WARNING ^WARNINGS; 


IMULATOR ERROR-; 

OPERATOR < 3 CHARACTERS-; 

OPERAND C 4 CHARACTERS-; 
UNRECOGNIZED OPERATOR"; 

UNDEFINED VARIABLE NAME-S 
UNDEFINED LABEL NAME-; 
UNRECOGNIZABLE DATA"? 

EOLN DETECTED AFTER LABEL READ-J 
EOLN DETECTED AFTER OPERATOR READ- 
EOLN DETECTED BEFORE OPERAND READ* 

: IMPLIED AOORESS ONLY*# 

: LABEL OR IMMEDIATE AOORESS ONLY-; 

: LA8EL OR IMMEDIATE ADORESS ONLY-; 
IMPROPER ADDRESSING TECHNIQUE"? 
DUPLICATE LABEL NAME*; 

DUPLICATE VARIABLE NAME"? 

MISSING LABEL-* 

BRANCH TO NON-EXISTENT STATEMENT"? 
IMPROPER OPERAND-; 






37 


PAGE 6 HEWLETT-PACKARD 322C1A.7.12 EDIT/3000 WED* MAR 30. 1983* 5:3Q PM (C) h 


286 

297 
288 

289 

290 

291 

292 

293 

294 

295 

296 
2 97 

298 

299 

300 

301 

302 
333 

304 

305 

306 

307 

303 

309 

310 

311 

312 

313 

314 

315 

316 

317 
313 

319 

320 

321 

322 

323 

324 

325 

326 

327 
323 

329 

330 

331 

332 

333 

334 

335 

336 

337 

338 

339 

340 

341 

342 


BEGIN 

3YTE ARRAY WARNINGLIME{0:71H 
MOVE WARNINGLINE:=72(" ■); 

CASE WARNING OF BEGIN 

MOVE WAftNINGLINE:="SYSTEM simulator error-; 

MOVE WARNINGLINE:=*UARNIMG i: OPERATOR >3 CHARACTERS-; 

MOVE WARNINGLIME;=-WARNING 2: OPERAND > 4 CHARACTERS-; 

MOVE WARNINGLINE;=-WARNING 3: CARRIAGE CONTROL CODE NUMBER > 
MOVE WARNINGLINE:=-UARNING 4»; 

end; 

PRINT(WARNINGLINE.-72 *-o*); 

UARNINGS:=WARNINGS+i; 

uarning:=o; 

end; 

PROCEDURE MESSAGE; 

<< PRINTS SYSTEM ERROR MESSAGES FOR ANY I/O ERRORS >> 

BEGIN 

INTEGER ERRORCOOE.DUMMY; 

3 YTE ARRAY ERRORLINEC0171 )i 
INTEGER number:=OJ 
INTRINSIC FCHECK* FERRMSG; 

fcheckcn umber,errorcode); 

MOVE ERR0RLINE:=72(- -)| 

FERRMSG(ERRORCODE.ERRORLINE.DUMMY); 

?RINT(ERR0RLI.NEt-72.- ■) 

end; y 

PROCEDURE ADDLABELCLABELS.LABEL,NUMBER,0PLA3EL); 

« ADDS A LABEL TO THE LABEL TABLE AND CHECKS FOR DUPLICATION » 

BYTE ARRAY LABELS.OPLABELJ 
INTEGER LABELNUMBERJ 
BEGIN 

FOR LOOP:=0 STEP 10 UNTIL LABELNUMBER DO 
BEGIN 

testlabel:= true; 

FOR LOOPi:=0 UNTIL 9 DO 

IF LABELSCLOOP+LOOP1) <> OPLA3ELCLOOP1) THEN 

testlabel:= false; 

IF TESTLABEL THEN 
BEGIN 

error:=14; 

PRINTERROft(ERROR,ERRORS)} 

RETURN 

end; 

end; 

for L00p:=0 UNTIL 9 DO 

LABELS(LABELNUM9ER>L00P):=0PLA3EL(LOOP); 

labelnumber:=label.number ♦ io 

end; 

PROCEDURE AD0VARIABLE(VARIABLES,VARIABLENUMBER,0PVARIABLE); 

<< ADDS A VARIABLE TO THE VARIABLE TABLE AND ASSIGNS A 
POSITION IN THE STACK » 

BYTE ARRAY VARIABLES.OPVARIABLE; 

INTEGER VARIA8LENUMBER; 

BEGIN 



38 


PAGE 7 


HEWLETT-PACKARD 32201A.7.12 EDXT/3000 WED, MAR 30* 1983, 5:30 PM CC> 


343 

344 

345 

346 

347 

348 

349 

350 

351 

352 

353 

354 

355 

356 

357 

358 

359 

360 

361 

362 

363 

364 

365 

366 

367 
3 68 

369 

370 

371 

372 

373 

374 

375 

376 

377 

378 
3 79 

380 

381 
332 

383 

384 

385 

386 

387 

388 

389 

390 

391 

392 

393 

394 

395 

396 

397 

398 

399 


END 


FOR LQQP: = Q STEP 10 UNTIL WAR IA8LEMUMBER D3 

begin 

testvariable:= true; 

FOR j ^BLESCLOOP+LOO 3 1) <> 0?VARIABLE(LOOP!> THEN 

testvariable:= false; 

IF TESTVARIABLE THEN 
BEGIN 

rooQO* — 15• 

PRINTERRORCERROR*ERRORSIJ 

RETURN 

end; 

eno; 

F3R V ARI^BLESC VARIABLENUMBER*LOOP> t=OPVARIABLE(LOOP)5 
VARIABLENUMBER:=VARIABLENUMBER ♦ 10 


PROCEDURE PREPARE(LABELNUMBER,LABELS,LA8ELREFi; „ p . n(r . 

<< ASSIGNS LINE NJM8ERS TO ALL BRANCH STATEMENTS USING LABELS » 

INTEGER LABELNUMBER5 
INTEGER ARRAY LABELREF* 

BYTE ARRAY LABELS; 

BEGIN 

DOU8 =or L loop:=:i until linenumber DO 

BEGIN 

L00P2:=D0UBLECL00P); 

FREADOIR(OBJECTNUMBER *CODE ,3,LOOP2)» 

IF < THEN MESSAGE; 

IF CODE(1) = 6 THEN 

BE5I C0DE(2):=LABELREF(C30E(2)); 

IF CODE(2) = 0 THEN E.RROR:=l&; 

FURITEDIR(OBJECTNUMBER*CODE,3*L00P2), 

IF < THEN MESSAGE 

end; 

end; 

end; 

<< T LOADS P THE E PROPER°DAfA INTO THE OPERAND ACCORDING TO THE 
ADDRESSING TECHNIQUE >> 

BEGIN 

IF CODE(l) = 0 THEN 

load:=operand 

ELSE 

LOAD:=STACK(OPERAND I 

end; 

<<°R ? SETS THE^PROGRAM COUNTER AND CHECKS r 0R ERRORS >> 

BEGIN 

IF CODE(1) = 6 THEN 

counter:=o 3 erand - 1 

riSE 

COUNTER:=COUNTER - (OPERAND + 1); 



39 


PAGE a 


HEWLETT-PACKARD 322Q1A-7-12 EDIT/3Q30 WED* MAR 30t 1393* 5:30 PM (C) 


400 

401 

402 

403 

404 

405 

406 

407 
403 

409 

410 

411 

412 

413 

414 

415 
415 

417 

418 

419 

420 

421 

422 

423 

424 

425 

426 

427 

428 

429 

430 

431 

432 

433 

434 

435 

436 

437 

438 

439 

440 

441 

442 

443 

444 

445 

446 

447 

448 

449 

450 

451 

452 

453 

454 

455 

456 


IF (COUNTER < 0) 
error:=17? 


OR (COUNTER > LI ME MUMBE R) THEN 


end; 

PROCEDURE ROUND(NUMBER)* 

INTEGER NUMBER*. 

R£51 vj 

IF (NUMBER > 255) OR (NUMBER < -255) THEN 
3EGIN 

SS"?a*3IS M ?5*aa , i«rus.«a:»s.ST»Tu 8 .«2:i» * <-i> 

end; 

end; 


PROCEDURE RUN; _ 

<< EXECUTES THE OBJECT CODE STORED 
BEGIN 

INTRINSIC causebreak; 

DOUBLE L00P2; 

counter:=i; 

5TATUS:=0; 

3 tackpointer:=ioo; 

eof:=false; 

L00P2:=D0UBLE(C0UNTER); 

FREADDIR (OBJECTNUMBER iCODE »3»LOOt*2) ; 

if > then eof:=true; 

IF < THEN MESSAGE; 

WHILE NOT EOF DO 

BEGI CASE CODEC 1) OF BEGIN 

operand:=code(2); 
operand:=code (2 >; 

OPERAND:=C0DE(2) ♦ XREG; 
operand:=code(2) «■ yris; 
OPERAND:=STACK(COOE(2) ) • 

operand:= o; 

OPERAND:=cODE(2); 

cjyjQ • 

CASE CODE(O) OF BEGIN 


IN TEMP FILE "OBJECT* » 


causebreak; 
status-( 2 : 1 ):=o; 

BEGIN 

xreg:=xreg - 1 ; 
operand:=i; 

ROUND(XREG) 

end; 

BEGIN 

yreg:=yreg - 1 ; 
operand:=i; 

ROUND(YREG) 

end; 

BEGIN 

xreg:=xreg ♦ 1 ; 
operand:=i; 

ROUND(XREG) 


<<i>> 

<< 2 >> 

<<3>> 

<<4>> 


<<5 >> 


<< 6 » 



40 


HEU_£TT-PACKARD 32201A.7.12 EJir/300a WEDt MAR 30t 1983* 5:30 PM (Cl 


457 

458 

459 

460 

461 

462 

463 

464 

465 

466 

467 

468 

469 

470 

471 

472 

473 
4 74 

475 

476 
4 77 
478 
4 79 

480 

481 

482 

483 

484 

485 

486 

487 

488 

489 

490 

491 

492 

493 

494 

495 

496 

497 

498 

499 

500 

501 

502 

503 

504 

505 

506 

507 

508 

509 
513 

511 

512 

513 


eno; 

BEGIN <<7» 

yreg:=yreg + ii 
operand:=i; 

ROUNDCYREG) 

end; 

; << 8 » 

BEGIN <<9>> 

STACK(STACKPOINTER 1:=STACK(01« 
STACKPQINTER:=S7ACKP0INTER - 1 

end; 

BEGIN <<10» 

STACK(STACKPOINTER11=STATUS» 

stackpointer:=stackpoimter -i 

end; 

begin <<11 » 

STACKPOINTER:=STACKPOINTER ♦ IS 
STACK(01:=STACK(STACKPOINTER) 

end; 

BEGIN <<12» 

stackpointer:=stackpointer ♦ u 

ST A TUS:=STACK(STACKPOINTER! 

end; 

BEGIN <<13» 

stackpointer:=stackpointer ♦ IS 
counter:=stackcstackpointeri 

end; 

status-( 2:n: = i; <<14» 

xreg:=stack(oi; <<15» 

yreg:=stack(oi; <<i6» 

xreg:=stacxpointer+i; «17» 
stack(oi:=xreg; <<18>> 

BEGIN <<19>> 

stackpointer:=xreg; 
stackpointer:=stackpointer - 1 
end; 


stack(oi:=yres; 

return; 


IF 


< <20 >> 
« 21 >> 
<<22-29» 
«33>> 
«31>> 
<<32>> 


STACK(01 = 0 THEN 

branch; 

ST A C K ( 0 1 
branch; 

STACK(01 

branch; 

STACK(01 

branch; 

STATUS-(2:11=0 

branch; 

STATUS.(2:11=1 

branch; 

;; <<38-39>> 

BEGIN <<40» 

counter:=operand - is 

IF (COUNTER > LINENUMBER1 OR 


IF 

IF 

IF 

IF 

IF 


C 0 THEN <<33>> 
<> 0 THEN <<34» 
> 0 THEN «35>> 


THEN<<36>> 

THEN«37» 


(COUNTER < 1) THEN 






41 


PAGE 13 


514 

515 

516 

517 

518 

519 

520 

521 

522 

523 

524 

525 

526 

527 

528 

529 

530 

531 
5 32 

533 

534 

535 

536 

537 
533 

539 

540 

541 

542 

543 

544 

545 

546 

547 

548 

549 

550 

551 

552 

553 

554 

555 

556 

557 

558 

559 

560 

561 

562 

563 

564 
555 
366 
567 
563 

569 

570 


HEWLETT-PACKARD 32201A-7.12 EDIT/30Q0 WED* MAR 30* 1983* 5:30 PM (C) 

ERR0R:=17 

BEGIN <<41>> 

STACK(STACKPOINTER) :=C3UMT:.R; 

stackpointer:=stackpointer ♦ is 

IF U, (COUNrER e > A LINENUMBER) DR (COUNTER < 0) THEN 
error:=17 


end; 


<<42-49>> 

<<50» 


BEGIN 

xreg:=loaq; 

ROUND(XREGJ 

BEGIN <<51» 

treg:=load; 

ROUND(YREG) 

BEGIN <<52>> 

IF (OPERAND < 01 OR (OPERAND > OPLIMIT) THEN 
ERROR:=17 

ELiE STACK(OPERAND):=XR£G 

end; 

BEGHNp ^OPERAND < 01 OR (OPERAND > OPLIMIT) THEN 
__ERR0R:=17 

i ELU STACK (OPERAND) 5 = YRES 

<<54-59» 

BEGIN <<60» 

IF (OPERAND < 0) OR (OPERAND > OPLIMIT) THEN 

error:=18 

ELSE BEGIN 

STACK(OPERA'lO ) :=STACK(OPERAND) * 2* 
ROUND(3TACK(OPERAND)) 

end; 

end; 

BEGIN <<&!» 

IF (OPERAND < 0) OR (OPERAND > OPLIMIT) THEN 
ERROR:=18 
ELSE BEGIN 

STACK(OPERAND):=ST ACK(OPERA ND) ♦ li 
ROUND(31ACK(OPERAND)) 

end; 

ItACK(OPER AN0):=STACK(0PERAN0)/2;«62>> 

BEGIN <<63» 

IF (OPERANO < 0) OR (OPERANO > OPLIMIT) THEN 

error:=18 

ELSE BEGIN 

STACK(OPERAND):=STACK(OPERAND) - 13 
ROUND(STACK(OPERANO>) 

eno; 

end; 

BEGIN <<64» 





42 


PAGE 11 HEWLETT-PACKARD 322C1A.7.12 EDII/3300 WED* MAR 30. 1933, 5:30 PH (C3 


571 

572 

573 

574 

575 
575 
577 
573 
579 
530 

581 

582 

583 

584 

585 
588 

587 

588 

589 
5 90 

591 

592 

593 

594 

595 

596 

597 

598 

599 

500 

501 
602 

603 

604 

605 

606 
507 
60 3 

609 

610 
611 
612 
513 
814 

615 

616 

617 

618 

619 

620 
621 
622 

523 

524 

525 
826 
627 


IF (OPERAND < 3) OR (OPERAND > 0PLIMIT3 THEN 
ERRQR:=17 

ELSE 

STACK(0PERAN03:=STACK(33 

end; 

BEGIN <<65» 

LENGTH:=ASCIICLOAOtlO.OP8YTE3; 

length:=length * (- 13 ; 

IF STACK(0PLIHIT+13 = 0 THEN 
PRINT(OPBYTE,LENGTH,X3203; 

IF STACKCOPLIMIT+1) = 1 THEN 
PRINT(OPBYTEt LENGTH*- ■>i 
IF STACK(OPLI MIT*13 = 2 THEN 
PRINT(OPBYTE.LENGTH*-a-)5 
IF STACK(OPLIMIT+13 = 3 THEN 
PRINT(OPBYTE.LENGTH**!“I * 

IF STACK!OPLI MIT*13 > 3 THEN 
BEGIN 

warning:=3; 

PRINTUARNING(WARNING*WARNINGS3J 
PRINT(OPBYTE.LENGTH,- "1 

end; 

end; 

BEGIN «66» 

length:=read(opbyte.-4j; 

IF (OPERAND < 03 OR (OPERAND > OPLIMIT3 THEN 
ERR0R:=18 
ELSE BEGIN 

STACK(OPERAND 3:=BINARY(OPBYTE,LENGTHTJ 
ROUND(ST ACK(0PERAND3 3 

end; 

end; 

BEGIN «67>> 

opbyte(O):=byte(load>; 

IF STACK(OPLIMIT+13 = 0 THEN 
PRINT(OPBYTE!03,-1,13203; 


IF 


IF 

IF 

IF 


= 1 
*-l 
= 2 

t-1*' 

= 3 

,-l»* 

> 3 


THEN 

•>; 

THEN 

0-3; 

THEN 

i->; 

THEN 


STACK(OPLIMIT+13 
PRINT(0PBYTE(0 3 
ST ACK(OPLIMIT*13 
PRINT(OPBYTE(03 
STACK(OPLIMIT+ 13 
PRINT(OPBYTE(0 3 
STACK!OPLIHIT*13 
BEGIN 

warning:=3; 

PRINTWARNING!WARNING,WARNINGS3; 
PRINT(OPBYTE(03,-1.- -3; 

end; 

end; 

BEGIN <<6S>> 

REAO(OPBYTE,—13; 

IF (OPERAND < 03 OR (OPERAND > OPLIMIT3 
ERR0R:=13 
ELSE BEGIN 

STACK(OPERAND 3: = INTEGER(0P3YTE(0 3 3 ; 
ROUND(STACK(3PERAND3 3 

end; 


THEN 



43 


PAGE 12 HEWLETT-PACKARD 322Q1A.7.12 EDIT/SODO WED* MAR 30* 1983* 5230 PM <C) 


628 

629 

633 

631 

632 

633 

634 

635 

636 

637 

638 
S39 

640 

641 

642 

643 

644 

645 

646 

647 

648 

649 

650 

651 

652 

653 

654 

655 

656 

657 

658 

659 
86 3 
661 
662 

663 

664 

665 

666 

667 

668 

669 

670 

671 
6 72 

673 

674 

675 

676 

677 
578 

679 

680 
631 
682 

683 

684 


end; 

; <<S9>> 

BEGIN «70» 

STACK(0)2=L0AD+STACK(0>* 

ROUNQCSTACKCO)) 

end; 

BEGIN <<71>> 

ST ACK CO): = 1NTESER (L3GICALCSTACKCQ)) LAND 
LOGICAL(LOAD)); 

ROUNOCSTACKC3)) 


END ; 


<<72» 

<<73» 


BEGIN 

stackco)2=ldad; 

R OUNDCSTACK(0 >) 

end; 

BEGI STACKCO): = INTEGER(LOGICAL(STACK<0)J LOR <<74» 

logical(load)); 

RQUNDCSTACKCO)) 

end; 

BEGIN <<75>> 

STACKCO)2=STACK(0)-loao; 

ROUNOCSTACKCO)) 

end; 

STACK(OPLIMIT*1)2=L0A D « <C76>> 

end; 

IF STACKCD ) < 0 THEN STATUS.CO 21)2=1 
ELSE STATUS.<021)2=0? , 

IF STACKCO) = 0 THEN STATUS-C121)2=1 
ELSE STATUS.C121)2=0? 

IF STACKCO).<821) = 1 THEN STATUS.C521)2=1 
ELSE STATUS.C521)2=0; 

C OUNTER 2=COUNTER + IS 
L00P2 2=D0UBLE(COUNTER); 

FREAODIRC33JECTNUMBER.CODE* 3*L00»2)* 

IF > THEN E0F2=TRUE; 

IF < THEN MESSAGE; 

IF ERROR > 0 THEN 
BEGIN 

PRINTERROR(ERROR.ERRORS); 

MOVE DISPLAYLINE(0)2=30C" »); 

PRINTCDISPLAYLINE.—80." ■); 

MOVE DISPLAYLINE(0)2= „ 

■ 3 R OGR AM TERMINATED IN AN ERROR STATE*; 

PRINT(DISPLAYLINE.-80.“O*); 

EOF2=TRUE 

end; 


end; 

end; 

<< ***■»■»**.**+*+******* >> 
<< BEGINNING OF PROGRAM >> 
<< ******************** >> 


LINENUMBER 2=0; 
LABELMUMBER 2=0; 



44 


PASE 13 HEWLETT-PACKARD 32201A.7.12 EDIT/3300 WED, MAR 30, 1983, 5:30 PM (C) 


685 

585 

537 

583 

589 

590 

591 

592 
693 

594 

595 

596 

697 

698 

699 

700 

701 

702 

703 

704 

705 

706 

707 

708 

709 

710 

711 

712 

713 

714 

715 

716 

717 

718 

719 

720 

721 

722 

723 

724 

725 

726 

727 

728 

729 

730 

731 

732 

733 

734 

735 

736 

737 

738 

739 

740 

741 


VI 


variablenumberx=q; 
stackpointer:=oplimit; 

1OURCENUMBER:=FOPEN(SOURCEFILE *X5,X13 03 ,-72 Ji 
IF < THEM MESSAGE* 

o bjectnumber:=f opemcobjectfile, to,%5,3 >; 

IF < then message; 

FREAD<SOURCEMUMBER,LINE,-723; 

IF > then eof:=true; 

MOVE DISPLAYLINE:=-6502 ASSEMBLY LANGUAGE SIMULATOR- 
DATELINE (DISPLAYLINEC373); 

PRINTCDISPLAYLIME,-30,"0*3; 

MOVE DISPLAYLINE:=30(" "3; 

3RINT(DISPLAYLINE,-30,*0*3; 

WHILE NOT EOF DO 
BEGIN 

PARSER(LINENUHBERiiLINE.LABELS,LA8ELNUMBER, OPERATOR, 

TECHNIQUE.OPBYTE »OPLABEL,OPVAR IABLE,VARIABLES, 

ERROR,WARNING); 

CODEC 3 3:=OPCOOE(OPERATOR3 * 

MOVE DISPLAYLINE:=80 (» ■); TIJC . 11 

IF (COOE(0 3 <> 803 AND (COOE(O) O 31) THEN 
ASCII(LINENUMBER,10.DISPLAYLINECQ)3; 

FOR L00P: = 0 UNTIL 71 DO _ _„ , . 

0ISPLAYLINE(9*L00P):-LINE(L00P); 

LENGTH:=(-1)*(CURS0R+9>; 

PRIMT(OIS®LAYLINE,LENGTH," *3; . 

IF ERROR <> 0 THEN PRIMTERROR (ERROR,C.RR0RS3 , 

IF WARNING <> 0 THEN PRINTWARNING(WARNING,WARNINGS 35 

IF CODE(O) = 0 THEN 

BEGIN 

error:=3; 

PRINTERROR(ERROR,ERRORS 3 

IF^CODE(0 3 = 80 THEN ADDLABEL(LABELS,LABELNUMBER,OPLABEL3 5 
IF C ADDVAR I ABLE(VARIABLES,VARIA8LENUMBER,OPVARIABLE)J 

aooressing:=-i; _ 

TECHNIOUE = *#• THEN ADDRE3SING:=0; 

TECHNIQUE = THEN ADDRESSING:^; 

TECHNIQUE = "X* THEN A00RESSIMG:=2; 

TECHNIQUE = *Y* THEM ADDRESSIMS:=3; 

TECHNIQUE = »V* THEN ADORESSING:=i; 

TECHNIQUE = m L m THEN ADDRESSING:=6; 

TECHNIQUE = "I" THEN AD0RES3IN3:=4; 

TECHNIQUE = "P* THEN ADDRESSING:=4, 

TECHNIQUE THE?1 ADORESSING:=5; 

IF D (C0Dif0)<2i) S AN0 ; (C00E(3)O0) AND (TECHNIQUE<>*-*3 THEN 

(CODe1o)>=30) AND (CDDE(0)<40) AMD (TECHNIQUE<>*L»> 

AND (TECHNIQUEO" #* > THEN ERR0Rt=li; 

(CODE(03>=403 ANO (CODE(0)<50) AND (TECHNIQUEO"L*3 
AND ( T ECHNIQUEO" #") THEN ERROR :=12; 

(CODE (0 ) >=50 3 AND (CODE (0><60 ) AND (TECHNIQUEO*# > 


IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 

IF 


IF 

IF 


IF 



45 


PA3E 14 HEWLETT-PACKARD 322Q1A-7.12 EDIT/3200 WED* MAR 30* 1983* 5J3C PM (C) 


742 

743 

744 

745 

746 

747 

748 

749 

750 

751 

752 

753 

754 

755 

756 

757 

758 

759 

760 

761 

762 

763 

764 

765 

766 

767 

768 

769 

770 

771 

772 

773 

774 

775 

776 

777 

778 

779 

780 

781 

782 

783 

784 

785 

786 

787 

788 

789 

790 

791 

792 

793 

794 

795 

796 

797 

798 


IF 


IF 


IF 

IF 

IF 

IF 


AMD < TECHNIQUEO 
(TECHNIQUEO*I*> 
tCODE( 3 )>=60) AMD 
AMD (TECHNIQUEO 
(TECHNIQUEO"V “) 
(TECHNI QUEO*P* ) 
(C00E(3)>=70) AND 
■S*) AMD (TECHNI 
(TECHNI QUEO" V") 
(TECHNI QUEO"P*) 
(CODE(Q)=80) AND 
£RR0R:=13i 
(CODE(0)=81) AND 
error:=i3j 
ERROR >0 THEN PRI 


»S») AMO (TECHNI QUEO*V*> AND 
ANO (TECHNIDUE<>“P*) THEN ERR0R:=13? 
(CODE(0)<70) AMD ( TECHNI QUE 0*i" ) 
•X») AND (TECHNIQUEO* Y«) AND 
AND (TECHNIQUEO*I*) AND 
THEN error:=13; 

(TECHNIQUEO*#*) ANO (TECHNIQUEO 
QUEO" X*) AND (TECHNIQUEO"Y»> AND 
ANO ( TECHNIQUEO* I *3 AND 
ANO (CODE(3)<83)THEM E3R0R: = 13; 
(TECHNIQUE O *L*> THEN 

(TECHNIQUE O *V") THEN 

NTERR0R(ERROR*ERRORS); 


OR 


( TECHNIQUE="X») 
THEN 


(TECHNIQUE=«#*> OR (TECHNIQUES***) 

OR (TECHNIQUE=*Y*) OR (TECHNIQUES 
C30E(2):=8INARY(0P9YTE * 4 )i 
IF (TECHNIQUE=*V“) OR (TECHNIQUEs*P*> THEN 
BEGIN 

code(2 ):=-i; 

FOR L00p:=0 STEP 10 JWTIL VARIA3LENUH9ER DO 
BEGIN 

testvariable:^ true; 

FOR LOOPl:=0 UNTIL 9 DO 

IF VARIA8LZ3( L00P-*L00P1) OOPV ARI ABLE ( L00P1 ) 

testvaria3le:=false; 

IF TESTVARIABLE then 
C 0DE(2)IsLOOP/10*1 

end; 

IF CODE(2) = -1 THEN 
BEGIN 

ERROR := 4 ; 

PR INTERRORIERROR*ERRORS) 

END? 

end; 

IF TECHNIQUE = *L* THEN 
BEGIN 

code(2 ):=-i; 

FOR L00P:=0 STEP 13 UNTIL LABELNUH3ER DO 
BEGIN 

testlabel:= true; 

FOR LOOPING UNTIL 9 DO 

IF LABELS(LOOP+LOOP1) O OPLABEL(LOOPl) THEN 

testlabel:= -alse; 

IF TESTLABEL THEN 

C0DE(2>:=L00P/10 

end; 

IF CODE(2)=—1 THEN 
BEGIN 

error;=5; 

PR INTERROR(ERROR*ERRORS) 


THEN 


end; 

end; 

IF (CODE(O) <> 80) ANO (CODE(O) <> 31) THEN 
BEGIN 



46 


PAGE 15 


HEWLETT-PACKARD 32201A.7.12 £017/3000 WED* MAR 30* 1983* 5:30 PM (C) 


7gg D0UBLENUMBER:=00U8LE( LINENUMBER ) ? 

30 9 FWRITEDIR(OBJECTNUMBER »CODE,3»DOUBLENUMBER)i 

301 IF < THEN MESSAGE? 

802 END 

803 ELSE LINENUMBER:=LINENUMBER - 15 

804 FREAD(S0URCENUMBER,LlNE»-72); 

305 IF > THEN EOF: = TRUE; 

806 IF < THEN MESSAGE; 

307 ENO; 

308 << CONTINUE WITH RUN OF PROGRAM I r NO ERRORS >> 

809 MOVE 0ISPLAYLINE:=80(* ">; 

310 PRINT (DISPLAY LINE. -80 *■•0*15 

311 MOVE DISPLAYLIME(0):="NUMBER OF ERRORS:*? 

812 ASCII(ERRORS,10,DISPLAYLIN£(19))? 

313 MOVE 0ISPLAYLINEC25)I=*NUM8ER OF WARNINGS:*? 

314 ASCII(WARNINGStlO.OISPLAYLINEC45)>i 

815 PRINT (DI SPLAYLINE *-80 , "0 * ) ; .. 

316 IF ERRORS = 0 THEN 

317 BEGIN 

818 MOVE DISPLAYLINE:=80(* ") i 

319 MOVE DISPLAYLINE:=*END of compile STEP*; 

820 PRINT(DISPLAYLINE,-8Q,*0*); 

321 PREPARE (LABELNUMBER »LABELS » LABEL.REF) ? 

322 IF ERROR = 0 THEN 

324 3EGI MDVE DISPLAYLINE:=*ENO OF PREPARE STEP*? 

325 PRINTOISPLAYLINE »—80 ,*0*)? 

826 RUN 

827 END 

323 ELSE BEGIN 

829 PRINTERROR(ERROR,ERRORS)? 

330 MOVE DISPLAYLINE:=*PRQGRAM TERMINATED IN AN ERROR 

331 PRINT(DISPLAYLINE,—90,*0“) 

832 END? 

833 END 

334 ELSE BEGIN 

835 MOVE DISPLAYLINE:=80(* *)? 

336 MOVE OISPLA YLINE:="PROGRAM 

337 PRINT(DISPLAYLINE »-30,*0") 

838 end; 

839 END. 


STATE*? 


TERMINATED IN AN ERROR STATE*? 



47 


APPENDIX E: SUPPLIMENTARY MATERIAL FOR USE WITH THIS SYSTEM 

THE NATURE OF THE SYSTEM—COMPILER, ASSEMBLER, OR SIMULATOR ? 

When electronic computers were first manufactured, 
the programmer had only the most primitive methods to 
program it. All programming was done through binary codes, 
a switch-flipping type process which was slow and tedious. 
It shortly became apparent that there must be a better way. 

A better way came with the advent of assemblers. 
These programs took other programs written in an "assembly 
language" code and translated them into a machine language 
that the computer could understand. Assemblers made the 
task of programming much less tedious, but the language was 
still machine-dependent—that is, one assembly language 
command executed only one machine instruction. In order to 
realize the full power of the computer, a language had to be 
developed that would execute several machine tasks with one 
command, keep track of tables and arrays, and generally 
free the programmer to concentrate on the finer points of 
programming. 

These higher level languages (among the most notable 
are BASIC, FORTRAN, COBOL, RPG, AND PASCAL) were developed 
with this goal in mind. The programs used to break these 
languages down into machine language are called compilers. 
Compilers are usually written in assembly language. 



48 


Unfortunately, computer science is noted for 
exceptions, and Hewlett-Packard fits the bill. They 
developed a language, Systems Programming Language (SPL), 
which was designed to be high-level language, yet still 
machine-oriented. SPL would then be used to write 
compilers, supervisors, and utility programs. The assembly 
language is still present, in a sense, but it is buried 
beneath other options designed to increase the power and 
useability of the language. 

SPL is an effective and powerful language, but it is 
inappropriate to use as a learning tool in a beginning 
assembly language course. The student must grasp the basic 
concepts of assembly language itself before trying to handle 
the intricacies of SPL. It was with this problem in mind 
that I set out to develop a simpler assembly language to use 
on the Hewlett-Packard. 

Ironically, I found SPL to be the most suitable 
language to program the system. In order to write a 
compiler/assembler for a language that was machine oriented, 

I had to program it in a language that was also machine 
oriented. Also, SPL is a fast-executing language, desirable 
for a system which is already burdened with excessive 
demands from interactive users. 

While Hewlett-Packard has its own machine instruction 
set, it has no real assembly language of its own, therefore 
I had to choose another well-known assembly language to 



49 


simulate on the HP machine. I chose a language based on the 
6502 microprocessor. This is a relatively simple language 
to learn and many students would already be familiar with it 
through existing microprocessor courses. 

This simulator acts like an assembler, but is 
actually written in SPL, a high-level language. This 
process is "transparent" to the user, meaning that in all 
respects, the system looks and acts like an assembler, when 
in actuality it is only simulating one. In all appearances, 
the student is using assembly language. 


THE SOURCE CODE 

In SPL, all procedures must come before the main 
part of the program, so the program actually starts at line 
683. The program executes as follows: 

INITIALIZATION (LINES 683-699): 

Assigns starting values, opens the input and object 
files and prints the heading. 

PARSER (LINES 119-251): 

Breaks each string of characters in a line of code 
down into its component parts. This procedure uses another 
procedure called OPERATOR (lines 55-117), which assigns a 
code to the parsed operator. 



50 


SOURCE LISTING (LINES 706-720): 

Prints the source listing plus any error or warning 
messages resulting from syntax errors detected by the 
parser. PRINTERROR (lines 253-282) and PRINTWARNING (lines 
284-299) are the two procedures used with this block of 
code. 

LABEL ADDITION (LINES 314-335) 

Adds any labels to the label table as specified by a 

LAB command. 

VARIABLE ADDITION (LINES 337-359) 

Adds any labels to the label table as specified by a 

VAR command. 

ADDRESSING TECHNIQUE CHECK (LINES 724-796) 

Checks to make sure the proper operand is used with 
the addressing technique, and assigns numerical values to 
variables and labels. 

OBJECT FILE GENERATION (LINES 797-8070 

Generates the "object" file to be used in the 
execution phase. 

PREPARATION FOR EXECUTION (LINES 361-381) 

Modifies the object file to replace label numbers 
with the actual line numbers in branch statements. 



51 


EXECUTION (LINES 414-617) 

Executes the object code. Three procedures are used 
with this block of code—LOAD (lines 383-319), which loads a 
value dependent on the addressing technique, BRANCH (lines 
393-402), which handles conditional and unconditional 
branching, and ROUND (lines 404-412) which handles data 
overflows and sets the overflow flag. 

VARIABLE LIST 

The following is a list of all variables used by the 
source code: 

INTEGERS- 

LINENUMBER - the program counter 

LABELNUMBER - first empty position in the label 
array 

VARIABLENUMBER - first empty position in the 

variable array 

ERROR - current error number 

ERRORS - total number of errors 

WARNING - current warning number 

WARNINGS - total number of warnings 

SOURCENUMBER - input file number 

OBJECTNUMBER - "object" file number 

LOOP, LOOPl, LOOP2 - used for loop counters 

STACKPOINTER - program stack pointer 

XREG - X-register 

YREG - Y-register 



52 


STATUS - status register 

COUNTER - current line number during execution 

OPERAND - current operand during execution 

CURSOR, LAST - substring pointers used for parsing 

LENGTH - length of input/output strings 

ADDRESSING - object code addressing technique 

DOUBLENUMBER - double word number needed for certain 

functions 


ARRAYS OF INTEGERS 

STACK - program stack 

CODE - "object" code 

LABELREF - label reference table 

ARRAYS OF CHARACTERS 

SOURCEFILE - input file name 

OBJECTFILE - "object" file name 

LINE - unparsed source line 

LABELS - label list 

VARIABLES - variable list 

OPERATOR - parsed operator 

OPBYTE - parsed operand if an ASCII digit 

OPLABEL - parsed operand if a statement label 

OPVARIABLE - parsed operand if a variable 

TECHNIQUE - parsed addressing technique 

DISPLAYLINE - output line buffer 



53 


LOGICAL VARIABLES- 

EOF - end-of-file flag 
TESTVARIABLE - variable test flag 
TESTLABEL - label test flag 

INCREASING MEMORY CAPABILITY 
The system was originally set up with a stack limit 
of 100 and space for 20 variables and 20 labels. This may 
be expanded by making small changes to the source code and 
re-compiling it. 

Line 25 defines the upper limit of the stack. The 
line can be changed to reflect the new upper limit. 

Line 28 defines the stack array itself, including 
the carriage control character. The stack should be 
redefined so that there will be one byte available for the 
carriage control character. For instance, if the stack 
limit defined in line 25 is 200 , the stack itself should 
have a lower limit of 0 and an upper limit of 201. Position 
0 would be the accumulator, positions 1-200 would be the 
program stack, and position 201 would be the carriage 
control character. 

Lines 37-38 define the label and variable stack. 
The upper limit is determined by multiplying the maximum 
number of variables or labels by 10, then subtracting 1. 
For instance, if the maximum number of labels desired is 50, 
then the upper limit would be 50 x 10 - 1 = 499. 



54 


Line 30 defines the label cross-reference table. 
Its upper limit should be redefined to be one less than the 
maximum number of labels desired. 



55 


APPENDIX F: SAMPLE PROGRAMS 



'•JOB SAFIGAN-PHYSICS#SAFIGAN 
PRIORITY = OS* IMPRI = 3# TIME 
JOB NUMBER = #J735 
JED# MAR 0 O 1 198 2*.„ 5 A* 3 PM 
HP3303 / MPE Itf C.A0.20 
JFILE SOURCE=SOURCEA 
IRUN EUREKA 


= UNLIMITED SECONDS 


56 


£502 ASSEMBLE LANGUAGE 


SIMULATOR- Vl JED# MAR 30# 1333# 5IA3 PM 


1 

2 

3 

A 

5 

6 

7 

8 

9 

10 
11 
12 
13 
1A 
15 
la 
17 
13 
END 


lab 

L START 

LDA 

#Q0A5 

ST A 

$0 005 

LDX 

itaoao 

start: txa ■ 

AOC 

#0001 

CCT 

#0000 

PRT 

$0000 

PR A 

$0 0 05 

PR A 

$0005 

PRA 

$0 005 

PR A 

$0 005 

CCT 

#0001 

PRA 

$0000 

TAX 

-OOQO 

ADC 

#0128 

BNE 

L START 

STP 

-0 000 

MOP 

- 0000 


-0300 


OF FILE (FSERR 3) 


number of errors: o 

END OF COMPILE STEP 
END OF PREPARE STEP 



number of warnings: o 




41 - 

42 - 

43 - 

44 - 

45 - 

46 - 

4 7- 

48 - 

49 - 

50 - 

51 - 

52 - 

53 - 

54 - 

55 - 

56 - 

57 - 

58 - 

59 - 

60 - 

61- 

62- 

63 - 

64 - 

65 - 

66 - 

67 - 

68 - 

69- 

73- 

71 - 

72 - 

73 - 

74 - 

75 - 

76 - 

77 - 

78 - 

79 - 

30- 

81- 

82- 

83 - 

84 - 

85 - 

86 - 

87 - 

88 - 

89 - 

90 - 

91 - 

92 - 

93 - 

94 - 

95— 

96 - 

97 - 

98 - 

99— 

130 — 

131 — 
102 — 
103 — 
104— 
105 — 

136— 

137— 
138 — 
109 — 
110 — 
111 — 
na- 

iii— 

114 — 

115 — 

116 — 
117— 
118 — 
119— 
120 — 





58 


121 

122 

123 

124 

125 
125 

127 

128 



END OF PROGRAM 

:eo j 

CPU SEC- = 11- 


ELAP3ED MIN. 


= 1 - 


UEDt MAR 30* 1933* 5144 PM 



! :J08 CARL.COBOL*assembly 





PRIORITY = os; INPRI = 8; TIME = UNLIMITED SECONDS ' 


JOB NUMBER = 4J736 





UEO» MAR 3G» 1383* 5:49 PM 





HP30 00 / MPE IV C.AG.20 





:A3SEMBL£G0 MPLY3 



59 


6502 ASSEMBLY LANGUAGE SIMULATOR- 

VI WED* 

MAR 30* 1933* 5:50 PM 



LAB 

L 

3E3IN 



LAB 

L 

END 



LAB 

L 

MULTIPLT LOOP 



LAB 

L 

ADD 



LAB 

L 

NO PRODUCT OVERFLOW 



LAB 

L 

DOIT'T ADD ” 



LAB 

L 

NO MPElCANO overflow 



LAB 

L 

wrtte ERROR” 



VAR 

V 

mplicjtno 



VAR 

V 

MPLIER 



VAR 

V 

PRODUCT 


i begin: 

CCT 

4 

0 000 


2 

LDA 

9 

0201 


3 

PRA 

s 

0000 


4 

LDA 

4 

0238 


5 

PRA 

$ 

0000 


6 

LDA 

9 

0240 


7 

PRA 

S 

0000 


3 

LDA 

9 

0245 


9 

PRA 

$ 

0 000 


10 

LDA 

4 

0244 


11 

PRA 

i 

0 000 


12 

LDA 

9 

0032 


13 

PRA 

5 

0000 


14 

LDA 

9 

0244 


15 

PRA 

S 

0000 


16 

LDA 

9 

0119 


17 

PRA 

S 

0000 


18 

LOA 

9 

0111 


19 

PRA 

I 

3000 


20 

LDA 

4 

0032 


21 

PRA 

% 

0000 


22 

LDA 

9 

0238 


23 

PRA 

S 

0000 


24 

LDA 

4 

0117 


25 

PRA 

$ 

0000 


26 

LDA 

9 

0109 


27 

PRA 

t 

3000 


28 

LOA 

4 

0098 


29 

PRA 

i 

0000 


30 

LDA 

4 

0101 


31 

PRA 

i 

0000 


32 

LDA 

4 

0114 


33 

PRA 

$ 

0030 


34 

LDA 

4 

0115 


35 

CCT 

4 

0001 


36 

PRA 

S 

0000 


37 

INP 

V 

MPLICAND 


38 

INP 

V 

MPLIER 


39 

LDA 

4 

0000 


40 

3TA 

V 

PRODUCT 


41 MULTIPLY LOOP! 

LOA 

4 

0001 


42 

AND 

V 

MPLIER 


43 

BEQ 

L 

DON *T ADD 


44 aoo: 

LDA 

V 

PROOUCT 


45 

ADC 

V 

MPLICAND 


46 

BVS 

L 

WRITE ERROR 


47 NO PRODUCT OVERFLOW: 

STA 

V 

PRODUCT 


48 ~ UON* T ADO: 

LSR 

V 

MPLIER 


49 

LDA 

4 

0255 


50 

SBC 

V 

PROOUCT 


51 

SBC 

V 

MPLICANO 


52 

SBC 

V 

MPLICAND 


53 

BVS 

L 

WRITE ERROR 


54 NO MPLICAND OVERFLOW: 

A3L 

V 

MPLICffND 


55 “ 

LDA 

V 

MPLIER 


56 

BNE 

L 

MULTIPLY LOOP 


57 

PR T 

V 

PROOUCT ” 


58 

JMP 

L 

END 




59 

63 

61 

62 

63 

64 

65 

66 

67 

68 
69 
73 

END OF FILE 


WRITE ERROR 


END 


(FSERR 0) 


LDA 9 3101 
PRA $ 0000 
LDA 9 3114 
poft j 3000 
LDA 4 3114 
PRA S 0333 
LDA 9 0111 
PRA 5 3303 
LDA * 3114 
PRA S 0003 
3TP “ 0300 
NOP - 0003 


60 


NUMBER OF ERRORS: 0 NUMBER OF WARNINGS: 0 

END OF COMPILE STEP 

END OF PREPARE STEP 

Input two nunbsrs 12,13 
156 

END OF PROGRAM 

£PU J SEC. = 5. ELAPSED MIN. = 1- WED* MAR 30, 1933, 5:50 PH 



Steve Safigan attended Mississippi College from 1979 
to 1983, where he majored in mathematics and computer 
science. He currently works with Southern Farm Bureau Life 
Insurance Company as an Actuarial Student. 


