An-/V94? 273 MENTATION PAGE 

_ IIBII !■■■■ nil III! ^ 1 »Mlir MAMMA inHta«1irM (Ka Mma f<sr -• :■ 


Fom Approved 
OPMNo. 0704-0188 


] iMtag* t hour par rtoponu. Including Iho dm* lor lOMOwing MrucUom. (ouching oxIMIng da> toucao galharing and m a inli n ing tw data 
ragaidmg diia budan aatimata or any othar aapad ol dila coiaction d Mormaiion, Including auggaatlona for ladudng diia burdan, to W a ihinglon 
lorta. 1215 Jallarson Oavia Highway. Suia 1204. Artngfon. VA 22202-4302, and to lha Ollica of Moimation and RagUaloiy Altaira. Ollica dl 


12. REPORT DATE 


3. REPORT TYPE AND DATES CX3VERED 

Rnal; 17 May 1991 to 01 Jun 1993 


4. TITLE AND SUBTITLE 

Ada Compiler Validation Summary Report: U. S. NAVY, AdaVAX, Version 5.0, 
(/OPTIMIZE), VAX11/785 (Host & Target), 910517S1.11164 


6. AUTHOR(S) 

National Institute of Standards and Technology 
Gaithersburg, MD * ; 

USA 


7 PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) . 

National Institute of Standards and Technology \ 

National Computer Systems Laboratory ■ '' 

Bldg. 255, Rm A266 
Gaithersburg, MD 20899 USA 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, RM 3E114 
Washington, D.C. 20301-3081 


11. SUPPLEMENTARY NOTES 


^ r 





8. PERFORMING ORGANIZATION 
REPORT NUMBER 

NIST90USN510 3 1.11 


10. SPONSORING/MONITORING AGENCY 
REPORT NUMBER 


U'y\ 


12a DISTRIBUTION/AVAILABILITY STATEMENT 

Approved for public release; distribution unlimited. 


12b. DISTRIBUTION CODE 


13. ABSTRACT (Maximum 200 words) 

U. S. NAVY, AdaVAX, Version 5.0, Gaithersburgh, MD, (/OPTIMIZE), VAX11/785 (Host & Target), ACVC 1.11. 




14 SUBJECT TERMS 


Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17 SECURITY CLASSIFICATION 
OF REPORT 

UNCLASSIFIED 


18, SECURITY CLASSIFICATION 


UNCLASSIFED 


19. SECURITY CLASSIFICATION 
OF ABSTRACT 

UNCLASSIFIED 


IS. NUMBER OF PAGES 


16. PRICE CODE 


20, LIMITATION OF ABSTRACT 


1104 iol 


NSN 7540-01-280-550 


Standard Form 298, (Rev 2-89) 
Prescribed by ANSI Std. 239-128 















AVF Control Number: NIST90USN510_3_1.11 
DATE COMPLETED 

BEFORE ON-SITE; 1991-04-05 
AFTER ON-SITE: 1991-05-17 
REVISIONS: 1991-07-24 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 910517S1.11164 
U.S. NAVY 

AdaVAX, Version 5.0 (/OPTIMIZE) 
VAX 11/785 *> VAX 11/785 


Prepared By; 

Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
■Gaithersburg, Maryland 20899 


; /.c 

'j-'>.*i 




' if 


‘ r. If rt* 

; cf, sr :'ll 



AVF Control Number: NIST90USN510_3_1.11 
Certificate Information 


The following Ada implementation was tested and determined to pass 
ACVC 1.11. Testing was completed on 17 May 1991. 

Compiler Name and Version: AdaVAX, Version 5.0 (/OPTIMIZE) 

Host Computer System: VAX 11/785, running VAX/VMS Version 

5.3 

Target Computer System: VAX 11/785, running VAX/VMS Version 

5.3 

A more detailed description of this Ada implementation is found in 
section 3.1 of this report. 

As a result of this validation effort. Validation Certificate 
910517S1.11164 is awarded to U.S. NAVY. This certificate expires 
on 01 March 1993. 


This report has been reviewed and is approved. 



A'da^Val idatior 
Dr. David K. 

Chief, Information Systems 
Engineering Division (ISED) 



Validation Group 


Computer Systems Laboratory (CLS) 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


Ada Validation Organization 
Director, Computer & Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 


Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 



DECLARATION OF CONFORMANCE 


The following declaration of conformance was supplied by the 
customer. 


DECLARATION OF CONFORMANCE 


Customer: U.S. NAVY 

Certificate Awardee: U.S. NAVY 

Ada Validation Facility: National Institute of Standards and 

Technology 

Computer Systems Laboratory (CSL) 
Software Validation Group 
Building 225, Room A266 
Gaithersburg, Maryland 20899 

ACVC Version: 1.11 


Ada Implementation: 

Compiler Name and Version: AdaVAX, Version 5.0 (/OPTIMIZE) 

Host Computer System: VAX 11/785, running VAX/VMS Version 

5.3 

Target Computer System: VAX 11/785, running VAX/VMS Version 

5.3 

Declaration: 


I the undersigned, declare that I have no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STD-1815A ISO 
8652-1987 in the implementation listed above. 


Customer 


signature 



Company U.S. Navy 
Title.' 



Certificate Awardee Signature 



Date' 


Company U.S. Navy 
Title 





TABLE OF CONTENTS 


CHAPTER 1.1-1 

■ INTRODUCTION.1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT .... 1-1 

1.2 REFERENCES. 1-1 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2...«••••••••••••••••••••••2—1 

IMPLEMENTATION DEPENDENCIES . 2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-5 

CHAPTER 

PROCESSING INFORMATION . 3-1 

3.1 TESTING ENVIRONMENT . 3-1 

3-2 SUMMARY OF TEST RESULTS.3-2 

3.3 TEST EXECUTION.'. . . 3-2 


APPENDIX A.A-1 

MACRO PARAMETERS.A-i 

APPENDIX B.B-1 

COMPILATION SYSTEM OPTIONS . B-1 

LINKER OPTIONS . B-2 

APPENDIX C.C-1 

APPENDIX F OF THE Ada STANDARD.C-1 
























CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro90] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to [Pro90]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552) . The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from; 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to; 


Ada Validation Organization 
Computer and Software Engineering Division 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311-1772 


1.2 REFERENCES 

[Ada83] Reference Manual for the Ada Programming Language . 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro90] Ada Compiler Validation Procedures . Version 2.1, Ada Joint 
Program Office, August 1990. 




[UG89] Ada Compiler Validation Catjabilitv User's Guide . 21 June 
1989 . 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK_FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued, class B 
tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that 
all violations of the Ada Standard are detected. Some of the class 
B tests contain legal Ada code which must not be flagged illegal by 
the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values — for example, the 
largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 
the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1; and, possibly some inapplicable tests (see Section 3.2 


1-2 


and [UG89]). 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler The software and any needed hardware that have to 
be added to a given host and target computer 
system to allow transformation of Ada programs 
into executable form and execution thereof. 


Ada Compiler 
Validation 
Capability 
(ACVC) 


The means for testing compliance of Ada 
implementations. Validation consisting of the 
test suite, the support programs, the ACVC 
Capability user's guide and the template for 
the validation summary (ACVC) report. 


Ada An Ada compiler with its host computer system and 

Implementation its target computer system. 


Ada The part of the certification body which carries 

Validation out the procedures required to establish the 

Facility (.AVF) compliance of an Ada implementation. 

Ada The part of the certification body that provides 

Validation technical guidance for operations of the Ada 

Organization certification system. 

(AVO) 

Compliance of The ability of the implementation to pass an ACVC 
an Ada version. 

Implementation 


Computer 

System 


Conformity 


A functional unit, consisting of one or more 
computers and associated software, that uses 
common storage for all or part of a program and 
also for all or part of the data necessary for 
the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including 
arithmetic operations and logic operations; and 
that can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 

Fulfillment by a product, process or service of 
all requirements specified. 


1-3 




Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Imp1ementation 


Validation 


Withdrawn 

test 


An individual or corporate entity who enters into 
an agreement with an AVF which specifies the terms 
and conditions for AVF services (of any kind) to 
be performed. 

A formal statement from a customer assuring that 
conformity is realized or attainable on the Ada 
implementation for which validation status is 
realized. 

A computer system where Ada source programs are 
transformed into executable form. 

A test that contains one or more test objectives 
found to be irrelevant for the given Ada 
implementation. 

Software that controls the execution of programs 
and that provides services such as resource 
allocation, scheduling, input/output control, 
and data management. Usually, operating systems 
are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada 
programs are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated 
successfully either by AVF testing or by 
registration [Pro90]. 

The process of checking the conformity of an Ada 
compiler to the Ada programming language and of 
issuing a certificate for this implementation. 

A test found to be incorrect and not used in 
conformity testing. A test nay be incorrect 
because it has an invalid test objective, fails 
to meet its test objective, or contains erroneous 
or illegal use of the Ada programming language. 


1-4 




CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 94 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 91-05-03. 


E28005C 

B28006C 

C34006D 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

383025D 

B33026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 




2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Issues and commonly referenced in the 
format Al-dddd. For this implementation, the following tests were 
inapplicable for the reasons indicated; references to Ada Issues 
are included as appropriate. 

• 

The following 285 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 


C24113F..Y (20 tests) 
C35706F..Y (20 tests) 
C35708F..Y (20 tests) 


1-1 


C35705F..Y (20 tests) 
C35707F..Y (20 tests) 
C35802F..Z (21 tests) 






C45241F..Y (20 tests) 
C45421F..Y (20 tests) 
C45524F..Z (21 tests) 
C45641F..Y (20 tests) 


C45321F..Y (20 tests) 
C45521F..Z (21 tests) 
C45621F..Z (21 tests) 
C46012F..Z (21 tests) 


The following 21 tests check for the predefined type SHORT_INTEGER; 
for this implementation, there is no such type: 


C35404B 

B36105C 

C45231B 

C45304B 

C45411B 

C45412B 

C45502B 

C45503B 

C45504B 

C45504E 

C45611B 

C45613B 

C45614B 

C45631B 

C45632B 

B52004E 

CD7101E 

C55B07B 

B55B09D 

B86001V 

C86006D 

C45231D, 

B86001X, 

C86006E, and 

CD7101G 

check for 


predefined integer type with a name other than INTEGER, 
LONG_INTEGER, or SHORT_INTEGER; for this implementation, there is 
no such type. 


C35713B, C45423B, B86001T, and C86006H check for the predefined 
type SHORT_FLOAT; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with 
a name other than FLOAT, LONG_FLOAT, or SHORT_FLOAT; for this 
implementation, there is no such type. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater? for 
this implementation, there is no such type. 

C45624A..B (2 tests) check that the proper exception is raised :f 
MACHINE_OVERFLOWS is FALSE for floating point types; for this 
implementation, MACHINE_OVERFLOWS is TRUE. 

B86001Y uses the name of a predefined fixed-point type other thar 
DURATION; for this implementation, there is no such type. 

C96005B checks for values of type DURATION'BASE that are outside 
the range of DURATION; for this implementation, there are no such 
values. 


> 


CD1009C checks whether a length clause can specify a non-default 
size for a floating-point type; this implementation does not 
support such sizes. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length 
clauses to specify non-default sizes for access types; this 
implementation does not support such sizes. 

AE2101C and EE2201D..E (2 tests) use instantiations of package 
SEQUENTIAL_IO with unconstrained array types and record types with 


2-2 




discriminants without defaults; these instantiations are rejected 
by this compiler. 

AE2101H, EE2401D, and EE2401G use instantiations of package 
DIRECT_IO with unconstrained array types and record types with 
discriminants without defaults; these instantiations are rejected 
by this compiler. 

The tests listed in the following table are not applicable because 
the given file operations are supported for the given combination 
of mode and file access method. 


Test 

File Operation Mode 

File Access 

Method 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL 

10 

CE2102F 

CREATE 

INCUT FILE 

DIRECT 10 


CE2102J 

CREATE 

OUT FILE 

DIRECT 10 


CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 

10 

CE21020 

RESET 

IN FILE 

SEQUENTIAL 

10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 

10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 

10 

CE2102R 

OPEN 

INOtJT FILE 

DIRECT 10 


CE2102S 

RESET 

INOUT FILE 

DIRECT 10 


CE2102T 

OPEN 

IN FILE 

DIRECT 10 


CE2102U 

RESET 

IN FILE 

DIRECT 10 


CE2102V 

OPEN 

OUT FILE 

DIRECT 10 


CE2102W 

RESET 

OUT FILE 

DIRECT 10 


CE3102F 

RESET 

Any Mode 

TEXT 10 


CE3102G 

DELETE 

TEXT 10 


CE3102I 

CREATE 

OUT FILE 

TEXT 10 


CE3102J 

OPEN 

IN FILE 

TEXT 10 


CE3102K 

OPEN 

OUT FILE 

TEXT 10 



The tests listed in the following table are not applicable because 
the given file operations are not supported for the given 
combination of mode and file access method. 


Test 


File Operation Mode 


File Access Method 


CE2105A 

CE2105B 

CE3109A 


CREATE 

CREATE 

CREATE 


IN_FILE 
IN_FILE 
IN FILE 


SEQUENTIAL_IO 
DIRECT_IO 
TEXT 10 


CE2107B..D (3 tests), CE2110B, and CE2111D check operations on 
sequential files when multiple internal files are associated with 
the same external file and one or more are open for writing; 
USE_ERR0R is raised when this association is attempted. 


CE2107E and CE2107L check operations on direct and sequential files 
when files of both kinds are associated with the same external 
file; USE_ERR0R is raised when this association is attempted. 


2-3 






CE2107G..H (2 tests), CE2110D, and CE2111H check operations on 
direct files when multiple internal files are associated with the 
same external file and one or more are open for writing; USE_ERROR 
is raised when this association is attempted. 

CE2203A checks that WRITE raises USE_ERROR if the capacity of an 
external sequential file is exceeded; this implementation cannot 
restrict file capacity. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of an 
external direct file is exceeded; this implementation cannot 
restrict file capacity. 

CE3111B, CE3111D..E (2 tests), CE3114B, and CE3115A check 
operations on text files when multiple internal files are 
associated with the same external file and one or more are open for 
writing; USE_ERROR is raised when this association is attempted. 

CE3413B checks that PAGE raises LAy0UT_ERR0R when the value of the 
page number exceeds COUNT'LAST. For this implementation, the value 
of COUNT'LAST is greater than 150000 making the checking of this 
objective impractical. 


2.3 TEST MODIFICATIONS 


Modifications (see section 1.3) were required for 41 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in 


the way expected by the 

original 

tests. 



B22003A 

B22004A 

B23004A 

B24005A 

B24005B 

B28003A 

B33201C 

B33202C 

B33203C 

B33301B 

B37106A 

B37301I 

B38003A 

B380033 

B38009A 

B38009B 

B44001A 

B44004A 

B54A01L 

B55A01A 

B61005A 

B85008G 

B85008H 

B95063A 

B97103E 

BBIOOSB 

BC1102A 

BC1109A 

BC1109B 

BC1109C 

BC1109D 

.BC1201F 

BC1201G 

BC1201H 

BC1201I 

BC1201J 

BC1201L 

BC3013A 

BE2210A 

BE2413A 




"PRAGMA ELABOPATE (REPORT)" has been added at appropriate points in 
order to solve the elaboration problems for: 

C83030C C360C7A 


Parens were inserted into the various expressions that produce 
out-of-range intermediate values in order to force the evaluation 
order and thus avoid the exception. For the two tests, the 
particular TModifications are; 

[for C34005P] 


2-4 




at line 187, "I - X'FIRST" => "(I - X'FIRST)", yielding: 

IF NOT EQUAL (X (I), Y ((I = X'FIRST) + Y'FIRST)) THEN 

[for C34005S] 
at lines 262/3 

[262] "I X'FIRST" => "(I - X'FIRST)" 

[263] "J - X'FIRST(2)" => "(J - X'FIRST(2))", yielding; 

Y ((I - X'FIRST) + Y'FIRST, 

(J - X'FIRST(2)) + 


2-5 




CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is 
described adequately by the information given in the initial 
pages of this report. 

For a point of contact for. technical information about this 
Ada implementation system, see: 

Mr. Christopher T. Geyer 
Fleet Combat Directions Systems Support Activity 
Code 81, Room 30ID 
200 Catalina Blvd. 

San Diego, California 92147 
619-553-9447 


For a point of contact for sales information about this Ada 
implementation system, see: 

NOT APPLICABLE FOR THIS IMPLEMENTATION 

Testing of this Ada implementation was conducted at the 
customer's site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


a) Total Number of Applicable Tests 3695 

b) Total Number of Withdrawn Tests 94 

c) Processed Inapplicable Tests 381 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 0 


3-1 


f) Total Number of Inapplicable Tests 381 (c+d+e) 

g) Total Number of Tests for ACVC 1.11 4170 (a+b+f) 


When this implementation was tested, the tests listed in section 
2.1 had been withdrawn because of test errors. 


3.3 TEST EXECUTION 

Version 1.11 of the ACVC comprises 4170 tests. When this 
compiler was tested, the tests listed in section 2.1 had been 
withdrawn because of test errors. The AVF determined that 381 
tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing. 
In addition, the modified tests mentioned in section 2.3 were 
also processed. 

A magnetic tape containing the customized test suite (see 
section 1.3) was taken on-site by the validation team for 
processing. The contents of the magnetic tape were loaded 
directly onto the host computer. 

After the test files were loaded onto the host computer, the 
full set of tests was processed by the Ada implementation. 

The tests were compiled, linked, and executed on the host/ 
target computer system. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B 
for a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this 
test were: 


FOR /NO_OPTIMIZE the options were: 

/SUMMARY /NO_TRACE_BACK /NO_OPTIMIZE /SOURCE 
/0UT=<filename> 

FOR /OPTIMIZE the options were; 

/SUMMARY /NO_TRACE_BACK /OPTIMIZE /SOURCE 

/0UT=<filename> 


The options invoked by default for validation testing during 
this test were: 


3-2 





FOR /NO_OPTIMIZE the options were: 

/NO_MACHINE_CODE /NO_ATTRIBUTE /NO_CROSS_REFERENCE 
/NO_DIAGNOSTICS /NO_NOTES /PRIVATE /LIST 
/CONTAINER_GENERATION /CODE_ON_WARNING /NO_MEASURE /DEBUG 
/CHECKS 

FOR /OPTIMIZE the options were: 

/NO_MACHINE_CODE /NO_ATTRIBUTE /NO_CROSS_REFERENCE 
/NO_DIAGNOSTICS /NO_NOTES /PRIVATE /LIST 
/CONTAINER_GENERATION /CODE_ON_WARNING /NO_MEASURE /DEBUG 
/CHECKS 

Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. Selected 
listings examined on-site by the validation team were also 
archived. 


3-3 






APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for 
customizing the ACVC. The meaning and purpose of these 
parameters are explained in [UG89]. The parameter values are 
presented in two tables. The first table lists the values 
that are defined in terms of the maximum input-line length, 
v/hich is I the value for $MAX_IN_LEN—also listed here. 
These values are expressed here as Ada string aggregates, 
v;here "V” represents the maximum input-line length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 120 

$BIG_ID1 (1..V-1 => 'A', V => '1') 

$BIG_ID2 (1..V-1 => 'A', V => '2') 

$BIG_ID3 (1..V/2 => 'A') & *3' & (1..V-1-V/2 => 'A') 

$BIG_ID4 (1..V/2 *> 'A') & '4' & (1..V-1-V/2 => 'A') 

$BIG_INT_LIT (1..V-3 => '0') & ••298'' 

$BIG_REAL_LIT (1..V-5 => '0') & ”690.0” 

$BIG_STRING1 & (1..V/2 => 'A') & ' 

$BIG_STRING2 "" & (1..V-1-V/2 => 'A') & '1' & "" 

$BLANKS (1..V-20 => ' ' ) 

$MAX_LEN_INT_BASED_LITER.\L 

''2;" & (1..V-5 => '0') & ”11;” 

$MAX_LEN_REAL_BASED_LITERAL 

"16;" & (1..V-7 => '0'} & "F.E;" 

$MAX STRING LITERAL "" & (1..V-2 => 'A') & "" 


A-1 



The following table contains the values for the remaining 
macro parameters. 

Macro Parameter Macro Value 


$ACC_SIZE 
$ALIGNMENT 
$COUNT_LAST 
$ DEFAULT_MEM_SIZE 
$DEFAULT_STOR_UNIT 
$ DEFAULT_S YS_NAME 
$DELTA_DOC 

$ENTRY_ADDRESS 
$ENTRY_ADDRESS1 
$ENTRY_ADDRESS2 
$FIELD_LAST 
$FILE_TERMINATOR 
$FIXED_NAME 
$FLOAT_NAME 
$FORM_STRING 
$F0RM_STRING2 
$ GREATER_THAN_DURATION 
$GREATER THAN DURATION BASE_I 


32 

4 

2_147_483_647 • 

1073741823 

8 

ADAVAX 

0.000_000_000_465_661_2 8 7_3 0 7_ 
739_257_812_5 

16#40# 

16#80# 

16#100# 

32_767 

I f 

NO_SUCH_TYPE_AVAILABLE 
NO_SUCH_TYPE_AVAILABLE 

IIII 

"CANNOT_RESTRICT_FILE_CAPACITY" 
75_000.0 
^ST 131 073.0 


$GREA‘TER THAN FLOAT_BASE LAST 1.80141E+38 


$GREATER THAN FLOAT SAFE LARGE 1.0E308 


SGREATER THAN SHORT FLOAT 3AFE_LARGE 1.0E308 


$HIGH PRIORITY 


15 


A-2 





$NAME_SPECIFICATI0N2 
ALSN$TEST:[ALSN_ 

$NAME_SPECIFICATI0N3 
ALSN$TEST:[ALSN_ 

$NEG_BASED_INT 

$NEW_MEM_SIZE 

$NEW_STOR_UNIT 

$NEW_SYS_NAME 

$PAGE_TERMINATOR 

$RECORD_DEFINITION 

$RECORD_NAME 
$TASK_SIZE 
$TASK_STORAGE_SIZ E 
$TICK 

$VARIABLE_ADDRESS 
$VARIABLE_ADDRESS1 
$VARIABLE_ADDRESS 2 
$YOUR PRAGMA 


TESTS.ACVC.TESTACVCVAX.RUNNING]X212 03.;1 

TESTS.ACVC.TESTACVCVAAX.RUNNING]X3119A.;1 
16#FFFFFFFE# 

1073741823 

8 

ADA_L 
ASCII.FF 

RECORD LWORD_l;LONG_WORD; 
LWORD_2:LONG_WORD; END RECORD; 

QUADWORD 

1624 

1024 

0.01 

16#0020# 

16#0024# 

1610028# 

TITLE ("THIS IS AN ALS/N ACVC 
TITLE") 


A-4 



APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in 
this Appendix, are provided by the customer. Unless specifically 
noted otherwise, references in this appendix are to compiler 
documentation and not to this report. 


B-1 




ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


Section 9 
Compiler Options 


I Option Function 

-- 

MEASURE Generates code to monitor execution 

frequency at the subprogram level for 
the current unit. Default: NO_MEASURE 

NO_CHECKS NO__CHECKS suppresses all riin-time 

error checking. CHECKS provides 
run-time error checking. 

Default: CHECKS 

NO_CODE_ON_WARNING 

NO_CODE_ON_WARNING means no code is 
generated when there is a diagnostic 
of severity WARNING or higher. 
CODE_OM_WARNING generates code 
only“if~there are no diagnostics 
of a severity higher than WARNING. 
Default: CODE_OH_WARNING 

NO_CONTAINER GENERATION 

"■ NO_CONTAINER_GEHERATION means that no 
container is produced even if there 
are no diagnostics. 
CONTAINER_GENERATION produces a 
container if diagnostic serverity 
permits. 

Default: CONTAINER_GENERATION 
+- 


T 2 d)le 9-la - Special Processing Options 


9-01 






Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


Option 


Function 


NO DEBUG 


NO TRACE BACK 


OPTIMIZE 


If NO_DEBUG is specified, only that 
information needed to link, export 
and execute the current unit is 
included in the compiler output. 

With the DEBUG option in effect, 
internal representations and 
additional symbolic information are 
stored in the container. 

Default: DEBUG 

Disables the location of source 
exceptions that are not handled by 
built-in exception handlers. 

Default: TRACE_BACK 

Enables global optimizations in 
accordance with the optimization 
pragmas specified in the source 
program. If the pragma OPTIMIZE is 
not included, the optimizations 
emphasize TIME over SPACE. 

When NOjOPTIMIZE is in effect, no 
global optimizations are performed, 
regardless of the pragmas specified. 
Default: NO OPTIMIZE 


Table 9-lb - Special Processing Options (Continued) 


9-02 





ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


Option 

Function 

ATTRIBUTE 

Produces a Symbol Attribute Listing. 
(Produces an attribute cross-reference 
listing when both ATTRIBUTE and 

CROSS ^FERENCE are specified.) 

De fauXt: NO_ATTRI BUTE 

CROSS_REFERENCE 

Produces a Cross-Reference Listing. 
(Produces an attribute cross-reference 
listing when both ATTRIBUTE and 

CROSS REFERENCE are specified.) 

Default: NO_CROSS_REFERENCE 

DIAGNOSTICS 

Produces a Diagnostic Summary Listing. 
Default: NO_DI AGNOSTICS 

MACHINE_CODE 

Produces a machine code listing if 
code is generated. Code is generated 
when CONTAINER GENERATION option is 
in effect and Jl) there are no 
diagnostics of severity ERROR, SYSTEM 
or FATAL, and/or (2) NO_CODE_ON_WARNING 
option is in effect and there are no 
diagnostics of severity higher than 

NOTE. Default: NO_MACHINE_CODE 

NOTES 

Includes diagnostics of NOTE severity 
level in the Source Listing. 

Default: NO_NOTES 

NO_PRIVATE 

Excludes listing of Ada statements in 
private part if a Source Listing is 
produced. Default: PRIVATE 

SOURCE 

Produce listing of Ada source 
statements. Default; NO_SOURCE 

SUMMARY 

Produce a Summary Listing; always 
produced when there are errors in the 
compilation. Default; NO_SUMMARY 


Table 9-2 - Listing Control Options 


9-03 









Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


I Option Function | 

+-+ 

MSG Sends error messages and the 

Diagnostic Summary Listing to the 
file specified. The default is to 
send error messages and the Diagnostic 
Summary Listing to Message Output 
(usually the terminal). 

OUT Sends all selected listings to the 

single file specified. The default 
is to send listings to Standard 
Output (usually the terminal). 

+-+ 

Table 9-3 - Control_Part (Redirection) Options 


9-04 







LINKi..' OPTIONS 


The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation 
and not to this report. 



ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


Section 11 
Linker Options 


I Option Function | 

+-+ 

DEBUG Produces a linked_container to be 

debugged. Default: NO_DEBU6. 

MEASURE Produces a linked container to be 

analyzed. Default: NO_MEASURE 

NO_SEARCH Limits the contents of the linked 

container to those units explicitly 
specified in the UNITLIST. 

Default: SEARCH. 

PARTIAL Produces an incomplete 

linked container with unresolved 


references. Default: NO_PARTIAL. 

+- -- —— - --+ 


Table 11-1 - LNKVAX Linker Special Processing Options 









Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


Option 

Function 

no option 

Linker Sianmary listing, always produced 
unless diagnostics prevent its generation. 

ELAB_LIST 

Generates an eledsoration order listing. 
Default: NO_ELAB_LIST. 

SYMBOLS 

Produces a Linker symbols listing. 

Default: NO_SYMBOLS. 

UNITS 

Produces a Linker units listing. 

Default: NO_UNITS. 

Table 

11-2 - LNKVAX Linker Listing Options 

1 Option 

Function | 



MSG 

Sends error messages to the file 
specified. The default is to send 
error messages to Message Output 
(usually the terminal) . 

OUT 

+- 

Sends all selected listings to the 
single file specified. The default 
is to send listings to Standard 

Output (usually the terminal). 


Table 11-3 - Control_Part (Redirection) Options 


11-02 












ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


Section 12 
Exporter Options 


I Option Function 


ACCOUNTING Causes the amount of CPU time and 

wall clock time used by the program 
to be reported at program termination 
to message output. 

Default: NO_ACCOUNTING 

DEBUG Produces a load module that can be 

debugged by the ALS/N Symbolic 
Debugger. Default: NO_DEBUG 

DEBUG_SYMBOLS Produces a file of external symbols 

suitable for input to the VAX/VMS 
Debugger. Default: NO_DEBUG_SYMBOLS 

MEASURE Produces a load module that includes 

the invocation of frequency and 
statistical analyzer. 

Default: NO MEASURE 



Table 12-1 - Special Processing Options 


12-01 





Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


Option 

Function 

no option 

Expoxrter Sxunmary Listing is always 
produced unless diagnostics prevent 

Its generation. 

MAP 

Produces a program sections map 
listing that summarizes the 
executable image. Default: N0_MAP 

SYMBOLS 

Produces a list of external symbol 
descriptor information for external 
definitions contained in the object 
module. Default: NO SYMBOLS 

Table 12-2 - Listing Options 

Option 

Function 

MSG 

Sends error messages to the file 
specified. The default is to send 
error messages to Message Output 
(usually the terminal). 

OUT 

Sends all selected listings to the 
single file specified. The default 
is to send listings to Standard 

Output (usually the terminal). 


Table 12-3 - Control_Part (Redirection) Options 


12-02 










APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type INTEGER is range -32_768 .. 32_767; 

type LONG_INTEGER is range -2_147_483_648 .. 2_147_483_647; 
type FLOAT is digits 6 range 

-(2#0.1111_llll_llll_llll_llll_l#E127) .. 

(2#0.1111_1111_1111_1111_1111_1#E127); 
type LONG_FLOAT is digits 9 range 

-(2#0.llll_llll_llll_llll_llll_llll_llll_lll#E127) .. 

(2#0.1111_1111_1111_1111_1111_1111_1111_111#E127); 
type DURATION is delta 2.0 ** (-14) range 

-131_072.0 .. 131_072.0 - 2.0 ** (-14); 

end STANDARD; 


C-1 



ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


Appendix F 

The Ada Language for the VAX Target 


The source language accepted by the compiler is Ada, as 
described in the Military Standard, Ada Programming Language, 
ANSI/MIL-STD-1815A-1983, 17 February 1983 ("Ada Language 
Reference Manual"). 

The Ada definition permits certain implementation 
dependencies. Each Ada implementation is required to supply a 
complete description of its dependencies, to be thought of as 
Appendix F to the Ada Language Reference Manual. This section is 
that description for the VAX/VMS target. 


F.l Options 

There are several compiler options provided by all ALS/N 
Compilers that directly affect the pragmas defined in the Ada 
Language Reference Manual. These compiler options currently 
include the CHECKS and OPTIMIZE options that affect the SUPPRESS 
and OPTIMIZE pragmas, respectively. A complete list of ALS/N 
Compiler options can be found in Section 9. 

The CHECKS option enables all run-time error checking for the 
source file being compiled, which can contain one or more 
compilation units. This allows the SUPPRESS pragma to be used in 
suppressing the run-time checks discussed in the Ada Language 
Reference Manual, but note that the SUPPRESS pragmas must be 
applied to each compilation unit. The NO CHECKS option disables 
all run-time error checking for all compiTation units within the 
source file and is equivalent to SUPPRESSing all mn-time checks 
within every compilation unit. 

The OPTIMIZE option enables all compile-time optimizations 
for the source file being compiled, which can contain one or more 
compilation units. This allows the OPTIMIZE pragma to request 
either TIME-oriented or SPACE-oriented optimizations be 
performed, but note that the OPTIMIZE pragma must be applied to 
each compilation unit. If the OPTIMIZE pragma is not present, 
the ALS/N Compiler's Global Optimizer tends to optimize for TIME 
over SPACE. The NO OPTIMIZE option disables all compile-time 
optimizations for all compilation units within the source file 
regardless of whether or not the OPTIMIZE pragma is present. 


F.l Options 


F-01 



Version 4.5 • 
29 March 1991 


AliS/N Reference Handbook 


F. 2 Pragmas 

Both implementation-defined and Ada language-defined pragmas 
are provided by all ALS/N Compilers. The syntax defined in the 
Ada Language Reference Manual allows pragmas as the only element 
in a compilation, before a compilation unit, at defined places 
within a compilation unit, or following a compilation unit. The 
ALS/N Compilers associates pragmas with compilation units as 
follows: 

a. If a pragma appears before any compilation unit in a 
compilation, It will affect all following compilation units, 
as specified below, and in the Ada Lemguage Reference Manual. 

b. If a pragma appears inside a compilation unit, it will be 
associated with that compilation unit, and in listings 
associated with that compilation unit as described in the Ada 
Language Reference Manual, or in this document. 

c. If a pragma follows a compilation unit, it will be associaced 
with the preceding compilation unit, and the effects of the 
pragma will be found in the container of that compilation 
unit, and in listings associated with that container. 

The pragmas MEMORY_SIZE, STORAGE UNIT, and SYSTEM_NAME are 
described in Section 13.7 of the Ada^Language Reference Manual. 
They may appear only at the start of the first compilation when 
creating a new program library. In the ALS/N, however, since 
program libraries are created by the Program Library Manager and 
not by the compiler, the use of these pragmas is obviated. If 
they appear anywhere, a diagnostic of severity level WARNING is 
generated. 


F.2.1 Language-defined Pragmas 

The following notes specify the language-required definitions 
of the predefined pragmas. Unmentioncd language-defined pragmas 
are implemented as defined by the Ada Language Reference Manual. 


F-02 


F.2.1 


Language-defined Pragmas 






ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


pragma INLINE (siibprogram_name) ; 

There are three Instances in which the INLINE pragma is 
ignored. Each of these cases produces a warning 
message that states the INLINE did not occur. 

a. If a call to an INLINE siibprogram is compiled 
before the actual body of the subprogram has beer, 
compiled, a routine call is made instead. 

b. If the compilation unit containing the INLINE 
subprogram depends on the compilation unit of its 
caller, a routine call is made instead. 

c. If an immediately recursive subprogram call is made 
within the body of the INLINE subprogram, the 
pragma INLINE is ignored entirely. 

pragma INTERFACE (language_name, subprogram_name}; 

Two language_names will be recognized and implemented: 

ASMVAX_JSB, and ASMVAX_CALLS. 

The language_name ASMVAX_JSB indicates that a 
subprogram written in the VAX/VMS assembler language 
will be called with a JSB instruction and the 
pareuneters passed in registers. The language_name 
ASMVAX CALLS will provide an interface to a VAX 
assembXer language subprogram via the CALLS 
Instruction, with the parameters passed on the stack, 
with the same parameter passing conventions used for 
calling Ada subprograms. 

The user must ensure that an assembly-language body 
container for this specification exists in the program 
library before linking. 


F.2.1 


Language-defined Pragmas 


F-03 






Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


pragma OPTIMIZE (arg); 

This pragma is effective only when the "OPTIMIZE" 
option has been given to the compiler. The argument is 
either TIME or SPACE. If TIME is specified, the 
optimizer concentrates on optimizing code execution 
time. If SPACE is specified, the optimizer 
concentrates on optimizing code size. 

pragma PRIORITY (arg)l; 

The PRIORITY argument is an integer static expression 
value of predefined integer subtype PRIORITY. The 
pragma has no effect in a location other than a task 
(type) specification or outermost declarative part of a 
subprogram. If the pragma appears in the declarative 
part of a subprogram, it has no effect unless that 
subprogram is designated as the "main" sxibprogram at 
link time. 

pragma SUPPRESS (arg(,arg]); 

Pragmas to suppress OVERFLOW_CHECK will have no effect 
for operations of integer types. 

A SUPPRESS pra^a will have effect only within the 
compilation unit in which it appears, except that a 
SUPPRESS of ELABORATION_CHECK applied at the 
declaration of a sxibprogram or task unit will apply to 
all calls or activations. 

pragma MEMORY_SIZE; 

This pragma is ignored and a WARNING diagnostic is 
issued. 

pragma STORAGE_SIZE; 

This pragma is ignored and a WARNING diagnostic is 
issued. 

pragma SYSTEM_NAME; 

This pragma is ignored and a WARNING diagnostic is 
issued. 


r-04 


F.2.1 Language-defined Pragmas 




ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


F.2.2 Implementation-defined Pragmas 

The following is the only implementation-defined pragma: 
pragma TITLE (arg); 

This is a listing control pragma. It takes a 
single argument of type string. The string 
specified will appear on the second line of 
each page of the source listing produced for 
the compilation unit within which it appears. 

The pragma should be the first lexical unit 
to appear within a compilation unit 
(excluding comments). If it is not, a 
warning message is issued. 


F.2.3 Scope of Pragmas 

The scope of pragmas is as described in the Ada Language 
Reference Manual except as noted below: 

MEMORY_SIZE - No scope, but a WARNING diagnostic is generated. 
PAGE - No scope. 

ST0RAGE__SI2E - No scope, but a WARNING diagnostic is generated. 
SYSTEM_NAME - No scope, but a WARNING diagnostic is generated. 
TITLE - The compilation unit within which the pragma occurs. 


F.2.3 Scope of Pragmas 


F-05 






Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.3 Attributes 

There is one implementation-defined attribute in addition to 
the predefined attributes found in Appendix A of the Ada Language 
Reference Manual. 


X'DISP 

A value of type UNIVERSAL_INTEGER that 
corresponds to the displacement that is used 
to address the first storage unit occupied 
by a data object X at: a static offset within 
an implemented activation record. 

This attribute differs from the ADDRESS 
attribute in that ADDRESS supplies the 
absolute address while DISP supplies the 
displacement relative bo some base value 
(such as a stack frame pointer). It is the 
user's responsibility to determine the base 
value relevant to the attribute. 


The following notes augment the language-required definitions 
of the predefined attributes found in Appendix A of the Ada 
Language Reference Manual. 


T'MACHINE^EMAX 
T'MACHINE_EMIN 
T'MACHINE MANTISSA 


T' MACHINE_OVERFLOWS 
T'MACHINE_RADIX 
T'MACHINE ROUNDS 


is 127. 
is -127. 

if the size of the base type T is 32, 
MACHINE_MANTISSA is 24. 
if the size of the base type T is 64, 
MACHINE_MANTISSA is 56. 

is true. 

is 2. 

is false. 


F.4 Predefined Language Environment 

The predefined Ada language environment consists of the 
packages STANDARD and SYSTEM described below. 


F-06 


F.4 Predefined Language Environment 




ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


F.4.1 Package STANDARD 

The Package STANDARD contains the following definitions in 
addition to those specified in Appendix C of the Ada Language 
Reference Manual: 

— For this impleaentation, there is no corresponding body, 
type BOOLEAN is (FALSE',TRUE) ; for BOOLEAN^SIZE use 1; 

— The universal type UNIVERSAL_INTEGER is predefined for Ada. 

type INTEGER is range -32_768 .. 32_767; 

type LONG_INTEGER is range -2_147_483_648 .. 2_147_483_647; 

— The universal type UNIVERSAL_REAL is predefined for Ada. 

type FLOAT is digits 6 range 

- (2#0.1111_1111_1111_1111_1111_1#E127} .. 
(2#0.1111_1111_1111_1111_1111_1#E127) ; 

type LONG_FLOAT is digits 9 range 

-(2#0.1111_1111 1111_1111 1111_1111 nil 111#E127) .. 
(2#0.1111_llll“llll_llll~llll_llll“llll_lll#E127) ; 

— Predefined subtypes within the Ada Language: 

subtype NATURAL is INTEGER range 0 .. INTEGER'LAST; — 32 767 
subtype POSITIVE is INTEGER range 1 .. INTEGER' LAST; — 32 767 
subtype LONG NATURAL is LONG INTEGER 

“ range 0 .. LONG INTEGER'LAST; 

subtype LONG_POSITIVE is LONG_INTEGER 

range l .. LONG_INTEGER'LAST; 

— Predefined STRING type within the Ada Language: 

type STRING is array (POSITIVE range <>) of CHARACTER; 
pragma PACK(STRING); 

— The type DURATION is predefined for use with Ada DELAY. 

type DURATION is delta 2.0 ** (-14) 

range -131_072.0 .. i31_072.0 - 2.0 ** (-14) 

— The predefined operators for the type DURATION are the same 

— as for any fixed point type within the Ada language. 


F.4.1 Package STANDARD 


F-07 



Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.4.2 Package SYSTEM 

Within the various implementations, no corresponding package 
body is required for the package SYSTEM. The package SYSTEM is 
as follows: 


type ADDRESS is new LONG_INTEGER; 
type NAME is (AdaVAX, Ada_L, Ada_M) ; 
SYSTEM_NAME : constant NAME :=» Ada VAX; 
STORAGE_UNIT : constant := 8; 

MEMORY SIZE : constant := 2**30 - 1; 


— System-Dependent Named Numbers: 


MIN_INT : constant 
MAX_INT : constant 
MAX_DIGITS : constant 
MAX_MANTISSA : constant 
FINE_DELTA : constant 
TICK ; constant 


-(2**31); 

(2**31)-1; 
9; 

31; 

2.0**(-31) ; 

0 . 01 ; 


— Other System-Dependent Declarations 


subtype PRIORITY is INTEGER range 1..15; 


— The following exceptions are provided as a "convention" 

— whereby the Ada proaram can be compiled with all implicit 

— checks suppressed (I.e., pragma SUPPRESS or equivalent), 

— explicit checks included as necessary, the appropriate 

— exception raised when required, and then the exception is 
—■ either handled or the Ada program terminates. 


ACCESS_CHECK 

DISCRIMINANT_CHECK 

INDEX_CHECK 

LENGTH_CHECK 

RANGE_CHECK 

DIVISION_CHECK 

OVERFLOW_CHECK 

ELABORATION_CHECK 

STORAGE CHECK 


exception; 

exception; 

exception; 

exception; 

exception; 

exception ;• 

exception; 

exception; 

exception; 


— The following exceptions provide for (1) Ada programs that 

— contain unresolved subprogram calls and (2) VAX/VMS 

— system-level errors. 


UNRESOLVED_REFERENCE ; exception; 
SYSTEM_ERROR : exception; 


F-08 


F.4.2 Package SYSTEM 




ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


F.5 Character Set 

Ada compilations may be expressed using the following 
characters, in addition to the basic character set: 

lover case letters: 

abcdefghijklmnopqrstuvwxyz 

special characters: 

!$%?§[ ]"'{}- 

The following transliterations are permitted (see Paragraph 2.10 
of the Ada Language Reference Manual) : 

a. Exclamation mark for vertical bar; 

b. Colon for sharp; and 

c. Percent for double_quote. 


F.5 Character Set 


F-09 



Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.6 Declaration and Representation Restrictions 

Declarations are described in Chapter 3 of the Ada Lan^age 
Reference Manual. Representation specifications are described in 
Chapter 13 and discussed here. 

In the following specifications, the capitalized word SIZE 
indicates the number of bits used to represent an object of the 
type under discussion. The upper case symbols D, L, and R 
correspond to those discussed in Section 3.5.9 of the Ada 
Language Reference Manual. 


F.6.1 Integer Types 

Integer types are specified with constraints of the form: 
RANGE L..R 

where: 

R <= SYSTEM.MAX_INT & L >= SYSTEM.MIN_INT 
For an integer type, length specifications of the form; 

FOR t'SIZE USE n; 

may specify integer values n such that n is in 2..32, 

R <» 2**(n-l)-l 4 L >» -2**(n-l); 
or else such that 

R <= (2**N)-1 & L >= 0 
and N is in 1..31. 

For a stand-alone object of integer type, a default SIZE of 16 
is used when: 

R <= 2**15-1 & L >= 2**15 

Otherwise a SIZE of 32 is used. 

For components of integer types within packed composite 
objects, the smaller of the default stand-alone SIZE or the SIZE 
from a length specification will be used. 


F-10 


F.6.1 Integer Types 




ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


F.6.2 Floating Types 

Floating types are specified with constraints of the form; 
DIGITS D 

where D is an integer value in 1 through 9. 

For floating point types, length specifications of the form: 
FOR t'SIZE USE n; 

are permitted only when the integer values N = 32 when D <= 6, 
or N = 64 when D <= 9. 

When no length specification is provided, a size of 32 is used 
when D <= 6; 64 when D is 7 through 9. 


F.6.3 Fixed Types 

Fixed types are specified with constraints of the form: 
delta D range L..R 


where: 

max (abs(R), abs(L)) < 2**31-1 


actual^delta 

The actual delta defaults to the largest integral power of 2 
less than or equal to the specified delta D. (This implies 
that fixed point values are stored right-aligned.) 

For fixed point types, length specifications of the form: 

for T'SIZE use N; 

are permitted only when N in 1 .. 32, if: 

R - actual delta <= 2**(N-1)-1 * actual_delta 


and 


or 


and 


L + actual_delta >= -2**(n-l) * actual)delta 
R - actual_delta <=* 2**(N)-1 * actual_delta- 


F.6.3 Fixed Types 


F-11 








Version 4.5 
29 March 1991 


ALS/H Reference Handbook 


I L >= 0 

For stand-alone objects of fixed point type, a default size of 32 
is used. For components of fixed point types within packed 
composite objects, the size from the length specification will be 
used. 

I Specifications of the form: 

I for SMALL use X; 

are permitted for any value of X, such that X <= D. X must be 
specified either as a base 2 value or as a base 10 value. Note 
that when X is specified as other than a power of 2, actual_delta 
will still be the largest integreal power of two less than X. 


F-12 


F.6.3 Fixed Types 




ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


F.6.4 Enumeration Types 

In the absence of a representation specification for an 
enumeration type T, the internal representation of T'FIRST * 0. 
The default SIZE for a stand-alone object of enumeration type T 
will be the smallest of the values 8, 16, or 32, such that the 
internal representation of T'FIRST and T'LAST both falls within 
the range: 

-2**(T'SIZE-1) .. 2**(T'SIZE-1)-1. 

For enumeration types, length specification of the form: 
for T'SIZE use N; 

and/or enumeration representations of the form: 
for T use <aggregate>; 

are permitted for M in 2..32, provided that the internal 
representations and the SIZE conform to the relationship 
specified above. 

Or else for N in 1..31, is supported for enumeration types 
and provides an internal representation of: 

T'FIRST>»0 .. T'IAST<=2**(T'SIZB)-1. 

For components of enumeration types within packed composite 
objects, the smaller of the default stand-alone SIZE, or the SIZE 
from a length specification will be used. 

Enumeration representation on types derived from the 
predefined type BOOLEAN will not be accepted, but length 
specifications will be accepted. 


F.6.4 


Enumeration Types 


F-13 




Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.6.5 Access Types 

For access type, T, length specifications of the form: 
for T^SIZE use N; 

will not affect the run-time implementation of T, therefore N * 
32 is the only value permitted for SIZE, which is the value 
returned by the attribute. 

For collection size specifications of the form: 

for T'STORAGE_SIZE use N; 

any value of N is permitted (and that value will be retxirned by 
the attribute call). The collection size specification will 
affect the implementation of T and its collection at run-time by 
limiting the number of objects for type T that can be allocated. 


F.6.6 Arrays and Records 

For arrays and records, length specifications of the form: 
for T'SIZE use N; 

may cause arrays and records to be packed, if required, to 
accommodate the length specification. If the SIZE specified is 
not large enough to contain all possible values of the 
components, a diagnostic message of severity ERROR is issued. 

The PACK pragma may be used to minimize wasted space, if any, 
between components of arrays and records. The pragma causes the 
type representation to be chosen suc>’ that storage space 
requirements are minimized at the possible expense of data access 
time and code space. 

For records, a component clause of the form: 
at N [range i.. j ] 

specifies the allocation of components in a record. Bits are 
numbered 0..7 from the right and bit 8 starts at the right of the 
next higher-number byte. Each location specification must allow 
at least X bits of range, where X is lar^e enough to hold any 
value of the subtype of the component being allocated. 

Otherwise, a diagnostic message of severity ERROR is generated. 


F-14 


F.6.6 Arrays and Records 



ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


For records, an alignment clause of the form: 
at mod N 

specify alignments of N bytes for 1 byte, 2 bytes (VAX "word"), 
and 4 bytes (VAX "long_word"). 

If it is determinable at compilation time that the SIZE of a 
record or array type or subtype maybe outside the range of 
STANDARD. LONG_INTEGER, a diagnostic message of severity WARNING 
is generated. Declaration of an object of such a type or subtype 
would raise NlJMERIC_ERROR when eled^orated. Note that a 
discriminant record or array may never raise the NUMERIC ERROR 
when elaborated based on the actual discriminant provideH. 


F.6.7 Other Length Specifications 

Length Specifications are described in Section 13.2 of the 
Ada Language Reference Manual. 

A length specification for a task type T, of the form: 

for T'SIZE use N; 

specifies the number of bits to be allocated for objects of the 
task type T. For the VAX/VMS target, N must be defined: 

N » 8 * (109 + 13 * number__of__entries) 

Where number_of entries is the number of entries declared in the 
ta*sk type speciTication. 


F.6.7 Other Length Specifications 


F-15 



Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.7 System Names 

Refer to Section 13.7 of the Ada Lanc^age Reference Manual 
for a discussion of package SYSTEM. 

The available system naunes are "AdaVAX", "Ada_L'', and 
"Ada M"; the system name is chosen based on the targets 
supported, but it can not be changed. In the case of VAX/VMS, 
the system name is "AdaVAX". 


F.8 Address Clauses 

Refer to Section 13.5 of the Ada Language Reference Manual 
for a discussion of Address Clauses. Address clauses for objects 
and code are allowed by the VAX/VMS target, but they have no 
effect beyond changing the value returned by the 'ADDRESS 
attribute call. 

The Run-Time Support Library (RSL) for the VAX/VMS target 
does not handle hardware interrupts. All hardware interrupts are 
handled by the VAX/VMS operating system. However, the VAX_^VMS 
tar(^et uses asynchronous system traps (ASTs) in a manner sTmilar 
to interrupt entries. 


F.9 Unchecked Conversions 

Refer to Section 13.10.2 of the Ada Language Reference Manual 
for a description of UNCHECKED_CONVERSION. 

A program is erroneous if it performs UNCHECKED_CONVERSION 
when the source and target have different sizes. 


F.IO Restrictions on the Main (Sub)Program 

Refer to Section 10.1 of the Ada Language Reference Manual 
for a discussion of the main (sub)program. The subprogram 
designated as the main (sub)program cannot have parameters. The 
desi<^nation as the main (sub)program of a sxibprogram whose 
specification contains a formal_part results in a diagnostic of 
severity ERROR at link time. 

The main (sxib)program can be a function, but the return value 
will not be available upon completion of the main (sub)program's 
execution. The main (sub)program may not be an imported 
subprogram. 


F-16 


F.IO Restrictions on the Main (Sub)Progreua 






ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


F.ll Input/Output 

Refer to Chapter 14 of the Ada Language Reference Manual for 
a description of Ada Input/Output (I/O). 

The RSL I/O subsystem provides the following packages to the 
user: TEXT_IO, SEQUENTIAL_IO, DIRECT lO, and LOW LEVEL 10. These 
packages execute in the context of tHe an individual Ada task 
making the I/O request. Consequently, all of the code that 
process an I/O request on behalf of the Ada task executes 
sequentially. The package I0_EXCEPTI0NS defines all of the 
exceptions needed by the packages TEXT_I0, SEQUENTIAL_IO, and 
DIRECT 10. The specification of this package is given in Section 
14.5 o7 the Ada LRM. This package is visible to all of the 
constituent packages of the RSL I/O stibsystea so that appropriate 
exception handlers can be inserted. 

High-level I/O in AdaVAX is performed solely on external 
files. No allowance is provided in the RSL I/O subsystem for 
memory resident files (i.e., files which do not reside on a 
peripheral device) . This is true even in the case of temporary 
files. With the external files residing on peripheral devices, 
only the various VAX/VMS quotas restricts the number of files 
that may be open on an individual peripheral device. 

Section 14.1 of the Ada LRM states that all I/O operations 
are expressed as operations on objects of some file type, rather 
than in terms of an external file. File objects are iisplemented 
in AdaVAX as access objects that point to a data stzructure call 
the File Control Block (FCB). This FCB is defined internally to 
each high-level I/O package; its purpose is to represent an 
external file. The FCB contains all of the I/O-specific 
information about an external file that is needed by the 
high-level packages to accomplish the requested I/O operation. 


F.11.1 Naming External Files 

The naming conventions for external files in AdaVAX are of 
particular importance to the user. An external file name for Ada 
I/O can be any valid path name (e.g., 

disk:[directories]filename.ext) in the VAX/VMS environment. 


F.11.1 


Naming External Files 


F-17 





Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.11.2 The FORM Specification for External Files 

The FORM specification for external Files created by TEXT 10 
include the default (i.e., the NULL string) and the two shortHand 
strings: "PASS AU." or "LOG FILE". The only FORM specification 
for external fXles created Ey SEQUEMTIAL_IO and DIR£CT_I0 is the 
default of the NULL string. Note that opening the external file 
after its creation still utilizes the file attributes assigned to 
the file when it was created and, therefore, the only legal FORM 
specification is the NULL string. 

An alloweUale FORM string in TEXT_I0 has syntax defined by the 
grammar is shown in Tedsle F-l below. The tokens of the graunmar 
may be separated by any combination of blanks (' ’) and 
horizontal tab (ASCII.HT) characters. The FO^ parameter is not 
case sensitive, but repetition of a file_attribute_item is not 
allowed. The record format values valid with the file 
organization SEQUENTIAL are: STREAM, STREAM CARRIAGE_RETURN, 
STREAM LINE_FEED, and UNDEFINED. Note that“the 
VARIABIe FIXZD_C0NTR0L record format is not valid with the 
INDEXED 7ile organization. 

In TEXT_I0, the following default FORM value is assumed when 
the FORM parameter is the NULL string: 

. "RECORD FORMAT :» VARIABLE, " & 

"FILE ORGANIZATION := SEQUENTIAL, " & 

"CARRlAGE_CONTROL := CARRIAGE_RETURN" 

The "PASS_ALL" FORM parameter is equivalent to the string: 

"REC0RD_F0RMAT := VARIABLE, " & 

"FILE_ORGANIZATION := SEQUENTIAL, " & 

"CARRIAGE_CONTROL := NONE" 

The "L0G_FILE" FORM parameter is equivalent to the string: 

"RECORD_FORMAT :- VARIABLE_FIXED_CONTROL, " & 
"FILE_ORGANIZATION :» SEQUENTIAL, " & 

"CARRIAGE CONTROL := PRINT" 


F-18 


F.11.2 The FORM Specification for External Files 




ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


I Left Hand Side Right Hand Side 

. 1 ._—________ 


form_string 

• 

"" 1 shorthand_string j 
file_attribute_list 

shorthand_string 

% 

• 

PASS__ALL 1 LOG_FILE 

f i 1 e_a tt r ibut e__l i s t 

• aat 

file attibute item 
{,fiTe_attribute_item} 

f ile__attr ibute_itein 

• 

record_fonnat_string | 
file_^organization_string [ 
carrTage_control _string 

record_forBiat_string 

• 

• 

RECORD_FORMAT := record_format 

record_fonnat 

* — — 

VARIABLE 1 FIXED | STREAM | 
VARIABLE FIXED CONTROL | 

STREAM CARRIAGE CONTROL ] 
STREAM_LINE_FEED | Ul'DEFINED 

file__organization_string 

• 

FILE ORGANIZATION := 
file^organization 

file_organization 


SEQUENTIAL | RELATIVE ) INDEXED 

carriage_control_string 


CARRIAGE CONTROL :» 
carriage”control 

carriage_control 

• ' 

FORTRAN 1 CARRIAGE RETURN I 

PRINT 1 NONE 


Table F-1 - FORM String Graaunar 


F.11.2 The FORM Specification for External Files 


F-19 




Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.11.3 External File Processing 

Section 14 of the Ada LRM defines two kinds of access to 
external files: sequential access and direct access. A file 
object used for sequential access is call a sequential file, and 
one used for direct access is called a direct file. Three file 
inodes are defined: IN FILE, OUT_FILE, and INOUT_FIIjE. All three 
file modes are allowed for direct files, whereas only the modes 
IN_FILE and OUT_FILE are allowed for sequential files. 

AdaVAX takes the view that files of mode IN^FILE already 
contain data, making them suitable for reading,'while files of 
mode OUT_FILE are empty, making them suitable for writing. Files 
of mode IN0UT_FIL£ may contain data or may be empty, making them 
suitable for reading or writing. An attempt to create a file of 
mode IN^FILE will raise the exception USE_ERROR since a newly 
created file is empty (i.e., not suitable for reading). Stated 
more simply, AdaVAX restricts the creation of files to those of 
mode OUT_FILE or INOUT_FILE. 

Processing allowed on external files is determined by the 
access controls set by the owner of the file and by the physical 
characteristics of the underlying device. The following 
restrictions apply: 

a. A user may open a file as an IN__FILE only if that user has 
read access to the node. A user may open a file as an 
OUT__FILE only if that user has write access to the node. 
Finally, a user may open a file as an INOUT FILE only if that 
user has read and write access to the node.' 

b. The attempt to CREATE a file with the mode IN FILE is not 
supported since there will be no data in the Tile to read. 

c. Multiple OPENS are allowed to read from a file, but all OPENS 
to write require exclusive access to the file. The exception 
USE__ERROR is raised if this restriction is violated. 

• 

d. No positioning operations are allowed on files associated 
with a printer or hard-copy terminal. The exception 

USE ERROR is raised if this restriction is violated. 


F-20 


F.11.3 External File Processing 





ALS/N Reference Hemdbook 


Version 4.5 
29 March 1991 


F.11.4 Text Input/Output 

The specification of TEXT 10 is given by Section 14.3.10 of 
the Ada LRH. TEXT_I0 is invoiced by the Ada task to perfom 
sequential access I/O operations on text files (i.e., files whose 
content is in a human-readable form). TEXT_IO is not a generic 
package, and thus, its s\:bproqr 2 uns may be invoked directly from 
the Ada task, using objects wit h base type or parent type in the 
language-defined type CHARACTER (and or course STRING). TEXT_I0 
also provides the generic packaqes INTEGER 10, FLOAT_IO, FIXED_I0 
and ENUMERATI0N_I0 for the reading and writing of numeric values 
and enumeration“values. The generic packages within TEXT_I0 
require an instantiation for a given element type before any of 
their subprograms are invoked. 

The implementation-defined type COUNT that appears in Section 
14.3.10 of the Ada LRM is defined as follows: 

type COUNT is range 0. .LONG_INTEGER'LAST; 

The implementation-defined stibtype FIELD that appears in Section 
14.3.10 of the Ada LRM is defined as follows: 

subtype FIELD is INTEGER range 0..INTEGER'LAST; 

At the beginning of program execution, the STANDARD_INPUT 
file and the STANDARD OUTPUT file are open and associated with 
the ALS/N-supported standard input and output files. The 
STANDARD INPUT and STANDARD OUTPUT file cannot be deleted, 
attempts“to do so raise the^exception USE ERROR. Additionally, 
if a program terminates before an open file is closed (except for 
STANDARD INPUT and STANDARD_OUTPUT) , then the last line the user 
put to tHe file may be lost. 

A program is erroneous if concurrently executing tasks 
attempt to perform overlapping GET and/or PUT operations on the 
same terminal. Because of the physical nature of DeeWriters and 
Video terminals, the semantics of text layout as specified in Ada 
Language Reference Manual Section 14.3.2 (especially the concents 
of current column number and current line) cannot be guaranteed 
when GET operations are intezrweaved with PUT operations. 

Programs that rely on the semantics of text layout under those 
circumstances are erroneous. 

For TEXT^IO processing, the line length can be no longer than 
the maximum VAX/VMS record lenqth minus one (i.e., 255 
characters) . An attempt to write over the record length boundary 
will result in writing a full record and starting a new record. 

An attempt to set the line length through SET_LINE LENGTH to a 
length greater than 255 will result in USE_ERROR. “An attempt to 
read a file with a line length greater than 255 will also result 
in a USE ERROR. 


P.11.4 Text Input/Output 


F-21 




Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.11.5 Sequential Input/Output 

The specification of SEQUENTIAL_IO is given in Section 14.2.3 
of the Ada LRM. SEQUENTIAL_IO is invoked by the Ada task to 
perform I/O of the records of a file in an arbitrary order. The 
package SEQUENTIAL_IO requires a generic instantiation for a 
given element type before any of its subprograms may be invoked. 
Once the package SEQUENTIAL_IO is made visible, it will perform 
any service defined by the subprograuns decrlared in its 
specification. 

The following restrictions are imposed on the use of the 
package Sequential_IO: 


a. A null file name parameter to the CREATE procedure (for 
opening a temporary file) is not appropriate, and raises the 
exception NAME_ERROR. 

b. Writing a record on a file associated with a tape adds the 
record to the file such that the record just written becomes 
the last record of the file. 

c. On a disk or tape, the DELETE procedure closes the file and 
sets its size to zero so that its data may no longer be 
accessed. 

d. The subprograua EMD_OF_FIU! always returns FALSE for a 
character-oriented”device and RESET performs no action on a 
character-oriented device. 


F.11.6 Direct Input/Output 

The specification of DIRECT_IO is given in Section 14.2.5 of 
the Ada LRM. DIRECT 10 is invoked by the Ada task to perform I/O 
of the rcscords of a Tile in an arbitrary order. The package 
DIRECT_I0 requires a generic instantiation for a given element 
typo before any of its subprograms may be invoked. Once the 
package DIRECT_I0 is made visible, it will perform any service 
defined by the subprograms declared in its specification. 

The implementation-defined type COUNT that appears in Section 
14.2.5 of the Ada LRM is defined as follows: 

type COUNT is range 0. .LONG_INTEGER'LAST; 


F-22 


F.11.6 Direct Input/Output 




ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


F.11.7 Low Level Input/Output 

The packaqe LOW_LEVEL_IO defines a standard interface to 
allow an application to interact directly with a physical device. 
LOW LEVEL 10 provides a definition of data types for a physical 
device an9 data to be operated on, along with the standard 
procedures SEND_C0NTR0L and RECEIVE_CONTROL. The procedure 
SEND CONTROL may be used to send control information to a 
physical device. RECEIVE_CONTROL may be used to monitor the 
execution of an I/O operation by requesting information from a 
physical device. 

with SYSTEM; 

package L0W_LEVEL__I0 is 

type I0_BUFFER_ADDRESS is new SYSTEM.ADDRESS; 
type I0_BUFFER_C0UNT is new INTEGER; 
type IO_TIME_OUT is new INTEGER; 

type I0_FUNCTI0N is ( 

read_data, ~ read data 

write data, — write data 

initialize, — initialize the device and 
— return the device_code 
cancel, — cancel 10 request*" 

control); — return control information 

type DEVICE TYPE is new LONG_INTEGER; 

DEVICE”NAME_LENGTH: constant INTEGER := 32; 

type 10 REQUEST_BLOCK is record 

REQUESTED_FUNCTION; IO_FUNCTION; 

DE^/ICE_NAME: STRING {1. . DEVICE_NAME_LENGTH) ; 

DEVICE: DEVICE_TYPE; 

BUFFER_ADDRESS; IO_BUFFER_ADDRESS ; 

BUFFER_COUNT: I0_BUFFER_C0UNT ; 

TIME OUT: I0_TIME_0UT; 

end recorl; 


F.11.7 Low Level Input/Output 


F-23 





Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


type IO_RETURN_STATUS is { 

ss_nonnal, — normal completion 

ss_abort, — all "failure" status codes 

ss_accvio, 

ss_devoffline, 

ss~exguota, 

ss~illefc, 

ss~insfmem, 

ss_ivcham, 

ss_nopr iv, 

ss_unasefc, 

ss_linkabort , 

ss_linkdiscon, 

ss_protocol, 

ss_connecfail, 

ss_filalracc, 

ss_invlogin, 

ss_indevnam, 

ss_linkexit, 

ss_nolinks, 

ss_nosuchnode , 

ss_reject, 

ss^remrsrc, 

ss”shut , 

ss”toomuchdata, 

ss_unreachable); 


type IO_STATUS_BLOCK is record 

BYTE_COUNT; IO_BUFFER COUNT; 

RETURNED_STATUS; I0_RETURN“STATUS ; 

end record; 

procedure SEND_CONTROL (DEVICE: in DEVICE_TYPE; 

DATA: in out IO_REQUEST_BLOCK) ; 

procedure RECEIVE_CONTROL (DEVICE: in DEVICE_TYPE; 

DATA: in out IO_STATUS_BLOCK) ; 

end LOW LEVEL 10; 


F.12 System Defined Exceptions 

In addition to the exceptions defined in the Ada Language 
Reference Manual, this implementation pre-defines the exceptions 
shown in Table F-2 below. 


F-24 


F.12 System Defined Exceptions 






ALS/N Reference Handbook Version 4.5 

29 March 1991 


I Name Significance 

j_________- 


ACCESS_CH£CK The ACCESS CHECK exception has been 

raised explicitly within the program. 

DISCRIMINANT_CHECK DISCRIMINANT_CHECK exception has been 

raised explicitly within the program. 

INDEX_CHECK The INDEX_CHECK exception has been 

raised explicitly within the progrzun. 

IiENGTH_CHECK The LENGTH CHECK exception has been 

raised explicitly within the program. 

RANGE_CHECK The RANGE_CHECK exception has been 

raised explicitly within the program. 

DIVISION_CHECK The DIVISION_CHECK exception has been 

raised explicitly within the program. 

OVERFLOW_CHECK The OVERFLOW_CHECK exception has been 

raised explicitly within the program. 

ELABORATION^CHECK ELABORATION^CHECK exception has been 
^ raised explicitly within the program. 

STORAGE_CHECK The STORAGE CHECK exception has been 

raised explicitly within the program. 

UNRESOLVED__REFERENCE Attempted call to a routine not linked 
“ into the executable image. 

SYSTEM_ERROR Serious error detected in underlying 

VAX/VMS operating system. 


Table F-2 - System Defined Exceptions 


F.12 System Defined Exceptions 


F-25 





Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.13 Machine Code Insertions 

The Ada language definition permits machine code insertions 
as described in Section 13.8 of the Ada Language Reference 
Manual. This section describes the implementation specific 
details for writing machine code insertions as provided by the 
predefined library package MACHINE_COOE. 

The user may, if desired, include MACRO instructions within 
an Ada program. This is done by including a subprogram in the 
program which contains only record aggregates defining machine 
code instructions. The package MACHINE_COOE, included in the 
system program library, contains type, record and constant 
declarations which are used to form the instructions. Each field 
of the aggregate contains a field of the resulting machine 
instruction. These fields are specified in the order in which 
they appear in the actural instruction. Records for one- and 
two- byte instruction codes are available. Each instruction 
record is discriminated using the instruction code. The record 
components determined by the discriminant are the argviments of 
the record. Arguments are represented using records whose 
discriminants are called address modes. The discriminant 
determines what additional information (if any) must be 
associated with the argument. Separate records are available for 
specifying data. 

WITH machine_code; 

USE machine_code; 

FUNCTION fixed multiply 

(multiplier""! : IN LONG_INTEGER; 
multiplier"2 : IN LONG_INTEGER ; 
scaling_factor : IN LONG_INTEGER 
) RETURN LONG_INTEGER IS 

BEGIN 

— EMUL RO, Rl, #0, RO 

— named aggregate notation 
byte_op_code 

(op => emul, 

emul_l => long_word_general_operand(op => RO) , 

emul_2 => long_word_general_operand(op => Rl) , 

emul_3 => long_word_general_operand(op => LO) , 

emul_4 => quad_word_general_operand(op => RO)) ; 

— ASHQ R2, RO, RO 

— positional notation 
byte_op_code 

(ashq, 

byta_word_general_operand (op => R2) , 
quad_word_general_operand(op *=> RO), 
quad_word general_operand (op *> R2)) ; 

END fixed_multipTy ; 

Note that either positional or named aggregates may be used. 


— in RO 

— in Rl 

— in R2 

— in RO 


F-26 


F.13 Machine Code Insertions 



ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


ALS/M supports machine code insertions through calls to 
procedures whose bodies are composed of sequences of assembly 
languaqe instructions. Each instruction in the sequence is 
specified as an aggregate of either the record type BYTE OP_COD£ 
or WORD_OP_CODE, both declared in the Rxintime Support LiErary 
packaae MACHIME_COOE. These types are variant records whose 
discriminant is a symbolic VAX-11 instruction opcode. Components 
of each discriminated record correspond to the instruction 
operands appropriate to a given instruction opcode. Components 
of BYTE OP_CODE and WORD_OP_CODE are themselves variant records. 
Their dTscriminated components are used to specify operand 
addressing modes together with needed registers, displacements 
and literal values. The type mark BYTE_OP_CODE is used for those 
VAX-11 instructions whose opcodes can be represented in a single 
byte (e.g., MOVL). WORD_OP_CODE is used for those VAX-11 
instructions whose opcodes consume two bytes (e.g., CMPH). 

These ideas are Illustrated in Figure F-1 below. A more 
detailed explanation of how machine code insertions are composed 
for the VAX target is given in section 6.14. In this example the 
procedure TIMES_TWO is used to double integer valued objects. It 
effects a multiplication of its single argiiment using the 
Arithmetic Shift Logical instruction, ASHL. The value to be 
multiplied is passed by reference to the procedure TIMES_TWO and 
can be found four bytes away from the address held in the 
Argument Pointer, AP. Using byte displacement deferred 
addressing mode (i.e., IB AP) to access the procedure argument 
allows the shift by one bit to occur **in place". 


F.13 


Machine Code Insertions 


F-27 




ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


with MACHINE_CODE ; use MACHINE_CODE ; 

procedure TIMES_TWO(value : IN OUT integer) is 
begin 

B\TE_OP CODE’ ( 


OP 

-> 

ASHL. 




-- Instruction 

- ASHL 

ASHL_1 

-> 

( 

OP -> 

IMD, B 

_IMD -> 1 ), 


- - Operand 1 - 

** ** 

ASHL 2 

-> 

( 

OP -> 

IB AP,' 

'byte DISP -> 

A). 

-- Operand 2 - 

(c4(AP) 

ASHL 3 

-> 

( 

OP -> 

IB AP. 

BYTE DISP -> 

4) ) 

:- - Operand 3 - 

-;aA(AP) 


end TIMES_'IVO ; 

Figure F-1 - Machine Code Insertion 


F-28 


F.13 Machine Code Inse 





ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


F.13.1 Machine Features 

This paragraph describes* specific machine language features 
needed to write code statements. These machine features include 
the OISP and ADDRESS attributes and the address mode specifiers. 
The address mode specifiers make it possible to describe both the 
address mode and register niimber of any operand as a single value 
by mapping these values directly onto the first byte of each 
operand. The following is an entuneration of all mode specifiers: 


-- The first 64 are the short literal modes. • 

— These mode specifiers signify (short literal mode, value) 

— combinations. The values are in the range 0 to 63. 


LO, 

LI, 

L2, 

L3, 

L4/ 

L5, 

L6, 

L7, 

L8, 

L9, 

LIO, 

Lll, 

L12, 

L13, 

L14, 

L15, 

L16, 

L17, 

L18, 

L19, 

L20, 

L21, 

L22, 

L23, 

L24, 

L25, 

L26, 

L27, 

L28, 

L29, 

L30, 

L31, 

L32, 

L33, 

L34, 

L35, 

L36, 

L37, 

L38, 

L39, 

L40, 

L41, 

L42, 

L43, 

L4^., 

L45, 

L46, 

L47, 

L48, 

L49, 

L50, 

LSI, 

L52, 

L53, 

L54, 

L55, 

L56, 

L57, 

L58, 

L59, 

LgO, 

L61, 

L62, 

L63, 


F.13.1 Machine Features 


F-29 




Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


Nexb are the (index mode, register) combinations. 


X_RO, 

X_R4, 

X_R8, 

X_AP, 

The following 


X_R1, 

X_R5, 

X_R9, 

X_FP, 

are the (register 


X_R2, 

X_R6, 

X_R10, 

X_SP, 

mode, register) 


X_R3, 

X_R7, 

X_R11, 

X_PC, 

combinations 


RO, 

Rl 

R4, 

R5 

R8, 

R9 

AP, 

FP 


R2, 

R3, 

R6, 

R7, 

RIO, 

Rll 

SP, 

PC, 


— The following are the (indirect register mode, register) 

— combinations. 


IRO, 

IRl 

IR4, 

IRS 

IR8, 

IR9 

lAP, 

IFP 


IR2, 

IR3, 

IR6, 

IR7, 

IRIO, 

IRll 

ISP, 

IPC, 


— Next are the (autodecrement register mode, register) 

— combinations. 


DEC RO, 
DEC“R4, 
DEC R8, 
DEC“AP, 


DEC Rl, 
DEC“R5, 
DEC~R9, 
DEC~FP, 


DEC R2, 
DEC~R6, 
DEC~R10, 
DEC SP, 


DEC_R3 , 
DEC_R7, 
DEC Rll, 
DEC PC, 


— Next are the (autoincrement register mode, register) 

— combinations. IMD (immediate mode) is autoincrement 

— mode using the PC. 


RO_INC, 

R4_INC, 

R8_INC, 

AP_INC, 


R1_INC, 

R5_INC, 

RS_INC, 

FP_INC, 


R2_INC, 

R6_INC, 

R10_INC, 

SP_INC, 


R3_INC, 

R7_INC, 

R11_INC, 

IMD, 


— The following are the (autoincrement deferred mode, register) 

— combinations. A (absolute address mode) is autoincrement 

— deferred using the PC. 


IRO_INC, 

IR4_INC, 

IR8_INC, 

IAP_INC, 


IRl INC, 
IR5”INC, 
IR9~INC, 
IFP INC, 


IR2_INC, 
IR6_INC, 
IR10_INC, 
ISP_INC, 


IR3_INC, 

IR7_INC, 

IR11_INC, 

A, 


F-30 


F.13.1 Machine Features 




ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


— The following are the (byte-displacement mode, register) 

— combinations. B_PC is byte-relative mode for the PC. 


B_R0, 
B_R4, 
B_R8, 
B AP, 


B Rl, 
B_R5, 
B_R9, 
B_FP, 


B_R2, 

B_R6, 

B_R10, 

B_SP, 


B_R3, 

B_R7, 

B_R11, 

B_PC, 


— Next are the (byte-displacement deferred mode, register) 

— combinations. IB_PC is byte-relative deferred mode for 

— the PC. 

IB_RO, 

IB_R4, 

IB_R8, 

IB_AP, 

— The following are the (word-displacement mode, register) 

— combinations. W PC is word relative mode for the PC. 


IB_R1, 
IB_R5, 
IB_R9, 
IB_FP, 


IB_R2, 
IB_R6, 
IB_R10, 
IB_SP, 


IB_R3, 
IB_R7, 
IB_R11, 
IB_PC, 


W_R1, W_R2, W_R3, 

W_R5, W_R6, W_R7, 

W_R9, W_R10, W_R11, 

W_FP, W_SP, W_PC, 

— The following are the (word-displacement deferred mode, 

— register) combinations. IW_PC is word relative deferred 

— mode for the PC. “ 


W_RO, 
W_R4, 
W R8, 

Wap, 


IW_RO, 
IW_R4, 
IW_R8, 
IW_AP, 


IW_R1, 
IW_R5, 
IW_R9, 
IW_FP, 


IW_R2, 
IW_R6, 
IW_R10, 
IW SP, 


IW R3, 
IW~R7, 
IW_R11, 
IW_PC, 


— Next are the (longword-displacement mode, register) 

— combinations. L_PC is longword-relative mode. 

L_R1, L_R2, L_R3, 

L_R5, L_R6, L_R7, 

L_R9, L_R10, L_R11, 

L_FP, L_SP, L_PC, 

— The following are the (longword-displacement deferred mode, 

— register) coi^inations. IL_PC is longword-relative deferred 

— mode. 


L_R0, 

L_R4, 

L_R8, 

L_AP, 


IL_R0, 
IL_R4, 
IL_R8, 
IL_AP, 


IL_R1, 
IL_R5, 
IL_R9, 
IL_FP, 


IL_R2, 

IL_R6, 

IL_R10, 

IL_SP, 


IL_R3, 
IL_R7, 
IL_R11, 
IL_PC) ; 


F.13.1 Machine Features 


F-31 







Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.13.2 ADDRESS and DISP Attributes 

The following restriction applies to the use of the ADDRESS 
and DISP attributes: 


a. All displacements and addresses (i.e., branch destinations, 
progreun counter addressing mode displacements, etc.) must be 
static expressions. 

b. Since neither the ADDRESS nor the DISP attributes return 
static values, they can not be used in code statements within 
the Ada compilation unit. 


F.13.3 Restrictions on Assembler Constructs 

These unsupported Assembler constructs within the 

MACHINE_CODE package are as follows: 

a. The VAX/VMS assembler's capability to compute the length of 
immediate and literal data is not replicated in MACHINE CODE. 
This means the user cannot supply a value without specifying 
the length of that value. This disallows the assembler 
operand general formats: D(R), G, G^G, Icons, Icons[Rx], 
D(R)[RX], G[RX], G^location[Rx], §D(R)[Rx], eG[Rx], §D(R), §G 
such that D and G are byte, word, or long^word values. 
Operands must contain address mode specifiers which 
explicitly define the length of any immediate or literal 
values of that operand. 

b. The radix of the assembler notation is decimal. To express a 
hexadecimal literal, the notation 16|literal| should be used 
instead of ''X. 

c. To construct an octaword, guadword, g_float or h_float 
number, it is important for the user to remember that the 
component fields of the records that make up the long numeric 
types are signed. This means that the user must take care to 
be assured that the values for these components, although 
signed, are interpreted correctly by the instruction set 
architecture. 

d. Edit instruction streams must be constructed through the use 
of the VAX data statements described in Section 6.12.3. 


F-32 


F.13.3 Restrictions on Assembler Constructs 







ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


e. Compatibility mode instruction streams must be constructed 
through the use of the VAX data statements described in 
Section 6.12.3, if still supported on the VAX computer being 
utilized as the target machine (i.e., VAX-11/780 and 785, but 
not the VAX-8600). 

f. No error messages are generated if the PC is used as the 
register for operands taking a single register, if the SP or 
PC are used for operands taking two registers, or if the AP, 
FP, SP, or PC is used for operands taking four registers. 

g. No error message is generated if the PC is used in register 
deferred or autodecrement mode. 

h. If any register other than the PC is used as both the 
simple_operand and as the index_reg for an operand (see 
Section 6.14.1.2 for definitions of simple_operand and 
index_reg) , no error message is generated. An ex 2 unple of 
this case is the VAX Assembler operand (7) [7]. 

i. Generic opcode selection is not supported. This means the 
opcode which reflects the specified number of operands must 
be used. For example, for 2 operand word addition, ADDW2 
must be used, not just AODW. 

j. The PC is not supplied as a default if no register is 
specified in an operand. The user must supply the mode 
specifier which is mapped onto the PC. Examples are IMD, A, 

B PC, W PC, etc. 


F.13.3 Restrictions on Assembler Constructs 


F-33 



Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.14 Machine Instructions and Data 

This section describes the syntactic details for writing code 
statements (machine code insertions) as provided for the VAX by 
the pre-defined package MACHINE^CODE. The format for writing 
code statements is detailed, as^are descriptions of the values to 
be supplied in the code statements. Each value is described by 
the named association for that value and its defined in the order 
in which it must appear in positional notation. The pro^ammer 
should refer to the VAX-IL Architecture Handbook along with this 
section to ensure that the machine instructions are correct from 
an architectural viewpoint. 

To ensure a proper interface between Ada and machine code 
insertions, the user must be aware of the calling conventions 
used by the Ada compiler. 


F.14.1 VAX Instructions 

The general format for VAX code statements where the opcode 
is a one byte opcode is 

BYTE OP_CODE (OP => opcode {, "opcode" 1 => operand 
~ (,"opcode^ 2 => operand 

(, "opcode'*’’ 3 => operand 
(,"opcode^ 4 => operand 
(, "opcode**^ 5 *> operand 
{,"opcode^_6 *> operand})}}))); 

The general format for VAX code statements where the opcode 
is a two byte opcode is 

WORD_OP_CODE (OP => opcode2 {,"opcode2" 1 => operand 

{, "opcode2’*^_2 => operand 
{,"opcode2" 3 => operand 
{,"opcode2^_4 => operand 
{,"opcode2" 5 => operand 
{,"opcode2**^_6 => operand)))}}}); 

where "opcode"_n and "opcode2"_n is the result of the 
concatenation of the VAX opcode, an underscore, and the position 
of the operemd in the VAX instruction. The BYTE_OP CODE and 
WORD_OP_CODE statements always require an opcode an3 may include 
from one to six operands. The opcode mnemonics are precisely the 
same as described in the previously referenced VAX-11 
Architecture Handbook. The VAX address modes divide the operands 
into six general categories: Short Literal Operand, Indexed 
Operand, Register Operand, Byte-Displacement Operand, 
Word-Displacement Operand, and Long_Word-Dispiacement Operand. 


F-34 


F.14.1 VAX Instructions 



ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


F.14.1.1 Short Literal Operands 

The VAX/VMS Assembler format for short literal operands is 
Icons 

where cons is an integer constant with a range from 0 to 63 
(decimal). 

The code statement format for short literal operands is 
(OP => short_lit) 

where short_lit is one of the enumerated values, range LO to L63, 
of the address mode specifiers in Section 6.11.1. 

The following are examples of how some VAX Asseiublsr short 
literals would be expressed in code statements: 

S^#7 becomes (OP *> L7) 

S^#33 becomes (OP *> L33) 

3^160 becomes (OP *> L60) 

(For explanations of named and unnamed component association, see 
Section 4.3 of the Ada Language Reference Manual.) 


F.14.1.2 Indexed Operands 

The VAX/VMS Assembler format for the indexed operands is 
simple_operand[Rx] 

where a simple_operand is an operand of any address mode except 
register, literal, or index. 

The general code statement format for indexed operands is 

(index_reg, simple_operand) or 

(OP => index_reg, OPND => simple_operand) 

where index_reg is one of the enumerated address mode specifiers, 
range X_R0 to X_SP, from Section 6.11.1. Simple_operand is an 
operand of any address mode except register, literal, or index. 


F.14.1.2 Indexed Operands 


F-35 




Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


For example, the following are indexed assembler operands; 

a. (R8)[R7] becomes (X_R7, (OP »> IR8)) 

b. (R8) + [R7] becomes (X_R7, (OP *> R8_INC)) 

c. I^#600[R4] becomes (X_R4, (IMD,600)) 

d. -(R4)[R3] becomes (X_R3, (OP => DEC_R4)) 

e. B''4(R9)[R3] becomes (X_R3, (B_R9,4)) 

f. W''800(R8) [R5] becomes (X_R5, (W_R8,800)) 

g. L^34000(R8)[R4] becomes (X_R4,(L_R8,34000)) 

h. B^10[R9] becomes (X_R9, (B_PC,10)) 

i. W^130[R2] becomes (X_R2, (W_PC,130)) 

j. L^35000[R6] becomes (X_R6, (L_PC,35000)) 

k. @(R3)+[R5] becomes (X_R5, (OP => IR3_INC)) 

l. §#1432[R5] becomes (X_R5, (A,1432)) 

m. @B* 4(R9) CR3] becomes (X_R3, IB_R9,4)) 

n. @W^8(R8)[R5] becomes (X_R5, (IW_R8,8)) 

o. eL^2(R8)[R4] becomes (X_R4, (IL_R8,2)) 

p. §B^3[R1] becomes (X_R1, (IB_PC,3)) 

q. @W^150[R2] becomes (X_R2, (IW_PC,150)) 

r. 9L^100000[R3] becomes (X_R3, (IL_PC,100000)) 


F-36 


F.14.1.2 Indexed Operands 




ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


Then would be expressed in named notation as: 


a. 

(OP 

»> 

X, 


OPND 

*> 

(OP 


IR7)) 

b. 

(OP 

=> 

X. 


OPND 

=> 

(OP 

=> 

R8_INC)) 

c. 

(OP 

=> 

x_ 

R4, 

OPND 

*> 

(OP 

=*> 

IMD, W_IMD => 600) ) 

d. 

(OP 

=> 

X. 

_R3, 

OPND 

=> 

(OP 

=> 

DEC_R4)) 

e. 

(OP 

=> 

X. 

.R3, 

OPND 

=> 

(OP 

=> 

B_R9, BYTE_DISP => 4)) 

f. 

(OP 

=> 

x_ 

_R5, 

OPND 

=■> 

(OP 

=> 

W_R8, WORD_DISP => 800)) 

g- 

(OP 

=> 

x_ 

_R4, 

OPND 

=> 

(OP => L R8, 

LONG_WORD_DISP => 34000)) 

h. 

(OP 

=> 

X. 

_R9, 

OPND 

=> 

(OP 

=> 

B_PC, BYTE_DISP => 10)) 

i. 

(OP 

=> 

X, 

_R2, 

OPND 

=> 

(OP 

=> 

W_PC, WORD_DISP => 130)) 

j- 

(OP 

=> 

X. 

_R6, 

OPND 

=> 

(OP => L PC, 

LONG_WORD_DISP => 35000)) 

k. 

(OP 

*> 

X. 

R5, 

OPND 

=> 

(OP 

=> 

IR3_INC)) 

1. 

(OP 

*> 

X. 

in 

OPND 

=> 

(OP 

=> 

A, ADDR => 1432)) 

m. 

(OP 

=> 

x_ 

.R3, 

OPND 

=«> 

(OP 

=> 

IB_R9 , BYTE_DISP =*> 4) ) 

n. 

(OP 

=> 

X, 

.R5, 

OPND 

=> 

(OP 

=> 

IW_R8, WORD_DISP => 8)) 

o. 

(Ot 

=> 

x_ 

.R4, 

OPND 

=> 

(OP => IL R8, 

IiONG_WORD_DISP => 2)) 

P- 

(OP 

=> 

X, 

_R1, 

OPND 

=> 

(OP 

=> 

IB_PC, B_DISP => 3)) 

q* 

(OP 

=> 

X, 

.R2, 

OPND 

=> 

(OP 

=> 

IW_PC, WORD_DISP => 150)) 

r. 

(OP 

=> 

x_ 

.R3, 

OPND 

=> 

(OP => IL PC, 

LONG_WORD_DISP => 100000)) 


F.14.1.2 Indexed Operands 


F-37 




Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.14.1.3 Register Operands 

The VAX/VMS Assembler formats for register operands are 

Rn — Register mode 
(Rn) — Register deferred mode 
-(Rn) — Autodecrement mode 

(Rn)+ — Autoincrement mode 

§(Rn)+ — Autoincrement deferred mode 

where Rn represents a register niunbered from 0 to 15. 

The general code statement format for register operands is 


(OP => regmode_value) 

where regmode_value represents 
specifier range RO to PC,■from 

The following are examples 
mode operands would be written 

R7 becomes 

(R8) becomes 

-(R9) becomes 

(Rl)+ becomes 

@(R3)+ becomes 


one of the enumerated address mode 
Section 6.11.1. 

of how VAX/VMS Assembler register 
as code statements: 

(OP => R7) 

(OP => IRS) 

(OP => DEC_R9) 

(OP => R1_INC) 

(OP *> IR3 lUC) 


F.14.1.4 Byte-Displacement Operands 

The VAX/VMS Assembler syntax for the byte-displacement 
operands is 

B^d(Rn) — Byte-displacement mode 

@B^d(Rn) — Byte-displacement deferred mode 

where d is the displacement added to the contents of register Rn. 
If no register is specified, the program counter is assumed. The 
code statement general format for the byte-displacement and 
byte-displacement deferred modes is 

(byte_disp_spec, value) 

or 

(OP => byte__disp_spec, BYTE_DISP => value) 

where byte_disp_spec is one of the eniunerated address mode 
specifiers, range B RO to B_PC for byte-displacement or IB_R0 to 
IB_PC for byte displacement deferred, from Section 6.11.1. Value 
is in the range -128 to 127. 


F-38 


F. 14.1.4 Byte-Displacement Operands 


ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


The following are examples of how VAX/VMS Assembler 
byte-displacement operands would be written in code statements: 


B^4(R5) 

becomes 

(8_R5, 

4) 

or 






(OP »> 

8 R5, 

BYTE 

_DISP 

=> 

4) 

8^200(R5) 

becomes 

(B_R5, 

200) 

or 






(OP »> 

8 R5, 

BYTE_ 

.DISP 

=> 

200) 

8^33 

becomes 

(B_PC, 

337 

or 






(OP => 

8 PC, 

BYTE_ 

.DISP 

=> 

33) 

§8^4(R5) 

becomes 

(IB R5, 

4) 

or 






(OP *> 

IB R5, 

BYTE_ 

_DISP 

=> 

4) 

08^200(R5) 

becomes 

(IB R5, 

200) 

or 






(OP => 

IB R5, 

BYTE_ 

.DISP 

=> 

200) 

§8^33 

becomes 

(IB PC, 

33) 

or 






(OP => 

IB PC, 

BYTE, 

.DISP 

=> 

33) 


F. 14.1.5 Word-Displacement Operands 

The VAX/VMS Assembler syntax for the word-displacement 
operands are 

W-^dCRn) — Word-displacement 

ew^d(Rn)- -- Word-displacemenc deferred 

where d is the displacement to be added to the contents of 
register Rn. If no register is specified, the program counter is 
ass;imed. In code statements, word displacement operands are 
represented in general as 

(word_disp_spec, value) 

or 


(OP => word_disp_spec, WORD_DISP => value) 

where word_disp_spec is one of the enumerated address mode 
specifiers, range W_RO to W_PC for word-displacement mode or 
IW_R0 or IW PC for word-displacement deferred mode, from Section 
6.11.1. Value is in the range -2**15 to 2**15 - 1. 


The following are examples of how VAX/VMS Assembler 
word-displacement operands would be written in code statements: 


W^IO(R5) 
W^20 

@W''128 (R7) 
@W^324 


becomes (W_R5, 10) or 

(OP => W_R5, WORD_DISP => 10) 
becomes (W_PC, 20) or 

(OP *> W_PC WORD_DISP => 20) 
becomes (W_R7, 128) or 

(OP => IW R7 WORD_DISP => 128) 
becomes (W_PC, 3247 or 

(OP => IW_PC WORD_DISP => 324) 


F. 14.1.5 Word-Displacement Operands 


F-39 




Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F. 14.1.6 Long_Word-Displaceinent Operands 

The VAX/VMS Assembler general formats for the 
long_vord-displacement operands is 

L''d(Rn) — Long_word-displacement 

§L^d(Rn) — Long_word-displacement deferred 

where d is the displacement to be added to the register 
represented by Rn. Long_word-displacement operands are 
represented in code statements by the general format 

(lword_disp_spec, value) 

or 

(OP => lword_disp_spec, LONG_WORD_DISP => value) 

where lword_disp_spec is one of the en\amerated address mode 
specifiers, range L RO to L PC for long_word-displacement mode or 
IL_RO to IL_PC for Tong_^wor3-displacement deferred mode, from 
Section 6.11.1. Value Ts in the range -2**31 to 2**31 - l. 

The following are examples of how VAX/VMS Assembler 
long_word-displacement operands would be written in code 
statements; 


L^1000(R7) 

L^25000 

@L''1000(R9) 

eL^3500 


becomes 

becomes 

becomes 

becomes 


(L_R7, 1000) or 

(OP => L_R7, LONG WORD_DISP *> 1000) 
(L_PC, 25000) or 

(OP »> L_PC, LONG_WORD_DISP *> 25000) 
(IL_R9, 1000) or 

(OP *> IL_R9, LONG_WORD_DISP => 1000) 
(IL_PC, 3500) or 

(OP => IL_PC, LONG_WORD_DISP => 3500) 


F.14.2 The CASE Statement 

The VAX case statements (mnemonics CASES, CASEW, and CASEL) 
have the following general symbolic form 

opcode selector.rx, base.rx, limit.rx, 

displ[0j.bw, .. , displ[limit].bw 

where x is dependent upon the opcode as to whether the ooerand is 
of type BYTE, WORD, or LONG_WORD. Displ [0].bw, .. , 

displ[limit].bw is a list of displacements to which to branch. 
Case statements would be written as code statements as: 


F-40 


F.14.2 The CASE Statement 




ALS/N Reference Handbook 


Version 4.5 
29 March 1991 


BYTE_OP_CODE(OP => case opcode,"case_opcode"_l*> operand, 
"case^opcoSe" 2 *> operand, 

''case_opcode^__3 =»> case_operand) 

where case opcode Is one of CA5EB, CASEW, or CASEL. The type of 
operand an3 case operand are as indicated in the opcode (BYTE, 
WORD, or LONG_WORO). A case_operand is a special case operand of 
the form: 

case_operand => (case_limit_address_mode, (case_enuB)) 

or 

case_operand => (LIMIT => case_limit_address_mode, 
(CASES=>case_entm)) “ 

if caae_liinit_address mode is one of the short literal address 
specifiers. If case Timit_address__mode is the mode specifier 
IMD, the case_operan3 takes the form: 

case_operand => (IMD, (case_limit, (case_enum))) 

or 

case_operand => (LIMIT *> IMD, c:ase_LIST => 

“(LIMIT =■> case^limit, (CASES »> case_enum))) 

where case operand is one of BYTE CASE OPERAND, 

WORD_CASE OPERAND, or LONG_WORD_CASE__OPERAND. The 
case^limi€__address_^mode is one of the short literal mode 
specifiers“or the mode specifier IMD. Case enum is a list of 
branch addresses. The branch addresses mus€ be of type WORD. 

The case_limit is a value of the type indicated by the 
case_opcode. 

Some examples of case statements written as code statements 

are: 

«START» • BYTE_OP CODE(CASEB, (OP =>R3, (IMD, 5), (IMD 

(2,715,30,45))))); — Case statement using 

— immediate mode. 

S2 BYTE 0P_C0DE(CASEW, (OP => (W_PC, 10)) , (IMD, 100), 

7L2 ,(10,20,30))) ; — Case statement using 

— short literal mode. 


F.14.2 The CASE Statement 


F-41 





Version 4.5 
29 March 1991 


ALS/N Reference Handbook 


F.14.3 VAX Data 

Constant values such as absolute addresses or displacements 
may be entered into the code stream with any of these nine 
statements: 

BYTE_VAHJE' (byte) 

WORD_VALUE'(word) 

LONG_WORD_VALUE' (long_word) 

QUADWORD_VALUE" (quadword) 

OCTAWORD_VAUJE' (octaword) 

FLOAT_VALUE' (float) 

LONG_FLOAT_VALCJE' (long_float) 

G_FLOAT_VALUE' (g_float) 

H FLOAT_VALUE'(h float) 


F-42 


F.14.3 VAX Data 






