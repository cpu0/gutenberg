General Disclaimer 


One or more of the Following Statements may affect this Document 


• This document has been reproduced from the best copy furnished by the 
organizational source. It is being released in the interest of making available as 
much information as possible. 


• This document may contain data, which exceeds the sheet parameters. It was 
furnished in this condition by the organizational source and is the best copy 
available. 


• This document may contain tone-on-tone or color graphs, charts and/or pictures, 
which have been reproduced in black and white. 


• This document is paginated as submitted by the original source. 


• Portions of this document are not fully legible due to the historical nature of some 
of the material. However, it is the best reproduction available from the original 
submission. 


Produced by the NASA Center for Aerospace Information (CASI) 




Onderafdeling der Wiskunde en Informatica 

Julianalaan 132,2628 BL Delft 
Postbus 356, 2600 AJ Delft 

Department of Mathematics and Informatics 

Juliana laan 132, 2628 BL Delft 
P.O. Box 356, 2600 AJ Delft 


Rapporten van de 
Onderafdeling < ler Wiskunde 


en Informatica 


Reports of the 
Department of Mathematics 




CONTENTS 


1. Inleiding 1 

2. Status van Ada 2 

3 . Ada in Europe 4 

3.1 Feitelijke ontwikkelingen binnen de E.G 4 

3.2 Ada Europe 5 

3.3 Contacten Europa en DoD 6 

4. Ada Programming Support Environments. 7 

4.1 Requirements voor een APSE......... 7 

4.2 De database 9 

4.3 APSE's in ontwikkeling ... 10 

4.4 De CAIS ontwikkelingen 12 

5. Ada in Nederland 14 

6. Ada in Delft 15 

6.1 Inleiding 15 

6.2 De DAPSE 15 

7. Implementatie van een Ada subset 17 

7.1 Compiletime aspecten 18 

7.2 Runtime aspecten.... '. 21 

8. DAS data descriptie model 22 

8.1 Oplossingsmodel 22 

8.2 Implementatie implicaties van het model... 26 

8.3 Records, adresseren van componenten en variant 

selectie.. 28 

9. Conclusies en verder werk... 34 

10. Bibliografie 35 


Ada ia een gedeponeerd handelamerk van DoD OUSDRE-AJPO 


ABSTRACT 


In dit rapport, samengesteld naar aanleidlng van een 
voordracht van de auteur op 14 maart 1984 op het informatics 
colloquium van de VU te Amsterdam, wordt ingegaan op een 
drietal ontwikkelingen rond de programmeertaal Ada. 

Eerst komen wereldwijde ontwikkelingen rond de 
programmeertaal Ada ter sprake, vervolgens wordt een 
overzicht gegeven van de activiteiten op dit gebied 
ontplooid aan de Technische Hogeschool te Delft en tenslotte 
wordt, in een meer technisch gedeelte, een aspect behandeld 
van de implementatie van de Delftse Ada Subset, DAS, 


1. Inlelding. 

Dit rapport bestaat uit drie gedeelten. In het eerste deel zal worden 
ingegaan op de wereldwijde ontwikkelingen rond Ada. Het tweede deel 
geeft een korte impressie van de Ada activiteiten aan de TH Delft. Het 
derde deel is meer technisch van aard en geeft een inleiding in de 
structurering en beschrijving van data structuren in de Ada subset 
implementatie die aan de TH Delft wordt ontwikkeld. 

Er wordt vanuit gegaan dat de lezer/toehoorder op de hoogte is 
van het bestaan van de programmeertaal Ada en van de oorspronkelijke 
achtergronden die tot de ontwikkeling van de taal hebben geleid, 

Het is niet de bedoeling uitgebreid in te gaan op de al dan niet 
vermeende kwaliteiten van Ada. Ada zal zich zelf, tenminste in de 
toepassingsgebieden waarvoor de taal bruikbaar wordt verondersteld , 
moeten bewijzen. Het heeft geen zin daarnaast veel uitlatingen te doen 
over het al dan niet mooi zijn van bepaalde constructies of 
combinaties van zulke constructies. 


- 2 - 

Ontwikkelingen rond Ada 
2. Status van Ada. 

Toen de "Green" language in 1979 als DoD 3tandaard werd geaccepteerd 
en de naam "Ada" kreeg, verwachtte de wereld op korte termijn 
programmatuur in Ada te kunnen draaien. Weliswaar wa3 aan de dikte van 
het reference manual te zien dat de definitie van de taal langer was 
dan de definitie van bijvoorbeeld PASCAL, toch zijn alle problemen 
behoorlijk onderschat. Nu, vijf jaar nadat Wichmann de historische 
woorden "Ada is green" [Wichmann] schreef is er slechts een handje vol 
gevalideerde 2 implementaties. Deze zijn, volgens [AJPOnews] (juli 
1984) : 

+ De NYU Ada/Ed implementatie. Een in SETL geschreven "semantisch 
model", bestaande uit een kleine 20k SETL regels. De 
implementatie draait op diverse hostsystemen , een VAX onder VMS 
en onder UNIX en een Amdahl onder UTS. G. Fisher een van de 
makers heeft (regeimatig) de woorden "If it moves it's fast 
enough" uitgesproken, een indioatie over de snelheid van de 
implementatie, Na de validatie van de implementatie zijn 
overigens nog enkele tientallen fouten in de implementatie aan 
het licht gekomen. Geconstateerd kan worden dat het nlet 
triviaal is om te verifieren of een implementatie een gegeven 
taal werkelijk implementeert. 

Validatie datum was 11 april 1983. 

+ ROLM Corporation/Data General Corporation implementatie. ROLM Ada 
Compiler version 4.52 Host and targets: Data General MV4000, 
MV6000 , MV8000, MV8000-n, MV10000 en ROLM MSE-800. 

De datum van validatie was 13 -juni 1983. 

+ Gensoft Corporation (voorhecn Systems Technology Center., Western 
Digital Corporation) implementatie. 

Host en target machines: Western Digital WD1600 Series Micro 
Engine 

Validatie datum was 9 augustus 1983. 

+ Telesoft Inc. compiler. Deze compiler i3 gevalideerd draaiend 
onder 68000 ROS operating systeem op een O-bus systeem en een 
LABTEK systeem. 

Datum van validatie was 21 mei 1984. 

De Ada taal is, sinds zijn ontstaan in 1979, in aanzienlijke mate 
gewijzigd. In 1980 kwam het eerste "groene" document, waarna de 
"canvass" procedure werd aangespannen om tot een ANSI standaard te 
komen. Tijdens deze procedure werden meer dan 5000 commentaren op de 
taal gegeven. 

De coordinatie van de ontwikkelingen rond het hele Ada gebeuren werd 
in handen gelegd van een buro, het Ada Joint Program Office, AJP0. 

Op 18 februari 1983 kwam er een door ANSI gestandaardiseerde versie 


2. Ada is pas Ada als DoD er Ada op gezet heeft. Een implementatie 
mag pas een Ada implementatie heten als ze gevalideerd is onder 
toezicht van DoD. 



Ontwikkelingen rond Ada 


- 3 - 


[LRM] uit. Een eersbe poging om de ANSI standaard tot ISO "workitem" 
te verheffen is vertraagd door de zg. trademark affaire. Sommige ISO 
leden, waaronder Zwitserland, hebben problemen met het felt dat DoD 
zou moeten kunnen bepalen of een implementatie aan een door ISO 
gedefinieerde standaard zou voldoen of niet. 

Toch is 3inds april 1984 de Internationale standaardisatie van Ada in 
voile gang, een ISO werkgroep, TC97/SC5/WG14 , is belast met de 
voorbereiding van de standaard. 

Ook is een nieuwe rationale in ontwikkeling. Daarin zouden een aantal, 
voor de buitenwereld onduideli jke, beslis3ingen verklaard kunnen 
worden. 


- 4 - 

Ontwikkelingen rond Ada 
3. Ada in Europa. 

In het midden van de 70' er Jaren werd een ESL (European System 
Language) studie begonnen onder auspicien van de Commissie van de 
Europese Gemeensohappen (CEC), kortweg de Commissie. De studie kende 
een resultaat dat nogal leek op het toenmalige ontwerp van de "green" 
language. Dit is niet zo verwonderlijk als men de "requirements" 
nagaat voor de ESL: 

+ portabiliteit van software, 

+ competitie tussen leveranciers, 

+ verbeterde kwaliteit van software, 

♦ verbetering van software engineering methoden. 

Gelet op de overeenkomsten tussen de requirements van de ESL en de DoD 
taal [en waarschijnlijk ook het felt dat het door DoD uitverkoren 
ontwerp, Green, van europese origine was] werd door de Commissie de 
ondersteuning aan de ESL ontwikkelingen gestaakt en support voor Ada 
gegeven. 

Dit uiteraard zeer naar de zin van DoD, binnen DoD is vanaf het begin 
een sterke wil aanwezig geweest om van Ada een, met reoht 
Internationale, standaard te maken. 

De huidige ondersteuning van Ada onder het zg. "multi annual data 
processing programme" is gebaseerd op een tweetal punten: 

+ Ada voldoet in grote mate aan de requirements voor de ESL, 

+ voor producten, "software componenten" is er na een 
internationale standaardisatie een grotere markt dan voor op ESL 
gebaseerde componenten. Door de Commissie wordt gedacht aan een 
sterkere eigen europese software componenten Industrie. Momenteel 
is de invoer van soft- en hardware componenten binnen de EG een 
veelvoud van de bijdrage van de europese Industrie aan de 
thuismarkt. 

3.1 Feitelijke ontwikkelingen binnen de E.G. 

Onder het huidige multi-annual programme ondersteunt de Commissie een 
aantal projecten, waarvan de belangrijkste zijn: 

1. De portable Ada Compiler family, een europese "root" compiler 
ontwikkeld door een consortium bestaande uit CII/Honeywell Bull, 
Alsys (de firma van Ichbiah) en Siemens, 

2. De Portable Ada Programming Support Environment, PAPS, een 
europese implementatie gebaseerd op de Stoneman requirements, 
uitgevoerd door een consortium bestaande uit Olivetti, Dansk 
Datamatik Center en Christian Rovsing 


Ontwlkkelingen rond Ada 


- 3 - 


[LRM] ulfc. Een eerate poging om de ANSI 3tandaard tot ISO "workitem" 
te verheffen is vertraagd door de zg, trademark affaire. Sommige ISO 
leden, waaronder Zwit3erland, hebben problemen met het felt dat DoD 
zou moeten kunnen bepalen of een implementabie aan een door ISO 
gedefiniaerde standaard zou voldoen of niet, 

Toch is sinds april 198M de Internationale standaardisatie von Ada in 
voile gang, een ISO werkgroep, TC97/SC5/WG14 , is belast met de 
voorbereiding van de standaard. 

Ook is een nieuwe rationale in ontwikkeling . Daarin zouden een aantal, 
voor de buitenwereld onduideli jke, beslissingen verklaard kunnen 
worden. 


- 5 - 


Ontwikkel ingen rond Ada 


Anders, door de Commissie onder3teunde projecten, zijn hoofdzakelijk 
voorstudies: 

1. life cycle support voor Ada projecten (SDL en TECSI), 

2. Ada en een multi-mieroproce33oir omgeving (SPL, TXT en CISE), 

3. conversie van RTL/2 naar Ada (SPL en HSA) , 

4. grote numerieke bibliotheken in Ada (NPL en CWI). 


Voor meer details wordt verwezen naar het bureau van de CEC3. 

3.2 Ada Europe, 

On binnen Europa in een iets breder verband te kunnen di3cussieren 
over de diverse aspecten van de ontwikkelingen rond Ada, is er al in 
1980 een Ada Europe groep gevormd. Een van de initiatiefnemers was 
Brian Wichmann, tevens een van de leden van het ontwerpteam vnn de 
taal. 

De groep is gevormd door personen en organisaties die, Leroepshalve, 
geintereseerd zijn in de implementatie en het gebruik van Ada, 0m 
zo'n groep werkbaar te maken zijn er subgroepen gevormd waarin de 
diverse aspecten van de taal of haar gebruik aan de orde komen. 
Momenteel zijn er subgroepen voor o.a.: 

+ Education, 

+ Formal Application semantics, 

+ Environments, 

+ Portability, 

+ Numerics, 

+ Implementation, 

+ Validation. 

De huidige vice voorzitter van Ada Europe is een nederlander, M. 
Boasson van HSA. De huidige voorzitter is K. Ripken van TECSI. 
Overigens zijn niet alle subgroepen even actief. 

Ada Europe heeft momenteel een 100 tal leden, verspreid over geheel 
Europa. Een van de belangrijkste activiteiten is de jaarlijks 
terugkerende "joint Ada Europe/ AdaTec" meeting, dit jaar in juni, in 


3. Dr. R. W. Meyer, 

Commission of the European Communities, 
DG-III 

Rue de loi 200 Brussels, B-1049 


- 6 - 

Ontwikkelingen rood Ada 
Brussel . 

De Commis3ie ondersteunt het werk van Ada Europe door rels en 
verblljfko3ten von de leden voor de diverse bijeenkomsten be 
vergoeden. 

3.3 Confcacten Europa en DoD, 

Een Ada Lia3on Organisation (ALO) is gevormd om de AJPO in alle3 wat 
met Ada betrekking heeft te adviseren en om een lia3on te 
implementeren tU3sen AJPO en andere belanghebbenden, onder andere in 
Europa. 


3.3.1 Interessante europese implementaties. Binnen en buiten Europa 
wordt op verschillende plaatsten gewerkt aan implementaties van de 
taal Ada of subsets daarvan. De meest bekende europese implementatie 
pogingen zijn: 

+ De Karlsruhe implementatie, Een groep onder leiding van Prof. G. 
Goos op de universiteit van Karlsruhe heeft een volledige 
implementatie van Ada-80 gemaakt, Deze implementatie draait 
momenteel op grotere Siemens systemen, het is de bedoeling te 
bootstrappen naar o.a. 68000 gebaseerde systemen. 

De implementatiegroep is nu overgegaan van de universiteit van 
Karlsruhe naar het GMD^ research lab Karlsruhe. 

+ De York implementatie. Een Ada implementatie is ontwikkeld door 
de groep van Prof. I. Pyle aan de universiteit van York in 
Engeland, Deze implementatie draait op VAX systemen en zal, als 
alles volgens de plannen verloopt, dit jaar ter validatie worden 
aangeboden. 

Een zogenaamde matrix van implementaties wordt regelmatig gepubliceerd 
in Ada Letters, het bjlad van Ada-Tec. Een copie van zo'n matrix is als 
appendix opgenomen. 


H. GMD: Gesellschaft fur Mathematik und Datenverarbeitung 


- 7 - 


Untwikkelingen rond Ada 


4. Ada Programming Support Environments. 

4 . 1 Requirements voor een APSE. 

Een ontwikkeling die tenminsbe van even groot belang is als de 
ontwikkeling van de programmeertaal Ada, is de ontwikkeling van een 
progran development system voor Ada: de Ada Programming Support 
Environment, kortweg de APSE. 

Parallel aan de latere ontwikkelingen van de taal is gewerkt aan het 
opstellen van requirements voor zo'n Ada omgevlng. Het meest bekende 
document waarin requirements zijn besebreven is het zg "Stoneman" 
document [Stoneman], 

Karakteri3tiek voor de toepassingsgebieden van Ada zijn: 

+ grootschaligheid , veel ontwerpers, veel programmeurs en veel 
onderhoudspregrammeurs, 

+ lange levensduur, programmatuur met een levensduur van 20 jaar is 
geen uitzondering (F104 starfighter bijvoorbeeld) . 

Het uitgangspunt voor een Ada Programming Support Environment i3 de 
ondersteuning die zo'n omgeving moet kunnen bieden gedurende alle 
fasen in de lifeoycle van een project. Dit betekent dat een APSE over 
20 Jaar ondersteuning moet bieden aan een project waarin gebruikt 
gemaakt wordb van programmafcUvtf die nu ontwikkeld Wordt. 

Bij alle discussies over Adn m ^PSE's moet zowel de schaal van de 
software als de lifetime de te ontwikkelen programmatuur in 
beschouwing worden genomen, Vergelijk dat met de "wegwerp" filosofie 
die veelal bij UNIX^ wordt gehanteerd [UNIX]. 

De problemen die uit de grootschaligheid voortvloeien zijn te 
lijf te gaan met: 

+ project management, 

+ software management. 

Denk bij dit laatste aan ondersteuning op het gebied van version 
control en configuration management. 

De problemen die uit de langere lifetime van de programmatuur 
voortvloeien (regenereerbaarheid van oude(re) versies) zijn op te 
lossen door : 

+ software management, 

+ portabiliteit. 

Portabillteit is een sleutelwoord, denk aan een stuk programmatuur dat 
nu wordt ontwikkeld op systeem X voor systeem Y en waarin de klant na 


5. UNIX is een handelsmerk van Bell Labs 


- 6 - 

Ontwikkelingeu rond \da 

20 jaar lets gewijzlgd wil hebben. Dab betekent dot in het ergste 
geval de gehele ontwikkelomgeving portable moet zijn, tenzij de maker 
van de software bereid is gedurende de gehele lifetime van die 
software een sy3teem van merk X in hi' is te hebben. Ala vergelijking 
kunnen we denken aan de computersystemen van 20 jaar geleden. De 360 
serie was neb geannonoeerd , de IBM 7090 en de TR4 waren toen moderne 
systemen. 

Bij de disoussies over de APSE komt naar voren dat zo'n APSE 
ondersteuning moet bieden voor: 

+ portabiliteit, 

+ software management. 

Voor zover mogelijk moet een APSE ook tools kunnen ondersteunen voor 


+ project managements 


De architectuur van APSE’s kent, om de diverse aspecten van 
portabiliteit te ondersteunen, een tweetal nivo's, de KAPSE en de 
MAPSE, zoals uit het volgende schematisch overzicht blijkt. 



Ada is primair ontwikkeld voor de implementatie van embedded systems. 












- 9 - 


Ontwikkelingen rond Ada 


Het systeem waarop de programmatuur wordt ontwikkeld is niet 
noodzakelijk het systeem waarop de ontwikkelde programmatuur wordt 
gedraaid. (Host/target approach). We hebben dan te maken met een 
drietal portabiliteits problemen: 

+ portabiliteit van de ontwikkelomgeving, rehosting. 

+ portabiliteit van toolsets op een specif ieke ontwikkelomgeving, 

+ portabiliteit van de ontwikkelde programmatuur • voor andere 
targets, re-targeting. 

Het KAPSE nivo is het best vergelijkbaar met het nivo dat geboden 
wordt door de standard I/O library onder UNIX. De KAPSE biedt een 
interface naar functie3 die niet in Ada worden uitgedrukt en biedt het 
runtime support voor Ada programmatuur. 

Het KAPSE nivo staat centraal bij het porteren van de gehele 
omgeving, en het overdragen van losse tools. 

Net als in UNIX voor een programma dat alleen gebruik maakt van 
functies die door de standard I/O library geboden worden, is in Ada 
een programma dat alleen gebruik maakt van KAPSE functies in principe 
overdraagbaar . 

Het MAPSE nivo is het nivo van de programmeursportabiliteit. Het 
wordt gevormd door een Minimale Toolset waarmee de MAPSE zelf kan 
worden onderhouden. Door de open endness-heid van de omgeving is elke 
gebruikersgroep van zo'n MAPSE in staat een omgeving te creeeren die 
meer is gericht op de aard van het project en de werkwijze van de 
gebruikers. Als een standaard MAPSE als uitgangspunt genomen wordt kan 
zo'n ontwikkelde omgeving in zijn geheel getransporteerd worden naar 
een andere host die dezelfde MAPSE ondersteunt. 

De ondersteuning die op dit nivo geboden wordt voor project management 
en de eerste (ontwerp) fasen in de lifecycle van de programmatuur 
bestaat uit niet meer dan een text editor. 

4.2 De database. 

Buiten de ondersteuning die Ada zelf vraagt, bijvoorbeeld voor de 
ondersteuning van separate compilatie, biedt UNIX veel van wat voor 
een APSE nodig is. Een van de min of meer karakteristieke verschillen 
treedt op bij de database (UNIX: filesysteem) . 

Terwille van de ondersteuning van de grootschaligheid en de lange 
levensduur voor de ontwikkelde programmatuur wordt: 

configuration management, en 

+ history en version control, 

belangrijk. 

Anders dan bij het UNIX filesysteem zijn de objecten in de database op 
meerdere wijzen met elkaar verbonden, getypeerd en is het bestaan van 
meerdere versies van een object niet uitgesloten. 



Ontwikkelingen rond Ada 


-.10 


Met name "history control" legt zware eisen op aan de database, van 
elk object moet, volgens Stoneman, de hele history bewaard blijven. 

Dat wil zeggen dat te achterhalen moet zijn: 

+ welke versies van welke modules gebruikt zijn bij het genereren 
van programma Y voor target Z, 

welke editor was gebruikt bij het invoeren van deze modules en 
welke text- en commando regels waren gebruikt, 

+ welke compiler was gebruikt met welke command options, 

+ (transitieve afsluiting:) welke compilerversie was gebruikt om de 
compilerversle te genereren waarmee module A voor target Z 
gecompileerd is, 

Zo'n database wordt snel groot! 

Voor uitgebreidere informatle wordt de lezer verwezen naar 
[Stoneman], [Computer], 

Samenvattend : 

De APSE heeft veel van UNIX weg: 

+ open ended, 

+ een KAPSE laag als kernel extensie van Ada programmatuur , 

+ combinatie van tools door middel van piping alsmede redirection 
van input en output zijn mogelijk. 

Het wezenlijke verschil tussen een APSE en UNIX zit in de 
grootschaligheid : 

+ UNIX is, in het bijzonder wat betreft de functionele 
ondersteuning op kernel nivo, gericht op de lndividuele C 
programmeur, voor kortlcpende projecten. Er zijn ad hoc tools, in 
het bijzonder Make en SCCS die kunnen bijdragen in het software 
management, 

+ APSE's zijn, in het bijzonder wat betreft de functionele 
ondersteuning op kernel nivo, gericht op de groep van Ada 
programmeurs, bezig met langlopende projecten. (uitgebreide 
faciliteiten vcor history control en configuration management.) 

4.3 APSE's in ontwikkeling. 

Op een aantal plaatsen wordt aandacht besteed aan de feitelijke 
ontwikkeling van APSE's. De "grote" ontwikkelingen zijn die welke 
ondersteund worden door sponsors: 


+ ALS en de AIE in de V.S, 



- 11 


Ontwikkelingen rond Ada 


+ PAPS in Europa. 

Buiten deze zijn nog een aantal andere pogingen onderweg. We zullen 
ons hier echter beperken tot de genoemde drie. 

<1.3.1 De ALS. Het Ada Language Sy3tem, ALS in de wandeling, is een 
ontwikkeling van Softech (de indiener van het Blue language voorstel) 
in opdracht van de VS "Army”. Host is een VAX/VMS systeem, initieel 
zijn er diverse targets, w.o. de host zelf, 

Gmdat de ALS het eer3te werkende systeem is dreigt het een de- 
facto standaard binnen DoD te gaan worden. De "Army" heeft in elk 
geval zelf al de uitspraak gedaan dat voor ontwikkelingen ten behoeve 
van dit krijgsmachtonderdeel de nieuwe versie van de ALS, de ALS/N, 
gebruikt moet worden zodra die leverbaar is. Indien nodig kunnen de 
diverse program offices zelf de rehosting en/of retargeting van de 
ALS/N autoriseren. 

Ook de "Navy" lijkt voor de ALS/N overstag gegaan te zijn, de 
"Airforce" heeft nog geen beslissing genomen. 

Ten behoeve van rehosting van de huidige versie van de ALS is deze 
voor derden beschikbaar. Overigens is de huidige versie van de ALS nog 
niet volledig, ook is de Ada compiler nog niet klaar. Verwacht wordt 
dat de ALS/N in 85/86 beschikbaar komt. 

Een globale indruk van de ALS, op basis van de beschikbare documenten, 
toont dat het ontwerp sterk beinvloed i3 door UNIX. De belangrijkste 
tools zijn: 


1. 

Command Language Interpreter, 

2. 

DBMS, 


3. 

Configuration management 

tools, 

4. 

Ada Compiler met diverse 

back-ends 

5. 

assemblers, linkers en loaders, 

6. 

stub generatoren, 


7. 

pretty printers. 



Text editoren en formatters worden voorlopig van het hostsysteem, 
VAX/VMS, geleend . 

4.3.2 De AIE, De AIE, de Ada Integrated Environment, is een 
ontwikkeling van Intermetrics (Red language) in opdracht van de 
"Airforce". De AIE zou moeten werken op IBM 4341 en PE 8/32 
computersystemen van de "Airforce". Om aan te geven hoe de 
opdrachtgevers zelf over de belasting van zo'n systeem denken, zijn de 
volgende requirements indicatief: 



- 12 - 

Ontwikkelingen rond Ada 

■#• De Ada oompiler/linker mag voor heb compileren van een 
willekeurig Ada programma niet meer dan 512 kb main memory 
gebruiken, 

+ Het residente gedeelte van de KAPSE mag niet groter dan 256 Kb 
zijn, 

+ Elapsed time voor de compilatie en linkage van een enkel 1000 
regelig Ada programma mag niet groter zijn dan 4 minuten, 

CPU time voor deze activiteit mag niet groter zijn dan 1 minuut. 

Deze laatste twee eisen onder de volgende voorwaarden; Een IBM 4341 
met 4Mb, vier gebruikers ingelogged waarvan er een de Ada compiler 
gebruikt en de andere drie of de CLI of de editor. 

De huidige status van de AIE is tamelijk onduidelijk. 

4.3.3 De PAPS. De CEC financiert twee grote projecten in het Ada 
traject, de ene is de europese rootcompiler , de andere is de PAPS, de 
Portable Ada Programming Support Environment. 

De PAPS wordt ontworpen en gebouwd door een consortium bestaande uit 
Olivetti, Dansk Datamatik Center en Christian Rovsing. Het is de 
bedoeling om een MAPSE te ontwerpen en te implementeren op o.a, mini 
computers. De opzet was om de PAPS april 1984 klaar te hebben. Die 
datura is niet gehaald, volgen3 de laatste berichten wordt de 
oplevering nu september/oktober verwacht. 

4.4 De CAIS ontwikkelingen. 

Initieel zijn binnen de DoD organisaties een tweetal, grote, 
contracten gegund voor de ontwikkeling van een APSE (ALS, AIE). A1 
snel bleek dat de verschillende ontwerpen divergeerden en dat er dus 
van de zo fel begeerde portabiliteit tussen APSE's weinig terecht zou 
komen. In 1981 is daarom binnen DoD een team geformeerd, onder 
auspicien van de "Navy", om bepaalde portabiliteitsaspecten te 
onderzoeken. Dit team luistert naar de naam KIT, Kapse Interface Team. 
Het wordt bijgestaan door een ander, niet DoD, team, KITIA. Het 
achtervoegsel "IA" staat hier voor "Industry and Academia" . 

Het KIT met ondersteuning van KITIA moet het probleem van 
"transportability" en "interoperability" onderzoeken. De problemen 
die gepaard gaan met het gebruik van tools op ineerdere APSE's en, veel 
moeilijker, uitwisselbaarheid van database objecten worden door deze 
teams geinventariseerd en zoveel mogelijk opgelost. 

Elnd 1982, begin 1983, bracht dit team een informele definitie 
uit van de SIS, de "Standard Interface Set". In September 1983 kwam 
een eerste versie van de CAIS, de "Common APSE Interface Set" [CAIS] 
uit. Daarop zijn alweer een aantal wijzigingen. 

De CAIS is gedefinieerd in de vorm van een aantal packages. Elk 
Ada programma dat zich aan de door de CAIS geboden definitie 



- 13 - 


Ontwikkelingen rond Ada 

conformeert, en verder geen host of target afhankell jkheden bevat, 
most overgedragen kunnen worden tU3sen alle DoD APSE's. 


- V) - 

Ontwikkelingen rond Ada 
5. Ada in Nederland. 

Na het verschijnen van de preliminary versie van het Ada reference 
manual [SIGPLAN], werd in april 1980 een eendaags symposium over Ada 
gehouden, georganiseerd door de sectie SP van het NGI. De 
belang 3 telling was 20 overweldigend dat door de sectie voorzichtige 
pogingen in het werk zijn gesteld om een werkgroep over/voor Ada in te 
stellen. 

Na enige vertraging werd zo’n werkgroep inderdaad opgericht, op 2 
april 1982 hield de "Ada werkgroep Nederland 11 , werkgroep van de sectie 
SP van het NGI, de oprichtingsbijeenkomst. 

De doel3tellingen van de werkgroep waren, en zijn: 

+ het vormen van een forum voor discussies over alle aspecten van 
de taal en haar omgeving, 

+ het ontsluiten van documentatie over Ada. 

De tweede doel3telling is zeker bereikt. Door de werkgroep zijn 
contacten gelegd met informatie (data) producerende instanties zoals : 

+ de sectie SP van het NGI, 

♦ NNI/SC5, 

+ Ada Europe, 

+ DoD via mailing lists, 

+ KITIA. 

Bovendien zijn contacten gelegd met de "industrie 11 . 

De eerste doelstelling blijkt nog niet geheel opportuun te zijn, 
het aantal mensen dat daadwerkelijk met Ada bezig is is tamelijk 
beperkt in Nederland. 

Geinteresseerden kunnen zich wenden tot de auteur, voorzitter van 
de werkgroep, of tot de secretaris 6 van de werkgroep. 


6. J van Someren 
p/a ACE bv 
Nz Voorburgwal 31 
1012 RV Amsterdam. 



- 15 - 


Ontwlkkelingen rond Ada 


6. Ada in Delft. 

6.1 Inleldlng. 

Aan de TH te Delft wordt al geruime tijd aandacht besteed aan de 
ontwlkkelingen rond Ada. Dit heeft zich o.a. geuit in een Ada cursu3 
en inbedding van Ada in colleges over programmeertalen en software 
engineering. Bovendien wordt, meer in het kader van onderzoek dan 
onderwijs, aandacht geschonken aan implementatie a3pecten van Ada, 
instructieset architecturen, compiler structuren, en aan diverse 
aspecten van Ada Programming Support Environments. 

Ook bij het IBBC-TNO bestaat veel belangstelling voor Ada, bij 
TNO lopen twee projecten die aan Ada gerelateerde activiteiten met 
zich meebrengen. 

Momenteel wordt, gezamenlijk door TH Delft en IBBC-TNO, gewerkt aan: 

+ de ontwikkeling van een eenvoudige doch doelmatige programming 
support 'environment. 

+ een portable en retargetable compiler voor DAS, de Delft Ada? 
Subset. 

Een tamelijk grote handicap bij deze activiteiten is de omvang van het 
werk. Een "production quality" Ada compiler wordt geschat op een 
inspanning van enkele tientallen manjaren, manjaren die wij niet 
beschikbaar hebben. 

Het werk aan alle deelprojecten wordt momenteel uitgevoerd door een 
vijftal afstudeerstudenten, K. Dijkstra, E. van Konijnenburg, M. de 
Niet, R. van Liere en H. Toetenel, een onderzoeker bij IBBC-TNO, C, 
Barkey, een TNO 3taflid, R. Westermann, en twee medewerkers van de 
vakgroep Informatics, A. Hartveld en de auteur. 

Een belangrijke doelstelling bij deze activiteiten is het 
ontwikkelen van een bruikbare subset compiler, tesamen met een subset 
van de CAIS, een subset die voldoende functionaliteit biedt om een 
goede DAS omgeving te kunnen realiseren. 

6.2 De DAPSE. 

Een eenvoudige programming support environment, de Delft Ada Program 
Support Environment, DAPSE, is in ontwikkeling. Een pre-release die 
momenteel in gebruik is, is noodgedwongen ontstaan uit de noodzaak een 
program library te gebruiken voor de ondersteuning van separate 
compilation . 

De huidige versie van de DAPSE is een gesloten omgeving waarbij 
de gemanipuleerde objecten compilation units of text units zijn. 
Afhankelijk van indicatoren die bij de naam van zo'n object wordt 
meegegeven wordt de source versie, een of andere intermediaire versie, 


7. Ada laat overigens geen subsetting toe. 


- 16 - 

Ontwikkelingen rond Ada 

een object module of een executable bedoeld, 

De relaties die er bestaan tussen de verschillende compilatie units en 
de verschillende representaties van dezelfde compilatie unit worden 
bijgehouden in de DAPSE. 

Voorbeeld van een (stukje) DAPSE sessie 
Sdapse Jan 

DELFT PROGRAMMING SUPPORT ENVIRONMENT 


->edit x 

?x 

a 

with my_unit; use my_unit; 
with text_io; use te7t_io; 

package x is 

type kleur is (rood, wit, blauw); 

end; 

• 

w 

q 

->compile x 

In dit voorbeeld wordt een klein package gedefinieerd, met de naam x. 
Na invoering in de DAPSE is de compilatieunit bekend onder de naam x. 
De relaties tussen de unit '*x" en de units "myunit" en ’’text^o" 
Worden afgeleid en bewaard. 


- 17 - 


Ontwikkelingen rond Ada 


7. Implementatie van eon Ada subset. 

In het kader van de Ada georienteerde aotiviteiten wordt aandacht 
besteed aan de implementatle van een Ada subset compiler, Doel van de 
implementafcie poging is tweeledig, enerzijds lever t zo'n 
implementatiepoging veel kenni3 en inzicht op op het gebied van 
compiler technologie, anderszijd3 is het resultaat een bruikbare 
implementatie van een systeem implementatietaal . 

Het werk aan de implementatie is begonnen op een PDP-11, momenteel 
wordt dit werk afgerond op een Geminix8, een H68000 gebaseerd 
computersysteem. 

DAS, Delft Ada Subset is een subset van Ada die groot genoeg is 
om een compiler voor DAS en voor Ada in te schrijven. De relatie 
tussen PASCAL, Ada en DAS komt, globaal , naar voren uit het volgende 
schema : 


DAS 


Pascal subset ! Dynamic Arrays 
of Ada I . 

I No floating precisions 
No Fixed point 

Overloading user defined operators 


No tasking (yet) 
separate compilation 
Exceptions 

No representation specifications 
PACKAGES 
Private Types 
No Generics (yet??) 


Schematisch overzicht PASCAL, DAS en Ada 

De voorvoegsels "No" in dit schema zijn van toepassing op DAS, zonder 
deze voorvoegsels wordt naar Ada gerefereerd. 

Het zal evident zijn dat Ada een complexere taal is dan bijvoorbeeld 
PASCAL. Ook DAS is nog een orde complexer dan PASCAL. 

Deze grotere complexiteit uit zich in: 

1. Complexere analyse fases in de compiler, 

2. Complexere runtime organisatie. 

Bij dat laatste moeten we voorzichtlg zijn, runtime efficiency is 
belangrijk voor een bruikbare systeemimplementatietaal . 


8. Geminix is een handelsmerk van IBBC-TNO. 


- 18 - 

Ontwikkellngen rond Ada 

7.1 Compiletime aspecten. 

In deze septie geven we een kort overzicht over de verschillende fases 
van de DAS compiler. 

Elementen die aan de orde komen zijnj 

+ parsing, 

+ static semantics, 

high level intermedialre representatie, 

+ low level intermediaire representatie. 

De modeliering van het runtime systeem wordt niet behandeld. Een 
detail, de modeliering van data en datadescriptoren wordt later 
behandeld. 

7.1.1 Parsing. Een logisch gevolg van een grote taal is een groot 
aantal regels bij de context vrije syntax (tenmin3te als we naar een 
redelijk nauwkeurlge benadering van de taal streven). Alleen al uit 
het feit dat er met enige regelmaat beschrijvingen van een context 
vrije grammatics, liefst een LALR(I) grammatics, gepubliceerd worden, 
mogen we afleiden dat het formuleren van zo’n syntactische 
beschrijving niet geheel triviaal is. 

Bij de DAS compiler worden ca 310 productieregels gebruikt om een 
ambigue LALR ( 1 )' ^ beschrijving te geven die door YACC [YACC] in een 
parser wordt omgezet. Bij de syntactische speclficatie wordt gebruik 
gemaakt van een eenvoudige preprocessor om de relaties tussen de 
attributen van de diverse grammarsymbolen te specificeren [YACCPREP]. 

Het gebruik van een door YACC gegenereerde parser in een compiler 
heeft een probleem, het vermogen om te recoveren van syntactische 
fouten is, zacht gezegd, nogal mager. 

Een betrekkelijk grote hoeveelheid werk is er ingaan zitten om de 
syntactische error repair 10 van de compiler op een redelijk nivo te 
brengen. 

7.1.2 Static semantics. De analyse van de static semantics Cook wel 
context condities genaamd) valt globaal uiteen in drie, niet 
disjunkte, delen: 

1, implementatie van scope en visibility regels, 


9. Ik ben mij ervan bewust dat dit een contradictie is, ambigue 
grammatical zijn niet LR. Gebruik wordt echter gemaakt van het 
"vermogen" van YACC om ambiguiteiten "op te lossen". 

10. We streven repair na i.p.v. recovery zodat binnen de routines die 
door de parse worden aangestuurd (bijna) geen rekening behoeft te 
worden gehouden met syntactische gebruikersfouten. 


Ontwikkelingen rond Ada 


- 19 - 


2, type checking, 

3. evaluatie van statische expreaaies. 

We zullen ons beperken tot een enkele voorbeeld constructie om te 
tonen dat dit soort problemen beataat, 

package kleuren ia 

type tl ia (rood, wit, blauw) ; 

type t2 ia (rood, wit, blauw); 
type t3 ia (rood, wit, blauw); 
type t4 ia (rood, wit, blauw); 
type t5 ia (rood, wit, blauw); 
type t6 i3 (rood, wit, blauw); 


function 

lf + ll 

(a, b 

• 

• 

tl) 

return 

tl; 

function 

n+it 

(a, 

b 

• 

• 

t2) 

return 

t2; 

function 

11 + 11 

(a, 

b 

• 

• 

t3) 

return 

t3; 

function 

ii+tr 

(a, b 

» 

• 

t4) 

return 

t4; 

function 

u+» 

(a, b 

• 

m 

t5) 

return 

t5; 

function 

11+11 

(a, b 

• 

• 

t6) 

return 

t6; 

function 


(a, b 

• 

• 

t4) 

return 

t4; 

function 

ii_ii 

(a, b 

• 

• 

t5) 

return 

t5; 


procedure P (a; tl); 
procedure P (a: t2); 
procedure P (a: t3); 
procedure P (a: t4); 

end; 

U3e kleuren; 

P (((rood + rood) - (rood + rood)) + (rood + rood)); 

Welke P en welke "rood"’ a worden in deze procedure call gebruikt. 

7.1.3 High level intermediate repre^&itation. Na de analyse fase van 
de compiler is het programma getranaformeerd in een high level tree. 

De tree struetuur lijkt nogal veel op de grote broer DIANA [DIANA]. 
Alvorens deze 3tructuur verder te vertalen wordt zij eerst 
geattribueerd . Informatie over de adressering van runtime objecten 
wordt aan alle knopen, waar relevant, toegevoegd. 

We zullen ons hier beperken tot een voorbeeld. 



- 20 - 

Ontwikkelingen rond Ada 


ectypo 
flags => 
tag => R 



record type definitie 
naam R 

enclunit => ( 

23, 

1) 

encoding van een pointer 

REC alloc => 1 

REC flags => — V-2 
REC" offset => 28 


descriptor globaal 

REC_nform => 

2 


twee discriminanten 

REC vdsize => 

28 


value descriptor grootte 28 bytes 

REC nflds => 

9 


aantal velden 9 

RECjiinits => 

0 


aantal initialisaties 0 

REC~npath3 => 
REC maxpfld => 
REC vsize => 

4 

6 

0 


aantal layouts 4 


Enkele record knoop 


Deze recordknoop is de beginknoop van het recordtype R op biz. 31. 

Merk trouwen3 op dat zo’n ASCII codering van een lntermediaire 
representatie nogal snel in omvang toeneemb. 

7.1.4 Low level tree representable, Ala low level tree representatie 
is gekozen voor de intermediaire code van de Portable C compiler 
[PCC], De linearisering van de code is gebeurd, goede doelcode voor 
expressies moet nog worden gegenereerd. Voor dat doel zijn er diverse 
backends beschikbaar, o.a. voor de PDP-11, 68000, VAX, en EH. 

Wat betreft ons werk zijn we dus na deze linearisering klaar, de 
low level bomen vormen de. target code van de DAS compiler. 

7.1.5 EH. EM code i3 ontwikkeld aan de VU door de groep van Prof. 
Tanenbaum [EM], Als experiment wordt de DAS compiler zo 
geparametrizeerd dat deze in staat is, alweer via een backend van de 
Portable C compiler, om EH code te genereren. Deze EH code kan dan 
doorvertaald worden naar bijvoorbeeld 68000 code waar ook direct code 
voor kan worden gegenereerd. Dit experiment moet leiden tot inzichten 
in het gebruik van zowel EH als van de intermediaire code van de 
Portable C compiler als tussentaal. 

7.1.6 Status van de compiler. De DAS compiler is initieel opgezet 
als een vijf pass compiler op een PDP-11, De functies van de passes 
waren resp. contextvrije parse, naam analyse, type checking, storage 
allocatie en code linearisatie, De compiler is, al geruime tijd, in 
staat om een subset van onze Ada subset, te vertalen. Eerst naar PDP- 
11 code, later naar 68000 code. De software, die initieel is 
ontwikkeld op een PDP-11 i3 overgehaald naar een 68000 gebaseerde 
machine en wordt aangepast aan de beschikbaarheid van een grotere 
adresruimte. Dit komt in feite neer op het reduceren van het aantal 
passes. 

Het aantal eodegeneratie passesll is tot een gereduceerd, de laatste 
hand word gelegd aan een front end in een enkele pass. 


11. "pass" is hier een totale doorgang over de brontekst, lokaal 
worden veel meer scans uitgevoerd, bijvoorbeeld bij de 


- 21 - 

Ontwikkelingen rond Ada 

Do cerate release van de DAS compiler met een DAPSE komt dezo zomer 
beschikbaor. Momenteel Worden de diverse delen van do compiler 
debugged. 

7 .2 Runtime aspecten. 

Ook voor een Ada subset is een zekere mate van runtime efficiency 
gewenst. Runtime efficiency en compiletime complexiteit gaan meestal 
hand in hand, ue zoeken naar eon redelijke balancering. 

Een belangrijk uitgang3punt daarbij i3 het definieren van een 
eenvoudig en compleet runtime model dat een efficiente implementatic 
niet uitsluit. 

Het runtime model voor DAS valt uiteen in een drietal elementen: 

+ target instruotle set, 

+ globale geheugen en stack organisatie, 

♦ het data descriptie model. 

Over de eerste twee aspecten zullen we kort zijn. Als instructie set 
wordt, zoal3 eerder aangegeven, de intermediaire code van de portable 
C compiler gebruikt. 

De globale geheugenorganisatie is zoals te verwachten op een 
hedendaagse micro of minicomputer, een stack groeit de ene kant op, 
een heap de andere kant. De stack elementen zijn activeringsrecords. 
Daar niet alle dataobjecten statisch van lengte zijn is de organisatie 
van een aetiveringsrecord wat ingewikkelder dan in bijvoorbeeld 
PASCAL. 

Bij de structurering van zo’n aetiveringsrecord is gestreefd naar een 
zo groot mogelijke overeenkomst met de activeringsrecords in C. Het is 
mogelijk om vanuit een DAS procedure een C functie aan te roepen 
zonder extra overhead. 

Alhoewel de structurering van zo'n aetiveringsrecord aardige 
elementen bevat zullen we daar niet op ingaan. In plaats daarvan zal 
ingegaan Worden op het model dat gekozen i3 voor de descriptie van 
data. 


typechecking. 



- 22 - 

Ontwikkelingen rond Ada 
9. DAS data descriptie model. 

In Ada en DAS hebben de data objecten rneer vrijheidsgraden dan In 
bijvoorbeeld PASCAL. Bij arrays betekent dit dat de grenzen niet 
(noodzakeli jk) meer in compiletime bekend zijn, bij records betekent 
dit dat de record elementen niet noodzakelijk een compiletime bekende 
grootte hebben. Dit tesamen met de wens om veilige variant records te 
hebben heeft geleid tot de ontwikkeling van een eenvoudig en doelmatig 
datadescriptie model. 

Het model is beschreven in [DASDESC] en [DOUBLET]. Het is 
geimplem ‘nteerd op een VAX als deel van een interpretator voor DAS 
[DASINTEK], en als deel van de compiler op een PDP-11 en de 68000 
[BACKEND]. 

Alvorens in te gaan op het model voor de oplossing, eerst een 
paar uitgangspunten. 

+ Bij de ontwikkeling van het model werd uitgegaan van een PDP-11 
met, in hedendaagse termen, een beperkte adresruimte. Opslag van 
gegevens voor de datadescriptie moest derhalve behoorlijk 
efficient zijn. 

+ Platte data opslag, Het leek een redelijk uitgangspunt om alle 
datastructuren, hoe complex ook gedefinieerd, plat, 
gelineariseerd, op te slaan, Zeker voor assignments van multiple 
values heeft dit voordelen. Merk overigens op dat deze voordelen 
niet altijd aanwezig hoeven te zijn bij vergelijking van. multiple 
values als gevolg van de alignment van componenten. 

+ Automatisohe initialisatie en constraint checking moest mogelijk 
zijn. Om de hoeveelheid code te reduceren werd besloten om 
bepaalde "onder water handelingen" , zoals bij automatisohe 
initialisatie van record componenten, over te laten aan een, 
lokaal zeer intelligent, runtime support systeem. 

8 . 1 0ploa3ingsmodel . 

Uitgangspunt bij het model is dat voor elke elaboratie van een 
typedefinitie of een constraint er een descriptor is in runtime die de 
typedef initie of constraint implementeert. 

Als een type definltie of een constraint verwijst naar een ander type 
of constraint, dan komt dat in de corresponderende descriptor tot 
uitdrukking door een pointer van de ene descriptor naar de andere. 



- 23 - 


Ontwikkelingen rond Ada 


type E is . . . ; 



type AE is array (I range <>) of E; 

De bijbehorende descriptor heet type descriptor. Als, zoals hier een 
typedefinitie parameters bevat is zij niet zonder meer bruikbaar voor 
de beschrijving van variabelen en values van het type. 


SAE: 



subtype SAE i3 AE (constraint); 

De descriptor voortkomend uit een expliciete of impliciete subtype 
definitie wordt value descriptor genoemd. 

Verder is er in het model voor elke variabele, hetzij implieiet, 
hetzij expliciet, een doublet die de variabele implementeert. Dus: 

VSAE: SAE; 

wordt gerepresenteerd in het model als: 



Ontwikkelingen rond Ada 


- 24 - 


VSAE: 


VSAE : 


Bij een operatie als indexing op de variabele VSAE wordt een doublet 
gecreeerd, waarna de structuur wordt: 



- 25 - 


Ontwikkelingen rond Ada 


In het bovenstaande voorbeeld gingen we er, gemakshalve, vanuit dat we 
steeds als we een descriptor nodig hadden deze reeds bestond, zoals in 
PASCAL. Een extra complicatie wordt gevormd door de parametrizatie die 
o.a. bij records kan optrden. In het geval van een definitie 

type R (D; I) i3 
record 

RC 1 : AE (M .. D); 

RC2 : E; 
end record; 

kunnen we in de descriptor die de definitie van R implementeert niet 
verwijzen naar de descriptor van de component RC1, de descriptor van 
de laatste bestaat eenvoudig nog niet. 

De oplossing voor dit probleem is gegeven in [CALLBLOCK], we kunnen 
voor RC 1 geen descriptor maken maar wel een indicatie hoe we te zijner 
tijd een descriptor moeten maken. We maken een structuur, een call 
block, waarin we alle relevante informatie over de te creeeren 
descriptor zetten. 

Een descriptor voor typedefinitie R wordt: 



Als we een constraint op R leggen, zoals in: 
subtype SR is R (expressie); 

wordt de waarde van de parameter D bekend en kunnen we een descriptor 
maken voor de component RC1. Herk op dat elke keer als zo'n constraint 
op R gelegd wordt, een nieuwe descriptor voor RC1 gemaakt moet worden. 
We moeten ons de descriptor van RC1 dan ook voorstellen lokaal ten 
opzichte van de descriptor voor SR. 



Ontwikkelingen rcmd Ada 


- 26 - 



Schematische voorstelling descriptor SR 

8.2 Impienentatie implicaties van het model. 

In het model wordt voor elke variabele, hetzij expliciet hetzij 
impliciet, een doublet gemaakt. In de, half afgekomen, boom 
interpretator voor DAS [DASINTER], werd dit model letterlijk 
geimplementeerd. Elk tussenresultaat van een operatie werd ook 
werkelijk als een doublet geimplementeerd. 

Een van de aardige aspecten van het model is dat de implementatie 
partieel door de code generator en partieel door het runtime support 
systeem plaats vindt. De codegenerator kan zljn kennis benutten om een 
gedeelte van de informatie die het model verschaft, in compile time te 
verwerken zodat de informatie in runtime niet meer nodig is. 

Een van de meest voor de hand liggende voorbeelden is een 
"gewone" variabele. De compiler weet: 

+ waar de waarde van de variabele te vinden is, althans de 
adresfunctie is bekend, 

+ waar de descriptor van de variabele, of de waarde van de 
variabele, te vinden is, ook daarvan is tenminste een 
adresfunctie bekend . 

Voor alle optredens van de variabele die door de compiler worden 
vertaald, is de compiler in staat het bestaan van het doublet te 
simuleren. In plaats van het doublet te genereren kunnen steeds de 
accessfuncties voor de waarde of voor de descriptor worden 
gegenereerd. 

Voor "gewone" variabelen wordt nooit een runtime-doublet gemaakt. 

Als voorbeeld nemen we een indexing operatie, eerst eenvoudig 
daarna in een geeompliceerdere context. 

A (expr) 

waarbij A een gewone variabele is gedefinieerd als: 



- 27 - 


Ontwikkelingen rond Ada 


type my_array is array (integer range <>) of integer; 

A : my_array (1 .. 10); 

In dit voorbeeld zijn de adressen van zowel de array data als de 
descriptor bekend, indexering is nu eenvoudig: 



intermediaire 

code 

voor A( 1 ) := 

1 

58 

4 



assign 


13 

0 

4 


deref 


6 

24 



sub 


8 

24 



add 


94 

0 

14 

24 

reg 0 


4 

64 

0 

4 

64 


11 

4 



mult 


4 

4 

0 

24 

4 

elementsize 

8 

24 



sub 


4 

1 

0 

4 

1 


13 

0 

4 


deref 


6 

24 



plus 


4 

0 

0 

24 

Mce3 

descriptor adres 

4 

16 

0 

4 

16 


4 

1 

0 

4 

1 



De elemenfcgrootte is in compiletime bekend en dus inline gecodeerd . 
Als deze grootte niet in compiletime bekend is dan is ze uit de 
runtime descriptor te halen, 

Als complexes'- voorbeeld nemen we een oombinatie van een functie 
aanroep en een indexing operatie. 

function moeilijk (a : integer) return My_type ; 

Eenvoudshalve nemen we even aan dat het type van de resultaat value 
van de functie '’moeilijk’' een of ander array type of subtype is. 

moeilijk (3)(index_expressie) 

De evaluatie in het model ’is als volgt: 

1. evalueer de functie "moeilijk", deze functie keert terug met een 
doublet. 

2. doe de indexing. D.w.z. maak een nieuw doublet met daarin een 
verwijzing naar de berekende plaats van de waarde en de 
bijbehorende descriptor. 

3. neem de inhoud van de berekende locatie. 

Bij de implementatie van het model moeten we twee gevallen 
onderscheiden : 


- 28 - 

Ontwikkelingen rond Ada 

+ het return type van de functie (, moeilijk ,t verachaft informatie 
over de grenzen, d.w.z het la een subtype, 

+ het return type van de functie is een unconatrained array type. 

In het eerste geval kunnen we het model verder door de compiler laten 
implementeren dan in het tweede geval. Van elk der gevallen zullen we 
een globale uitwerking geven, 

Ala de functie "moeilijk" een arraysubtype als resultaattype 
heeft, dan is weliswaar in compiletime het adres van de array data 
niet bekend maar wel het adres van de descriptor. 12 In executietijd 
komt de functie terug met een pointer naar de waarde. 

De compiler kan hier nog een aanzienlijk deel van het doublet 
simuleren. 

Het meest ingewikkelde geval treedt op als de return value 
unconstrained is, bijvoorbeeld: 

function moeilijk (a : integer) return AE; 

In compiletime is nu noch het adres van de descriptor van het 
resultaat, noch het adres van de resultaat value zelf bekend. D.w.z. 
dat de compiler nog maar welnig van het doublet kan simuleren. 

Wel kunnen we aangeven waar de losse elementen van de doubletten zich 
bevinden. Ook de structuur van de descriptor is bekend, d.w.z. de 
indexeringsoperatie kan worden uitgedrukt in termen van een indirecte 
referentie naar de value en een indirecte referentie naar de 
descriptor van de value, 

De descriptor voor het resultaat van de indexering is altijd weer 
in compiletime bekend. D.w.z. dat het doublet voor het resultaat, 
tenminste voor de bewerkingen die op de descriptor plaats vinden, weer 
in compile time kan worden gesimuleerd. Voor de descriptor van het 
resultaat van de indexering hoeven we de descriptor van de arrayvalue 
niet te raadplegen. 

8.3 Records, adresseren van cotnponenten en variant selectie. 

In Ada zijn, zoals bekend, records minder statisch van structuur dan 
in bijvoorbeeld PASCAL. Dit heeft zijn weerslag in de complexiteit van 
het access van record componenten. 

Selectie van een component is niet altijd triviaal. Ook voor de wat 
ingewikkelder gestructureerde record objects willen we graag het 
eerder gegeven model hanteren, d.w.z.: 

+ complete scheidlng tussen data en data descriptie, 


12. Merk op dat alle vormen van constraint checking van de return 
value van de function bij de executie van de return statement, 
binnen de body, worden verricht. 


- 29 - 


Ontwikkelingen rond Ada 


+ geatrekte values. 

De complication t.o.v. PASCAL records zijn o.a,: 

+ de record componenten zijn minder statisch van grootte, 

+ we willen checken dat een component binnen de geldende variant is 
geselecteerd. 

In die gevallen dat de offsets van de data van de record componenten 
niet statisch te bepalen zijn, voeren we een noodgedwongen indirectie 
in. Hetzij de typedescriptor , hetzij de valuedescriptor , wordt 
voorzien van een zg. off settable, een tabel die voor elke component in 
het record vertelt wat de offset van de data van de component binnen 
de data van een object van dat type of subtype is. 

We zullen de complete descriptor structuur geven voor een object 
van een niet triviaal record type. 

type my_array is array (integer range <>> of integer; 

type R2 (x : integer) is record 

A : my_array (el . . x) ; — el, e2, e3 willekeurig 

B ; my_array (e2 . . x) ; 

C ; my_array (e3 .. x) ; 
end record; 

02 ; X2 (constraint); 

Merk op dat de structuur en de grootte van deze descriptoren bekend 
is, Ook bekend is de relatieve positie van de locale descriptoren voor 
A, B en C binnen de descriptor van het subtype van 02. 

Ook hier geldt dat, gegovcn het adres van een descriptor de 
adressen van de component descriptoren hetzij compiletime bepaald, 
hetzij in runtime berekend kunnen Worden. 

We nemen als voorbeeld weer een functie, met als returnbype R2. 
function moeilijker (x : integer) return R2; 
en beschouwen een "name construct" 

...moeilijker (3). B (exp) 

De volgende opmerkingen kunnen daarbij worden gemaakt: 

1 . het adres van de storage waarin B moet worden geselecteerd is het 
resultaat van de functie aanroep, 

2. via een pseudo out parameter is de descriptor van dit resultaat 
adresseerbaar , 



Ontwikkelingen rond Ada 


- 30 - 


my array : 


R2 


array | < 

I 

> Integer 

t 

I 

— — > integer 

I 

record I 


X > integer 

1 

A > callblock - 

1 

B > callblock - 

1 

C — — -> callblock - 


type descriptor structuur voor R2 

3. het adres van de data van B vinden we door de inhoud van een 

element, met een compiletime bekende offset, uit de offset table 
bij het adres van de data op te tellen, 

*J. de descriptor van B vinden we op een, compile time, bekende 
offset binnen de descriptor van het functie resultaat, 

5. het adres van het arrayelement vinden we op de gebruikelijke 
wijzo binnen de data op het adres van B, 

6. De descriptor van het arrayelement is "integer", die vinden we op 
een complletime bekende plaats. 

Het is het vermelden waard dat de selectie: 

. . .moeilijker (3). x 

anders loopt. Voor de selectie van een discriminant hebben we de 
descriptor van de value, in plaats van de value zelf, nodig. 

De beschrijving van het data descriptiemodel wordt gecompleteerd 
met een beschrijving van een eenvoudig mechanisme ter ondersteuning 
van de zg. variant selectie, de verificatie dat een gekozen component 
ligt binnen een aanwezige variant. 

We zullen de methode aangeven aan de hand van een voorbeeld. 



31 


Ontwikkelingen rond Ada 


VD REC 


> to descriptor R2 


value size 
discriminant's value 


offset A 
offset B 
offset C 

VD_ARR 


* • • * 
• « • • 

A ' 3 descriptor 

LD_ARR 


« » < « 
• • • • 

B's descriptor 

LD_ARR 


♦ • » • 
t ( < « 

C’s descriptor 

descriptor voor 
R2 (constraint) 


type R (dl, d2 : integer) is 
record 

fl, f2 : integer; 
ca3e dl Is 

when -100 . . -1 => 
f3* f4 : integer; 
when 0 => 

f5 : integer; 
case d2 is 

when -1000 .. -1 => 
f6 ; integer; 



when others => 

f9, f8, f9 : character; 
end case; 
when others => 
null; 
end case; 
end record; 



- 32 - 

Ontwikkelingen rond Ada 

We kunnen de paden door dit recordtype nummeren en krijgen dan een 
relatie tus3en paden* of layouts, en oomponenten: 

+ layout nummer 1 : 

D1, D2 , FI, F2, F3, FH 


+ layout nummer 2: 

D1, D2, FI, F2, F5, F6 


+ layout nummer 3! 

D1, D2, FI, F2, F5, F7, F8, F9 


+ layout nummer Hi 
D1, D2, FI, F2 

Voor elk van de oomponenten kunnen we een range aangeven waarblnnen 
bet getal dat de layout aangeeft moet vallen om geselecteerd te mogen 
worden. 

+ F2 mag worden geselecteerd voor de layouts 1.. 4 

+ F5 mag geselecteerd worden voor layouts 2 .. 3 

+ F6 mag geselecteerd worden voor layouts 2 .. 2 

We moeten ons daarbij reallseren dat voor elk subtype van dit record 

de layout vast ligt als de discriminantwaardes bekend zijn, De layout 
hoeven we dus maar eenmallg te berekenen en in de 'descriptor te 
stoppen. Staat de codering van de layout in de descriptor, dan kan 
bet access zoals door de DAS compiler wordt gegenereerd naar 
bijvoorbeeld component F5 worden geformu.leerd als: 

base + (not layout in 2 .. 3 ? 

raise exception : offset_van F5 

Om de layout te bepalen van een recordaubtype, wordt een zg padfunctie 
gegenereerd, gebaseerd op de structuur van het record. Voor 
bovenstaand record type is de gegenereerde padfunctie: 

L5: 


tstb 

spg(- F7-61J) 

link 

a6 F7 

moveml 

//_S7,a6@(-_F7) 

movl 

a6§(8) ,a0 

moveq 

#-100, dO 

cmpl 

a0@,d0 

Jgt 

L10000 

cmpl 

//-I .aoe 


33 


Ontwikkelingen rond Ada 



Jet 

LIOOOO 


moveq 

in ,d 0 


jra 

LIOOOI 

Lioooo: 


movl 

a6(3(8) ,aO 


tstl 

aoe 


jne 

L10002 


movl 

<1-1 000 ,d0 


cmpl 

aOfi(4) ,dO 


Jgt 

L10003 


cmpl 

#-1,a0e<4> 


jgt 

L10003 


moveq 

02, dO 


jra 

LI 0004 

L 10003 : 


moveq 

#3, dO 

L10004; 


jra 

L10005 

LI 0002: 


moveq 

#4, dO 

L10005: 
Lioooi : 


moveml 


a6@(- F7) ,#1028 



- 34 - 

Ontwikkelingen rond Ada 
9. Conciliates en vorder work. 

0ndank3 dat Ada niet dagolijk3 in de ochtendkranten wordt vermeld 
lijkt de opmars van de taal niet te stuiten, Difc kan o.a, 
geconstabeerd worden uib heb regelmatig versohijnen van nieuwc 
leerboeken over de taal. 

Zeer belangrijk is heb gegeven dab nu reeda vele tienballen tniljoenen 
guldens geinve 3 beerd zijn in de onbwikkelingen rond Ada en dat ook 
buiten DoD, in het bijzonder in de VS en Europa, de taal geaceepteerd 
wordt. 

We kunnen niet verwachten dat een programme or taal van de ene op de 
andere dag lngeburgerd is bij een groot publiek. Ook voor een, 
momenteel, populaire taal ala PASCAL heeft het 5 a 10 jaar geduurd 
voor de taal werkelijk populair werd. 

Het is overigens niet erg waarsohijnlijk dat Ada de populariteit zal 
halen die PASCAL momenteel heeft, Ada is een orde complexer en wordt 
vooralsnog gezien als taal voor grote projecten. 

Programming Support Environments, programmeer omgevingen waarbij 
een zekere mate van integratie wordt gerealiseerd tussen de tools 
onderling en de tools en de te manipuleren objecten, staan de laat3te 
Jaren volop in de belangstelling, De eer3te Ada Programming Support 
Environments zijn in aantocht, de eerste resultaten tonen dat er 
relatief veel computer "power" voor nodir is. Gezien de snelle 
ontwikkelingen van de microelectronics lijkt dit echter geen beletsel, 
momenteel heeft een pooket computer het vermogen van een mainframe van 
20 jaar geleden. 

Binnen DoD heeft men een beeld van de software engineer van de 
toekomst [SI], Zo iemand is uitgerust met een eigen portable computer 
3ysteem (een Super Apse Workstation), liefst gebaseerd op het dynabook 
concept, met megabit verbindingen naar centrale apparatuur die de 
grootschaliger databases bevat. 

Wat betreft ons eigen werk, een initiele versie van de DAS 
implementatie nadert zijn voltooing. Het nodige werk zal nog besteed 
moeten worden aan diverse vormen van optimalisatie. In het bijzonder 
high-level optimalisaties zijn nodig txn de resulterende code efficient 
te krijgen. 

Overwogen wordt om, als exercltie af te stappen van het gebruik van 
het back end van de PCC en een eigen codegenerator te ontwikkelen. Ook 
bestaan plannen om DAS uit te breiden met tasking en generics. 

Een tweede versie van de DAPSE staat op het punt te verschijnen. In 
deze versie wordt een eenvoudige vorm van een database management 
systeem geboden aan de gebruiker, o.a. ten behoeve van de domain 
manager, de beheerder van de program libraries. 


35 - 


Ontwikkelingen rond Ada 


10. Bibliografie. 

[1] [Wichmann] 

Ada is green 
B.A. Wichmann, 

Computer Bulletin sept 1979 

[2] [AJPOnews] 

Newsletter Ada Information Clearinghouse, 

Volume I, Number 4 
July 1984 

E33 [LRM] 

Reference manual for the Ada programming language, 
ANSI/MIL-STD 1815-A, 

Januari 1983 

[4] [Stoneman] 

Requirements for Ada Programming Support Environments, 

U.S, Department of Defense, 

1980 

[5] [UNIX] 

Foreword in: Bell System Technical Journal, 

Juli-augustus 1978 

[6] [Computer] 

diverse artikelen in: Computer magazine, 
juni 1981 , 

[7] [CAIS] 

Draft specification of the Common APSE Interface Set (CAIS), 
Version 1,0 
26 Augustus 1983 t 
llitgegeven door DoD 

[8] [SIGPLAN] 

Preliminary Ada Reference Manual, 

Sigplan Notices Juni 1979. 

[93 [YACC] 

YACC- yet another compiler compiler, 

S.C. Johnson 

CSTR 32, Bell laboratories Murray Hi,' 1 1 
1974 

included in UNIX documentation 

[10] [YACCPREP] 

A preprocessor for YACC or 

a poor man's approach to parsing attributed grammars, 

J van Katwijk, 

SIGPLAN Notices, October 1983 



Ontwikkelingen rond Ada 


- 36 


C113 [DIANA] 

DIANA reference manual, 

revision 3 

A. Evans, K. Butler 

Tartan Laboratories Incorporated 

1983. 

[12] [PCC], 

A tour through the Portable C compiler, 

UNIX documentatie versie 7 

[13] [EM] 

Description of a machine architecture for use with block 
structured languages, 

A.S. Tanenbaum, H van Staveren, E.G. Keizer, J.W. Stevenson 
Rapport IR-81 

Subfaculteit Wiskunde en Informatics 
Vrije Universiteit Amsterdam 

[1'*] [DASDESC] 

Descriptors for DAS, 

J van Katwijk en J van Someren 

Rapport 82-20 Onderafdeling der Wiskunde en Informatics 
Technische Hogeschool Delft, 

1982. 

[15] [DOUBLET] 

The doublet model, 

J van Katwijk and J van Someren, 

SIGPLAN Notices januari 1984 

[16] [DASINTER] 

An viterpreter for DAS, 

N.C. Bogstad, A.M.J. Hartveld 

Laboratorium voor schakeltechnlek en techniek van de 
informatieverwerkende machines 
rapport 051560-28(1983)16, 

Afdeling der Elektrotechniek, 

Technische h’ogeschool Delft, 

1983 

[17] [CALLBLOCK] 

A runtime representation for Ada variables and types, 

A. Hisgen, D.A. Lamb, J Rosenberg and M. Sherman 
SIGPLAN Notices 15, November 1980 

[18] [SI] 

Strategy for a DoD Software Initiative, 

U.S. Department of Defense. 

1 October 1982 

[19] [BACKEND] 

Using PCC's backend for generating code in the DAS compiler, 


- 37 - 


Onfcwikkelingen rond Ada 


doctor aalscriptie, 

C. Barkey, 

Onderafdeling Wiskunde en Informatica, 
Technische Hogeschool Delft, 
december 1982 . 




miirix of m lwcwce impioiewtawsis 
(U pdilidKoonbrr ISS3) 
EUKCPCM «I0 JAPfflESE EFFORTS 


0RGAH12ATIQI 

Conan 

Ct3(T' : n 

r 

SCOPE 

HOST SYSIDt 

TARGET SYSTEM 

MAlUOILtrf 

SESA-Oiulichlmd On ID 

Nr. Of tf it 

firm HoO Spied Icillcn tnd 

SiMini 7,7ii 

Slmrni 331, 

Cmplftld 


Frmllurt, U,6im. 

fpirt of 

rulliition ol Adi I/O 

(Adi) 

porlibti to othiri 

0l(, ISSI 


(IS) i 11-71 72 It 

SPERGEJ) 





SPEREER PreJicti 

KoSr f, Flckmtchir Gtriti H:0 Slindirdlud progrn 

Slmint 7iu 

Srvtrol | including 

St* tndlulduil 

thli. Kirliruhi) 

(211) 1II*<3S3 


diurlejnmt irltm for 

(Adi) 

Slmrni ?m * Ju 

pro/idt 

IFF, SESA, tittti 

IASS CTrth. Coord) 
Dr. K. Hutu 1 , 

(IS) SS 2M0-3ISI 


nilltirlr ipplicillons 













SritiMkC 

Crorg tflntirilitn 


i.) Adi'OI Front End 

MAX 

WX 

1,3 Km 

(IS) 7733 37637 


In itufdird Piuil 
b.) ffiSI Adi cenpllir 


IBi-376 

b.) Kid 1303 


mm »p»«m ■ iiihim 



..............*.l..4**.4... 




Unti. «( Kniurg 

fro/. Or. H. Ntgil 

Orutiehi 

tn.fitigili luftibtlflr 

OEM! 

Girnin 


(IS) 111*1123*1151 

firithonoi of Adi for inigi prcnt- 

fPucil flril. 

nlnfemjutiri 

** 



■gmiin 

ling irilml, APSE Inpll- 

Adi-0 lupcni t 


• 



•IChlft 

mnlition plinmd, liin 
Kirliruht Front Cnd, 

liter) 



Ikii*. of Kirliruhi 

Or. Emhird toot 

Front End 

Full Adi, 

Slmmt 7741 

Slmmt 7. Ml, 

Front End cm* 


Or, Guido Pinch 

br Grroin 

holt Indtpindmt 


KCdBIII 

plltld In Du, 


«?) 7JMS0 3115 

PICO, 

Front End, 

ritirgitibd Out End 



IfSI, Bootitnp 



Out End 



Out End nrlr 



Intirnil 



ISO), ccnplflid 
tic. ISO) 


lhl». of York 

Or, /in find 

Setmn 

Cenpllir for toll Adi 

EWUftX (C) 

Smr, plot 

Sublet cenptlir 


fff) SU-SSOSl 

Smirch 

ulth rilirgitibli Out 


POP-1 1/tSIIX, 

for MAX lUlllibli 



Council 

End| mphilll on ecnpllt 

FESO/lflfX <C) 

bin PDP-11 

to lit idueithnit 



of Grill 

Uni dlignotllct 



•itibHihiinti Ii 

- 


Orllilo 


■ 

Oct, 3767. Full 
cenpllir for MAX 
In nid-iu-wr 3763. 




IWRIX Of AM IAHGW0E IMPlfMtXTAlICNS 
(Vpditid Noumbir IS33) 

U. S. EFFORTS 


0RWU2AIKH 

CO/TACT 

(CHI tod 

•III*.. ■■.*..*..1111111 III* mm 

SCOPE 

■»■"»»»»»»» ■■■■ MOM 

HOST SYSTEM 

TASSH SYSTDt 

AVAIUOIIITT 




• **• mmmmmm mm m-m m ... 



Alin, tie. 

Chuck Pilrlcl 

Intirnil 

Full FflS] Adl| Joint 

WXAHSj (Bill- 

KC Mill, 

Fill ISM 


(117)131-1131 


f f fort .ilh Alin, S.A. 

ind GI9f-bitid 
■orlitltlom 

Intit 6184 


AndiM Corp. 

lubirl lint 

mo 

Port K3U Adi/ED to Adiihl 

AndiM 171 

Mill IIM 

Adi/Edl no* 


tlll)74M3i) 


17l| cron-cmpilir (or 

ItSt conpitlblt) 


IMfi Oil. '11 




Intel 6186. 



(In!, ill onlr) 

It It ll* 

Chirlit Vithirtll 

Intirnil 

Ooolitnp Subtit Ccnptliri 

VAX (Drill} 

m 

(trip '13 (iMlilnp) 


<763)567-317? 


Full Prolotfpi Cotplllf 



Undid 

lott, lirmit md Nnnin 

lob Thom 

tnlirnil 

Por till Inplininlitlon 

UAXOHSJj 

MAX, POP-Ill 

...nna...a...aa*l>.w««» 

till 1392 


Rich Shiplro 
dul It Sutinln 


bind on Prtilt empiltr 

DEC-71 

DEC-26 



<4l7>473-ie:i 






turroughi Fidirit ind 

TlM Par (OA. 

mo 

Adi Tre ni End to Ohm 

OurrovgM 

Ittrroughf 


Jfuiil Sritm 

(215)m*)2Jt 


uiing ittrlbvti gr**ur 
tlChniqum 

lirgi mini 

intm 







— *■ M ***• mm m .*■... . ■ ■ mmmmm mmmmmmm 


Cirifglfttinfirt luftF* 

Kiflo lirbicci 

SPICE 

full conpilir 1 

DEC VAX CLNIX) Ind 

PERCiAlio VAX (MIX 

Subt a 1 ccnpJlir 


<1)2)5)1-25)1 

Frojid 

progrmmg inilromint 

Thru Rt.iri Cot- 

•Ith lottprocmor 

■bli linn Iff], Full 


lirbiccdSW 



pulir Corp, PER? 

Adi empiltr k pro- 





(ACCEMT) 


grnilng m.lrommt 
In 1786. Olilribulien 


• 





indfr SPICE ProjfCt 
Induitrlil Adit, i(n 





• 



Progrn. 

Control till Corp. 

Clrdi (, t.-if, dr. 

Inlirnit 

Full Adi nilh 

CYIEM)t(KOS) 

CTBEX-DI 

lilt ISM 

— 

<111)355-1)12 


Mr 1 J a I tnvifowifftl 

U*M*n..n*tnnnt..... 



««»l«n*». I««. hiniw «• lit. . 11 * 4.1 ll. HI ■> ml ,t i.k aiur | a | |» „ mUt 

’mi ill > ^i!‘! !' *" •? **>••» ♦••••mil ••.•Mm* I*. *c* c.*»n*i t*i mu ii im 

..J * !!. 1 mim ail uliri ll ll.i. 1**1 ii*.i*i u l. *«,.,*.,,. , f ,, ■ lu«ri*i|u f ar C*«*.li*l n*uu*i t ■ >u . 

•> *« nil 1 ...uni ...ll 1*11 "iii'ui I, I* M»||{ m*i*i*.* I. ra*. 



*ST*fr-III I CSI**-IIX 


nvmx or am l/ticmce impkmehtatiehs 
(Updated Nouenber 1(93) 

It. S. EFFORTS 


C9&W2ATIEH 

Conner 

cow fact 

SCOPE 

HOST SYSTEM 

TASOH SYSTEM 

ff-ttl LABILITY 

OlgHil Cqulpirnl 

Mirglr tigl lerp 


Fell Adi 

WXAHS “• 

UAXAMS 


Ccrpvellcn 

(9131991-3339 






Oi 9l(cn; (uetrch 

Orthn Kill 

Uritern 

mi Blindin' '.di 

CrtpKi ill wl in 

Sue 

tuediile 

Ccrporetlon 

<417)273*3911 

Oi 91 1*1 

* , 

Cimoft SIC Adi 

(«llldllid)| 

Tilitdll-Adi 



Florida Slit* Uitlw. 

Of. 3. P. Biker 

USAf/ 

Fell Adt 

COC Cyber 71 

71(09 2-Sltt 

Pet. 1(93 


<9l4)4t(*5432 

AFATL 


(KOS) 

Develcp.ienl Module 



cr 999*19(9 




MII-ST0-I73M 


Senioil Corporation 

Puilt Sujir 

t. icq'il 

l) FftSI Adi 

). uo 1911 Series* 

1. Sue 

1, Kw) vi! lotted 

(9)3)931-1233 

(rtn U.O. 




Aug. 1, 1(93 



2. TW 

2. WSJ .Adi 

.2. VAXAKt 

2. MCF 

2. Utl 1(93 



3. In* 

3. 14-btl interpreter. 

3. WADS 

3. WXAWS 

3. Mu 



ternil 

United to (It line unlit. 
Prlnirr vte it edecitlcn 
ind Irlining, 


* 




9. In* 

9. 32-bil interpreter. 

4. tMXAttS 

9. UAXAMS 

4, April 1(99 



ternil 

WS! SUndird Adt 




Kontrut I t Office Kgil. 

Alin C. Inin 

Konr 

Subset 

mines <Fui> 

0PS9 

Hoe 

Jytleni Sivltion 

(917)9(1-29(3 


Full Adi 

OPS 9 

Sue 

ISO 

lit lei Csrpoeil 1 on 

Ton; Anderton 

Intel 

Full Adt. linker, Debugger , 

Utt(UflXWlS) 

Intel iAPX-433 

April 1(93 


9313)991-7131 


Ttrgrl Operating Srtten 
eecept Find Point Types. 
Abort, lined Entry, Enunert- 







t ion Type I/O, tone pre- 
defined pragma. 





tWTSIX OF AM lAHOUAGE IMPlEMEMTATIOiS 
(Updated Noveieber 1(93) 

U, S. EFFORTS 


OSW912ATKH 

CtNTACT 

COfTPACT 

SCOPE 

HOST SYSTEM 

TARGET SYSTEM 

ACSIIA3M.ITY 

Intel Corpontlon 

Xinnelh Pcnper 
(4I9)(87*5(34 

Intel 

Full, uilidited Adt 

WXAttS 

9194 (IAPX94) 

End of 1(91 

Intemitrici, Inc. 

Piter letnonl 
Mile Jyer 
(917)991*1991 
(etnontiECLS 

AiPO 

Full Adi 

PDP-11 (TCPS-21) 
(SIMM) 

TCPS-21 wEtli 
extended drilling 

Ptrlill Inslenenlation 
(Hot tuppcrled) 

Intimetrlci, Inc, 

Mite Brer 
(917)991*1991 

USAF 

(SACO 

Full Adt plus enulrciuienl 
f'Stonmtn') 

191 371 

Sue 

1(94 

ItiMt InlcrnitPoml 

Kirk KcCleet 
Cirllon Hill* 
(217)3(9*1(99 

Priutle 

Full Fit 

Burr ought large 
intern! BS’ll, 
14(19, 17(11 

SI 96 1 m t host 

fflullticft 

Third quirter l(9t 

Hew Tort Unlvertily 

Ed Schonberg 
(212)991*7992 
SCH09SERG it MTU 

U. S. 

Arny 

9CEC01) 

Full Itngutge Interpreter 
ind in opiNtiontt 
definition of Adt. 

WXi WS ind mix 
IfftlCMS, MJS, VSI 

Sue 

lieu, VWXAKSi fro, hi IS 
(uilidited 1/93) 
otheri: fren NYU 

HuSoft 

Wayne Higor 
t!l()S25*l993 

Internet , Full Adi 
u/Hexle 1 1 eventuitly 
Ptcktrd 

HP3III 

Sue 

Sublet late 1(92 

HOLM Corp. 

Utn William 
(499)999*2(99 

Inlirnil 

Full AMS! Adi Milk loot III 

OSE/Btlf 
Oita (merit 
32-bll ECLIPSE 

MSE/Sit, 

MSE/lt, 

14940 

Uilidited cenpilrr 
ivlilible ncu 

HR Softvire 

Olndltl Sruklitrdt 
(419)244*9479 

« 

Internet 

Oeugned lo run on, 
genertle code’ for, 
current nlcreproceiioM. 

0909 MS-005, 
9194 CP/M-94 

Sue, 

end 9191/299 

Piriitl inplenenltlion 
‘lutiltble ncu 

Scimi El icit Horn, 
IhC. 

truce lightner 
lee Ctruer 
(410434*4491 

Internal 

u/Heutelt 

Ptcktrd 

Full Ada euentually 

HP 1191 Win 
(PlKlI) 

S»f 

Sublet Itlr K93 






II2-4.15G 


MHIX CF AM UFIGIMC IKPlIMXfATIOlS 
FUpdllld Hovinbir 1 f S3) 

B. S. E/fCffTS 


OJWFIJATICN 

COFTACT 

CtNTIWC? 

SCOPE 

N0ST STSTD1 

tajish sraut 

4M911ASIIW 

SafTich, Inc. 

6torgr Rodrlgvn 
(417)111-4311 

If.S.Amr 

(CECW 

Cmanhinilvt Adi Pro- 
graining Support tnvlron- 
nmt .lib 'Sloimm', and 
Including production ANSI 
Adi coiplltr. 

UAXAtiS 

Slit 

NCF 

Hoil/tirgrl - Oct. '84 
NCF- Otc. '83 

Stulord Ihlviriltr 

Daw Id Uclhin 
(415)437*1242 
Softuara 01)1. Ctr. 
<413)437-1431 

MSPA 

Ad« tupporli gmtrlct, 
ciciptioni, up. [tup,, 
nail of AdiBI Uitfngi 
Full Adi luting In 
progriti. 

CEC-II 

T0FS-2I 

OEC-II 

* 

Adtn iviltible nor 

TilnoFt, jnc. 

Brutl Sbimm 
(413)457-2711 
V.P., Slid t 
rur tiling 

Nani 

Klgb prrlammcf lubitm- 
(HI boil Indrptndinl 
InplNiintitlon Franl End 
(ANSI Adi '83) md ftlddll 
pail, ml 1 r rtlirgilid 
Bid End, Sulliblt Far 
production prolidi md/er 
education, 

UVCANSl 
VWtNJXl 
HTVWJS/TSOl 
I9V04SI IBM PC 
48111/1311X1 
4S 18 8/A0S 

San* , 

croii-ccnpllillon 
(ren III Noils la 
48111 Bar* nichini 
For prcdvcllen 
code. 

Pirtlil ANSI Adi '13 lev 
ill ibavf mlliblt t.v, 
CirllFp to pm ill 
ullldillan trill on il 
1 mt enr hoit/lmget br 
Ihr lid of 1383, Up 1 1 be 
lu&ltlrd Far ealidltlon 
ihortlp ihirrilirr, 

Unlvic Oefmie Sritm 
Olililoo 

Jar Cron 
<412)454*4327 

13.10 

'Bdi' i«b|it| no lilting 
•irx mill 

ivij.it mi 

FOElftN llnulitor 
el 9-iucblnt target 

Jinurr 1381 

USAF Annint Ub 

Nr. A.Hlrtou Htftm 
2nd M, trim K. 
Vhitcoli 
<314)882-8244 
-2141 


Full Adi Caipllir 

COC Crirr 174 
running NOS or 
NOS/BE operiling 
ipllra. 

28882 Oivtlapnm! 
Module, 

28412 OJS ccnpulir 

2B882 Civile; Nodule 
Tirjit III 8 Cllt 
28112 0IS ccnpulir 
large t 3rd 0 CT84 

ISC-1SI 

Oil) Until 
Robert Billrr 
<213)822-1511 

MUM 

Intrrprilir For Fee-nil 
Smmtlc Olflnllton 0 < Adi 
br INRIAAALSY5 

0EC-2I (10PS-2I) 
Birtilir WC 

Inter) Jtp 

/ulr 1982 


FHTRIX Of AM LANOIME mtNDFTATICNS 
(Upditid Hovmiir 1383) 

EUROPEAN AN9 JAPANE5E EFFORTS 


0R6VFI2ATI9F 

CtNIACT 

CfNTMCT 

SCOPE 

host SYSTEM 

TAR6CT SYSTEM 

AwiiASiim 

EAC? (Etropiu Adi 
Ccnpllir ProJid)| 
At in, S.A.j 
CI1 Konepwl) Bull) 

ilont 

J-C. Kiliird 
Alin 

ll Call* St, Cloud 
Frinci 

(33-3)318 1244 
MAftnri NIT-Nultlci 

Europnn 

Coevjni- 

llil 

Full Mi[ porlibll root, 
rehoilibli an rtlni- md 
ilcro-conpeten 

c!‘, HI livtl 44, 
Sllnini 7741 

Sail. 

1384 

Intvlcllungibeiro 

UEttfl 

Mr. Vlndiuir 
(43)4131 33344 

Simin NoO Srabollc Teit/Oibug Snt» Slmmi 7,it> 
(pirt of Can; Hid md Inlirpntid 8$ 2111 
SPCRBER) aodi j high!; rehaitibll/ (Adi) 
ritirgflible. 

Sale, end llio Nld 1384 

SInn.ii 331/ Off ( 

8PP Munich 

Nr. Elcbinavir 

Birnm NaO Ritirgetible Bict End 

Slnint 7118 

Slmmi 3311 

Kid 1383 


<43)13 481434 (pirt of Fee Full Adit input ii (Adl-I) It. Il, 

SPER8ER) 01 nil Trot Kirlirulll 
Front End 


Iit't Capoten ltd. Nirtn Jordm (CL Sritmi prejig. iubiet| la 2SM la 2914 

(44)700 31 111 exclude! fisting, ml 

I/PII, I/O 

Nippon Titigriph.l R/olchl Hoion Full Ada evenluillr DIPS Sale 

Ttliplioni, Yceaiuti <8l>44B-39-2?JI 
Elfctn'eal Cawnl- 
Cttloo Wboriterp 

Olivetll/Omlil Oil Oift Eurapnn Full Adi tmpflir plat Chriitiin Sni 

Ditmtlci Centre UngOr, Oenmrt Cowuni* Slonmin invlrcmmt tovs Ing 01 810 

CPriitlu tailing Ltd. (43)2-872422 till Olliittl S4III 


Subllt Ittt 1)83 


Ctrl r 1984 


Dr SoMplin AO 


frthi UMInin 
((331)31 37 317 
TElEKt 

12 3 348 SPIAN S f 


NOKIA Sobut For Irilmi 
tlictren- loFtuin dtvelapnint 
Itl on NFS || 
flnlind 


lootilrtp oa 

mxxis 


NFS II 


Odobir 1381 


Reeds eerder verschenen in deze reeks: 


84-11 

Z. Nowak 

A quasi-Newton multigrid method lor 
dertermining the transonic lifting 
flows around airfoils 

84-12 

A. Segal 

A short note on the implementation 
of boundary conditions of the type u 
equals unknown constant in finite 
element codes 

84-13 

W. de Meio & S.3. van Strien 

Diffeomorphisms on surfaces with a 
finite number of moduli 

84-14 

G.W. Decnop 

In de ban van de drlehoek 

84-15 

J. van Kan 

A second-order pressure-correction 
method for viscous incompressible 
flow 

84-16 

P. Sonneveld 

CGS, a fast Lanczos-type solver for 
nonsymmetric linear systems 

84-17 

A.H.P. van der Burgh 

A simple aeroelastic oscillator as a 
model for conductor galloping 

84-18 

H.L. CJaasen (red.) 

Colloquium Vakgroep Aigemene 

Wiskunde 

84-19 

M. Kok and FA, Lootsma 

Pairwise-comparison methods in 

multi-objective programming, with 
applications in a long-term energy- 
planning model 

84-20 

Bram van Leer and 
William A. Mulder 

Relaxation methods for hyperbolic 
equations 

84-21 

Ben de Pagter 

A functional calculus in f-aJgebras 

84-22 

M. Kok and C. Roos 

On the convergence of a nonnegative 
square matrix 

84-23 

Bram van Leer 

Upwind-difference methods for 

aerodynamic problems governed by 
the Euier equations 

84-24 

L, Fortuin and F.A. Lootsma 

Future directions in operations 
research 

84-25 

P. Sonneveld and 
B. van Leer 

A minimax problem along the 
imaginary axis' 

84-26 

CJ, van Duyn and 
D. Hilhorst 

On a doubly nonlinear diffusion 
equation in hydroiogy 

84-27 

G. Hooghiemstra 
and M. Keane 

Calcuiation of the equilibrium 

distribution for a solar energy 

storage model 

84-28 

J. van Katwijk 

Ontwikkeiingen rond Ada 


Exemplaren van deze rapporten kunnen besteld worden blj het bureau van 
de Onderafdeling der Wiskunde en Informatica, 3ulianaiaan 132, 2628 BL 
DELFT, telefoon 015-784568. 


