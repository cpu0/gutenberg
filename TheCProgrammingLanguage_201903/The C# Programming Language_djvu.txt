Special Annotated Edition for C# 4.0 


The C# 

Programming 

Language 

Fourth Edition 














The C# Programming Language 

Fourth Edition 


www.it-ebooks.info 


;> The C# 
Programming 
•\ Language 

^ Fourth Edition 


■ Anders Hejlsberg 
Mads Torgersen 
Scott Wiltamuth 
Peter Golde 


AAddison-Wesley 


Upper Saddle River, NJ • Boston • Indianapolis • San Francisco 
New York • Toronto • Montreal • London • Munich • Paris • Madrid 
Capetown • Sydney • Tokyo • Singapore • Mexico City 


www.it-ebooks.info 



Many of the designations used by manufacturers and sellers to distinguish their products are 
claimed as trademarks. Where those designations appear in this book, and the publisher was 
aware of a trademark claim, the designations have been printed with initial capital letters or in all 
capitals. 

The .NET logo is either a registered trademark or trademark of Microsoft Corporation in the Unit¬ 
ed States and/or other countries and is used under license from Microsoft. 

Microsoft, Windows, Visual Basic, Visual C#, and Visual C-t-t are either registered trademarks or 
trademarks of Microsoft Corporation in the U.S.A. and/or other countries/regions. 

The authors and publisher have taken care in the preparation of this book, but make no expressed or 
implied warranty of any kind and assume no responsibility for errors or omissions. No liability is 
assumed for incidental or consequential damages in connection with or arising out of the use of the 
information or programs contained herein. 

The publisher offers excellent discounts on this book when ordered in quantity for bulk purchases or 
special sales, which may include electronic versions and / or custom covers and content particular to 
your business, training goals, marketing focus, and branding interests. For more information, please 
contact: 

U.S. Corporate and Government Sales 
(800)382-3419 

corpsales@pearsontechgroup.com 

For sales outside the United States, please contact: 

International Sales 
international@pearson.com 

Visit us on the Web: informit.com/aw 

Library of Congress Cataloging-in-Publication Data 

The C# programming language / Anders Hejlsberg... [etal.].—4th ed. 

p. cm. 

Includes index. 

ISBN 978-0-321-74176-9 (hardcover: alk. paper) 

1. C# (Computer program language) I. Hejlsberg, Anders. 

QA76.73.C154H45 2010 
005.13'3—dc22 

2010032289 


Copyright © 2011 Microsoft Corporation 

All rights reserved. Printed in the United States of America. This publication is protected by copy¬ 
right, and permission must be obtained from the publisher prior to any prohibited reproduction, 
storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, 
photocopying, recording, or likewise. For information regarding permissions, write to: 

Pearson Education, Inc. 

Rights and Contracts Department 
501 Boylston Street, Suite 900 
Boston, MA 02116 
Fax: (617) 671-3447 


ISBN-13:978-0-321-74176-9 
ISBN-10: 0-321-74176-5 

Text printed in the United States on recycled paper at Courier in Westford, Massachusetts. 
First printing, October 2010 


www.it-ebooks.info 


Contents 


Foreword xi 
Preface xiii 
About the Authors xv 
About the Annotators xvii 

1 Introduction i 

1.1 Hello, World 3 

1.2 Program Structure 4 

1.3 Types and Variables 6 

1.4 Expressions 13 

1.5 Statements 16 

1.6 Classes and Objects 21 

1.7 Structs 50 

1.8 Arrays 53 

1.9 Interfaces 56 

1.10 Enums 58 

1.11 Delegates 60 

1.12 Attributes 61 

2 Lexical Structure 65 

2.1 Programs 65 

2.2 Grammars 65 

2.3 Lexical Analysis 67 

2.4 Tokens 71 

2.5 Preprocessing Directives 85 


www.it-ebooks.info 


Contents 


3 Basic Concepts 99 

3.1 Application Start-up 99 

3.2 Application Termination 100 

3.3 Declarations 101 

3.4 Members 105 

3.5 Member Access 107 

3.6 Signatures and Overloading 117 

3.7 Scopes 120 

3.8 Namespace and Type Names 127 

3.9 Automatic Memory Management 132 

3.10 Execution Order 137 

4 Types 139 

4.1 Value Types 140 

4.2 Reference Types 152 

4.3 Boxing and Unboxing 155 

4.4 Constructed Types 160 

4.5 Type Parameters 164 

4.6 Expression Tree Types 165 

4.7 The dynamic Type 166 

5 Variables 169 

5.1 Variable Categories 169 

5.2 Default Values 175 

5.3 Definite Assignment 176 

5.4 Variable References 192 

5.5 Atomicity of Variable References 193 

6 Conversions 195 

6.1 Implicit Conversions 196 

6.2 Explicit Conversions 204 

6.3 Standard Conversions 213 

6.4 User-Defined Conversions 214 

6.5 Anonymous Eunction Conversions 219 

6.6 Method Group Conversions 226 


www.it-ebooks.info 



7 Expressions 231 

7.1 Expression Classifications 231 

7.2 Static and Dynamic Binding 234 

7.3 Operators 238 

7.4 Member Lookup 247 

7.5 Function Members 250 

7.6 Primary Expressions 278 

7.7 Unary Operators 326 

7.8 Arithmetic Operators 331 

7.9 Shift Operators 343 

7.10 Relational and Type-Testing Operators 344 

7.11 Logical Operators 355 

7.12 Conditional Logical Operators 358 

7.13 The Null Coalescing Operator 360 

7.14 Conditional Operator 361 

7.15 Anonymous Function Expressions 364 

7.16 Query Expressions 373 

7.17 Assignment Operators 389 

7.18 Expression 395 

7.19 Constant Expressions 395 

7.20 Boolean Expressions 397 

8 Statements 399 

8.1 End Points and Reachability 400 

8.2 Blocks 402 

8.3 The Empty Statement 404 

8.4 Labeled Statements 406 

8.5 Declaration Statements 407 

8.6 Expression Statements 412 

8.7 Selection Statements 413 

8.8 Iteration Statements 420 

8.9 Jump Statements 429 

8.10 The try Statement 438 

8.11 The checked and unchecked Statements 443 

8.12 The lock Statement 443 

8.13 The using Statement 445 

8.14 The yield Statement 449 


www.it-ebooks.info 



Contents 


9 Namespaces 453 

9.1 Compilation Units 453 

9.2 Namespace Declarations 454 

9.3 Extern Aliases 456 

9.4 Using Directives 457 

9.5 Namespace Members 463 

9.6 Type Declarations 464 

9.7 Namespace Alias Qualifiers 464 

10 Classes 467 

10.1 Class Declarations 467 

10.2 Partial Types 481 

10.3 Class Members 490 

10.4 Constants 506 

10.5 Fields 509 

10.6 Methods 520 

10.7 Properties 545 

10.8 Events 559 

10.9 Indexers 566 

10.10 Operators 571 

10.11 Instance Constructors 579 

10.12 Static Constructors 586 

10.13 Destructors 589 

10.14 Iterators 592 

11 Structs 607 

11.1 Struct Declarations 608 

11.2 Struct Members 609 

11.3 Class and Struct Differences 610 

11.4 Struct Examples 619 

12 Arrays 625 

12.1 Array Types 625 

12.2 Array Creation 628 

12.3 Array Element Access 628 


VIII 


www.it-ebooks.info 



12.4 Array Members 628 

12.5 Array Covariance 629 

12.6 Array Initializers 630 

13 Interfaces 633 

13.1 Interface Declarations 633 

13.2 Interface Members 639 

13.3 Fully Qualified Interface Member Names 645 

13.4 Interface Implementations 645 

14 Enums 663 

14.1 Enum Declarations 663 

14.2 Enum Modifiers 664 

14.3 Enum Members 665 

14.4 The System.Enum Type 668 

14.5 Enum Values and Operations 668 

15 Delegates 671 

15.1 Delegate Declarations 672 

15.2 Delegate Compatibility 676 

15.3 Delegate Instantiation 676 

15.4 Delegate Invocation 677 

16 Exceptions 681 

16.1 Causes of Exceptions 683 

16.2 The System.Exception Class 683 

16.3 How Exceptions Are Handled 684 

16.4 Common Exception Classes 685 

17 Attributes 687 

17.1 Attribute Classes 688 

17.2 Attribute Specification 692 

17.3 Attribute Instances 698 

17.4 Reserved Attributes 699 

17.5 Attributes for Interoperation 707 


www.it-ebooks.info 



Contents 


18 Unsafe Code 709 


18.1 

Unsafe Contexts 710 


18.2 

Pointer Types 713 


18.3 

Fixed and Moveable Variables 

716 

18.4 

Pointer Conversions 717 


18.5 

Pointers in Expressions 720 


18.6 

The fixed Statement 728 


18.7 

Fixed-Size Buffers 733 


18.8 

Stack Allocation 736 


18.9 

Dynamic Memory Allocation 

738 

Documentation Comments 741 


A.l 

Introduction 741 


A.2 

Recommended Tags 743 


A.3 

Processing the Documentation File 754 

A.4 

An Example 760 


Grammar 767 


B.l 

Fexical Grammar 767 


B.2 

Syntactic Grammar 777 


B.3 

Grammar Extensions for Unsafe Code 809 

References 813 


Index 

815 



X 


www.it-ebooks.info 



Foreword 


It's been ten years since the launch of .NET in the summer of 2000. For me, the significance 
of .NET was the one-two combination of managed code for local execution and XML mes¬ 
saging for program-fo-program commimicafion. What wasn't obvious to me at the time 
was how important C# would become. 

From the inception of .NET, C# has provided the primary lens used by developers for 
understanding and interacting with .NET. Ask the average .NET developer the difference 
between a value type and a reference t 5 ^e, and he or she will quickly say, "Sfrucf versus 
class," nof "Types that derive from System.ValueType versus those that don't." Why? 
Because people use languages—^not APIs—to communicate their ideas and intention to the 
rimtime and, more importantly, to each other. 

It's hard to overstate how important having a great language has been to the success of fhe 
plafform af large. C# was initially important to establish the baseline for how people think 
about .NET. It's been even more important as .NET has evolved, as features such as itera¬ 
tors and true closures (also known as anonymous methods) were introduced to developers 
as purely language features implemented by the C# compiler, not as features native to the 
platform. The fact that C# is a vital center of innovation for .NET became even more appar¬ 
ent with C# 3.0, with the introduction of standardized query operators, compact lambda 
expressions, extension methods, and runtime access to expression trees—again, all driven 
by development of the language and compiler. The most significant feature in C# 4.0, 
dynamic invocation, is also largely a feature of the language and compiler rather than 
changes to the CLR itself. 

It's difficult to talk about C# without also talking about its inventor and constant shepherd, 
Anders Hejlsberg. I had the distinct pleasure of participating in the recurring C# design 
meetings for a few months during the C# 3.0 design cycle, and it was enlightening watch¬ 
ing Anders at work. His instinct for knowing what developers will and will not like is truly 


www.it-ebooks.info 



Foreword 


world-class—^yet at the same time, Anders is extremely inclusive of his design team and 
manages to get the best design possible. 

With C# 3.0 in particular, Anders had an uncarmy ability to take key ideas from fhe func- 
fional language communify and make fhem accessible fo a very broad audience. This is no 
frivial feaf. Guy Sfeele once said of Java, "We were nof ouf fo win over fhe Lisp program¬ 
mers; we were affer the C++ programmers. We managed to drag a lot of fhem abouf half¬ 
way fo Lisp." When 1 look af C# 3.0,1 fhink C# has managed fo drag af leasf one C++ 
developer (me) mosf of fhe resf of fhe way. C# 4.0 fakes fhe nexf sfep foward Lisp (and 
JavaScripf, Pyfhon, Ruby, ef al.) by adding fhe abilify fo cleanly wrife programs fhaf don'f 
rely on sfafic fype definitions. 

As good as C# is, people still need a documenf written in bofh nafural language (English, 
in fhis case) and some formalism (BNF) fo grok fhe subflefies and fo ensure fhaf we're all 
speaking fhe same C#. The book you hold in your hands is fhaf documenf. Based on my 
own experience, 1 can safely say fhaf every .NET developer who reads if will have af leasf 
one "aha" momenf and will be a better developer for if. 

Enjoy. 

Don Box 
Redmond, Washington 
May 2010 


xii 


www.it-ebooks.info 



Preface 


The C# project started more than 12 years ago, in December 1998, with the goal to create a 
simple, modern, object-oriented, and type-safe programming language for fhe new and 
yef-fo-be-named .NET plafform. Since fhen, C# has come a long way The language is now 
in use by more fhan a million programmers and has been released in four versions, each 
wifh several major new feafures added. 

This book, foo, is in ifs fourfh edifion. If provides a complefe fechnical specification of fhe 
C# programming language. This lafesf edifion includes fwo kinds of new maferial nof 
found in previous versions. Mosf nof ably, of course, if has been updafed fo cover fhe new 
feafures of C# 4.0, including dynamic binding, named and opfional paramefers, and cova- 
rianf and confravarianf generic f 5 ^es. The overarching fheme for fhis revision has been fo 
open up C# more fo inferacfion wifh objecfs oufside of fhe .NET environmenf. Jusf as LINQ 
in C# 3.0 gave a language-infegrafed feel fo code used fo access exfernal dafa sources, so 
fhe dynamic binding of C# 4.0 makes fhe inferacfion wifh objecfs from, for example, 
dynamic programming languages such as Pyfhon, Ruby, and JavaScripf feel native fo C#. 

The previous edifion of fhis book infroduced fhe notion of armofafions by well-known C# 
experfs. We have received consisfenfly enfhusiasfic feedback abouf fhis feafure, and we are 
exfremely pleased fo be able fo offer a new round of deep and enferfaining insighfs, guide¬ 
lines, background, and perspecfive from bofh old and new armofafors fhroughouf fhe 
book. We are very happy fo see fhe armofafions confinue fo complemenf fhe core maferial 
and help fhe C# feafures spring fo life. 

Many people have been involved in fhe creafion of fhe C# language. The language design 
feam for C# 1.0 consisfed of Anders Hejlsberg, Scoff Wilfamufh, Pefer Golde, Pefer Sollich, 
and Eric Gurmerson. Eor G# 2.0, fhe language design feam consisfed of Anders Hejlsberg, 
Pefer Golde, Pefer Hallam, Shon Kafzenberger, Todd Proebsfing, and Anson Horfon. 


■ xiii 


www.it-ebooks.info 



Preface 


Furthermore, the design and implementation of generics in C# and the .NET Common 
Language Runtime is based on the "Gyro" prototype built by Don Syme and Andrew 
Kennedy of Microsoff Research. C# 3.0 was designed by Anders Hejlsberg, Erik Meijer, 
Maff Warren, Mads Torgersen, Pefer Hallam, and Dinesh Kulkarni. On fhe design feam for 
C# 4.0 were Anders Hejlsberg, Maff Warren, Mads Torgersen, Eric Lipperf, Jim Hugunin, 
Lucian Wischik, and Neal Gaffer. 

If is impossible fo acknowledge fhe many people who have influenced fhe design of G#, 
buf we are nonefheless grafeful fo all of fhem. Nofhing good gefs designed in a vacuum, 
and fhe consfanf feedback we receive from our large and enfhusiasfic communify of devel¬ 
opers is invaluable. 

G# has been and confinues fo be one of fhe mosf challenging and excifing projecfs on which 
we've worked. We hope you enjoy using C# as much as we enjoy creating if. 

Anders Hejlsberg 
Mads Torgersen 
Scoff Wilfamufh 
Pefer Golde 
Seattle, Washington 
September 2010 


xiv 


www.it-ebooks.info 



About the Authors 


Anders Hejlsberg is a programming legend. He is the architect of the C# language and a 
Microsoft Technical Fellow. He joined Microsoft Corporation in 1996, following a 13-year 
career af Borland, where he was fhe chief archifecf of Delphi and Turbo Pascal. 

Mads Torgersen is fhe program manager for fhe C# language af Microsoff Corporafion, 
where he runs fhe day-fo-day language design process and mainfains fhe language 
specification. 

Scott Wiltamuth is director of program managemenf for fhe Visual Sfudio Professional 
feam af Microsoff Corporafion. Af Microsoff, he has worked on a wide range of develop- 
menf fools, including OLE Aufomafion, Visual Basic, Visual Basic for Applications, VBScripf, 
JScripf, Visual J++, and Visual C#. 

Peter Golde was the lead developer of fhe original Microsoff C# compiler. As fhe primary 
Microsoff represenfafive on fhe ECMA commiffee fhaf sfandardized C#, he led fhe imple- 
menfafion of fhe compiler and worked on fhe language design. He is currenfly an archifecf 
af Microsoff Corporafion working on compilers. 


www.it-ebooks.info 



This page intentionally left blank 


www.it-ebooks.info 


About the Annotators 


Brad Abrams was a founding member of bofh fhe Common Language Runfime and fhe 
■NET Framework feams af Microsoff Corporafion, where he was mosf recenfly fhe direcfor 
of program managemenf for WCF and WF. Brad has been designing parfs of fhe .NET 
Framework since 1998, when he sfarfed his framework design career building fhe BCL (Base 
Class Library) fhaf ships as a core parf of fhe .NET Framework. Brad graduafed from Norfh 
Carolina Sfafe Universify in 1997 wifh a BS in compufer science. Brad's publications include: 
Framework Design Guidelines, Second Edition (Addison-Wesley, 2009), and .NET Framework 
Standard Library Annotated Reference (Volumes 1 and 2) (Addison-Wesley, 2006). 

Joseph Albahari is coaufhor of C# 4.0 in a Nutshell (O'Reilly, 2007), fhe C# 3.0 Pocket Refer¬ 
ence (O'Reilly, 2008), and fhe LINQ Pocket Reference (O'Reilly, 2008). He has 17 years of expe¬ 
rience as a senior developer and soffware archifecf in fhe healfh, educafion, and 
felecommunicafion indusfries, and is fhe aufhor of LlNQPad, fhe ufilify for inferactively 
querying dafabases in LINQ. 

Krzysztof Cwalina is a principal archifecf on fhe .NET Framework feam af Microsoff. He 
sfarfed his career af Microsoff designing APIs for fhe firsf release of fhe Framework. Cur- 
renfly, he is leading fhe efforf fo develop, promofe, and apply design and archifecfural 
sfandards fo fhe developmenf of fhe .NET Framework. He is a coaufhor of Framework 
Design Guidelines (Addison-Wesley, 2005). Reach him af his blog ahffp://blogs.msdn.com/ 
kcwalina. 

Jesse Liberty ("Silverlight Geek") is a senior program manager at Microsoft and the author 
of numerous besf-selling programming books and dozens of popular articles. He's also a 
frequent speaker at events world-wide. His blog,http://JesseLiberty.com, is required read¬ 
ing for Silverlighf, WPF, and Windows Phone 7 developers. Jesse has more fhan fwo 
decades of real-world programming experience, including sfinfs as a vice presidenf af Cifi 
and as a distinguished soffware engineer af AT&T. He can be reached fhrough his blog and 
followed af ©JesseLiberfy. 


www.it-ebooks.info 



About the Annotators 


Eric Lippert is a senior developer on the C# compiler team at Microsoft. He has worked 
on the design and implementation of the Visual Basic, VBScript, JScript, and C# languages 
and Visual Studio Tools For Office. His blog about all those topics and more can be found 
at http://blogs.msdn.com/EricLippert. 

Christian Nagel is a Microsoft regional director and MVP. He is the author of several 
books, including Professional C# 4 with .NET 4 (Wrox, 2010) and Enterprise Services with the 
.NET Framework (Addison-Wesley, 2005). As founder of CN innovation and associate of 
thinktecture, he teaches and coaches software developers on various Microsoft .NET tech¬ 
nologies. Christian can be reached at http://www.cninnovation.com. 

Vladimir Reshetnikov is a Microsoft MVP for Visual C#. He has more than eight years of 
software development experience, and about six years of experience in Microsoft .NET and 
C#. He can be reached at his blog http://nikov-thoughts.blogspot.com. 

Marek Safar is the lead developer of the Novell C# compiler team. He has been working 
on most of the features of Mono C# compiler over the past five years. Reach him at his blog 
at http://mareksafar.blogspot.com. 

Chris Sells is a program manager for the Business Platform Division (aka the SQL Server 
division) of Microsoft Corporation. He's written several books, including Programming 
WPP (O'Reilly, 2007), Windows Forms 2.0 Programming (Addison-Wesley, 2006), and ATE 
Internals (Addison-Wesley, 1999). In his free time, Chris hosts various conferences and 
makes a pest of himself on Microsoft internal product team discussion lists. More informa¬ 
tion about Chris, and his various projects, is available at http://www.sellsbrothers.com. 

Peter Sestoft is a professor of software development at the IT University of Copenhagen, 
Denmark. He was a member of the ECMA International C# standardization committee 
from 2003 through 2006, and is the author of C# Precisely (MIT Press, 2004) and Java Pre¬ 
cisely (MIT Press, 2005). Eind him at http://www.itu.dk/people/sestoft. 

Jon Skeet is the author of C# in Depth (Manning, 2010) and a C# MVP. He works for 
Google in London, writing and speaking about C# in his leisure time. His blog is at 
http:/ /msmvps.com/jon.skeet —or you can find him answering questions most days on 
Stack Overflow (http://stackoverflow.com). 

Bill Wagner is the founder of SRT Solutions, a Microsoft regional director, and a C# MVP. 
He spent the overwhelming majority of his professional career between curly braces. He 
is the author of Effective C# (Addison-Wesley, 2005) and More Effective C# (Addison-Wesley, 
2009), a former C# columnist for Visual Studio Magazine, and a contributor to the C# Devel¬ 
oper Center on MSDN. You can keep up with his evolving thoughts on C# and other top¬ 
ics at http://srtsolutions.com/blogs/billwagner. 


xviii 


www.it-ebooks.info 



1. Introduction 


C# (pronounced "See Sharp") is a simple, modem, object-oriented, and t 5 ^e-safe program¬ 
ming language. C# has its roots in the C family of languages and will be immediafely 
familiar fo C, C++, and Java programmers. C# is sfandardized by ECMA Infernafional as 
fhe ECMA-334 sfandard and by ISO/IEC as fhe ISO/IEC 23270 sfandard. Microsoff's C# 
compiler for fhe .NET Eramework is a conforming implemenfafion of bofh of fhese 
sfandards. 

C# is an objecf-orienfed language, buf C# furfher includes supporf for component-oriented 
programming. Confemporary soffware design increasingly relies on software componenfs 
in fhe form of self-confained and self-describing packages of funcfionalify. Key fo such 
componenfs is fhaf fhey presenf a programming model wifh properfies, mefhods, and 
evenfs; fhey have affribufes fhaf provide declarafive informafion abouf fhe componenf; 
and fhey incorporafe fheir own documenfafion. C# provides language consfrucfs fo direcfly 
supporf fhese concepfs, making C# a very nafural language in which fo creafe and use 
soffware componenfs. 

Several C# feafures aid in fhe consfrucfion of robusf and durable applicafions: Garbage 
collection aufomafically reclaims memory occupied by unused objecfs; exception handling 
provides a sfrucfured and exfensible approach fo error defection and recovery; and fhe 
type-safe design of fhe language makes if impossible fo read from uninitialized variables, 
fo index arrays beyond fheir bounds, or fo perform unchecked type casts. 

C# has a unified type system. All C# t 5 ^es, including primitive types such as int and 
double, inherit from a single roof object type. Thus all t 5 ^es share a set of common opera- 
fions, and values of any f 5 ^e can be stored, fransporfed, and operated upon in a consisfenf 
manner. Eurfhermore, C# supporfs bofh user-defined reference fypes and value fypes, 
allowing d 5 mamic allocafion of objecfs as well as in-line sforage of lighfweighf sfrucfures. 

To ensure fhaf C# programs and libraries can evolve over time in a compafible manner, 
much emphasis has been placed on versioning in C#'s design. Many programming lan¬ 
guages pay little attention fo fhis issue. As a resulf, programs written in fhose languages 
break more offen fhan necessary when newer versions of dependenf libraries are infro- 
duced. Aspecfs of C#'s design fhaf were directly influenced by versioning considerations 
include fhe separate virtual and override modifiers, fhe rules for mefhod overload reso¬ 
lution, and supporf for explicif inf erf ace member declarafions. 


www.it-ebooks.info 




Introduction 


1. Introduction 


The rest of this chapter describes the essential features of the C# language. Although later 
chapters describe rules and exceptions in a detail-oriented and sometimes mathematical 
manner, this chapter strives for clarity and brevity at the expense of completeness. The 
intent is to provide the reader with an introduction to the language that will facilitate the 
writing of early programs and the reading of later chapters. 



■■ CHRIS SELLS Tm absolutely willing to go with "modern, object-oriented, and 
type-safe," but C# isn't nearly as simple as it once was. However, given that the lan¬ 
guage gained functionality such as generics and anonymous delegates in C# 2.0, 
LlNQ-related features in C# 3.0, and d 5 mamic values in C# 4.0, the programs them¬ 
selves become simpler, more readable, and easier to maintain—which should be the 
goal of any programming language. 


“■ ERIC LIPPERT C# is also increasingly a functional programming language. Fea¬ 
tures such as t 5 ^e inference, lambda expressions, and monadic query comprehensions 
allow traditional object-oriented developers to use these ideas from functional lan¬ 
guages to increase the expressiveness of the language. 


"■ CHRISTIAN NAGEL C# is not a pure object-oriented language but rather a lan¬ 
guage that is extended over time to get more productivity in the main areas where C# 
is used. Programs written with C# 3.0 can look completely different than programs 
written in C# 1.0 with functional programming constructs. 


■■ JONSKEET Certain aspects of C# have certainly made this language more func¬ 
tional over time—^but at the same time, mutability was encouraged in C# 3.0 by both 
automatically implemented properties and object initializers. It will be interesting to 
see whether features encouraging immutability arrive in future versions, along with 
support for other areas such as tuples, pattern matching, and tail recursion. 


"■ BILL WAG N E R This section has not changed since the first version of the C# spec. 
Obviously, the language has grown and added new idioms—and yet C# is still an 
approachable language. These advanced features are always within reach, but not 
always required for every program. C# is still approachable for inexperienced devel¬ 
opers even as it grows more and more powerful. 


2 


www.it-ebooks.info 














1.1 Hello, World 


1.1 Hello, World 


The "Hello, World" program is traditionally used to introduce a programming language. 
Here it is in C#: 



using System; 

class Hello 
{ 

static void Main() { 

Console.WriteLine("Hello, World"); 

} 

} 


C# source files t 5 ^ically have the file exfension .cs. Assuming fhaf fhe "Hello, World" 
program is sfored in fhe file hello. cs, fhe program can be compiled wifh fhe Microsoff C# 
compiler using fhe command line 


CSC hello.cs 


which produces an execufable assembly named hello. exe. The oufpuf produced by fhis 
application when if is run is 

Hello, World 

The "Hello, World" program sfarfs wifh a using directive fhaf references fhe System 
namespace. Namespaces provide a hierarchical means of organizing C# programs and 
libraries. Namespaces confain fypes and ofher namespaces—for example, fhe System 
namespace confains a number of f 5 ^es, such as fhe Console class referenced in fhe pro¬ 
gram, and a number of ofher namespaces, such as 10 and Collections. A using directive 
fhaf references a given namespace enables unqualified use of fhe fypes fhaf are members 
of fhaf namespace. Because of fhe using directive, fhe program can use Console. WriteLine 
as shorfhand for System.Console.WriteLine. 

The Hello class declared by fhe "Hello, World" program has a single member, fhe mefhod 
named Main. The Main mefhod is declared wifh fhe static modifier. While insfance mefh- 
ods can reference a parficular enclosing objecf insfance using fhe keyword this, sfafic 
mefhods operafe wifhouf reference fo a parficular objecf. By convenfion, a sfafic mefhod 
named Main serves as fhe enfry poinf of a program. 

The oufpuf of fhe program is produced by fhe WriteLine mefhod of fhe Console class in 
fhe System namespace. This class is provided by fhe .NET Framework class libraries, which, 
by defaulf, are aufomafically referenced by fhe Microsoff C# compiler. Nofe fhaf C# ifself 
does nof have a separafe runfime library. Insfead, fhe .NET Framework is fhe runfime 
library of C#. 


3 


www.it-ebooks.info 


Introduction 




Introduction 


1. Introduction 



■■ BRAD ABRAMS It is interesting to note that Console.WriteLine() is simply a 
shortcut for Console. Out. WriteLine. Console. Out is a property that returns an imple¬ 
mentation of fhe System. 10.TextWriter base class designed to output to the console. 
The preceding example could be written equally correctly as follows: 

using System; 
class Hello 
{ 

static void Main() { 

Console.Out.WriteLine("Helloj World"); 

} 

} 

Early in the design of the framework, we kepf a careful eye on exactly how this section 
of the C# language specification would have to be written as a bellwether of fhe com¬ 
plexity of the language. We opted to add the convenience overload on Console to 
make "Hello, World" that much easier to write. By all accounts, it seems to have paid 
off. In fact, today you find almosf no calls to Console.Out .WriteLine(). 


1.2 Program Structure 

The key organizational concepts in C# are programs, namespaces, types, members, and 
assemblies. C# programs consist of one or more source files. Programs declare f 5 q)es, which 
contain members and can be organized into namespaces. Classes and interfaces are exam¬ 
ples of types. Fields, methods, properties, and events are examples of members. When C# 
programs are compiled, fhey are physically packaged into assemblies. Assemblies typi¬ 
cally have the file extension . exe or .dll, depending on whether they implement applica¬ 
tions or libraries. 

The example 
using System; 

namespace Acme.Collections 
{ 

public class Stack 
{ 

Entry top; 

public void Push(object data) { 
top = new Entry(top, data); 

} 

public object Pop() { 

if (top == null) throw new InvalidOperatlonException(); 
object result = top.data; 


4 


www.it-ebooks.info 






1.2 Program Structure 


top = top.next; 
return result; 

} 

class Entry 
{ 

public Entry next; 
public object data; 

public Entry(Entry next, object data) { 
this.next = next; 
this.data = data; 

} 

} 

} 

} 

declares a class named Stack in a namespace called Acme. Collections. The fully qualified 
name of fhis class is Acme.Collections. Stack. The class confains several members: a field 
named top, fwo mefhods named Push and Pop, and a nesfed class named Entry. The Entry 
class furfher confains fhree members: a field named next, a field named data, and a con¬ 
structor. Assuming that the source code of the example is stored in the file acme, cs, the 
command line 

CSC /t:library acme.cs 

compiles the example as a library (code without a Main entry point) and produces an 
assembly named acme.dll. 

Assemblies contain executable code in the form of Intermediate Language (IT) instructions, 
and symbolic information in the form of metadata. Before it is executed, the IT code in an 
assembly is automatically converted to processor-specific code by the Just-In-Time (JIT) 
compiler of .NET Common Language Rimtime. 

Because an assembly is a self-describing unit of functionality containing both code and 
metadata, there is no need for #include directives and header files in C#. The public types 
and members contained in a particular assembly are made available in a C# program sim¬ 
ply by referencing that assembly when compiling the program. For example, this program 
uses the Acme.Collections.Stack class from the acme.dll assembly: 

using System; 

using Acme.Collections; 

class Test 
{ 

static void Main() { 

Stack s = new Stack(); 
s.Push(l); 
s.Push(10); 
s.Push(100); 


5 


www.it-ebooks.info 


Introduction 




Introduction 


1. Introduction 


Console.WriteLine(s.Pop()); 
Console.WriteLine(s.Pop()); 
Console.WriteLine(s.Pop()); 

} 

} 


If the program is stored in the file test. cs, when test. cs is compiled, the acme .dll assem¬ 
bly can be referenced using the compiler's /r option: 


/rracme.dll test.cs 


This creates an executable assembly named test. exe, which, when run, produces the fol¬ 
lowing output: 


100 

10 

1 


C# permits the source text of a program to be stored in several source files. When a multi¬ 
file C# program is compiled, all of the source files are processed together, and the source 
files can freely reference one another—conceptually, it is as if all the source files were con¬ 
catenated into one large file before being processed. Forward declarations are never needed 
in C# because, with very few exceptions, declaration order is insignificant. C# does not 
limit a source file to declaring only one public t 5 ^e nor does it require the name of the 
source file to match a t 5 q)e declared in the source file. 


“■ ERIC LIPPERT This is unlike the Java language. Also, the fact that the declaration 
order is insignificant in C# is unlike the C++ language. 


“■ CHRIS SELLS Notice in the previous example the using Acme.Collections 
statement, which looks like a C-style #include directive, but isn't. Instead, it's merely 
a naming convenience so that when the compiler encounters the Stack, it has a set of 
namespaces in which to look for the class. The compiler would take the same action if 
this example used the fully qualified name: 

Acme.Collections.stack s = new Acme.Collections.Stack(); 


1.3 Types and Variables 

There are two kinds of types in C#: value types and reference types. Variables of value 
types directly contain their data, whereas variables of reference types store references to 
their data, the latter being known as objects. With reference types, it is possible for two 


6 


www.it-ebooks.info 








1.3 Types and Variables 


variables to reference the same object and, therefore, possible for operations on one vari¬ 
able to affect the object referenced by the other variable. With value types, the variables 
each have their own copy of the data, and it is not possible for operations on one to affect 
the other (except in the case of ref and out parameter variables). 



■■ JON SKEET The choice of the word "reference" for reference t5q3es is perhaps 
unfortunate. It has led to huge amounts of confusion (or at least miscommunication) 
when considering the difference between pass-by-reference and pass-by-value seman¬ 
tics for parameter passing. 

The difference between value t 5 ^es and reference tjqjes is possibly the most important 
point to teach C# beginners: Until that point is understood, almost nothing else makes 
sense. 


“■ ERIC LIPPERT Probably the most common misconception about value t 5 ^es is 
that they are "stored on the stack," whereas reference t 5 ^es are "stored on the heap." 
First, that behavior is an implementation detail of the runtime, not a fact about the 
language. Second, it explains nothing to the novice. Third, it's false: Yes, the data asso¬ 
ciated with an instance of a reference type is stored on the heap, but that data can 
include instances of value t 5 ^es and, therefore, value t 5 ^es are also stored on the heap 
sometimes. Fourth, if the difference between value and reference t 5 ^es was their stor¬ 
age details, then the CLR team would have called them "stack types" and "heap 
types." The real difference is that value t5q3es are copied by value, and reference t 5 ^es 
are copied by reference; how the runtime allocates storage to implement the lifetime 
rules is not important in the vast majority of mainline programming scenarios. 


“■ BILL WAGN ER C# forces you to make the important decision of value semantics 
versus reference semantics for your t 5 ^es. Developers using your type do not get to 
make that decision on each usage (as they do in C++). You need to think about the 
usage patterns for your types and make a careful decision between these two kinds of 
types. 


"■ VLADIMIR RESHETNIKOV C# also supports unsafe pointer t 5 ^es, which are 
described at the end of this specification. They are called "unsafe" because their neg¬ 
ligent use can break the type safety in a way that carmot be caught by the compiler. 


7 


www.it-ebooks.info 


Introduction 












Introduction 


1. Introduction 


C#'s value types are further divided into simple types, enum types, struct types, and nul¬ 
lable types. C#'s reference f 5 ^es are furfher divided info class types, interface types, array 
types, and delegate types. 

The following fable provides an overview of C#'s type system. 


Category 

Description 

Value 

types 

Simple types 

Signed integral: sbyte, short, int, long 


Unsigned integral: byte, ushort, uint, ulong 



Unicode characters: char 



IEEE floating point: float, double 



High-precision decimal: decimal 



Boolean: bool 


Enum types 

User-defined types of the form enum E { ... } 


Struct types 

User-defined types of the form struct S { ... } 


Nullable types 

Extensions of all other value types with a null value 

Reference 

types 

Class types 

Ultimate base class of all other types: object 


Unicode strings: string 



User-defined types of the form classCf...} 


Interface types 

User-defined types of the form interface I { ... } 


Array types 

Single- and multi-dimensional; for example, int [ ] and 
int[,] 


Delegate types 

User-defined types of the form e.g. delegate int 

D(...) 


The eight integral t 5 ^es provide support for 8-bif, 16-bif, 32-bif, and 64-bif values in signed 
or unsigned form. 


8 


www.it-ebooks.info 






















1.3 Types and Variables 


"■ JON SKEET Hooray for byte being an unsigned t 5 ^e! The fact that in Java a byte 
is signed (and with no unsigned equivalent) makes a lot of bit-twiddling pointlessly 
error-prone. 

It's quite possible that we should all be using uint a lot more than we do, mind you: 
Tm sure many developers reach for int by default when they want an integer t 5 q)e. 
The framework designers also fall into this category, of course: Why should 
String. Length be signed? 



“■ ERIC LIPPERT The answer to Jon's question is that the framework is designed to 
work well with the Common Language Specification (CLS). The CLS defines a set of 
basic language features that all CLS-compliant languages are expected to be able to 
consume; unsigned integers are not in the CLS subset. 


The two floating point types, float and double, are represented using the 32-bit single¬ 
precision and 64-bit double-precision IEEE 754 formats. 

The decimal type is a 128-bit data type suitable for financial and monetary calculations. 


■■ jON SKEET These two paragraphs imply that decimal isn't a floating point t 5 q)e. 
It is—it's just a floating decimal point 1 )^) 0 , whereas float and double are floating 
binary point types. 


C#'s bool t 5 q)e is used to represent boolean values—^values that are either true or false. 

Character and string processing in C# uses Unicode encoding. The char type represents a 
UTE-16 code unit, and the string type represents a sequence of UTE-16 code units. 

The following table summarizes C#'s numeric types. 


Category 

Bits 

Type 

Range/Precision 

Signed 

integral 

8 

sbyte 

-128...127 

16 

short 

-32,768...32,767 

32 

int 

-2,147,483,648...2,147,483,647 

64 

long 

-9,223,372,036,854,775,808.. .9,223,372,036,854,775,807 


Continued 


9 


www.it-ebooks.info 


Introduction 


















Introduction 


1. Introduction 


Category 

Bits 

Type 

Range/Precision 

Unsigned 

integral 

8 

byte 

0...255 

16 

ushort 

0...65,535 

32 

uint 

0...4,294,967,295 

64 

ulong 

0...18,446,744,073,709,551,615 

Floating 

point 

32 

float 

1.5 X 10"'‘® to 3.4 X 10^®, 7-digit precision 

64 

double 

5.0 X 10“^^^ to 1.7 X 10™, 15-digit precision 

Decimal 

128 

decimal 

1.0 X 10"^® to 7.9 X 10^®, 28-digit precision 


"■ CH RISTIAN NAGEL One of the problems we had with C++ on different platforms 
is that the standard doesn't define the number of bits used with short, int, and long. 
The standard defines only short <= int <= long, which results in different sizes on 
16-, 32-, and 64-bit platforms. With C#, the length of numeric types is clearly defined, 
no matter which platform is used. 


C# programs use type declarations to create new types. A t 5 ^e declaration specifies the 
name and the members of the new t 5 ^e. Five of C#'s categories of types are user-definable: 
class types, struct t 5 ^es, interface types, enum types, and delegate t 5 ^es. 

A class type defines a data structure that contains data members (fields) and function 
members (methods, properties, and others). Class types support single inheritance and 
polymorphism, mechanisms whereby derived classes can extend and specialize base 
classes. 


“■ ERIC LIPPERT Choosing to support single rather than multiple inheritance on 
classes eliminates in one stroke many of the complicated comer cases found in mul¬ 
tiple inheritance languages. 


A struct t 5 ^e is similar to a class t 5 ^e in that it represents a structure with data members 
and fimction members. However, unlike classes, structs are value types and do not require 
heap allocation. Struct types do not support user-specified inheritance, and all struct t 5 q)es 
implicitly inherit from type object. 


10 


www.it-ebooks.info 



















1.3 Types and Variables 


“■ VLADIMIR RESHETNIKOV Structs inherit from object indirectly. Their implicit 
direct base class is System. ValueType, which in turn directly inherits from object. 



An interface t 5 ^e defines a contract as a named set of public function members. A class or 
struct that implements an interface must provide implementations of the interface's func¬ 
tion members. An interface may inherit from multiple base interfaces, and a class or struct 
may implement multiple interfaces. 


A delegate type represents references to methods with a particular parameter list and 
return type. Delegates make it possible to treat methods as entities that can be assigned to 
variables and passed as parameters. Delegates are similar to the concept of function point¬ 
ers found in some other languages, but unlike fimction pointers, delegates are object-ori¬ 
ented and type-safe. 


Class, struct, interface, and delegate types all support generics, whereby they can be 
parameterized with other types. 


An enum t 5 ^e is a distinct t 5 ^e with named constants. Every enum t 5 ^e has an underlying 
type, which must be one of the eight integral t 5 ^es. The set of values of an enum t 5 ^e is the 
same as the set of values of the underlying type. 


"■ VLADIMIR RESHETNIKOV Enum t 5 ^es cannot have type parameters in their 
declarations. Even so, they can be generic if nested within a generic class or struct 
type. Moreover, C# supports pointers to generic enum t 5 ^es in unsafe code. 

Sometimes enum t 5 ^es are called "enumeration types" in this specification. These two 
names are completely interchangeable. 


C# supports single- and multi-dimensional arrays of any type. Unlike the types listed 
above, array t 5 ^es do not have to be declared before they can be used. Instead, array t 5 ^es 
are constructed by following a t 5 ^e name with square brackets. Eor example, int[ ] is a 
single-dimensional array of int, int [, ] is a two-dimensional array of int, and int [ ] [ ] is 
a single-dimensional array of single-dimensional arrays of int. 

Nullable t 5 q)es also do not have to be declared before they can be used. Eor each non-nullable 
value t 5 q)e T there is a corresponding nullable type T?, which can hold an additional value 
null. Eor instance, int? is a type that can hold any 32 bit integer or the value null. 


"■ CHRISTIAN NAGEL T? is the C# shorthand notation for the Nullable<T> 
structure. 


11 


www.it-ebooks.info 


Introduction 










Introduction 


1. Introduction 



■■ ERICLIPPERT In C# 1.0, we had nullable reference t 5 ^es and non-nullable value 
types. In C# 2.0, we added nullable value types. But there are no non-nullable refer¬ 
ence t 5 ^es. If we had to do it all over again, we probably would bake nullability and 
non-nullability into the type system from day one. Unfortunately, non-nullable refer¬ 
ence t 5 ^es are difficult to add to an existing t 5 ^e system that wasn't designed for 
them. We get feature requests for non-nullable reference types all the time; it would be 
a great feature. However, code contracts go a long way toward solving the problems 
solved by non-nullable reference types; consider using them if you want to enforce 
non-nullability in your programs. If this subject interests you, you might also want to 
check out Spec#, a Microsoft Research version of C# that does support non-nullable 
reference t 5 q)es. 


C#'s type system is unified such that a value of any type can be treated as an object. Every 
type in C# directly or indirectly derives from the object class type, and object is the ulti¬ 
mate base class of all t 5 q)es. Values of reference types are treated as objects simply by view¬ 
ing the values as type object. Values of value types are treated as objects by performing 
boxing and unboxing operations. In the following example, an int value is converted to 
object and back again to int. 

using System; 

class Test 
{ 

static void Main() { 
int i = 123; 
object o = i; 
int j = (int)o; 

} 

} 

When a value of a value type is converted to type object, an object instance, also called 
a "box," is allocated to hold the value, and the value is copied into that box. Conversely, 
when an object reference is cast to a value type, a check is made that the referenced 
object is a box of the correct value type, and, if the check succeeds, the value in the box is 
copied out. 

C#'s unified type system effectively means that value types can become objects "on 
demand." Because of the unification, general-purpose libraries that use type object can be 
used with both reference tjqies and value types. 

There are several kinds of variables in C#, including fields, array elements, local variables, 
and parameters. Variables represent storage locations, and every variable has a type that 
determines what values can be stored in the variable, as shown by the following table. 


// Boxing 
// Unboxing 


12 


www.it-ebooks.info 






1.4 Expressions 


Type of Variable 

Possible Contents 

Non-nullable value 
type 

A value of that exact type 

Nullable value type 

A null value or a value of that exact type 

object 

A null reference, a reference to an object of any reference type, or a 
reference to a boxed value of any value type 

Class type 

A null reference, a reference to an instance of that class type, or a 
reference to an instance of a class derived from that class type 

Interface type 

A null reference, a reference to an instance of a class type that 
implements that interface type, or a reference to a boxed value of 
a value type that implements that interface type 

Array type 

A null reference, a reference to an instance of that array type, or a 
reference to an instance of a compatible array type 

Delegate type 

A null reference or a reference to an instance of that delegate type 


1.4 Expressions 

Expressions are constructed from operands and operators. The operators of an expression 
indicafe which operafions fo apply fo fhe operands. Examples of operafors include +, *, 

/, and new. Examples of operands include liferals, fields, local variables, and expressions. 

When an expression confains mulfiple operafors, fhe precedence of fhe operafors confrols 
fhe order in which fhe individual operafors are evaluafed. Eor example, fhe expression x + 
y * z is evaluafed as x + (y * z) because fhe * operafor has higher precedence fhan fhe + 
operafor. 


“■ ERIC LI PPERT Precedence confrols fhe order in which fhe operafors are execufed, 
buf nof fhe order in which fhe operands are evaluafed. Operands are evaluafed from leff 
fo righf, period. In fhe preceding example, x would be evaluafed, fhen y, fhen z, fhen fhe 
mulfiplicafion would be performed, and fhen fhe addition. The evaluafion of operand x 
happens before fhaf of y because x is fo fhe leff of y; fhe evaluafion of fhe mulfiplicafion 
happens before fhe addition because fhe mulfiplicafion has higher precedence. 


Mosf operafors can be overloaded. Operafor overloading permifs user-defined operafor 
implemenfafions fo be specified for operafions where one or bofh of fhe operands are of a 
user-defined class or sfrucf type. 

13 


www.it-ebooks.info 


Introduction 















Introduction 


1. Introduction 


The following table summarizes C#'s operators, listing the operator categories in order of 
precedence from highest to lowest. Operators in the same category have equal 
precedence. 


Category 

Expression 

Description 

Primary 

X. m 

Member access 


x(...) 

Method and delegate invocation 


x[...] 

Array and indexer access 


X++ 

Post-increment 


X- - 

Post-decrement 


new T(...) 

Object and delegate creation 


new T(. 

Object creation with initializer 


new {...} 

Anonymous object initializer 


new T[...] 

Array creation 


typeof(T) 

Obtain System .Type object for T 


checked(x) 

Evaluate expression in checked context 


unchecked(x) 

Evaluate expression in unchecked context 


default(T) 

Obtain default value of type T 


delegate {...} 

Anonymous function (anonymous method) 

Unary 

+x 

Identity 


-X 

Negation 


!x 

Logical negation 


'^x 

Bitwise negation 


++X 

Pre-increment 


- -X 

Pre-decrement 


(T)x 

Explicitly convert x to type T 


14 


www.it-ebooks.info 




























1.4 Expressions 


Category 

Expression 

Description 

Multiplicative 

X * y 

Multiplication 

X / y 

Division 

X % y 

Remainder 

Additive 

X + y 

Addition, string concatenation, delegate 
combination 

X - y 

Subtraction, delegate removal 

Shift 

> 

V 

V 

X 

Shift left 

X 

V 

V 

Shift right 

Relational and type 
testing 

X < y 

Less than 

X > y 

Greater than 

X <= y 

Less than or equal 

X >= y 

Greater than or equal 

X is T 

Return true if x is a T, false otherwise 

X as T 

Return x typed as T, or null if x is not a T 

Equality 

X == y 

Equal 

X ! = y 

Not equal 

Logical AND 

X & y 

Integer bitwise AND, boolean logical AND 

Logical XOR 

X y 

Integer bitwise XOR, boolean logical XOR 

Logical OR 

X 1 y 

Integer bitwise OR, boolean logical OR 

Conditional AND 

X && y 

Evaluates y only if x is true 

Conditional OR 

X II y 

Evaluates y only if x is false 

Null coalescing 

X ?? y 

Evaluates to y if x is null, to x otherwise 

Conditional 

X ? y : z 

Evaluates y if x is true, z if x is false 


Continued 


15 


www.it-ebooks.info 


Introduction 





























Introduction 


1. Introduction 


Category 

Expression 

Description 

Assignment or 

anonymous 

function 

x = y 

Assignment 

x op= y 

Compound assignment; supported operators are 
*= /= %= += -= <<= >>= &= 1 = 

(T X) => y 

Anonymous function (lambda expression) 


■■ ERICLIPPERT It is often surprising to people that the lambda and anonymous 
method S 5 mtaxes are described as operators. They are unusual operators. More typi¬ 
cally, you think of an operator as faking expressions as operands, nof declarafions of 
formal paramefers. S 5 mfacfically, however, fhe lambda and anonymous mefhod S 5 m- 
faxes are operators like any ofher. 


1.5 Statements 

The acfions of a program are expressed using statements. C# supporfs several kinds of 
sfafemenfs, a number of which are defined in terms of embedded sfafemenfs. 

A block permifs mulfiple sfafemenfs fo be wriffen in confexfs where a single sfafemenf is 
allowed. A block consisfs of a lisf of sfafemenfs wriffen befween fhe delimiters { and }. 

Declaration statements are used fo declare local variables and consfanfs. 

Expression statements are used fo evaluafe expressions. Expressions fhaf can be used as 
sfafemenfs include mefhod invocations, objecf allocafions using fhe new operafor, assign- 
menfs using = and fhe compound assignmenf operafors, and incremenf and decremenf 
operafions using fhe ++ and - - operafors. 

Selection statements are used fo selecf one of a number of possible sfafemenfs for 
execution based on fhe value of some expression. In fhis group are fhe if and switch 
sfafemenfs. 

Iteration statements are used fo repeafedly execute an embedded sfafemenf. In fhis group 
are fhe while, do, for, and foreach sfafemenfs. 

Jump statements are used fo fransfer confrol. In fhis group are fhe break, continue, goto, 
throw, return, and yield sfafemenfs. 


16 


www.it-ebooks.info 












1.5 Statements 


The try...catch statement is used to catch exceptions that occur during execution of a 
block, and the try...finally statement is used to specify finalization code that is always 
executed, whether an exception occurred or not. 



■■ ERICLIPPERT This is a bit of a fib; of course, a finally block does not always 
execute. The code in the try block could go into an infinite loop, the exception could 
trigger a "fail fast" (which takes the process down without running any finally 
blocks), or someone could pull the power cord out of the wall. 


The checked and unchecked statements are used to control the overflow checking context 
for integral-type arithmetic operations and conversions. 


The lock statement is used to obtain the mutual-exclusion lock for a given object, execute 
a statement, and then release the lock. 


The using statement is used to obtain a resource, execute a statement, and then dispose of 
that resource. 


The following table lists C#'s statements and provides an example for each one. 


statement 

Example 

Local variable 
declaration 

static void Main() { 
int a; 

int b = 2j c = 3; 
a = 1; 

Console.WriteLine(a + b + c); 

} 

Local constant 
declaration 

static void Main() { 

const float pi = 3.1415927f; 
const int r = 25; 

Console.WriteLine(pi * r * r); 

} 

Expression 

statement 

static void Main() { 
int i; 

1 = 123; // Expression statement 

Console.WriteLine(i); // Expression statement 

1++; // Expression statement 

Console.WriteLine(i); // Expression statement 

} 


Continued 


17 


www.it-ebooks.info 


Introduction 











Introduction 


1. Introduction 


statement 

Example 

if statement 

static void Main(string[] args) { 
if (args.Length == 0) { 

Console.WriteLine("No arguments"); 

} 

else { 

Console.WriteLine("One or more arguments")j 

} 

} 

switch statement 

static void Main(string[] args) { 
int n = args.Length; 
switch (n) { 
case 0: 

Console.WriteLine("No arguments"); 
break; 
case 1: 

Console.WriteLine("One argument"); 
break; 
default: 

Console.WriteLine("{0} arguments''^ n); 
break; 

} 

} 

} 

while statement 

static void Main(string[] args) { 
int i = 0; 

while (i < args.Length) { 

Console.WriteLine(args[i]); 
i++; 

} 

} 

do statement 

static void Main() { 
string s; 
do { 

s = Console.ReadLine(); 

if (s != null) Console.WriteLine(s); 

} while (s != null); 

} 


18 


www.it-ebooks.info 










1.5 Statements 


statement 

Example 

for statement 

static void Main(strlng[] args) { 

for (int i = 0; i < args.Length; i++) { 

Console.WriteLine(args[i])j 

} 

} 

foreach 

statement 

static void Main(strlng[] args) { 
foreach (string s in args) { 

Console.WriteLine(s)j 

} 

} 

break statement 

static void Main() { 
while (true) { 

string s = Console.ReadLine()j 
if (s == null) break; 

Console.WriteLine(s); 

} 

} 

continue 

statement 

static void Main(strlng[] args) { 

for (int i = 0; 1 < args.Length; i++) { 
if (args[i].StartsWith("/")) continue; 

Console.WriteLine(args[i]); 

} 

} 

goto statement 

static void Main(strlng[] args) { 
int i = 0; 
goto check; 
loop: 

Console.WriteLine(args[i++]); 
check: 

if (i < args.Length) goto loop; 

} 

return statement 

static int Add(int aj int b) { 
return a + b; 

} 

static void Main() { 

Console.WriteLine(Add(lj 2)); 
return; 

} 


Continued 


19 


www.it-ebooks.info 


Introduction 












Introduction 


1. Introduction 


statement 

Example 

yield statement 

static IEnumerable<int> Range(int frotHj int to) { 
for (int i = from; i < to; i++) { 
yield return i; 

} 

yield break; 

} 

static void Main() { 

foreach (int x in Range(-10j10) ) { 

Console.WriteLine(x); 

} 

} 

throw and try 
statements 

static double Divide(double x, double y) { 

if (y == 0) throw new DivideByZeroException(); 
return x / y; 

} 

static void Main(string[] args) { 
try { 

if (args.Length != 2) { 

throw new Exception("Two numbers required"); 

} 

double X = double.Parse(args[0]); 
double y = double.Parse(args[l]); 

Console.WriteLine(Divide(Xj y)); 

} 

catch (Exception e) { 

Console.WriteLine(e.Message); 

} 

finally { 

Console.WriteLine(“Good bye!”); 

} 

} 

checked and 
unchecked 

statements 

static void Main() { 

int i = int.MaxValue; 
checked { 

Console.WriteLine(i + 1); // Exception 

} 

unchecked { 

Console.WriteLine(i + 1); // Overflow 

} 

} 


20 


www.it-ebooks.info 









1.6 Classes and Objects 


statement 

Example 

lock statement 

class Account 

{ 

decimal balance; 

public void Withdraw(decimal amount) { 
lock (this) { 

if (amount > balance) { 

throw new Exception("Insufficient funds"); 

} 

balance -= amount; 

} 

} 

} 

using statement 

static void Main() { 

using (TextWriter w = File.CreateText("test.txt")) { 
w.WriteLine("Line one"); 
w.WriteLine("Line two"); 
w.WriteLine("Line three"); 

} 

} 


1.6 Classes and Objects 

Classes are the most fundamental of C#'s t 5 ^es. A class is a data structure that combines 
state (fields) and actions (methods and other function members) in a single unit. A class 
provides a definition for dynamically created instances of the class, also known as objects. 
Classes support inheritance and polymorphism, mechanisms whereby derived classes can 
extend and specialize base classes. 

New classes are created using class declarations. A class declaration starts with a header 
that specifies the attributes and modifiers of the class, the name of the class, the base class 
(if given), and the interfaces implemented by the class. The header is followed by the 
class body, which consists of a list of member declarations written between the delimit¬ 
ers { and }. 


21 


www.it-ebooks.info 


Introduction 








Introduction 


1. Introduction 


The following is a declaration of a simple class named Point: 

public class Point 
{ 

public int x, y; 

public Point(int x, int y) 

{ 

this.x = x; 
this.y = y; 

} 

} 

Instances of classes are created using the new operator, which allocates memory for a new 
instance, invokes a constructor to initialize the instance, and returns a reference to the 
instance. The following statements create two Point objects and store references to those 
objects in two variables: 

Point pi = new Point(0, 0); 

Point p2 = new Point(10, 20); 

The memory occupied by an object is automatically reclaimed when the object is no longer 
in use. It is neither necessary nor possible to explicitly deallocate objects in C#. 

1.6.1 Members 

The members of a class are either static members or instance members. Static members 
belong to classes, and instance members belong to objects (instances of classes). 


"■ ERIC LI PPERT The term "static" was chosen because of its familiarity to users of 
similar languages, rather than because it is a particularly sensible or descriptive term 
for "shared by all instances of a class." 


■■ jONSKEET I'd argue that "shared" (as used in Visual Basic) gives an incorrect 
impression, too. "Sharing" feels like something that requires one or more participants, 
whereas a static member doesn't require any instances of the t 5 q)e. I have the perfect 
term for this situation, but it's too late to change "static" to "associated-with-the-type- 
rather-than-with-any-specific-instance-of-the-type" (h5q3hens optional). 


The following table provides an overview of the kinds of members a class can contain. 


22 


www.it-ebooks.info 








1.6 Classes and Objects 


Member 

Description 

Constants 

Constant values associated with the class 

Fields 

Variables of the class 

Methods 

Computations and actions that can be performed by the class 

Properties 

Actions associated with reading and writing named properties of the class 

Indexers 

Actions associated with indexing instances of the class like an array 

Events 

Notifications that can be generated by the class 

Operators 

Conversions and expression operators supported by the class 

Constructors 

Actions required to initialize instances of the class or the class itself 

Destructors 

Actions to perform before instances of the class are permanently discarded 

Types 

Nested types declared by the class 


1.6.2 Accessibility 

Each member of a class has an associated accessibility, which controls the regions of pro¬ 
gram text that are able to access the member. The five possible forms of accessibility are 
summarized in the following table. 


Accessibility 

Meaning 

public 

Access not limited 

protected 

Access limited to this class or classes derived from this class 

internal 

Access limited to this program 

protected internal 

Access limited to this program or classes derived from this class 

private 

Access limited to this class 


"■ KRZYSZTOF CWALINA People need to be careful with the public keyword, 
public in C# is not equivalent to public in C++! In C++, it means "internal to my 
compilation unit." In C#, it means what extern meant in C++ (i.e., everybody can 
call it). This is a huge difference! 


www.it-ebooks.info 


Introduction 

























Introduction 


1. Introduction 


“■ CHRISTIAN NAGEL I would describe the internal access modifier as "access lim¬ 
ited to this assembly" instead of "access limifed fo fhis program." If fhe infernal access 
modifier is used wifhin a DLL, fhe EXE referencing fhe DLL does nof have access fo if. 



■■ ERICLIPPERT protected internal has proven fo be a confroversial and some- 
whaf unforfunafe choice. Many people using fhis feafure incorrecfly believe fhaf 
protected internal means "access is limifed fo derived classes wifhin fhis pro¬ 
gram." Thaf is, fhey believe if means fhe more resfricfive combinafion, when in facf if 
means fhe less resfricfive combinafion. The way fo remember fhis relafionship is fo 
remember fhaf fhe "nafural" sfafe of a member is "privafe" and every accessibilify 
modifier makes fhe accessibilify domain larger. 

Were a h 5 ^ofhefical fufure version of fhe C# language fo provide a synfax for "fhe 
more resfricfive combinafion of profecfed and infernal," fhe quesfion would fhen be 
which combinafion of ke 5 rwords would have fhaf meaning. I am holding ouf for eifher 
"profemal" or "infecfed," buf I suspecf I will have fo live wifh disappoinfmenf. 


“■ CHRISTIAN NAGEL C#defines protected internal fo limif access fo fhis assem¬ 
bly or classes derived from fhis class. The CLR also allows limifing access fo fhis 
assembly and classes derived from fhis class. C++/CLI offers fhis CLR feafure wifh fhe 
public private access modifier (or private public —fhe order is nof relevanf). Real- 
isfically fhis access modifier is rarely used. 


1.6.3 Type Parameters 

A class definition may specify a set of type parameters by following the class name with 
angle brackets enclosing a list of type parameter names. The type parameters can then be 
used in the body of the class declarations to define the members of the class. In the follow¬ 
ing example, the type parameters of Pair are TFirst and TSecond: 

public class PaircTFirst, TSecond> 

{ 

public TFirst First; 
public TSecond Second; 

} 

A class type that is declared to take type parameters is called a generic class t 5 q)e. Struct, 
interface, and delegate types can also be generic. 


24 


www.it-ebooks.info 










1.6 Classes and Objects 


"■ ERIC LIPPERT If you need a pair, triple, and so on, the generic "tuple" t 5 ^es 
defined in the CLR 4 version of the framework are handy t 5 ^es. 



When the generic class is used, type arguments must be provided for each of the type 
parameters: 

Pair<int,string> pair = new Pair<int,string> { First = 1, Second = "two" }; 
int i = pair.First; // TFirst is int 
string s = pair.Second; // TSecond is string 

A generic type with type arguments provided, like Pair<int, string> above, is called a 
constructed t 5 ^e. 


1.6.4 Base Classes 

A class declaration may specify a base class by following the class name and type param¬ 
eters with a colon and the name of the base class. Omitting a base class specification is the 
same as deriving from type object. In the following example, the base class of PointBD is 
Point, and the base class of Point is object: 

public class Point 
{ 

public int x, y; 

public Point(int x, int y) 

{ 

this.x = x; 
this.y = y; 

} 

} 

public class PointSD : Point 
{ 

public int z; 

public Point3D(int x, int y, int z): base(x, y) 

{ 

this.z = z; 

} 

} 

A class inherits the members of its base class. Inheritance means that a class implicitly con¬ 
tains all members of its base class, except for the instance and static constructors, and the 
destructors of the base class. A derived class can add new members to those it inherits, but 
it carmot remove the definition of an inherited member. In the previous example, PointBD 


25 


www.it-ebooks.info 


Introduction 






Introduction 


1. Introduction 


inherits the x and y fields from Point, and every PointBD insfance confains fhree fields, x, 
y, and z. 



"■ JESSE LIBERTY There is nothing more important to understand about C# than 
inheritance and polymorphism. These concepts are the heart of the language and the 
soul of object-oriented programming. Read this section until it makes sense, or ask for 
help or supplement it with additional reading, but do not skip over it—these issues 
are the sine qua non of C#. 


An implicit conversion exists from a class type to any of its base class types. Therefore, a 
variable of a class t 5 q)e can reference an instance of that class or an instance of any derived 
class. For example, given the previous class declarations, a variable of type Point can refer¬ 
ence either a Point or a PointBD: 


Point a = new Point(10, 20); 

Point b = new Point3D(10, 20, 30); 


1.6.5 Fields 

A field is a variable that is associated with a class or with an instance of a class. 

A field declared with the static modifier defines a static field. A static field identifies 
exactly one storage location. No matter how many instances of a class are created, there is 
only ever one copy of a static field. 


“■ ERIC LIPPERT Sfatic fields are per constructed t 5 q)e for a generic t 5 q)e. Thaf is, if 
you have a 

class Stacl«T> { 

public readonly static Stacl«T> empty = whatever; ... 

} 

then Stacl«int>.empty is a different field than Stacl«string>.empty. 


A field declared without the static modifier defines an instance field. Every instance of a 
class contains a separate copy of all fhe insfance fields of fhaf class. 

In fhe following example, each insfance of the Color class has a separate copy of fhe r, g, 
and b instance fields, buf there is only one copy of fhe Black, White, Red, Green, and Blue 
sfafic fields: 


26 


www.it-ebooks.info 








1.6 Classes and Objects 


public class Color 

{ 

public static readonly Color 
public static readonly Color 
public static readonly Color 
public static readonly Color 
public static readonly Color 

private byte r, g, b; 

public Color(byte r, byte g, 

{ 

this.r = r; 
this.g = g; 
this.b = b; 

} 

} 


Black = new Color(0, 0); 

White = new Color(255, 255, 255); 
Red = new Color(255, 0, 0); 

Green = new Color(0, 255, 0); 

Blue = new Color(0, 0, 255); 


byte b) 



As shown in the previous example, read-only fields may be declared with a readonly 
modifier. Assignment to a readonly field can occur only as part of the field's declaration or 
in a constructor in the same class. 


BRAD ABRAMS readonly protects the location of the field from being changed 
outside the type's constructor, but does not protect the value at that location. For 
example, consider the following type: 

public class Names 

{ 

public static readonly StringBullder FirstBorn = new StringBullder("Doe"); 
public static readonly StringBullder SecondBorn = new StringBuilder("Sue"); 

} 

Outside of the constructor, directly changing the FirstBorn instance results in a com¬ 
piler error: 

Names.FirstBorn = new StringBuilder("Biff"); 

// Compile error 

However, I am able to accomplish exactly the same results by modifying the 
StringBullder instance: 

Names.FirstBorn.Remove (0,6) .Append("Biff"); 

Console.WriteLine(Names.FirstBorn); // Outputs "Biff" 

It is for this reason that we strongly recommend that read-only fields be limited to 
immutable types. Immutable types do not have any publicly exposed setters, such as 
int, double, or String. 


27 


www.it-ebooks.info 


Introduction 






Introduction 


1. Introduction 


“■ BILL WAGNER Several well-known design patterns make use of the read-only 
fields of mufable fypes. The Adapfer, Decorafor, Fa(;ade, and Proxy pafferns are fhe 
mosf obvious examples. When you are creafing a larger sfrucfure by composing 
smaller sfrucfures, you will often express insfances of fhose smaller strucfures using 
read-only fields. A read-only field of a mufable f 5 ^e should indicafe fhaf one of fhese 
sfrucfural pafferns is being used. 


1.6.6 Methods 

A method is a member that implements a computation or action that can be performed by 
an object or class. Static methods are accessed through the class. Instance methods are 
accessed through instances of the class. 

Methods have a (possibly empty) list of parameters, which represent values or variable 
references passed to the method, and a return type, which specifies the t 5 ^e of the value 
computed and returned by the method. A method's return t 5 ^e is void if it does not return 
a value. 

Like types, methods may also have a set of t 5 ^e parameters, for which type arguments 
must be specified when the method is called. Unlike types, the type arguments can often 
be inferred from the arguments of a method call and need not be explicitly given. 

The signature of a method must be unique in the class in which the method is declared. 
The signature of a method consists of the name of the method, the number of type param¬ 
eters, and the number, modifiers, and t 5 q)es of its parameters. The signature of a method 
does not include the return type. 


■■ ERIC UPPER! An unfortunate consequence of generic t 5 q)es is that a constructed 
type may potentially have two methods with identical signatures. For example, class 
C<T> { void M(T t){} void M(int t){} ...} is perfectly legal, but C<int> has two 
methods M with identical signatures. As we'll see later on, this possibility leads to 
some interesting scenarios involving overload resolution and explicit interface imple¬ 
mentations. A good guideline: Don't create a generic t 5 q)e that can create ambiguities 
under construction in this way; such types are extremely confusing and can produce 
unexpected behaviors. 


28 


www.it-ebooks.info 








1.6 Classes and Objects 


1.6.6.1 Parameters 

Parameters are used to pass values or variable references to methods. The parameters of a 
method get their actual values from the arguments that are specified when the method is 
invoked. There are four kinds of parameters: value parameters, reference parameters, out¬ 
put parameters, and parameter arrays. 



A value parameter is used for input parameter passing. A value parameter corresponds to 
a local variable that gets its initial value from the argument that was passed for the param¬ 
eter. Modifications to a value parameter do not affect the argument that was passed for the 
parameter. 


“■ BILL WAGNER The statement that modifications to value parameters do not 
affect the argument might be misleading because mutator methods may change the 
contents of a parameter of reference t 5 ^e. The value parameter does not change, but 
the contents of the referred-to object do. 


Value parameters can be optional, by specifying a default value so that corresponding 
arguments can be omitted. 

A reference parameter is used for both input and output parameter passing. The argument 
passed for a reference parameter must be a variable, and during execution of the method, 
the reference parameter represents the same storage location as the argument variable. A 
reference parameter is declared with the ref modifier. The following example shows the 
use of ref parameters. 

using System; 

class Test 
{ 

static void Swap(ref int x, ref int y) { 
int temp = x; 

X = y; 
y = temp; 

} 

static void Main() { 
int i = 1, j = 2; 

Swap(ref i, ref j); 

Console.WriteLine("{0} {1}", 1, j); // Outputs "2 1" 

} 

} 


29 


www.it-ebooks.info 


Introduction 






Introduction 


1. Introduction 



“■ ERIC LI PPERT This S 5 mtax should help clear up the confusion between the two 
things both called "passing by reference." Reference t 5 ^es are called this name in C# 
because they are "passed by reference"; you pass an object instance to a method, and 
the method gets a reference to that object instance. Some other code might also be 
holding on to a reference to the same object. 

Reference parameters are a slightly different form of "passing by reference." In this case, 
the reference is to the variable itself, not to some object instance. If that variable happens 
to contain a value t 5 ^e (as shown in the previous example), that's perfectly legal. The 
value is not being passed by reference, but rather the variable that holds it is. 

A good way to think about reference parameters is that the reference parameter 
becomes an alias for the variable passed as the argument. In the preceding example, x 
and i are essentially the same variable. They refer to the same storage location. 


An output parameter is used for output parameter passing. An output parameter is similar 
to a reference parameter except that the initial value of the caller-provided argument is 
unimportant. An output parameter is declared with the out modifier. The following exam¬ 
ple shows the use of out parameters. 

using System; 
class Test 
{ 

static void Divide(int x, int y, out int result, out int remainder) { 
result = X / y; 
remainder = x % y; 

} 

static void Main() { 
int res, rem; 

Divide(10, 3, out res, out rem); 

Console.WriteLine("{0} {1}", res, rem); // Outputs "3 1 " 

} 

} 


"■ ERIC LI PPERT The CLR directly supports only ref parameters. An out param¬ 
eter is represented in metadata as a ref parameter with a special attribute on it indi¬ 
cating to the C# compiler that this ref parameter ought to be treated as an out 
parameter. This explains why it is not legal to have two methods that differ solely in 
"out/ref-ness"; from the CLR's perspective, they would be two identical methods. 


30 


www.it-ebooks.info 








1.6 Classes and Objects 


A parameter array permits a variable number of arguments to be passed to a method. A 
parameter array is declared with the params modifier. Only the last parameter of a method 
can be a parameter array, and the type of a parameter array must be a single-dimensional 
array t 5 ^e. The Write and WriteLine methods of the System.Console class are good exam¬ 
ples of parameter array usage. They are declared as follows. 

public class Console 
{ 

public static void Write(string fmt, params object[] args) {...} 
public static void WriteLine(string fmt, params object[] args) {...} 



Within a method that uses a parameter array, the parameter array behaves exactly like a 
regular parameter of an array type. However, in an invocation of a method with a param¬ 
eter array, it is possible to pass either a single argument of the parameter array type or any 
number of arguments of the element type of the parameter array. In the latter case, an array 
instance is automatically created and initialized with the given arguments. This example 

Console.WriteLine("x={0} y={l} z={2}", x, y, z); 
is equivalent to writing the following. 

string s = "x={0} y={l} z={2}"; 
object[] args = new object[3]; 
args[0] = x; 
args[l] = y; 
args[2] = z; 

Console.WriteLine(s, args); 


"■ BRAD ABRAMS You may recognize the similarity between pa rams and the C pro¬ 
gramming language's varargs concept. In keeping with our goal of making C# very 
simple to understand, the params modifier does not require a special calling conven¬ 
tion or special library support. As such, it has proven to be much less prone to error 
than varargs. 

Note, however, that the C# model does create an extra object allocation (the containing 
array) implicitly on each call. This is rarely a problem, but in irmer-loop t 5 q)e scenarios 
where it could get inefficient, we suggest providing overloads for the mainstream 
cases and using the params overload for only the edge cases. An example is the 
StringBuilder .AppendFormat( ) family of overloads: 

public StringBuilder AppendFormat(string format, object arg0); 

public StringBuilder AppendFormat(string format, object arg0, object argl); 

public StringBuilder AppendFormat(string format, object arg0, object argl, object arg2); 

public StringBuilder AppendFormat(string format, params object[] args); 


31 


www.it-ebooks.info 


Introduction 






Introduction 


1. Introduction 



“■ CHRIS SELLS One nice side effect of the fact that params is really just an optional 
shortcut is that 1 don't have to write something crazy like the following: 

static object[] GetArgs() { ... } 

static void Main() { 

object[] args = GetArgs(); 
object X = args[0]; 
object y = args[l]; 
object z = args[2]; 

Console.WriteLine("x={0} y={l} z={2}", x, y, z); 

} 

Here I'm calling the method and cracking the parameters out just so the compiler can 
create an array around them again. Of course, I should really just write this: 


static object[] GetArgs() { 


} 


static void Main() { 

Console.WriteLine("x={0} y={l} z={2}", GetArgs()); 

} 

However, you'll find fewer and fewer methods that return arrays in .NET these days, 
as most folks prefer using IEnumerable<T > for its flexibility. This means you'll proba¬ 
bly be writing code like so: 


static IEnumerable<object> GetArgs() { 


} 


static void Main() { 

Console.WriteLine("x={0} y={l} z={2}", GetArgs() .ToArrayO); 

} 

It would be handy if params "understood" lEnumenable directly. Maybe next time. 


1.6.6.2 Method Body and Local Variables 

A method's body specifies the statements to execute when the method is invoked. 

A method body can declare variables that are specific to the invocation of the method. Such 
variables are called local variables. A local variable declaration specifies a tj^e name, a 
variable name, and possibly an initial value. The following example declares a local vari¬ 
able i with an initial value of zero and a local variable j with no initial value. 


32 


www.it-ebooks.info 






1.6 Classes and Objects 


using System; 


class Squares 
{ 


static void Main() { 
int i = 0; 
int j; 

while (i < 10) { 
j = i * i; 

Console.WriteLine("{0} x {0} = {1}", 
i = 1 + 1; 


} 


} 


} 


i. j); 


C# requires a local variable to be definitely assigned before its value can be obtained. For 
example, if the declaration of the previous i did not include an initial value, the compiler 
would report an error for the subsequent usages of i because i would not be definitely 
assigned at those points in the program. 

A method can use return statements to return control to its caller. In a method returning 
void, return statements cannot specify an expression. In a method returning non-void, 
return statements must include an expression that computes the return value. 


1.6.6.3 Static and Instance Methods 

A method declared with a static modifier is a static method. A static method does not 
operate on a specific instance and can only directly access static members. 


ERICLIPPERT It is, of course, perfectly legal for a static method to access instance 
members should it happen to have an instance handy. 


A method declared without a static modifier is an instance method. An instance method 
operates on a specific instance and can access both static and instance members. The 
instance on which an instance method was invoked can be explicitly accessed as this. It is 
an error to refer to this in a static method. 

The following Entity class has both static and instance members. 

class Entity 
{ 

static int nextSerialNo; 

int serialNo; 

public EntityO 
{ 


33 


www.it-ebooks.info 


Introduction 






Introduction 


1. Introduction 


serialNo = nextSerialNo++; 

} 

public int GetSerialNo() 

{ 

return serialNo; 

} 

public static int GetNextSerialNo() 

{ 

return nextSerialNo; 

} 

public static void SetNextSerialNo(int value) 

{ 

nextSerialNo = value; 

} 

} 

Each Entity instance contains a serial number (and presumably some other information 
that is not shown here). The Entity constructor (which is like an instance method) initial¬ 
izes the new instance with the next available serial number. Because the constructor is an 
instance member, it is permitted to access both the serialNo instance field and fhe 
nextSerialNo sfafic field. 

The GetNextSerialNo and SetNextSerialNo sfafic mefhods can access fhe nextSerialNo 
sfafic field, buf if would be an error for fhem fo direcfly access fhe serialNo insfance 
field. 

The following example shows fhe use of fhe Entity class. 

using System; 

class Test 

{ 

static void Main() { 

Entity.SetNextSerialNo(1000); 

Entity el = new EntityO; 

Entity e2 = new EntityO; 

Console .WriteLine(el.GetSerialNoO); 

Console.WriteLine(e2.GetSerialNo()); 

Console.WriteLine(Entity.GetNextSerialNo()); 

} 

} 

Nofe fhaf fhe SetNextSerialNo and GetNextSerialNo sfafic mefhods are invoked on fhe 
class, whereas fhe GetSerialNo insfance mefhod is invoked on insfances of fhe class. 


34 


// Outputs "1000" 
// Outputs "1001" 
// Outputs "1002" 


www.it-ebooks.info 




1.6 Classes and Objects 


1.6.6.4 Virtual, Override, and Abstract Methods 

When an instance method declaration includes a virtual modifier, the method is said to 
be a virtual method. When no virtual modifier is present, the method is said to be a non¬ 
virtual method. 



When a virtual method is invoked, the runtime type of the instance for which that invoca¬ 
tion takes place determines the actual method implementation to invoke. In a nonvirtual 
method invocation, the compile-time type of the instance is the determining factor. 


A virtual method can be overridden in a derived class. When an instance method declara¬ 
tion includes an override modifier, the method overrides an inherited virtual method with 
the same signature. Whereas a virtual method declaration introduces a new method, an 
override method declaration specializes an existing inherited virtual method by providing 
a new implementation of that method. 


“■ ERIC LIPPERT A subtle point here is that an overridden virtual method is still 
considered to be a method of the class that introduced it, and not a method of the class 
that overrides it. The overload resolution rules in some cases prefer members of more 
derived t5q3es to those in base t 5 ^es; overriding a method does not "move" where that 
method belongs in this hierarchy. 

At the very beginning of this section, we noted that C# was designed with versioning 
in mind. This is one of those features that helps prevent "brittle base-class syndrome" 
from causing versioning problems. 


An abstract method is a virtual method with no implementation. An abstract method is 
declared with the abstract modifier and is permitted only in a class that is also declared 
abstract. An abstract method must be overridden in every non-abstract derived class. 

The following example declares an abstract class. Expression, which represents an expres¬ 
sion tree node, and three derived classes. Constant, VariableReference, and Operation, 
which implement expression tree nodes for constants, variable references, and arithmetic 
operations. (This is similar to, but not to be confused with, the expression tree types intro¬ 
duced in §4.6). 

using System; 

using System.Collections; 

public abstract class Expression 
{ 

public abstract double Evaluate(Hashtable vars); 

} 


35 


www.it-ebooks.info 


Introduction 






Introduction 


1. Introduction 


public class Constant; Expression 

{ 

double value; 

public Constant(double value) { 
this.value = value; 

} 

public override double Evaluate(Hashtable vars) { 
return value; 


public class VariableReference: Expression 

{ 

string name; 

public VariableReference(string name) { 
this.name = name; 

} 

public override double Evaluate(Hashtable vars) { 
object value = vars[name]; 
if (value == null) { 

throw new Exception("Unknown variable: " + name); 

} 

return Convert.ToDouble(value); 

} 

} 

public class Operation: Expression 

{ 

Expression left; 
char op; 

Expression right; 

public Operation(Expression leftj char op. Expression right) { 
this.left = left; 
this.op = op; 
this.right = right; 

} 

public override double Evaluate(Hashtable vars) { 
double X = left.Evaluate(vars); 
double y = right.Evaluate(vars); 
switch (op) { 

case ’+': return x + y; 
case '-': return x - y; 
case '*': return x * y; 
case ’/' : return x / y; 

} 

throw new Exception("Unknown operator"); 

} 

} 


36 


www.it-ebooks.info 





1.6 Classes and Objects 


The previous four classes can be used to model arithmetic expressions. For example, using 
instances of these classes, the expression x + 3 can be represented as follows. 


Expression e = new Operation( 
new VariableReferenceC'x"), 

new Constant(3)); 



The Evaluate method of an Expression instance is invoked to evaluate the given expres¬ 
sion and produce a double value. The method takes as an argument a Hashtable that con¬ 
tains variable names (as keys of the entries) and values (as values of the entries). The 
Evaluate method is a virtual abstract method, meaning that non-abstract derived classes 
must override it to provide an actual implementation. 


A Constant's implementation of Evaluate simply returns the stored constant. A 
VariableReference's implementation looks up the variable name in the hashtable and 
returns the resulting value. An Operation's implementation first evaluates the left 
and right operands (by recursively invoking their Evaluate methods) and then performs 
the given arithmetic operation. 


The following program uses the Expression classes to evaluate the expression x * (y + 2) 
for different values of x and y. 


using System; 

using System.Collections; 

class Test 
{ 

static void Main() { 

Expression e = new Operation( 

new VariableReferenceC'x"), 

' * 1 

i 

new Operation( 

new VariableReferenceC'y"), 

' +' j 

new Constant(2) 

) 

); 

Hashtable vans = new Hashtable(); 

vars["x"] = 3; 
vars["y"] = 5; 

Console.WriteLine(e.Evaluate(vars)); // Outputs "21" 

vars["x"] = 1.5; 
vars["y"] = 9; 

Console.WriteLlne(e.Evaluate(vars)); // Outputs "16.5 

} 

} 


37 


www.it-ebooks.info 


Introduction 




Introduction 


1. Introduction 


“■ CHRIS SELLS Virtual functions are a major feature of objecf-orienfed program¬ 
ming fhaf differenfiafe if from ofher kinds of programming. For example, if you find 
yourself doing somefhing like fhis: 

double GetHourlyRate(Person p) { 
if( p is Student ) { return 1.0; } 
else if( p is Employee ) { return 10.0; } 
return 0.0; 

} 

You should almosf always use a virfual mefhod insfead: 
class Person { 

public virtual double GetHourlyRate() { 
return 0.0; 

} 

} 

class Student { 

public override double GetHourlyRate() { 
return 1.0; 

} 

} 

class Employee { 

public override double GetHourlyRate() { 
return 10.0; 

} 

} 


1.6.6.5 Method Overloading 

Mefhod overloading permits multiple mefhods in fhe same class fo have fhe same name as 
long as fhey have unique signafures. When compiling an invocafion of an overloaded 
mefhod, fhe compiler uses overload resolution fo defermine fhe specific mefhod fo invoke. 
Overload resolution finds fhe one mefhod fhaf hesf mafches fhe argumenfs or reporfs an 
error if no single hesf mafch can he found. The following example shows overload resolu¬ 
tion in effecf. The commenf for each invocafion in fhe Main mefhod shows which mefhod 
is acfually invoked. 

class Test 
{ 

static void F() { 

Console.WriteLlne("F()"); 

} 

static void F(object x) { 

Console .WriteLineC'F(object)"); 

} 


38 


www.it-ebooks.info 






1.6 Classes and Objects 


static void F(int x) { 

Console.WriteLine("F(int)"); 

} 


static void F(double x) { 

Console.WriteLine("F(double)"); 

} 



static void F<T>(T x) { 

Console.WriteLine("F<T>(T)"); 

} 


static void F(double x, double y) { 

Console.WriteLlneC'F(doublej double)"); 

} 


static void Main() { 
F(); 

F(l); 

F(1.0); 

F("abc"); 

F((double)l); 
F((object)l); 
F<int>(l); 

F(l. 1); 

} 


// Invokes F() 

// Invokes F(int) 

// Invokes F(double) 

// Invokes F(object) 

// Invokes F(double) 

// Invokes F(object) 

// Invokes F<T>(T) 

// Invokes F(double, double) 


As shown by the example, a particular method can always be selected by explicitly casting 
the arguments to the exact parameter types and/or explicitly supplying type arguments. 


"■ BRAD ABRAMS The method overloading feature can be abused. Generally 
speaking, it is better to use method overloading only when all of the methods do 
semantically the same thing. The way many developers on the consuming end think 
about method overloading is that a single method takes a variety of arguments. In 
fact, changing the t 5 ^e of a local variable, parameter, or property could cause a differ¬ 
ent overload to be called. Developers certainly should not see side effects of the deci¬ 
sion to use overloading. For users, however, it can be a surprise when methods with 
the same name do different things. For example, in the early days of the .NET Frame¬ 
work (before version 1 shipped), we had this set of overloads on the string class: 

public class String { 

public int IndexOf (string value); 

// Returns the index of value with this instance 
public int IndexOf (char value); 

// Returns the index of value with this instance 
public int IndexOf (char [] value); 

// Returns the first index of any of the 
// characters in value within the current instance 

} 

Continued 


39 


www.it-ebooks.info 


Introduction 







Introduction 


1. Introduction 



This last overload caused problems, as it does a different thing. For example, 

"Doshua, Hannah, Doseph".IndexOf("Hannah");// Returns 7 

but 

"Doshua, Hannah, Doseph".IndexOf(new char [] {'H’,'a',’n','n’,'a,'h;"); 

// Returns 3 

In this case, it would be better to give the overload that does something a differ¬ 
ent name: 

public class String { 

public int IndexOf (string value); 

// Returns the index of value within this instance 
public int IndexOf (char value); 

// Returns the index of value within this instance 
public int IndexOfAny(char [] value); 

// Returns the first index of any of the 
// characters in value within the current instance 

} 


"■ BILL WAG N E R Method overloading and inheritance don't mix very well. Because 
overload resolution rules sometimes favor methods declared in the most derived class, 
that can sometimes mean a method declared in the derived class may be chosen 
instead of a method that appears to be a better match in the base class. For that reason, 
I recommend not overloading members that are declared in a base class. 


1.6.7 Other Function Members 

Members that contain executable code are collectively known as the function members of 
a class. The preceding section describes methods, which are the primary kind of function 
members. This section describes the other kinds of function members supported by C#: 
constructors, properties, indexers, events, operators, and destructors. 

The following table shows a generic class called List<T>, which implements a growable 
list of objects. The class contains several examples of the most common kinds of function 
members. 


40 


www.it-ebooks.info 









1.6 Classes and Objects 


public class List<T> 

{ 

const int defaultCapacity = 4j 

Constant 

T[] items; 
int count; 

Fields 

public List(int capacity = defaultCapacity) { 
items = new T[capacity]; 

} 

Constructors 

public int Count { 

get { return count; } 

} 

public int Capacity { 
get { 

return items.Length; 

} 

set { 

if (value < count) value = count; 
if (value != items.Length) { 

T[] newitems = new T[value]; 

Array.Copy(itemSj 0, newItemSj 0, count); 
items = newitems; 

} 

} 

} 

Properties 

public T this[int index] { 
get { 

return items[index]; 

} 

set { 

items[index] = value; 

OnChangedO; 

} 

} 

Indexer 


Continued 


41 


www.it-ebooks.info 


Introduction 











Introduction 


1. Introduction 


public void Add(T item) { 

if (count == Capacity) Capacity = count * 2; 

items[count] = item; 

count++; 

OnChanged(); 

} 

protected virtual void OnChanged() { 

if (Changed != null) Changed(thiSj EventArgs.Empty); 

} 

public override bool Equals(object other) { 
return Equals(thiSj other as List<T>); 

} 

static bool Equals(List<T> a, List<T> b) { 
if (a == null) return b == null; 
if (b == null 11 a.count != b.count) return false; 
for (int 1=0; i < a.count; i++) { 

if ( !object.Equals(a.ltems[i]j b.items[i])) { 
return false; 

} 

} 

return true; 

} 

Methods 

public event EventHandler Changed; 

Event 

public static bool operator ==(Llst<T> a, List<T> b) { 
return Equals(aj b); 

} 

public static bool operator !=(Llst<T> a, List<T> b) { 
return !Equals(a, b); 

} 

Operators 

} 


1.6.7.1 Constructors 

C# supports both instance and static constructors. An instance constructor is a member 
that implements the actions required to initialize an instance of a class. A static constructor 
is a member that implements the actions required to initialize a class itself when it is first 
loaded. 

A constructor is declared like a method with no return type and the same name as the con¬ 
taining class. If a constructor declaration includes a static modifier, it declares a static 
constructor. Otherwise, it declares an instance constructor. 


42 


www.it-ebooks.info 









1.6 Classes and Objects 


Instance constructors can be overloaded. For example, the List<T> class declares two 
instance constructors, one with no parameters and one that takes an int parameter. Instance 
constructors are invoked using the new operator. The following statements allocate two 
List<string> instances using each of the constructors of the List class. 



List<string> listl = new List<string>(); 
List<string> list2 = new List<string>(10); 


Unlike other members, instance constructors are not inherited, and a class has no instance 
constructors other than those actually declared in the class. If no instance constructor is 
supplied for a class, then an empty one with no parameters is automatically provided. 


"■ BRAD ABRAMS Constructors should be lazy! The best practice is to do minimal 
work in the constructor—that is, to simply capture the arguments for later use. For 
example, you might capture the name of the file or the path to the database, but don't 
open those external resources until absolutely necessary. This practice helps to ensure 
that possibly scarce resources are allocated for the smallest amount of fime possible. 

I was personally bitfen by this issue recently with the DataContext class in Linq to 
Entities. It opens the database in the connection string provided, rather than waiting 
to perform that operation until it is needed. For my test cases, I was providing test 
suspect data directly and, in fact, never wanted to open the database. Not only does 
this unnecessary activity lead to a performance loss, but it also makes the scenario 
more complicated. 


1.6.7.2 Properties 

Properties are a natural extension of fields. Both are named members with associated 
types, and the S 5 mtax for accessing fields and properties is the same. However, unlike 
fields, properties do not denote storage locations. Instead, properties have accessors that 
specify the statements to be executed when their values are read or written. 


"■ JESSE LIBERTY Aproperty looks to the creator of the class like a method allow¬ 
ing the developer to add behavior prior to setting or retrieving the underlying value. 
In contrast, the property appears to the client of the class as if if were a field, providing 
direcf, unencumbered access through the assignment operator. 


43 


www.it-ebooks.info 


Introduction 








Introduction 


1. Introduction 



■■ ERICLIPPERT A standard "best practice" is to always expose field-like data as 
properties with getters and setters rather than exposing the field. Thai way, if you ever 
wanf fo add funcfionalify fo your geffer and seffer (e.g., logging, dafa binding, secu- 
rify checking), you can easily do so wifhouf "breaking" any consumer of fhe code fhaf 
mighf rely on fhe field always being fhere. 

Alfhough in some sense fhis pracfice is a violation of anofher bif of good advice 
("Avoid premafure generalizafion"), fhe new "aufomafically implemenfed proper¬ 
ties" feafure makes if very easy and nafural fo use properfies rafher fhan fields as parf 
of fhe public inferface of a fype. 


"■ CHRIS SELLS Eric makes such a good poinf fhaf 1 wanfed fo show an example. 
Don'f ever make a field public: 

class Cow 
{ 

public int Milk; // BAD! 

} 

If you don'f wanf fo layer in anyfhing besides sforage, lef fhe compiler implemenf fhe 
properfy for you: 

class Cow 
{ 

public int Milk { get; set; } // Good 

} 

Thai way, fhe clienf binds fo fhe properfy geffer and seffer so fhaf lafer you can fake 
over fhe compiler's implemenfafion fo do somefhing fancy: 

class Cow { 

bool gotMllk = false; 
int milk; 
public int Milk { 
get { 

if( IgotMilk ) { 

milk = ApplyMilkingMachine(); 
gotMilk = true; } 
return milk; 

} 

set { 


44 


www.it-ebooks.info 









1.6 Classes and Objects 


ApplyReverseMilkingMachine(value); // The cow might not like this., 
milk = value; 

} 

} 

} 

Also, I really love the following idiom for cases where you know a calculated value 
will be used in your program: 

class Cow { 
public Cow() { 

Milk = ApplyMilkingMachineO; 

} 

public int Milk { get; private set; } 

} 

In this case, we are precalculating the property, which is a waste if we don't know 
whether we will need it. If we do know, we save ourselves some complication in the 
code by eliminating a flag, some branching logic, and the storage management. 


"■ BILL WAG N E R Property accesses look like field accesses to your users—and they 
will naturally expect them to act like field accesses in every way, including perfor¬ 
mance. If a get accessor needs to do significant work (reading a file or querying a 
database, for example), it should be exposed as a method, not a property. Callers 
expect that a method may be doing more work. 

For the same reason, repeated calls to property accessors (without intervening code) 
should return the same value. Date!ime. Now is one of very few examples in the frame¬ 
work that does not follow this advice. 


A property is declared like a field, except that the declaration ends with a get accessor 
and /or a set accessor written between the delimiters { and } instead of ending in a semi¬ 
colon. A property that has both a get accessor and a set accessor is a read-write property, 
a property that has only a get accessor is a read-only property, and a property that has only 
a set accessor is a write-only property. 

A get accessor corresponds to a parameterless method with a return value of the property 
type. Except as the target of an assignment, when a property is referenced in an expression, 
the get accessor of the property is invoked to compute the value of the property. 


45 


www.it-ebooks.info 


Introduction 









Introduction 


1. Introduction 


A set accessor corresponds to a method with a single parameter named value and no 
return type. When a property is referenced as the target of an assignment or as the operand 
of ++ or - - , the set accessor is invoked with an argument that provides the new value. 


The List<T> class declares two properties. Count and Capacity, which are read-only and 
read-write, respectively. The following is an example of use of these properties. 



List<string> names = new List<string>(); 

names.Capacity = 100; // Invokes set accessor 
int i = names.Count; // Invokes get accessor 
int j = names.Capacity; // Invokes get accessor 


Similar to fields and methods, C# supports both instance properties and static properties. 
Static properties are declared with the static modifier, and insfance properfies are declared 


without it. 


The accessor(s) of a property can be virtual. When a property declaration includes a 
virtual, abstract, or override modifier, if applies to the accessor(s) of the property. 


“■ VLADIMIR RESHETNIKOV If a virtual property happens to have a private acces¬ 
sor, this accessor is implemented in CLR as a nonvirtual method and cannot be over¬ 
ridden in derived classes. 


1.6.7.3 Indexers 

An indexer is a member that enables objects to be indexed in the same way as an array. An 
indexer is declared like a property except that the name of the member is this followed by 
a paramefer lisf written between the delimiters [ and ]. The parameters are available in the 
accessor(s) of fhe indexer. Similar fo properties, indexers can be read-write, read-only, and 
write-only and the accessor(s) of an indexer can be virtual. 

The List class declares a single read-write indexer that takes an int parameter. The indexer 
makes it possible to index List instances with int values. For example: 

List<string> names = new List<string>(); 
names.AddC'Liz"); 
names.Add("Martha"); 
names.Add("Beth"); 

for (int i = 0; i < names.Count; i++) { 
string s = names[i]; 
names[i] = s.ToUpper(); 

} 


46 


www.it-ebooks.info 






1.6 Classes and Objects 


Indexers can be overloaded, meaning that a class can declare multiple indexers as long as 
the number or types of their parameters differ. 

1.6.7.4 Events 

An event is a member that enables a class or object to provide notifications. An event is 
declared like a field except that the declaration includes an event ke 5 rword and the t 5 ^e 
must be a delegate type. 


■■ JESSE LIBERTY In truth, event is just a ke 5 rword that signals C# to restrict the 
way a delegate can be used, thereby preventing a client from directly invoking an 
event or hijacking an event by assigning a handler rather than adding a handler. In 
short, the keyword event makes delegates behave in the way you expect events to 
behave. 


“■ CHRIS SELLS Without the event ke 5 rword, you are allowed to do this: 

delegate void WorkCompleted(); 
class Worker { 

public WorkCompleted Completed; // Delegate field, not event 

} 

class Boss { 

public void WorkCompleted() { ... } 

} 

class Program { 

static void Main() { 

Worker peter = new Worker(); 

Boss boss = new Boss(); 

peter.Completed += boss.WorkCompleted; // This is what you want to happen 
peter.Completed = boss.WorkCompleted; // This is what the compiler allows 

} 

} 

Continued 


47 


www.it-ebooks.info 


Introduction 









Introduction 


1. Introduction 


Unfortunately, with the event ke 5 rword. Completed is just a public field of 1)^0 dele¬ 
gate, which can be stepped on by anyone who wants to—and the compiler is okay with 
that. By adding the event ke 5 rword, you limit the operations to += and -= like so: 

class Worker { 

public event WorkCompleted Completed; 

} 

peter.Completed += boss.WorkCompleted; // Compiler still okay 
peter.Completed = boss.WorkCompleted; // Compiler error 

The use of the event ke 5 rword is the one time where it's okay to make a field public, 
because the compiler narrows the use to safe operations. Further, if you want to take 
over the implementation of += and -+ for an event, you can do so. 


Within a class that declares an event member, the event can be accessed like a field of a 
delegate type (provided the event is not abstract and does not declare accessors). The field 
stores a reference to a delegate that represents the event handlers that have been added to 
the event. If no event handlers are present, the field is null. 

The List<T > class declares a single event member called Changed, which indicates that a 
new item has been added to the list. The Changed event is raised by the OnChanged virtual 
method, which first checks whether the event is null (meaning that no handlers are pres¬ 
ent). The notion of raising an event is precisely equivalent to invoking the delegate repre¬ 
sented by the event—thus there are no special language constructs for raising events. 

Clients react to events through event handlers. Event handlers are attached using the += 
operator and removed using the -= operator. The following example attaches an event 
handler to the Changed event of a List<string>. 

using System; 

class Test 
{ 

static int changeCount; 

static void ListChanged(object sender, EventArgs e) { 
changeCount++; 

} 


48 


www.it-ebooks.info 







1.6 Classes and Objects 


static void Main() { 

List<string> names = new List<string>(); 

names.Changed += new EventHandler(ListChanged); 

names.Add("Liz"); 

names.Add("Martha"); 

names.Add("Beth"); 

Console.WriteLine(changeCount); // Outputs "3" 

} 



For advanced scenarios where control of the underlying storage of an event is desired, an 
event declaration can explicitly provide add and remove accessors, which are somewhat 
similar to the set accessor of a property. 


"■ CHRIS SELLS As of C# 2.0, explicitly creating a delegate instance to wrap a 
method was no longer necessary. As a consequence, the code 

names.Changed += new EventHandler(ListChanged); 

can be more succinctly written as 

names.Changed += ListChanged; 

Not only does this shortened form require less t 5 q)ing, but it is also easier to read. 


1.6.7.5 Operators 

An operator is a member that defines the meaning of applying a particular expression 
operator to instances of a class. Three kinds of operators can be defined: unary operators, 
binary operators, and conversion operators. All operators must be declared as public and 
static. 

The List<T> class declares two operators, operator == and operator !=, and thus gives 
new meaning to expressions that apply those operators to List instances. Specifically, the 
operators define equality of two List<T> instances as comparing each of the contained 
objects using their Equals methods. The following example uses the == operator to com¬ 
pare two List<int> instances. 

using System; 

class Test 
{ 

static void Main() { 

List<int> a = new List<int>(); 
a.Add(l); 


49 


www.it-ebooks.info 


Introduction 






Introduction 


1. Introduction 


a. Add(2); 

List<int> b = new List<int>(); 

b. Add(l); 
b.Add(2); 

Console.WriteLine(a == b); // Outputs "True" 

b.Add(3); 

Console.WriteLine(a == b); // Outputs "False" 

} 

} 



The first Console.WriteLine outputs True because the two lists contain the same number 
of objects with the same values in the same order. Had List<T > not defined operator ==, 
the first Console.WriteLine would have output False because a and b reference different 


List<int> instances. 


1.6.7.6 Destructors 

A destructor is a member that implements the actions required to destruct an instance of a 
class. Destructors cannot have parameters, they cannot have accessibility modifiers, and 
they cannot be invoked explicitly. The destructor for an instance is invoked automatically 
during garbage collection. 

The garbage collector is allowed wide latitude in deciding when to collect objects and run 
destructors. Specifically, the timing of destructor invocations is not deterministic, and 
destructors may be executed on any thread. For these and other reasons, classes should 
implement destructors only when no other solutions are feasible. 


■■ VLADIMIR RESHETNIKOV Destructors are sometimes called "finalizers." 
This name also appears in the garbage collector API—for example, 
GC.WaitForPendingFinalizers. 


The using statement provides a better approach to object destruction. 

1.7 Structs 

Like classes, structs are data structures that can contain data members and function mem¬ 
bers, but unlike classes, structs are value t 5 q)es and do not require heap allocation. A vari¬ 
able of a struct type directly stores the data of the struct, whereas a variable of a class 1)^)0 
stores a reference to a d 5 mamically allocated object. Struct t 5 q)es do not support user- 
specified inheritance, and all struct types implicitly inherit from type object. 


50 


www.it-ebooks.info 






1.7 Structs 


“■ ERIC LI PPERT The fact that structs do not require heap allocation does not mean 
that they are never heap allocated. See the annotations to §1.3 for more details. 



Structs are particularly useful for small data structures that have value semantics. Complex 
numbers, points in a coordinate system, or key-value pairs in a dictionary are all good 
examples of structs. The use of structs rather than classes for small data structures can 
make a large difference in the number of memory allocations an application performs. For 
example, the following program creates and initializes an array of 100 points. With Point 
implemented as a class, 101 separate objects are instantiated—one for the array and one 
each for the 100 elements. 


class Point 
{ 

public int x, y; 

public Point(int x, int y) 
{ 

this.x = x; 
this.y = y; 

} 


class Test 
{ 

static void Main() 

{ 

Point[] points = new Point[100]; 

for (int i = 0; i < 100; i++) points[i] = new Point(i, i); 

} 


An alternative is to make Point a struct. 


struct Point 
{ 

public int x, y; 

public Point(int x, int y) 

{ 

this.x = x; 
this.y = y; 

} 

} 

Now, only one object is instantiated—the one for the array—and the Point instances are 
stored in-line in the array. 


51 


www.it-ebooks.info 


Introduction 






Introduction 


1. Introduction 



“■ ERIC LI PPERT The takeaway message here is that certain specific data-intensive 
applications, which would otherwise be gated on heap allocation performance, benefif 
greafly from using sfrucfs. The fakeaway message is emphafically not "Always use 
sfrucfs because fhey make your program fasfer." 

The performance benefif here is a fradeoff: Sfrucfs can in some scenarios fake less fime 
fo allocafe and deallocafe, buf because every assignmenf of a sfrucf is a value copy, 
fhey can fake more fime fo copy fhan a reference copy would fake. 

Always remember fhaf if makes liffle sense fo optimize anyfhing ofher fhan fhe slowest 
fhing. If your program is nof gafed on heap allocafions, fhen pondering whefher fo 
use sfrucfs or classes for performance reasons is nof an effective use of your fime. Find 
fhe slowesf fhing, and fhen opfimize if. 


Sfrucf consfrucfors are invoked wifh fhe new operator, buf fhaf does nof imply fhaf memory 
is being allocafed. Instead of dynamically allocating an objecf and refuming a reference fo 
if, a sfrucf consfrucfor simply refums fhe sfrucf value ifself (fypically in a temporary loca- 
fion on fhe sfack), and fhis value is fhen copied as necessary. 

Wifh classes, if is possible for two variables to reference fhe same objecf and fhus possible 
for operafions on one variable fo affecf fhe objecf referenced by fhe ofher variable. Wifh 
sfrucfs, fhe variables each have fheir own copy of fhe dafa, and if is nof possible for opera¬ 
fions on one fo affecf fhe ofher. For example, fhe oufpuf produced by fhe following code 
fragmenf depends on whefher Point is a class or a sfrucf. 

Point a = new Point(10, 10); 

Point b - a; 
a.x = 20; 

Console.WriteLine(b.x); 

If Point is a class, fhe oufpuf is 20 because a and b reference fhe same objecf. If Point is a 
sfrucf, fhe oufpuf is 10 because fhe assignmenf of a fo b creafes a copy of fhe value, and fhis 
copy is unaffected by fhe subsequenf assignmenf fo a. x. 

The previous example highlighfs fwo of fhe limifafions of sfrucfs. Firsf, copying an enfire 
sfrucf is fypically less effidenf fhan copying an objecf reference, so assignmenf and value 
paramefer passing can be more expensive wifh sfrucfs fhan wifh reference fypes. Second, 
excepf for ref and out paramefers, if is nof possible fo creafe references fo sfrucfs, which 
rules ouf fheir usage in a number of sifuafions. 


52 


www.it-ebooks.info 






1.8 Arrays 


“■ BILL WAGNER Read those last two paragraphs again. They describe the most 
important design differences befween sfrucfs and classes. If you don'f wanf value 
semanfics in all cases, you musf use a class. Classes can implemenf value semanfics in 
some sifuafions (string is a good example), buf by defaulf fhey obey reference seman¬ 
fics. Thai difference is more imporfanf for your designs fhan size or sfack versus heap 
allocations. 


1.8 Arrays 



An array is a dafa sfrucfure fhaf confains a number of variables fhaf are accessed fhrough 
compufed indices. The variables confained in an array, also called fhe elements of fhe array, 
are all of fhe same t 5 ^e, and fhis f 5 ^e is called fhe element type of fhe array. 


Array f 5 ^es are reference f 5 ^es, and fhe declarafion of an array variable simply sefs aside 
space for a reference fo an array insfance. Acfual array insfances are creafed d 5 mamically 
af runtime using fhe new operafor. The new operation specifies fhe length of fhe new array 
insfance, which is fhen fixed for fhe lifefime of fhe insfance. The indices of fhe elemenfs of 
an array range from 0 fo Length - 1. The new operafor aufomafically inifializes fhe elemenfs 
of an array fo fheir defaulf value, which, for example, is zero for all numeric fypes and null 
for all reference fj^es. 


"■ ERICLIPPERT The confusion resulting from some languages indexing arrays 
sfarfing wifh 1 and some ofhers sfarfing wifh 0 has befuddled multiple generations of 
novice programmers. The idea fhaf array "indexes" sfarf wifh 0 comes from a subfle 
misinferprefafion of fhe C language's array S 5 mfax. 

In C, when you say myArray [x], whaf fhis means is "sfarf af fhe begirming of fhe array 
and refer fo fhe fhing x sfeps away." Therefore, myArray [ 1 ] refers fo fhe second elemenf, 
because fhaf is whaf you gef when you sfarf af fhe firsf elemenf and move one sfep. 

Really, fhese references should be called array offsets rafher fhan indices. Buf because 
generafions of programmers have now infemalized fhaf arrays are "indexed" sfarfing 
af 0, we're sfuck wifh fhis ferminology. 


53 


www.it-ebooks.info 


Introduction 








Introduction 


1. Introduction 


The following example creates an array of int elements, initializes the array, and prints out 
the contents of the array. 

using System; 

class Test 
{ 

static void Main() { 

int[] a = new int[10]; 
for (int i = 0; i < a.Length; i++) { 
a[i] = i * i; 

} 

for (int i = 0; i < a.Length; i++) { 

Console.WriteLine("a[{0}] = {1}", i, a[i]); 

} 

} 

} 

This example creates and operates on a single-dimensional array. C# also supports multi¬ 
dimensional arrays. The number of dimensions of an array type, also known as the rank 
of the array t 5 ^e, is one plus the number of commas written between the square brackets 
of the array type. The following example allocates one-dimensional, two-dimensional, and 
three-dimensional arrays. 

int[] al = new int[10]; 
int[,] a2 = new lnt[10, 5]; 
int[,,] a3 = new int[10, 5, 2]; 

The al array contains 10 elements, the a2 array contains 50 (10 x 5) elements, and the a3 
array contains 100 (10 x 5 x 2) elements. 


“■ BILL WAGNER An FxCop rule recommends against multi-dimensional arrays; 
it's primarily guidance against using multi-dimensional arrays as sparse arrays. If you 
know that you really are filling in all the elements in the array, multi-dimensional 
arrays are fine. 


The element type of an array can be any type, including an array type. An array with 
elements of an array type is sometimes called a jagged array because the lengths of 
the element arrays do not all have to be the same. The following example allocates an array 
of arrays of int: 

int[][] a = new int[3][]; 
a[0] = new int[10]; 
a[l] = new int[5]; 
a[2] = new int[20]; 

The first line creates an array with three elements, each of type int [ ] and each with an 
initial value of null. The subsequent lines then initialize the three elements with references 
to individual array instances of varying lengths. 

54 


www.it-ebooks.info 






1.8 Arrays 


The new operator permits the initial values of the array elements to be specified using an 
array initializer, which is a lisf of expressions wriffen between fhe delimifers { and }. The 
following example allocafes and inifializes an int[ ] wifh fhree elemenfs. 

int[] a = new int[] {1, 2, 3}; 

Nofe fhaf fhe lengfh of fhe array is inferred from fhe number of expressions between { and 
}. Local variable and field declarations can be shortened further such that the array t 5 ^e 
does not have to be restated. 

int[] a = {1, 2, 3}; 

Both of fhe previous examples are equivalenf fo fhe following: 



int[] t = new int[3]; 

t[0] = l; 

t[l] = 2; 

t[2] = 3; 

int[] a = t; 


■■ ERICLIPPERT In a number of places fhus far, fhe specificafion nofes fhaf a par¬ 
ticular local initialization is equivalenf fo "assign somefhing fo a femporary variable, 
do somefhing fo fhe femporary variable, declare a local variable, and assign fhe fem¬ 
porary fo fhe local variable." You may be wondering why fhe specificafion calls ouf 
fhis seemingly unnecessary indirection. Why nof simply say fhaf fhis inifializafion is 
equivalenf fo fhis: 

int[] a = new int[3]; 
a[0] = l; a[l] = 2; a[2] =3; 

In facf, fhis practice is necessary because of definife assignmenf analysis. We would like 
fo ensure fhaf all local variables are definifely assigned before fhey are used. In particu¬ 
lar, we would like an expression such as object [] arr = {arr}; fo be illegal because 
if appears fo use arr before if is definifely assigned. If fhis were equivalenf fo 

object[] arr = new object[l]; 
arr[0] = arr; 

fhen fhaf would be legal. Buf by saying fhaf fhis expression is equivalenf fo 

object[] temp = new object[l]; 
temp[0] = arr; 
object[] arr = temp; 

fhen if becomes clear fhaf arr is being used before if is assigned. 


55 


www.it-ebooks.info 


Introduction 






Introduction 


1. Introduction 


1.9 Interfaces 

An interface defines a contract that can be implemented by classes and structs. An interface 
can contain methods, properties, events, and indexers. An interface does not provide 
implementations of the members it defines—it merely specifies the members that must be 
supplied by classes or structs that implement the interface. 



Interfaces may employ multiple inheritance. In the following example, the interface 
IComboBox inherits from both ITextBox and IListBox. 


interface IControl 
{ 

void Paint(); 


} 


interface ITextBox : IControl 
{ 

void SetText(string text); 

} 

interface IListBox : IControl 
{ 

void Setltems(string[] items); 

} 

interface IComboBox : ITextBox, IListBox { } 


Classes and structs can implement multiple interfaces. In the following example, the class 
EditBox implements both IControl and IDataBound. 

interface IDataBound 
{ 

void Bind(Binder b); 

} 

public class EditBox : IControl, IDataBound 
{ 

public void Paint() {...} 
public void Bind(Binder b) {...} 

} 


“■ KRZYSZTOF CWALINA Perhaps I am stirring up quite a bit of controversy with 
this statement, but I believe the lack of support for multiple inheritance in our t 5 qie 
system is the single biggest contributor to the complexity of the .NET Framework. 
When we designed the t 5 qTe system, we explicitly decided not to add support for mul¬ 
tiple inheritance so as to provide simplicity. In retrospect, this decision had the exact 
opposite effect. The lack of multiple inheritance forced us to add the concept of inter¬ 
faces, which in turn are responsible for problems with the evolution of the framework, 
deeper inheritance hierarchies, and many other problems. 


56 


www.it-ebooks.info 






1.9 Interfaces 


When a class or struct implements a particular interface, instances of that class or struct can 
be implicitly converted to that interface type. For example: 


EditBox editBox = new EditBox(); 
IControl control = editBox; 
IDataBound dataBound = editBox; 



In cases where an instance is not statically known to implement a particular interface, 
dynamic t 5 ^e casts can be used. For example, the following statements use d 5 mamic type 
casts to obtain an object's IControl and IDataBound interface implementations. Because 
the actual type of the object is EditBox, the casts succeed. 

object obj = new EditBox(); 

IControl control = (IControl)obj; 

IDataBound dataBound = (IDataBound)obj; 


In the previous EditBox class, the Paint method from the IControl interface and the Bind 
method from the IDataBound interface are implemented using public members. C# also 
supports explicit interface member implementations, using which the class or struct can 
avoid making the members public. An explicit interface member implementation is writ¬ 
ten using the fully qualified interface member name. For example, the EditBox class could 
implement the IControl. Paint and IDataBound. Bind methods using explicit interface 
member implementations as follows. 

public class EditBox : IControl, IDataBound 
{ 

void IControl.Paint() {...} 

void IDataBound.Bind(Binder b) {...} 

} 


Explicit interface members can only be accessed via the interface type. For example, the 
implementation of IControl. Paint provided by the previous EditBox class can only be 
invoked by first converting the EditBox reference to the IControl interface type. 

EditBox editBox = new EditBox(); 

editBox.PaintO; // Error; no such method 

IControl control = editBox; 

control.Paint(); // Okay 


"■ VLADIMIR RESHETNIKOV Actually, explicitly implemented interface members 
can also be accessed via a tjqie parameter, constrained to the interface tjqie. 


57 


www.it-ebooks.info 


Introduction 






Introduction 


1. Introduction 


1.10 Enums 

An enum type is a distinct value type with a set of named constants. The following exam¬ 
ple declares and uses an enum fype named Color wifh fhree consfanf values. Red, Green, 
and Blue. 

using System; 
enum Color 


Green, 

Blue 

} 

class Test 

{ 

static void PrintColor(Color color) { 
switch (color) { 
case Color.Red: 

Console.WriteLine("Red"); 
break; 

case Color.Green: 

Console.WriteLine("Green"); 
break; 

case Color.Blue: 

Console.WriteLine("Blue"); 
break; 
default: 

Console.WriteLine("Unknown color"); 
break; 

} 

} 

static void Main() { 

Color c = Color.Red; 

PrlntColor(c); 

PrlntColor(Color.Blue); 

} 

} 

Each enum 1)^6 has a corresponding infegral 15^0 called fhe underlying type of fhe enum 
fype. An enum fype fhaf does nof explicifly declare an underlying fype has an underlying 
fype of int. An enum f5^e's sforage formaf and range of possible values are defermined 
by ifs underlying fype. The sef of values fhaf an enum fype can fake on is nof limifed by ifs 
enum members. In parficular, any value of fhe underlying fype of an enum can be casf fo 
fhe enum f5^e and is a disfincf valid value of fhaf enum fype. 

The following example declares an enum f5^e named Alignment wifh an underlying fype 
of sbyte. 

enum Alignment : sbyte 

{ 

Left = -1, 


58 


www.it-ebooks.info 




1.10 Enums 


Center = 0, 
Right = 1 

} 


VLADIMIR RESHETNIKOV Although this S5mtax resembles base t 5 q 3 e specification, 
it has a different meaning. The base t5^e of Alignment is nof sbyte, buf System. Enum, 
and fhere is no implicif conversion from Alignment fo sbyte. 


As shown by fhe previous example, an enum member declarafion can include a consfanf 
expression fhaf specifies fhe value of fhe member. The consfanf value for each enum mem¬ 
ber musf be in fhe range of fhe underlying f5^e of fhe enum. When an enum member 
declarafion does nof explicifly specify a value, fhe member is given fhe value zero (if if is 
fhe firsf member in fhe enum f5^e) or fhe value of fhe fexfually preceding enum member 
plus one. 

Enum values can be converfed fo infegral values and vice versa using fype casfs. For 
example: 

int i = (int)Color.Blue; // int i = 2; 

Color c = (Color)2; // Color c = Color.Blue; 


BILL WAGNER The facf fhaf zero is fhe defaulf value for a variable of an enum fype 
implies fhaf you should always ensure fhaf zero is a valid member of any enum 
fype. 


The defaulf value of any enum f5^e is fhe infegral value zero converfed fo fhe enum type. 
In cases where variables are automatically initialized to a default value, this is the value 
given to variables of enum fypes. For fhe defaulf value of an enum f5^e fo be easily avail¬ 
able, fhe liferal 0 implicifly converfs fo any enum fype. Thus fhe following is permitted. 

Color c = 0; 


BRAD ABRAMS My firsf programming class in high school was in Turbo Pascal 
(Thanks, Anders!). On one of my firsf assignments I got back from my feacher, I saw a 
big red circle around fhe number 65 in my source code and fhe scrawled nofe, "No 
Magic Consfanfsi!" My feacher was insffiling in me fhe virfues of using fhe consfanf 
RetirementAge for readabilify and mainfenance. Enums make fhis a super-easy deci¬ 
sion fo make. Unlike in some programming languages, using an enum does nof incur 
any runfime performance overhead in C#. While I have heard many excuses in API 
reviews, fhere are jusf no good reasons fo use a magic consfanf rafher fhan an enum! 


59 


www.it-ebooks.info 


Introduction 










Introduction 


1. Introduction 


1.11 Delegates 

A delegate type represents references to methods with a particular parameter list and 
return type. Delegates make it possible to treat methods as entities that can be assigned to 
variables and passed as parameters. Delegates are similar to the concept of function point¬ 
ers found in some other languages, but unlike function pointers, delegates are object- 
oriented and type-safe. 



The following example declares and uses a delegate t5^e named Function, 
using System; 

delegate double Function(double x); 


class Multiplier 
{ 

double factor; 


public Multiplier(double factor) { 
this.factor = factor; 

} 

public double Multiply(double x) { 
return x * factor; 

} 


class Test 
{ 

static double Square(double x) { 
return x * x; 

} 

static double[] Apply(double[] a. Function f) { 
double[] result = new double[a.Length]; 
for (int i = 0; i < a.Length; i++) result[i] = f(a[i]); 
return result; 

} 


static void Main() { 

double[] a = {0.0, 0.5, 1.0}; 


double[] squares = Apply(a, Square); 


double[] sines = Apply(a, Math.Sin); 

Multiplier m = new Multiplier(2.0); 
double[] doubles = Apply(a, m.Multiply); 

} 

} 


An instance of the Function delegate type can reference any method that takes a double 
argument and returns a double value. The Apply method applies a given Function to the 
elements of a doublet ], returning a doublet ] with the results. In the Main method. Apply is 
used to apply three different functions toadoublet]. 


60 


www.it-ebooks.info 




1.12 Attributes 


Adelegate can reference either a static method (such as Square or Math. Sin in the previous 
example) or an instance method (such as m. Multiply in the previous example). A delegate 
that references an instance method also references a particular object, and when the instance 
method is invoked through the delegate, that object becomes this in the invocation. 



Delegates can also be created using anonymous fimctions, which are "in-line methods" 
that are created on the fly. Anonymous functions can see the local variables of the sur¬ 
rounding methods. Thus the multiplier example above can be written more easily without 
using a Multiplier class: 

double[] doubles = Apply(a, (double x) => x * 2.0); 


An interesting and useful property of a delegate is that it does not know or care about the 
class of the method it references; all that matters is that the referenced method has the same 
parameters and return t5^e as the delegate. 


BILL WAG N E R This property of delegates make them an excellent tool for providing 
interfaces between components with the lowest possible coupling. 


1.12 Attributes 

Types, members, and other entities in a C# program support modifiers that control certain 
aspects of their behavior. For example, the accessibility of a method is controlled using the 
public, protected, internal, and private modifiers. C# generalizes this capability such 
that user-defined types of declarative information can be attached to program entities and 
retrieved at runtime. Programs specify this additional declarative information by defining 
and using attributes. 

The following example declares a HelpAttribute attribute that can be placed on program 
entities to provide links to their associated documentation. 

using System; 

public class HelpAttribute: Attribute 
{ 

string url; 
string topic; 

public HelpAttribute(string url) { 
this.url = url; 

} 

public string Url { 

get { return url; } 

} 


61 


www.it-ebooks.info 


Introduction 






Introduction 


1. Introduction 


public string Topic { 

get { return topic; } 
set { topic = value; } 

} 

} 



All attribute classes derive from the System.Attribute base class provided by the .NET 
Framework. Attributes can be applied by giving their name, along with any arguments, 
inside square brackets just before fhe associafed declaration. If an atfribufe's name ends in 
Attribute, fhat part of fhe name can be omiffed when the attribute is referenced. For exam¬ 
ple, fhe HelpAttribute attribute can be used as follows. 


[Help("http: //msdn .microsoft. com/... /MyClass. htm") ] 
public class Widget 
{ 


[Help("http://msdn.microsoft.com/.../MyClass.htm". Topic = "Display")] 
public void Display(string text) { } 


} 


This example attaches a HelpAttribute to the Widget class and another HelpAttribute to 
the Display method in the class. The public constructors of an attribute class control the 
information that must be provided when the attribute is attached to a program entity. 
Additional information can be provided by referencing public read-write properties of the 
attribute class (such as the reference to the Topic property previously). 


The following example shows how attribute information for a given program entify can be 
retrieved at runtime using reflection. 


using System; 

using System.Reflection; 


class Test 


{ 


static void ShowHelp(HemberInfo member) { 

HelpAttribute a = Attribute.GetCustomAttribute(member, 
typeof(HelpAttribute)) as HelpAttribute; 
if (a == null) { 

Console.WrlteLineC'No help for {0}", member); 

} 

else { 

Console.WriteLine("Help for {0}:", member); 
Console.WrlteLine(" Url={0}, Topic={l}", 
a.Url, a.Topic); 


} 


} 


static void Main() { 

ShowHelp(typeof(Widget)); 

ShowHelp(typeof(Widget).GetMethod("Display")); 

} 

} 


62 


www.it-ebooks.info 




1.12 Attributes 


When a particular attribute is requested through reflection, the constructor tor the attribute 
class is invoked with the intormation provided in the program source, and the resulting 
attribute instance is returned. It additional intormation was provided through properties, 
those properties are set to the given values before the attribute instance is returned. 



BILL WAGNER The foil potential ot attributes will be realized when some tuture ver¬ 
sion ot the C# compiler enables developers to read attributes and use them to modity 
the code model before the compiler creates IL. I've wanted to be able to use attributes 
to change the behavior ot code since the flrst release ot C#. 


63 


www.it-ebooks.info 


Introduction 






This page intentionally left blank 


www.it-ebooks.info 


2. Lexical Structure 


2.1 Programs 

A C# program consists of one or more source files, known formally as compilation units 
(§9.1). A source file is an ordered sequence of Unicode characfers. Source files fypically 
have a one-fo-one correspondence wifh files in a file sysfem, buf fhis correspondence is nof 
required. For maximal porfabilify, if is recommended fhaf files in a file sysfem be encoded 
with the UTF-8 encoding. 

Conceptually speaking, a program is compiled using three steps: 

1. Transformation, which converts a file from a parficular characfer repertoire and encod¬ 
ing scheme info a sequence of Unicode characfers. 

2. Lexical analysis, which franslafes a sfream of Unicode inpuf characfers info a sfream of 
tokens. 

3. Synfacfic analysis, which franslafes fhe sfream of tokens info execufable code. 

2.2 Grammars 

This specificafion presenfs fhe S 5 mfax of fhe C# programming language using fwo gram¬ 
mars. The lexical grammar (§2.2.2) defines how Unicode characfers are combined fo form 
line ferminafors, while space, commenfs, tokens, and preprocessing direcfives. The syntac¬ 
tic grammar (§2.2.3) defines how fhe tokens resulting from fhe lexical grammar are com¬ 
bined fo form C# programs. 

2.2.1 Grammar Notation 

The lexical and S 5 mfacfic grammars are presenfed using grammar productions. Each gram¬ 
mar producfion defines a nonterminal symbol and fhe possible expansions of fhaf nonter¬ 
minal symbol into sequences of nonterminal or ferminal symbols. In grammar productions, 
nonterminal symbols are shown in ifalic type, and terminal symbols are shown in a fixed- 
widfh fonf. 


www.it-ebooks.info 




Lexical Structure 


2. Lexical Structure 




The first line of a grammar production is the name of the nonterminal symbol being 
defined, followed by a colon. Each successive indented line contains a possible expansion 
of the nonterminal given as a sequence of nonterminal or terminal symbols. For example, 
the production 

while-statement: 

while ( boolean-expression ) embedded-statement 

defines a while-statement to consist of the token while, followed by the token " (", followed 
by a boolean-expression, followed by the token ")", followed by an embedded-statement. 

When there is more than one possible expansion of a nonterminal symbol, the alternatives 
are listed on separate lines. For example, the production 

statement-list: 

statement 

statement-list statement 

defines a statement-list to either consist of a statement or consist of a statement-list followed 
by a statement. In other words, the definition is recursive and specifies that a statement list 
consists of one or more statements. 

A subscripted suffix is used to indicate an optional symbol. The production 
block: 

{ statement-list , } 
is shorthand for 

block: 

{ } 

{ statement-list } 

and defines a block to consist of an optional statement-list enclosed in "{" and "}" tokens. 

Alternatives are normally listed on separate lines, though in cases where there are many 
alternatives, the phrase "one of" may precede a list of expansions given on a single line. 
This is simply shorthand for listing each of the alternatives on a separate line. For example, 
the production 

real-type-sujfix: one of 
F f D d M m 

is shorthand for 


66 


www.it-ebooks.info 




2.3 Lexical Analysis 


real-type-sujfix: 

F 

f 

D 

d 

M 

m 


2.2.2 Lexical Grammar 

The lexical grammar of C# is presented in §2.3, §2.4, and §2.5. The terminal symbols of the 
lexical grammar are the characters of the Unicode character set, and the lexical grammar 
specifies how characters are combined to form tokens (§2.4), white space (§2.3.3), com¬ 
ments (§2.3.2), and preprocessing directives (§2.5). 

Every source file in a C# program must conform to the input production of the lexical 
grammar (§2.3). 

2.2.3 Syntactic Grammar 

The S 5 mtactic grammar of C# is presented in the chapters and appendices that follow this 
chapter. The terminal symbols of the syntactic grammar are the tokens defined by the lexi¬ 
cal grammar, and the S 5 mtactic grammar specifies how tokens are combined to form C# 
programs. 

Every source file in a C# program must conform to the compilation-unit production of the 
S 5 mtactic grammar (§9.1). 


NJ 


2.3 Lexical Analysis 

The input production defines the lexical structure of a C# source file. Each source file in a 
C# program must conform to this lexical grammar production. 

input: 

input-section 

input-section: 

input-section-part 
input-section input-section-part 

input-section-part: 

input-elements^^ new-line 
pp-directive 


67 


www.it-ebooks.info 


Lexical Structure 




Lexical Structure 


2. Lexical Structure 




input-elements: 

input-element 

input-elements input-element 

input-element: 

whitespace 

comment 

token 

Five basic elements make up the lexical structure of a C# source file: line terminators 
(§2.3.1), white space (§2.3.3), comments (§2.3.2), tokens (§2.4), and preprocessing directives 
(§2.5). Of these basic elements, only tokens are significant in the S 5 mtactic grammar of a C# 
program (§2.2.3). 

The lexical processing of a C# source file consists of reducing the file into a sequence of 
tokens, which then becomes the input to the syntactic analysis. Line terminators, white 
space, and comments can serve to separate tokens, and preprocessing directives can cause 
sections of the source file fo be skipped, but otherwise these lexical elements have no 
impact on the syntactic structure of a C# program. 

When several lexical grammar productions match a sequence of characters in a source file, 
fhe lexical processing always forms the longest possible lexical element. For example, the 
character sequence //is processed as the begirming of a single-line comment because that 
lexical element is longer than a single / token. 

2.3.1 Line Terminators 

Line terminators divide the characters of a C# source file into lines. 
new-line: 

Carriage return character (U+000D) 

Line feed character (U+000A) 

Carriage return character (U+000D) followed by line feed character (U+000A) 

Next line character (U+0085) 

Line separator character (U+2028) 

Paragraph separator character (U+2029) 

For compatibility with source code editing tools that add end-of-file markers, and to enable 
a source file to be viewed as a sequence of properly terminated lines, the following trans¬ 
formations are applied, in order, to every source file in a C# program: 

• If the last character of the source file is a Control-Z character (U+001A), this character is 
deleted. 


68 


www.it-ebooks.info 




2.3 Lexical Analysis 


• A carriage return character (U+000D) is added to the end of the source file if fhaf source 
file is non-empfy and if fhe lasf characfer of fhe source file is nof a carriage refurn 
(U+000D), a line feed (L)+000A), a line separator (U+2028), or a paragraph separafor 
(U+2029). 


2.3.2 Comments 

Two forms of commenfs are supporfed: single-line commenfs and delimifed commenfs. 
Single-line comments sfarf wifh fhe characfers // and exfend fo fhe end of fhe source line. 
Delimited comments sfarf wifh the characters /* and end with the characters */. Delimited 
comments may span multiple lines. 

comment: 

single-line-comment 
del im ited-commen t 

single-line-comment: 

II input-characters 

input-characters: 

input-character 

input-characters input-character 
input-character: 

Any Unicode character except a new-line-character 

new-line-character: 

Carriage return character (U+000D) 

Line feed characfer (U+000A) 

Nexf line characfer (U+0085) 

Line separafor characfer (U+2028) 

Paragraph separafor characfer (U+2029) 

delimited-comment: 

!* delimited-comment-text^ asterisks / 

delimited-comment-text: 

delimited-comment-section 

delimited-comment-text delimited-comment-section 

delimited-comment-section: 

/ 

asterisks , not-slash-or-asterisk 

opt 


NJ 


69 


www.it-ebooks.info 


Lexical Structure 




Lexical Structure 


2. Lexical Structure 


asterisks: 

* 

asterisks * 

not-slash-or-asterisk: 

Any Unicode character except / or * 

Comments do not nest. The character sequences /* and */ have no special meaning within 
a // comment, and the character sequences // and /* have no special meaning within a 
delimited comment. 

Comments are not processed within character and string literals. 

The example 

/* Hello, world program 

This program writes "hello, world" to the console 

*/ 

class Hello 
{ 

static void Main() { 

System.Console.WriteLine("hello, world"); 

} 

} 

includes a delimited comment. 

The example 

// Hello, world program 

// This program writes "hello, world" to the console 
// 

class Hello // any name will do for this class 
{ 

static void Main() { // this method must be named "Main" 

System.Console.WriteLine("hello, world"); 

} 

} 

shows several single-line comments. 

2.3.3 White Space 

White space is defined as any character with Unicode class Zs (which includes the space 
character) as well as the horizontal tab character, the vertical tab character, and the form 
feed characfer. 


70 


www.it-ebooks.info 




2.4 Tokens 


whitespace: 

Any character with Unicode class Zs 
Horizontal tab character (U+0009) 
Vertical tab character (U+000B) 

Form feed character (U+000C) 


2.4 Tokens 

There are several kinds of fokens: identifiers, keywords, literals, operators, and punctua¬ 
tors. White space and comments are not tokens, though they act as separators for fokens. 


NJ 


identifier 

keyword 

integer-literal 

real-literal 

character-literal 

string-literal 

operator-or-punctuator 

2.4.1 Unicode Character Escape Sequences 

A Unicode characfer escape sequence represents a Unicode character. Unicode character 
escape sequences are processed in identifiers (§2.4.2), character literals (§2.4.4.4), and regu¬ 
lar string literals (§2.4.4.5). A Unicode character escape is not processed in any other loca¬ 
tion (for example, fo form an operator, punctuator, or keyword). 

unicode-escape-sequence: 

\u hex-digit hex-digit hex-digit hex-digit 

\L) hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit 


"■ ERIC LIPPERT This practice differs from Java, in which Unicode escape sequences 
may appear almosf an 5 rwhere. 


A Unicode escape sequence represents the single Unicode character formed by the hexa¬ 
decimal number following the "\u" or "\U" characters. Since C# uses a 16-bit encoding of 
Unicode code points in characters and string values, a Unicode character in the range 
U+10000 to U+IOFFFF is not permitted in a character literal and is represented using a 


71 


www.it-ebooks.info 


Lexical Structure 






Lexical Structure 


2. Lexical Structure 




Unicode surrogate pair in a string literal. Unicode characters with code points above 
OxlOFFFF are not supported. 

Multiple translations are not performed. For instance, the string literal "\u005Cu005C" is 
equivalent to "\u005C" rather than "\". The Unicode value \u005C is the character "\". 

The example 

class Classl 
{ 

static void Test(bool \u0066) { 
char c = ’\u0066'; 
if (\u0066) 

System.Console.WriteLine(c.ToString()); 

} 

} 

shows several uses of \u0066, which is fhe escape sequence for fhe leffer "f". The program 
is equivalenf fo 

class Classl 
{ 

static void Test(bool f) { 
char c = 'f'; 
if (f) 

System.Console.WriteLine(c.ToString()); 

} 

} 


2.4.2 Identifiers 

The rules for idenfifiers given in fhis secfion correspond exacfly fo fhose recommended by 
fhe Unicode Sfandard Annex 31, excepf fhaf underscore is allowed as an initial characfer 
(as is fradifional in fhe C programming language), Unicode escape sequences are permif- 
fed in idenfifiers, and fhe characfer is allowed as a prefix fo enable ke 5 rwords fo be used 
as idenfifiers. 

identifier: 

available-identifier 
@ identifier-or-keyword 

available-identifier: 

An identifier-or-keyword fhaf is nof a keyword 
identifier-or-keyword: 

identifier-start-character identifier-part-characters 


72 


www.it-ebooks.info 




2.4 Tokens 


identifier-start-character: 

letter-character 

_ (the underscore character U+005F) 

identifier-part-characters: 

identifier-part-character 

identifier-part-characters identifier-part-character 

identifier-part-character: 

letter-character 

decimal-digit-character 

connecting-character 

combining-character 

formatting-character 

letter-character: 

A Unicode character of classes Lu, LI, Lt, Lm, Lo, or N1 

A unicode-escape-sequence representing a character of classes Lu, LI, Lf, Lm, Lo, or N1 
combining-character: 

A Unicode characfer of classes Mn or Me 

A unicode-escape-sequence representing a characfer of classes Mn or Me 

decimal-digit-character: 

A Unicode characfer of fhe class Nd 

A unicode-escape-sequence representing a characfer of fhe class Nd 

connecting-character: 

A Unicode characfer of fhe class Pc 

A unicode-escape-sequence representing a characfer of fhe class Pc 

formatting-character: 

A Unicode characfer of fhe class Cf 

A unicode-escape-sequence representing a characfer of fhe class Cf 

For informafion on fhe Unicode characfer classes mentioned above, see The Unicode Stan¬ 
dard, Version 3.0, section 4.5. 

Examples of valid identifiers include "identifier!", "_identifier2", and "@if". 

An identifier in a conforming program musf be in fhe canonical formal defined by Unicode 
Normalizafion Form C, as defined by Unicode Sfandard Annex 15. The behavior when 
encounfering an idenfifier nof in Normalizafion Form C is implemenfafion-defined; how¬ 
ever, a diagnosfic is nof required. 


NJ 


73 


www.it-ebooks.info 


Lexical Structure 




Lexical Structure 


2. Lexical Structure 


The prefix enables the use of ke 5 rwords as identifiers, which is useful when interfacing 
with other programming languages. The character @ is not actually part of the identifier, so 
the identifier might be seen in other languages as a normal identifier, without the prefix. 
An identifier with an @ prefix is called a verbatim identifier. Use of the @ prefix for identi¬ 
fiers that are not keywords is permitted, but strongly discouraged as a matter of style. 

The example 

class @class 
{ 

public static void @static(bool @bool) { 
if (@bool) 

System.Console.WriteLine("true"); 

else 

System.Console.WriteLine("false"); 

} 

} 

class Classl 
{ 

static void M() { 

cl\u0061ss.st\u0061tic(true); 

} 

} 

defines a class named "class" with a static method named "static" that takes a parameter 
named "bool". Note that since Unicode escapes are not permitted in keywords, the token 
"cl\u0061ss" is an identifier, and is fhe same identifier as "@class". 

Two identifiers are considered the same if they are identical after the following transforma¬ 
tions are applied, in order: 

• The prefix "@", if used, is removed. 

• Each unicode-escape-sequence is transformed into its corresponding Unicode character. 

• Any formatting-characters are removed. 

Identifiers containing two consecutive underscore characters (U+005F) are reserved for use 
by the implementation. For example, an implementation might provide extended key¬ 
words that begin with two underscores. 

2.4.3 Keywords 

A keyword is an identifier-like sequence of characters that is reserved, and carmot be used 
as an identifier except when prefaced by the @ character. 


74 


www.it-ebooks.info 




2.4 Tokens 


keyword: one of 


abstract 

as 

base 

bool 

break 

byte 

case 

catch 

char 

checked 

class 

const 

continue 

decimal 

default 

delegate 

do 

double 

else 

enum 

event 

explicit 

extern 

false 

finally 

fixed 

float 

for 

foreach 

goto 

if 

implicit 

in 

int 

interface 

internal 

is 

lock 

long 

namespace 

new 

null 

object 

operator 

out 

override 

params 

private 

protected 

public 

readonly 

ref 

return 

sbyte 

sealed 

short 

sizeof 

stackalloc 

static 

string 

struct 

switch 

this 

throw 

true 

try 

typeof 

uint 

ulong 

unchecked 

unsafe 

ushort 

using 

virtual 

void 

volatile 

while 





In some places in the grammar, specific identifiers have special meaning, but are not key¬ 
words. Such identifiers are sometimes referred to as "contextual ke 5 rwords." For example, 
within a property declaration, the "get" and "set" identifiers have special meaning 
(§10.7.2). An identifier other than get or set is never permitted in these locations, so this 
use does not conflict with a use of these words as identifiers. In other cases, such as with 
the identifier "var" in implicitly typed local variable declarations (§8.5.1), a contextual 
keyword can conflict with declared names. In such cases, the declared name takes prece¬ 
dence over the use of the identifier as a contextual ke 5 rword. 


“■ ERIC LIPPERT C# has not added any new reserved ke 5 rwords since its original 
release. All the new language features that require new ke 5 rwords (yield, select, and 
so on) use "contextual ke 5 rwords," which are not reserved and have special meaning 
only in context. This decision helps preserve backward compatibility with existing 
programs. 


■■ VLADIMIR RESHETNIKOV In case you need the full list of these contextual key¬ 
words (including supported attribute targets), here it is: 

add alias ascending assembly by descending dynamic equals field from get 
global group into join let method module on orderby param partial property 
remove select set type typevar value var where yield 


75 


www.it-ebooks.info 


Lexical Structure 








Lexical Structure 


2. Lexical Structure 


2.4.4 Literals 

A literal is a source code representation of a value. 
literal: 

boolean-literal 

integer-literal 

real-literal 

character-literal 

string-literal 

null-literal 

2.4.4.1 Boolean Literals 

There are two boolean literal values: true and false. 

boolean-literal: 

true 

false 

The t 5 ^e of a boolean-literal is bool. 

2.4.4.2 Integer Literals 

Integer literals are used to write values of types int, uint, long, and ulong. Integer literals 
have two possible forms: decimal and hexadecimal. 

integer-literal: 

decimal-integer-literal 

hexadecimal-integer-literal 

decimal-integer-literal: 

decimal-digits integer-type-suffix 

decimal-digits: 

decimal-digit 

decimal-digits decimal-digit 

decimal-digit: one of 

0123456789 

integer-type-suffix: one of 

U u L 1 UL U1 uL ul LU Lu lU lu 


76 


www.it-ebooks.info 




2.4 Tokens 


hexadecimal-mteger-literal: 

0x hex-digits integer-type-suffix 
0X hex-digits integer-type-suffix 

hex-digits: 

hex-digit 

hex-digits hex-digit 
hex-digit: one of 

0123456789ABCDEFabcdef 


"■ ERIC LIPPERT C# does not support octal literals, for two reasons. First, hardly 
anyone uses octal literals these days. Second, if C# supported octal in the standard 
"leading zero means octal" format, then it would be a potential source of errors. Con¬ 
sider this code: 

FlightNumber = 0541; 

Clearly this expression is intended as a decimal literal, not an octal literal. 


The t 5 ^e of an integer literal is determined as follows: 

• If the literal has no suffix, it has the first of these t 5 ^es in which its value can be repre¬ 
sented: int, uint, long, ulong. 

• If the literal is suffixed by U or u, it has the first of these types in which its value can be 
represented: uint, ulong. 

• If the literal is suffixed by L or 1, it has the first of these types in which its value can be 
represented: long, ulong. 

• If the literal is suffixed by UL, Ul, uL, ul, LU, Lu, lU, or lu, it is of type ulong. 

If the value represented by an integer literal is outside the range of the ulong type, a 

compile-time error occurs. 

As a matter of style, it is suggested that "L" be used instead of "1" when writing literals of 

type long, since it is easy to confuse the letter "1" with the digit "1". 

To permit the smallest possible int and long values to be written as decimal integer liter¬ 
als, the following two rules exist: 

• When a decimal-integer-literal with the value 2147483648 (2^^) and no integer-type-suffix 
appears as the token immediately following a unary minus operator token (§7.7.2), the 


NJ 


77 


www.it-ebooks.info 


Lexical Structure 






Lexical Structure 


2. Lexical Structure 


result is a constant of type int with the value -2147483648 (-2^^). In all other situations, 
such a decimal-integer-literal is of t 5 ^e uint. 

• When a decimal-integer-literal wifh fhe value 9223372036854775808 (2®) and no integer- 
type-suffix or fhe integer-type-suffix L or 1 appears as fhe foken immediafely following a 
unary minus operafor foken (§7.7.2), fhe resulf is a consfanf of t 5 ^e long wifh fhe value 
-9223372036854775808 (-2®). In all ofher sifuafions, such a decimal-integer-literal is of 
fype ulong. 




■■ JOSEPH ALBAHARI Thanks fo implicif consfanf expression conversions (§6.1.8), 
infeger liferals can be assigned direcfly fo fhe uint, long, and ulong f5q3es (as well as 
short, ushort, byte, and sbyte): 

uint X = 3; long y = 3; ulong z = 3; 

As a consequence, fhe U and L suffixes are rarely necessary. An example of when fhey 
are sfill useful is fo force 64-bif calculafions on liferals fhaf would ofherwise affracf 
32-bif arifhmefic: 

long error = 1000000 * 1000000 ; // Compile-time error (32-bit overflow) 

long trillion = 1000000L * 1000000L; // Okay -- no overflow 


2.4.4.3 Real Literals 

Real liferals are used fo wrife values of fypes float, double, and decimal. 
real-literal: 

decimal-digits . decimal-digits exponent-partreal-type-suffix 
. decimal-digits exponent-partreal-type-suffix 
decimal-digits exponent-part real-type-suffix 
decimal-digits real-type-suffix 

exponent-part: 

e sign^^ decimal-digits 
E sign^^ decimal-digits 

sign: one of 

+ 

real-type-suffix: one of 
F f D d M m 


78 


www.it-ebooks.info 






2.4 Tokens 


If no real-type-suffix is specified, fhe type of the real literal is double. Otherwise, the real 
type suffix determines the type of the real literal, as follows: 

• A real literal suffixed by F or f is of t 5 ^e float. For example, the literals If, 1.5f, lel0f, 
and 123.456F are all of t 5 ^e float. 

• A real literal suffixed by D or d is of type double. For example, the literals Id, 1 .5d, lel0d, 
and 123.456D are all of t 5 ^e double. 

• A real literal suffixed by M or m is of type decimal. For example, the literals Im, 1.5m, 
lel0m, and 123.456M are all of t 5 ^e decimal. This literal is converted to a decimal value 
by taking the exact value and, if necessary, rounding to the nearest representable value 
using banker's rounding (§4.1.7). Any scale apparent in the literal is preserved unless the 
value is rounded or the value is zero (in which latter case, the sign and scale will be 0). 
Hence the literal 2.900m will be parsed to form the decimal with sign 0, coefficient 2900, 
and scale 3. 

If the specified literal cannot be represented in the indicated type, a compile-time error 
occurs. 

The value of a real literal of 1)^0 float or double is determined by using the IEEE "round 
to nearest" mode. 

Note that in a real literal, decimal digits are always required after the decimal point. Eor 
example, 1.3F is a real literal but 1. F is not. 


NJ 


■■ JOSEPH ALBAHARI Of all the numeric suffixes, m and f are by far the most useful. 
Without these suffixes, a fractional float or decimal literal cannot be specified with¬ 
out a cast. Eor example, the following code will not compile, because the literal 1.5 
will be parsed as t 5 q)e double: 

float X = 1.5; // Error: no implicit conversion from double to float 

decimal y = 1.5; // Error: no implicit conversion from double to decimal 

Interestingly, the following code does compile, because C# defines an implicit conver¬ 
sion from int to decimal: 

decimal z = 123; // Okay: parsed as int, and then implicitly converted 

// to decimal 

The d suffix is technically redundant in that the presence of a decimal point does the 
same job: 

Console.WriteLine ((123.0).GetType() == typeof (double));// True 


79 


www.it-ebooks.info 


Lexical Structure 






Lexical Structure 


2. Lexical Structure 




2.4.4.4 Character Literals 

A character literal represents a single character, and usually consists of a character in 
quotes, as in ' a'. 

character-literal: 

' character ' 

character: 

single-character 

simple-escape-sequence 

hexadecimal-escape-sequence 

unicode-escape-sequence 

single-character: 

Any character except ' (U+0027), \ (U+005C), and new-line-character 

simple-escape-sequence: one of 

\' \" \\ \0 \a \b \f \n \r \t \v 

hexadecimal-escape-sequence: 

\x hex-digit hex-digithex-digit^^ hex-digit^^ 

A characfer fhaf follows a backslash characfer (\) in a character musf be one of fhe following 
characfers: ', ", \, 0, a, b, f, n, r, t, u, L), x, v. Ofherwise, a compile-fime error occurs. 

A hexadecimal escape sequence represenfs a single Unicode characfer, wifh fhe value 
formed by fhe hexadecimal number following "\x". 

If fhe value represenfed by a characfer liferal is greafer fhan U+FFFF, a compile-fime error 
occurs. 

A Unicode characfer escape sequence (§2.4.1) in a characfer liferal musf be in fhe range 
U+0000 fo U+FFFF. 

A simple escape sequence represenfs a Unicode characfer encoding, as described in fhe 
fable below. 


Escape Sequence 

Character Name 

Unicode Encoding 

\' 

Single quote 

0x0027 

\" 

Double quote 

0x0022 

W 

Backslash 

0X005C 


80 


www.it-ebooks.info 










2.4 Tokens 


Escape Sequence 

Character Name 

Unicode Encoding 

\0 

Null 

0X0000 

\a 

Alert 

0x0007 

\b 

Backspace 

0x0008 

\f 

Form feed 

0X000C 

\n 

New line 

0X000A 

\r 

Carriage return 

0X000D 

\t 

Horizontal tab 

0x0009 

\v 

Vertical tab 

0X000B 


The type of a character-literal is char. 

2.4.4.5 String Literals 

C# supports two forms of string literals: regular string literals and verbatim string 
literals. 

A regular string literal consists of zero or more characters enclosed in double quotes, as in 
"hello", and may include both simple escape sequences (such as \t for the tab character), 
and hexadecimal and Unicode escape sequences. 

A verbatim string literal consists of an @ character followed by a double-quote character, 
zero or more characters, and a closing double-quote character. A simple example is 
hello". In a verbatim string literal, the characters between the delimiters are interpreted 
verbatim, the only exception being a quote-escape-sequence. In particular, simple escape 
sequences and hexadecimal and Unicode escape sequences are not processed in verbatim 
string literals. A verbatim string literal may span multiple lines. 


■■ JONSKEET One aspect of verbatim string literals that makes me nervous is the 
way a line break will take on the form in which it occurs in the file. If's fhe natural 
option of course, buf if means swifching a file befween "\r\n" and "\n" line breaks 
isn't a purely decorative change: It can affect behavior, too. 


81 


www.it-ebooks.info 


Lexical Structure 

















Lexical Structure 


2. Lexical Structure 


fN 


string-literal: 

regular-string-literal 

verbatim-string-literal 

regu lar-s tring-1 i teral: 

" regular-string-literal-characters^^ " 

regular-string-literal-characters: 

regular-string-literal-character 

regular-string-literal-characters regular-string-literal-character 

regular-string-literal-character: 

single-regular-string-literal-character 

simple-escape-sequence 

hexadecimal-escape-sequence 

unicode-escape-sequence 

single-regular-string-literal-character: 

Any character except" (U+0022), \ (U+005C), and new-line-character 

verbatim-string-literal: 

verbatim-string-literal-characters^^ " 

verbatim-string-literal-characters: 

verbatim-string-literal-character 

verbatim-string-literal-characters verbatim-string-literal-character 

verbatim-string-literal-character: 

single-verbatim-string-literal-character 

quote-escape-sequence 

single-verbatim-string-literal-character: 

Any character except" 

quote-escape-sequence: 


A character that follows a backslash character (\) in a regular-string-literal-character must be 
one of fhe following characfers: ', 0, a, b, f, n, r, t, u, L), x, v. Ofherwise, a compile-fime 

error occurs. 


82 


www.it-ebooks.info 




2.4 Tokens 


The example 


string a = "hellOj world"; 
string b = @"hellOj world"; 

string c = "hello \t world"; 
string d = @"hello \t world"; 

string e = "Doe said \"Hello\" to me"; 
string f = @"Doe said ""Hello"" to me"; 

string g = "\\\\server\\share\\file.txt"; 
string h = @"\\server\share\file.txt"; 


string i 
string j 
two 

three"; 


"one\r\ntwo\r\nthree"; 

@"one 


// hello, world 
// hello, world 

// hello world 
// hello \t world 

// Doe said "Hello" to me 

// Doe said "Hello" to me 

// \\server\share\file.txt 
// \\server\share\file.txt 


shows a variety of string literals. The last string literal, j, is a verbatim string literal that 
spans multiple lines. The characters between the quotation marks, including white space 
such as new line characters, are preserved verbatim. 


■■ BRAD ABRAMS In the early days of the C# language design, we experimented 
with using the backtick (') character. Personally, 1 really liked this choice: The backtick 
is in the quote family and is a grossly underused character. In fact, it was so underused 
that some international keyboards don't even include a key for it. We were lucky to 
have such a good, early international following for C#, which allowed us to fix this 
potential error very early in the design of the language. 


NJ 


Since a hexadecimal escape sequence can have a variable number of hex digits, the string 
literal "\xl23" contains a single character with hex value 123. To create a string containing 
the character with hex value 12 followed by the character 3, one could write "\x00123" or 
"\xl2" + "3" instead. 


■■ JONSKEET Hexadecimal escape sequences aren't just rare—they're dangerous. 
While a string such as "\x9Tabbed" is reasonably clear, it's not nearly as obvious that 
"\x9Badly tabbed" actually begins with the Unicode character U+9BAD. 


The type of a string-literal is string. 

Each string literal does not necessarily result in a new string instance. When two or more 
string literals that are equivalent according to the string equality operator (§7.10.7) appear 


83 


www.it-ebooks.info 


Lexical Structure 








Lexical Structure 


2. Lexical Structure 




in the same program, these string literals refer to the same string instance. For instance, the 
output produced by 

class Test 
{ 

static void Main() { 
object a = "hello"; 
object b = "hello"; 

System.Console.WriteLine(a == b); 

} 

} 

is True because the two literals refer fo fhe same sfring insfance. 


■■ JOSEPH ALBAHARI This opfimizafion is called interning. One of fhe benefifs of 
infeming is fhaf if reduces fhe size of fhe compiled assembly because duplicafe sfring 
liferals are facfored ouf. 

In fhe preceding example, a and b are declared of tj^e object, which forces fhe sub- 
sequenf comparison fo use object's reference-fjq^e equalify semantics. If a and b were 
declared of fjqie string, fhe comparison would bind fo string's == operator, which 
evaluafes fo true if fhe sfrings have identical confenf—even if fhey refer fo differenf 
underlying objecfs. 


2.4.4.6 The null Literal 

null-literal: 

null 

The null-literal can be implicifly converted fo a reference type or nullable type. 


"■ ERIC LI PPERT The null literal expression itself does nof have a tjqre. 


2.4.5 Operators and Punctuators 

There are several kinds of operafors and puncfuafors. Operafors are used in expressions fo 
describe operations involving one or more operands. For example, fhe expression a + b 
uses fhe + operafor fo add fhe fwo operands a and b. Puncfuafors are for grouping and 
separating. 


84 


www.it-ebooks.info 








2.5 Preprocessing Directives 


operator-or-punctuator: one of 

{ } [ ] 

+ - * / 

= < > ? 

-> == != <= 

&= 1 = << 

right-shift: 

>l> 

right-shift-assignment: 

>l>= 

The vertical bars in the right-shift and right-shift-assignment productions are used to indicate 
that, unlike other productions in the syntactic grammar, no characters of any kind (not 
even white space) are allowed between the tokens. These productions are treated specially 
to enable the correct handling of type-parameter-lists (§10.1.3). 


% 

?? 

>= 

<<= 


) 

& 

+= 
= > 


! 

St& 

/= 


2.5 Preprocessing Directives 


“■ BILL WAG N E R This section shows how the C heritage colors so much of modern 
development. 1 rarely, if ever, use any of the preprocessing directives—^but 1 can only 
imagine the storm of criticism if C# had not included a strong set of preprocessing 
directives. 


NJ 


The preprocessing directives provide the ability to conditionally skip sections of source 
files, to report error and warning conditions, and to delineate distinct regions of source 
code. The term "preprocessing directives" is used only for consistency with the C and C++ 
programming languages. In C#, there is no separate preprocessing step; preprocessing 
directives are processed as part of the lexical analysis phase. 

pp-directive: 

pp-declaration 

pp-conditional 

pp-line 

pp-diagnostic 

pp-region 

pp-pragma 


85 


www.it-ebooks.info 


Lexical Structure 






Lexical Structure 


2. Lexical Structure 




The following preprocessing directives are available: 

• #define and #undef, which are used to define and undefine, respectively, conditional 
compilation symbols (§2.5.3). 

• #if, #elif, #else, and #endif, which are used to conditionally skip sections of source 
code (§2.5.4). 

• #line, which is used to control line numbers emitted for errors and warnings (§2.5.7). 

• terror and twarning, which are used to issue errors and warnings, respectively 
(§2.5.5). 

• tregion and tend region, which are used to explicitly mark sections of source code 
(§2.5.6). 

• tpragma, which is used to specify optional contextual information to the compiler 
(§2.5.8). 

A preprocessing directive always occupies a separate line of source code and always begins 
with a t character and a preprocessing directive name. White space may occur before the 
t character and between the t character and the directive name. 

A source line containing a ttdef ine, tundef, tif, telif, ttelse, tendif, or tline directive 
may end with a single-line comment. Delimited comments (the /* */ style of comments) 
are not permitted on source lines containing preprocessing directives. 

Preprocessing directives are not tokens and are not part of the S 5 mtactic grammar of C#. 
However, preprocessing directives can be used to include or exclude sequences of tokens 
and can in that way affect the meaning of a C# program. For example, when compiled, the 
program 

tdefine A 
#undef B 

class C 
{ 

#if A 

void F() {} 

#else 

void G() {} 

#endif 

#if B 

void H() {} 

#else 

void I() {} 

#endif 

} 


86 


www.it-ebooks.info 




2.5 Preprocessing Directives 


results in the exact same sequence of tokens as the program 

class C 
{ 

void F() {} 
void I() {} 


Thus, whereas lexically the two programs are quite different, syntactically they are 
identical. 


2.5.1 Conditional Compilation Symbols 

The conditional compilation functionality provided by the #if, #elif, #else, and #endif 
directives is controlled through preprocessing expressions (§2.5.2) and conditional compi¬ 
lation symbols. 

conditional-symbol: 

Any identifier-or-keyword except true or false 

A conditional compilation symbol has two possible states: defined or undefined. At the 
begirming of the lexical processing of a source file, a conditional compilation symbol is 
undefined unless it has been explicitly defined by an external mechanism (such as a com¬ 
mand-line compiler option). When a #def ine directive is processed, the conditional com¬ 
pilation symbol named in that directive becomes defined in that source file. The symbol 
remains defined until an #undef directive for that same symbol is processed, or until the 
end of the source file is reached. An implication of this is that #def ine and #undef direc¬ 
tives in one source file have no effect on other source files in the same program. 

When referenced in a preprocessing expression, a defined conditional compilation symbol 
has the boolean value true, and an undefined conditional compilation symbol has the 
boolean value false. There is no requirement that conditional compilation symbols be 
explicitly declared before they are referenced in preprocessing expressions. Instead, imde- 
clared symbols are simply undefined and thus have the value false. 

The name space for conditional compilation symbols is distinct and separate from all other 
named entities in a C# program. Conditional compilation symbols can only be referenced 
in #def ine and #undef directives and in preprocessing expressions. 

2.5.2 Preprocessing Expressions 

Preprocessing expressions can occur in #if and #elif directives. The operators ! =, 
&&, and I I are permitted in preprocessing expressions, and parentheses may be used for 
grouping. 


NJ 


87 


www.it-ebooks.info 


Lexical Structure 




Lexical Structure 


2. Lexical Structure 



pp-expression: 

whitespace^^ pp-or-expression zvhitespace^^ 


pp-or-expression: 

pp-and-expression 
pp-or-expression whitespace^^^ 


whitespace^^ pp-and-expression 


pp-and-expression: 

pp-equality-expression 

pp-and-expression whitespace^i && whitespace^^^ pp-equality-expression 


pp-equality-expression: 
pp-unary-expression 
pp-equality-expression zvhitespace^^ 
pp-equality-expression zvhitespace^^ 

pp-unary-expression: 

pp-primary-expression 
! ivhitespace^i pp-unary-expression 


pp-primary-expression: 
true 
false 

conditional-symbol 

( whitespace^^ pp-expression whitespace^^ ) 


whitespace^^ pp-unary-expression 
whitespace^^ pp-unary-expression 


Opt 


When referenced in a preprocessing expression, a defined conditional compilation symbol 
has the boolean value true, and an undefined conditional compilation symbol has the 
boolean value false. 

Evaluation of a preprocessing expression always yields a boolean value. The rules of eval¬ 
uation for a preprocessing expression are the same as those for a constant expression 
(§7.19), except that the only user-defined entities that can be referenced are conditional 
compilation symbols. 

2.5.3 Declaration Directives 

The declaration directives are used to define or undefine conditional compilation 
symbols. 


pp-declaration: 

whitespace 

whitespace^^ 


# whitespace^^ 

# whitespace 


define whitespace conditional-symbol pp-new-line 
undef whitespace conditional-symbol pp-new-line 


88 


pp-new-line: 

whitespace^^ single-line-commentnew-line 


www.it-ebooks.info 




2.5 Preprocessing Directives 


The processing of a #def ine directive causes the given conditional compilation symbol to 
become defined, starting with the source line that follows the directive. Likewise, the pro¬ 
cessing of a #undef directive causes the given conditional compilation symbol to become 
undefined, starting with the source line that follows the directive. 

Any #def ine and #undef directives in a source file must occur before the first token (§2.4) 
in the source file; otherwise, a compile-time error occurs. In intuitive terms, #def ine and 
#undef directives must precede any "real code" in the source file. 

The example 

tdefine Enterprise 

#if Professional || Enterprise 
#define Advanced 
#endif 

namespace Megacorp.Data 
{ 

#if Advanced 

class PivotTable {...} 

#endif 

} 

is valid because the #def ine directives precede the first token (the namespace ke 5 rword) in 
the source file. 

The following example results in a compile-time error because a #def ine follows real code: 

#define A 
namespace N 
{ 

#define B 
#if B 

class Classl {} 

#endif 

} 

A #def ine may define a conditional compilation symbol that is already defined, without 
there being any intervening #undef for that symbol. The example below defines a condi¬ 
tional compilation symbol A and then defines it again. 

#deflne A 
#deflne A 

A #undef may "undefine" a conditional compilation symbol that is not defined. The exam¬ 
ple below defines a conditional compilation symbol A and then undefines it twice; although 
the second #undef has no effect, it is still valid. 

#deflne A 
#undef A 
#undef A 


NJ 


89 


www.it-ebooks.info 


Lexical Structure 




Lexical Structure 


2. Lexical Structure 


fN 


2.5.4 Conditional Compilation Directives 

The conditional compilation directives are used to conditionally include or exclude por¬ 
tions of a source file. 


pp-conditional: 

pp-if-section pp-elif-sections^^ pp-else-section^^^ pp-endif 


pp-if-section: 

ivhitespace^^ # ivhitespace^^ if whitespace pp-expression pp-new-line 
conditional-section , 

opt 

pp-elif-sections: 

pp-elif-section 

pp-elif-sections pp-elif-section 


pp-elif-section: 

whitespace^^ # whitespace^^ elif whitespace pp-expression pp-new-line 
conditional-section , 

opt 

pp-else-section: 

whitespace^^ # whitespace^^ else pp-new-line conditional-section 
pp-endif: 

whitespace^^ # whitespace^^ endif pp-new-line 


conditional-section: 

input-section 

skipped-section 


skipped-section: 

skipped-section-part 
skipped-section skipped-section-part 


skipped-section-part: 

skipped-characters^^ new-line 
pp-directive 


skipped-characters: 

whitespace^^ not-number-sign input-characters 

not-number-sign: 

Any input-character except # 


90 


www.it-ebooks.info 




2.5 Preprocessing Directives 


As indicated by the syntax, conditional compilation directives must be written as sets con¬ 
sisting of, in order, an #if directive, zero or more #elif directives, zero or one #else direc¬ 
tive, and an #endif directive. Between the directives are conditional sections of source 
code. Each section is controlled by the immediately preceding directive. A conditional sec¬ 
tion may itself contain nested conditional compilation directives provided these directives 
form complete sets. 


■■ CHRIS SELLS I can see #if and #endif, but #elif? Is this a Santa's helper with 
a lisp? A hipster abbreviation for some large, gray, wrinkled animal? I'd have pre¬ 
ferred springing for the two extra characters in #elseif simply so I could actually 
remember it. . . 


A pp-conditional selects at most one of the contained conditional-sections for normal lexical 
processing: 

• The pp-expressions of the #if and #elif directives are evaluated in order until one yields 
true. If an expression yields true, the conditional-section of the corresponding directive 
is selected. 

• If all pp-expressions yield false, and if an #else directive is present, the conditional-section 
of the #else directive is selected. 

• Otherwise, no conditional-section is selected. 

The selected conditional-section, if any, is processed as a normal input-section: The source 
code contained in the section must adhere to the lexical grammar; tokens are generated 
from the source code in the section; and preprocessing directives in the section have the 
prescribed effects. 

The remaining conditional-sections, if any, are processed as skipped-sections: Except for pre¬ 
processing directives, the source code in the section need not adhere to the lexical gram¬ 
mar; no tokens are generated from the source code in the section; and preprocessing 
directives in the section must be lexically correct but are not otherwise processed. Within a 
conditional-section that is being processed as a skipped-section, any nested conditional-sections 
(contained in nested #if...#endif and #region...#endregion constructs) are also processed 
as skipped-sections. 

The following example illustrates how conditional compilation directives can nest: 

tdefine Debug // Debugging on 

#undef Trace // Tracing off 

class PurchaseTransaction 
{ 


NJ 


91 


www.it-ebooks.info 


Lexical Structure 






Lexical Structure 


2. Lexical Structure 


void Commit 0 { 

#if Debug 

CheckConsistencyO; 

#if Trace 

WriteToLog(this .ToStringO); 

#endif 

#endif 

CommitHelper(); 

} 

} 

Except for preprocessing directives, skipped source code is not subject to lexical analysis. 
For example, the following is valid despite the unterminated comment in the #else 
section: 

#define Debug // Debugging on 

class PurchaseTransaction 

{ 

void Commit 0 { 

#if Debug 

CheckConsistencyO; 

#else 

// Do something else 
#endif 

} 

} 

Note, however, that preprocessing directives are required to be lexically correct even in 
skipped sections of source code. 


"■ CH RIS SELLS Avoid the use of nested preprocessing directives if you can, simply 
because by default the most popular C# editor on the planet. Visual Studio, will 
arrange them along the left edge of your text file, making it very difficult to follow the 
nesting. For example, 

#define Debug // Debugging on 

#undef Trace // Tracing off 

class PurchaseTransaction { 
void Commit 0 { 

#if Debug 

CheckConsistencyO i 
#if Trace 

WriteToLog(this.ToString ()); 

#endif 

#endif 

CommitHelperO; 

} 


92 


www.it-ebooks.info 






2.5 Preprocessing Directives 


Preprocessing directives are not processed when they appear inside multi-line input ele¬ 
ments. For example, the program 

class Hello 
{ 

static void Main() { 

System.Console.WriteLine(@"hello, 

#if Debug 

World 

#else 

Nebraska 

#endlf 

} 

} 


NJ 


results in the output: 

hello, 

#if Debug 

world 

#else 

Nebraska 

#endlf 

In peculiar cases, the set of preprocessing directives that is processed might depend on the 
evaluation of the pp-expression. The example 

#if X 
/* 

#else 

/* *! class Q { } 

#endif 

always produces the same token stream (class Q { }), regardless of whether X is defined. 
If X is defined, the only processed directives are #if and #endif, due to the multi-line 
comment. If X is undefined, then three directives (#if, #else, #endif) are part of the 
directive set. 

2.5.5 Diagnostic Directives 

The diagnostic directives are used to explicitly generate error and warning messages that 
are reported in the same way as other compile-time errors and warnings. 

pp-diagnostic: 

whitespace^^ # whitespace^^ error pp-message 
whitespace^^ # whitespace^^ warning pp-message 


93 


www.it-ebooks.info 


Lexical Structure 




Lexical Structure 


2. Lexical Structure 




pp-message: 

new-line 

whitespace input-charactersnew-line 
The example 

#warning Code review needed before check-in 
#if Debug && Retail 

terror A build can't be both debug and retail 
tendif 

class Test {...} 

always produces a warning ("Code review needed before check-in"), and produces a com¬ 
pile-time error ("A build can't be both debug and retail") if the conditional symbols Debug 
and Retail are both defined. Note that a pp-message can contain arbitrary text; specifically, 
it need not contain well-formed tokens, as shown by the single quote in the word can't. 

2.5.6 Region Directives 

The region directives are used to explicitly mark regions of source code. 
pp-region: 

pp-start-region conditional-section^^ pp-end-region 
pp-start-region: 

whitespace^^ # whitespace^^ region pp-message 
pp-end-region: 

whitespace^^ # whitespace^^ end region pp-message 

No semantic meaning is attached to a region; regions are intended for use by the program¬ 
mer or by automated tools to mark a section of source code. The message specified in a 
#region or #endregion directive likewise has no semantic meaning; it merely serves to 
identify the region. Matching #region and #endregion directives may have different 
pp-messages. 

The lexical processing of a region 
#region 
#endregion 

corresponds exactly to the lexical processing of a conditional compilation directive of 
the form: 

#if true 

#endif 


94 


www.it-ebooks.info 




2.5 Preprocessing Directives 


2.5.7 Line Directives 

Line directives may be used to alter the line numbers and source file names that are 
reported by the compiler in output such as warnings and errors. 

Line directives are most commonly used in meta-programming tools that generate C# 
source code from some other text input. 

pp-line: 

whitespace # ivhitespace^^ line whitespace line-indicator pp-new-line 
line-indicator: 

decimal-digits whitespace file-name 

decimal-digits 

default 

hidden 

file-name: 

" file-name-characters " 

file-name-characters: 

file-name-character 

file-name-characters file-name-character 

file-name-character: 

Any input-character except " 

When no #line directives are present, the compiler reports true line numbers and source 
file names in its output. When processing a #line directive that includes a line-indicator 
that is not default, the compiler treats the line after the directive as having the given line 
number (and file name, if specified). 


NJ 


■■ JONSKEET If you're writing a tool that generates code from some ofher source, 
you might think that the easiest approach is to just include a #line directive for every 
line you oufpuf. It's not quite that simple, however: A #line directive within a verba¬ 
tim string literal ends up as part of the string, rather than being treated as a directive. 
So the following code almosf cerfainly doesn'f work as infended: 

#line 5 

Console.WriteLine(@"First line 
#line 6 
Second line"); 


95 


www.it-ebooks.info 


Lexical Structure 






Lexical Structure 


2. Lexical Structure 




A #line default directive reverses the effect of all preceding #line direcfives. The compiler 
reporfs true line information for subsequenf lines, precisely as if no #line direcfives had 
been processed. 

A #line hidden directive has no effecf on the file and line numbers reporfed in error mes¬ 
sages, buf does affect source-level debugging. When debugging, all lines between a #line 
hidden directive and the subsequent #line directive (that is not #line hidden) have no line 
number information. When stepping through code in the debugger, these lines will be 
skipped entirely. 

Note that a file-name differs from a regular sfring liferal in that escape characters are not 
processed; the '\' character simply designates an ordinary backslash character within a 
file-name. 

2.5.8 Pragma Directives 

The #pragma preprocessing directive is used to specify optional confextual information to 
the compiler. The information supplied in a #pragma directive will never change program 
semantics. 

pp-pragma: 

ivhitespace^^ # ivhitespace^^ pragma whitespace pragma-body pp-new-line 

pragma-body: 

pragma-warning-body 

C# provides #pragma directives to control compiler warnings. Future versions of fhe lan¬ 
guage may include additional #pragma direcfives. To ensure interoperability with other C# 
compilers, the Microsoft C# compiler does not issue compilation errors for unknown 
#pragma direcfives; such direcfives do, however, generafe warnings. 


2.5.8.1 Pragma Warning 

The #pragma warning directive is used fo disable or restore all or a particular sef of warning 
messages during compilafion of fhe subsequenf program fexf. 

pragma-warning-body: 

warning whitespace warning-action 

warning whitespace warning-action whitespace warning-list 

warning-action: 

disable 

restore 


96 


www.it-ebooks.info 




2.5 Preprocessing Directives 


warning-list: 

decimal-digits 

warning-list whitespace^^ , whitespace^^ decimal-digits 

A #pragma warning directive that omits the warning list affects all warnings. A #pnagma 
warning directive that includes a warning list affects only those warnings that are specified 
in the list. 


■■ JONSKEET I'm not sure that defaulting to affecting all warnings is a good idea. 
Requiring an explicit "all" as an alternative warning list wouldn't have conflicted with 
any other warnings (because individual warnings have to be numeric) and it would 
make the meaning a good deal clearer. Having said this. I've never seen anyone dis¬ 
able all warnings—and I hope never to do so. 


A #pragma warning disable directive disables all or the given set of warnings. 

A #pragma warning restore directive restores all or the given set of warnings to the state 
that was in effect at the beginning of the compilation unit. Note that if a particular warning 
was disabled externally, a #pragma warning restore (whether for all or the specific warn¬ 
ing) will not re-enable that warning. 

The following example shows use of #pragma warning to temporarily disable the warning 
reported when obsoleted members are referenced, using the warning number from the 
Microsoft C# compiler. 

using System; 

class Program 
{ 

[Obsolete] 

static void Foo() {} 

static void Main() { 

#pragma warning disable 612 
Foo(); 

#pragma warning restore 612 
} 

} 


NJ 


■■ JOSEPH ALBAHARI The compiler generates a warning when it detects a condi¬ 
tion that might possibly indicate a mistake in the code. Because of the potential for 
false positives, the ability to disable certain warnings over selected lines of code is 
important in maintaining a good signal-to-noise ratio—so that the real mistakes are 
noticed. It's also essential if you want to instruct the compiler to treat warnings as 
errors—something I do in my own projects 


www.it-ebooks.info 


Lexical Structure 








This page intentionally left blank 


www.it-ebooks.info 


3. Basic Concepts 


3.1 Application Start-up 

An assembly that has an entry point is called an application. When an application is run, 
a new application domain is created. Several different instantiations of an applicafion may 
exisf on fhe same machine af fhe same fime, and each has ifs own applicafion domain. 

An applicafion domain enables applicafion isolafion by acting as a confainer for applica¬ 
fion sfafe. An applicafion domain acfs as a confainer and boundary for fhe f 5 ^es defined in 
fhe applicafion and fhe class libraries if uses. Types loaded info one applicafion domain are 
disfincf from fhe same t 5 ^e loaded info anofher applicafion domain, and insfances of 
objecfs are nof direcfly shared between applicafion domains. For insfance, each applicafion 
domain has ifs own copy of sfafic variables for fhese fypes, and a sfafic consfrucfor for a 
fype is run af mosf once per applicafion domain. Implemenfafions are free fo provide 
implemenfafion-specific policy or mechanisms for fhe creation and desfrucfion of applica¬ 
fion domains. 

Application start-up occurs when fhe execution environmenf calls a designafed mefhod, 
which is referred fo as fhe applicafion's enfry poinf. This enfry poinf mefhod is always 
named Main, and can have one of fhe following signafures: 

static void Main() {...} 

static void Main(string[] args) {... } 

static int Main() {...} 

static int Main(string [] args) {...} 

As shown, fhe entry point may optionally return an int value. This return value is used in 
application termination (§3.2). 

The entry point may optionally have one formal paramefer. The paramefer may have any 
name, buf fhe f 5 ^e of fhe paramefer musf be string []. If fhe formal paramefer is presenf, 
fhe execufion environmenf creafes and passes a string [ ] argumenf confaining fhe com¬ 
mand-line argumenfs fhaf were specified when fhe applicafion was sfarfed. The string[ ] 
argumenf is never null, buf if may have a lengfh of zero if no command-line argumenfs 
were specified. 


www.it-ebooks.info 




Basic Concepts 


3. Basic Concepts 


Since C# supports method overloading, a class or struct may contain multiple definitions 
of some method, provided each has a different signature. However, within a single pro¬ 
gram, no class or struct may contain more than one method called Main whose definition 
qualifies it to be used as an application entry point. Other overloaded versions of Main are 
permitted, however, provided they have more than one parameter, or their only parameter 
is other than type string[]. 

An application can be made up of multiple classes or structs. It is possible for more than 
one of these classes or structs to contain a method called Main whose definition qualifies it 
to be used as an application entry point. In such cases, an external mechanism (such as a 
command-line compiler option) must be used to select one of these Main methods as the 
entry point. 


■■ ERIC UPPER! The "esc" command-line compiler provides the /main: switch for 
this purpose. 


In C#, every method must be defined as a member of a class or struct. Ordinarily, the 
declared accessibility (§3.5.1) of a method is determined by the access modifiers (§10.3.5) 
specified in its declaration, and similarly the declared accessibility of a t 5 q)e is determined 
by the access modifiers specified in its declaration. For a given method of a given type to 
be callable, both the type and the member must be accessible. However, the application 
entry point is a special case. Specifically, the execution environment can access the applica¬ 
tion's entry point regardless of its declared accessibility and regardless of the declared 
accessibility of its enclosing type declarations. 

The application entry point method may not be in a generic class declaration. 

In all other respects, entry point methods behave like those that are not entry points. 

3.2 Application Termination 

Application termination returns control to the execution environment. 

If the return type of the application's entry point method is int, the value returned serves 
as the application's termination status code. The purpose of this code is to allow commu¬ 
nication of success or failure to the execution environment. 

If the return t 5 q)e of the entry point method is void, reaching the right brace (}) that termi¬ 
nates the method, or executing a return statement that has no expression, results in a ter¬ 
mination status code of 0. 


100 


www.it-ebooks.info 






3.3 Declarations 


“■ BILL WAGNER The following rule is an important difference between C# and 
other managed environments. 


Prior to an application's termination, destructors for all of its objects that have not yet been 
garbage collected are called, unless such cleanup has been suppressed (by a call to the 
library method GC.SuppressFinalize, for example). 


3.3 Declarations 

Declarations in a C# program define the constituent elements of the program. C# programs 
are organized using namespaces (§9), which can contain type declarations and nested 
namespace declarations. Type declarations (§9.6) are used to define classes (§10), structs 
(§10.14), interfaces (§13), enums (§14), and delegates (§15). The kinds of members permit¬ 
ted in a type declaration depend on the form of the type declaration. For instance, class 
declarations can contain declarations for constants (§10.4), fields (§10.5), methods (§10.6), 
properties (§10.7), events (§10.8), indexers (§10.9), operators (§10.10), instance constructors 
(§10.11), static constructors (§10.12), destructors (§10.13), and nested types (§10.3.8). 

A declaration defines a name in the declaration space to which the declaration belongs. 
Except for overloaded members (§3.6), it is a compile-time error to have two or more dec¬ 
larations that introduce members with the same name in a declaration space. It is never 
possible for a declaration space to contain different kinds of members with the same 
name. For example, a declaration space can never contain a field and a method by the 
same name. 


"■ ERIC LIPPERT "Declaration spaces" are frequently confused with "scopes." 
Although related conceptually, the two have quite different purposes. The scope of a 
named element is the region of the program text in which that element may be referred 
to by name without additional qualification. By contrast, the declaration space of an 
element is the region in which no two elements may have the same name. (Well, 
almost—methods may have the same name if they differ in signature, and t 5 q)es may 
have the same name if they differ in generic arity.) 


yj 


There are several different t 5 q)es of declaration spaces. 

• Within all source files of a program, namespace-member-declarations with no enclosing 
namespace-declaration are members of a single combined declaration space called the 
global declaration space. 


101 


www.it-ebooks.info 


Basic Concepts 








Basic Concepts 


3. Basic Concepts 


(n 


• Within all source files of a program, namespace-member-dedarations wifhin namespace- 
dedarations fhaf have fhe same fully qualified namespace name are members of a single 
combined declarafion space. 

• Each class, sfrucf, or inferface declarafion creafes a new declarafion space. Names are 
infroduced info fhis declarafion space fhrough dass-member-dedarations, strud-member- 
dedarations, interface-member-dedarations, or type-parameters. Excepf for overloaded 
insfance consfrucfor declarafions and sfafic consfrucfor declarafions, a class or sfrucf 
cannof confain a member declarafion wifh fhe same name as fhe class or sfrucf. A class, 
sfrucf, or inferface permifs fhe declarafion of overloaded mefhods and indexers. Eur- 
fhermore, a class or sfrucf permifs fhe declarafion of overloaded insfance consfrucfors 
and operafors. Eor example, a class, sfrucf, or inferface may confain mulfiple mefhod 
declarafions wifh fhe same name, provided fhese mefhod declarafions differ in fheir 
signafure (§3.6). Nofe fhaf base classes do nof confribufe fo fhe declarafion space of a 
class, and base inferfaces do nof confribufe fo fhe declarafion space of an inferface. Thus 
a derived class or inferface is allowed fo declare a member wifh fhe same name as an 
inherifed member. Such a member is said fo hide fhe inherifed member. 

• Each delegafe declarafion creafes a new declarafion space. Names are infroduced into 
this declaration space through formal parameters (fixed-parameters and parameter-arrays) 
and type-parameters. 

• Each enumeration declaration creates a new declaration space. Names are introduced 
into this declaration space through enum-member-dedarations. 

• Each method declaration, indexer declaration, operator declaration, instance construc¬ 
tor declaration, and anonymous function creates a new declaration space called a local 
variable declaration space. Names are introduced into this declaration space through 
formal parameters (fixed-parameters and parameter-arrays) and type-parameters. The body 
of the fimction member or anonymous function, if any, is considered to be nested within 
the local variable declaration space. It is an error for a local variable declaration space 
and a nested local variable declaration space to contain elements with the same name. 
Thus, within a nested declaration space, it is not possible to declare a local variable or 
constant with the same name as a local variable or constant in an enclosing declaration 
space. It is possible for two declaration spaces to contain elements with the same name 
as long as neither declaration space contains the other. 

• Each block or szvitch-block, as well as each for, foreach, and using statement, creates a 
local variable declaration space for local variables and local constants. Names are intro¬ 
duced into this declaration space through local-variable-dedarations and local-constant- 
dedarations. Note that blocks that occur as or within the body of a function member or 
anonymous function are nested within the local variable declaration space declared by 


102 


www.it-ebooks.info 




3.3 Declarations 


those functions for fheir paramefers. Thus if is an error fo have, for example, a mefhod 
wifh a local variable and a paramefer of fhe same name. 

• Each block or sivitch-block creafes a separafe declaration space for labels. Names are infro- 
duced info fhis declarafion space fhrough labeled-statements, and fhe names are refer¬ 
enced through goto-statements. The label declaration space of a block includes any nesfed 
blocks. Thus, wifhin a nesfed block, if is nof possible fo declare a label wifh fhe same 
name as a label in an enclosing block. 

The fexfual order in which names are declared is generally of no significance. In particular, 
fexfual order is nof significanf for fhe declarafion and use of namespaces, consfanfs, mefh- 
ods, properties, evenfs, indexers, operafors, insfance consfrucfors, desfrucfors, sfafic con- 
sfrucfors, and fypes. Declarafion order is significanf in fhe following ways: 

• Declarafion order for field declarations and local variable declarations defermines fhe 
order in which fheir inifializers (if any) are execufed. 

• Local variables musf be defined before fhey are used (§3.7). 

• Declarafion order for enum member declarations (§14.3) is significant when constant- 
expression values are omitted. 

The declaration space of a namespace is "open-ended," and fwo namespace declarafions 
wifh fhe same fully qualified name confribufe fo fhe same declarafion space. For 
example: 


yj 


namespace Megacorp.Data 
{ 

class Customer 
{ 

} 

} 

namespace Megacorp.Data 
{ 

class Order 
{ 

} 

} 

The fwo namespace declarafions above confribufe fo fhe same declarafion space, in fhis 
case declaring fwo classes wifh fhe fully qualified names Megacorp.Data.Customer and 
Megacorp.Data.Order. Because fhe fwo declarafions confribufe fo fhe same declarafion 
space, if would have caused a compile-fime error if each confained a declaration of a class 
wifh fhe same name. 


103 


www.it-ebooks.info 


Basic Concepts 




Basic Concepts 


3. Basic Concepts 


“■ Bl LL WAGNER Think of namespaces as a tool to manage the logical organiza¬ 
tion of your code. By comparison, assemblies manage the physical organization of 
your code. 


(n 


As specified above, the declaration space of a block includes any nested blocks. Thus, in 
the following example, the F and G methods result in a compile-time error because the 
name i is declared in the outer block and carmot be redeclared in the irmer block. However, 
the H and I methods are valid because the two i's are declared in separate non-nested 
blocks. 

class A 
{ 

void F() 

{ 

int 1 = 0; 
if (true) 

{ 

int 1=1; 

} 

} 

void G() 

{ 

if (true) 

{ 

int i = 0; 

} 

int 1=1; 

} 

void H() 

{ 

if (true) 

{ 

int i = 0; 

} 

if (true) 

{ 

int i = 1; 

} 

} 


void I() 



{ 



for 

(int i = 0; 

i < 10; i++) 


H(); 


for 

(int i = 0; 

i < 10; i++) 


H(); 



} 


104 


www.it-ebooks.info 






3.4 Members 


3.4 Members 

Namespaces and types have members. The members of an entity are generally available 
through the use of a qualified name that starts with a reference to the entity, followed by a 
"." token, followed by the name of the member. 

Members of a type are either declared in the t 5 q)e declaration or inherited from the base 
class of the type. When a type inherits from a base class, all members of the base class, 
except instance constructors, destructors, and static constructors, become members of the 
derived type. The declared accessibility of a base class member does not control whether 
the member is inherited—inheritance extends to any member that isn't an instance con¬ 
structor, static constructor, or destructor. However, an inherited member may not be acces¬ 
sible in a derived type, either because of its declared accessibility (§3.5.1) or because it is 
hidden by a declaration in the type itself (§3.7.1.2). 

3.4.1 Namespace Members 

Namespaces and types that have no enclosing namespace are members of the global 
namespace. This corresponds directly to the names declared in the global declaration 
space. 

Namespaces and types declared within a namespace are members of that namespace. This 
corresponds directly to the names declared in the declaration space of the namespace. 

Namespaces have no access restrictions. It is not possible to declare private, protected, or 
internal namespaces, and namespace names are always publicly accessible. 

3.4.2 Struct Members 

The members of a struct are the members declared in the struct and the members inherited 
from the struct's direct base class System. ValueType and the indirect base class object. 

The members of a simple type correspond directly to the members of the struct t 5 q)e aliased 
by the simple type: 

• The members of sbyte are the members of the System. SByte struct. 

• The members of byte are the members of the System. Byte struct. 

• The members of short are the members of the System. Intl6 struct. 

• The members of ushort are the members of the System. UIntl6 struct. 

• The members of int are the members of the System. Int32 struct. 

• The members of uint are the members of the System. UInt32 struct. 

• The members of long are the members of the System. Int64 struct. 


yj 


105 


www.it-ebooks.info 


Basic Concepts 




Basic Concepts 


3. Basic Concepts 


• The members of ulong are the members of the System. UInt64 struct. 

• The members of char are the members of the System.Char struct. 

• The members of float are the members of the System. Single struct. 

• The members of double are the members of the System. Double struct. 

• The members of decimal are the members of the System. Decimal struct. 

• The members of bool are the members of the System. Boolean struct. 

3.4.3 Enumeration Members 

The members of an enumeration are the constants declared in the enumeration and the 
members inherited from the enumeration's direct base class System. Enum and the indirect 
base classes System.ValueType and object. 


(n 


3.4.4 Class Members 

The members of a class are the members declared in the class and the members inherited 
from the base class (except for class object, which has no base class). The members inher¬ 
ited from the base class include the constants, fields, methods, properties, events, indexers, 
operators, and types of the base class, but not the instance constructors, destructors, and 
static constructors of the base class. Base class members are inherited without regard to 
their accessibility. 

A class declaration may contain declarations of constants, fields, methods, properties, 
events, indexers, operators, instance constructors, destructors, static constructors, and 
types. 

The members of object and string correspond directly to the members of the class types 
they alias: 

• The members of object are the members of the System. Object class. 

• The members of string are the members of the System. String class. 


3.4.5 Interface Members 

The members of an interface are the members declared in the interface and in all base inter¬ 
faces of the interface. The members in class object are not, strictly speaking, members of 
any interface (§13.2). However, the members in class object are available via member 
lookup in any interface type (§7.4). 

3.4.6 Array Members 

The members of an array are the members inherited from class System. Array. 


106 


www.it-ebooks.info 




3.5 Member Access 


3.4.7 Delegate Members 

The members of a delegate are the members inherited from class System.Delegate. 


"■ VLADIMIR RESHETNIKOV In the Microsoft implementation of C#, the members 
of a delegate also include the instance methods Invoke, Begininvoke, and Endinvoke, 
and the members inherited from class System.MulticastDelegate. 


■■ JON SKEET The Invoke, Begininvoke, and Endinvoke methods mentioned by 
Vladimir carmot be specified within the Delegate or MulticastDelegate types, as they 
depend on the parameters and return type of the delegate. This is an example of 
parameterized typing that generics couldn't quite handle even if it had been present 
from the first version of C#. 


3.5 Member Access 

Declarations of members allow control over member access. The accessibility of a member 
is established by the declared accessibility (§3.5.1) of the member combined with the acces¬ 
sibility of the immediately containing type, if any. 

When access to a particular member is allowed, the member is said to be accessible. Con¬ 
versely, when access to a particular member is disallowed, the member is said to be inac¬ 
cessible. Access to a member is permitted when the textual location in which the access 
takes place is included in the accessibility domain (§3.5.2) of the member. 

3.5.1 Declared Accessibility 

The declared accessibility of a member can be one of the following: 

• Public, which is selected by including a public modifier in the member declaration. The 
intuitive meaning of public is "access not limited." 

• Protected, which is selected by including a protected modifier in the member declara¬ 
tion. The intuitive meaning of protected is "access limited to the containing class or 
types derived from the containing class." 

• Internal, which is selected by including an internal modifier in the member declaration. 
The intuitive meaning of internal is "access limited to this program." 

• Protected internal (meaning protected or internal), which is selected by including both 
a protected and an internal modifier in the member declaration. The intuitive meaning 


yj 


107 


www.it-ebooks.info 


Basic Concepts 








Basic Concepts 


3. Basic Concepts 


of protected internal is "access limited to this program or types derived from the con¬ 
taining class." 

• Private, which is selected by including a private modifier in the member declaration. 
The intuitive meaning of private is "access limited to the containing type." 


"■ JESSE LIBERTY While there is always a default accessibility, it is good program¬ 
ming practice to declare the accessibility explicitly. This makes for code that is easier 
to read and far easier to maintain. 


(n 


■■ JONSKEET The default accessibility is nicely chosen in C#: It's always the most 
restrictive level available, with the exception of making a property getter/setter more 
restrictive than the overall property declaration. 1 used to prefer to leave the accessibil¬ 
ity as an implicit value, but Tve come around to Jesse's point of view over time. Mak¬ 
ing anything explicit indicates that you are aware that a choice exists, and that you 
have deliberately chosen this particular option. If you leave the choice implicit, it 
could be because you wanted that option—or it could be because you forgot there was 
a choice to make in the first place. 


Depending on the context in which a member declaration takes place, only certain types of 
declared accessibility are permitted. Furthermore, when a member declaration does not 
include any access modifiers, the context in which the declaration takes place determines 
the default declared accessibility. 

• Namespaces implicitly have public declared accessibility. No access modifiers are 
allowed on namespace declarations. 

• Types declared in compilation units or namespaces can have public or internal declared 
accessibility and default to internal declared accessibility. 

• Class members can have any of the five kinds of declared accessibility and default to 
private declared accessibility. (Note that a type declared as a member of a class can have 
any of the five kinds of declared accessibility, whereas a t 5 ^e declared as a member of a 
namespace can have only public or internal declared accessibility.) 


"■ VLADIMIR RESHETNIKOV If a sealed class declares a protected or protected 
internal member, a warning is issued. If a static class declares a protected or 
protected internal member, a compile-time error occurs (CS1057). 


108 


www.it-ebooks.info 










3.5 Member Access 


• Struct members can have public, internal, or private declared accessibility and default 
to private declared accessibility because structs are implicitly sealed. Struct members 
introduced in a struct (that is, not inherited by that struct) cannot have protected or 
protected internal declared accessibility. (Note that a t 5 ^e declared as a member of a 
sfrucf can have public, internal, or private declared accessibilify, whereas a f 5 ^e declared 
as a member of a namespace can have only public or internal declared accessibilify.) 

• Inf erf ace members implicifly have public declared accessibilify. No access modifiers are 
allowed on inf erf ace member declarafions. 

• Enumerafion members implicifly have public declared accessibilify. No access modifi¬ 
ers are allowed on enumerafion member declarafions. 


“■ VLADIMIR RESHETNIKOV The wording "enumerafion members" here means 
"members, declared in an enumerafion." Enumerafions also inherif members from 
fheir base classes System. Enum, System.ValueType, and System.Object, and fhose 
members can be non-public. 


"■ JOSEPH ALBAHARI The rationale behind fhese rules is fhaf fhe defaulf declared 
accessibilify for any consfrucf is fhe minimum accessibilify fhaf if requires fo be useful. 
Minimizing accessibilify is posifive in fhe sense fhaf if promofes encapsulafion. 


■■ JESSE LIBERTY Thaf said, if is good programming pracfice fo make fhe accessi¬ 
bilify explicif, which makes your code much easier fo mainfain. 


"■ ERIC LIPPERT There is a difference befween fhe "declared" accessibilify and fhe 
acfual effective accessibilify. Eor example, a mefhod declared as public on a class 
declared as internal is, for mosf pracfical purposes, an infernal mefhod. 

A good way fo fhink abouf fhis issue is fo recognize fhaf a public class member is 
public only fo fhe enfifies fhaf have access fo fhe class. 


■■ JONSKEET One nofable exception fo Eric's annofafion is when you're overriding 
a public mefhod wifhin an internal (or even private) class—including implemenf- 
ing an inferface. Many inferface implemenfafions will be wifhin internal classes, buf 
insfances may still be available fo ofher assemblies via fhe inferface. 


109 


www.it-ebooks.info 


Basic Concepts 














Basic Concepts 


3. Basic Concepts 


(n 


3.5.2 Accessibility Domains 

The accessibility domain of a member consists of the (possibly disjoint) sections of pro¬ 
gram text in which access to the member is permitted. For purposes of defining the acces¬ 
sibility domain of a member, a member is said to be top-level if it is not declared within a 
type, and a member is said to be nested if it is declared within another type. Furthermore, 
the program text of a program is defined as all program text contained in all source files of 
the program, and the program text of a type is defined as all program text contained in the 
type-declarations of that type (including, possibly, types that are nested within the type). 

The accessibility domain of a predefined type (such as object, int, or double) is 
unlimited. 

The accessibility domain of a top-level unbound type T (§4.4.3) that is declared in a pro¬ 
gram P is defined as follows: 

• If the declared accessibility of T is public, the accessibility domain of T is the program 
text of P and any program that references P. 

• If the declared accessibility of T is internal, the accessibility domain of T is the program 
text of P. 

From these definitions, it follows that the accessibility domain of a top-level unbound type 
is always at least the program text of the program in which that t 5 ^e is declared. 

The accessibility domain for a constructed type T<Aj , ..., A|^> is the intersection of the acces¬ 
sibility domain of the unbound generic t 5 ^e T and the accessibility domains of the type 
arguments Aj, ...,A^. 

The accessibility domain of a nested member M declared in a t 5 ^e T within a program P is 
defined as follows (noting that M itself may possibly be a t 5 ^e): 

• If the declared accessibility of M is public, the accessibility domain of M is the accessibil¬ 
ity domain of T. 

• If the declared accessibility of M is protected internal, let D be the union of the program 
text of P and the program text of any type derived from T, which is declared outside P. 
The accessibility domain of M is the intersection of the accessibility domain of T with D. 

• If the declared accessibility of M is protected, let D be the union of the program text of T 
and the program text of any type derived from T. The accessibility domain of M is the 
intersection of the accessibility domain of T with D. 

• If the declared accessibility of M is internal, the accessibility domain of M is the intersec¬ 
tion of the accessibility domain of T with the program text of P. 

• If the declared accessibility of M is private, the accessibility domain of M is the program 
text of T. 


110 


www.it-ebooks.info 




3.5 Member Access 


From these definitions, it follows fhaf fhe accessibilify domain of a nesfed member is 
always af leasf fhe program fexf of fhe fype in which fhe member is declared. Furfhermore, 
if follows fhaf fhe accessibilify domain of a member is never more inclusive fhan fhe acces¬ 
sibilify domain of fhe t 5 ^e in which fhe member is declared. 

In infuifive ferms, when a fype or member M is accessed, fhe following sfeps are evaluafed 
fo ensure fhaf fhe access is permiffed: 

• Firsf, if M is declared wifhin a fype (as opposed fo a compilation unif or a namespace), a 
compile-fime error occurs if fhaf t 5 ^e is nof accessible. 

• Then, if M is public, fhe access is permiffed. 

• Ofherwise, if M is protected internal, fhe access is permiffed if if occurs wifhin fhe 
program in which M is declared, or if if occurs wifhin a class derived from fhe class in 
which M is declared and fakes place fhrough fhe derived class type (§3.5.3). 

• Otherwise, if M is protected, fhe access is permiffed if if occurs wifhin fhe class in which 
M is declared, or if if occurs wifhin a class derived from fhe class in which M is declared 
and fakes place fhrough fhe derived class fype (§3.5.3). 

• Ofherwise, if M is internal, fhe access is permiffed if if occurs wifhin fhe program in 
which M is declared. 

• Ofherwise, if M is private, fhe access is permiffed if if occurs wifhin fhe t 5 ^e in which M 
is declared. 

• Ofherwise, fhe fype or member is inaccessible, and a compile-fime error occurs. 

In fhe example 

public class A 
{ 

public static int X; 
internal static int Y; 
private static int Z; 

} 

internal class B 
{ 

public static int X; 
internal static int Y; 
private static int Z; 

public class C 
{ 

public static int X; 
internal static int Y; 
private static int Z; 

} 

private class D 


yj 


111 


www.it-ebooks.info 


Basic Concepts 




Basic Concepts 


3. Basic Concepts 


{ 

public static int X; 
internal static int Y; 
private static int Z; 

} 

} 

the classes and members have the following accessibility domains: 

• The accessibility domain of A and A. X is unlimited. 

• The accessibility domain of A. Y, B, B. X, B. Y, B. C, B. C. X, and B. C. Y is the program text of 
the containing program. 

• The accessibility domain of A. Z is the program text of A. 

• The accessibility domain of B. Z and B. D is the program text of B, including the program 
text of B. C and B. D. 

• The accessibility domain of B. C. Z is the program text of B. C. 

• The accessibility domain of B. D. X and B. D. Y is the program text of B, including the pro¬ 
gram text of B. C and B. D. 

• The accessibility domain of B. D. Z is the program text of B. D. 

As the example illustrates, the accessibility domain of a member is never larger than that 
of a containing type. For example, even though all X members have public declared acces¬ 
sibility, all but A. X have accessibility domains that are constrained by a containing type. 


■■ JOSEPH ALBAHARI Declaring a public member within an internal t 5 ^e might 
seem pointless, given that the member's visibility will be capped at internal. It can 
make sense, however, if the public member modifier is interpreted as meaning "hav¬ 
ing the same visibility as the containing type." 

A good question to ask in deciding whether to declare a member of an internal t 5 q)e as 
public or internal is this: If the t 5 q)e was later promoted to public, would I want this 
member to become public, too? If the answer is yes, one could argue for declaring the 
member as public from the outset. 


"■ JESSE LIBERTY While there are rational examples of each of the cases mentioned 
above, good programming practice strongly favors using the least complex and most 
obvious accessibility, to reduce confusion and make for more easily maintainable code. 
I've written hundreds of commercially viable applications using nothing more than 
public, private, and protected. 


112 


www.it-ebooks.info 








3.5 Member Access 


As described in §3.4, all members of a base class, except for instance constructors, destruc¬ 
tors, and static constructors, are inherited by derived t 5 ^es. This includes even private 
members of a base class. However, the accessibility domain of a private member includes 
only the program text of the t 5 ^e in which the member is declared. In the example 

class A 
{ 

int x; 

static void F(B b) 

{ 

b.x = 1 ; // Ok 

} 

} 

class B : A 
{ 

static void F(B b) 

{ 

b.x = 1; // Error: x not accessible 

} 

} 

the B class inherits the private member x from the A class. Because the member is private, 
it is only accessible within the class-body of A. Thus the access to b. x succeeds in the A. F 
method, but fails in the B. F method. 


"■ BILL WAG N E R Notice that the inaccessible methods also obviate the need for the 
new modifier on B:F(). 


3.5.3 Protected Access for Instance Members 

When a protected instance member is accessed outside the program text of the class in 
which it is declared, and when a protected internal instance member is accessed outside 
the program text of the program in which it is declared, the access must take place within 
a class declaration that derives from the class in which it is declared. Furthermore, the 
access is required to take place through an instance of that derived class type or a class type 
constructed from it. This restriction prevents one derived class from accessing protected 
members of other derived classes, even when the members are inherited from the same 
base class. 


yj 


113 


www.it-ebooks.info 


Basic Concepts 






Basic Concepts 


3. Basic Concepts 


“■ ERIC LIPPERT For instance, suppose you have a base class Animal and two 
derived classes. Mammal and Reptile, and Animal has a protected method Feed(). 
Then the Mammal code can call Feed() on a Mammal or any subclass of Mammal 
(Tiger, say). 

Mammal code cannot call Feed() on an expression of type Reptile because there is no 
inheritance relationship between Mammal and Reptile. 

Furthermore, because an expression of type Animal might actually be a Reptile at 
runtime. Mammal code also carmot call Feed( ) on an expression of t 5 ^e Animal. 


(n 


Let B be a base class that declares a protected instance member M, and let D be a class that 
derives from B. Within the class-body of D, access to M can take one of the following forms: 

• An unqualified type-name or primary-expression of the form M. 

• A primary-expression of the form E. M, provided the t5q)e of E is T or a class derived from 
T, where T is the class t5q)e D, or a class t5q)e constructed from D. 

• A primary-expression of the form base. M. 

In addition to these forms of access, a derived class can access a protected instance con¬ 
structor of a base class in a constructor-initializer (§10.11.1). 


"■ VLADIMIR RESHETNIKOV Put simply, other forms of access are not allowed. For 
example, a derived class carmot invoke its base class's protected constructor in a new 
operator: 

class Base 
{ 

protected Base() { } 

} 

class Derived : Base 
{ 

static void Main() 

{ 

new Base(); // Error CS0122: 'Base.Base()' is 
// inaccessible due to its 
// protection level 

} 

} 


114 


www.it-ebooks.info 








3.5 Member Access 


In the example 

public class A 
{ 

protected int x; 

static void F(A a, 
{ 

a. x = 1; 

b. x = 1; 

} 

} 

public class B : A 
{ 

static void F(A a, 
{ 

a. x = 1; 

b. x = 1; 

} 

} 


B b) 

// Okay 
// Okay 


B b) 

// Error: must access through instance of B 
// Okay 


within A, it is possible to access x through instances of both A and B, since in either case the 
access takes place through an instance of A or a class derived from A. However, wifhin B, if 
is nof possible fo access x fhrough an insfance of A, since A does nof derive from B. 

In fhe example 

class C<T> 

{ 

protected T x; 

} 

class D<T> : C<T> 

{ 

static void F() 

{ 

D<T> dt = new D<T>(); 

D<int> di = new D<int>(); 

D<string> ds = new D<string>(); 
dt.x = default(T); 
di.x = 123; 
ds.x = "test"; 

} 

} 


fhe fhree assignmenfs fo x are permiffed because fhey all fake place fhrough insfances of 
class fypes consfrucfed from fhe generic fype. 


yj 


115 


www.it-ebooks.info 


Basic Concepts 




Basic Concepts 


3. Basic Concepts 


“■ CHRIS SELLS To minimize the surface area of a class or namespace, I recom¬ 
mend keeping fhings private/internal unfil fhey prove fo be necessary in a wider 
scope. Refacforing is your friend here. 


"■ BILL WAGNER These rules exisf fo allow for fhe separafe evolution of compo- 
nenfs in differenf assemblies. You should nof incorporafe fhese rules info your regular 
design patterns. 


3.5.4 Accessibility Constraints 

Several consfrucfs in fhe C# language require a fype fo be at least as accessible as a mem¬ 
ber or anofher fype. A f5q)e T is said fo be af leasf as accessible as a member or fype M if fhe 
accessibilify domain of T is a supersef of fhe accessibilify domain of M. In ofher words, T is 
af leasf as accessible as M if T is accessible in all confexfs in which M is accessible. 


"■ VLADIMIR RESHETNIKOV For fhe purposes of fhis paragraph, only accessibilify 
modifiers are considered. For insfance, if a protected member is declared in a public 
sealed class, fhe facf fhaf fhis class cannof have descendanfs (and, fherefore, fhe acces¬ 
sibilify domain of fhis member does nof include any descendanfs) is nof considered. 

The following accessibilify consfrainfs exisf: 

• The direcf base class of a class 1)^)0 musf be af leasf as accessible as fhe class fype ifself. 

• The explicif base inferfaces of an inferface type must be at least as accessible as the inter¬ 
face type itself. 

• The return t5q)e and parameter types of a delegate type must be at least as accessible as 
the delegate t5q)e itself. 

• The t5q>e of a constant must be at least as accessible as the constant itself. 

• The t5q)e of a field must be at least as accessible as the field itself. 

• The return t5q)e and parameter types of a method must be at least as accessible as the 
method itself. 

• The t5q)e of a property must be at least as accessible as the property itself. 

• The t5q>e of an event must be at least as accessible as the event itself. 


116 


www.it-ebooks.info 










3.6 Signatures and Overloading 


• The type and parameter types of an indexer must be at least as accessible as the indexer 
itself. 

• The return t5^e and parameter types of an operator must be at least as accessible as the 
operator itself. 

• The parameter types of an instance constructor must be at least as accessible as the 
instance constructor itself. 

In the example 
class A {...} 
public class B: A {...} 

the B class results in a compile-time error because A is not at least as accessible as B. 

Likewise, in the example 

class A {...} 

public class B 
{ 

A F() {...} 
internal A G() {... } 
public A H() {...} 

} 

the H method in B results in a compile-time error because the return t5^e A is not at least as 
accessible as the method. 


3.6 Signatures and Overloading 

Methods, instance constructors, indexers, and operators are characterized by their 
signatures: 

• The signature of a method consists of the name of the method, the number of type 
parameters, and the type and kind (value, reference, or output) of each of its formal 
parameters, considered in the order left to right. For these purposes, any type param¬ 
eter of the method that occurs in the type of a formal parameter is identified not by its 
name, but rather by its ordinal position in the type argument list of the method. The 
signature of a method specifically does not include the return type, the params modi¬ 
fier that may be specified for the rightmost parameter, or the optional type parameter 
constraints. 


yj 


117 


www.it-ebooks.info 


Basic Concepts 




Basic Concepts 


3. Basic Concepts 


■■ JON SKEET The use of overloading by number of type parameters is 
interesting—and occurs at the type level, too (consider, for example, the .NET t5^es 
System. Nullable and System. Nullable<T >). The fact that constraints aren't taken into 
account can very occasionally be irritating. In some cases, it could be handy to be able 
to write 

void Process<T>(T reference) where T : class { ... } 
void Process<T>(T value) where T : struct { ... } 

but this would introduce more complexity into an area that can already be very tricky 
to reason about. Developers' minds have been known to spontaneously combust when 
overloading and 1)^0 inference meet. 


(n 


• The signature of an instance constructor consists of the t5^e and kind (value, reference, 
or output) of each of its formal parameters, considered in the order left to right. The 
signature of an instance constructor specifically does not include the pa rams modifier 
that may be specified for the rightmost parameter. 

• The signature of an indexer consists of the t5^e of each of its formal parameters, consid¬ 
ered in the order left to right. The signature of an indexer specifically does not include 
the element t5^e, nor does it include the pa rams modifier that may be specified for the 
rightmost parameter. 

• The signature of an operator consists of the name of the operator and the t5^e of each of 
its formal parameters, considered in the order left to right. The signature of an operator 
specifically does not include the result type. 

Signatures are the enabling mechanism for overloading of members in classes, structs, and 

interfaces: 

• Overloading of methods permits a class, struct, or interface to declare multiple methods 
with the same name, provided their signatures are unique within that class, struct, or 
interface. 

• Overloading of instance constructors permits a class or struct to declare multiple instance 
constructors, provided their signatures are unique within that class or struct. 

• Overloading of indexers permits a class, struct, or interface to declare multiple indexers, 
provided their signatures are unique within that class, struct, or interface. 


118 


www.it-ebooks.info 






3.6 Signatures and Overloading 


“■ VLADIMIR RESHETNIKOV One exception to the uniqueness requirement for 
indexer signatures: If an indexer is an explicit implementation of an interface, its sig¬ 
nature is checked for uniqueness only within those interface's explicitly implemented 
indexers: 

class A : Ilndexable 
{ 

int Ilndexable.this[int x] 

{ 

get { /* ... */ } 

} 

public int thls[int x] // Okay 
{ 

get { /* ... */ } 

} 

} 


• Overloading of operators permits a class or struct to declare multiple operators with the 
same name, provided their signatures are unique within that class or struct. 

Although out and ref parameter modifiers are considered part of a signature, members 
declared in a single t5q)e carmot differ in signature solely by ref and out. A compile-time 
error occurs if two members are declared in the same t5q)e with signatures that would be 
the same if all parameters in both methods with out modifiers were changed to ref modi¬ 
fiers. For other purposes of signature matching (e.g., hiding or overriding), ref and out are 
considered part of the signature and do not match each other. (This restriction is to allow 
C# programs to be easily translated to run on the Common Language Infrastructure [CLI], 
which does not provide a way to define methods that differ solely in ref and out.) 

For the purposes of signatures, the types object and dynamic are considered the same. 
Members declared in a single type carmot, therefore, differ in signature solely by object 
and dynamic. 

The following example shows a set of overloaded method declarations along with their 
signatures. 


yj 


interface ITest 


void 

F(); 


// 

F() 


void 

F(int 

x); 

// 

F(int) 


void 

F(ref 

int x); 

// 

F(ref int) 


void 

F(out 

int x); 

// 

F(out int) 

error 


119 


www.it-ebooks.info 


Basic Concepts 






Basic Concepts 


3. Basic Concepts 


void F(int x, int y); 

int F(string s); 

int F(int x); 

void F(string[] a); 

void F(params string[] a); 


// F(int, int) 
// F(string) 

// F(int) 


// F(string[]) 

// F(string[]) error 


error 


} 


Note that any ref and out parameter modifiers (§ 10 . 6 . 1 ) are part of a signature. Thus 
F(int) and F(ref int) are unique signatures. However, F(ref int) and F(out int) carmot 
be declared within the same interface because their signatures differ solely by ref and out. 
Also, note that the return t5qie and the pa rams modifier are not part of a signature, so it is 
not possible to overload solely based on return type or on the inclusion or exclusion of the 
params modifier. As such, the declarations of the methods F(int) and F(params string[ ]) 
identified above result in a compile-time error. 


3.7 Scopes 


The scope of a name is the region of program text within which it is possible to refer to the 
entity declared by the name without qualification of the name. Scopes can be nested, and 
an inner scope may redeclare the meaning of a name from an outer scope (this does not, 
however, remove the restriction imposed by § 3.3 that within a nested block it is not pos¬ 
sible to declare a local variable with the same name as a local variable in an enclosing 
block). The name from the outer scope is then said to be hidden in the region of program 
text covered by the inner scope, and access to the outer name is possible only by qualify¬ 
ing the name. 

• The scope of a namespace member declared by a namespace-member-declaration (§ 9 . 5 ) 
with no enclosing namespace-declaration is the entire program text. 

• The scope of a namespace member declared by a namespace-member-declaration within 
a namespace-declaration whose fully qualified name is N is the namespace-body of every 
namespace-declaration whose fully qualified name is N or starts with N, followed by a 
period. 

• The scope of a name defined by an extern-alias-directive extends over the using-directives, 
global-attributes, and namespace-member-declarations of its immediately containing compi¬ 
lation unit or namespace body. An extern-alias-directive does not contribute any new 
members to the underlying declaration space. In other words, an extern-alias-directive is 
not transitive, but rather affects only the compilation unit or namespace body in which 
it occurs. 

• The scope of a name defined or imported by a using-directive (§ 9 . 4 ) extends over the 
namespace-member-declarations of the compilation-unit or namespace-body in which the 


120 


www.it-ebooks.info 




3.7 Scopes 


using-directive occurs. Ausing-directive may make zero or more namespace or type names 
available within a particular compilation-unit or namespace-body, but does not contribute 
any new members to the underlying declaration space. In other words, a using-directive 
is not transitive, but rather affects only the compilation-unit or namespace-body in which it 
occurs. 

• The scope of a t 5 ^e paramefer declared by a type-parameter-list on a class-declaration 
(§10.1) is the class-base, type-parameter-constraints-clauses, and class-body of fhaf class- 
declaration. 

• The scope of a type parameter declared by a type-parameter-list on a struct-declaration 
(§11.1) is the struct-interfaces, type-parameter-constraints-clauses, and struct-body of that 
struct-declaration. 

• The scope of a type parameter declared by a type-parameter-list on an interface-declaration 
(§13.1) is the interface-base, type-parameter-constraints-clauses, and interface-body of that 
interface-declaration. 

• The scope of a t 5 ^e parameter declared by a type-parameter-list on a delegate-declaration 
(§15.1) is the return-type, formal-parameter-list, and type-parameter-constraints-clauses of 
fhat delegate-declaration. 

• The scope of a member declared by a class-member-declaration (§10.1.6) is the class-body in 
which the declaration occurs. In addition, the scope of a class member extends to the 
class-body of those derived classes that are included in the accessibility domain (§3.5.2) 
of the member. 

• The scope of a member declared by a struct-member-declaration (§11.2) is the struct-body 
in which the declaration occurs. 

• The scope of a member declared by an enum-member-declaration (§14.3) is fhe enum-body 
in which the declaration occurs. 

• The scope of a parameter declared in a method-declaration (§10.6) is the method-body of 
that method-declaration. 

• The scope of a paramefer declared in an indexer-declaration (§10.9) is fhe accessor- 
declarations of that indexer-declaration. 

• The scope of a paramefer declared in an operator-declaration (§10.10) is fhe block of fhat 
operator-declaration. 

• The scope of a parameter declared in a constructor-declaration (§10.11) is the constructor- 
initializer and block of that constructor-declaration. 

• The scope of a parameter declared in a lambda-expression (§7.15) is the lambda-expression- 
body of thaf lambda-expression. 

• The scope of a parameter declared in an anonymous-method-expression (§7.15) is the block 
of that anonymous-method-expression. 


yj 


121 


www.it-ebooks.info 


Basic Concepts 




Basic Concepts 


3. Basic Concepts 


• The scope of a label declared in a labeled-statement (§8.4) is the block in which the declara¬ 
tion occurs. 

• The scope of a local variable declared in a local-variable-declaration (§8.5.1) is the block in 
which the declaration occurs. 

• The scope of a local variable declared in a switch-block of a switch statement (§8.7.2) is 
the switch-block. 

• The scope of a local variable declared in a for-initializer of a for statement (§8.8.3) is the 
for-initializer, the for-condition, the for-iterator, and the contained statement of the for 
statement. 

• The scope of a local constant declared in a local-constant-declaration (§8.5.2) is the block in 
which the declaration occurs. It is a compile-time error to refer to a local constant in a 
textual position that precedes its constant-declarator. 

• The scope of a variable declared as part of a foreach-statement, using-statement, lock- 
statement, or query-expression is determined by the expansion of the given construct. 


"■ JESSE LIBERTY This list is a classic, almost iconic example of the difference 
between what is possible and what is advisable. Scope, like method names, and nearly 
everything else in your program should be as self-revealing and unambiguous as 
possible—^but no more so! 


Within the scope of a namespace, class, struct, or enumeration member, it is possible to 
refer to the member in a textual position that precedes the declaration of the member. For 
example, in 

class A 
{ 

void F() 

{ 

i = i; 

} 

int i = 0; 

} 

it is valid for F to refer to i before it is declared. 

Within the scope of a local variable, it is a compile-time error to refer to the local variable 
in a textual position that precedes the local-variable-declarator of the local variable. For 
example: 

class A 
{ 

int i = 0; 


122 


www.it-ebooks.info 






3.7 Scopes 


void F() 

{ 

i = 1; // Error: use precedes declaration 

int i; 

i = 2; 

} 


void G() 

{ 

int j = (j = 1); // Valid 

} 

void H() 

{ 

int a = Ij b = ++a; // Valid 

} 


In the F method above, the first assignment to i specifically does nof refer fo fhe field 
declared in fhe oufer scope. Rafher, if refers fo fhe local variable and resulfs in a compile- 
fime error because if fexfually precedes fhe declaration of fhe variable. In fhe G mefhod, fhe 
use of j in fhe initializer for fhe declaration of j is valid because fhe use does nof precede 
fhe local-variable-declarator. In fhe H mefhod, a subsequenf local-variable-declarator correcfly 
refers fo a local variable declared in an earlier local-variable-declarator wifhin fhe same local- 
variable-declaration. 


The scoping rules for local variables are designed fo guaranfee fhaf fhe meaning of a name 
used in an expression confexf is always fhe same wifhin a block. If fhe scope of a local vari¬ 
able were fo exfend only from ifs declaration fo fhe end of fhe block, fhen in fhe example 
above, fhe firsf assignmenf would assign fo fhe insfance variable and fhe second assign- 
menf would assign fo fhe local variable, possibly leading fo compile-fime errors if fhe sfafe- 
menfs of fhe block were lafer rearranged. 

The meaning of a name wifhin a block may differ based on fhe confexf in which fhe name 
is used. In fhe example 


using System; 
class A { } 

class Test 
{ 

static void Main() 

{ 

string A = "hello, world"; 
string s = A; 

Type t = typeof(A); 

Console.WriteLine(s); 
Console.WriteLine(t); 

} 

} 


// Expression context 

// Type context 

// Writes "hello, world" 
// Writes "A" 


yj 


123 


www.it-ebooks.info 


Basic Concepts 




Basic Concepts 


3. Basic Concepts 


the name A is used in an expression context to refer to the local variable A and in a t 5 ^e 
context to refer to the class A. 

3.7.1 Name Hiding 

The scope of an entity typically encompasses more program text than the declaration space 
of the entity. In particular, the scope of an entity may include declarations that introduce 
new declaration spaces containing entities of the same name. Such declarations cause the 
original entity to become hidden. Conversely, an entity is said to be visible when it is not 
hidden. 

Name hiding occurs when scopes overlap through nesting and when scopes overlap 
through inheritance. The characteristics of the two t 5 ^es of hiding are described in the fol¬ 
lowing sections. 


■■ JESSE LIBERTY I would argue that name hiding should always be considered a 
bug, in that it makes for code that is miserably difficult to maintain and it is always 
avoidable. 


3.7.1.1 Hiding Through Nesting 

Name hiding through nesting can occur as a result of nesting namespaces or types within 
namespaces, as a result of nesting types within classes or structs, and as a result of param¬ 
eter and local variable declarations. 

In the example 

class A 
{ 

int i = 0; 

void F() 

{ 

int i = 1; 

} 

void G() 

{ 

i = i; 

} 

} 

within the F method, the instance variable i is hidden by the local variable i, but within the 
G method, i still refers to the instance variable. 

When a name in an irmer scope hides a name in an outer scope, it hides all overloaded 
occurrences of that name. In the example 


124 


www.it-ebooks.info 






3.7 Scopes 


class Outer 
{ 

static void F(int i) { } 
static void F(string s) { } 

class Inner 
{ 

void G() 

{ 

F(l); // Invokes Outer.Inner.F 

F("Flello"); // Error 

} 

static void F(long 1) { } 

} 

} 

the call F(l) invokes the F declared in Inner because all outer occurrences of F are hidden 
by the inner declaration. For the same reason, the call F ("Flello" ) results in a compile-time 
error. 


“■ VLADIMIR RESHETNIKOV If a nested scope contains a member with the same 
name as a member from an outer scope, then the member from fhe outer scope is not 
always hidden due to the following rule: If the member is invoked, all non-invocable 
members are removed from the set (see §7.3). 

class A 
{ 

static void Foo() { } 
class B 
{ 

const int Foo = 1; 
void Bar() 

{ 

Foo(); // Okay 

} 

} 

} 


yj 


3.7.1.2 Hiding Through Inheritance 

Name hiding through inheritance occurs when classes or structs redeclare names that were 
inherited from base classes. This type of name hiding takes one of the following forms: 

• A constant, field, property, event, or type introduced in a class or struct hides all base 
class members with the same name. 


125 


www.it-ebooks.info 


Basic Concepts 






Basic Concepts 


3. Basic Concepts 


• A method introduced in a class or struct hides all nonmethod base class members with 
the same name, and all base class methods with the same signature (method name and 
parameter count, modifiers, and t 5 ^es). 

• An indexer introduced in a class or struct hides all base class indexers with the same 
signature (parameter count and types). 

The rules governing operator declarations (§10.10) make it impossible for a derived class 
to declare an operator with the same signature as an operator in a base class. Thus opera¬ 
tors never hide one another. 

Contrary to hiding a name from an outer scope, hiding an accessible name from an inher¬ 
ited scope causes a warning to be reported. In the example 

class Base 
{ 

public void F() { } 

} 

class Derived : Base 
{ 

public void F() { } // Warning: hiding an inherited name 

} 

the declaration of F in Derived causes a warning to be reported. Hiding an inherited name 
is specifically not an error, since that would preclude separate evolution of base classes. For 
example, the above situation might have come about because a later version of Base intro¬ 
duced an F method that wasn't present in an earlier version of the class. Had the above 
situation been an error, then any change made to a base class in a separately versioned class 
library could potentially cause derived classes to become invalid. 

The warning caused by hiding an inherited name can be eliminated through use of the new 
modifier: 

class Base 
{ 

public void F() { } 

} 

class Derived : Base 
{ 

new public void F() { } 

} 

The new modifier indicates that the F in Derived is "new," and that it is indeed intended to 
hide the inherited member. 

A declaration of a new member hides an inherited member only within the scope of the 
new member. 


126 


www.it-ebooks.info 




3.8 Namespace and Type Names 


class Base 
{ 

public static void F() { } 

} 

class Derived : Base 
{ 

new private static void F() { } // Flides Base.F in Derived only 

} 

class MoreDerived : Derived 
{ 

static void G() { F(); } // Invokes Base.F 

} 

In the example above, the declaration of F in Derived hides the F that was inherited from 
Base, but since the new F in Derived has private access, its scope does not extend to 
MoreDerived. Thus the call F () in MoreDerived. G is valid and will invoke Base.F. 


"■ CHRIS SELLS If you find yourself using new to hide an instance method on the 
base class, you're almost always going to be disappointed, if for no other reason than 
a caller can simply cast to the base class to get to the "hidden" method. For example: 

class Base { public void F() {} } 

class Derived : Base { new public void F() {} } 

Derived d = new Derived(); 

((Base)d).F(); // Base.F not so hidden as you would like 

You'll be much happier if you pick a new name for fhe mefhod in fhe derived class 
insfead. 


3.8 Namespace and Type Names 

Several contexfs in a C# program require a namespace-name or a type-name fo be specified. 

namespace-name: 

namespace-or-type-name 

type-name: 

namespace-or-type-name 


namespace-or-type-name: 

identifier type-argument-list 

namespace-or-type-name . identifier type-argument-list 
qualified-alias-member 


yj 


127 


www.it-ebooks.info 


Basic Concepts 






Basic Concepts 


3. Basic Concepts 


(n 


A yiamespace-name is a namespace-or-type-name that refers to a namespace. Following resolu¬ 
tion as described below, the namespace-or-type-name of a namespace-name must refer to a 
namespace; otherwise, a compile-time error occurs. No type arguments (§4.4.1) can be 
present in a namespace-name (only t 5 ^es can have type arguments). 

A type-name is a namespace-or-type-name that refers to a type. Following resolution as 
described below, the namespace-or-type-name of a type-name must refer to a t 5 ^e; otherwise, 
a compile-time error occurs. 

If the namespace-or-type-name is a qualified-alias-member, its meaning is as described in §9.7. 
Otherwise, a namespace-or-type-name has one of four forms: 

• I 

• KA,. .... A^> 

• N.I 

• N.KA^, ..., A^> 

where I is a single identifier, N is a namespace-or-type-name, and A|^> is an optional 

type-argument-list. When no type-argument-list is specified, consider K to be zero. 

The meaning of a namespace-or-type-name is determined as follows: 

• If the namespace-or-type-name is of the form I or of the form I<Aj, ..., A^>: 

- If K is zero and the namespace-or-type-name appears within a generic method declara¬ 
tion (§10.6) and if that declaration includes a t 5 ^e parameter (§10.1.3) with name I, 
then the namespace-or-type-name refers to that type parameter. 

- Otherwise, if the namespace-or-type-name appears within a type declaration, then for 
each instance t 5 ^e T (§10.3.1), starting with the instance t 5 ^e of that type declaration 
and continuing with the instance type of each enclosing class or struct declaration 
(if any): 

• If K is zero and the declaration of T includes a type parameter with name I, then 
the namespace-or-type-name refers to that t 5 ^e parameter. 

• Otherwise, if the namespace-or-type-name appears within the body of the type dec¬ 
laration, and T or any of its base types contain a nested accessible type having 
name I and K type parameters, then the namespace-or-type-name refers to that type 
constructed with the given t 5 ^e arguments. If there is more than one such t 5 ^e, the 
type declared within the more derived type is selected. Note that nont 5 ^e mem¬ 
bers (constants, fields, methods, properties, indexers, operators, instance construc¬ 
tors, destructors, and static constructors) and type members with a different 
number of type parameters are ignored when determining the meaning of the 
namespace-or-type-name. 


128 


www.it-ebooks.info 




3.8 Namespace and Type Names 


- If the previous steps were unsuccessful, then, for each namespace N, starting with the 
namespace in which the namespace-or-type-name occurs, continuing with each enclos¬ 
ing namespace (if any), and ending with the global namespace, the following steps 
are evaluated until an entity is located: 

• If K is zero and I is the name of a namespace in N, then: 

- If the location where the namespace-or-type-name occurs is enclosed by a 
namespace declaration for N and the namespace declaration contains an extern- 
alias-directive or using-alias-directive that associates the name I with a namespace 
or t 5 ^e, then the namespace-or-type-name is ambiguous and a compile-time error 
occurs. 

- Otherwise, the namespace-or-type-name refers to the namespace named I in N. 

• Otherwise, if N contains an accessible type having name I and K type parame¬ 
ters, then: 

- If K is zero and the location where the namespace-or-type-name occurs is enclosed 
by a namespace declaration for N and the namespace declaration contains an 
extern-alias-directive or using-alias-directive that associates the name I with a 
namespace or t 5 ^e, then the namespace-or-type-name is ambiguous and a com¬ 
pile-time error occurs. 

- Otherwise, the namespace-or-type-name refers to the type constructed with the 
given t 5 ^e arguments. 

• Otherwise, if the location where the namespace-or-type-name occurs is enclosed by a 

namespace declaration for N: 

- If K is zero and the namespace declaration contains an extern-alias-directive or 
using-alias-directive that associates the name I with an imported namespace or 
type, then the namespace-or-type-name refers to that namespace or t 5 ^e. 

- Otherwise, if the namespaces imported by the using-namespace-directives of the 
namespace declaration contain exactly one type having name I and K type 
parameters, then the namespace-or-type-name refers to that type constructed with 
the given t 5 ^e arguments. 

- Otherwise, if the namespaces imported by the using-namespace-directives of the 
namespace declaration contain more than one type having name I and K t 5 ^e 
parameters, then the namespace-or-type-name is ambiguous and an error occurs. 

- Otherwise, the namespace-or-type-name is undefined and a compile-time error occurs. 


yj 


129 


www.it-ebooks.info 


Basic Concepts 




Basic Concepts 


3. Basic Concepts 


• Otherwise, the namespace-or-type-name is of the form N. I or of the form N. I<Ajj , A^>. N 
is first resolved as a namespace-or-type-name. If the resolution of N is not successful, a 
compile-time error occurs. Otherwise, N. I or N. I<Aj, ..., \> is resolved as follows: 

- If K is zero and N refers to a namespace and N contains a nested namespace with name 
I, then the namespace-or-type-name refers to that nested namespace. 

- Otherwise, if N refers to a namespace and N contains an accessible t 5 ^e having name I 
and K t 5 ^e parameters, then the namespace-or-type-name refers to that t 5 ^e constructed 
with the given type arguments. 

- Otherwise, if N refers to a (possibly constructed) class or struct t 5 ^e and N or any of its 
base classes contain a nested accessible type having name I and K type parameters, 
then the namespace-or-type-name refers to that type constructed with the given type 
arguments. If there is more than one such t 5 ^e, the type declared within the more 
derived type is selected. Note that if the meaning of N. I is being determined as part 
of resolving the base class specification of N, then the direct base class of N is consid¬ 
ered to be object (§10.1.4.1). 

- Otherwise, N. I is an invalid namespace-or-type-name, and a compile-time error 
occurs. 


“■ VLADIMIR RESHETNIKOV This algorithm is different from (albeit similar to) the 
corresponding algorithm for simple names (see §7.6.2). It means that in contrived 
cases, the same identifier may have different meanings in contexts of type-name and 
simple-name: 

class T 

t 

public const int X = 1; 

} 

class C 

{ 

void Foo<T>(int x = T.X /* global::! */, 

T y = default(T) /* type parameter */) { } 

} 


A namespace-or-type-name is permitted to reference a static class (§10.1.1.3) only if 

• The namespace-or-type-name is the T in a namespace-or-type-name of the form T. I, or 

• The namespace-or-type-name is the T in a typeof-expression (§7.5.11) of the form 
typeof(T). 


130 


www.it-ebooks.info 






3.8 Namespace and Type Names 


3.8.1 Fully Qualified Names 

Every namespace and type has a fully qualified name, which uniquely identifies the 
namespace or type among all others. The fully qualified name of a namespace or type N is 
determined as follows: 

• If N is a member of fhe global namespace, ifs fully qualified name is N. 

• Ofherwise, ifs fully qualified name is S. N, where S is fhe fully qualified name of fhe 
namespace or fype in which N is declared. 

In ofher words, fhe fully qualified name of N is fhe complefe hierarchical pafh of idenfifi- 
ers fhaf lead fo N, sfarfing from fhe global namespace. Because every member of a 
namespace or fype musf have a unique name, if follows fhaf fhe fully qualified name of 
a namespace or f 5 q)e is always unique. 

The example below shows several namespace and fype declarafions, along wifh fheir asso- 
ciafed fully qualified names. 

class A { } 

namespace X 
{ 

class B 
{ 

class C { } 

} 

namespace Y 
{ 

class D { } 

} 

} 

namespace X.Y // X.Y 

{ 

class E { } // X.Y.E 

} 


■■ JOSEPH ALBAHARI If a fully qualified name conflicfs wifh a parfially qualified 
or unqualified name (a nesfed accessible t 5 qie, for insfance), fhe laffer wins. Prefixing 
fhe name wifh global:: forces fhe fully qualified name fo win (§9.7). There is liffle 
chance of such a collision in human-wriffen code; wifh machine-wriffen code, how¬ 
ever, fhe odds are greafer. For fhis reason, some code generafors in design fools and 
IDEs emif fhe global:: prefix before all fully qualified t 5 qie names fo eliminafe any 
possibilify of conflicf. 


// A 
// X 

// X.B 
// X.B.C 


// X.Y 
// X.Y.D 



131 


www.it-ebooks.info 


Basic Concepts 






Basic Concepts 


3. Basic Concepts 


(n 


3.9 Automatic Memory Management 

C# employs automatic memory management, which frees developers from manually allo- 
cafrng and freeing fhe memory occupied by objecfs. Automatic memory managemenf poli¬ 
cies are implemenfed by a garbage collector. The memory managemenf life cycle of an 
objecf is as follows: 

1. When fhe objecf is creafed, memory is allocafed for if, fhe consfrucfor is run, and fhe 
objecf is considered live. 

2. If fhe objecf, or any parf of if, carmof be accessed by any possible continuation of execu¬ 
tion, ofher fhan fhe running of desfrucfors, fhe objecf is considered no longer in use, and 
if becomes eligible for desfrucfion. The C# compiler and fhe garbage collecfor may 
choose fo analyze code fo defermine which references to an objecf may be used in fhe 
fufure. For insfance, if a local variable fhaf is in scope is fhe only existing reference fo an 
objecf, buf fhaf local variable is never referred fo in any possible continuation of execu¬ 
tion from fhe currenf execution poinf in fhe procedure, fhe garbage collecfor may (buf 
is nof required fo) freaf fhe objecf as no longer in use. 


“■ CHRISTIAN NAGEL From a desfrucfor, fhe C# compiler creates code fo override 
fhe Finalize mefhod of fhe base class. Overriding fhe Finalize mefhod also means 
an overhead on objecf insfanfiafion and keeps fhe objecf longer alive unfil fhe finaliza¬ 
tion was run. Wifh C++/CL1, fhe code generafed from fhe desfrucfor implemenfs fhe 
IDisposable interface, which has a beffer fif wifh deferminisfic cleanup. 


■■ jONSKEET The poinf af which an objecf is eligible for desfrucfion is earlier fhan 
you mighf expecf. In parficular, an objecf's desfrucfor may run while anofher fhread is 
sfill execufing an insfance mefhod "in" fhe same objecf—so long as fhaf insfance 
mefhod doesn'f refer fo any insfance variables in any possible code pafh affer fhe cur¬ 
renf poinf of execution. 

Forfunafely, fhis behavior can cause a noficeable problem only in f 5 q)es wifh desfruc¬ 
fors, which are relatively uncommon in .NET code since fhe advenf of SafeHandle. 


3. Once fhe objecf is eligible for desfrucfion, af some unspecified later time fhe desfrucfor 
(§10.13) (if any) for fhe objecf is run. Unless overridden by explicif calls, fhe desfrucfor 
for fhe objecf is run once only. 


132 


www.it-ebooks.info 








3.9 Automatic Memory Management 


“■ CH RISTIAN NAGEL "The destruction is called at some unspecified later time .. 
When a destructor is created, it's usually a good idea to implement the interface 
IDisposable as well. Wifh fhe IDisposable inferface, fhe caller has a chance fo invoke 
fhe cleanup code early, when fhe objecf is no longer needed. 


"■ CHRISTIAN NAGEL To invoke fhe desfrucfor more fhan once, GC. ReRegister- 
ForFinalize keeps fhe objecf alive and allows for fhe desfrucfor fo be called once 
more. Insfead of faking fhis fack, if could be worfhwhile fo change fhe applicafion 
archifecfure. 


4. Once fhe desfrucfor for an objecf is run, if fhaf objecf, or any parf of if, carmof be accessed 
by any possible confinuafion of execufion, including fhe running of desfrucfors, fhe 
objecf is considered inaccessible and fhe objecf becomes eligible for collection. 

5. Finally, af some time affer fhe objecf becomes eligible for collection, fhe garbage collec¬ 
tor frees fhe memory associafed wifh fhaf objecf. 

The garbage collecfor mainfains informafion abouf objecf usage, and uses fhis information 
fo make memory managemenf decisions, such as where in memory fo locate a newly cre- 
afed objecf, when fo relocafe an objecf, and when an objecf is no longer in use or 
inaccessible. 

Like ofher languages fhaf assume fhe exisfence of a garbage collecfor, C# is designed so 
fhaf fhe garbage collecfor may implemenf a wide range of memory managemenf policies. 
For insfance, C# does nof require fhaf desfrucfors be run or fhaf objecfs be collected as soon 
as fhey are eligible, or fhaf desfrucfors be run in any parficular order, or on any parficular 
f bread. 

The behavior of fhe garbage collecfor can be confrolled, fo some degree, via sfafic mefhods 
on fhe class System.GC. This class can be used fo requesf a collection fo occur, desfrucfors 
fo be run (or nof run), and so torfh. 


yj 


"■ ERIC LI PPERT Using fhese sfafic mefhods fo confrol fhe behavior of fhe garbage 
collecfor is almosf never a good idea. In producfion code, odds are good fhaf fhe gar¬ 
bage collecfor knows more abouf when would be a good time fo do a collection fhan 
your program does. 

Explicif fweaking of fhe garbage collecfor behavior af runfime should fypically be 
limited fo purposes such as forcing a collecfion for testing purposes. 


133 


www.it-ebooks.info 


Basic Concepts 










Basic Concepts 


3. Basic Concepts 


Since the garbage collector is allowed wide latitude in deciding when to collect objects and 
run destructors, a conforming implementation may produce output that differs from that 
shown by the following code. The program 

using System; 

class A 
{ 

~A() 

{ 

Console.WriteLine("Destruct instance of A"); 

} 

} 

class B 
{ 

object Ref; 

public B(object o) 

{ 

Ref = o; 

} 

~B() 

{ 

Console.WriteLine("Destruct Instance of B"); 

} 

} 

class Test 
{ 

static void Main() 

{ 

B b = new B(new A()); 
b = null; 

GC.CollectO; 

GC.WaitForPendingFinalizers(); 

} 


creates an instance of class A and an instance of class B. These objects become eligible for 
garbage collection when the variable b is assigned the value null, since after this time it is 
impossible for any user-written code to access them. The output could be either 

Destruct instance of A 
Destruct instance of B 


or 


Destruct instance of B 
Destruct instance of A 

because the language imposes no constraints on the order in which objects are garbage 
collected. 


134 


www.it-ebooks.info 




3.9 Automatic Memory Management 


In subtle cases, the distinction between "eligible for destruction" and "eligible for collec¬ 
tion" can be important. For example: 

using System; 

using System; 
class A 
{ 

~A() { 

Console.WriteLineC'Destruct instance of A"); 

} 

public void F() { 

Console.WriteLine("A.F"); 

Test.RefA = this; 

} 

} 

class B 

{ 

public A Ref; 

~B() { 

Console.WriteLineC'Destruct instance of B"); 

Ref.FO; 

} 

} 

class Test 

{ 

public static A RefA; 
public static B RefB; 

static void Main() { 

RefB = new B(); 

RefA = new A(); 

RefB.Ref = RefA; 

RefB = null; 

RefA = null; 

// A and B now eligible for destruction 
GC.CollectO; 

GC.WaitForPendingFinalizers(); 

// B now eligible for collection, but A is not 
if (RefA != null) 

Console.WriteLine("RefA is not null"); 

} 

In the above program, if the garbage collector chooses to run the destructor of A before the 
destructor of B, then the output of this program might be 

Destruct instance of A 
Destruct instance of B 
A.F 

RefA is not null 


yj 


135 


www.it-ebooks.info 


Basic Concepts 




Basic Concepts 


3. Basic Concepts 


Note that although the instance of A was not in use and A's destructor was run, it is still 
possible for methods of A (in this case, F) to be called from another destructor. Also, note 
that rurming a destructor may cause an object to become usable from the mainline program 
again. In this case, the running of B's destructor caused an instance of A that was previously 
not in use to become accessible from the live reference Test. Ref A. After the call to 
WaitForPendingFinalizers, the instance of B is eligible for collection, but the instance of A 
is not, because of the reference Test. Ref A. 

To avoid confusion and unexpected behavior, it is generally a good idea for destructors to 
only perform cleanup on data stored in their object's own fields, and not to perform any 
actions on referenced objects or static fields. 


(n 


■■ ERIC LIPPERT It is an even better idea for the destructor to clean up only the 
fields that contain data representing unmanaged objects, such as operating system 
handles. Because you do not know which thread the destructor will run on or when it 
will run, it is particularly important that the destructor have as few side effects as 
possible. 

The calls to Console.WriteLine in the example obviously violate this good advice to 
only do cleanup and not perform other actions. This code is intended solely as a peda¬ 
gogic aid. Real production code destructors should never attempt to do anything that 
has a complex side effect such as console output. 


An alternative to using destructors is to let a class implement the System. IDisposable 
interface. This allows the client of the object to determine when to release the resources of 
the object, typically by accessing the object as a resource in a using statement (§8.13). 


“■ BRAD ABRAMS Nine times out of ten, using GC.Collect () is a mistake. It is 
often an indication of a poor design that is being cobbled together. The garbage col¬ 
lector is a finely tuned instrument, like a Porsche. Just as you would not play bum¬ 
per tag with a new Porsche, so you should generally avoid interfering with the 
garbage collector's algorithms. The garbage collector is designed to unobtrusively 
step in at the right time and collect the most important unused memory. Kicking it 
with the call GC .Collect( ) can throw off the balance and tuning. Before resorting to 
this solution, take a few minutes to figure why it is required. Have you disposed of 
all your instances? Have you dropped references where you could? Have you used 
weak references in the right places? 


136 


www.it-ebooks.info 








3.10 Execution Order 


“■ KRZYSZTOF CWALINA Some people attribute the performance problems of 
modem VM-based sysfems fo fheir use of garbage collecfion. In facf, modem garbage 
collecfors are so efficienf fhaf fhere is very liffle software leff fhaf would have prob¬ 
lems wifh fhe garbage collecfor's performance in if self. The biggesf performance cul- 
prif is over-engineering of applicafions and, sadly, many framework libraries. 


■■ CHRIS SELLS in fhe modern business sysfems fhaf .NET is generally used fo 
build, garbage collecfion provides wondrous robustness, it's only now that we have 
begun to use managed code in real-time applications, such as games (e.g., XNA for 
Xbox) and fhe Windows Phone 7 plafforms, fhaf fhe careful considerafion of fhe 
behavior of fhe garbage collecfor has become imporfanf. Even in fhose cases, an effi¬ 
cienf design is much more abouf pre-allocafing resources before fhe fwifch begins fhan 
wifh monkeying direcfly wifh fhe garbage collecfor. 


“■ C H RISTI AN NAG EL To reemphasize fhe poinf made by Krzyszfof, discussions on 
fhe performance of fhe garbage collecfor usually are similar fo discussions some years 
ago when C code was compared fo assembly code, or some years lafer when C++ 
performance was suspecf in comparison fo C. Of course, fhere is sfill a place for assem¬ 
bler code and for C, buf mosf applicafions are happy wifh a managed runtime. 


“■ BILL WAGNER Collecfively, fhese nofes poinf ouf how few of your regular 
assumptions are valid in fhe confexf of a destrucfor. Member variables may have 
already execufed fheir desfrucfors. They are called on a differenf fhread, so fhread 
local sforage may nof be valid. They are called by fhe sysfem, so your applicafion 
won'f see errors reporfed by desfrucfors using excepfions. If's hard fo over-emphasize 
how defensively you need fo wrife desfrucfors. Luckily, fhey are needed only rarely. 


yj 


3.10 Execution Order 

Execution of a C# program proceeds such fhaf fhe side effecfs of each execufing fhread are 
preserved af crifical execution poinfs. A side effect is defined as a read or wrife of a volatile 
field, a wrife fo a nonvolatile variable, a wrife fo an exfernal resource, and fhe fhrowing of 
an exception. The critical execution points at which the order of fhese side effecfs musf be 
preserved are references fo volatile fields (§10.5.3), lock sfafemenfs (§8.12), and fhread 


137 


www.it-ebooks.info 


Basic Concepts 












Basic Concepts 


3. Basic Concepts 


creation and termination. The execution environment is free to change the order of execu¬ 
tion of a C# program, subject to the following constraints: 

• Data dependence is preserved within a thread of execution. That is, the value of each 
variable is computed as if all statements in the thread were executed in original program 
order. 

• Initialization ordering rules are preserved (§10.5.4 and §10.5.5). 

• The ordering of side effects is preserved with respect to volatile reads and writes (§10.5.3). 
Additionally, the execution environment need not evaluate part of an expression if it can 
deduce that that expression's value is not used and that no needed side effects are pro¬ 
duced (including any caused by calling a method or accessing a volatile field). When 
program execution is interrupted by an asynchronous event (such as an exception 
thrown by another thread), it is not guaranteed that the observable side effects will be 
visible in the original program order. 


(n 


138 


www.it-ebooks.info 




4. Types 


The t 5 ^es of the C# language are divided into two main categories: value types and refer¬ 
ence types. Both value types and reference t 5 ^es may be generic types, which take one or 
more type parameters. Type parameters can designate both value types and reference 
types. 

type: 

value-type 

reference-type 

type-parameter 

A third category of t 5 ^es, pointers, is available only in unsafe code. This issue is discussed 
further in §18.2. 

Value t 5 ^es differ from reference t 5 ^es in that variables of the value t 5 ^es directly contain 
their data, whereas variables of the reference t 5 ^es store references to their data, the latter 
being known as objects. With reference types, it is possible for two variables to reference 
the same object, and thus possible for operations on one variable to affect the object refer¬ 
enced by the other variable. With value types, the variables each have their own copy of 
the data, so it is not possible for operations on one to affect the other. 

C#'s type system is unified such that a value of any type can be treated as an object. Every type 
in C# directly or indirectly derives from the object class type, and object is the ultimate 
base class of all t 5 ^es. Values of reference types are treated as objects simply by viewing the 
values as type object. Values of value types are treated as objects by performing boxing 
and unboxing operations (§4.3). 


"■ ERICLIPPERT We normally do not think of interface types or the t 5 ^es associ¬ 
ated with type parameters as having a "base class" per se. What this discussion is 
getting at is that every concrete object—no matter how you are treating it at compile 
time—may be treated as an instance of object at runtime. 


139 


www.it-ebooks.info 






Types 


4. Types 


4.1 Value Types 

A value type is either a struct type or an enumeration type. C# provides a set of pre¬ 
defined sfrucf fypes called fhe simple types. The simple fypes are idenfified fhrough 
reserved words. 

value-type: 

struct-type 

enum-type 

struct-type: 

type-name 

simple-type 

nullable-type 

simple-type: 

numeric-type 

bool 

numeric-type: 

integral-type 

floating-point-type 

decimal 

integral-type: 

sbyte 

byte 

short 

ushort 

int 

uint 

long 

along 

char 

floating-point-type: 

float 

double 

nullable-type: 

non-nullable-value-type ? 

non-nullable-value-type: 

type 

I enum-type: 

type-name 

140 


www.it-ebooks.info 




4.1 Value Types 


Unlike a variable of a reference fype, a variable of a value type can contain the value null 
only if the value t 5 ^e is a nullable t 5 ^e. For every non-nullable value type, there is a cor¬ 
responding nullable value type denoting the same set of values plus the value null. 

Assignment to a variable of a value type creates a copy of the value being assigned. This 
differs from assignment to a variable of a reference type, which copies the reference but not 
the object identified by the reference. 

4.1.1 The System.ValueType Type 

All value types implicitly inherit from the class System.ValueType, which in turn inherits 
from class object. It is not possible for any type to derive from a value type, and value 
types are thus implicitly sealed (§10.1.1.2). 

Note that System.ValueType is not itself a value-type. Rather, it is a class-type from which all 
value-types are automatically derived. 


“■ ERICLIPPERT This point is frequently confusing to novices. I am often asked, 
"But how is it possible that a value t 5 q)e derives from a reference type?" I think the 
confusion arises as a result of a misunderstanding of what "derives from" means. 
Derivation does not imply that the layout of the bits in memory of the base t 5 q)e is 
somewhere found in the layout of bits in the derived t 5 q)e. Rather, it simply implies 
that some mechanism exists whereby members of the base type may be accessed from 
the derived tjqje. 


4.1.2 Default Constructors 

All value types implicitly declare a public parameterless instance constructor called the 
default constructor. The default constructor returns a zero-initialized instance known as 
the default value for the value type: 

• For all simple-types, the default value is the value produced by a bit pattern of all zeros: 

- For sbyte, byte, short, ushort, int, uint, long, and ulong, the default value is 0. 

- For char, the default value is ' \x0000'. 

- For float, the default value is 0.0f. 

- For double, the default value is 0.0d. 

- For decimal, the default value is 0.0m. 

- For bool, the default value is false. 




141 


www.it-ebooks.info 


Types 






Types 


4. Types 


• For an enum-type E, the default value is 0, converted to the type E. 

• For a struct-type, the default value is the value produced by setting all value t 5 ^e fields 
fo fheir defaulf values and all reference type fields fo null. 

“■ VLADIMIR RESHETNIKOV Obviously, fhe wording "all fields" here means only 
insfance fields (nof sfafic fields). If also includes field-like insfance evenfs, if any exisf. 


• For a nullable-type, fhe defaulf value is an insfance for which fhe HasValue properfy is 
false and fhe Value properfy is undefined. The defaulf value is also known as fhe null 
value of fhe nullable type. 

Like any other instance constructor, the default constructor of a value type is invoked 
using the new operator. For efficiency reasons, fhis requiremenf is nof infended fo acfually 
have fhe implemenfafion generafe a consfrucfor call. In fhe example below, variables i and 
j are bofh inifialized fo zero. 

class A 
{ 

void F() { 

int i = 0; 

int j = new int(); 

} 

} 

Because every value fype implicifly has a public parameferless insfance consfrucfor, if is nof 
possible for a sfrucf fype fo confain an explicif declaration of a parameferless consfrucfor. A 
sfrucf fype is, however, permiffed fo declare parameferized insfance consfrucfors (§11.3.8). 


“■ ERIC LIPPERT Anofher good way fo obfain fhe defaulf value of a 1)^)0 is fo use 
the default(type) expression. 


■i JONSKEET This is one example of where fhe C# language and fhe underlying 
plafform may have differenf ideas. If you ask fhe .NET plafform for fhe consfrucfors 
of a value type, you usually won'f find a parameferless one. Insfead, .NET has a spe¬ 
cific insfrucfion for inifializing fhe defaulf value for a value t 5 qie. Usually fhese small 
impedence mismafches have no effecf on developers, buf if's good fo know fhaf fhey're 
possible—and fhaf fhey don'f represenf a faulf in eifher specification. 


142 


www.it-ebooks.info 










4.1 Value Types 


4.1.3 Struct Types 

A struct t 5 ^e is a value t 5 ^e that can declare constants, fields, methods, properties, index¬ 
ers, operators, instance constructors, static constructors, and nested types. The declaration 
of struct t 5 ^es is described in §11.1. 

4.1.4 Simple Types 

C# provides a set of predefined strucf t 5 ^es called the simple types. The simple types are 
identified through reserved words, but these reserved words are simply aliases for pre¬ 
defined sfrucf fypes in fhe System namespace, as described in fhe fable below. 


Reserved Word 

Aliased Type 

sbyte 

System.SByte 

byte 

System.Byte 

short 

System.Intl6 

ushort 

System.UIntie 

int 

System.Int32 

uint 

System.UInt32 

long 

System.Int64 

ulong 

System.UInt64 

char 

System.Char 

float 

System.Single 

double 

System.Double 

bool 

System.Boolean 

decimal 

System.Decimal 


Because a simple t 5 ^e aliases a sfruct t 5 ^e, every simple t 5 ^e has members. For example, 
int has the members declared in System. Int32 and the members inherited from System. 
Object, and the following statements are permitted: 


int i = int.MaxValue; 
string s = i.ToString(); 
string t = 123.ToString(); 


// System.Int32.MaxValue constant 
// System.Int32.ToString() instance method 
// System.Int32.ToString() instance method 




143 


www.it-ebooks.info 


Types 



















Types 


4. Types 


The simple t 5 ^es differ from ofher sfrucf fypes in fhaf fhey permif cerfain addifional 
operafions: 

• Mosf simple fypes permif values fo be creafed by wrifing literals (§2.4.4). For example, 
123 is a liferal of type int and ' a' is a literal of char. C# makes no provision for 
literals of struct t 5 ^es in general, and nondefault values of other struct types are ulti¬ 
mately always created through instance constructors of those struct types. 


■■ ERICLIPPERT The "most" in the phrase "most simple t 5 ^es" refers to the fact 
that some simple t 5 ^es, such as short, have no literal form. In reality, any integer lit¬ 
eral small enough to fit into a short is implicitly converted to a short when used as 
one, so in that sense there are literal values for all simple types. 

There are a handful of possible values for simple t 5 ^es that have no literal forms. The 
NaN (Not-a-Number) values for floating point t 5 ^es, for example, have no literal form. 


• When the operands of an expression are all simple type constants, it is possible for the 
compiler to evaluate the expression at compile time. Such an expression is known as a 
constant-expression (§7.19). Expressions involving operators defined by other struct t 5 ^es 
are not considered to be constant expressions. 


“■ VLADIMIR RESHETNIKOV It is not just "possible": The compiler always does 
fully evaluate constant-expressions at compile time. 




• Through const declarations, it is possible to declare constants of the simple types (§10.4). 
It is not possible to have constants of other struct types, but a similar effect is provided 
by static readonly fields. 

• Conversions involving simple types can participate in evaluation of conversion opera¬ 
tors defined by other struct types, but a user-defined conversion operator can never 
participate in evaluation of another user-defined operator (§6.4.3). 


■■ JOSEPH ALBAHARI The simple t 5 ^es also provide a means by which the com¬ 
piler can leverage direct support within the IL (and ultimately the processor) for 
computations on integer and floating point values. This scheme allows arithmetic on 
simple types that have processor support (typically float, double, and the integral 
types) to run at native speed. 


144 


www.it-ebooks.info 










4.1 Value Types 


4.1.5 Integral Types 

C# supports nine integral types: sbyte, byte, short, ushort, int, uint, long, ulong, and 

char. The integral t 5 ^es have the following sizes and ranges of values: 

• The sbyte t 5 ^e represents signed 8-bit integers with values between -128 and 127. 

• The byte type represents unsigned 8-bit integers with values between 0 and 255. 

• The short type represents signed 16-bit integers with values between -32768 and 
32767. 

• The ushort type represents unsigned 16-bit integers with values between 0 and 65535. 

• The int type represents signed 32-bit integers with values between -2147483648 and 
2147483647. 

• The uint type represents unsigned 32-bit integers with values between 0 and 
4294967295. 

• The long t 5 ^e represents signed 64-bit integers with values between-9223372036854775808 
and 9223372036854775807. 

• The ulong type represents unsigned 64-bit integers with values between 0 and 
18446744073709551615. 

• The char ti^e represents unsigned 16-bit integers with values between 0 and 65535. The 
set of possible values for the char type corresponds to the Unicode character set. 
Although char has the same representation as ushort, not all operations permitted on 
one t 5 ^e are permitted on the other. 


"■ JESSE LIBERTY 1 have to confess that with the power of modern PCs, and the 
greater cost of programmer fime relative to the cost of memory, 1 tend to use int for 
just about any integral (nonfractional) value and double for any fractional value. All 
the rest, 1 pretty much ignore. 


The integral-type unary and binary operators always operate with signed 32-bit precision, 
unsigned 32-bit precision, signed 64-bit precision, or unsigned 64-bit precision: 

• For the unary + and ~ operators, the operand is converted to ti^e T, where T is the first 
of int, uint, long, and ulong fhat can fully represent all possible values of fhe operand. 
The operation is then performed using the precision of type T, and the type of the 
result is T. 

• For the unary - operator, the operand is converted to t 5 ^e T, where T is the first of int 
and long that can fully represenf all possible values of fhe operand. The operation is then 




145 


www.it-ebooks.info 


Types 






Types 


4. Types 


performed using the precision of type T, and the type of the result is T. The unary - 
operator carmot be applied to operands of type along. 

• For the binary +, /, %, |, ==, ! =, >, <, >=, and <= operators, the operands are con¬ 

verted to type T, where T is the first of int, uint, long, and along that can fully represent 
all possible values of both operands. The operation is then performed using the preci¬ 
sion of type T, and the type of the result is T (or bool for the relational operators). It is 
not permitted for one operand to be of t 5 ^e long and the other to be of type along with 
the binary operators. 

• For the binary < < and > > operators, the left operand is converted to type T, where T is the 
first of int, aint, long, and along that can fully represent all possible values of the oper¬ 
and. The operation is then performed using the precision of type T, and the t 5 ^e of the 
result is T. 

The char t 5 ^e is classified as an integral t 5 ^e, but it differs from the other integral types in 
two ways: 

• There are no implicit conversions from other types to the char type. In particular, even 
though the sbyte, byte, and ashort t 5 ^es have ranges of values that are fully repre¬ 
sentable using the char type, implicit conversions from sbyte, byte, or ashort to char 
do not exist. 

• Constants of the char type must be written as character-literals or as integer-literals in 
combination with a cast to type char. For example, (char) 10 is the same as ' \x000A'. 

The checked and anchecked operators and statements are used to control overflow check¬ 
ing for integral-type arithmetic operations and conversions (§7.6.12). In a checked context, 
an overflow produces a compile-time error or causes a System.OverflowException to be 
thrown. In an anchecked context, overflows are ignored and any high-order bits that do not 
fit in the destination t 5 ^e are discarded. 

4.1.6 Floating Point Types 

C# supports two floating point t 5 ^es: float and doable. The float and doable t 5 ^es are 
represented using the 32-bit single-precision and 64-bit double-precision IEEE 754 formats, 
which provide the following sets of values: 

• Positive zero and negative zero. In most situations, positive zero and negative zero 
behave identically as the simple value zero, but certain operations distinguish between 
the two (§7.8.2). 


146 


www.it-ebooks.info 




4.1 Value Types 


“■ VLADIMIR RESHETNIKOV Be aware that the default implementation of fhe 
Equals mefhod in value fypes can use bifwise comparison in some cases fo speed up 
performance. If fwo insfances of your value t 5 ^e confain in fheir fields posifive and 
negafive zero, respectively, fhey can compare as nof equal. You can override fhe Equals 
mefhod fo change fhe defaulf behavior. 

using System; 

struct S 

{ 

double X; 

static void Main() 

{ 

var a = new S {X = 0.0}; 
var b = new S {X = -0.0}; 

Console.WriteLine(a.X.Equals(b.X)); // True 
Console.WriteLine(a.Equals(b)); // False 

} 

} 


“■ PETER SESTOFT Some of fhe confusion over negafive zero may sfem from fhe 
facf fhaf fhe currenf implemenfafions of C# prinf posifive and negafive zero in 
fhe same way, as 0.0, and no combinafion of formaffing paramefers seems fo affecf 
fhaf display. Alfhough fhis is probably done wifh fhe besf of infenfions, if is unforfu- 
nafe. To reveal a negafive zero, you musf resorf fo sfrange-looking code like fhis, which 
worksbecause l/(-0.0) = -Infinity < 0: 

public static string DoubleToString(double d) { 
if (d == 0.0 && 1/d < 0) 
return "-0.0"; 
else 

return d.ToStringO; 

} 


• Posifive infinify and negative infinity. Infinities are produced by such operations as 
dividing a non-zero number by zero. For example, 1.0 / 0.0 yields positive infinity, and 
-1.0 / 0.0 yields negative infinity. 

• The Not-a-Numher value, often abbreviated NaN. NaNs are produced by invalid float¬ 
ing point operations, such as dividing zero by zero. 


"■ PETER SESTOFT A large number of disfincf NaNs exisf, each of which has a dif- 
ferenf "payload." See fhe annofafions on §7.8.1. 




147 


www.it-ebooks.info 


Types 










Types 


4. Types 




• The finite set of non-zero values of the form s x m x 2‘, where s is 1 or -1, and m and e 
are determined by the particular floating point t 5 ^e: For float, 0 < m < and -149 < e 
< 104; for double, 0 <m< 2® and -1075 < e < 970. Denormalized floating point numbers 
are considered valid non-zero values. 

The float type can represent values ranging from approximately 1.5 x 10~^® to 3.4 x 10^® 
with a precision of 7 digits. 

The double type can represent values ranging from approximately 5.0 x to 1.7 x 10^“® 
with a precision of 15 or 16 digits. 

If one of the operands of a binary operator is of a floating point type, then the other oper¬ 
and must be of an integral type or a floating point t 5 ^e, and the operation is evaluated as 
follows: 

• If one of the operands is of an integral type, then that operand is converted to the float¬ 
ing point t 5 ^e of the other operand. 

• Then, if either of the operands is of type double, the other operand is converted to 
double, the operation is performed using at least double range and precision, and the 
type of the result is double (or bool for the relational operators). 

• Otherwise, the operation is performed using at least float range and precision, and the 
type of the result is float (or bool for the relational operators). 

The floating point operators, including the assignment operators, never produce excep¬ 
tions. Instead, in exceptional situations, floating point operations produce zero, infinity, or 
NaN, as described below: 

• If the result of a floating point operation is too small for the destination format, the result 
of the operation becomes positive zero or negative zero. 

• If the result of a floating point operation is too large for the destination format, the result 
of the operation becomes positive infinity or negative infinity 

• If a floating point operation is invalid, the result of the operation becomes NaN. 

• If one or both operands of a floating point operation is NaN, the result of the operation 
becomes NaN. 

Floating point operations may be performed with higher precision than the result type of 
the operation. For example, some hardware architectures support an "extended" or "long 
double" floating point t 5 ^e with greater range and precision than the double t 5 ^e, and 
implicitly perform all floating point operations using this higher precision type. Only at 
excessive cost in performance can such hardware architectures be made to perform float¬ 
ing point operations with less precision. Rather than require an implementation to forfeit 


148 


www.it-ebooks.info 




4.1 Value Types 


both performance and precision, C# allows a higher precision type to be used for all float¬ 
ing point operations. Other than delivering more precise results, this rarely has any mea¬ 
surable effects. However, in expressions of the form x * y / z, where the multiplication 
produces a result that is outside the double range, but the subsequent division brings the 
temporary result back into the double range, the fact that the expression is evaluated in a 
higher range format may cause a finite result to be produced instead of an infinity. 


■■ JOSEPH ALBAHARI NaNs are sometimes used to represent special values. In 
Microsoft's Windows Presentation Foundation, double.NaN represents a measure¬ 
ment whose value is "automatic." Another way to represent such a value is with a 
nullable type; yet another is with a custom struct that wraps a numeric type and adds 
another field. 


4.1.7 The decimal Type 

The decimal type is a 128-bit data type suitable for financial and monetary calculations. 
The decimal t 5 q)e can represent values ranging from 1.0 x 10“^® to approximately 7.9 x 10^® 
with 28 or 29 significant digits. 

The finite set of values of type decimal are of the form (-1)"* x c x 10 ®, where the sign s is 0 
or 1, the coefficient c is given by 0 s c < 2^®, and the scale e is such that 0 s e < 28.The decimal 
type does not support signed zeros, infinities, or NaNs. A decimal is represented as a 96-bit 
integer scaled by a power of 10. For decimals with an absolute value less than 1.0m, the 
value is exact to the 28* decimal place, but no further. For decimals with an absolute value 
greater than or equal to 1.0m, the value is exact to 28 or 29 digits. Unlike with the float and 
double data types, decimal fractional numbers such as 0.1 can be represented exactly in the 
decimal representation. In the float and double representations, such numbers are often 
infinite fractions, making those representations more prone to round-off errors. 


“■ PETER SESTOFT The IEEE 754-2008 standard describes a decimal floating point 
type called decimall28. It is similar to the type decimal described here, but packs a lot 
more punch within the same 128 bits. It has 34 significant decimal digits, a range from 
10-6134 iQ igsin^ and supports NaNs. It was designed by Mike Cowlishaw at IBM UK. 
Since it extends the current decimal in all respects, it would seem feasible for C# to 
switch to IEEE decimall28 in some future version. 


If one of the operands of a binary operator is of type decimal, then the other operand must 
be of an integral type or of type decimal. If an integral type operand is present, it is con¬ 
verted to decimal before the operation is performed. 




149 


www.it-ebooks.info 


Types 








Types 


4. Types 


“■ BILL WAGNER You cannot mix decimal and the floating point types (float, 
double). This rule exists because you would lose precision mixing computations 
between those types. You must apply an explicit conversion when mixing decimal 
and floating point t 5 ^es. 


The result of an operation on values of type decimal is what would result from calculafing 
an exacf resulf (preserving scale, as defined for each operafor) and fhen rounding fo fif fhe 
represenfafion. Resulfs are rounded fo fhe nearesf represenfable value and, when a resulf 
is equally close fo fwo represenfable values, fo fhe value fhaf has an even number in fhe 
leasf significanf digif position (fhis is known as "banker's rounding"). A zero resulf always 
has a sign of 0 and a scale of 0. 


"■ ERIC LIPPERT This mefhod has fhe affracfive properfy fhaf if f 5 q)ically infro- 
duces less bias fhan mefhods fhaf always round down or up when fhere is a "fie" 
between fwo possibilities. 

Oddly enough, despife fhe nickname, fhere is liffle evidence fhaf fhis mefhod of round¬ 
ing was ever in widespread use in banking. 




If a decimal arifhmefic operation produces a value less fhan or equal fo 5 x 10'^® in absolufe 
value, fhe resulf of fhe operation becomes zero. If a decimal arifhmefic operafion produces 
a resulf fhaf is too large for fhe decimal formal, a System.OverflowException is fhrown. 

The decimal fype has greafer precision buf smaller range fhan fhe floating poinf fypes. 
Thus conversions from fhe floating poinf f 5 q)es fo decimal mighf produce overflow excep- 
fions, and conversions from decimal fo fhe floating poinf fypes mighf cause loss of preci¬ 
sion. For fhese reasons, no implicif conversions exisf between the floating point t 5 q)es and 
decimal, and without explicit casts, it is not possible to mix floating point and decimal 
operands in the same expression. 


"■ ERIC LIPPERT C# does not support the Currency data t 5 q)e familiar to users of 
Visual Basic 6 and other OLE Automation-based programming languages. Because 
decimal has both more range and precision than Currency, anything that you could 
have done with a Currency can be done just as well with a decimal. 


4.1.8 The bool Type 

The bool type represents boolean logical quantities. The possible values of type bool are 
true and false. 


150 


www.it-ebooks.info 










4.1 Value Types 


No standard conversions exist between bool and other t 5 ^es. In particular, the bool t 5 ^e 
is distinct and separate from the integral types; a bool value cannot be used in place of an 
integral value, and vice versa. 

In the C and C++ languages, a zero integral or floating point value, or a null pointer, can 
be converted to the boolean value false, and a non-zero integral or floating point value, or 
a non-null pointer, can be converted to the boolean value true. In C#, such conversions are 
accomplished by explicitly comparing an integral or floating point value to zero, or by 
explicitly comparing an object reference to null. 


“■ CHRIS SELLS The inability of a non-bool to be converted to a bool most often 
bites me when comparing for null. For example: 

object obj = null; 

if( obj ){...} // Okay in C/C++, error in C# 

if( obj != null ){...} // Okay in C/C++/C# 


4.1.9 Enumeration Types 

An enumeration tj^e is a distinct tj^e with named constants. Every enumeration type has 
an underlying type, which must be byte, sbyte, short, ushort, int, uint, long, or ulong. 
The set of values of the enumeration tj^e is the same as the set of values of the underlying 
type. Values of the enumeration type are not restricted to the values of the named con¬ 
stants. Enumeration tj^es are defined through enumeration declarations (§14.1). 


“■ ERIC LIPPERT This is an important point: Nothing stops you from putting a 
value that is not in the enumerated tj^e into a variable of that tj^e. Do not rely on the 
language or the runtime environment to verify fhat instances of enumerated tj^es are 
within the bounds you expect. 


"■ VLADIMIR RESHETNIKOV The CLR also supports char as an underlying tj^e of 
an enumeration. If you happen to reference an assembly confaining such a tj^e in 
your application, the C# compiler will not recognize this tj^e as an enumeration and 
will not allow you, for example, to convert it to or from an infegral tj^e. 




4.1.10 Nullable Types 

A nullable tj^e can represent all values of its underlying type plus an additional null value. 
A nullable type is written T?, where T is the underlying type. This Sjmtax is shorthand for 
System. Nullable<T >, and the two forms can be used interchangeably. 


151 


www.it-ebooks.info 


Types 










Types 


4. Types 


A non-nullable value type, conversely, is any value type other than System. Nullable<T> 
and its shorthand T? (for any T), plus any t 5 ^e parameter that is constrained to be a non- 
nullable value type (that is, any type parameter with a struct constraint). The System. 
Nullable<T > type specifies the value t 5 ^e constraint for T (§10.1.5), which means that the 
underlying t 5 ^e of a nullable type can be any non-nullable value type. The underlying 
type of a nullable t 5 ^e carmot be a nullable type or a reference t 5 ^e. For example, int ? ? 
and string? are invalid t 5 ^es. 

An instance of a nullable t 5 ^e T? has two public read-only properties: 

• A HasValue property of t 5 ^e bool 

• A Va 1 u e properly of 1)^0 T 

An insfance for which HasValue is true is said fo be non-null. Anon-null insfance confains 
a known value and Value refums thaf value. 

An instance for which HasValue is false is said to be null. Anull instance has an undefined 
value. Attempting to read the Value of a null instance causes a System. Inva lidOperat ion- 
Exception to be thrown. The process of accessing fhe Value properly of a nullable instance 
is referred fo as unwrapping. 

In addition to the default constructor, every nullable t 5 ^e T ? has a public constructor that 
takes a single argument of type T. Given a value x of t 5 ^e T, a constructor invocation of 
fhe form 

new T?(x) 

creates a non-null instance of T? for which fhe Value properly is x. The process of creating 
a non-null instance of a nullable t 5 ^e for a given value is referred fo as wrapping. 

Implicit conversions are available from the null literal to T? (§6.1.5) and from T fo T? 
(§6.1.4). 




4.2 Reference Types 

A reference type is a class type, an interface type, an array t 5 ^e, or a delegate type. 

reference-type: 

class-type 

interface-type 

array-type 

delegate-type 


152 


www.it-ebooks.info 




4.2 Reference Types 


class-type: 

type-name 

object 

dynamic 

string 

interface-type: 

type-name 

array-type: 

non-array-type rank-specifiers 

non-array-type: 

type 

rank-specifiers: 

rank-specifier 

rank-specifiers rank-specifier 

rank-specifier: 

[ dim-separators^^ ] 

dim-separators: 

3 

dim-separators , 

deiegate-type: 

type-name 

A reference type value is a reference to an instance of the type, the latter known as an 
object. The special value null is compatible with all reference types and indicates the 
absence of an instance. 


4.2.1 Class Types 

A class type defines a data structure that contains data members (constants and fields), 
function members (methods, properties, events, indexers, operators, instance constructors, 
destructors, and static constructors), and nested t 5 ^es. Class t 5 ^es support inheritance, a 
mechanism whereby derived classes can extend and specialize base classes. Instances of 
class types are created using object-creation-expressions (§7.6.10.1). 

Class t 5 ^es are described in §10. 




153 


www.it-ebooks.info 


Types 




Types 


4. Types 


Certain predefined class types have special meaning in the C# language, as described in 
the table below. 


Class Type 

Description 

System.Object 

The ulhmate base class of all other types. (See §4.2.2.) 

System.String 

The string type of the C# language. (See §4.2.3.) 

System.ValueType 

The base class of all value types. (See §4.1.1.) 

System.Enum 

The base class of all enum types. (See §14.) 

System.Array 

The base class of all array types. (See §12.) 

System.Delegate 

The base class of all delegate types. (See §15.) 

System.Exception 

The base class of all exception types. (See §16.) 




4.2.2 The object Type 

The object class type is the ultimate base class of all other types. Every t 5 ^e in C# directly 
or indirectly derives from the object class type. 

The ke 5 rword object is simply an alias for the predefined class System.Object. 

4.2.3 The dynamic Type 

The dynamic t 5 ^e, like object, can reference any object. When operators are applied to 
expressions of t 5 ^e dynamic, their resolution is deferred until the program is run. Thus, if 
the operator cannot legally be applied to the referenced object, no error is given during 
compilation. Instead, an exception will be thrown when resolution of the operator fails at 
runtime. 

The d 5 mamic t 5 ^e is further described in §4.7, and dynamic binding in §7.2.2. 

4.2.4 The String Type 

The string type is a sealed class type that inherits directly from object. Instances of the 
string class represent Unicode character strings. 

Values of the string type can be written as string literals (§2.4.4.5). 

The ke 5 rword string is simply an alias for the predefined class System.String. 


154 


www.it-ebooks.info 













4.3 Boxing and Unboxing 


4.2.5 Interface Types 

An interface defines a contract. A class or struct that implements an interface must adhere 
to its contract. An interface may inherit from multiple base interfaces, and a class or struct 
may implement multiple interfaces. 

Inferface types are described in §13. 

4.2.6 Array Types 

An array is a data structure that contains zero or more variables that are accessed through 
computed indices. The variables contained in an array, also called the elements of fhe array, 
are all of the same type, and this type is called the element t 5 ^e of the array. 

Array types are described in §12. 

4.2.7 Delegate Types 

A delegate is a data structure that refers to one or more methods. For instance methods, it 
also refers to their corresponding object instances. 

The closest equivalent of a delegafe in C or C++ is a fimcfion pornfer, buf whereas a func- 
fion poinfer can reference only sfatic funcfions, a delegate can reference bofh stafic and 
instance methods. In the latter case, the delegate stores not only a reference to the method's 
entry point, but also a reference to the object instance on which to invoke the method. 

Delegate t 5 q)es are described in §15. 


"■ CHRIS SELLS Although C++ can reference instance member functions via a 
member function pointer, it's such a difficult thing to get right that the feature might 
as well be illegal! 


4.3 Boxing and Unboxing 

The concept of boxing and unboxing is central to C#'s type system. It provides a bridge 
between value-types and reference-types by permitting any value of a value-type to be con¬ 
verted to and from type object. Boxing and unboxing enables a unified view of the type 
system wherein a value of any t 5 q)e can ultimately be treated as an object. 




155 


www.it-ebooks.info 


Types 






Types 


4. Types 


■■ JOSEPH ALBAHARI Prior to C# 2.0, boxing and unboxing were the primary 
means by which you could write a general-purpose collection, such as a list, stack, or 
queue. Since the introduction of C# 2.0, generics have provided an alternative solution 
in these cases, which leads to better static t 5 q)e safety and performance. Boxing/ 
unboxing necessarily demands a small performance overhead, because if means copy¬ 
ing values, dealing wifh indirecfion, and allocafing memory on fhe heap. 


■■ JESSE LIBERTY 1 would go furfher and say fhaf fhe infroducfion of generics has, 
for all pracfical purposes, dislodged boxing and unboxing from a cenfral concern fo a 
peripheral one, of inferesf only when passing value fypes as out or ref paramefers. 


“■ CHRISTIAN NAGEL The normally small performance overhead associafed wifh 
boxing and unboxing can become huge if you are iferafing over large collecfions. 
Generic collecfion classes help wifh fhis problem. 




4.3.1 Boxing Conversions 

A boxing conversion permifs a value-type fo be implicifly converfed fo a reference-type. The 
following boxing conversions exisf: 

• From any value-type fo fhe fype object. 

• From any value-type fo fhe fype System.ValueType. 

• From any non-nullable-value-type fo any interface-type implemenfed by fhe value-type. 

• From any nullable-type fo any interface-type implemenfed by fhe underlying fype of fhe 
nullable-type. 


“■ VLADIMIR RESHETNIKOV The nwHafe/e-fi/pe does nof implement fhe inferfaces 
from ifs underlying fype; if is simply convertible to them. This distinction is impor¬ 
tant in some contexts—for example, in checking generic consfrainfs. 


• From any enum-type fo fhe fjT’S System. Enum. 

• From any nullable-type wifh an underlying enum-type fo fhe fype System .Enum. 


156 


www.it-ebooks.info 












4.3 Boxing and Unboxing 


“■ BILL WAGNER The choice of the word "conversion" here is illustrative of the 
behavior seen in these circumstances. You are not reinterpreting the same storage as a 
different type; you are converting it. That is, you are examining different storage, not 
looking at the same storage through two different variable t 5 ^es. 


Note that an implicit conversion from a type parameter will be executed as a boxing con¬ 
version if at runtime it ends up converting from a value type to a reference type (§6.1.10). 

Boxing a value of a non-nullable-value-type consists of allocating an object instance and 
copying the non-nullable-value-type value into that instance. 

Boxing a value of a nullable-type produces a null reference if it is the null value (HasValue 
is false), or the result of unwrapping and boxing the underlying value otherwise. 

The actual process of boxing a value of a non-nullable-value-type is best explained by imag¬ 
ining the existence of a generic boxing class, which behaves as if it were declared as 
follows: 

sealed class Box<T>: System.ValueType 

{ 

T value; 

public Box(T t) { 
value = t; 

} 

} 

Boxing of a value v of t 5 ^e T now consists of executing the expression new Box<T > ( v) and 
returning the resulting instance as a value of t 5 ^e object. Thus the statements 

int 1 = 123; 
object box = 1; 

conceptually correspond to 
int 1 = 123; 

object box = new Box<int>(i); 

A boxing class like Box<T> above doesn't actually exist, and the djmamic type of a boxed 
value isn't actually a class tj^e. Instead, a boxed value of type T has the djmamic tj^e T, and 
a djmamic tj^e check using the is operator can simply reference type T. For example, 

int 1 = 123; 
object box = 1; 
if (box is int) { 

Console.Write("Box contains an int"); 

} 

will output the string "Box contains an int" on the console. 




157 


www.it-ebooks.info 


Types 






Types 


4. Types 


A boxing conversion implies making a copy of the value being boxed. This is different from 
a conversion of a reference-type to t5^e object, in which the value continues to reference the 
same instance and simply is regarded as the less derived type object. For example, given 
the declaration 

struct Point 
{ 

public int x, y; 

public Point(int x, int y) { 

this.x = x; 
this.y = y; 

} 

} 

the following statements 

Point p = new Point(10, 10); 
object box = p; 
p.x = 20; 

Console.Write(((Point)box).x); 


will output the value 10 on the console because the implicit boxing operation that occurs 
in the assignment of p to box causes the value of p to be copied. Had Point been declared a 
class instead, the value 20 would be output because p and box would reference the same 
instance. 


“■ ERIC LIPPERT This possibility is just one reason why it is a good practice to make 
structs immutable. If the struct cannot mutate, then the fact that boxing makes a copy 
is irrelevant: Both copies will be identical forever. 




4.3.2 Unboxing Conversions 

An unboxing conversion permits a reference-type to be explicitly converted to a value-type. 
The following unboxing conversions exist: 

• From the type object to any value-type. 

• From the tj^e System. ValueType to any value-type. 

• From any interface-type to any non-nullable-value-type that implements the interface-type. 

• From any interface-type to any nullable-type whose underlying tj^e implements the 
interface-type. 

• From the type System. Enum to any enum-type. 

• From the type System. Enum to any nullable-type with an underlying enum-type. 


158 


www.it-ebooks.info 






4.3 Boxing and Unboxing 


“■ BILL WAGNER As with boxing, unboxing involves a conversion. If you box a 
struct and then unbox it, three different storage locations may result. You most cer¬ 
tainly do not have three variables examining the same storage. 


Note that an explicit conversion to a type parameter will be executed as an unboxing con¬ 
version if at runtime it ends up converting from a reference type to a value type (§6.2.6). 

An unboxing operation to a non-nullable-value-type consists of first checking that the object 
instance is a boxed value of the given non-nullable-value-type, and then copying the value 
out of the instance. 


"■ ERIC LIPPERT Although it is legal to convert an unboxed int to an unboxed 
double, it is not legal to convert a boxed int to an unboxed double —only to an 
unboxed int. This constraint exists because the unboxing instruction would then have 
to know all the rules for type conversions that are normally done by the compiler. If 
you need to do these kinds of conversions at runtime, use the Convert class instead of 
an unboxing cast. 


Unboxing to a nullable-type produces the null value of the nullable-type if the source oper¬ 
and is null, or the wrapped result of unboxing the object instance to the underlying type 
of the nullable-type otherwise. 

Referring to the imaginary boxing class described in the previous section, an unboxing 
conversion of an object box to a value-type T consists of executing the expression ( (Box<T>) 
box) .value. Thus the statements 

object box = 123; 
int i = (int)box; 

conceptually correspond to 

object box = new Box<int>(123); 
int i = ((Box<int>)box).value; 

For an unboxing conversion to a given non-nullable-value-type to succeed at runtime, the 
value of the source operand must be a reference to a boxed value of that non-nullable-value- 
type. If the source operand is null, a System.NullReferenceException is thrown. If the 
source operand is a reference to an incompatible object, a System. InvalidCastException 
is thrown. 




159 


www.it-ebooks.info 


Types 








Types 


4. Types 


■■ JON SKEET Some unboxing conversions aren't guaranteed to work by the C# 
specification, yet are legal under the CLl specification. For example, the previously 
given description precludes unboxing from an enum value fo ifs underlying fype, and 
vice versa: 

object o = System.DayOfWeek.Sunday; 
int i = (int) o; 

This conversion will succeed in .NET, buf would nof be guaranfeed fo succeed on a 
differenf C# implemenfafion. 


For an unboxing conversion fo a given nullable-type fo succeed af runtime, fhe value of fhe 
source operand musf be eifher null or a reference fo a boxed value of fhe underlying non- 
nullable-value-type of fhe nullable-type. If fhe source operand is a reference fo an incompati¬ 
ble objecf, a System. InvalidCastException is fhrown. 


"■ CHRIS SELLS Boxing and unboxing are designed such fhaf you almosf never 
have fo fhink abouf fhem unless you're frying fo reduce your memory usage (in which 
case, profiling is your friend!). However, if you see out or ref values whose values 
don'f seem fo be sef properly af fhe caller's sife, suspecf boxing. 




4.4 Constructed Types 

A generic fype declarafion, by ifself, denofes an unbound generic type fhaf is used as a 
"blueprinf" fo form many differenf fypes, by way of applying type arguments. The fype 
argumenfs are wriffen wifhin angle brackefs (< and >) immediafely following fhe name of 
fhe generic fype. A fype fhaf includes af leasf one fj^e argumenf is called a constructed 
type. A consfrucfed type can be used in most places in the language in which a type name 
can appear. An unbound generic type can be used only within a typeof-expression (§7.6.11). 

Constructed types can also be used in expressions as simple names (§7.6.2) or when access¬ 
ing a member (§7.6.4). 

When a namespace-or-type-name is evaluated, only generic types with the correct number of 
fype paramefers are considered. Thus if is possible fo use fhe same idenfifier fo identify 
differenf fypes, as long as fhe fypes have differenf numbers of type parameters. This is use¬ 
ful when mixing generic and nongeneric classes in fhe same program: 


160 


www.it-ebooks.info 








4.4 Constructed Types 


namespace Widgets 
{ 

class Queue {... } 

class Queue<TElement> {...} 

} 

namespace MyApplication 
{ 

using Widgets; 

class X 
{ 

Queue ql; // Nongeneric Widgets.Queue 

Queue<int> q2; // Generic Widgets.Queue 

} 

} 

A type-name might identify a constructed t 5 ^e even though it doesn't specify fype param- 
efers direcfly. This can occur where a fype is nesfed wifhin a generic class declaration, and 
fhe insfance type of fhe confaining declarafion is implicifly used for name lookup 
(§10.3.8.6): 

class Outer<T> 

{ 

public class Inner {...} 

public Inner i; // Type of i is Outer<T>.Inner 

} 

In unsafe code, a consfrucfed t 5 ^e cannof be used as an unmanaged-type (§18.2). 

4.4.1 Type Arguments 

Each argumenf in a fype argumenf lisf is simply a type. 

type-argument-list: 

< type-arguments > 

type-arguments: 

type-argument 

type-arguments , type-argument 
type-argument: 




In unsafe code (§18), a type-argument may nof be a poinfer fype. Each fype argumenf musf 
safisfy any consfrainfs on fhe corresponding f 5 ^e paramefer (§10.1.5). 


161 


www.it-ebooks.info 


Types 




Types 


4. Types 


4.4.2 Open and Closed Types 

All tj^es can be classified as either open types or closed types. An open type is a t 5 ^e that 
involves t 5 ^e parameters. More specifically: 

• A t 5 ^e parameter defines an open type. 

• An array type is an open type if and only if its element type is an open type. 

• A constructed type is an open type if and only if one or more of its type arguments is an 
open type. A constructed nested type is an open type if and only if one or more of its 
type arguments or the t 5 ^e arguments of its containing type(s) is an open type. 

A closed t 5 ^e is a t 5 ^e that is not an open t 5 ^e. 

At runtime, all of the code within a generic type declaration is executed in the context of a 
closed constructed type that was created by applying t 5 ^e arguments to the generic decla¬ 
ration. Each t 5 ^e parameter within the generic type is bound to a particular runtime t 5 ^e. 
The runtime processing of all statements and expressions always occurs with closed types, 
and open t 5 ^es occur only during compile-time processing. 

Each closed constructed t 5 ^e has its own set of sfatic variables, which are not shared with 
any other closed constructed t 5 ^es. Since an open type does not exist at runtime, there are 
no static variables associated with an open t 5 ^e. Two closed constructed t 5 ^es are the same 
type if they are constructed from the same unbound generic type, and their corresponding 
type arguments are the same t 5 ^e. 

4.4.3 Bound and Unbound Types 

The term unbound type refers to a nongeneric type or an unbound generic type. The term 
bound type refers to a nongeneric type or a constructed t 5 ^e. 




"■ ERIC LIPPERT Yes, nongeneric types are considered to be both bound and 
unbound. 


An unbound t 5 ^e refers fo the entity declared by a type declaration. An unbound generic 
type is not itself a type, and it cannot be used as the t 5 ^e of a variable, argument, or return 
value, or as a base type. The only construct in which an unbound generic type can be ref¬ 
erenced is the typeof expression (§7.6.11). 

4.4.4 Satisfying Constraints 

Whenever a constructed type or generic method is referenced, fhe supplied t 5 ^e argu¬ 
ments are checked against the t 5 ^e parameter constraints declared on the generic type or 


162 


www.it-ebooks.info 






4.4 Constructed Types 


method (§10.1.5). For each where clause, the type argument A that corresponds to the named 
type parameter is checked against each constraint as follows: 

• If the constraint is a class type, an interface type, or a type parameter, let C represent that 
constraint with the supplied type arguments substituted for any type parameters that 
appear in the constraint. To satisfy the constraint, it must be the case that t 5 ^e A is con¬ 
vertible to t 5 ^e C by one of the following: 

- An identity conversion (§6.1.1). 

- An implicit reference conversion (§6.1.6). 

- A boxing conversion (§6.1.7), provided fhaf t 5 ^e A is a non-nullable value t 5 ^e. 

- An implicit reference, boxing, or type parameter conversion from a type parameter 
A to C. 

• If the constraint is the reference t 5 ^e constraint (class), the type A must satisfy one of 
fhe following: 

- A is an inferface type, class t 5 ^e, delegate type, or array type. Both System. ValueType 
and System. Enum are reference fypes fhaf satisfy fhis constrainf. 

A is a t 5 ^e paramefer fhaf is known fo be a reference type (§10.1.5). 

• If the constraint is the value t 5 ^e constraint (struct), the t 5 ^e A must satisfy one of the 
following: 

A is a struct t 5 ^e or enum t 5 ^e, but not a nullable type. Both System.ValueType and 
System .Enum are reference t 5 ^es that do not satisfy this constraint. 

A is a type parameter having the value t 5 ^e constraint (§10.1.5). 

• If the constraint is the constructor constraint new(), the type A must not be abstract 
and must have a public parameterless constructor. This is satisfied if one of fhe follow¬ 
ing is true: 

A is a value t 5 ^e, since all value t 5 ^es have a public default constructor (§4.1.2). 

- A is a type parameter having the constructor constraint (§10.1.5). 

A is a type parameter having the value t 5 ^e constraint (§10.1.5). 




A is a class that is not abstract and contains an explicitly declared public constructor 
with no parameters. 

A is not abstract and has a default constructor (§10.11.4). 

A compile-time error occurs if one or more of a type parameter's constraints are not satis¬ 
fied by the given type arguments. 


163 


www.it-ebooks.info 


Types 




Types 


4. Types 


Since t 5 ^e parameters are not inherited, constraints are never inherited either. In the exam¬ 
ple below, D needs to specify the constraint on its type parameter T so that T satisfies the 
constraint imposed by the base class B<T>. In contrast, class E need not specify a consfraint, 
because List<T> implemenfs lEnumerable for any T. 

class B<T> where T: lEnumerable {...} 
class D<T>: B<T> where T: lEnumerable {...} 
class E<T>: B<List<T>> {...} 




4.5 Type Parameters 

A type parameter is an identifier designafing a value type or reference type that the 

parameter is bound to at runtime. 

type-parameter: 

identifier 

Since a type parameter can be instantiated with many different actual type arguments, 

type parameters have slightly different operations and restrictions than other t 5 ^es: 

• A type parameter cannot be used directly to declare a base class (§10.2.4) or interface 
(§13.1.3). 

• The rules for member lookup on f 5 ^e paramefers depend on the constraints, if any, 
applied to the t 5 ^e parameter. They are detailed in §7.4. 

• The available conversions for a type parameter depend on the constraints, if any, applied 
fo fhe type parameter. They are detailed in §6.1.10 and §6.2.6. 

• The literal null carmot be converted to a t 5 ^e given by a type parameter, except if the 
type parameter is known to be a reference type (§6.1.10). However, a default expression 
(§7.6.13) can be used instead. In addition, a value with a t 5 ^e given by a t 5 ^e parameter 
can be compared with null using == and ! = (§7.10.6) unless the t 5 ^e parameter has the 
value t 5 ^e constraint. 

• A new expression (§7.6.10.1) can be used with a t 5 ^e parameter only if the type parameter 
is constrained by a constructor-constraint or the value t 5 ^e constraint (§10.1.5). 

• A t 5 ^e parameter cannot be used an 5 rwhere within an attribute. 

• A t 5 ^e parameter cannot be used in a member access (§7.6.4) or type name (§3.8) to 
identify a sfafic member or a nested t 5 ^e. 

• In unsafe code, a f 5 ^e paramefer cannof be used as an unmanaged-type (§18.2). 


164 


www.it-ebooks.info 




4.6 Expression Tree Types 


As a type, type parameters are purely a compile-time construct. At runtime, each type 
parameter is bound to a runtime t 5 ^e that was specified by supplying a t 5 ^e argument to 
the generic type declaration. Thus the t 5 ^e of a variable declared wifh a fype paramefer 
will, af runfime, be a closed consfrucfed type (§4.4.2). The runtime execution of all sfafe- 
menfs and expressions involving f 5 ^e paramefers uses fhe acfual type that was supplied 
as the t 5 ^e argument for fhaf paramefer. 


4.6 Expression Tree Types 

Expression trees permif anonymous functions fo be represenfed as dafa sfrucfures insfead 
of execufable code. Expression frees are values of expression tree types of fhe form System. 
Linq. Expressions. Expression<D>, where D is any delegafe type. For the remainder of fhis 
specification, we will refer fo fhese fypes using fhe shorfhand Expression<D>. 

If a conversion exisfs from an anonymous funcfion fo a delegafe type D, a conversion also 
exists to the expression tree t 5 ^e Expression<D>. Whereas the conversion of an anonymous 
funcfion fo a delegafe fype generafes a delegafe fhaf references execufable code for fhe 
anonymous funcfion, conversion fo an expression free fype creafes an expression free rep- 
resenfafion of fhe anonymous funcfion. 

Expression frees are efficienf in-memory dafa represenfafions of anonymous functions and 
make fhe sfrucfure of fhe anonymous fimcfion fransparenf and explicif. 

Jusf like a delegafe type D, Expression<D> is said to have parameter and return types, 
which are the same as those of D. 

The following example represenfs an anonymous funcfion bofh as execufable code and 
as an expression free. Because a conversion exisfs fo Func<int, int>, a conversion also 
exisfs fo Expression<Func<intjint>>: 

Func<int,int> del = x => x + 1; // Code 

Expression<Func<int,int>> exp = x => x + 1; // Data 

Following these assignments, the delegate del references a mefhod fhaf refurns x + 1, 
and fhe expression free exp references a dafa sfrucfure fhaf describes fhe expression x => 
X + 1. 

The exacf definition of fhe generic f 5 ^e Expression<D> as well as fhe precise rules for con¬ 
structing an expression tree when an anonymous function is converted to an expression 
tree type are implementation defined. 




165 


www.it-ebooks.info 


Types 




Types 


4. Types 


Two things are important to make explicit: 

• Not all anonymous functions can be represented as expression trees. For instance, anon¬ 
ymous functions with statement bodies and anonymous fimctions containing assign¬ 
ment expressions carmot be represented. In these cases, a conversion still exists, but will 
fail af compile time. 

• Expression<D> offers an insfance mefhod Compile fhaf produces a delegafe of 1)^0 D: 

Func<int,int> del2 = exp.Compile(); 

Invoking fhis delegafe causes fhe code represenfed by fhe expression free fo be execufed. 

Thus, given fhe definifions above, del and del2 are equivalenf, and fhe following fwo 

sfafemenfs will have fhe same effecf: 

int il = del(l); 

int i2 = del2(l); 

Affer executing fhis code, il and i2 will bofh have fhe value 2. 


4.7 The dynamic Type 

The type dynamic has special meaning in C#. Its purpose is to allow dynamic binding, 
which is described in detail in §7.2.2. 

The dynamic type is considered identical to the object type except in the following 
respecfs: 

• Operations on expressions of t 5 q)e dynamic can be d 5 mamically bound (§7.2.2). 

• Type inference (§7.5.2) will prefer dynamic over object if bofh are candidafes. 

Because of fhis equivalence, fhe following sfafemenfs hold: 

• There is animplicif identify conversionbefween object and dynamic, and befween con- 
sfrucfed f 5 q)es fhaf are fhe same when replacing dynamic wifh object. 

• Implicif and explicif conversions fo and from object also apply fo and from dynamic. 

• Mefhod signafures fhaf are fhe same when replacing dynamic wifh object are consid¬ 
ered fhe same signafure. 

The t 5 q)e dynamic is indistinguishable from object af runtime. 

An expression of fhe f 5 q)e dynamic is referred fo as a dynamic expression. 


166 


www.it-ebooks.info 




4.7 The dynamic Type 


“■ ERIC LIPPERT The t 5 ^e dynamic is a bizarre t 5 ^e, but it is important to note 
that, from the compiler's perspective, it is a t 5 ^e. Unlike with var, you can use it in 
most of fhe sifuafions fhaf call for a fype: refurn types, parameter t 5 ^es, t 5 ^e argu¬ 
ments, and so on. 


"■ PETER SESTOFT Actually, var is a reserved word, not a compile-time type, 
whereas dynamic is a compile-time type. The var ke 5 rword tells the compiler, "Please 
infer fhe compile-fime type of fhis variable from ifs inifializer expression." The 
dynamic type essentially tells the compiler, "Do not worry about compile-time type 
checking of expressions in which fhis variable appears; fhe runfime sysfem will do 
fhe righf fhing based on fhe runfime type of fhe value of fhe variable (or fhrow an 
exception, where fhe compiler would have reporfed a t 5 ^e error)." The type dynamic 
cannot be used as receiver (this type) of an exfension mefhod, as base fype of a class, 
or as f 5 ^e bound for a generic fype paramefer, buf ofherwise if can be used preffy 
much like any ofher t 5 ^e. 


"■ MAREK SAFAR Mefhod signafures are considered fo be same when using fhe 
dynamic and object fypes. This allows use of a nice frick: The inferface mefhod 
declared using type object can be directly implemented using a method with t 5 ^e 
dynamic. 


“■ CH RIS SELLS 1 begin to wonder about any language where the following siring 
of characfers is bofh valid and meaningful: 

class Foo { 

public static dynamic DoFoo() {...} 

} 

Of course, fhis means fhaf fhe Do Foo mefhod is a 1)^0 mefhod (as opposed fo an 
insfance mefhod) and fhaf fhe type of fhe refum value is unknown unfil runfime, buf 
if's hard nof fo read DoFoo as bofh static and dynamic af fhe same time and worry 
abouf an occurrence of a singularify. 




167 


www.it-ebooks.info 


Types 












This page intentionally left blank 


www.it-ebooks.info 


5. Variables 


Variables represent storage locations. Every variable has a t 5 ^e that determines what val¬ 
ues can be stored in the variable. C# is a t 5 ^e-safe language, and the C# compiler guaran¬ 
tees that values stored in variables are always of the appropriate type. The value of a 
variable can be changed fhrough assignmenf or fhrough use of fhe ++ and - - operafors. 

A variable musf be definitely assigned (§5.3) before ifs value can be obfained. 

As described in fhe following secfions, variables are eifher initially assigned or initially 
unassigned. An inifially assigned variable has a well-defined inifial value and is always 
considered definifely assigned. An inifially unassigned variable has no inifial value. For an 
initially unassigned variable to be considered definitely assigned at a certain location, an 
assignment to the variable must occur in every possible execution path leading to that 
location. 


5.1 Variable Categories 

C# defines seven cafegories of variables: sfafic variables, insfance variables, array elemenfs, 
value paramefers, reference paramefers, oufpuf paramefers, and local variables. The sec¬ 
fions fhaf follow describe each of fhese cafegories. 

In fhe example 

class A 
{ 

public static int x; 
int y; 

void F(int[] v, int a, ref int b, out int c) 

{ 

int i = 1; 
c = a + b++; 

} 

} 

X is a sfafic variable, y is an insfance variable, v[0] is an array elemenf, a is a value param- 
efer, b is a reference paramefer, c is an oufpuf paramefer, and i is a local variable. 


169 


www.it-ebooks.info 




Variables 


5. Variables 


■■ JESSE LIBERTY It is inevitable—^but unfortunate—that x is used as the name of 
fhe firsf variable described in all our books. Variable names should be self-revealing 
and, excepf perhaps when used as counfers in for loops, should never be given single- 
letter names. I'd much prefer fo see fhis example written (fo sfrefch fhe poinf) as 
follows: 

class ASimpleExampleClass 
{ 

public static int staticMember; 

int memberVariable; 

void ExampleFunction( 

int[] arrayOfIntsParam, 
int simpleParam, 
ref int refParam, 
out int OutParam) 

{ 

int tempVariable = 1; 

outParam = simpleParam + refParam ++; 

} 

} 

While fhe naming scheme may seem cumbersome in fhis simple example, fhere is no 
ambiguify abouf whaf is happening or why—and fhe explanafion fhaf follows is 
nearly superfluous. 


5.1.1 Static Variables 

Afield declared wifh fhe static modifier is called a static variable. Astatic variable comes 
info exisfence before execution of fhe sfafic consfrucfor (§10.12) for ifs confaining fype, and 
ceases fo exisf when fhe associafed applicafion domain ceases fo exisf. 

The initial value of a sfafic variable is fhe defaulf value (§5.2) of fhe variable's type. 

For purposes of definife assignmenf checking, a sfafic variable is considered initially 
assigned. 

5.1.2 Instance Variables 

A field declared wifhouf fhe static modifier is called an instance variable. 


5.1.2.1 Instance Variables in Classes 

An insfance variable of a class comes info exisfence when a new insfance of fhaf class is 
creafed, and ceases fo exisf when fhere are no references fo fhaf insfance and fhe insfance's 
desfrucfor (if any) has execufed. 

The inifial value of an insfance variable of a class is fhe defaulf value (§5.2) of fhe vari¬ 
able's type. 


170 


www.it-ebooks.info 






5.1 Variable Categories 


For the purpose of definite assignment checking, an instance variable of a class is consid¬ 
ered initially assigned. 

5.1.2.2 Instance Variables in Structs 

An instance variable of a struct has exactly the same lifetime as the struct variable to which 
it belongs. In other words, when a variable of a struct type comes into existence or ceases 
to exist, so, too, do the instance variables of the struct. 

The initial assignment state of an instance variable of a struct is the same as that of the con¬ 
taining struct variable. In other words, when a struct variable is considered initially assigned, 
so, too, are its instance variables. When a struct variable is considered initially unassigned, 
its instance variables are likewise unassigned. 


U1 


“■ BILL WAGNER An instance variable in a struct of reference t 5 ^e may not be eli¬ 
gible for garbage collection when the struct containing it ceases to exist. If the object is 
reachable in another path, the object is still alive even though the instance variable of 
the struct is not. This is also true for array elements. 


5.1.3 Array Elements 

The elements of an array come into existence when an array instance is created, and cease 
to exist when there are no references to that array instance. 

The initial value of each of the elements of an array is the default value (§5.2) of the type of 
the array elements. 

For the purpose of definite assignment checking, an array element is considered initially 
assigned. 

5.1.4 Value Parameters 

A parameter declared without a ref or out modifier is a value parameter. 

A value parameter comes into existence upon invocation of the function member (method, 
instance constructor, accessor, or operator) or anonymous function to which the parameter 
belongs, and is initialized with the value of the argument given in the invocation. A value 
parameter normally ceases to exist upon return of the function member or anonymous 
function. Flowever, if the value parameter is captured by an anonymous function (§7.15), 
its lifetime extends at least until the delegate or expression tree created from that anony¬ 
mous function is eligible for garbage collection. 

For the purpose of definite assignment checking, a value parameter is considered initially 
assigned. 


171 


www.it-ebooks.info 


Variables 






Variables 


5. Variables 


5.1.5 Reference Parameters 

A parameter declared with a ref modifier is a reference parameter. 

A reference paramefer does nof create a new storage location. Instead, a reference param- 
efer represenfs fhe same storage locafion as fhe variable given as fhe argument in the func¬ 
tion member or anonymous function invocation. Thus the value of a reference paramefer 
is always the same as the underlying variable. 

The following definite assignment rules apply to reference parameters. Note the different 
rules for output parameters described in §5.1.6. 

• A variable must be definitely assigned (§5.3) before if can be passed as a reference param¬ 
efer in a funcfion member or delegate invocation. 

• Within a function member or anonymous function, a reference parameter is considered 
initially assigned. 

Within an instance method or instance accessor of a struct t 5 ^e, the this ke 5 rword behaves 
exactly as a reference parameter of the struct t 5 ^e (§7.6.7). 


"■ ERICLIPPERT Less formally, the difference between a reference and an outpuf 
paramefer is thaf a reference parameter represents an "input and output" parameter: 
It must be initialized when the method starts, and the method may optionally change 
the contents. An output parameter, by comparison, is used for oufpuf; the method 
must fill in fhe contents and may not peek at the contents until after it has done so. 


■■ JONSKEET Even an output parameter doesn't have to be used solely for oufpuf. 
In particular, after a mefhod has assigned a value to an outpuf paramefer, it can then 
read from if. Because the parameter will share a storage location with another vari¬ 
able, however, there's no guarantee that the value won't change again after it's been 
assigned in the method. This approach prevents output parameters being used 
covariantly. 


“■ ERIC LIPPERT Some other programming languages support another kind of 
paramefer passing: an "inpuf only" reference. That is, the reference fo the variable is 
passed to the method but, unlike a C# reference paramefer, fhe method may not write 
to it—only read from if. This approach is useful for efficienfly passing large value 
fypes around; passing a reference to a variable may lead to better performance than 
passing a copy of the value if fhe value is large. C# does nof supporf fhis kind of refer¬ 
ence passing. 


172 


www.it-ebooks.info 










5.1 Variable Categories 


5.1.6 Output Parameters 

A parameter declared with an out modifier is an output parameter. 

An output parameter does not create a new storage location. Instead, an output parameter 
represents the same storage location as the variable given as the argument in the function 
member or delegate invocation. Thus the value of an output parameter is always the same 
as the underlying variable. 

The following definite assignment rules apply to output parameters. Note the different 
rules for reference parameters described in §5.1.5. 

• A variable need not be definitely assigned before it can be passed as an output param¬ 
eter in a function member or delegate invocation. 

• Following the normal completion of a function member or delegate invocation, each 
variable that was passed as an output parameter is considered assigned in that execu¬ 
tion path. 

• Within a function member or anonymous function, an output parameter is considered 
initially unassigned. 

• Every output parameter of a function member or anonymous function must be defi¬ 
nitely assigned (§5.3) before the function member or anonymous function returns 
normally. 

Within an instance constructor of a struct type, the this ke 5 rword behaves exactly as an 
output parameter of the struct t 5 ^e (§7.6.7). 


U1 


“■ CHRISTIAN NAGEL Instead of using output parameters to return multiple values 
from a function, you might use the tuple tj^e. This t 5 ^e is new with .NET 4. 


5.1.7 Local Variables 

A local variable is declared either by a local-variable-declaration, which may occur in a block, 
afor-statement, a switch-statement, or a using-statement) by aforeach-statement) or by a specific- 
catch-clause for a try-statement. 

The lifetime of a local variable is the portion of program execution during which storage is 
guaranteed to be reserved for it. This lifetime extends at least from entry into the block, for- 
statement, switch-statement, using-statement, foreach-statement, or specific-catch-clause with 
which it is associated, until execution of that block, for-statement, switch-statement, using- 
statement, foreach-statement, or specific-catch-clause ends in any way. (Entering an enclosed 
block or calling a method suspends, but does not end, execution of the current block, for- 
statement, switch-statement, using-statement, foreach-statement, or specific-catch-clause.) If the 


173 


www.it-ebooks.info 


Variables 






Variables 


5. Variables 


in 


local variable is captured by an anonymous function (§7.15.5.1), its lifetime extends at least 
until the delegate or expression tree created from fhe anonymous function, along wifh any 
other objects that come to reference fhe capfured variable, are eligible for garbage 
collecfion. 


“■ BILL WAG N E R This lasf senfence has imporfanf implications for fhe possible cosf 
of local variables capfured in anonymous functions. The lifetimes of fhose variables 
may be much longer, which means any ofher objecfs fhaf are referenced by fhose local 
variables will also live much longer. 


If fhe parenf block, for-statement, switch-statement, using-statement, for each-statement, or 
specific-catch-clause is enfered recursively, a new insfance of fhe local variable is creafed 
each time, and its local-variable-initializer, if any, is evaluafed each time. 

A local variable infroduced by a local-variable-declaration is nof aufomafically inifialized and 
fhus has no defaulf value. For fhe purpose of definife assignmenf checking, a local variable 
infroduced by a local-variable-declaration is considered inifially unassigned. A local-variable- 
declaration may include a local-variable-initializer, in which case fhe variable is considered 
definifely assigned only affer fhe initializing expression (§5.3.3.4). 


"■ ERIC LIPPERT Requiring local variables to be definitely assigned rather than 
automatically assigning them to their default values might seem like it confers a per¬ 
formance benefif; affer all, fhe compiler need nof generafe code fhaf redundanfly 
assigns a defaulf value fo fhe location. In realify, fhis is nof fhe motivation for fhe fea- 
fure. In practice, fhe CLR does initialize local variables fo fheir defaulf values, which 
fypically fakes place very rapidly. The motivating facfor for definife assignmenf checks 
is fhaf if prevenfs a common cause of bugs. C# does nof guess fhaf you meanf for fhe 
local variable fo be inifialized and hide your bug; if requires fhaf fhe local variable be 
explicifly inifialized before you use if. 


Wifhin fhe scope of a local variable infroduced by a local-variable-declaration, if is a compile- 
fime error fo refer fo fhaf local variable in a fexfual position fhaf precedes ifs local-variable- 
declarator. If fhe local variable declaration is implicif (§8.5.1), if is also an error fo refer fo fhe 
variable wifhin ifs local-variable-declarator. 

A local variable infroduced by a for each-statement or a specific-catch-clause is considered defi¬ 
nifely assigned in ifs enfire scope. 

The acfual lifefime of a local variable is implemenfafion-dependenf. For example, a com¬ 
piler mighf sfafically defermine fhaf a local variable in a block is used for only a small 


174 


www.it-ebooks.info 








5.2 Default Values 


portion of that block. Using this analysis, the compiler could generate code that results in 
the variable's storage having a shorter lifetime than its containing block. 

The storage referred to by a local reference variable is reclaimed independently of the life¬ 
time of that local reference variable (§3.9). 


"■ CHRIS SELLS C required variables to be declared at the top of a scope: 

void F() { 

int X = ...; 

Foo(x); // What was x again? 

} 

In C#, it's generally considered bad practice to declare a variable far from where it's 
used. Instead, the following form is preferred: 

void F() { 

int X = ...; 

Foo(x); // Oh, right, I see x... 

} 

Taking this principle, which is known as "locality of reference," into account makes 
your programs more readable and more maintainable. 


U1 


5.2 Default Values 

The following categories of variables are automatically initialized to their default values: 

• Static variables. 

• Instance variables of class instances. 

• Array elements. 

The default value of a variable depends on the type of the variable and is determined as 
follows: 

• For a variable of a value-type, the default value is the same as the value computed by the 
value-type's default constructor (§4.1.2). 

• For a variable of a reference-type, the default value is null. 


175 


www.it-ebooks.info 


Variables 






Variables 


5. Variables 


in 


Initialization to default values is typically done by having the memory manager or garbage 
collector initialize memory to all-bits-zero before if is allocafed for use. For fhis reason, if is 
convenienf fo use all-bifs-zero fo represenf fhe null reference. 


5.3 Definite Assignment 

Af a given locafion in fhe execufable code of a funcfion member, a variable is said fo be 
definitely assigned if fhe compiler can prove, by a parficular sfafic flow analysis (§5.3.3), 
fhaf fhe variable has been aufomafically inifialized or has been fhe fargef of af leasf one 
assignmenf. Informally sfafed, fhe rules of definife assignmenf are: 

• An initially assigned variable (§5.3.1) is always considered definifely assigned. 

• An inifially unassigned variable (§5.3.2) is considered definifely assigned af a given loca¬ 
fion if all possible execution pafhs leading fo fhaf locafion confain af leasf one of fhe 
following: 

- A simple assignmenf (§7.17.1) in which fhe variable is fhe leff operand. 

- An invocafion expression (§7.6.5) or objecf creafion expression (§7.6.10.1) fhaf passes 
fhe variable as an oufpuf paramefer. 

- For a local variable, a local variable declaration (§8.5.1) fhaf includes a variable 
initializer. 

The formal specification underlying fhe above informal rules is described in §5.3.1, §5.3.2, 
and §5.3.3. 

The definife assignmenf sfafes of rnsfance variables of a struct-type variable are fracked 
individually as well as collectively In addition fo fhe rules above, fhe following rules apply 
fo struct-type variables and fheir insfance variables: 

• An insfance variable is considered definifely assigned if ifs confaining struct-type vari¬ 
able is considered definifely assigned. 

• A struct-type variable is considered definifely assigned if each of ifs insfance variables is 
considered definifely assigned. 

Definife assignmenf is a requiremenf in fhe following confexfs: 

• A variable musf be definifely assigned af each locafion where ifs value is obfained. This 
ensures fhaf undefined values never occur. The occurrence of a variable in an expression 
is considered fo obfain fhe value of fhe variable, excepf when 


176 


www.it-ebooks.info 




5.3 Definite Assignment 


- The variable is the left operand of a simple assignmenf, 

- The variable is passed as an oufpuf paramefer, or 

- The variable is a struct-type variable and occurs as fhe leff operand of a member 
access. 

• A variable musf be definifely assigned af each locafion where if is passed as a reference 
paramefer. This ensures fhaf fhe funcfion member being invoked can consider fhe refer¬ 
ence paramefer initially assigned. 

• All oufpuf paramefers of a funcfion member musf be definifely assigned af each locafion 
where fhe funcfion member refums (fhrough a return sfafemenf or fhrough execufion 
reaching fhe end of fhe funcfion member body). This ensures fhaf funcfion members do 
nof refurn undefined values in oufpuf paramefers, fhus enabling fhe compiler fo con¬ 
sider a funcfion member invocafion fhaf fakes a variable as an oufpuf paramefer equiv- 
alenf fo an assignmenf fo fhe variable. 

• The this variable of a struct-type insfance consfrucfor musf be definifely assigned af each 
locafion where fhaf insfance consfrucfor refums. 


U1 


5.3.1 Initially Assigned Variables 

The following cafegories of variables are classified as inifially assigned: 

• Sfafic variables. 

• Insfance variables of class insfances. 

• Insfance variables of inifially assigned sfrucf variables. 

• Array elemenfs. 

• Value paramefers. 

• Reference paramefers. 

• Variables declared in a catch clause or a foreach sfafemenf. 


5.3.2 Initially Unassigned Variables 

The following cafegories of variables are classified as inifially unassigned: 

• Insfance variables of inifially unassigned sfrucf variables. 

• Oufpuf paramefers, including fhe this variable of sfrucf insfance consfrucfors. 

• Local variables, excepf fhose declared in a catch clause or a foreach sfafemenf. 


177 


www.it-ebooks.info 


Variables 




Variables 


5. Variables 


5.3.3 Precise Rules for Determining Definite Assignment 

To determine that each used variable is definitely assigned, the compiler must use a pro¬ 
cess that is equivalent to the one described in this section. 

The compiler processes the body of each funcfion member fhaf has one or more inifially 
unassigned variables. For each inifially unassigned variable v, fhe compiler defermines a 
definite assignment state for v af each of fhe following poinfs in fhe funcfion member: 

• Af fhe beginning of each sfafemenf. 

• Af fhe end poinf (§8.1) of each sfafemenf. 

• On each arc fhaf fransfers confrol fo anofher sfafemenf or fo fhe end poinf of a 
sfafemenf. 

• Af fhe beginning of each expression. 

• Af fhe end of each expression. 

The definife assignmenf sfafe of v can be eifher: 

• Definifely assigned. This indicafes fhaf on all possible confrol flows fo fhis poinf, v has 
been assigned a value. 

• Nof definifely assigned. For fhe sfafe of a variable af fhe end of an expression of type 
bool, the state of a variable fhaf isn'f definifely assigned may (buf doesn'f necessarily) 
fall info one of fhe following subsfafes: 

- Definifely assigned affer true expression. This state indicates that v is definitely 
assigned if fhe boolean expression evaluafed as true, but is not necessarily assigned 
if fhe boolean expression evaluafed as false. 

- Definifely assigned affer false expression. This sfafe indicafes fhaf v is definifely 
assigned if fhe boolean expression evaluafed as false, buf is nof necessarily assigned 
if fhe boolean expression evaluafed as frue. 

The following rules govern how fhe sfafe of a variable v is defermined af each locafion. 

5.3.3.1 General Rules for Statements 

• z; is nof definifely assigned af fhe begirming of a funcfion member body. 

• z; is definifely assigned af fhe beginning of any unreachable sfafemenf. 


178 


www.it-ebooks.info 




5.3 Definite Assignment 


“■ ERIC LI PPERT This rule may strike you as unusual. Why should every variable 
be considered to be definitely assigned within an unreachable statement? Some rea¬ 
sons are discussed here. 

If fhe sfafemenf is unreachable, fhen if will nof execufe. If if will nof execufe, fhen if 
will nof read from an unassigned variable. Therefore, if is nof a problem; fhe compiler 
is looking for pofenfial problems, and fhis is nof one. 

Also, unreachable sfafemenfs are almosf cerfainly misfakes. Once fhe compiler has 
idenfified one misfake, odds are good fhaf a whole hosf of relafed misfakes are clus- 
fered around if. Rafher fhan reporfing a huge number of relafed problems, if is offen a 
beffer idea fo reporf jusf one problem and allow fhe user fo fix if, rafher fhan frying fo 
reporf every possible specification violafion. 




• The definife assignmenf sfafe of v af fhe beginning of any ofher sfafemenf is defermined 
by checking fhe definife assignmenf sfafe of v on all confrol flow fransfers fhaf fargef fhe 
begirming of fhaf sfafemenf. If (and only if) v is definifely assigned on all such confrol 
flow fransfers, fhen v is definifely assigned af fhe beginning of fhe sfafemenf. The sef of 
possible confrol flow fransfers is defermined in fhe same way as for checking sfafemenf 
reachabilify (§8.1). 

• The definife assignmenf sfafe of v af fhe end poinf of a block, checked, unchecked, if, 
while, do, for, foreach, lock, using, or switch sfafemenf is defermined by checking fhe 
definife assignmenf sfafe of v on all confrol flow fransfers fhaf fargef fhe end poinf of fhaf 
sfafemenf. If v is definifely assigned on all such confrol flow fransfers, fhen v is definifely 
assigned af fhe end poinf of fhe sfafemenf. Ofherwise, v is nof definifely assigned af fhe 
end poinf of fhe sfafemenf. The sef of possible confrol flow fransfers is defermined in fhe 
same way as for checking sfafemenf reachabilify (§8.1). 

5.3.3.2 Block Statements, checked Statements, and unchecked Statements 

The definife assignmenf sfafe of v on fhe confrol fransfer fo fhe firsf sfafemenf of fhe sfafe¬ 
menf lisf in fhe block (or fo fhe end poinf of fhe block, if fhe sfafemenf lisf is empfy) is fhe 

same as fhe definife assignmenf sfafemenf of v before fhe block, checked, or unchecked 

sfafemenf. 

5.3.3.3 Expression Statements 

For an expression sfafemenf stmt fhaf consisfs of fhe expression expr: 

• V has fhe same definife assignmenf sfafe af fhe beginning of expr as af fhe begirming 
of stmt. 

• If u is definifely assigned af fhe end of expr, if is definifely assigned af fhe end poinf of 
stmt- ofherwise, if is nof definifely assigned af fhe end poinf of stmt. 


www.it-ebooks.info 


Variables 






Variables 


5. Variables 


5.3.3.4 Declaration Statements 

• If stmt is a declaration statement without initializers, then v has the same definite assign¬ 
ment state at the end point of stmt as at the beginning of stmt. 

• If stmt is a declaration statement with initializers, then the definite assignment state for 
V is determined as if stmt were a statement list, with one assignment statement for each 
declaration with an initializer (in the order of declaration). 

5.3.3.5 if Statements 

For an if statement stmt of the form: 

if ( expr ) then-stmt else else-stmt 

• V has the same definite assignment state at the beginning of expr as at the begirming 
of stmt. 

• If z; is definitely assigned at the end of expr, then it is definitely assigned on the control 
flow transfer to then-stmt and to either else-stmt or to the end point of stmt if there is no 
else clause. 

• If z; has the state "definitely assigned after true expression" at the end of expr, then it is 
definitely assigned on the control flow transfer to then-stmt, and not definitely assigned 
on the control flow transfer to either else-stmt or to the end point of stmt if there is no 
else clause. 

• If z; has the state "definitely assigned after false expression" at the end of expr, then it is 
definitely assigned on the control flow transfer to else-stmt, and not definitely assigned 
on the control flow transfer to then-stmt. It is definitely assigned at the end point of stmt 
if and only if it is definitely assigned at the end point of then-stmt. 

• Otherwise, v is considered not definitely assigned on the control flow transfer to either 
then-stmt or else-stmt, or to the end point of stmt if there is no else clause. 

5.3.3.6 switch Statements 

In a switch statement stmt with a controlling expression expr: 

• The definite assignment state of v at the begirming of expr is the same as the state of v at 
the begirming of stmt. 

• The definite assignment state of v on the control flow transfer to a reachable switch block 
statement list is the same as the definite assignment state of v at the end of expr. 


www.it-ebooks.info 




5.3 Definite Assignment 


“■ ERIC LIPPERT Unfortunately, in the few cases where it is feasible to switch 
exhaustively on the entire range of a controlling expression without a default switch 
label (that is, bool, the byte types, and their corresponding nullable t 5 ^es), definite 
assignment checking does not take into consideration the possibility that a variable 
may be definitely assigned at the end of the switch if it is definitely assigned at the 
end of every switch section. For example: 

int x; 

bool b = B(); 

switch(b) { 

case true : x = 1; break; 

case false: x = 2; break; 

} 

Console.WriteLine(x); // Error: x is not definitely assigned 
In those rare cases, you can always put an urmecessary default switch label on one of 
the switch sections to make the definite assignment checker happy. 


U1 


5.3.3.7 while Statements 

For a while statement stmt of the form: 

while ( expr ) ivhile-body 

• V has the same definite assignment state at the beginning of expr as at the beginning 
of stmt. 

• If u is definitely assigned at the end of expr, then it is definitely assigned on the control 
flow transfer to while-body and to the end point of stmt. 

• If u has the state "definitely assigned after true expression" at the end of expr, then it is 
definitely assigned on the control flow transfer to while-body, but not definitely assigned 
at the end point of stmt. 

• If V has the state "definitely assigned after false expression" at the end of expr, then it is 
definitely assigned on the control flow transfer to the end point of stmt, but not definitely 
assigned on the control flow transfer to while-body. 

5.3.3.8 do Statements 

For a do statement stmt of the form: 

do do-body while ( expr ) ; 

• V has the same definite assignment state on the control flow transfer from the beginning 
of stmt to do-body as at the begirming of stmt. 


181 


www.it-ebooks.info 


Variables 






Variables 


5. Variables 


• V has the same definite assignment state at the beginning of expr as af fhe end poinf of 
do-body. 

• If z; is definifely assigned af fhe end of expr, fhen if is definifely assigned on fhe confrol 
flow fransfer fo fhe end poinf of stmt. 

• If z; has fhe sfafe "definifely assigned affer false expression" af fhe end of expr, fhen if is 
definifely assigned on fhe confrol flow fransfer fo fhe end poinf of stmt. 

5.3.3.9 for Statements 

Definife assignmenf checking for a for sfafemenf of fhe form: 

for ( for-initializer j for-condition ; for-iterator ) embedded-statement 
is done as if fhe sfafemenf were wriffen: 

{ 

for-initializer ; 
while ( for-condition ) { 
embedded-statement; 
for-iterator ; 

} 

} 

If the for-condition is omiffed from fhe for sfafemenf, fhen evaluafion of definife assign¬ 
menf proceeds as it for-condition were replaced wifh true in fhe above expansion. 

5.3.3.10 break, continue, and goto Statements 

The definife assignmenf sfafe of v on fhe confrol flow fransfer caused by a break, continue, 
or goto sfafemenf is fhe same as fhe definife assignmenf sfafe of v af fhe begirming of fhe 
sfafemenf. 

5.3.3.11 throw Statements 

For a sfafemenf stmt of fhe form: 

throw expr ; 

fhe definife assignmenf sfate of v af fhe begirming of expr is fhe same as fhe definife assign¬ 
menf sfafe of V af fhe begirming of stmt. 

5.3.3.12 return Statements 

For a sfafemenf stmt of fhe form: 

return expr ; 


182 


www.it-ebooks.info 




5.3 Definite Assignment 


• The definite assignment state of v at the beginning of expr is the same as the definite 
assignment state of v at the beginning of stmt. 

• If i; is an output parameter, then it must be definitely assigned either 

- After expr or 

- At the end of the finally block of a try-finally or try-catch-finally that encloses 
the return statement. 

For a statement stmt of the form: 

return ; 

• If u is an output parameter, then it must be definitely assigned either 

- Before stmt or 

- At the end of the finally block of a try-finally or try-catch-finally that encloses 
the return statement. 


U1 


5.3.3.13 try-catch Statements 


"■ BILL WAGNER Starting here, you see how any of the nonstructured statements 
(e.g., throw, catch, goto, finally) can complicate both the compiler's analysis and 
your own understanding. Be careful how you use these statements in your regular 
logic. The try/finally statement is a simplified special case, but the general cases can 
greatly decrease program readability. 


For a statement stmt of the form: 

try try-block 

catch(...) catch-block-1 

catch(...) catch-block-n 

• The definite assignment state of v at the beginning of try-block is the same as the definite 
assignment state of v at the beginning of stmt. 

• The definite assignment state of v at the beginning of catch-block-i (for any i) is the same 
as the definite assignment state of v at the beginning of stmt. 

• The definite assignment state of v at the end point of stmt is definitely assigned if (and 
only if) V is definitely assigned at the end point of try-block and every catch-block-i (for 
every i from 1 to n). 


183 


www.it-ebooks.info 


Variables 






Variables 


5. Variables 


in 


5.3.3.14 try-finallyStatements 

For a try statement stmt of the form: 

try try-block finally finally-block 

• The definife assignmenf sfafe of v af fhe beginning of try-block is fhe same as fhe definife 
assignmenf sfafe of v af fhe beginning of stmt. 

• The definife assignmenf sfafe of v af fhe beginning oi finally-block is fhe same as fhe 
definife assignmenf sfafe of v af fhe beginning of stmt. 

• The definife assignmenf sfafe of v af fhe end poinf of stmt is definifely assigned if (and 
only if) af leasf one of fhe following is frue: 

- V is definifely assigned af fhe end poinf of try-block. 

- V is definifely assigned af fhe end poinf oi finally-block. 

If a confrol flow fransfer (for example, a goto sfafemenf) is made fhaf begins wifhin try- 
block and ends oufside of try-block, fhen v is also considered definifely assigned on fhaf 
confrol flow fransfer if v is definifely assigned af fhe end poinf oi finally-block. (This is nof 
an "only if": If v is definifely assigned for anofher reason on fhis confrol flow fransfer, fhen 
if is sfill considered definifely assigned.) 


5.3.3.15 try-catch-finally Statements 

Definife assignmenf analysis for a try-catch-finally sfafemenf of fhe form: 
try try-block 

catch( ...) catch-block-1 

catch(...) catch-block-n 
finally finally-block 

is done as if fhe sfafemenf were a try-finally sfafemenf enclosing a try-catch sfafemenf: 
try { 

try try-block 

catch (...) catch-block-1 

catch (...) catch-block-n 

} 

finally finally-block 

The following example demonsfrafes how fhe differenf blocks of a try sfafemenf (§8.10) 
affecf definife assignmenf. 


184 


www.it-ebooks.info 




5.3 Definite Assignment 


class A 

{ 

static void F() 

{ 

int i, j; 
try 
{ 

goto LABEL; 

// Neither i nor j definitely assigned 
i = i; 

// i definitely assigned 

} 

catch 

{ 

// Neither i nor j definitely assigned 
i = 3; 

// i definitely assigned 

} 

finally 

{ 

// Neither i nor j definitely assigned 
j = 5; 

// j definitely assigned 

} 

// i and j definitely assigned 
LABEL; ; 

// j definitely assigned 




} 

} 

5.3.3.16 foreach Statements 

For a foreach statement stmt of the form: 

foreach ( type identifier in expr ) embedded-statement 

• The definite assignment state of v at the begirming of expr is the same as the state of v at 
the begirming of stmt. 

• The definite assignment state of v on the control flow transfer to embedded-statement or 
to the end point of stmt is the same as the state of v at the end of expr. 

5.3.3.17 using Statements 

For a using sfafement stmt of the form: 

using ( resource-acquisition ) embedded-statement 

• The definite assignment state of v at the begirming of resource-acquisition is the same as 
the state of v at the begirming of stmt. 


185 


www.it-ebooks.info 


Variables 




Variables 


5. Variables 


• The definite assignment state of v on the control flow transfer to embedded-statement is 
the same as the state of v at the end of resource-acquisition. 

5.3.3.18 lock Statements 

For a lock statement stmt of the form: 

lock ( expr ) embedded-statement 

• The definite assignment state of v at the beginning of expr is the same as the state of v at 
the beginning of stmt. 

• The definite assignment state of v on the control flow transfer to embedded-statement is 
the same as the state of v at the end of expr. 

5.3.3.19 yield Statements 

For a yield return statement stmt of the form: 

yield return expr ; 

• The definite assignment state of v at the beginning of expr is the same as the state of v at 
the beginning of stmt. 

• The definite assignment state of v at the end of stmt is the same as the state of v at the 
end of expr. 

A yield break statement has no effect on the definite assignment state. 

5.3.3.20 General Rules for Simple Expressions 

The following rule applies to these kinds of expressions: literals (§7.6.1), simple names 
(§7.6.2), member access expressions (§7.6.4), non-indexed base access expressions (§7.6.8), 
typeof expressions (§7.6.11), and default value expressions (§7.6.13). 

• The definite assignment state of v at the end of such an expression is the same as the 
definite assignment state of v at the beginning of the expression. 

5.3.3.21 General Rules for Expressions with Embedded Expressions 

The following rules apply to these kinds of expressions: parenthesized expressions (§7.6.3); 
element access expressions (§7.6.6); base access expressions with indexing (§7.6.8); incre¬ 
ment and decrement expressions (§7.6.9, §7.7.5); cast expressions (§7.7.6); unary +, -, ~, 

• expressions; binary +, -, *, /, %, <<, >>, <, <=, >, >=, ==, ! =, is, as, &, |, '^ expressions (§7.8, 
§7.9, §7.10, §7.11); compound assignment expressions (§7.17.2); checked and unchecked 
expressions (§7.6.12); plus array and delegate creation expressions (§7.6.10). 


186 


www.it-ebooks.info 




5.3 Definite Assignment 


Each of these expressions has one or more subexpressions that are unconditionally evalu¬ 
ated in a fixed order. For example, the binary % operator evaluates the left-hand side of the 
operator, then the right-hand side. An indexing operation evaluates the indexed expres¬ 
sion, and then evaluates each of the index expressions, in order from left to right. For an 
expression expr that has subexpressions expr^, expr ^,..., expr^^, evaluated in that order: 

• The definite assignment state of v at the begirming of expr^ is the same as the definite 
assignment state at the begirming of expr. 

• The definife assignment state of v at the beginning of expr. {i greafer than 1) is the same 
as the definite assignment state at the end of expr j. 

• The definite assignment state of v at the end of expr is the same as the definite assignment 
state at the end of expr^. 


U1 


5.3.3.22 Invocation Expressions and Object Creation Expressions 

For an invocation expression expr of the form: 

primary-expression ( arg^ , arg^ , ... , arg^ ) 

or an object creation expression of the form: 
new type ( arg^ , arg^ ^ ■■■ , arg^ ) 

• For an invocation expression, the definite assignment state of v before primary-expression 
is fhe same as the state of v before expr. 

• For an invocation expression, the definite assignment state of v before arg^ is the same as 
the state of v after primary-expression. 

• For an object creation expression, the definite assignment state of v before arg^ is fhe 
same as the state of v before expr. 

• For each argumenf arg., fhe definite assignment state of v affer arg. is determined by the 
normal expression rules, ignoring any ref or out modifiers. 

• For each argument arg. for any i greater than 1, the definite assignment state of v before 
arg. is the same as the state of v after arg._j. 

• If the variable v is passed as an out argument (i.e., an argument of fhe form "out v") in 
any of the arguments, then the state of v affer expr is definitely assigned. Otherwise, the 
state of V after expr is the same as the state of v affer arg^. 

• For array initializers (§7.6.10.4), object initializers (§7.6.10.2), collection initializers 
(§7.6.10.3), and anonymous object initializers (§7.6.10.6), the definite assignment state is 
determined by the expansion that these constructs are defined in terms of. 


187 


www.it-ebooks.info 


Variables 




Variables 


5. Variables 


in 


5.3.3.23 Simple Assignment Expressions 

For an expression expr of the form w = expr-rhs: 

• The definite assignment state of v before expr-rhs is the same as the definite assignment 
state of V before expr. 

• If If is the same variable as v, then the definite assignment state of v after expr is definitely 
assigned. Otherwise, the definite assignment state of v after expr is the same as the defi¬ 
nite assignment state of v after expr-rhs. 

5.3.3.24 && Expressions 

For an expression expr of the form expr-first && expr-second: 

• The definite assignment state of v before expr-first is the same as the definite assignment 
state of V before expr. 

• The definite assignment state of v before expr-second is definitely assigned if the state of 
V after expr-first is either definitely assigned or "definitely assigned after true expres¬ 
sion." Otherwise, it is not definitely assigned. 

• The definite assignment state of v after expr is determined by: 

- If the state of v after expr-first is definitely assigned, then the state of v after expr is 
definitely assigned. 

- Otherwise, if the state of v after expr-second is definitely assigned, and the state of v 
after expr-first is "definitely assigned after false expression," then the state of v after 
expr is definitely assigned. 

- Otherwise, if the state of v after expr-second is definitely assigned or "definitely 
assigned after true expression," then the state of v after expr is "definitely assigned 
after true expression." 

- Otherwise, if the state of v after expr-first is "definitely assigned after false expres¬ 
sion," and the state of v after expr-second is "definitely assigned after false expression," 
then the state of v after expr is "definitely assigned after false expression." 

- Otherwise, the state of v after expr is not definitely assigned. 

In the example 

class A 
{ 

static void F(int x, int y) 

{ 

int i; 

if (x >= 0 && (i = y) >= 0) 


188 


www.it-ebooks.info 




5.3 Definite Assignment 


{ 

// i definitely assigned 

} 

else 




// i not definitely assigned 

} 

// i not definitely assigned 

} 

} 

the variable i is considered definitely assigned in one of fhe embedded sfafemenfs of an if 
sfafemenf buf nof in fhe ofher. In fhe if sfafemenf in mefhod F, fhe variable i is definifely 
assigned in fhe firsf embedded sfafemenf because execufion of fhe expression (i = y) 
always precedes execufion of fhis embedded sfafemenf. In confrasf, fhe variable i is nof 
definifely assigned in fhe second embedded sfafemenf, because x >= 0 mighf have fesfed 
false, resulting in fhe variable i being unassigned. 

5.3.3.25 II Expressions 

For an expression expr of fhe form expr-first \ | expr-second: 

• The definife assignmenf sfafe of v before expr-first is fhe same as fhe definife assignmenf 
sfafe of V before expr. 

• The definife assignmenf sfafe of v before expr-second is definifely assigned if fhe sfafe of 
V affer expr-first is eifher definifely assigned or "definifely assigned affer false expres¬ 
sion." Ofherwise, if is nof definifely assigned. 

• The definife assignmenf sfafemenf of v affer expr is defermined by: 

- If fhe sfafe of v affer expr-first is definifely assigned, fhen fhe sfafe of v affer expr is 
definifely assigned. 

- Ofherwise, if fhe sfafe of v affer expr-second is definifely assigned, and fhe sfafe of v 
affer expr-first is "definifely assigned affer frue expression," fhen fhe sfafe of v affer 
expr is definifely assigned. 

- Ofherwise, if fhe sfafe of v affer expr-second is definifely assigned or "definifely 
assigned affer false expression," fhen fhe sfafe of v affer expr is "definifely assigned 
affer false expression." 

- Ofherwise, if fhe sfafe of v affer expr-first is "definifely assigned affer frue expres¬ 
sion," and fhe sfafe of v affer expr-second is "definifely assigned affer frue expression," 
fhen fhe sfafe of v affer expr is "definifely assigned affer frue expression." 

- Ofherwise, fhe sfafe of v affer expr is nof definifely assigned. 


189 


www.it-ebooks.info 


Variables 




Variables 


5. Variables 


in 


In the example 

class A 
{ 

static void G(int x, int y) 

{ 

int i; 

if (x >= 0 I I (i = y) >= 0) 

{ 

// i not definitely assigned 

} 

else 

{ 

// i definitely assigned 

} 

// i not definitely assigned 

} 

} 

the variable i is considered definitely assigned in one of fhe embedded sfafemenfs of an if 
sfafemenf buf nof in fhe ofher. In fhe if sfafemenf in mefhod G, fhe variable i is definifely 
assigned in fhe second embedded sfafemenf because execufion of fhe expression (i = y) 
always precedes execufion of fhis embedded sfafemenf. In confrasf, fhe variable i is nof 
definifely assigned in fhe firsf embedded sfafemenf, because x >= 0 mighf have fesfed frue, 
resulting in fhe variable i being unassigned. 


5.3.3.26 ! Expressions 

For an expression expr of fhe form ! expr-operand: 

• The definife assignmenf sfafe of v before expr-operand is fhe same as fhe definife assign- 

menf sfafe of v before expr. 

• The definife assignmenf sfafe of v affer expr is defermined by: 

- If fhe sfafe of v affer expr-operand is definifely assigned, fhen fhe sfafe of v affer expr is 
definifely assigned. 

- If fhe sfafe of v affer expr-operand is nof definifely assigned, fhen fhe sfafe of v affer 
expr is nof definifely assigned. 

- If fhe sfafe of v affer expr-operand is "definifely assigned affer false expression," fhen 
fhe sfafe of v affer expr is "definifely assigned affer frue expression." 

- If fhe sfafe of v affer expr-operand is "definifely assigned affer frue expression," fhen 
fhe sfafe of v affer expr is "definifely assigned affer false expression." 


190 


www.it-ebooks.info 




5.3 Definite Assignment 


5.3.3.27 ?? Expressions 

For an expression expr of the form expr-first ? ? expr-second: 

• The definite assignment state of v before expr-first is the same as the definite assignment 
state of V before expr. 

• The definite assignment state of v before expr-second is the same as the definite assign¬ 
ment state of V after expr-first. 

• The definite assignment state of v after expr is determined by: 

- If expr-first is a constant expression (§7.19) with value null, then the state of v after 
expr is the same as the state of v after expr-second. 

• Otherwise, the state of v after expr is the same as the definite assignment state of v after 
expr-first. 


U1 


5.3.3.28 ?: Expressions 

For an expression expr of the form expr-cond ? expr-true : expr-false: 

• The definite assignment state of v before expr-cond is the same as the state of v 
before expr. 

• The definite assignment state of v before expr-true is definitely assigned if and only if 
the state of v after expr-cond is definitely assigned or "definitely assigned after true 
expression." 

• The definite assignment state of v before expr-false is definitely assigned if and only if 
the state of v after expr-cond is definitely assigned or "definitely assigned after false 
expression." 

• The definite assignment state of v after expr is determined by: 

- If expr-cond is a constant expression (§7.19) with value true, then the state of v after 
expr is the same as the state of v after expr-true. 

- Otherwise, if expr-cond is a constant expression (§7.19) with value false, then the 
state of V after expr is the same as the state of v after expr-false. 

- Otherwise, if the state of v after expr-true is definitely assigned and the state of v after 
expr-false is definitely assigned, then the state of v after expr is definitely assigned. 

- Otherwise, the state of v after expr is not definitely assigned. 


191 


www.it-ebooks.info 


Variables 




Variables 


5. Variables 


in 


5.3.3.29 Anonymous Functions 

For a lambda-expression or anonymous-method-expression expr with a body (either block or 
expression) body. 

• The definite assignment state of an oufer variable v before body is fhe same as fhe sfafe 
of V before expr. Thaf is, definife assignmenf sfafe of oufer variables is inberifed from fhe 
confexf of fhe anonymous fimcfion. 

• The definife assignmenf sfafe of an oufer variable v affer expr is fhe same as fhe sfafe of 
V before expr. 

The example 

delegate bool Filter(int i); 

void F() 

{ 

int max; 

// Error: max is not definitely assigned 
Filter f = (int n) => n < max; 

max = 5; 

DoWork(f); 

} 

generafes a compile-fime error because max is nof definifely assigned where fhe anony¬ 
mous function is declared. The example 

delegate void D(); 

void F() { 
int n; 

D d = 0 => { n = l; }; 
d(); 

// Error: n is not definitely assigned 
Console.WriteLine(n); 

} 

also generafes a compile-fime error because fhe assignmenf fo n in fhe anonymous funcfion 
has no effecf on the definite assignment state of n oufside fhe anonymous funcfion. 


5.4 Variable References 

A variable-reference is an expression fhaf is classified as a variable. A variable-reference denofes 
a sforage location fhaf can be accessed bofh fo fefch fhe currenf value and fo sfore a new 
value. 


192 


www.it-ebooks.info 




5.5 Atomicity of Variable References 


variahle-reference: 

expression 

In C and C++, a variable-reference is known as an lvalue. 




5.5 Atomicity of Variable References 

Reads and writes of the following data types are atomic: bool, char, byte, sbyte, short, 
ushort, uint, int, float, and reference types. In addition, reads and writes of enum types 
with an underlying type in the previous list are also atomic. Reads and writes of other 
types, including long, ulong, double, and decimal, as well as user-defined types, are not 
guaranteed to be atomic. Aside from the library functions designed for that purpose, there 
is no guarantee of atomic read-modify-write, such as in the case of increment. 


"■ ERIC LIPPERT The specification authors make certain assumptions about their 
readers—for instance, that the reader who cares about atomicity already knows what 
it is. If you're nof one of fhose readers, the issue here is that if one fhread is writing fhe 
long 0x0123456776543210 into a variable currently holding zero, then there might be a 
moment in time when another thread could read 0x0123456700000000 from thaf vari¬ 
able. This assignment is not "atomic" because it could happen in two distinct phases: 
first the top 32 bits, then the bottom 32 bits (or vice versa). The C# language guaran¬ 
tees you that this never happens with 32-bit data t 5 ^es, but makes no guarantees 
about anything larger. 


■■ JONSKEET There is often confusion befween afomicify and ofher complicafed 
aspecfs of memory models. In particular, just because an assignment is atomic doesn't 
mean it will be necessarily be seen immediately (or, indeed, at all) by other threads, 
unless S5mchronization techniques such as volatile variables, locks, or explicit memory 
barriers are involved. 


193 


www.it-ebooks.info 


Variables 








This page intentionally left blank 


www.it-ebooks.info 


6. Conversions 


A conversion enables an expression to be treated as being of a particular type. A conversion 
may cause an expression of a given type to be treated as having a different type, or it may 
cause an expression without a type to get a type. Conversions can be implicit or explicit, 
and this determines whether an explicit cast is required. For instance, the conversion from 
fype int to type long is implicit, so expressions of type int can implicitly be treated as type 
long. The opposite conversion, from f 5 q)e long fo type int, is explicit and so an explicit cast 
is required. 

int a = 123; 

long b = a; // Implicit conversion from int to long 

int c = (int) b; // Explicit conversion from long to int 

Some conversions are defined by the language. Programs may also define their own con¬ 
versions (§6.4). 


"■ ERIC LIPPERT The classification of conversions info "explicit" and "implicit" is 
handy when the developer needs to know whether a given conversion might fail af 
runtime. None of the implicit conversions ever fail, but explicit conversions might. 

Another way of partitioning conversions that this specification does not consider in 
depth would be into representation-preserving and representation-changing conver¬ 
sions. For example, an explicit conversion from a base class (Animal) fo a derived class 
(Giraffe) mighf fail af runtime if the expression converted is not an instance of 
Giraffe. If if does succeed, at least we know that the conversion will result in exactly 
the same object. An implicit conversion from int fo double, however, always succeeds 
buf always changes the representation; a brand-new double value is created, which 
has a completely different representation than the integer. 

This partitioning of conversions will become imporfant when we gef fo covarianf 
array conversions. 


195 


www.it-ebooks.info 






Conversions 


6. Conversions 


so 


6.1 Implicit Conversions 

The following conversions are classified as implicif conversions: 

• Identify conversions. 

• Implicif numeric conversions. 

• Implicif enumerafion conversions. 

• Implicif nullable conversions. 

• Null liferal conversions. 

• Implicif reference conversions. 

• Boxing conversions. 

• Implicif d 5 mamic conversions. 

• Implicif consfanf expression conversions. 

• User-defined implicif conversions. 

• Anonymous funcfion conversions. 

• Mefhod group conversions. 

Implicif conversions can occur in a variefy of sifuafions, including funcfion member invo¬ 
cations (§7.5.4), casf expressions (§7.7.6), and assignmenfs (§7.17). 

The predefined implicif conversions always succeed and never cause exceptions fo be 
fhrown. Properly designed user-defined implicif conversions should exhibif fhese charac- 
ferisfics as well. 

For fhe purposes of conversion, fhe fypes object and dynamic are considered equivalenf. 
However, dynamic conversions (§6.1.8 and §6.2.6) apply only fo expressions of type 
dynamic (§4.7). 


6.1.1 Identity Conversion 

An identity conversion converts from any type to the same type. This conversion exists 
such that an entity that already has a required type can be said to be convertible to 
that type. 

Because object and dynamic are considered equivalent, there is an identity conversion 
between object and dynamic, and between constructed types that are the same when 
replacing all occurrences of dynamic with object. 


196 


www.it-ebooks.info 





6.1 Implicit Conversions 


“■ VLADIMIR RESHETNIKOV Thus identity conversion is symmetric: If t 5 ^e T has 
an identity conversion to t 5 ^e S, then t 5 ^e S also has an identity conversion to type T. 
If two t 5 ^es have an identity conversion between them, they always have identical 
runtime representations. For example, List<object[] > and List<dynatnic[ ] >bothare 
represented as List<object [ ] > at runtime. 


"■ BILL WAGNER This is an important property of the dynamic t 5 ^e. It means types 
such as List<object> and List<dynamic> have an identity conversion. You can convert 
a collection of object t 5 ^es to a collection of dynamic t 5 ^es. Furthermore, this identity 
relationship does not exist between dynamic and any t 5 ^e derived from object. That is, 
List<string> and List<dynamic> do not have the identity conversion. 


6.1.2 Implicit Numeric Conversions 

The implicit numeric conversions are: 

• From sbyte to short, int, long, float, double, or decimal. 

• From byte to short, ushort, int, uint, long, ulong, float, double, or decimal. 

• From short to int, long, float, double, or decimal. 

• From ushort to int, uint, long, ulong, float, double, or decimal. 

• From int to long, float, double, or decimal. 

• From uint to long, ulong, float, double, or decimal. 

• From long to float, double, or decimal. 

• From ulong to float, double, or decimal. 

• From char to ushort, int, uint, long, ulong, float, double, or decimal. 

• From float to double. 

Conversions from int, uint, long, or ulong to float and from long or ulong to double may 
cause a loss of precision, but will never cause a loss of magnitude. The other implicit 
numeric conversions never lose any information. 

There are no implicit conversions to the char type, so values of the other integral types do 
not automatically convert to the char t 5 ^e. 




197 


www.it-ebooks.info 


Conversions 








Conversions 


6. Conversions 


6.1.3 Implicit Enumeration Conversions 

An implicit enumeration conversion permits the decimal-integer-literal 0 to be converted to 
any enum-type and to any nullable-type whose underlying type is an enum-type. In the latter 
case, the conversion is evaluated by converting to the underlying enum-type and wrapping 
the result (§4.1.10). 


■■ ERICLIPPERT This issue is particularly important for enums that represent a set 
of flags. To be complianf wifh CLR guidelines, if is a good idea for enum t 5 ^es infended 
fo be used as flags fo be marked wifh fhe [Flags] affribufe and to have a "None" 
value set to zero. But for fhose that do not meet these criteria, it is nice to be able to 
assign zero without having to cast. 

Lots more dos and don'ts exist regarding proper use of enumerafed types. See Section 
4.8 of "Framework Design Guidelines" for details. 

The Microsoft implementation of C# allows any constanf zero to go to any enum, not 
just literal constant zeros. This minor specification violation exists for historical 
reasons. 


■■ JOSEPH ALBAHARI The default value for an enum t5q3e is 0, so assigning fhe 
liferal 0 provides a consistent means of resetting an enum variable to its default value. 
For combinable flags-based enums, 0 means "no flags." 


6.1.4 Implicit Nullable Conversions 

Predefined implicit conversions that operate on non-nullable value t 5 ^es can also be used 
with nullable forms of those t 5 ^es. For each of the predefined implicit identity and numeric 
conversions that convert from a non-nullable value t 5 ^e S to a non-nullable value t 5 ^e T, 
the following implicit nullable conversions exist: 

• An implicit conversion from S? to T?. 

• An implicit conversion from S fo T ?. 

Evaluation of an implicif nullable conversion based on an underlying conversion from S fo 
T proceeds as follows: 

• If fhe nullable conversion is from S ? fo T ?: 

- If the source value is null (HasValue property is false), the result is the null value of 
type T?. 


198 


www.it-ebooks.info 








6.1 Implicit Conversions 


- Otherwise, the conversion is evaluated as an unwrapping from S ? to S, followed 
by the underlying conversion from S to T, followed by a wrapping (§4.1.10) from 
T to T?. 

• If the nullable conversion is from S to T?, the conversion is evaluated as the underlying 
conversion from S to T, followed by a wrapping from T to T?. 


6.1.5 Null Literal Conversions 

An implicit conversion exists from the null literal to any nullable type. This conversion 
produces the null value (§4.1.10) of the given nullable type. 

6.1.6 Implicit Reference Conversions 

The implicit reference conversions are: 

• From any reference-type to object and dynamic. 

• From any class-type S to any class-type T, provided S is derived from T. 

• From any class-type S to any interface-type T, provided S implements T. 

• From any interface-type S to any interface-type T, provided S is derived from T. 

• From an array-type S with an element type to an array-type T with an element type 
provided all of the following are true: 

' S and T differ only in element type. In other words, S and T have the same number of 
dimensions. 

- Both and are reference-types. 

- An implicit reference conversion exists from to 

"■ BILL WAGNER The fact that both SE and TE must be reference-types means that 
array conversion is illegal for arrays of numeric t 5 ^es. 


“■ VLADIMIR RESHETNIKOV Actually, the Microsoft C# compiler does not check 
that SE and TE are reference-types', it checks only that the implicit conversion from SE to 
TE is classified as an implicit reference conversion. This distinction is quite subtle, but 
it allows implicit conversions between arrays of type parameters. Note that in the fol¬ 
lowing example, the type parameter T is not even formally known to be a reference type 
(§10.1.5), although it always is a reference t 5 q)e at runtime: 

T[] Foo<T,S>(S[] x) where S: class, T 
{ 

return x; 

} 


P' 


199 


www.it-ebooks.info 


Conversions 








Conversions 


6. Conversions 


so 


“■ ERICLIPPERT Covariant array conversions were a controversial addition to the 
CLI and C#. This kind of conversion breaks t 5 ^e safety on arrays. You might assume 
that you can put a Turtle into an array of Animals, buf if is legal fo implicifly converf 
an array of Giraffes fo an expression f 5 ^ed as being an array of Animals. When you 
affempf fo add fhe Turtle fo fhaf fhing, fhe runtime environmenf will disallow fhe 
conversion from Turtle fo Giraffe. Thus if is sometimes not legal fo puf a Turtle info 
an array of Animals, and you will nof know fhaf facf unfil runfime. The compiler is 
unable fo cafch fhis f5T3e of error. 

On such occasions, if would be useful fo characferize conversions as represenfafion- 
preserving or representation-changing, rafher fhan implicif or explicif. The CLI rules for 
covarianf array conversions require fhaf fhe conversion from fhe source fo fhe destina¬ 
tion f 5 q)e preserve represenfafion af runfime. For example, converting an array of 10 
infegers info an array of 10 doubles would end up allocating memory for each double, 
so if could nof be done cheaply "in place." By confrasf, converting an array of Giraffes 
info an array of Animals preserves fhe represenfafion of every elemenf in fhe array af 
runfime, fhereby preserving fhe represenfafion of fhe array ifself. 

Because reference conversions always preserve fhe represenfafion, fhe C# language 
resfricfs explicif and implicif covarianf array conversions fo fhose where fhe conver¬ 
sion between the element t 5 q)es is a reference conversion. The CLR addifionally allows 
ofher represenfafion-preserving conversions such as int [ ] fo uint [ ]. 


• From any array-type fo System. Array and fhe inferfaces if implemenfs. 

• From a single-dimensional array fype S[ ] fo System. Collect ions .Generic. IList<T> 
and ifs base inferfaces, provided fhaf fhere is an implicif identify or reference conversion 
from S fo T. 

• From any delegate-type fo System. Delegate and fhe inferfaces if implemenfs. 

• From fhe null liferal fo any reference-type. 

• From any reference-type fo a reference-type T if if has an implicif identify or reference con¬ 
version fo a reference-type T^ and T^ has an idenfify conversion fo T. 

“■ VLADIMIR RESHETNIKOV For example, fhere is an implicif reference conversion 
from List<object> fo ICollection<dynamic>. 


• From any reference-type fo an inferface or delegafe f 5 q)e T if if has an implicif idenfify or 
reference conversion fo an inferface or delegafe fype T^ and T^ is variance-converfible 
(§13.1.3.2) fo T. 


200 


www.it-ebooks.info 








6.1 Implicit Conversions 


“■ VLADIMIR RESHETNIKOV For example, there is an implicit reference conversion 
from List<string> to IEnumerable<object>. 


• Implicit conversions involving type parameters that are known to be reference types. 
See §6.1.10 for more details on implicit conversions involving type parameters. 

The implicit reference conversions are those conversions between reference-types that can be 
proven to always succeed and, therefore, require no checks at runtime. 

Reference conversions, implicit or explicit, never change the referential identity of the 
object being converted. In other words, while a reference conversion may change the t 5 q)e 
of the reference, it never changes the type or value of the object being referred to. 

6.1.7 Boxing Conversions 

A boxing conversion permits a value-type to be implicitly converted to a reference type. A 
boxing conversion exists from any non-nullable-value-type to object and dynamic, to 
System.ValueType and to any interface-type implemented by the non-nullable-value-type. 
Furthermore an enum-type can be converted to the type System. Enum. 

A boxing conversion exists from a nullable-type to a reference t 5 q)e, if and only if a boxing 
conversion exists from the underlying non-nullable-value-type to the reference type. 

A value type has a boxing conversion to an interface type I if it has a boxing conversion to 
an interface type and has an identity conversion to I. 

A value type has a boxing conversion to an interface type I if it has a boxing conversion to 
an interface or delegate type and is variance-convertible (§13.1.3.2) to I. 

Boxing a value of a non-nullable-value-type consists of allocating an object instance and 
copying the value-type value into that instance. A struct can be boxed to the t 5 q)e System. 
ValueType, since that is a base class for all structs (§11.3.2). 

Boxing a value of a nullable-type proceeds as follows: 

• If the source value is null (HasValue property is false), the result is a null reference of 
the target type. 

• Otherwise, the result is a reference to a boxed T produced by unwrapping and boxing 
the source value. 

Boxing conversions are described further in §4.3.1. 


201 


www.it-ebooks.info 


Conversions 






Conversions 


6. Conversions 


6.1.8 Implicit Dynamic Conversions 

An implicit dynamic conversion exists from an expression of type dynamic to any t 5 ^e T. 
The conversion is d 5 mamically bound (§7.2.2), which means that an implicit conversion 
will be sought at runtime from the runtime type of the expression to T. If no conversion is 
found, a runtime exception is thrown. 


“■ VLAD IMIR R ES H ETNIKOV This does not imply that an implicit conversion from 
type dynamic to any type T exists—which is an important difference in some overload 
resolufion scenarios: 

class A 
{ 

static void Foo(string x) { } 
static void Foo(dynamic x) { } 

static void Main() 

{ 

Foo(null); 

} 

} 

The overloaded Foo(string x) is beffer than Foofdynamic x), because there is an 
implicit conversion from string fo dynamic, buf not from dynamic fo string. 


Note that this implicit conversion seemingly violates the advice in the begirming of §6.1 that 
an implicit conversion should never cause an exception. However, it is not the conversion 
itself, but the finding of the conversion, that causes the exception. The risk of runtime excep¬ 
tions is inherent in the use of d 5 mamic binding. If d 5 mamic binding of the conversion is not 
desired, the expression can be first converted to object, and then to the desired t 5 ^e. 


The following example illustrates implicit d 5 mamic conversions: 


object o 
dynamic d 


"object" 

"dynamic"; 


string si 
string s2 
int i 


o; // Fails at compile time: no conversion exists 
d; // Compiles and succeeds at runtime 

d; // Compiles but fails at runtime: no conversion exists 


The assignments to s2 and i both employ implicit djmamic conversions, where the binding 
of the operations is suspended until runtime. At runtime, implicit conversions are sought 
from the runtime tj^e of d - string - fo the target type. A conversion is found to string 
but not to int. 


202 


www.it-ebooks.info 






6.1 Implicit Conversions 


6.1.9 Implicit Constant Expression Conversions 

An implicit constant expression conversion permits the following conversions: 

• A constant-expression (§7.19) of t 5 ^e int can be converted to type sbyte, byte, short, 
ushort, uint, or along, provided the value of the constant-expression is within the range 
of the destination t 5 ^e. 


■■ JONSKEET C#'s approach here is more flexible fhan Java's: Java permits implicit 
constant expression conversions only as assignment conversions. For example, the 
following code is legal in C#, buf fhe equivalent Java code would fail fo compile 
because the integer expression 10 would not be converted to a byte: 

void MethodTakingByte(byte b) { ... } 

// In another method 

MethodTakingByte(10); 


• A constant-expression of t 5 q)e long can be converted to t 5 q)e along, provided the value of 
the constant-expression is not negative. 

6.1.10 Implicit Conversions Involving Type Parameters 

The following implicit conversions exist for a given type parameter T: 

• From T to its effective base class C, from T to any base class of C, and from T to any inter¬ 
face implemenfed by C. Af runfime, if T is a value t 5 q)e, the conversion is executed as a 
boxing conversion. Otherwise, the conversion is executed as an implicit reference con¬ 
version or identify conversion. 

• From T to an interface t 5 q)e I in T's effective interface set and from T to any base interface 
of I. At runtime, if T is a value t 5 q)e, the conversion is executed as a boxing conversion. 
Otherwise, the conversion is executed as an implicit reference conversion or identify 
conversion. 

• From T to a t 5 q)e parameter U, provided T depends on U (§10.1.5). At rimtime, if U is a value 
fype, then T and U are necessarily the same t 5 q)e and no conversion is performed. Other¬ 
wise, if T is a value tYpe, the conversion is executed as a boxing conversion. Otherwise, 
the conversion is executed as an implicit reference conversion or identity conversion. 

• From the null literal to T, provided T is known to be a reference type. 

• From T to a reference type I if it has an implicit conversion to a reference t 5 q)e and 
has an identity conversion to S. At runtime, the conversion is executed the same way as 
the conversion to S^. 


P' 


203 


www.it-ebooks.info 


Conversions 






Conversions 


6. Conversions 


so 


• From T to an interface type I, if it has an implicit conversion to an interface or delegate 
type Ig and is variance-convertible to I (§13.1.3.2). At runtime, if T is a value t 5 ^e, the 
conversion is executed as a boxing conversion. Otherwise, the conversion is executed as 
an implicit reference conversion or identity conversion. 

If T is known to be a reference t 5 ^e (§10.1.5), fhe conversions above are all classified as 
implicit reference conversions (§6.1.6). If T is not known to be a reference type, the conver¬ 
sions above are classified as boxing conversions (§6.1.7). 

6.1.11 User-Defined Implicit Conversions 

A user-defined implicit conversion consists of an optional standard implicit conversion, 
followed by execution of a user-defined implicif conversion operator, followed by anofher 
optional standard implicit conversion. The exact rules for evaluating user-defined implicit 
conversions are described in §6.4.4. 

6.1.12 Anonymous Function Conversions and Method Group Conversions 

Anonymous fimctions and method groups do not have types in and of themselves, but may 
be implicitly converted to delegate types or expression tree t 5 ^es. Anonymous function 
conversions are described in more detail in §6.5 and method group conversions in §6.6. 


6.2 Explicit Conversions 

The following conversions are classified as explicif conversions: 

• All implicif conversions. 

• Explicit numeric conversions. 

• Explicit enumeration conversions. 

• Explicit nullable conversions. 

• Explicit reference conversions. 

• Explicit interface conversions. 

• Unboxing conversions. 

• Explicit dynamic conversions. 

• User-defined explicif conversions. 

Explicit conversions can occur in cast expressions (§7.7.6). 

The set of explicit conversions includes all implicit conversions. This means that redundant 
cast expressions are allowed. 


204 


www.it-ebooks.info 




6.2 Explicit Conversions 


The explicit conversions that are not implicit conversions are conversions that cannot be 
proven to always succeed, conversions that are known to possibly lose information, and 
conversions across domains of types sufficiently different to merit explicit notation. 

6.2.1 Explicit Numeric Conversions 

The explicit numeric conversions are the conversions from a numeric-type to another 
numeric-type for which an implicif numeric conversion (§6.1.2) does nof already exisf: 

• From sbyte to byte, ushort, uint, ulong, or char. 

• From byte to sbyte and char. 

• From short to sbyte, byte, ushort, uint, ulong, or char. 

• From ushort to sbyte, byte, short, or char. 

• From int to sbyte, byte, short, ushort, uint, ulong, or char. 

• From uint to sbyte, byte, short, ushort, int, or char. 

• From long to sbyte, byte, short, ushort, int, uint, ulong, or char. 

• From ulong to sbyte, byte, short, ushort, int, uint, long, or char. 

• From char to sbyte, byte, or short. 

• From float to sbyte, byte, short, ushort, int, uint, long, ulong, char, or decimal. 

• From double to sbyte, byte, short, ushort, int, uint, long, ulong, char, float, or 
decimal. 

• From decimal to sbyte, byte, short, ushort, int, uint, long, ulong, char, float, or 
double. 

Because the explicit conversions include all implicit and explicit numeric conversions, it is 
always possible to convert from any numeric-type fo any ofher numeric-type using a casf 
expression (§7.7.6). 

The explicif numeric conversions possibly lose information or possibly cause exceptions fo 
be fhrown. An explicif numeric conversion is processed as follows: 

• For a conversion from an integral t 5 ^e to another integral type, the processing depends 
on the overflow checking contexf (§7.6.12) in which the conversion takes place: 

- In a checked context, the conversion succeeds if the value of fhe source operand is 
within the range of the destination type, but throws a System.OverflowException if 
fhe value of the source operand is outside the range of fhe desfinafion type. 

- In an unchecked context, the conversion always succeeds, and proceeds as follows: 


p\ 


205 


www.it-ebooks.info 


Conversions 





Conversions 


6. Conversions 


so 


• If the source type is larger than the destination t 5 ^e, then the source value is trun¬ 
cated by discarding its "extra" most significant bits. The result is then treated as a 
value of the destination t 5 ^e. 

• If the source type is smaller than the destination type, then the source value is 
either sign-extended or zero-extended so that it is the same size as the destination 
type. Sign-extension is used if the source type is signed; zero-extension is used if 
the source t 5 ^e is unsigned. The result is then treated as a value of the destina¬ 
tion type. 

• If the source t 5 ^e is the same size as the destination type, then the source value is 
treated as a value of the destination type. 

• For a conversion from decimal to an integral t 5 ^e, the source value is rounded toward 
zero to the nearest integral value, and this integral value becomes the result of the con¬ 
version. If the resulting integral value is outside the range of the destination type, a 
System.OverflowException is thrown. 

• For a conversion from float or double to an integral t 5 ^e, the processing depends on 
the overflow checking context (§7.6.12) in which the conversion takes place: 

- In a checked context, the conversion proceeds as follows: 

• If the value of the operand is NaN or infinite, a System.OverflowException 
is thrown. 

• Otherwise, the source operand is rounded toward zero to the nearest integral 
value. If this integral value is within the range of the destination type, then this 
value is the result of the conversion. 

• Otherwise, a System.OverflowException is thrown. 

- In an unchecked context, the conversion always succeeds, and proceeds as follows: 

• If the value of the operand is NaN or infinite, the result of the conversion is an 
unspecified value of the destination type. 

• Otherwise, the source operand is rounded toward zero to the nearest integral 
value. If this integral value is within the range of the destination type, then this 
value is the result of the conversion. 

• Otherwise, the result of the conversion is an unspecified value of the destina¬ 
tion type. 

• For a conversion from double to float, the double value is rounded to the nearest float 
value. If the double value is too small to represent as a float, the result becomes positive 
zero or negative zero. If the double value is too large to represent as a float, the result 
becomes positive infinity or negative infinity. If the double value is NaN, the result is 
also NaN. 


206 


www.it-ebooks.info 




6.2 Explicit Conversions 


• For a conversion from float or double to decimal, the source value is converted to 
decimal representation and rounded to the nearest number after the 28* decimal place 
if required (§4.1.7). If the source value is too small to represent as a decimal, the result 
becomes zero. If the source value is NaN, infinity, or too large to represent as a decimal, 
a System.OverflowException is thrown. 

• For a conversion from decimal to float or double, the decimal value is rounded to the 
nearest double or float value. While this conversion may lose precision, it never causes 
an exception to be thrown. 


■■ JOSEPH ALBAHARI The round-to-zero behavior in the real-to-integral conver¬ 
sions is efficient but not always the most useful approach. For instance, under this 
scheme, ( int) 3.9 evaluates to 3, rather than 4. C# provides no built-in mechanism 
for converting to the nearest integer; this capability is left to external libraries. In 
Microsoft's .NET Framework, the static Convert class provides this functionality via 
methods such as ToInt32. 


6.2.2 Explicit Enumeration Conversions 

The explicit enumeration conversions are: 

• From sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, or decimal 
to any enum-type. 

• From any enum-type to sbyte, byte, short, ushort, int, uint, long, ulong, char, float, 
double, or decimal. 

• From any enum-type to any other enum-type. 

An explicit enumeration conversion between two types is processed by treating any par¬ 
ticipating enum-type as the underlying type of that enum-type, and then performing an 
implicit or explicit numeric conversion between the resulting types. For example, given an 
enum-type E with an underlying t 5 q)e of int, a conversion from E to byte is processed as an 
explicit numeric conversion (§6.2.1) from int to byte, and a conversion from byte to E is 
processed as an implicit numeric conversion (§6.1.2) from byte to int. 

6.2.3 Explicit Nullable Conversions 

Explicit nullable conversions permit predefined explicit conversions that operate on non- 
nullable value types to also be used with nullable forms of those t 5 q)es. For each of the 
predefined explicit conversions that convert from a non-nullable value type S to a non- 
nullable value type T (§6.1.1, §6.1.2, §6.1.3, §6.2.1, and §6.2.2), the following nullable con¬ 
versions exist: 


P' 


207 


www.it-ebooks.info 


Conversions 






Conversions 


6. Conversions 


• An explicit conversion from S ? to T ? . 

• An explicit conversion from S to T?. 

• An explicit conversion from S ? to T. 

Evaluation of a nullable conversion based on an underlying conversion from S to T pro¬ 
ceeds as follows: 

• If the nullable conversion is from S ? to T ?: 

- If the source value is null (HasValue property is false), the result is the null value of 
type T?. 

- Otherwise, the conversion is evaluated as an unwrapping from S ? to S, followed by 
the underlying conversion from S to T, followed by a wrapping from T to T?. 

• If the nullable conversion is from S to T?, the conversion is evaluated as the underlying 
conversion from S to T followed by a wrapping from T to T?. 

• If the nullable conversion is from S ? to T, the conversion is evaluated as an unwrapping 
from S ? to S followed by the underlying conversion from S to T. 

Note that an attempt to unwrap a nullable value will throw an exception if the value 
is null. 

6.2.4 Explicit Reference Conversions 

The explicit reference conversions are: 

• From object and dynamic to any other reference-type. 

• From any class-type S to any class-type T, provided S is a base class of T. 

• From any class-type S to any interface-type T, provided S is not sealed and provided S does 
not implement T. 

• From any interface-type S to any class-type T, provided T is not sealed or provided T imple¬ 
ments S. 

• From any interface-type S to any interface-type T, provided S is not derived from T. 

• From an array-type S with an element t5^e to an array-type T with an element type 
provided all of the following are true: 

- S and T differ only in element type. In other words, S and T have the same number of 
dimensions. 

- Both Sg and are reference-types. 

- An explicit reference conversion exists from to T^. 


www.it-ebooks.info 




6.2 Explicit Conversions 


“■ VLADIMIR RESHETNIKOV The Microsoft C# compiler does not check whether 
SE and TE are reference-types', it only checks whether the explicit conversion from SE to 
TE is classified as an explicit reference conversion. See the corresponding annotation 
in §6.1.6 for details. 


• From System. Array and the interfaces it implements to any array-type. 

• From a single-dimensional array type S[ ] to System.Collections .Generic. IList<T> 
and its base interfaces, provided that there is an explicit reference conversion from 
S to T. 

• From System. Collections. Generic. IList<S> and its base interfaces to a single-dimen¬ 
sional array t5^e T[ ], provided that there is an explicit identity or reference conversion 
from S to T. 

• From System. Delegate and the interfaces it implements to any delegate-type. 

• From a reference t5^e to a reference t5^e T, if it has an explicit reference conversion to a 
reference t5^e and has an identity conversion T. 

• From a reference t5^e to an interface or delegate type T, if it has an explicit reference 
conversion to an interface or delegate t5^e and either is variance-convertible to T or 
T is variance-convertible to (§ 13 . 1 . 3 . 2 ). 

• From D<S^.. .S^> to a D<T^.. .T^>, where D<X^.. .X^> is a generic delegate type, DcS^... 
S^> is not compatible with or identical to DcT^... T^>, and for each type parameter X. of 
D the following holds: 

- If X. is invariant, then S. is identical to T.. 

- If X. is covariant, then there is an implicit or explicit identity or reference conversion 

from S. to T.. 

1 1 

- If X. is contravariant, then S. and T. are either identical or both reference types. 


“■ ERIC LI PPERT The justification of this last point is that you might have a variable 
of type Action<S>, where S is a reference type that contains an instance of 
Action<object>. You can implicitly convert an Action<object> to Action<T>, where T 
is any reference type, so you should be able to explicitly convert Action<S> to Action<T> 
for any reference t 5 ^es S and T. 




• Explicit conversions involving type parameters that are known to be reference types. For 
more details on explicit conversions involving type parameters, see §6.2.6. 

The explicit reference conversions are those conversions between reference types that 
require runtime checks to ensure they are correct. 


209 


www.it-ebooks.info 


Conversions 








Conversions 


6. Conversions 


so 


For an explicit reference conversion to succeed at runtime, the value of the source operand 
must be null, or the actual type of the object referenced by the source operand must be a 
type that can be converted to the destination t 5 ^e by an implicit reference conversion 
(§6.1.6) or boxing conversion (§6.1.7). If an explicit reference conversion fails, a System. 
InvalidCastException is thrown. 

Reference conversions, implicit or explicit, never change the referential identity of the 
object being converted. In other words, while a reference conversion may change the type 
of the reference, it never changes the type or value of the object being referred to. 

6.2.5 Unboxing Conversions 

An unboxing conversion permits a reference t 5 ^e to be explicitly converted to a value-type. 
An unboxing conversion exists from the t 5 rpes object, dynamic, and System.ValueType to 
any non-nullable-value-type, and from any interface-type to any non-nullable-value-type that 
implements the interface-type. Furthermore, type System. Enurn can be unboxed to any 
enum-type. 

An unboxing conversion exists from a reference type to a nullable-type if an unboxing 
conversion exists from the reference type to the underlying non-nullable-value-type of the 
nullable-type. 

A value t 5 ^e S has an unboxing conversion from an interface type I if it has an unboxing 
conversion from an interface type 1^ and 1^ has an identity conversion to I. 

A value t 5 ^e S has an unboxing conversion from an interface type I if it has an unboxing 
conversion from an interface or delegate t 5 ^e and either 1^ is variance-convertible to I 
or I is variance-convertible to (§13.1.3.2). 

An unboxing operation consists of first checking that the object instance is a boxed value 
of the given value-type, and then copying the value out of the instance. Unboxing a null 
reference to a nullable-type produces the null value of the nullable-type. A struct can be 
unboxed from the type System.ValueType, since that is abase class for all structs (§11.3.2). 

Unboxing conversions are described further in §4.3.2. 

6.2.6 Explicit Dynamic Conversions 

An explicit d 5 mamic conversion exists from an expression of type dynamic to any type T. 
The conversion is dynamically bound (§7.2.2), which means that an explicit conversion 
will be sought at runtime from the runtime type of the expression to T. If no conversion is 
found, a runtime exception is thrown. 

If d 5 mamic binding of the conversion is not desired, the expression can be first converted 
to object, and then to the desired type. 


210 


www.it-ebooks.info 




6.2 Explicit Conversions 


Assume the following class is defined: 

class C 
{ 

int i; 

public C(int i) { this.i = i; } 

public static explicit operator C(string s) 

{ 

return new C(int.Parse(s)); 

} 

} 

The following example illusfrafes explicif d 5 mamic conversions: 
object o = "1"; 


p\ 


var cl = (C)o; // CompileSj but explicit reference conversion fails 
var c2 = (C)d; // Compiles and user-defined conversion succeeds 

The besf conversion of o fo C is found af compile fime fo be an explicif reference conversion. 

This fails af runtime, because "1" is nof, in facf, a C. The conversion of d fo C as an explicif 

dynamic conversion, however, is suspended fo runtime, where a user-defined conversion 

from fhe runfime tjT’C ofd-string-foCis found, and succeeds. 

6.2.7 Explicit Conversions Involving Type Parameters 

The following explicif conversions exisf for a given fype paramefer T: 

• From fhe effecfive base class C of T fo T and from any base class of C fo T. Af runfime, if 
T is a value type, the conversion is executed as an unboxing conversion. Otherwise, the 
conversion is executed as an explicit reference conversion or identity conversion. 

• From any interface type to T. At runtime, if T is a value type, the conversion is executed 
as an unboxing conversion. Otherwise, the conversion is executed as an explicit refer¬ 
ence conversion or identity conversion. 

• From T to any interface-type I, provided there is not already an implicit conversion from 
T to I. At runtime, if T is a value tjT’S, the conversion is executed as a boxing conversion 
followed by an explicit reference conversion. Otherwise, the conversion is executed as 
an explicit reference conversion or identity conversion. 

• From a type parameter U to T, provided T depends on U (§10.1.5). At runtime, if U is a 
value type, then T and U are necessarily the same type and no conversion is performed. 
Otherwise, if T is a value tj^e, the conversion is executed as an unboxing conversion. 
Otherwise, the conversion is executed as an explicit reference conversion or identity 
conversion. 


211 


www.it-ebooks.info 


Conversions 




Conversions 


6. Conversions 


so 


If T is known to be a reference type, all of these conversions are classified as explicit refer¬ 
ence conversions (§6.2.4). If T is not known to be a reference t 5 ^e, these conversions are 
classified as unboxing conversions (§6.2.5). 


■■ JOSEPH ALBAHARI The behavior of conversions involving t 5 ^e parameters can 
be further illustrated with the following method: 

static T Cast<T>(object value) { return (T)value; } 

This method can perform a reference conversion or an unboxing, but never a numeric 
or user-defined conversion: 

string s = Cast<string>("s"); 

// Okay - reference conversion 
int i = Cast<int>(3); 

// Okay - unboxing 
long 1 = Cast<long>(3); 

// InvalldCastExceptlon: attempts 
// an unboxing instead of an 
// int->long numeric conversion 

An identical situation arises in the method System. Linq. Enumerable. Cast, which is a 
standard query operator in Microsoft's LINQ implementation. 


The above rules do not permit a direct explicit conversion from an unconstrained type 
parameter to a non-interface type, which might be surprising. The reason for this rule is to 
prevent confusion and make the semantics of such conversions clear. For example, con¬ 
sider the following declaration: 

class X<T> 

{ 

public static long F(T t) { 
return (long)t; // Error 

} 

} 

If the direct explicit conversion of t to int were permitted, one might easily expect that 
X<int>. F(7) would return 7L. However, it would not, because the standard numeric con¬ 
versions are considered only when the t 5 q)es are known to be numeric at binding time. To 
make the semantics clear, the above example must instead be written: 

class X<T> 

{ 

public static long F(T t) { 

return (long)(object)t; // Okay, but works only when T is long 

} 

} 

This code will now compile but executing X<int>. F(7) would then throw an exception at 
runtime, because a boxed int cannot be converted directly to a long. 


212 


www.it-ebooks.info 






6.3 Standard Conversions 


6.2.8 User-Defined Explicit Conversions 

A user-defined explicit conversion consists of an optional standard explicit conversion, 
followed by execution of a user-defined implicit or explicit conversion operator, followed 
by another optional standard explicit conversion. The exact rules for evaluating user- 
defined explicit conversions are described in §6.4.5. 


“■ ERIC LIPPERT The conversions that "sandwich" the user-defined conversion are 
explicit conversions and, therefore, might fail themselves. Thus a user-defined explicit 
conversion has three potential points of failure at runtime, not just one. 

Even so, at least the sandwiching conversions are never user-defined conversions 
themselves. For example, if there is a user-defined explicit conversion from X to Y, and 
a user-defined explicit conversion from Y to Z, then an attempt to cast X to Z will not 
succeed. 

That said, the chain of explicit conversions can get quite long in contrived scenarios. 
For example, consider a struct Foo with a user-defined explicit conversion from Foo? 
to decimal. A cast on an expression of t 5 q)e Foo to type int? will convert Foo to Foo?, 
then Foo? to decimal, then decimal to int, and then int to int?. 




6.3 Standard Conversions 

The standard conversions are those predefined conversions that can occur as part of a user- 
defined conversion. 

6.3.1 Standard Implicit Conversions 

The following implicit conversions are classified as standard implicit conversions: 

• Identity conversions (§6.1.1). 

• Implicit numeric conversions (§6.1.2). 

• Implicit nullable conversions (§6.1.4). 

• Implicit reference conversions (§6.1.6). 

• Boxing conversions (§6.1.7). 

• Implicit constant expression conversions (§6.1.8). 

• Implicit conversions involving t 5 q)e parameters (§6.1.10). 

The standard implicit conversions specifically exclude user-defined implicit conversions. 


213 


www.it-ebooks.info 


Conversions 






Conversions 


6. Conversions 


6.3.2 Standard Explicit Conversions 

The standard explicit conversions are all standard implicit conversions plus the subset of 
the explicit conversions for which an opposite standard implicit conversion exists. In other 
words, if a standard implicit conversion exists from a t 5 ^e A to a type B, then a standard 
explicit conversion exists from t 5 ^e A to type B and from t 5 ^e B to type A. 


“■ VLAD IMIR R ES H ETNIKOV For example, the predefined explicit numeric conver¬ 
sions from double fo decimal and from decimal fo double are nof sfandard explicit 
conversions. 


so 


6.4 User-Defined Conversions 

C# allows the predefined implicit and explicit conversions to be augmented by user-defined 
conversions. User-defined conversions are introduced by declaring conversion operators 
(§10.10.3) in class and struct t 5 ^es. 


"■ BILL WAGNER Conversions, in general, imply that multiple t 5 ^es are somehow 
interchangeable. That notion, in turn, implies that one of more of the t 5 ^es may not be 
necessary. As you write more conversion methods, consider whether you might have 
created multiple t 5 ^es that serve the same purpose. 

When you write conversions for reference f 5 ^es, be sure fo preserve fhe properfy fhat 
fhe resulf of a reference conversion always refers fo fhe same objecf as the source. 


6.4.1 Permitted User-Defined Conversions 

C# permits only certain user-defined conversions to be declared. In particular, it is not pos¬ 
sible to redefine an already existing implicit or explicit conversion. 

For a given source t 5 ^e S and target t 5 ^e T, if S or T are nullable fypes, let and refer to 
their underlying types; otherwise, and are equal to S and T, respectively. A class or 
struct is permitted to declare a conversion from a source type S to a target t 5 q)e T only if all 
of the following are true: 

• Sg and Tg are different types. 

• Either or is the class or struct t 5 q)e in which the operator declaration takes place. 


214 


www.it-ebooks.info 








6.4 User-Defined Conversions 


• Neither nor is an interface-type. 

• Excluding user-defined conversions, a conversion does not exist from S to T or from 
T to S. 

The restrictions that apply to user-defined conversions are discussed further in §10.10.3. 

6.4.2 Lifted Conversion Operators 

Given a user-defined conversion operator that converts from a non-nullable value t 5 ^e S 
to a non-nullable value t 5 ^e T, a lifted conversion operator exists that converts from S ? to 
T?. This lifted conversion operator performs an unwrapping from S? to S, followed by fhe 
user-defined conversion from S to T, followed by a wrapping from T to T?, except that a 
null-valued S? converts directly to a null-valued T?. 

A lifted conversion operator has the same implicit or explicit classification as its underly¬ 
ing user-defined conversion operator. The term "user-defined conversion" applies to the 
use of both user-defined and lifted conversion operators. 

6.4.3 Evaluation of User-Defined Conversions 

A user-defined conversion converts a value from ifs 1)^0, called fhe source type, to another 
type, called the target type. Evaluation of a user-defined conversion centers on finding the 
most specific user-defined conversion operator for fhe particular source and target types. 
This determination is broken into several steps: 

• Einding the set of classes and strucfs from which user-defined conversion operators will 
be considered. This set consists of the source t 5 ^e and its base classes and the target type 
and its base classes (with the implicit assumptions that only classes and structs can 
declare user-defined operators, and that non-class t 5 ^es have no base classes). Eor the 
purposes of fhis sfep, if eifher fhe source or farget f 5 ^e is a nullable-type, their underlying 
type is used instead. 

• Erom that set of types, determining which user-defined and liffed conversion operators 
are applicable. Eor a conversion operator to be applicable, it must be possible to perform 
a standard conversion (§6.3) from the source type to the operand t 5 ^e of the operator, 
and it must be possible to perform a sfandard conversion from the result type of the 
operator to the target type. 

• Erom the set of applicable user-defined operators, determining which operator is unam¬ 
biguously the most specific. In general terms, the most specific operafor is fhe operator 
whose operand type is "closest" to the source t 5 ^e and whose result type is "closest" to 
the target t 5 ^e. User-defined conversion operators are preferred over lifted conversion 
operators. The exact rules for establishing the most specific user-defined conversion 
operator are defined in the following secfions. 


p\ 


215 


www.it-ebooks.info 


Conversions 




Conversions 


6. Conversions 


so 


Once a most specific user-defined conversion operator has been idenfified, fhe acfual exe¬ 
cution of fhe user-defined conversion involves up to fhree sfeps: 

• Firsf, if required, performing a sfandard conversion from fhe source type to the operand 
type of fhe user-defined or liffed conversion operafor. 

• Nexf, invoking fhe user-defined or liffed conversion operafor fo perform fhe 
conversion. 

• Finally, if required, performing a sfandard conversion from fhe resulf f 5 q)e of fhe user- 
defined or liffed conversion operafor fo fhe fargef t 5 q)e. 

Evaluafion of a user-defined conversion never involves more fhan one user-defined or 
liffed conversion operafor. In ofher words, a conversion from f 5 q)e S fo type T will never 
first execute a user-defined conversion from S fo X and fhen execufe a user-defined conver¬ 
sion from X fo T. 

Exacf definitions of evaluafion of user-defined implicif or explicif conversions are given in 
fhe following sections. The definifions make use of fhe following terms: 

• If a sfandard implicif conversion (§6.3.1) exisfs from a fype A fo a fype B, and if neifher 
A nor B is an interface-type, fhen A is said fo be encompassed by B, and B is said fo encom¬ 
pass A. 

• The most encompassing type in a sef of fypes is fhe one f 5 q)e fhaf encompasses all ofher 
fypes in fhe sef. If no single fype encompasses all ofher fypes, fhen fhe sef has no mosf 
encompassing fype. In more infuifive ferms, fhe mosf encompassing fype is fhe "larg- 
esf" fype in fhe sef—fhe one f 5 q)e fo which each of fhe ofher fypes can be implicifly 
converfed. 

• The most encompassed type in a sef of f 5 q)es is fhe one fype fhaf is encompassed by all 
ofher fypes in fhe sef. If no single fype is encompassed by all ofher fypes, fhen fhe sef 
has no mosf encompassed type. In more intuitive terms, the most encompassed type is 
the "smallest" t 5 q)e in the set—the one type that can be implicitly converted to each of 
fhe ofher fypes. 


“■ BILL WAGNER The more conversion operators you write, fhe more likely if 
becomes fhaf you will infroduce ambiguities among conversions. Those ambiguifies 
will make your class more difficulf fo use. 


216 


www.it-ebooks.info 






6.4 User-Defined Conversions 


6.4.4 User-Defined Implicit Conversions 

A user-defined implicit conversion from type S to type T is processed as follows: 

• Determine the t 5 ^es and T^. If S and T are nullable types, and are their underlying 
types; otherwise, and are equal to S and T, respectively. 

• Find the set of types, D, from which user-defined conversion operators will be consid¬ 
ered. This set consists of (if is a class or struct), the base classes of (if is a class), 
and Tg (if is a class or struct). 

• Find the set of applicable user-defined and lifted conversion operators, U. This set con¬ 
sists of the user-defined and lifted implicit conversion operators declared by the classes 
or structs in D that convert from a type encompassing S to a t 5 q)e encompassed by T. If U 
is empty, the conversion is undefined and a compile-time error occurs. 


p\ 


• Find the most specific source t 5 q)e, of the operators in U: 

- If any of the operators in U convert from S, then S^, is S. 

- Otherwise, is the most encompassed t 5 q)e in the combined set of source types of the 
operators in U. If exactly one most encompassed type carmot be found, then the con¬ 
version is ambiguous and a compile-time error occurs. 

• Find the most specific target type, T^, of the operators in U: 

- If any of the operators in U convert to T, then is T. 

- Otherwise, is the most encompassing t 5 q)e in the combined set of target types of the 
operators in U. If exactly one most encompassing type carmot be found, then the con¬ 
version is ambiguous and a compile-time error occurs. 

• Find the most specific conversion operator: 

- If U contains exactly one user-defined conversion operator that converts from to 
then this is the most specific conversion operator. 

- Otherwise, if U contains exactly one lifted conversion operator that converts from 
to then this is the most specific conversion operator. 

- Otherwise, the conversion is ambiguous and a compile-time error occurs. 

• Finally, apply the conversion: 

- If S is not Sj,, then a standard implicit conversion from S fo is performed. 

- The most specific conversion operator is invoked to convert from to 

- If is nof T, fhen a standard implicit conversion from fo T is performed. 


217 


www.it-ebooks.info 


Conversions 




Conversions 


6. Conversions 


so 


6.4.5 User-Defined Explicit Conversions 

A user-defined explicit conversion from type S to t 5 ^e T is processed as follows: 

• Determine the t 5 ^es and If S or T is a nullable t 5 ^e, and are their respective 
underlying types; otherwise, and are equal to S and T, respectively. 

• Find the set of types, D, from which user-defined conversion operators will be consid¬ 
ered. This set consists of (if is a class or struct), the base classes of (if is a class), 
Tg (if Tg is a class or struct), and the base classes of (if is a class). 

• Find the set of applicable user-defined and lifted conversion operators, U. This set con¬ 
sists of the user-defined and lifted implicit or explicit conversion operators declared by 
the classes or structs in D that convert from a type encompassing or encompassed by S 
to a t 5 q)e encompassing or encompassed by T. If U is empty, the conversion is undefined 
and a compile-time error occurs. 

• Find the most specific source type, S^, of the operators in U: 

- If any of the operators in U convert from S, then S,, is S. 

- Otherwise, if any of the operators in U convert from types that encompass S, then 

is the most encompassed type in the combined set of source t 5 q)es of those operators. 
If no most encompassed type can be found, then the conversion is ambiguous and a 
compile-time error occurs. 

- Otherwise, is the most encompassing t 5 q)e in the combined set of source types of 
the operators in U. If exactly one most encompassing type carmot be found, then the 
conversion is ambiguous and a compile-time error occurs. 

• Find the most specific target type, T^,, of the operators in U: 

- If any of the operators in U convert to T, then is T. 

- Otherwise, if any of the operators in U convert to t 5 q)es that are encompassed by T, 
then T,, is the most encompassing type in the combined set of target t 5 q)es of those 
operators. If exactly one most encompassing type carmot be found, then the conver¬ 
sion is ambiguous and a compile-time error occurs. 

- Otherwise, is the most encompassed type in the combined set of target types of the 
operators in U. If no most encompassed type can be found, then the conversion is 
ambiguous and a compile-time error occurs. 

• Find the most specific conversion operator: 

- If U contains exactly one user-defined conversion operator that converts from to 
then this is the most specific conversion operator. 

- Otherwise, if U contains exactly one lifted conversion operator that converts from 
to T^, then this is the most specific conversion operator. 


218 


www.it-ebooks.info 




6.5 Anonymous Function Conversions 


- Otherwise, the conversion is ambiguous and a compile-time error occurs. 

• Finally, apply the conversion: 

- If S is not Sj,, then a standard explicit conversion from S fo 5,^ is performed. 

- The mosf specific user-defined conversion operator is invoked fo converf from 
S,fo T,. 

- If is nof T, fhen a sfandard explicif conversion from fo T is performed. 


6.5 Anonymous Function Conversions 

An anonymous-method-expression or lambda-expression is classified as an anonymous func- 
fion (§7.15). The expression does nof have a type but can be implicitly converted to a com¬ 
patible delegate type or expression tree t 5 ^e. Specifically, a delegafe fype D is compafible 
wifh an anonymous function F provided: 

• If F confains an anonymous-function-signature, fhen D and F have fhe same number of 
parameters. 

• If F does nof confain an anonymous-function-signature, fhen D may have zero or more 
parameters of any fype, as long as no paramefer of D has fhe out parameter modifier. 

• If F has an explicifly fyped paramefer lisf, each paramefer in D has fhe same type and 
modifiers as fhe corresponding paramefer in F. 


"■ VLADIMIR RESHETNIKOV One excepfion fo fhis rule: If fhe delegafe t 5 ^e D has 
a paramefer wifh fhe params modifier, fhen fhe corresponding paramefer in F is 
allowed (and required) nof fo have any modifiers. 




• If F has an implicifly fyped paramefer lisf, D has no ref or out parameters. 

• If D has a void ref urn f 5 q)e and fhe body of F is an expression, when each paramefer of F 
is given fhe type of fhe corresponding paramefer in D, fhe body of F is a valid expression 
(wifh respecf fo §7) fhaf would be permitted as a statement-expression (§8.6). 

• If D has a void refum fype and fhe body of F is a sfafemenf block, when each paramefer 
of F is given fhe type of fhe corresponding paramefer in D, fhe body of F is a valid sfafe¬ 
menf block (wifh respecf fo §8.2) in which no return sfafemenf specifies an expression. 

• If D has a non-void refurn f 5 q)e and fhe body of F is an expression, when each paramefer 
of F is given fhe t 5 q)e of fhe corresponding paramefer in D, fhe body of F is a valid expres¬ 
sion (wifh respecf fo §7) fhaf is implicifly converfible fo fhe refum f 5 q)e of D. 

• If D has a non-void refurn type and the body of F is a sfafemenf block, when each 
paramefer of F is given fhe t 5 q)e of fhe corresponding paramefer in D, fhe body of F is a 


219 


www.it-ebooks.info 


Conversions 






Conversions 


6. Conversions 


valid statement block (with respect to §8.2) with a non-reachable end point in which 
each return statement specifies an expression that is implicitly convertible to the return 
type of D. 

An expression tree type Expression<D> is compatible with an anonymous function F if the 
delegate t 5 ^e D is compatible with F. 


so 


“■ VLADIMIR RESHETNIKOV Only anonymous functions of the form lambda- 
expression can have implicif conversions fo expression free f 5 ^es {anonymous-method- 
expressions are never convertible to these tjqres). But even existing conversions from 
lambda-expressions can fail af compile fime. 


Certain anonymous functions carmot be converted to expression tree t 5 ^es: Even though 
the conversion exists, it fails at compile time. This is the case if the anonymous expression 
contains one or more of the following constructs: 

• Simple or compound assignment operators. 

• A dynamically bound expression. 


“■ VLADIMIR RESHETNIKOV The other constructs not supported in the current 
implementation include nested anonymous-method-expressions, lambda-expressions with 
statement bodies, lambda-expressions with ref or out parameters, base-access, multidi¬ 
mensional array initializers, named and optional parameters, implicit refs, and 
pointer operations. 

If you need to cast an expression of type dynamic to another t 5 ^e in an expression tree, 
you can either use as operator or cast the expression to object first. 


The examples that follow use a generic delegafe type Func<Aj R>, which represents a func¬ 
tion that takes an argument of type A and returns a value of 1)^0 R: 

delegate R Func<A,R>(A arg); 

In the assignments 


Func<int,int> fl 

= X 

=> X + 1; 

// 

Okay 

Func<int,double> 

f2 = 

X 

II 

V 

X 

+ 

l-» 

// 

Okay 

Func<double,int> 

f3 = 

X 

II 

V 

X 

+ 

l-» 

// 

Error 


the parameter and return types of each anonymous function are determined from the type 
of the variable to which the anonymous function is assigned. 


220 


www.it-ebooks.info 








6.5 Anonymous Function Conversions 


The first assignment successfully converts the anonymous function to the delegate type 
Func<int j int> because, when x is given t 5 ^e int, x + 1 is a valid expression that is implic¬ 
itly convertible to type int. 

Likewise, the second assignment successfully converts the anonymous function to the del¬ 
egate t 5 ^e Funccint j double> because the result of x + 1 (of t 5 ^e int) is implicitly convert¬ 
ible to t 5 rpe double. 

However, the third assignment generates a compile-time error because, when x is given 
type double, the result of x + 1 (of type double) is not implicitly convertible to t 5 ^e int. 

Anonymous functions may influence overload resolution and may participate in type 
inference. See §7.5 for further details. 

6.5.1 Evaluation of Anonymous Function Conversions to Delegate Types 

Conversion of an anonymous function to a delegate t 5 ^e produces a delegate instance that 
references the anonymous function and the (possibly empty) set of captured outer vari¬ 
ables that are active at the time of the evaluation. When the delegate is invoked, the body 
of the anonymous fimction is executed. The code in the body is executed using the set of 
captured outer variables referenced by the delegate. 

The invocation list of a delegate produced from an anonymous function contains a single 
entry. The exact target object and target method of the delegate are unspecified. In particu¬ 
lar, it is unspecified whether the target object of the delegate is null, the this value of the 
enclosing function member, or some other object. 

Conversions of semantically identical anonymous functions with the same (possibly 
empty) set of captured outer variable instances to the same delegate types are permitted 
(but not required) to return the same delegate instance. The term "semantically identical" 
is used here to mean that execution of the anonymous functions will, in all cases, produce 
the same effects given the same arguments. This rule permits code such as the following to 
be optimized. 

delegate double Function(double x); 

class Test 
{ 

static double[] Apply(double[] a. Function f) { 
double[] result = new double[a.Length]; 
for (int i = 0; i < a.Length; i++) result[i] = f(a[i]); 
return result; 

} 

static void F(double[] a, double[] b) { 

a = Apply(a, (double x) => Math.Sin(x)); 
b = Apply(b, (double y) => Math.Sin(y)); 




} 


221 


www.it-ebooks.info 


Conversions 




Conversions 


6. Conversions 


Since the two anonymous function delegates have the same (empty) set of capfured oufer 
variables, and since fhe anonymous functions are semanfically idenfical, fhe compiler is 
permitted fo have fhe delegafes refer fo fhe same fargef mefhod. Indeed, fhe compiler is 
permitted fo refurn fhe very same delegafe insfance from bofh anonymous funcfion 
expressions. 


so 


■■ JONSKEET This potential opfimizafion is somewhaf dangerous when one consid¬ 
ers fhe prospecf of combining and removing delegafes—which is particularly impor- 
fanf when if comes fo evenfs. Consider fhis piece of code: 

button.Click += (sender, args) => Console.WriteLine("Clicked"); 
button.Click -= (sender, args) => Console.WriteLine("Clicked"); 

Assuming a simple even! implemenfafion, whaf will be fhe resulf? Eifher fhe button's 
Click evenf will have fhe same evenf handlers if had before or if will have one addi¬ 
tional even! handler. Beware of "opfimizafions" fhaf change behavior significanfly. 


“■ VLADIMIR RESHETNIKOV The Microsoft C# compiler does nof cache delegafe 
insfances wifhin generic mefhods. 


6.5.2 Evaluation of Anonymous Function Conversions to Expression Tree Types 

Conversion of an anonymous funcfion fo an expression free type produces an expression 
tree (§4.6). More precisely, evaluation of fhe anonymous funcfion conversion leads fo fhe 
consfrucfion of an objecf sfrucfure fhaf represenfs fhe sfrucfure of fhe anonymous funcfion 
ifself. The precise sfrucfure of fhe expression free, as well as fhe exacf process for creafing 
if, are implemenfafion defined. 


“■ VLADIMIR RESHETNIKOV Like a delegafe, an expression free can have a sef of 
capfured oufer variables. 


6.5.3 Implementation Example 

This secfion describes a possible implemenfafion of anonymous funcfion conversions in 
ferms of ofher C# construcfs. The implemenfafion described here is based on fhe same 
principles used by fhe Microsoft C# compiler, buf if is by no means a mandafed implemen¬ 
fafion, nor is if fhe only one possible. If only briefly mentions conversions fo expression 
frees, as fheir exacf semantics are oufside fhe scope of fhis specificafion. 

The remainder of fhis secfion gives several examples of code fhaf confains anonymous 
funcfions wifh difterenf characferistics. For each example, a corresponding franslation fo 


222 


www.it-ebooks.info 










6.5 Anonymous Function Conversions 


code that uses only other C# constructs is provided. In the examples, the identifier D is 
assumed to represent the following delegafe 1 )^ 0 : 

public delegate void D(); 

The simplesf form of an anonymous funcfion is one fhaf capfures no oufer variables: 

class Test 
{ 

static void F() { 

D d = 0 => { Console.WriteLineC'test"); }; 

} 

} 

This can be franslafed fo a delegafe insfanfiafion fhaf references a compiler-generafed sfafic 
mefhod in which fhe code of fhe anonymous funcfion is placed: 

class Test 
{ 

static void F() { 

D d = new D(_Methodl); 

} 

static void _Methodl() { 

Console .WriteLineC'test"); 

} 

} 

In fhe following example, fhe anonymous funcfion references insfance members of this: 

class Test 
{ 

Int x; 
void F() { 

D d = 0 => { Console.WriteLine(x); }; 

} 

} 

This can be franslafed fo a compiler-generafed insfance mefhod confaining fhe code of fhe 
anonymous funcfion: 

class Test 
{ 

int x; 
void F() { 

D d = new D(_Methodl); 

} 

void _MethodlO { 

Console.WriteLlne(x); 

} 

} 


p\ 


223 


www.it-ebooks.info 


Conversions 




Conversions 


6. Conversions 


so 


In this example, the anonymous function captures a local variable: 

class Test 
{ 

void F() { 

int y = 123; 

D d = 0 => { Console.WriteLine(y); }; 

} 

} 

The lifetime of fhe local variable musf now be exfended fo af leasf fhe lifetime of fhe anony¬ 
mous funcfion delegafe. This can be achieved by "hoisting" fhe local variable info a field 
of a compiler-generafed class. Insfanfiafion of fhe local variable (§7.15.5.2) fhen corre¬ 
sponds fo creafing an insfance of fhe compiler generafed class, and accessing fhe local 
variable corresponds fo accessing a field in fhe insfance of fhe compiler-generafed class. 
Furfhermore, fhe anonymous funcfion becomes an insfance mefhod of fhe compiler-gener¬ 
afed class: 

class Test 
{ 

void F() { 

_Localsl _localsl = new _Localsl(); 

_localsl.y = 123; 

D d = new D(_localsl._Methodl); 

} 

class _Localsl 

{ 

public int y; 

public void _Methodl() { 

Console.WriteLine(y); 

} 

} 

} 

Finally, fhe following anonymous funcfion capfures this as well as fwo local variables 
wifh differenf lifetimes: 

class Test 
{ 

int x; 

void F() { 

int y = 123; 

for (int i = 0; i < 10; i++) { 
int z = i * 2; 

D d = 0 => { Console.WriteLine(x + y + z); }; 

} 

} 

} 


224 


www.it-ebooks.info 




6.5 Anonymous Function Conversions 


Here, a compiler-generated class is created for each statement block in which locals are 
captured, such that the locals in the different blocks can have independent lifetimes. An 

instance of_ Locals2, fhe compiler-generafed class for fhe irmer sfafemenf block, con- 

fains fhe local variable z and a field fhaf references an insfance of_ Localsl. An insfance 

of_ Localsl, fhe compiler-generafed class for fhe oufer sfafemenf block, confains fhe 

local variable y and a field fhaf references this of fhe enclosing funcfion member. Wifh 
fhese dafa sfrucfures, if is possible fo reach all capfured oufer variables fhrough an insfance 

of_Local2, and fhe code of fhe anonymous funcfion can fhus be implemenfed as an 

insfance mefhod of fhaf class. 


“■ BILL WAG N E R If F () refurned an insfance of D, fhe lives of all fhe variables fhis 
funcfion capfures would be exfended. 


class Test 
{ 

void F() { 

_Localsl _localsl = new _Localsl(); 

_localsl._this = this; 

_localsl.y = 123; 

for (int i = 0; i < 10; i++) { 

_Locals2 _locals2 = new _Locals2(); 

_locals2._localsl = _localsl; 

_locals2.z = i * 2; 

D d = new D(_locals2._Methodl); 

} 

} 

class _Localsl 

{ 

public Test _this; 

public int y; 

} 

class _Locals2 

{ 

public _Localsl _localsl; 

public int z; 

public void _Methodl() { 

Console.WriteLine(_localsl._this.x + _localsl.y + z); 

} 

} 

} 

The same fechnique applied here fo capfure local variables can also be used when convert¬ 
ing anonymous functions to expression trees: References fo fhe compiler-generafed objecfs 
can be stored in fhe expression free, and access fo fhe local variables can be represented as 
field accesses on fhese objecfs. The advanfage of fhis approach is fhaf if allows fhe "lifted" 
local variables fo be shared befween delegates and expression frees. 




225 


www.it-ebooks.info 


Conversions 






Conversions 


6. Conversions 


so 


“■ ERIC LI PPERT A downside of this implementation technique (and a disadvan¬ 
tage shared by many implementations of many languages that have similar closure 
semantics) is that two different anonymous functions in the same method that are 
closed over two different local variables cause the lifetimes of both variables to be 
extended to match the lifetime of the longest-lived delegate. 

Suppose you have two local variables, expensive and cheap, and two delegates, one 
closed over each variable: 

D longlived = ()=>cheap; 

D shortlived = ()=>expensive; 

The lifetime of expensive is at least as long as the lifetime of the object referred to by 
longlived, even though expensive is not actually used by longlived. A more sophis¬ 
ticated implementation would partition closed-over variables into separate compiler¬ 
generated classes and avoid this problem. 


6.6 Method Group Conversions 

An implicit conversion (§6.1) exists from a method group (§7.1) to a compatible delegate 
type. Given a delegate t 5 q)e D and an expression E that is classified as a method group, an 
implicit conversion exists from E to D if E contains at least one method that is applicable in 
its normal form (§7.5.3.1) to an argument list constructed by use of the parameter t 5 q)es and 
modifiers of D, as described in the following. 

The compile-time application of a conversion from a method group E to a delegate type D 
is described in the following. Note that the existence of an implicit conversion from E to 
D does not guarantee that the compile-time application of the conversion will succeed 
without error. 


"■ VLADIMIR RESHETNIKOV In particular, it is possible that overload resolution 
will pick the best function member containing a delegate type in its signature, while 
an implicit conversion from a method group, provided as the corresponding argu¬ 
ment, to that delegate type will result in a compile-time error. This situation may 
occur, for instance, because overload resolution cannot find the single best method in 
that group. Even if the best method is found, constraints on its type parameters might 
be violated, or the method might not be compatible with the delegate type, or it 
might be an instance method referenced in a static context. 


226 


www.it-ebooks.info 








6.6 Method Group Conversions 


• Asingle method M is selected corresponding to a method invocation (§7.6.5.1) of the form 
E (A), with the following modifications: 

- The argument list A is a list of expressions, each classified as a variable and with the 
type and modifier (ref or out) of the corresponding parameter in the formal-parameter- 
list of D. 

- The candidate methods considered are only those methods that are applicable in 
their normal form (§7.5.3.1), not those applicable only in their expanded form. 

• If the algorithm of §7.6.5.1 produces an error, then a compile-time error occurs. Other¬ 
wise, the algorithm produces a single best method M having the same number of param¬ 
eters as D and the conversion is considered to exist. 

• The selected method M must be compatible (§15.2) with the delegate type D; otherwise, a 
compile-time error occurs. 

• If the selected method M is an instance method, the instance expression associated with 
E determines the target object of the delegate. 

• If the selected method M is an extension method, which is denoted by means of a member 
access on an instance expression, that instance expression determines the target object 
of the delegate. 

• The result of the conversion is a value of 1)^0 D —^namely, a newly created delegate that 
refers to the selected method and target object. 

Note that this process can lead to the creation of a delegate to an extension method, if the 
algorithm of §7.6.5.1 fails to find an instance method but succeeds in processing the invoca¬ 
tion of E (A) as an extension method invocation (§7.6.5.2). A delegate thus created captures 
the extension method as well as its first argument. 




"■ VLADIMIR RESHETNIKOV If the first parameter of an extension method con¬ 
verted to a delegate t 5 ^e is of a value t 5 ^e or t 5 ^e parameter not known to be a refer¬ 
ence type (§10.1.5), a compile-time error occurs. 

If an instance method declared in System. Nullable<T > is converted to a delegate t 5 ^e, 
a compile-time error occurs as well. 


The following example demonstrates method group conversions: 
delegate string Dl(object o); 
delegate object D2(string s); 
delegate object D3(); 

delegate string D4(object o, pararrs object[] a); 


227 


www.it-ebooks.info 


Conversions 






Conversions 


6. Conversions 


so 


delegate string D5(int i); 
class Test 


static 

String F(object 

0) 

•} 


static 

void G() { 





Dl 

dl = F; 

// 

Okay 



D2 

d2 = F; 

// 

Okay 



D3 

d3 = F; 

// 

Error: 

not applicable 


D4 

d4 = F; 

// 

Error: 

not applicable 

in normal form 

D5 

dS = F; 

// 

Error: 

applicable but 

not compatible 


} 


} 


The assignment to dl implicitly converts the method group F to a value of 1)^0 Dl. 

The assignment to d2 shows how it is possible to create a delegate to a method that has less 
derived (contravariant) parameter types and a more derived (covariant) return type. 

The assignment to d3 shows how no conversion exists if fhe mefhod is nof applicable. 

The assignmenf fo d4 shows how fhe mefhod musf be applicable in ifs normal form. 

The assignmenf fo d5 shows how paramefer and refum fypes of fhe delegafe and mefhod 
are allowed fo differ only for reference f 5 ^es. 

As wifh all ofher implicif and explicif conversions, fhe casf operator can be used fo explic- 
ifly perform a mefhod group conversion. Thus fhe example 

object obj = new EventHandler(myDialog.OkClick); 

could insfead be written 

object obj = (EventHandler)rryDialog.OkClick; 

Mefhod groups may influence overload resolution, and parficipafe in fj^e inference. See 
§7.5 for furfher defails. 

The runtime evaluation of a mefhod group conversion proceeds as follows: 

• If fhe mefhod selecfed af compile time is an insfance mefhod, or if if is an exfension 
mefhod fhaf is accessed as an insfance mefhod, fhe fargef objecf of fhe delegafe is defer- 
mined from the instance expression associated with E: 

- The instance expression is evaluated. If fhis evaluafion causes an exception, no fur¬ 
fher sfeps are execufed. 

- If fhe insfance expression is of a reference-type, fhe value compufed by fhe insfance 
expression becomes fhe fargef objecf. If fhe selecfed mefhod is an insfance mefhod 


228 


www.it-ebooks.info 





6.6 Method Group Conversions 


and the target object is null, a System.NullReferenceException is thrown and no 
further steps are executed. 

- If the instance expression is of a value-type, a boxing operation (§4.3.1) is performed 
to convert the value to an object, and this object becomes the target object. 

• Otherwise, the selected method is part of a static method call, and the target object of the 
delegate is null. 

• A new instance of the delegate type D is allocated. If there is not enough memory avail¬ 
able to allocate the new instance, a System.OutOfMemoryException is thrown and no 
further steps are executed. 


■■ JONSKEET The fact that the specification explicitly states that a new instance is 
created at this point prevents a potential optimization. The Microsoft C# compiler is 
able to cache delegates created via anonymous functions if they don't capture any 
variables (including this). The same sort of caching would be feasible for delegates 
created via any method group conversion that selects a static method—^but the speci¬ 
fication prohibits it. 


• The new delegate instance is initialized with a reference to the method that was deter¬ 
mined at compile time and a reference to the target object computed above. 


p\ 


229 


www.it-ebooks.info 


Conversions 






This page intentionally left blank 


www.it-ebooks.info 


7. Expressions 


An expression is a sequence of operators and operands. This chapter defines the S 5 mtax, 
order of evaluation of operands and operators, and meaning of expressions. 


7.1 Expression Classifications 

An expression is classified as one of the following: 

• A value. Every value has an associated t 5 q)e. 

• A variable. Every variable has an associated type—namely, the declared type of the 
variable. 


“■ VLADIMIR RESHETNIKOV Types of local variables and lambda expression 
parameters can be inferred by the compiler in many cases, and do not always need to 
be explicitly specified in declarations. 


• A namespace. An expression with this classification can only appear as the left-hand side 
of a member-access (§7.6.4). In any other context, an expression classified as a namespace 
causes a compile-time error. 

• A type. An expression with this classification can only appear as the left-hand side of a 
member-access (§7.6.4), or as an operand for the as operator (§7.10.11), the is operator 
(§7.10.10), or the typeof operator (§7.6.11). In any other context, an expression classified 
as a t 5 q)e causes a compile-time error. 


■■ VLADIMIR RESHETNIKOV If an expression is classified as a tjqje and appears as 
the left-hand side of a member-access, it never denotes an array or pointer t 5 q)e. If the 
expression denotes a t 5 q)e parameter, it always leads to a compile-time error later. 


231 


www.it-ebooks.info 








Expressions 


7. Expressions 


• A method group, which is a set of overloaded methods resulting from a member lookup 
(§7.4). A mefhod group may have an associafed insfance expression and an associafed 
fype argumenf lisf. When an insfance mefhod is invoked, fhe resulf of evaluafing fhe 
insfance expression becomes fhe insfance represenfed by this (§7.6.7). A mefhod group 
is permiffed in an invocation-expression (§7.6.5), in a delegate-creation-expression (§7.6.10.5), 
and as fhe leff-hand side of an is operafor, and can be implicifly converfed fo a compaf- 
ible delegafe f 5 ^e (§6.6). In any ofher confexf, an expression classified as a mefhod group 
causes a compile-fime error. 


“■ ERIC LIPPERT Thaf a mefhod group is legal on fhe leff-hand side of an is opera¬ 
for is a bif of a misleading feafure. The resulf of fhe is evaluation will always be false, 
even if fhe mefhod group is converfible fo fhe f 5 ^e on fhe righf-hand side. 


"■ VLADIMIR RESHETNIKOV A mefhod group on fhe leff-hand side of an is opera¬ 
for cannof be used in expression frees. 


• A null liferal. An expression wifh fhis classificafion can be implicifly converfed fo a refer¬ 
ence f 5 ^e or nullable type. 

• An anonymous fimction. An expression with this classification can be implicitly con¬ 
verted to a compatible delegate t 5 ^e or expression tree t 5 ^e. 


“■ ERIC LIPPERT Method groups, anonymous functions, and the null literal are all 
expressions that have no t 5 ^e. These unusual expressions can be used only when the 
type can be figured ouf from fhe confexf. 


• A properfy access. Every properfy access has an associafed fype—namely, fhe fype of 
fhe properfy. Furfhermore, a properfy access may have an associafed insfance expres¬ 
sion. When an accessor (fhe get or set block) of an insfance properfy access is invoked, 
fhe resulf of evaluafing fhe insfance expression becomes fhe insfance represenfed by 
this (§7.6.7). 

• An evenf access. Every evenf access has an associafed type—namely, the t 5 ^e of fhe 
evenf. Furfhermore, an event access may have an associated instance expression. An 
event access may appear as the left-hand operand of fhe += and -= operators (§7.17.3). 
In any ofher confexf, an expression classified as an evenf access causes a compile-fime 
error. 


232 


www.it-ebooks.info 










7.1 Expression Classifications 


• An indexer access. Every indexer access has an associated type—namely, the element 
type of the indexer. Furthermore, an indexer access has an associated instance expres¬ 
sion and an associated argument list. When an accessor (the get or set block) of an 
indexer access is invoked, fhe result of evaluating the instance expression becomes the 
instance represented by this (§7.6.7), and the result of evaluating the argument list 
becomes the parameter list of the invocation. 

• Nothing. This occurs when the expression is an invocation of a method with a return 
type of void. An expression classified as nothing is only valid in the context of a 
statement-expression (§8.6). 

The final result of an expression is never a namespace, t 5 ^e, method group, or event access. 
Rather, as noted above, these categories of expressions are intermediate constructs that are 
permitted only in certain contexts. 

A property access or indexer access is always reclassified as a value by performing an invo- 
cafion of fhe get-accessor or the set-accessor. The particular accessor is determined by the 
context of the property or indexer access: If the access is the target of an assignment, the 
set-accessor is invoked to assign a new value (§7.17.1). Otherwise, the get-accessor is invoked 
to obtain the current value (§7.1.1). 


7.1.1 Values of Expressions 

Most of the constructs that involve an expression ultimately require the expression to 
denote a value. In such cases, if fhe acfual expression denotes a namespace, a type, a 
method group, or nothing, a compile-time error occurs. However, if the expression denotes 
a property access, an indexer access, or a variable, the value of the property, indexer, or 
variable is implicitly substituted: 

• The value of a variable is simply the value currently stored in the storage location iden¬ 
tified by the variable. A variable must be considered definitely assigned (§5.3) before its 
value can be obtained; otherwise, a compile-time error occurs. 

• The value of a properfy access expression is obtained by invoking the get-accessor of the 
property. If the property has no get-accessor, a compile-time error occurs. Otherwise, a 
function member invocation (§7.5.4) is performed, and fhe resulf of the invocation 
becomes the value of fhe property access expression. 

• The value of an indexer access expression is obtained by invoking the get-accessor of the 
indexer. If the indexer has no get-accessor, a compile-time error occurs. Otherwise, a func¬ 
tion member invocation (§7.5.4) is performed with the argument list associated with the 
indexer access expression, and the result of the invocation becomes the value of the 
indexer access expression. 




233 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


“■ VLADIMIR RESHETNIKOV If a property or indexer has a get-accessor, but the 
accessor has an accessibility modifier and is not accessible in the current context, a 
compile-time error occurs. 


7.2 Static and Dynamic Binding 

The process of determining the meaning of an operation based on the type or value of 
constituent expressions (arguments, operands, receivers) is often referred to as binding. 
For instance, the meaning of a method call is determined based on the type of the receiver 
and arguments. The meaning of an operator is determined based on the type of its 
operands. 

In C#, the meaning of an operation is usually determined at compile time, based on the 
compile-time type of its constituent expressions. Likewise, if an expression contains an 
error, the error is detected and reported by the compiler. This approach is known as static 
binding. 

However, if an expression is a dynamic expression (i.e., has the t 5 ^e dynamic), this indicates 
that any binding that it participates in should be based on its runtime type (i.e., the actual 
type of the object it denotes at runtime) rather than the type it has at compile time. The 
binding of such an operation is therefore deferred until the time where the operation is to 
be executed during the running of the program. This is referred to as dynamic binding. 

When an operation is dynamically bound, little or no checking is performed by the com¬ 
piler. Instead, if the runtime binding fails, errors are reported as exceptions at runtime. 

The following operations in C# are subject to binding: 

• Member access: e. M 

• Method invocation: ... jgJ 

• Delegate invocation: e(e^j..., ej 

• Element access: e[e^j... ,ej 

• Object creation: new , e^) 

• Overloaded unary operators: - -, true, false 

• Overloaded binary operators: +, -, *, /,%,&,&&, |, | |, ? ?,<<,>>, ==,! =, >, <, >=, <= 

• Assignment operators: =, +-, *=, /=, %=, \ ''=, <<=, >>= 

• Implicit and explicit conversions 


234 


www.it-ebooks.info 






7.2 Static and Dynamic Binding 


When no dynamic expressions are involved, C# defaults to static binding, which means 
that the compile-time types of constituent expressions are used in the selection process. 
However, when one of the constituent expressions in the operations listed above is a 
dynamic expression, the operation is instead dynamically bound. 

7.2.1 BindingTime 

Static binding takes place at compile time, whereas dynamic binding takes place at 
runtime. In the following sections, the term binding time refers to either compile time 
or runtime, depending on when the binding takes place. 

The following example illustrates the notions of static and d 5 mamic binding and of bind¬ 
ing time: 

object 0=5; 
dynamic d = 5; 

Console.WriteLine(5); // Static binding to Console.WriteLine(int) 

Console.WriteLine(o); // Static binding to Console.WriteLine(object) 

Console.WrlteLine(d); // Dynamic binding to Console.WriteLine(int) 

The first two calls are statically bound: The overload of Console. WriteLine is picked based 
on the compile-time type of their argument. Thus the binding time is compile time. 

The third call is dynamically bound: The overload of Console .WriteLine is picked based 
on the runtime tj^e of its argument. This happens because the argument is a dynamic 
expression—its compile-time tj^e is dynamic. Thus the binding time for the third call is 
runtime. 


“■ BILL WAG N E R Many people confuse djmamic binding with tj^e inference. Type 
inference is statically bound. The compiler determines the tj^e at compile time. For 
example: 

var i = 5; // i is an int (Compiler performs type inference) 

Console.WriteLine(i); // Static binding to Console.WriteLine(int) 

The compiler infers that i is an integer. All binding on the variable i uses static 
binding. 




7.2.2 Dynamic Binding 

The purpose of dynamic binding is to allow C# programs to interact with dynamic objects — 
that is, objects that do not follow the normal rules of the C# tj^e system. Djmamic objects 
may be objects from other programming languages with different type systems, or they 
may be objects that are programmatically set up to implement their own binding semantics 
for different operations. 


235 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


“■ ERIC LIPPERT The primary motivating examples of such objects are (1) objects 
from d 5 mamic languages such as IronPyfhon, IronRuby, JScripf, and so on; (2) objecfs 
from "expando" objecf models fhaf emphasize addifion of new properfies af runfime, 
such as fhe Infemef Explorer Documenf Objecf Model and ofher markup-based objecf 
models; and (3) legacy COM objecfs, such as fhe Microsoff Office objecf model. The 
infenfion here is fo make if easier for professional C# developers fo inferoperafe wifh 
fhese sysfems; our infenfion is not af all fo make C# info a dynamic language like 
JScripf. 


The mechanism by which a dynamic objecf implemenfs ifs own semanfics is implemenfa- 
fion defined. A given inferface—again, implemenfafion defined—is implemenfed by 
dynamic objecfs fo signal fo fhe C# runfime fhaf fhey have special semanfics. Thus, when¬ 
ever operations on a d 5 mamic objecf are d 5 mamically bound, fheir own binding semanfics, 
rather than those of C# as specified in fhis documenf, fake over. 


“■ ERIC LI PPERT The mechanism acfually chosen for fhe Microsoff implemenfafion 
of fhis feafure is fhe same mechanism used by IronPyfhon and fhe ofher DLR lan¬ 
guages fo make fheir d 5 mamic analysis and dispafch efficienf. A dynamic operafion 
compiles info a call fo mefhods of DLR objecfs, which fhen use a special runfime ver¬ 
sion of fhe C# expression binder fo build expression frees represenfing fhe d 5 mamic 
operafion. These expression frees are fhen compiled, cached, and reused fhe nexf time 
fhe call sife is execufed. 


While fhe purpose of d 5 mamic binding is fo allow inferoperafion wifh dynamic objecfs, C# 
allows dynamic binding on all objecfs, whefher fhey are dynamic or nof. This allows for a 
smoofher infegrafion of dynamic objecfs, as fhe resulfs of operafions on fhem may nof 
fhemselves be dynamic objecfs, buf are sfill of a fype unknown fo fhe programmer af com¬ 
pile time. Also, dynamic binding can help eliminafe error-prone reflection-based code even 
when no objecfs involved are dynamic objecfs. 


"■ ERIC LIPPERT C#already supporfed a form of d 5 mamic mefhod dispafch: Virfual 
mefhods are fechnically a form of dynamic dispafch because fhe runfime f 5 T'e of fhe 
receiver is used fo defermine precisely which mefhod fo call. Alfhough we do nof 
infend fo make C# a dynamic language (as I nofed earlier), fhere is af leasf one pro¬ 
gramming problem where dynamic dispafch comes in handy: fhe "multiple virfual 
dispafch" problem. This problem arises when you wanf fo choose which mefhod fo call 
based on fhe runfime f 5 ^es of many of fhe argumenfs, nof jusf fhe receiver. (If is nof 
difficulf fo implemenf "double virfual" dispafch wifh fhe visitor paffem, buf if becomes 
awkward fo implemenf rrmfime dispafching on mefhods wifh many argumenf f 5 ^es.) 


236 


www.it-ebooks.info 










7.2 Static and Dynamic Binding 


The following sections describe for each construct in the language exactly when dynamic 
binding is applied, which kind of compile-time checking (if any) is applied, and what the 
compile-time result and expression classification are. 

7.2.3 Types of Constituent Expressions 

When an operation is statically bound, the t 5 ^e of a constituent expression (e.g., a receiver, 
an argument, an index or an operand) is always considered to be the compile-time type of 
that expression. 

When an operation is dynamically bound, the type of a constituent expression is deter¬ 
mined in different ways depending on the compile-time type of the constituent 
expression: 

• A constituent expression of compile-time type dynamic is considered to have the type of 
the actual value that the expression evaluates to at runtime. 


“ BlLL WAGNER The rule that expressions of compile-time type dynamic use the 
actual runtime type leads to surprising behavior, such as the following compiler 
error: 

public class Base 
{ 

public Base(dynamic parameter) 

{ 

} 


public class Derived : Base 
{ 

public Derived(dynamic parameter) : base(parameter) 
{ 

} 


Dynamic dispatch is not allowed during construction, so you must force static dis¬ 
patch to the base constructor call. 




• A constituent expression whose compile-time t 5 ^e is a t 5 ^e parameter is considered to 
have the t 5 ^e which the type parameter is bound to at runtime. 

• Otherwise, the constituent expression is considered to have its compile-time type. 


237 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


7.3 Operators 

Expressions are constructed from operands and operators. The operators of an expression 
indicafe which operafions fo apply fo fhe operands. Examples of operafors include +, *, 

/, and new. Examples of operands include liferals, fields, local variables, and expressions. 

There are fhree kinds of operafors: 

• Unary operafors. The imary operafors fake one operand and use eifher prefix nofafion 
(such as -x) or posffix nofafion (such as x++). 

• Binary operafors. The binary operafors fake fwo operands and all use infix nofafion 
(such as X + y). 

• Ternary operator. Only one ternary operafor, ?:, exisfs; if fakes fhree operands and uses 
infix nofafion (c ? x: y). 

The order of evaluation of operafors in an expression is determined by fhe precedence and 
associativity of fhe operafors (§7.3.1). 

Operands in an expression are evaluated from leff fo righf. Eor example, in F(i) + G(i++) 

• H(i), mefhod F is called using fhe old value of i, fhen mefhod G is called wifh fhe old 
value of i, and, finally, mefhod H is called wifh fhe new value of i. This is separafe from 
and unrelafed fo operafor precedence. 

Cerfain operafors can be overloaded. Operafor overloading permifs user-defined operafor 
implemenfafions fo be specified for operafions where one or bofh of fhe operands are of a 
user-defined class or sfrucf fype (§7.3.2). 

7.3.1 Operator Precedence and Associativity 

When an expression confains mulfiple operafors, fhe precedence of fhe operafors confrols 
fhe order in which fhe individual operafors are evaluafed. Eor example, fhe expression 
x + y * z is evaluafed as x + (y * z) because fhe * operafor has higher precedence fhan fhe 
binary + operafor. The precedence of an operafor is esfablished by fhe definifion of ifs asso- 
ciafed grammar producfion. Eor example, an additive-expression consisfs of a sequence of 
multiplicative-expressions separafed by + or - operafors, fhus giving fhe + and - operafors 
lower precedence fhan fhe *, /, and % operafors. 

The following fable summarizes all operafors in order of precedence from highesf fo 
lowesf: 


238 


www.it-ebooks.info 




7.3 Operators 


Section 

Category 

Operators 

7.6 

Primary 

x.y f(x) a[x] X++ x-- new 

typeof default checked unchecked delegate 

7.7 

Unary 

+ - ! ~ ++X --X (T)x 

7.8 

Multiplicative 

* / % 

7.8 

Additive 

+ 

7.9 

Shift 

<< >> 

7.10 

Relational and type 
testing 

<><=>= is as 

7.10 

Equality 

== ! = 

7.11 

Logical AND 

Si 

7.11 

Logical XOR 

A 

7.11 

Logical OR 

1 

7.11 

Conditional AND 

SiS. 

7.12 

Conditional OR 

II 

7.12 

Null coalescing 

?? 

7.14 

Conditional 

?: 

7.17, 

7.15 

Assignment and 
lambda expression 

II 

II 

< 

II 

o3 

II 

/\ 

A 

II 

V 

V 

II 

1 

II 

+ 

II 

II 

* 

A 

II II 


When an operand occurs between two operators with the same precedence, the associativ¬ 
ity of the operators controls the order in which the operations are performed: 

• Excepf for fhe assignmenf operafors, all binary operators are left-associative, meaning 
fhaf operafions are performed from leff fo righf. For example, x + y + z is evaluafed as 
(x + y) + z. 

• The assignmenf operafors and fhe conditional operafor (?:) are right-associative, mean¬ 
ing thaf operafions are performed from righf fo leff. For example, x = y = z is evaluafed 
as X = (y = z). 


239 


www.it-ebooks.info 


Expressions 






















Expressions 


7. Expressions 


Precedence and associativity can be controlled using parentheses. For example, x + y * z 
first multiplies y by z and then adds the result to x, but (x + y) * z first adds x and y and 
then multiplies the result by z. 


■■ CHRIS SELLS I'm not a big fan of programs fhat rely on operator precedence fo 
execute correctly When the order of execufion is in doubt, wrap your expressions in 
parentheses. The parentheses will not affect the compiled output (except that you 
might have fixed a bug), buf fhey make fhe code much easier fo undersfand for the 
human readers. 


■■ JESSE LIBERTY I see no harm in going even further and always wrapping expres¬ 
sions in parentheses. You may not be in doubt what is intended, but the poor program¬ 
mer who has to maintain your code ought not have to look up the precedence to make 
sense of fhe code. If fhe number of parenfheses becomes confusing in ifself, consider 
breaking your sfafement into multiple statements using interim temporary variables. 


“■ ERICLIPPERT The relationship between precedence, associativity, parentheses, 
and order of execufion can be confusing. Operands are always evaluated on a strictly 
left-to-right basis. The way that the results of fhose evaluafions are combined is 
affected by precedence, associafivity, and parenfheses. It is emphatically not the case 
that y and z are evaluated before x. Yes, fhe mulfiplicafion is compufed before fhe 
addition, but the evaluation of x occurs before fhe mulfiplicafion. 


7.3.2 Operator Overloading 

All unary and binary operators have predefined implementafions thaf are automafically 
available in any expression. In addition to the predefined implemenfations, user-defined 
implementations can be introduced by including operator declarations in classes and 
structs (§10.10). User-defined operator implementations always take precedence over pre¬ 
defined operator implementations: Only when no applicable user-defined operator imple¬ 
mentations exist will the predefined operator implementations be considered, as described 
in §7.3.3 and §7.3.4. 

The overloadable unary operators are: 

+ - ! ~ ++ -- true false 


240 


www.it-ebooks.info 










7.3 Operators 


Although true and false are not used explicitly in expressions (and therefore are not 
included in the precedence table in §7.3.1), they are considered operators because they are 
invoked in several expression contexts: boolean expressions (§7.20) and expressions involv¬ 
ing the conditional (§7.14), and conditional logical operators (§7.12). 

The overloadahle binary operators are: 

+ -*/%&!''<<>>==!=><>=<= 

Only the operators listed above can be overloaded. In particular, it is not possible to over¬ 
load member access, method invocation, or the &&, | |,??,?:, =>, checked, unchecked, 
new, typeof, default, as, and is operators. 

When a binary operator is overloaded, the corresponding assignment operator, if any, is 
also implicifly overloaded. For example, an overload of operator * is also an overload of 
operator *=. This is described furfher in §7.17.2. Nofe fhaf fhe assignmenf operator ifself (=) 
carmof be overloaded. An assignmenf always performs a simple bifwise copy of a value 
info a variable. 

Casf operafions, such as (T) x, are overloaded by providing user-defined conversions 
(§6.4). 

Elemenf access, such as a[x], is nof considered an overloadahle operator. Instead, user- 
defined indexing is supporfed fhrough indexers (§10.9). 

In expressions, operators are referenced using operator nofafion, and in declarafions, oper¬ 
ators are referenced using funcfional nofafion. The following fable shows fhe relationship 
befween operafor and funcfional nofafions for unary and binary operafors. In fhe firsf 
entry, op denotes any overloadahle unary prefix operafor. In fhe second enfry, op denofes 
fhe unary posffix ++ and - - operafors. In fhe fhird enfry, op denofes any overloadahle 
binary operafor. 


Operator Notation 

Functional Notation 

op X 

operator op{x) 

X op 

operator op{x) 

X op y 

operator op{x, y) 




User-defined operafor declarafions always require af leasf one of fhe paramefers to be of 
fhe class or strucf type that contains the operator declaration. Thus it is not possible for a 
user-defined operafor to have the same signature as a predefined operafor. 


241 


www.it-ebooks.info 


Expressions 









Expressions 


7. Expressions 


User-defined operator declarations cannot modify the syntax, precedence, or associativity 
of an operator. For example, the / operator is always a binary operator, always has the 
precedence level specified in §7.3.1, and is always left-associative. 

While it is possible for a user-defined operator to perform any computation it pleases, 
implementations that produce results other than those that are intuitively expected are 
strongly discouraged. For example, an implementation of operator == should compare the 
two operands for equality and return an appropriate bool result. 


“■ BILL WAGNER In addition to following this rule, you should limit the use of 
user-defined operators to those times when the operation will be obvious to the vast 
majority of the developers who use your code. 


“■ ERIC LIPPERT The overloadable operators are all mathematical or logical in 
nature. If you are building a library of mathematical objects such as matrices, vectors, 
and so on, by all means create user-defined operators. But please resist the temptation 
to make "cute" operators, such as "a Customer plus an Order produces an Invoice." 


The descriptions of individual operators in §7.6 through §7.12 specify the predefined 
implementations of the operators and any additional rules that apply to each operator. The 
descriptions make use of the terms unary operator overload resolution, binary operator 
overload resolution, and numeric promotion, definitions of which are found in the follow¬ 
ing sections. 

7.3.3 Unary Operator Overload Resolution 

An operation of the form op x or x op, where op is an overloadable unary operator, and x is 
an expression of type X, is processed as follows: 

• The set of candidate user-defined operators provided by X for the operation operator 
op(x) is determined using the rules of §7.3.5. 

• If the set of candidate user-defined operators is not empty, then this becomes the set of 
candidate operators for the operation. Otherwise, the predefined imary operator op 
implementations, including their lifted forms, become the set of candidate operators for 
the operation. The predefined implementations of a given operator are specified in the 
description of the operator (§7.6 and §7.7). 

• The overload resolution rules of §7.5.3 are applied to the set of candidate operators to 
select the best operator with respect to the argument list (x), and this operator becomes 


242 


www.it-ebooks.info 








7.3 Operators 


the result of the overload resolution process. If overload resolufion fails fo selecf a single 
besf operator, a binding-fime error occurs. 


7.3.4 Binary Operator Overload Resolution 

An operafion of fhe form x op y, where op is an overloadable binary operator, x is an expres¬ 
sion of f 5 ^e X, and y is an expression of fype Y, is processed as follows: 

• The sef of candidafe user-defined operafors provided by X and Y for fhe operafion 
operator op(x, y) is determined. The sef consisfs of fhe union of fhe candidafe operafors 
provided by X and fhe candidafe operafors provided by Y, each determined using fhe 
rules of §7.3.5. If X and Y are fhe same t 5 ^e, or if X and Y are derived from a common base 
fype, fhen shared candidafe operafors occur in fhe combined sef only once. 

• If fhe sef of candidafe user-defined operafors is nof empfy, fhen fhis becomes fhe sef of 
candidafe operafors for fhe operafion. Ofherwise, fhe predefined binary operator op 
implemenfafions, including fheir liffed forms, become fhe sef of candidafe operafors for 
fhe operafion. The predefined implemenfafions of a given operafor are specified in fhe 
descripfion of fhe operafor (§7.8 fhrough §7.12). 

• The overload resolufion rules of §7.5.3 are applied fo fhe sef of candidafe operafors fo 
selecf fhe besf operafor wifh respecf fo fhe argumenf lisf (x, y), and fhis operafor 
becomes fhe resulf of fhe overload resolufion process. If overload resolufion fails fo 
selecf a single besf operafor, a binding-fime error occurs. 

7.3.5 Candidate User-Defined Operators 

Given a type T and an operation operator op (A), where op is an overloadable operator 

and A is an argument list, the set of candidafe user-defined operafors provided by T for 

operator op (A) is determined as follows: 

• Determine fhe fype T^. If T is a nullable f 5 ^e, is ifs underlying fype; ofherwise, is 
equal fo T. 

• For all operator op declarafions in and all liffed forms of such operafors, if af leasf one 
operafor is applicable (§7.5.3.1) wifh respecf fo fhe argumenf lisf A, fhen fhe sef of candi¬ 
dafe operafors consisfs of all such applicable operafors in T^. 

• Ofherwise, if is object, fhe sef of candidafe operafors is empfy. 

• Ofherwise, fhe sef of candidafe operafors provided by is fhe sef of candidafe operafors 
provided by fhe direcf base class of T^, or fhe effective base class of if is a f 5 q)e 
parameter. 




243 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


7.3.6 Numeric Promotions 

Numeric promotion consists of automatically performing certain implicit conversions of 
the operands of the predefined unary and binary numeric operators. Numeric promotion 
is not a distinct mechanism, but rather an effect of applying overload resolution to the 
predefined operators. Numeric promotion specifically does not affect evaluation of user- 
defined operators, although user-defined operators can be implemented to exhibit similar 
effects. 

As an example of numeric promotion, consider the predefined implementations of the 
binary * operator: 

int operator *(int x, int y); 
uint operator *(uint x, uint y); 
long operator *(long x, long y); 
ulong operator *(ulong x, ulong y); 
float operator *(float x, float y); 
double operator ^(double x, double y); 
decimal operator *(decimal x, decimal y); 

When overload resolution rules (§7.5.3) are applied to this set of operafors, fhe effecf is fo 
selecf fhe firsf of fhe operators for which implicit conversions exist from the operand types. 
For example, for fhe operafion b * s, where b is a byte and s is a short, overload resolution 
selecfs operator *(int, int) as the best operator. Thus the effect is that b and s are con¬ 
verted to int, and the t 5 ^e of the result is int. Likewise, for fhe operation i * d, where i is 
an int and d is a double, overload resolution selects operator *(doublej double) as the 
best operator. 

7.3.6.1 Unary Numeric Promotions 

Unary numeric promotion occurs for the operands of fhe predefined +, -, and ~ unary 
operafors. Unary numeric promotion simply consists of converting operands of fype sbyte, 
byte, short, ushort, or char fo type int. Additionally, for fhe unary - operator, unary 
numeric promotion converts operands of type uint to type long. 


73.6.2 Binary Numeric Promotions 

Binary numeric promotion occurs for the operands of the predefined +, -, *, /, %, &, |, 

! =, >, <, >=, and <= binary operators. Binary numeric promotion implicitly converts both 
operands to a common type which, in case of the nonrelational operators, also becomes the 
result type of fhe operafion. Binary numeric promotion consists of applying fhe following 
rules, in the order they appear here: 

• If eifher operand is of fype decimal, fhe other operand is converted to type decimal, or 
a binding-time error occurs if fhe ofher operand is of t 5 ^e float or double. 


244 


www.it-ebooks.info 




7.3 Operators 


• Otherwise, if either operand is of t 5 ^e double, the other operand is converted to type 
double. 

• Otherwise, if either operand is of t 5 ^e float, the other operand is converted to type 
float. 

• Otherwise, if either operand is of t 5 ^e ulong, the other operand is converted to type 
ulong, or a binding-time error occurs if the other operand is of t 5 ^e sbyte, short, int, 
or long. 

• Otherwise, if either operand is of type long, the other operand is converted to 
type long. 

• Otherwise, if either operand is of type uint and the other operand is of type sbyte, 
short, or int, both operands are converted to type long. 

• Otherwise, if either operand is of type uint, the other operand is converted to 
type uint. 

• Otherwise, both operands are converted to type int. 

Note that the first rule disallows any operations that mix the decimal type with the double 
and float types. The rule follows from the fact that there are no implicit conversions 
between the decimal type and the double and float types. 

Also note that it is not possible for an operand to be of t 5 ^e ulong when the other operand 
is of a signed integral type. The reason is that no integral t 5 ^e exists that can represent the 
full range of ulong as well as the signed integral types. 

In both of the above cases, a cast expression can be used to explicitly convert one operand 
to a t 5 ^e that is compatible with the other operand. 

In the example 

decimal AddPercent(decimal x, double percent) 

{ 

return x * (1.0 + percent / 100.0); 

} 

a binding-time error occurs because a decimal carmot be multiplied by a double. The error 
is resolved by explicitly converting the second operand to decimal, as follows: 

decimal AddPercent(declmal x, double percent) 

{ 

return x * (decimal)(1.0 + percent / 100.0); 

} 




245 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


■■ JOSEPH ALBAHARI The predefined operators described in this section always 
promote the 8- and 16-bit integral t 5 ^es—namely, short, ushort, sbyte, and byte. A 
common trap is assigning the result of a calculation on these t 5 ^es back to an 8- or 
16-bit integral: 

byte a = 1, b - 2; 

byte c = a + b; // Compile-time error 

In this case, the variables a and b are promoted to int, which requires an explicit cast 
to byte for the code to compile: 

byte a = 1, b - 2; 
byte c = (byte)(a + b); 


7.3.7 Lifted Operators 

Lifted operators permit predefined and user-defined operators that operate on non- 
nullable value t 5 q)es to also be used with nullable forms of those t 5 q)es. Lifted operators are 
constructed from predefined and user-defined operators that meet certain requirements, as 
described in the following list: 

• For the unary operators 

+++---!- 

a lifted form of an operator exists if the operand and result t 5 q)es are both non-nullable 
value types. The lifted form is constructed by adding a single ? modifier to the oper¬ 
and and result types. The lifted operator produces a null value if the operand is null. 
Otherwise, the lifted operator unwraps the operand, applies the underlying operator, 
and wraps the result. 

• For the binary operators 

+ -*/%&!''<<>> 

a lifted form of an operator exists if the operand and result t 5 q)es are all non-nullable 
value types. The lifted form is constructed by adding a single ? modifier to each oper¬ 
and and result t 5 q)e. The lifted operator produces a null value if one or both operands 
are null (an exception being the & and | operators of the bool? type, as described in 
§7.11.3). Otherwise, the lifted operator unwraps the operands, applies the underlying 
operator, and wraps the result. 

• For the equality operators 

a lifted form of an operator exists if the operand types are both non-nullable value 
types and if the result type is bool. The lifted form is constructed by adding a single 


246 


www.it-ebooks.info 






7.4 Member Lookup 


? modifier to each operand type. The lifted operator considers two null values equal, 
and a null value unequal to any non-null value. If both operands are non-null, the 
lifted operator unwraps the operands and applies the underlying operator to produce 
the bool result. 

• For the relational operators 
<><=>= 

a lifted form of an operator exists if the operand types are both non-nullable value 
types and if the result t 5 q)e is bool. The lifted form is constructed by adding a single ? 
modifier to each operand type. The lifted operator produces the value false if one or 
both operands are null. Otherwise, the lifted operator unwraps the operands and 
applies the underlying operator to produce the bool result. 


“■ BILL WAG N E R The default value of any nullable type is neither greater than nor 
less than any nullable t 5 q)e containing a value. 


7.4 Member Lookup 

Member lookup is the process whereby the meaning of a name in the context of a t 5 q)e is 
determined. A member lookup can occur as part of evaluating a simple-name (§7.6.2) or a 
member-access (§7.6.4) in an expression. If the simple-name or member-access occurs as the 
primary-expression of an invocation-expression (§7.6.5.1), the member is said to be invoked. 

If a member is a method or event, or if it is a constant, field, or property of either a delegate 
type (§15) or the type dynamic (§4.7), then the member is said to be invocable. 

Member lookup considers not only the name of a member, but also the number of type 
parameters the member has and whether the member is accessible. For the purposes of 
member lookup, generic methods and nested generic types have the number of type 
parameters indicated in their respective declarations and all other members have zero 
type parameters. 




"■ VLADIMIR RESHETNIKOV The result of member lookup never contains opera¬ 
tors, indexers, explicitly implemented interface members, static constructors, instance 
constructors, destructors (finalizers), or compiler-generated members. Although a 
type parameter contributes to the declaration space of its declaring t 5 q)e, it is not a 
member of that type and, therefore, cannot be a result of member lookup. 

Member lookup returns both static and instance members, regardless of the form of 
access. 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


A member lookup of a name N with K t 5 ^e parameters in a t 5 ^e T is processed as follows: 

• First, a set of accessible members named N is determined: 

- If T is a type parameter, then the set is the union of the sets of accessible members 
named N in each of the t 5 ^es specified as a primary constraint or secondary constraint 
(§10.1.5) for T, along with the set of accessible members named N in object. 

- Otherwise, the set consists of all accessible (§3.5) members named N in T, including 
inherited members and the accessible members named N in object. If T is a con¬ 
structed t 5 ^e, the set of members is obtained by substituting type arguments as 
described in §10.3.2. Members that include an override modifier are excluded from 
the set. 

• Next, if K is zero, all nested types whose declarations include type parameters are 
removed. If K is not zero, all members with a different number of type parameters 
are removed. Note that when K is zero, methods having t 5 ^e parameters are not removed, 
since the t 5 ^e inference process (§7.5.2) might be able to infer the type arguments. 

• Next, if the member is invoked, all non-invocable members are removed from the set. 


“■ VLADIMIR RESHETNIKOV This rule allows you to invoke an extension method 
even if a non-invocable instance member with the same name exists in the type T. For 
example, you can invoke extension method Count () on a collection even if it has an 
instance property Count of type int. 


• Next, members that are hidden by other members are removed from the set. For every 
member S . M in the set, where S is the type in which the member M is declared, the fol¬ 
lowing rules are applied: 

- If M is a constant, field, property, event, or enumeration member, then all members 
declared in a base type of S are removed from the set. 

- If M is a type declaration, then all nont 5 ^es declared in a base type of S are removed 
from the set, and all type declarations with the same number of type parameters as M 
declared in a base t 5 ^e of S are removed from the set. 

- If M is a method, then all nonmethod members declared in a base type of S are removed 
from the set. 


"■ VLADIMIR RESHETNIKOV Any members removed from the set on this step can 
still cause other members to be removed from the set. Thus the order in which the 
members are processed is not important. 


248 


www.it-ebooks.info 








7.4 Member Lookup 


• Next, interface members that are hidden by class members are removed from fhe sef. 

This sfep has an effecf only if T is a t 5 ^e paramefer and T has bofh an effective base class 

other than object and a non-empty effective interface sef (§10.1.5). For every member 

S. M in fhe sef, where S is fhe type in which the member M is declared, the following rules 

are applied if S is a class declaration ofher fhan object: 

- If M is a consfanf, field, properly, evenf, enumeration member, or type declaration, 
then all members declared in an interface declaration are removed from fhe sef. 

- If M is a mefhod, fhen all nonmefhod members declared in an inferface declarafion are 
removed from fhe sef, and all mefhods wifh fhe same signafure as M declared in an 
inferface declarafion are removed from fhe sef. 

• Finally, having removed hidden members, fhe resulf of fhe lookup is defermined: 

- If fhe sef consisfs of a single member fhaf is nof a mefhod, fhen fhis member is fhe 
resulf of fhe lookup. 

- Ofherwise, if fhe sef confains only mefhods, fhen fhis group of mefhods is fhe resulf 
of fhe lookup. 

- Ofherwise, fhe lookup is ambiguous, and a binding-fime error occurs. 


"■ VLADIMIR RESHETNIKOV The Microsoft C# compiler is more lenienf in fhe lasf 
case. If fhe sef confains bofh mefhods and nonmefhods, fhen a warning CS0467 is 
issued, all nonmefhods are discarded, and fhe group of remaining mefhods becomes 
fhe resulf of fhe lookup. This behavior is useful in some COM inferoperabilify 
scenarios. 


For member lookups in fypes ofher fhan type parameters and interfaces, and member 
lookups in inferfaces fhaf are sfricfly single-inherifance (each inferface in fhe inherifance 
chain has exacfly zero or one direcf base inferface), fhe effecf of fhe lookup rules is simply 
fhaf derived members hide base members wifh fhe same name or signafure. Such single- 
inherifance lookups are never ambiguous. The ambiguifies fhaf can possibly arise from 
member lookups in mulfiple-inherifance inferfaces are described in §13.2.5. 




7.4.1 Base Types 

For purposes of member lookup, a fype T is considered fo have fhe following base fypes: 

• If T is object, fhen T has no base f 5 ^e. 

• If T is an enum-type, fhe base fypes of T are fhe class fypes System. Enum, 

System.ValueType, and object. 


249 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


• If T is a struct-type, the base types of T are the class types System.ValueType and 
object. 

• If T is a class-type, the base types of T are the base classes of T, including the class type 
object. 

• If T is an interface-type, the base types of T are the base interfaces of T and the class t 5 ^e 
object. 


"■ ERIC LIPPERT This point ensures that it is legal to call ToString() and the other 
members of System.Object on a value of interface t 5 ^e. At runtime, any value of the 
interface type will be either null or something that inherits from System.Object, so 
this is a reasonable choice. 


• If T is an array-type, the base t5^es of T are the class types System. Array and object. 

• If T is a delegate-type, the base types of T are the class types System. Delegate and 
object. 


7.5 Function Members 

Function members are members that contain executable statements. Function members are 
always members of types and carmot be members of namespaces. C# defines the following 
categories of function members: 

• Methods 

• Properties 

• Events 

• Indexers 

• User-defined operators 

• Instance constructors 

• Static constructors 

• Destructors 

Except for destructors and static constructors (which cannot be invoked explicitly), the 
statements contained in function members are executed through function member 
invocations. The actual S 5 mtax for writing a function member invocation depends on the 
particular function member category. 


250 


www.it-ebooks.info 






7.5 Function Members 


The argument list (§7.5.1) of a fimction member invocation provides actual values or vari¬ 
able references for fhe paramefers of fhe funcfion member. 

invocafions of generic mefhods may employ fype inference fo defermine fhe sef of f 5 T’e 
argumenfs fo pass fo fhe mefhod. This process is described in §7.5.2. 

Invocafions of mefhods, indexers, operators, and msfance consfrucfors employ overload 
resolufion fo defermine which of a candidafe sef of funcfion members fo invoke. This pro¬ 
cess is described in §7.5.3. 

Once a parficular funcfion member has been idenfified af binding-fime, possibly fhrough 
overload resolufion, fhe acfual runfime process of invoking fhe funcfion member is 
described in §7.5.4. 

The following fable summarizes fhe processing fhaf fakes place in consfrucfs involving fhe 
six cafegories of funcfion members fhaf can be explicifly invoked. In fhe following fable, 
e, X, y, and value indicafe expressions classified as variables or values, T indicates an 
expression classified as a fype, F is fhe simple name of a mefhod, and P is fhe simple name 
of a properfy. 


Construct 

Example 

Description 

Method invocation 

> 

>< 

LL 

Overload resolution is applied to select 
the best method F in the containing class 
or struct. The method is invoked with the 
argument list (x, y). If the method is not 
static, the instance expression is this. 


T.F(x, y) 

Overload resolution is applied to select 
the best method F in the class or struct T. 

A binding-time error occurs if the method 
is not static. The method is invoked 
with the argument list (x, y). 


e.F(x, y) 

Overload resolution is applied to select 
the best method F in the class, struct, or 
interface given by the type of e. A 
binding-time error occurs if the method is 
static. The method is invoked with the 
instance expression e and the argument 
list (x, y). 


Continued 


251 


www.it-ebooks.info 


Expressions 










Expressions 


7. Expressions 


Construct 

Example 

Description 

Property access 

P 

The get accessor of the property P in the 
containing class or struct is invoked. A 
compile-time error occurs if P is write- 
only. If P is not static, the instance 
expression is this. 


P = value 

The set accessor of the property P in the 
containing class or struct is invoked with 
the argument list (value). A compile-time 
error occurs if P is read-only. If P is not 
static, the instance expression is this. 


T.P 

The get accessor of the property P in the 
class or struct T is invoked. A compile¬ 
time error occurs if P is not static or if P 
is write-only. 


T.P = value 

The set accessor of the property P in 
the class or struct T is invoked with the 
argument list (value). A compile-time 
error occurs if P is not static or if P is 
read-only. 


e.P 

The get accessor of the property P in the 
class, struct, or interface given by the 
type of e is invoked with the instance 
expression e. A binding-time error occurs 
if P is static or if P is write-only. 


e.P = value 

The set accessor of the property P in the 
class, struct, or interface given by the 
type of e is invoked with the instance 
expression e and the argument list 
(value). A binding-time error occurs if P 
is static or if P is read-only. 


252 


www.it-ebooks.info 













7.5 Function Members 


Construct 

Example 

Description 

Event access 

E += value 

The add accessor of the event E in the 
containing class or struct is invoked. If E is 
not static, the instance expression is this. 


E -= value 

The remove accessor of the event E in the 
containing class or struct is invoked. If E is 
not static, the instance expression is this. 


T.E += value 

The add accessor of the event E in the class 
or struct T is invoked. A binding-time 
error occurs if E is not static. 


T.E value 

The remove accessor of the event E in the 
class or struct T is invoked. A binding-time 
error occurs if E is not static. 


e.E += value 

The add accessor of the event E in the 
class, struct, or interface given by the 
type of e is invoked with the instance 
expression e. A binding-time error occurs 
if E is static. 


e.E -= value 

The remove accessor of the event E in 
the class, struct, or interface given by the 
type of e is invoked with the instance 
expression e. A binding-time error occurs 
if E is static. 

Indexer access 

e[x. y] 

Overload resolution is applied to select 
the best indexer in the class, struct, or 
interface given by the type of e. The get 
accessor of the indexer is invoked with the 
instance expression e and the argument 
list (Xj y). A binding-time error occurs if 
the indexer is write-only. 


e[Xj y] = value 

Overload resolution is applied to select 
the best indexer in the class, struct, or 
interface given by the type of e. The set 
accessor of the indexer is invoked with the 
instance expression e and the argument 
list (Xj y, value). A binding-time error 
occurs if the indexer is read-only. 


Continued 


253 


www.it-ebooks.info 


Expressions 















Expressions 


7. Expressions 


Construct 

Example 

Description 

Operator invocation 

-X 

Overload resolution is applied to select 
the best unary operator in the class or 
struct given by the type of x. The selected 
operator is invoked with the argument 
list (x). 

X + y 

Overload resolution is applied to select 
the best binary operator in the classes or 
structs given by the types of x and y. The 
selected operator is invoked with the 
argument list (x, y). 

Instance constructor 
invocation 

new T(Xj y) 

Overload resolution is applied to select 
the best instance constructor in the class or 
struct T. The instance constructor is 
invoked with the argument list (x, y). 


7.5.1 Argument Lists 

Every function member and delegate invocation includes an argument list that provides 
actual values or variable references for the parameters of the function member. The S 5 mtax 
for specifying the argument list of a function member invocation depends on the function 
member category: 

• For instance constructors, methods, indexers, and delegates, the arguments are specified 
as an argument-list, as described below. For indexers, when invoking the set accessor, 
the argument list additionally includes the expression specified as the right operand of 
the assignment operator. 


"■ VLADIMIR RESHETNIKOV This additional argument does not participate in 
overload resolution for indexers. 


• For properties, the argument list is empty when invoking the get accessor, and consists 
of the expression specified as the right operand of the assignment operator when invok¬ 
ing the set accessor. 

• For events, the argument list consists of the expression specified as the right operand of 
the += or - = operator. 

• For user-defined operators, the argument list consists of the single operand of the unary 
operator or the two operands of the binary operator. 


254 


www.it-ebooks.info 












7.5 Function Members 


The arguments of properties (§10.7), events (§10.8), and user-defined operators (§10.10) 
are always passed as value parameters (§10.6.1.1). The arguments of indexers (§10.9) are 
always passed as value parameters (§10.6.1.1) or parameter arrays (§10.6.1.4). Reference 
and output parameters are not supported for these categories of function members. 

The arguments of an instance constructor, method, indexer, or delegate invocation are 
specified as an argument-list: 

argument-list: 

argument 

argument-list , argument 
argument: 

argument-name argument-value 

argument-name: 
identifier : 

argument-value: 

expression 

ref variable-reference 
out variable-reference 

An argument-list consists of one or more arguments, separated by commas. Each argument 
consists of an optional argument-name followed by an argument-value. An argument with an 
argument-name is referred to as a named argument, whereas an argument without an 
argument-name is a positional argument. It is an error for a positional argument to appear 
after a named argument in an argument-list. 

The argument-value can take one of the following forms: 

• An expression, indicating that the argument is passed as a value parameter (§10.6.1.1). 

• The keyword ref followed by a variable-reference (§5.4), indicating that the argument is 
passed as a reference parameter (§10.6.1.2). A variable must be definitely assigned (§5.3) 
before it can be passed as a reference parameter. 

• The ke 5 rword out followed by a variable-reference (§5.4), indicating that the argument, is 
passed as an output parameter (§10.6.1.3). A variable is considered definitely assigned 
(§5.3) following a function member invocation in which the variable is passed as an 
output parameter. 




7.5.1.1 Corresponding Parameters 

For each argument in an argument list, there has to be a corresponding parameter in the 
function member or delegate being invoked. 


255 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


The parameter list used in the following is determined as follows: 

• For virfual mefhods and indexers defined in classes, fhe paramefer lisf is picked from 
fhe mosf specific declaration or override of fhe function member, sfarfing wifh fhe sfafic 
fype of fhe receiver, and searching fhrough ifs base classes. 


“■ ERIC LIPPERT These rules address fhe unforfunafe (and, one hopes, unlikely) 
sifuafion where you have a virfual mefhod—say, void M(int x, int y)—and an 
overriding mefhod—say, void M(int y, int x). Does fhe mefhod call Mfy:!, x:2) 
acf ually callMfl, 2)orM(2j 1)? Paramefer names are nof parf of fhe signaf ure of a 
mefhod and, fherefore, can change when overloaded. 


• For inferface mefhods and indexers, fhe paramefer lisf is picked from fhe mosf specific 
definition of fhe member, sfarfing wifh fhe inferface fype and searching fhrough fhe base 
inferfaces. If no unique paramefer lisf is found, a paramefer lisf wifh inaccessible names 
and no optional paramefers is consfrucfed, so fhaf invocations carmof use named param- 
efers or omif opfional argumenfs. 

• For partial mefhods, fhe paramefer lisf of fhe defining partial mefhod declarafion 
is used. 

• For all ofher function members and delegafes, fhere is only a single paramefer lisf, which 
is fhe one used. 

The position of an argumenf or paramefer is defined as fhe number of argumenfs or param¬ 
efers preceding if in fhe argumenf lisf or paramefer lisf. 

The corresponding paramefers for funcfion member argumenfs are esfablished as 

follows: 

• Argumenfs in fhe argument-list of insfance consfrucfors, mefhods, indexers, and 
delegafes: 

- A posifional argumenf where a fixed paramefer occurs af fhe same posifion in fhe 
paramefer lisf corresponds fo fhaf paramefer. 

- A posifional argumenf of a funcfion member wifh a paramefer array invoked in ifs 
normal form corresponds fo fhe paramefer array, which musf occur af fhe same posi¬ 
fion in fhe paramefer lisf. 

- A posifional argumenf of a funcfion member wifh a paramefer array invoked in ifs 
expanded form, where no fixed paramefer occurs af fhe same posifion in fhe param¬ 
efer lisf, corresponds fo an elemenf in fhe paramefer array. 


256 


www.it-ebooks.info 






7.5 Function Members 


- A named argument corresponds to the parameter of the same name in the 
parameter list. 

- For indexers, when invoking the set accessor, the expression specified as fhe righf 
operand of fhe assignmenf operafor corresponds fo fhe implicif value paramefer of 
fhe set accessor declarafion. 

• For properfies, when invoking fhe get accessor, fhere are no argumenfs. When invoking 
fhe set accessor, fhe expression specified as fhe righf operand of fhe assignmenf opera¬ 
for corresponds fo fhe implicif value paramefer of fhe set accessor declarafion. 

• For user-defined unary operafors (including conversions), fhe single operand corre¬ 
sponds fo fhe single paramefer of fhe operafor declarafion. 

• For user-defined binary operafors, fhe leff operand corresponds fo fhe firsf paramefer, 
and fhe righf operand corresponds fo fhe second paramefer of fhe operafor 
declarafion. 


7.5.1.2 Runtime Evaluation of Argument Lists 

During fhe runtime processing of a funcfion member invocafion (§7.5.4), fhe expressions 
or variable references of an argument list are evaluated in order, from leff fo righf, as 
follows: 

• For a value paramefer, fhe argumenf expression is evaluafed and an implicif conversion 
(§6.1) fo fhe corresponding paramefer f 5 ^e is performed. The resulfing value becomes 
fhe initial value of fhe value paramefer in fhe fimcfion member invocafion. 

• For a reference or oufpuf paramefer, fhe variable reference is evaluafed and fhe resulfing 
storage location becomes fhe sforage location represented by fhe paramefer in fhe func¬ 
fion member invocafion. If fhe variable reference given as a reference or oufpuf param¬ 
efer is an array elemenf of a reference-type, a runtime check is performed fo ensure fhaf 
fhe elemenf f 5 ^e of fhe array is identical fo fhe type of fhe paramefer. If fhis check fails, 
a System.ArrayTypeMismatchException is fhrown. 

Mefhods, indexers, and insfance consfrucfors may declare fheir righfmosf paramefer fo be 
a paramefer array (§10.6.1.4). Such funcfion members are invoked eifher in fheir normal 
form or in fheir expanded form depending on which is applicable (§7.5.3.1): 

• When a funcfion member wifh a paramefer array is invoked in ifs normal form, fhe argu¬ 
menf given for fhe paramefer array musf be a single expression fhaf is implicifly con¬ 
vertible (§6.1) fo fhe paramefer array fype. In fhis case, fhe paramefer array acfs precisely 
like a value paramefer. 

• When a function member with a parameter array is invoked in its expanded form, fhe 
invocation must specify zero or more posifional argumenfs for fhe paramefer array. 




257 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


where each argument is an expression that is implicitly convertible (§6.1) to the element 
type of the parameter array. In this case, the invocation creates an instance of the param¬ 
eter array type with a length corresponding to the number of arguments, initializes the 
elements of the array instance with the given argument values, and uses the newly cre¬ 
ated array instance as the actual argument. 

The expressions of an argument list are always evaluated in the order they are written. 
Thus the example 

class Test 
{ 

static void F(int x, int y = -1, int z = -2) 

{ 

System.Console.WriteLineC'x = {0}, y = {!}, z = {2}", x, y, z); 

} 

static void Main() 

{ 

int i = 0; 

F(i++, i++, i++); 

F(z: i++, x: i++); 

} 

} 

produces the output 

x = 0, y = l, z = 2 
X = 4, y = -1, z = 3 

The array covariance rules (§12.5) permit a value of an array type A[ ] to be a reference to 
an instance of an array type B[ ], provided an implicit reference conversion exists from B to 
A. Because of these rules, when an array element of a reference-type is passed as a reference 
or output parameter, a runtime check is required to ensure that the actual element type of 
fhe array is identical to that of the parameter. In the example 

class Test 
{ 

static void F(ref object x) {...} 

static void Main() 

{ 

object[] a = new object[10]; 
object[] b = new strlng[10]; 

F(ref a[0]); // Okay 

F(ref b[l]); // ArrayTypeMismatchException 

} 

} 

the second invocation of F causes a System. ArrayTypeMismatchException to be thrown 
because the actual element t 5 q)e of b is string and not object. 


258 


www.it-ebooks.info 




7.5 Function Members 


When a function member with a parameter array is invoked in its expanded form, the 
invocation is processed exactly as if an array creation expression with an array initializer 
(§7.6.10.4) was inserted around the expanded parameters. For example, given the 
declaration 

void F(int x, int y, params object[] args); 
the following invocations of the expanded form of the method 

F(10, 20); 

F(10, 20, 30, 40); 

F(10, 20, 1, "hello", 3.0); 

correspond exactly to 

F(10, 20, new object[] { }); 

F(10, 20, new object[] { 30, 40 }); 

F(10, 20, new object[] { 1, "hello", 3.0 }); 

In particular, note that an empty array is created when there are zero arguments given for 
the parameter array. 

When arguments are omitted from a function member with corresponding optional param¬ 
eters, the default arguments of the function member declaration are implicitly passed. 
Because these are always constant, their evaluation will not impact the evaluation order of 
the remaining arguments. 

7.5.2 Type Inference 

When a generic method is called without specifying type arguments, a type inference pro¬ 
cess attempts to infer t 5 ^e arguments for the call. The presence of t 5 ^e inference allows a 
more convenient S 5 mtax to be used for calling a generic method, and allows the program¬ 
mer to avoid specifying redundant type information. For example, given the method 
declaration 

class Chooser 
{ 

static Random rand = new Random(); 

public static T Choose<T>(T first, T second) 

{ 

return (rand.Next(2) == 0) ? first : second; 

} 

} 




259 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


it is possible to invoke the Choose method without explicitly specifying a type argument: 

int i = Chooser.Choose(5j 213); // Calls Choose<int> 

string s = Chooser.Choose("foo", "bar"); // Calls Choose<string> 

Through t 5 ^e inference, fhe fype argumenfs int and string are defermined from fhe argu- 
menfs fo fhe mefhod. 


■■ JONSKEET On occasion, 1 have affempfed fo work fhrough fhe fype inference 
algorithm for specific cases fhaf have nof behaved as 1 expecfed. I've nearly always 
regreffed if, coming ouf of fhe process more confused fhan before. If feels somewhaf 
like enfering a labyrinfh, hoping fo find fhe freasure (appropriafe f 5 ^e argumenfs) in 
fhe cenfer, buf usually encounfering a minofaur on fhe way. I am in awe of fhose who 
can nof only navigafe fhrough fhe algorifhm, buf also implemenf if in a compiler. 


"■ CH RIS S E LLS If undersfanding your code feels like navigating a labyrinfh, you're 
doing somefhing wrong. 


Type inference occurs as parf of fhe binding-time processing of a mefhod invocafion 
(§7.6.5.1) and fakes place before fhe overload resolution sfep of fhe invocafion. When a 
parficular mefhod group is specified in a mefhod invocafion, and no type arguments are 
specified as parf of fhe mefhod invocafion, fype inference is applied fo each generic mefhod 
in fhe mefhod group. If 1)^0 inference succeeds, fhen fhe inferred type arguments are used 
to determine the types of argumenfs for subsequenf overload resolution. If overload reso¬ 
lution chooses a generic mefhod as fhe one fo invoke, fhen fhe inferred fype argumenfs are 
used as fhe acfual type arguments for fhe invocafion. If fype inference for a parficular 
mefhod fails, fhaf mefhod does nof parficipafe in overload resolution. The failure of 1)^)0 
inference, in and of ifself, does nof cause a binding-time error. However, if offen leads fo a 
binding-time error when overload resolution then fails fo find any applicable mefhods. 


“■ ERIC LIPPERT The 15^26 inference algorifhm is nof guaranfeed fo produce an 
applicable candidafe. (Of course, overload resolution will weed ouf fhe nonapplicable 
candidafes.) The t5q3e inference algorifhm is designed fo answer one quesfion: Given 
only fhe argumenfs and fhe formal paramefer fypes, whaf is fhe best possible f 5 q)e argu- 
menf fhaf can be inferred for each f 5 q)e paramefer? If fhe besf possible inference pro¬ 
duces an inapplicable candidafe, fhen we do nof backfrack and fry fo guess whaf fhe 
user "really" mean! so fhaf inference can choose a differenf value. 


260 


www.it-ebooks.info 










7.5 Function Members 


“■ MAREK SAFAR When t 5 ^e inference succeeds but overloads resolution fails, the 
culprit might be an inferred type parameter that uses constraints. The t 5 ^e inference 
algorithm ignores type parameter constraints, leaving it to overload resolution to ver¬ 
ify the best candidate. 


If the supplied number of arguments is different than the number of parameters in the 
method, then inference immediately fails. Otherwise, assume that the generic method has 
the following signature: 

T M<X,. . .X >(T, X, ... T X ) 

r 1 n'll mm' 

With a method call of the form M(... E^), the task of type inference is to find unique 
type arguments S^.. .S^ for each of the type parameters X^.. .X^ so that the call M<Sj... 
S^> (Ej... E^)becomes valid. 


■■ VLAD IMIR R ES H ETNIKOV Although it is not indicated explicitly here, the signa¬ 
ture can have ref/ out parameters. 


During the process of inference, each t 5 q)e parameter X. is either/ixed to a particular 1)^)0 S. 
or unfixed with an associated set of bounds. Each of the bounds is some type T. Initially each 
type variable X. is imfixed with an empty set of bounds. 

Type inference takes place in phases. Each phase will try to infer type arguments for more 
type variables based on the findings of the previous phase. The first phase makes some 
initial inferences of bounds, whereas the second phase fixes type variables to specific types 
and infers further bounds. The second phase may have to be repeated a number of times. 

Note: Type inference takes place in more situations than just when a generic method is 
called. Type inference for conversion of method groups is described in §7.5.2.13 and find¬ 
ing the best common type of a set of expressions is described in §7.5.2.14. 


“■ ERIC LIPPERT The language design team occasionally is asked, "Why did you 
invent your own t 5 q)e inference algorithm instead of using a Hindley-Milner-style 
algorithm?" The short answer is that (1) Hindley-Milner-style algorithms are difficult 
to adapt to languages with class-based inheritance and covariant t 5 q)es, and (2) back¬ 
tracking algorithms can potentially take a very long time to execute. 

Our type inference algorithm was designed to handle inheritance and t 5 q)e variance. 
Because every iteration of the second phase either "fixes" an additional t 5 q)e parame¬ 
ter to its inferred type or fails if it is unable to do so, it is clear that the t 5 q)e inference 
process terminates in fairly short order. 




261 


www.it-ebooks.info 


Expressions 










Expressions 


7. Expressions 


“■ PETER SESTOFT Although probably not intended to, the previous annotation 
may leave the impression that a type inference algorithm for a Hindley-Milner-sfyle 
fype sysfem (fhaf is, ML lef polymorphism) musf use backfracking. In parficular, fhe 
Damas-Milner algorifhm (1978) does nof use backfracking. Thai said, use of back¬ 
fracking would be overkill for C# type inference, because in C# all t 5 ^e paramefers 
musf be explicifly specified. In confrasf, fhe Damas-Milner algorifhm will invenf 
enough 1)^30 parameters to find fhe mosf general ("principal") f 5 ^e for a given expres¬ 
sion. Thai problem is known fo be complefe for exponenfial fime. 


7.5.2.1 The First Phase 

For each of fhe mefhod argumenfs E.: 

• If E. is an anonymous fimcfion, an explicit parameter type inference (§7.5.2.7) is made from 

E. to T.. 

1 1 

• Ofherwise, if E. has a type U and x. is a value parameter, then a lower-bound inference is 
made from U to T.. 

• Otherwise, if E . has a type U and x. is a ref or out parameter, then an exact inference is 
made from U to T.. 

• Otherwise, no inference is made for fhis argumenf. 

7.5.2.2 The Second Phase 

The second phase proceeds as follows: 

• All unfixed fype variables X. fhaf do nof depend on (§7.5.2.5) any X. are fixed (§7.5.2.10). 

• If no such f 5 ^e variables exisf, all unfixed f 5 ^e variables X. are fixed for which bofh of fhe 
following hold: 

- There is af leasf one type variable X^ that depends on X.. 

- Xj has a non-empty set of bounds. 

• If no such type variables exist and there are still unfixed t 5 ^e variables, type inference 
fails. 

• Ofherwise, if no furfher unfixed type variables exist, type inference succeeds. 

• Ofherwise, for all argumenfs E. wifh corresponding paramefer type T. where the output 
types (§7.5.2.4) contain unfixed t 5 ^e variables X. but the input types (§7.5.2.3) do not, an 
output type inference (§7.5.2.6) is made from E. to T.. Then the second phase is repeated. 


262 


www.it-ebooks.info 






7.5 Function Members 


7.5.23 Input Types 

If E is a method group or implicitly typed anonymous fimction and T is a delegate type or 
expression tree type, then all the parameter types of T are input types of E with type T. 

7.5.2.4 Output Types 

If E is a method group or an anonymous function and T is a delegate type or expression tree 
type, then the return t 5 ^e of T is an output type of E with type T. 

7.5.2.5 Dependence 

An unfixed t 5 ^e variable X. depends directly on an unfixed t 5 ^e variable X . if for some argu¬ 
ment E|^ with t 5 ^e X. occurs in an input type of E^ with type and X. occurs in an output 
type of E^ with t 5 ^e T^. 

X. depends on X. if X. depends directly on X. or if X. depends directly on X^ and X,^ depends 
on X.. Thus "depends on" is the transitive but not reflexive closure of "depends directly on." 


“■ VLADIMIR RESHETNIKOV A type parameter could possibly directly or indirectly 
depend on itself. 


7.5.2.6 Output Type Inferences 

An output type inference is made from an expression E to a type T in the following way: 

• If E is an anonymous function with inferred return t 5 ^e U (§7.5.2.12) and T is a delegate 
type or expression tree t 5 ^e with return t 5 ^e then a lower-bound inference (§7.5.2.9) is 
made from U to T^. 

• Otherwise, if E is a method group and T is a delegate t 5 ^e or expression tree t 5 ^e with 

parameter t 5 ^es and return t 5 ^e T^, and overload resolution of E with the types 

Tj ... T|^ yields a single method with return type U, then a lower-bound inference is made 
from U to T|^. 


"■ VLADIMIR RESHETNIKOV This step applies only if all method type parameters 
occurring in the delegate parameter t 5 ^es are already fixed. Overload resolution does 
not try to select the best method based on incomplete t 5 ^e information. 




• Otherwise, if E is an expression with t 5 ^e U, then a lower-bound inference is made from 
U to T. 

• Otherwise, no inferences are made. 


263 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


7.52.7 Explicit Parameter Type Inferences 

An explicit parameter type inference is made from an expression E io a t5^e T in the follow¬ 
ing way: 

• If E is an explicifly fyped anonymous function wifh paramefer fypes and T is a 

delegafe fype or expression free fype wifh paramefer f5^es ... V^, fhen for each U. an 
exact inference (§ 7 . 5 . 2 . 8 ) is made from U. to fhe corresponding V.. 

7 . 5 . 2.8 Exact Inferences 

An exact inference from a t5^e U to a t5^e V is made as follows: 

• If V is one of fhe unfixed X., fhen U is added fo fhe sef of exacf bounds for X.. 

• Ofherwise, sefs and ... U|^ are defermined by checking if any of fhe following 

cases apply: 

- V is an array type V J ... ] and U is an array t5^e [... ] of fhe same rank. 

- V is fhe f5^e V^? and U is fhe f5^e U^?. 

V is a consfrucfed type C<Vj.. .V^> and U is a constructed type C<Uj.. .U^>. 

- If any of fhese cases apply, fhen an exact inference is made from each U. to fhe corre¬ 
sponding V.. 

• Ofherwise, no inferences are made. 

7 . 5 . 2.9 Lower-Bound Inferences 

A lower-bound inference from a type U fo a type V is made as follows: 

• If V is one of fhe unfixed X., fhen U is added fo fhe sef of lower boimds for X.. 

• Ofherwise, sefs and are defermined by checking if any of fhe following 

cases apply: 

- V is an array type V^[... ]and U is an array type L)J ... ] (or a type parameter whose 
effective base type is U J ... ]) of fhe same rank. 

- V is one of IEnumerable<Vj>, ICollection<V^>, or IList<V^> and U is a one-dimensional 
array fype UJ ] (or a f5^e paramefer whose effecfive base fype is UJ ]). 


“■ VLAD IMIR R ES H ETNIKOV Of course, fhis bullef (and fhe corresponding bullef in 
fhe nexf paragraph) menfions inferfaces from namespace System. Collections . 
Generic. 


264 


www.it-ebooks.info 






7.5 Function Members 


' Visthet5^e V^? and U is the type U^?. 

- V is a constructed class, struct, interface, or delegate type C<Vj.. .V^> and there is a 
unique type C<U^... U|^> such that U (or, if U is a t 5 q)e parameter, its effective base class 
or any member of its effective interface sef) is identical to, inherits from (directly or 
indirectly), or implements (directly or indirectly) C<Uj.. .U^>. 

(The "uniqueness" restriction means that in the case interface C<T>{} class U: 
C<X>, C<Y>{}, then no inference is made when inferring from U to C<T> because 
could be X or Y.) 


“■ VLAD IMIR R ES H ETNIKOV The same inference rule applies fo constructed enum 
types. Although enum types cannot have t 5 q)e parameters in their declarations, they 
can still be generic if nesfed within a generic class or struct t 5 q)e. 


If any of these cases apply, then an inference is made from each U. to the corresponding V. 
as follows: 

• If U. is not known to be a reference type, then an exact inference is made. 

• Otherwise, if U is an array t5q)e, then a lower-bound inference is made. 

• Otherwise, if V is C<V^... V^>, then inference depends on the i-th t5q)e parameter of C: 

- If if is covarianf, fhen a lower-hound inference is made. 

- If it is contravariant, then an upper-bound inference is made. 

- If if is invariant, then an exact inference is made. 

• Otherwise, no inferences are made. 

7.5.2.10 Upper-Bound Inferences 

An upper-bound inference from a t5q)e U fo a t5q)e V is made as follows: 

• If V is one of the unfixed X., then U is added to the set of upper bounds for X.. 

• Otherwise, sets and are determined by checking if any of the following 

cases apply: 

- L) is an array fype U J ... ] and V is an array t5q)e [... ] of the same rank. 

- L) is one of IEnumerable<U >, ICollection<L) >, or IList<U > and V is a one-dimensional 
array type V J ]. 

- L) is the t5q)e U^? and V is the t5q)e V^?. 




265 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


- L) is constructed class, struct, interface, or delegate type C<Uj.. .U|^> and V is a class, 
struct, interface, or delegafe type that is identical to, inherits from (direcfly or indi- 
recfly), or implemenfs (direcfly or indirecfly) a unique f5q)e C<\/^.. .\/^>. 

(The "uniqueness" resfricfion means fhaf if we have interface C<T>{} class V<Z>: 
C<X<Z>>, C<Y<Z>>{}, fhen no inference is made when inferring from C<Uj> fo V<Q>. 
Inferences are nof made from fo eifher X<Q> or Y<Q>.) 

If any of fhese cases apply, fhen an inference is made from each U. to fhe corresponding 
as follows: 

• If U. is nof known fo be a reference type, then an exact inference is made. 

• Otherwise, if V is an array type, then an upper-bound inference is made. 

• Otherwise, if U is C<U^... U^>, fhen inference depends on fhe i-fh f5q)e paramefer of C: 

- If if is covarianf, fhen an upper-bound inference is made. 

- If if is confravarianf, fhen a lower-bound inference is made. 

- If if is invarianf, fhen an exact inference is made. 

• Ofherwise, no inferences are made. 


■■ VLADIMIR RESHETNIKOV So, no inferences are ever made for mefhod type 
parameters that do not appear in the parameter types of fhe generic mefhod. For 
example, no inferences are made for paramefers fhaf appear only in consfrainfs: 

using System.Collections.Generic; 

class C 
{ 

static void Foo<T,U>(T x) where T : IEnumerable<U> { } 

static void Main() 

{ 

Foo(new List<int>()); 

// Error CS0411: The type arguments for method 
// ’C.Foo<T,U>(T)' cannot be inferred from the 
// usage. 

} 

} 


7.5.2.11 Fixing 

An unfixed fype variable X. wifh a sef of bounds is fixed as follows: 

• The sef of candidate types U. sfarfs ouf as fhe sef of all fypes in fhe sef of bounds for X.. 


266 


www.it-ebooks.info 






7.5 Function Members 


“■ ERIC LI PPERT This condition illustrates a subtle design point of C#. When faced 
wifh fhe need fo choose a "besf fype" given a sef of f 5 ^es, we always choose one of 
fhe f 5 ^es in fhe sef. Thaf is, if asked fo choose fhe besf f 5 ^e in {Cat, Dog, Goldfish}, 
we fail fo find a besf fype; we never say, "The common base f5T’e Animal is fhe besf 
we can do given fhose fhree choices" because Animal is nof one of fhe choices in fhe 
firsf place. 


• We fhen examine each bound for X. in furn: For each boimd U of X., all fypes U . fhaf are 
nof identical fo U are removed from fhe candidafe sef. For each lower bound U of X., all 
fypes U . fo which fhere is not an implicif conversion from U are removed from fhe candi¬ 
dafe sef. For each upper bound U of X., all fypes U . from which fhere is not an implicif 
conversion fo U are removed from fhe candidafe sef. 

• If among fhe remaining candidafe fypes fhere is a unique fype V from which fhere is 
an implicif conversion fo all fhe ofher candidafe f 5 q)es, fhen X. is fixed fo V. 

• Ofherwise, f}^)^ inference fails. 


■■ ERICLIPPERT In C# 2.0, fhe generic mefhod f 5 T>e inference algorifhm failed if 
two disfincf bounds were compufed for fhe same fype paramefer. In C# 3.0, we have 
sifuafions such as fhe loin mefhod, which musf infer fhe f5T>e of fhe "key" upon 
which fhe fwo collecfions are joined. If fhe key in one collecfion is, say, int, and fhe 
corresponding key in fhe ofher collecfion is int?, fhen we have fwo disfincf fypes. 
Because every int maybe converfed fo int?, however, we could allow fhe ambiguify 
and resolve if by picking fhe more general of fhe fwo fypes. C# 4.0 supporfs generic 
variance, which complicafes fhe sifuafion furfher; now we mighf have upper, lower, 
and exacf bounds on a fype paramefer. 


7.5.2.12 Inferred Return Type 

The inferred return type of an anonymous funcfion F is used during fype inference and 
overload resolution. The inferred refurn fype can only be defermined for an anonymous 
funcfion where all paramefer fypes are known, eifher because fhey are explicifly given, 
provided fhrough an anonymous fimcfion conversion, or inferred during fype inference on 
an enclosing generic mefhod invocation. The inferred refurn fype is defermined as 
follows: 

• If fhe body of F is an expression, fhen fhe inferred refurn f 5 q)e of F is fhe f 5 T>e of fhaf 
expression. 

• If fhe body of F is a block and fhe sef of expressions in fhe block's return sfafemenfs has 
a besf common f 5 q)e T (§7.5.2.14), fhen fhe inferred refurn fype of F is T. 




267 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


“■ VLADIMIR RESHETNIKOV Even return statements in unreachable code are 
included in the set and participate in calculation of the inferred refum f 5 ^e. This has 
a surprising consequence, in fhaf removing unreachable code can change fhe program 
behavior. 


• Ofherwise, a refum fype carmof be inferred for E. 

As an example of f 5 q>e inference involving anonymous funcfions, consider fhe Select 
exfension mefhod declared in fhe System. Linq. Enumerable class: 

namespace System.Linq 
{ 

public static class Enumerable 
{ 

public static IEnumerable<TResult> SelectcTSource, TResult>( 
this IEnumerable<TSource> source, 

Func<TSource, TResult> selector) 

{ 

foreach (TSource element in source) 
yield return selector(element); 

} 

} 

} 

Assuming fhe System. Linq namespace was imporfed wifh a using clause, and given a 
class Customer wifh a Name properfy of fype string, fhe Select mefhod can be used fo 
selecf fhe names of a lisf of customers: 

List<Customer> customers = GetCustomerList(); 

IEnumerable<string> names = customers.Select(c => c.Name); 

The exfension mefhod invocafion (§7.6.5.2) of Select is processed by rewriting fhe invoca- 
fion fo a sfafic mefhod invocafion: 

IEnumerable<string> names = Enumerable.Select(customers, c => c.Name); 

Since f5q5e argumenfs were nof explicifly specified, f 5 q)e inference is used fo infer fhe f 5 qie 
argumenfs. Firsf, fhe customers argumenf is relafed fo fhe source paramefer, inferring T fo 
be Customer. Then, using fhe anonymous function fype inference process described above, 
c is given f 5 q)e Customer, and fhe expression c.Name is relafed fo fhe refurn fype of fhe 
selector paramefer, inferring S fo be string. Thus fhe invocafion is equivalenf fo 

Sequence.SelectcCustomer,string>(customers, (Customer c) => c.Name) 
and fhe resulf is of fype IEnumerable<string>. 


268 


www.it-ebooks.info 






7.5 Function Members 


The following example demonstrates how anonymous fimction type inference allows type 
information to "flow" between arguments in a generic method invocation. Given the 
method 

static Z F<XjYjZ>(X value, Func<X,Y> fl, Func<Y,Z> f2) { 
return f2(fl(value)); 

} 

type inference for the invocation 

double seconds = F("l:15:30", s => TimeSpan.Parse(s), t => t.TotalSeconds); 

proceeds as follows: First, the argument "1:15:30" is related to the value parameter, infer¬ 
ring X to be string. Then, the parameter of the first anonymous function, s, is given the 
inferred type string, and the expression TimeSpan. Parse(s) is related to the return type of 
fl, inferring Y to be System.TimeSpan. Finally, the parameter of the second anonymous 
function, t, is given the inferred type System. TimeSpan, and the expression t. TotalSeconds 
is related to the return type of f2, inferring Z to be double. Thus the result of the invocation 
is of type double. 

7.5.2.13 Type Inference for Conversion of Method Groups 

Similar to calls of generic methods, type inference must also be applied when a method 
group M containing a generic method is converted to a given delegate type D (§6.6). Given 
a method 

T M<X,. . .X >(T X . . . T X ) 

r 1 n'll mm' 

and the method group M being assigned to the delegate t 5 ^e D, the task of type inference is 
to find t 5 ^e arguments S^ ... S^ so that the expression 

M<Sj. . .S„> 

becomes compatible (§15.1) with D. 

Unlike the t 5 ^e inference algorithm for generic method calls, in this case there are only 
argument types —no argument expressions. In particular, there are no anonymous functions 
and hence no need for multiple phases of inference. 

Instead, all X. are considered unfixed, and a lower-bound inference is made from each argu¬ 
ment t 5 ^e U . of D to the corresponding parameter type T . of M. If for any of the X. no bounds 
were found, type inference fails. Otherwise, all X. are fixed to corresponding S., which are 
the result of type inference. 


269 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


7.5.2.14 Finding the Best Common Type of a Set of Expressions 

In some cases, a common type needs to be inferred for a sef of expressions. In parficular, 
fhe elemenf fypes of implicifly fyped arrays and fhe refurn fypes of anonymous fimcfions 
wifh block bodies are found in fhis way. 

Infuifively, given a sef of expressions ... E^, fhis inference should be equivalenf fo calling 
a mefhod 

T M<X>(X X, ... X X ) 

r ' 1 m' 

wifh E. as argumenfs. 

More precisely, fhe inference sfarfs ouf wifh an unfixed type variable X. Output type infer¬ 
ences are then made from each E. to X. Finally, X is fixed and, if successful, fhe resulfing fype 
S is fhe resulfing besf common type for fhe expressions. If no such S exisfs, fhe expressions 
have no besf common type. 

7.5.3 Overload Resolution 

Overload resolution is a binding-time mechanism for selecting the best function member 
to invoke given an argument list and a set of candidafe function members. Overload reso- 
lufion selecfs fhe funcfion member fo invoke in fhe following disfincf confexfs wifhin C#: 

• Invocafion of a mefhod named in an invocation-expression (§7.6.5.1). 

• Invocafion of an insfance consfrucfor named in an object-creation-expression (§7.6.10.1). 

• Invocafion of an indexer accessor fhrough an element-access (§7.6.6). 

• Invocafion of a predefined or user-defined operator referenced in an expression (§7.3.3 
and §7.3.4). 


“■ VLADIMIR RESHETNIKOV The same rules govern selection of an affribufe 
insfance consfrucfor in an affribufe specificafion, invocafion of an insfance consfrucfor 
in a constructor-initializer, and invocafion of an indexer fhrough a base-access. 


Each of fhese confexfs defines fhe sef of candidafe funcfion members and fhe lisf of argu¬ 
menfs in ifs own unique way, as described in defail in fhe sections listed above. For exam¬ 
ple, the set of candidates for a mefhod invocafion does nof include mefhods marked 
override (§7.4), and mefhods in a base class are nof candidates if any mefhod in a derived 
class is applicable (§7.6.5.1). 


270 


www.it-ebooks.info 






7.5 Function Members 


Once the candidate function members and the argument list have been identified, fhe 
selection of fhe besf funcfion member is fhe same in all cases: 

• Given fhe sef of applicable candidafe funcfion members, fhe besf funcfion member in 
fhaf sef is locafed. If fhe sef confains only one fimcfion member, fhen fhaf funcfion mem¬ 
ber is fhe besf fimcfion member. Ofherwise, fhe besf funcfion member is fhe one funcfion 
member fhaf is beffer fhan all ofher funcfion members wifh respecf fo fhe given argu- 
menf lisf, provided fhaf each funcfion member is compared fo all ofher funcfion mem¬ 
bers using fhe rules in §7.5.3.2. If fhere is nof exacfly one funcfion member fhaf is beffer 
fhan all ofher funcfion members, fhen fhe funcfion member invocafion is ambiguous 
and a binding-fime error occurs. 

The following secfions define fhe exacf meanings of fhe ferms applicable function member 
and better function member. 


"■ BILL WAG N E R This secfion gefs very complicafed. As you read if, remember fhaf 
every addifional overload you creafe may confribufe fo fhe possible ambiguify in 
overload resolution. You should limif yourself fo fhe number of overloads fhaf fruly 
make if easier on your users. Thaf approach will keep matters as simple as possible for 
users of your class and help fhem ensure fhaf fhey gef fhe righf mefhod. 


7.5.3.1 Applicable Function Member 


"■ VLADIMIR RESHETNIKOV This secfion also governs applicabilify of delegafes 
(§7.6.5.3). 


A funcfion member is said fo be an applicable function member wifh respecf fo an argu- 
menf lisf A when all of fhe following are frue: 

• Each argumenf in A corresponds fo a paramefer in fhe funcfion member declaration as 
described in §7.5.1.1, and any parameter to which no argument corresponds is an 
optional parameter. 

• For each argument in A, the parameter passing mode of fhe argumenf (i.e., value, ref, or 
out) is identical fo fhe paramefer passing mode of fhe corresponding paramefer, and 

- For a value paramefer or a paramefer array, an implicif conversion (§6.1) exisfs from 
fhe argumenf fo fhe type of fhe corresponding paramefer, or 

- For a ref or out paramefer, fhe type of fhe argumenf is idenfical fo fhe t 5 ^e of fhe 
corresponding paramefer. After all, a ref or out paramefer is an alias for fhe argu¬ 
menf passed. 




271 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


A function member that includes a parameter array, if the function member is applicable 
by the above rules, is said to be applicable in its normal form. If a function member that 
includes a parameter array is not applicable in its normal form, the function member may 
instead be applicable in its expanded form: 

• The expanded form is constructed by replacing the parameter array in the function 
member declaration with zero or more value parameters of the element type of the 
parameter array such that the number of arguments in the argument list A matches the 
total number of parameters. If A has fewer arguments than the number of fixed param¬ 
eters in the function member declaration, the expanded form of the function member 
cannot be constructed and is thus not applicable. 

• Otherwise, the expanded form is applicable if for each argument in A the parameter 
passing mode of the argument is identical to the parameter passing mode of the corre¬ 
sponding parameter, and 

- For a fixed value parameter or a value parameter created by the expansion, an implicit 
conversion (§6.1) exists from the type of the argument to the t 5 ^e of the correspond¬ 
ing parameter, or 

- For a ref or out parameter, the type of the argument is identical to the type of the 
corresponding parameter. 

7.5.3.2 Better Function Member 

For the purposes of determining the better function member, a stripped-down argument 
list A is constructed containing just the argument expressions themselves in the order they 
appear in the original argument list. 

Parameter lists for each of the candidate function members are constructed in the follow¬ 
ing way: 

• The expanded form is used if the function member was applicable only in the 
expanded form. 

• Optional parameters with no corresponding arguments are removed from the parame¬ 
ter list. 

• The parameters are reordered so that they occur at the same position as the correspond¬ 
ing argument in the argument list. 

Given an argument list A with a set of argument expressions { E^, E^, ..., E^} and two appli¬ 
cable function members Mp and with parameter t 5 ^es { P^, P^, P„ } and { Q^, Q^, ..., 
}, Mp is defined to be a better function member than M^ if 


272 


www.it-ebooks.info 




7.5 Function Members 


• For each argument, the implicit conversion from to is not better than the implicit 
conversion from E,, fo and 

• For af leasf one argumenf, fhe conversion from E^^ fo P,, is beffer fhan fhe conversion from 
ExtoQ,. 

When performing fhis evaluafion, if or is applicable in ifs expanded form, fhen P,, or 
Qjj refers fo a paramefer in fhe expanded form of fhe paramefer lisf. 

In case fhe paramefer fype sequences {P^, P^, ..., PJ and {Q^, Q^, ..., QJ are equivalenf (i.e., 
each P. has an identify conversion fo fhe corresponding Qj, fhe following fie-breaking rules 
are applied, in order, fo defermine fhe beffer function member: 

• If Mp is a nongeneric mefhod and is a generic mefhod, fhen Mp is beffer fhan 

• Ofherwise, if Mp is applicable in ifs normal form and M^^ has a pa rams array and is appli¬ 
cable only in ifs expanded form, fhen Mp is beffer fhan M^. 

• Ofherwise, if Mp has more declared paramefers fhan M^^, fhen Mp is beffer fhan M^. This 
can occur if bofh mefhods have pa rams arrays and are applicable only in fheir expanded 
forms. 

• Ofherwise, if all paramefers of Mp have a corresponding argumenf whereas defaulf argu- 
menfs need fo be subsfifufed for af leasf one opfional paramefer in M^^, fhen Mp is beffer 
fhan Mjj. 

• Ofherwise, if Mp has more specific paramefer fypes fhan M^^, fhen Mp is beffer fhan M^^. Lef 
{R^, R^, ..., R„} and {S^, S^, ..., represenf fhe uninsfanfiafed and unexpanded param¬ 
efer fypes of Mp and M^. Mp's paramefer fypes are more specific fhan M^'s if, for each 
paramefer, R^^ is nof less specific fhan and, for af leasf one paramefer, R^, is more 
specific fhan S,,: 

- A fype paramefer is less specific fhan a nonf 5 q)e paramefer. 

- Recursively, a consfrucfed type is more specific fhan anofher consfrucfed t 5 q)e (wifh 
fhe same number of t 5 q)e argumenfs) if af leasf one type argument is more specific 
and no type argument is less specific fhan fhe corresponding type argument in 
the other. 

- An array type is more specific fhan anofher array type (with the same number of 
dimensions) if fhe elemenf type of fhe firsf is more specific fhan fhe elemenf type 
of fhe second. 

• Ofherwise, if one member is a non-liffed operator and fhe ofher is a liffed operafor, fhe 
non-liffed one is beffer. 

• Ofherwise, neifher funcfion member is beffer. 




273 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


7.5.3.3 Better Conversion from Expression 

Given an implicit conversion that converts from an expression E to a t 5 ^e T^, and an 
implicit conversion that converts from an expression E fo a type T^, is a better conver¬ 
sion than if af leasf one of fhe following holds: 

• E has a t 5 ^e S and an idenfify conversion exisfs from S fo buf nof from S fo T^. 

• E is nof an anonymous function and is a better conversion target than (§7.5.3.5). 

• E is an anonymous fimction, is either a delegate type or an expression tree t 5 ^e 
Expression<Dj>, is either a delegate t 5 ^e or an expression tree type Expression<D 2 > 
and one of fhe following holds: 

- is a beffer conversion fargef fhan D^. 

- and have identical paramefer lisfs, and one of fhe following holds: 

• has a refurn type Y^, and has a return type Y^, an inferred refum f 5 ^e X exisfs 
for E in fhe confexf of fhaf paramefer lisf (§7.5.2.12), and fhe conversion from X fo 
Y^ is beffer fhan fhe conversion from X fo Y^. 

• has a refum type Y, and is void returning. 

7.5.3.4 Better Conversion from Type 

Given a conversion that converts from a fype S fo a type T^, and a conversion that 
converts from a f 5 ^e S fo a f 5 ^e T^, is a better conversion fhan if af leasf one of fhe fol¬ 
lowing holds: 

• An idenfify conversion exisfs from S fo buf nof from S fo T^. 

• is a beffer conversion fargef fhan (§7.5.3.5). 

7.5.3.5 Better Conversion Target 

Given fwo differenf fypes and T^, is a beffer conversion fargef fhan if af leasf one of 
fhe following holds: 

• An implicif conversion from fo exisfs, and no implicif conversion from fo 
exisfs. 

• is a signed infegral t 5 ^e and is an unsigned infegral t 5 ^e. Specifically: 

- is sbyte and is byte, ushort, uint, or along. 

- is short and is ushort, uint, or along. 


274 


www.it-ebooks.info 




7.5 Function Members 


- is int and is uint, or ulong. 

- is long and is ulong. 


7.5.3.6 Overloading in Generic Classes 

While signatures as declared must be unique, it is possible that substitution of type argu¬ 
ments might result in identical signatures. In such cases, the tie-breaking rules of overload 
resolufion above will pick fhe mosf specific member. 


The following examples show overloads fhaf are valid and invalid according fo fhis rule: 


interface I1<T> {...} 
interface I2<T> {...} 

class G1<U> 

{ 

int F1(U u); 
int Fl(int i); 

void F2(I1<U> a); 
void F2(I2<U> a); 


class G2<U,V> 

{ 

void F3(U u, V v); 
void F3(V V, U u); 


// Overload resolution for G<int>.Fl 
// will pick nongeneric 

// Valid overload 


// Valid, but overload resolution for 
// G2<int,int>.F3 will fail 


void F4(U u, I1<V> v); // Valid, but overload resolution for 

void F4(I1<V> V, U u); // G2<Il<int>,int>.F4 will fall 


void F5(U ul, I1<V> v2); // Valid overload 
void F5(V vl, U u2); 


void F6(ref U u); // Valid overload 

void F6(out V v); 


7.5.4 Compile-Time Checking of Dynamic Overload Resolution 

For mosf d 5 mamically bound operafions, fhe sef of possible candidafes for resolufion is 
unknown af compile fime. In cerfain cases, however, fhe candidafe sef is known af com¬ 
pile fime: 

• Sfatic mefhod calls wifh dynamic argumenfs. 

• Insfance mefhod calls where fhe receiver is nof a dynamic expression. 

• Indexer calls where fhe receiver is nof a dynamic expression. 

• Consfrucfor calls wifh dynamic argumenfs. 




275 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


In these cases, a limited compile-time check is performed for each candidafe fo see if any 
of fhem could possibly apply af runfime. This check consisfs of fhe following sfeps: 

• Parfial f 5 ^e inference: Any type argument that does not depend directly or indirectly on 
an argument of t 5 ^e dynamic is inferred using fhe rules of §7.5.2. The remaining type 
arguments are unknown. 

• Partial applicability check: Applicability is checked according to §7.5.3.1, but ignoring 
parameters whose types are unknown. 

If no candidafe passes fhis fesf, a compile-fime error occurs. 

7.5.5 Function Member Invocation 

This secfion describes fhe process fhaf fakes place af runfime fo invoke a parficular func¬ 
tion member. If is assumed fhaf a binding-time process has already defermined fhe parficu¬ 
lar member fo invoke, possibly by applying overload resolution fo a sef of candidafe 
function members. 

For purposes of describing fhe invocafion process, function members are divided info fwo 
cafegories: 

• Sfafic function members. These are insfance consfrucfors, sfafic mefhods, sfafic properfy 
accessors, and user-defined operators. Sfafic function members are always nonvirfual. 

• Insfance funcfion members. These are insfance mefhods, insfance properfy accessors, 
and indexer accessors. Insfance fimcfion members are eifher nonvirfual or virfual, and 
are always invoked on a parficular insfance. The insfance is compufed by an insfance 
expression, and if becomes accessible wifhin fhe funcfion member as this (§7.6.7). 

The runfime processing of a funcfion member invocafion consisfs of fhe following sfeps, 
where M is fhe funcfion member and, if M is an insfance member, E is fhe insfance 
expression: 

• If M is a sfafic funcfion member: 

The argumenf lisf is evaluated as described in §7.5.1. 

- M is invoked. 

• If M is an insfance funcfion member declared in a value-type: 

E is evaluated. If fhis evaluation causes an exception, then no further steps are 
executed. 

- If E is nof classified as a variable, fhen a temporary local variable of E's type is created 
and the value of E is assigned fo fhaf variable. E is fhen reclassified as a reference fo 
fhaf femporary local variable. The femporary variable is accessible as this wifhin M, 


276 


www.it-ebooks.info 




7.5 Function Members 


but not in any other way. Thus, only when E is a true variable is it possible for the 
caller to observe the changes that M makes to this. 


“ ERIC LI PPERT This point illustrates yet another way in which the combination of 
mufabilify and copy-by-value semantics can lead fo frouble. For example, a readonly 
field is nof classified as a variable affer fhe consfrucfor runs. Therefore, an affempf fo 
call a mefhod fhaf mufafes fhe confenfs of a readonly field of value f 5 ^e succeeds buf 
acfually mufafes a copy! Avoid fhese problems by avoiding mufable value fypes 
alfogefher. 


- The argumenf lisf is evaluafed as described in §7.5.1. 

- M is invoked. The variable referenced by E becomes fhe variable referenced by this. 

• If M is an insfance funcfion member declared in a reference-type: 

- E is evaluafed. If fhis evaluation causes an exception, fhen no furfher sfeps are 
execufed. 

- The argumenf lisf is evaluafed as described in §7.5.1. 

- If fhe type of E is a value-type, a boxing conversion (§4.3.1) is performed fo converf E 
fo fype object, and E is considered fo be of t 5 ^e object in fhe following sfeps. In fhis 
case, M could only be a member of System. Object. 

- The value of E is checked fo see if if is valid. If fhe value of E is null, a System. 
NullRef erenceException is fhrown and no furfher sfeps are execufed. 

- The funcfion member implemenfafion fo invoke is defermined: 

• If fhe binding-fime t 5 ^e of E is an inferface, fhe funcfion member fo invoke is fhe 
implemenfafion of M provided by fhe runtime type of fhe insfance referenced by E. 
This funcfion member is defermined by applying fhe inferface mapping rules 
(§13.4.4) fo defermine fhe implemenfafion of M provided by fhe runtime type of fhe 
insfance referenced by E. 

• Ofherwise, if M is a virfual funcfion member, fhe funcfion member fo invoke is fhe 
implemenfafion of M provided by fhe runtime type of fhe insfance referenced by E. 
This funcfion member is defermined by applying fhe rules for defermining fhe 
mosf derived implemenfafion (§10.6.3) of M wifh respecf fo fhe runtime type of fhe 
insfance referenced by E. 

• Ofherwise, M is a nonvirfual funcfion member, and fhe funcfion member fo invoke 
is M ifself. 

• The funcfion member implemenfafion defermined in fhe sfep above is invoked. The 

objecf referenced by E becomes fhe objecf referenced by this. 




277 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


7.5.5.1 Invocations on Boxed Instances 

A function member implemented in a value-type can be invoked through a boxed instance 
of that value-type in the following situations: 

• When the function member is an override of a method inherited from type object and 
is invoked through an instance expression of t 5 ^e object. 

• When the function member is an implementation of an interface function member and 
is invoked through an instance expression of an interface-type. 

• When the function member is invoked through a delegate. 

In these situations, the boxed instance is considered to contain a variable of the value-type, 
and this variable becomes the variable referenced by this within the function member 
invocation. In particular, when a function member is invoked on a boxed instance, it is pos¬ 
sible for the function member to modify the value contained in the boxed instance. 


7.6 Primary Expressions 

Primary expressions include the simplest forms of expressions. 

primary-expression: 

primary-no-array-creation-expression 

array-creation-expression 

primary-no-array-creation-expression: 

literal 

simple-name 

parenthesized-expression 

member-access 

invocation-expression 

element-access 

this-access 

base-access 

post-increment-expression 

post-decrement-expression 

object-creation-expression 

delegate-creation-expression 

anonymous-object-creation-expression 

typeof-express ion 

checked-expression 

unchecked-express ion 

default-value-expression 

anonymous-method-expression 


278 


www.it-ebooks.info 




7.6 Primary Expressions 


Primary expressions are divided between array-creation-expressions and primary-no-array- 
creation-expressions. Treating array-creation-expression in this way, rather than listing it along 
with the other simple expression forms, enables the grammar to disallow potentially con¬ 
fusing code such as 

object o = new int[3][l]; 

which would otherwise be interpreted as 
object o = (new int[3])[l]; 


7.6.1 Literals 

Aprimary-expression that consists of a literal (§2.4.4) is classified as a value. 

7.6.2 Simple Names 

A simple-name consists of an identifier, optionally followed by a t 5 y)e argument list: 
simple-name: 

identifier type-argument-list 

Asimple-name is either of fhe form I or of fhe form I<Aj, ..., A^>, where I is a single identifier 

and <A^, ..., A^> is an optional type-argument-list. When no type-argument-list is specified, 

consider K to be zero. The simple-name is evaluated and classified as follows: 

• If K is zero and fhe simple-name appears wifhin a block, and if the block's (or an enclosing 
block's) local variable declaration space (§3.3) contains a local variable, parameter, or 
constant with name I, then the simple-name refers to that local variable, parameter, 
or constant and is classified as a variable or value. 


"■ VLADIMIR RESHETNIKOV This rule also applies if fhe simple-name appears 
wifhin a constructor-initializer and matches a name of the containing constructor's 
parameter. 




• If K is zero and the simple-name appears within the body of a generic mefhod declaration 
and if that declaration includes a type parameter with name I, then the simple-name 
refers to that t 5 y)e parameter. 


“■ VLADIMIR RESHETNIKOV This condition always leads to a compile-time error 
later. 


279 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


• Otherwise, for each instance type T (§10.3.1), starting with the instance type of the imme¬ 
diately enclosing type declaration and continuing with the instance type of each enclos¬ 
ing class or struct declaration (if any): 

- If K is zero and the declaration of T includes a type parameter with name I, then the 
simple-name refers to that type parameter. 


"■ VLADIMIR RESHETNIKOV This condition always leads to a compile-time error 
later. 


- Otherwise, if a member lookup (§7.4) of I in T with K type arguments produces a 

match: 

• If T is the instance type of the immediately enclosing class or struct t 5 ^e and the 
lookup identifies one or more methods, the result is a method group with an asso¬ 
ciated instance expression of this. If a t 5 ^e argument list was specified, it is used 
in calling a generic method (§7.6.5.1). 

• Otherwise, if T is the instance type of the immediately enclosing class or struct 
type, if the lookup identifies an instance member, and if the reference occurs within 
the block of an instance constructor, an instance method, or an instance accessor, the 
result is the same as a member access (§7.6.4) of the form this. I. This can only 
happen when K is zero. 

• Otherwise, the result is the same as a member access (§7.6.4) of the form T. I or 
T. I<Ajj ..., A^>. In this case, it is a binding-time error for the simple-name to refer to 
an instance member. 

• Otherwise, for each namespace N, starting with the namespace in which the simple-name 
occurs, continuing with each enclosing namespace (if any), and ending with the global 
namespace, the following steps are evaluated until an entity is located: 

- If K is zero and I is the name of a namespace in N, then: 

• If the location where the simple-name occurs is enclosed by a namespace declaration 
for N and the namespace declaration contains an extern-alias-directive or using-alias- 
directive that associates the name I with a namespace or t 5 ^e, then the simple-name 
is ambiguous and a compile-time error occurs. 

• Otherwise, the simple-name refers to the namespace named I in N. 


280 


www.it-ebooks.info 






7.6 Primary Expressions 


- Otherwise, if N contains an accessible t 5 ^e having name I and K type parameters, 

then: 

• If K is zero and the location where the simple-name occurs is enclosed by a namespace 
declaration for N and the namespace declaration contains an extern-alias-directive or 
using-alias-directive that associates the name I with a namespace or type, then the 
simple-name is ambiguous and a compile-time error occurs. 

• Otherwise, the namespace-or-type-name refers to the type constructed with the given 
type arguments. 

- Otherwise, if the location where the simple-name occurs is enclosed by a namespace 

declaration for N: 

• If K is zero and the namespace declaration contains an extern-alias-directive or using- 
alias-directive that associates the name I with an imported namespace or type, then 
the simple-name refers to that namespace or t 5 ^e. 

• Otherwise, if the namespaces imported by the using-namespace-directives of the 
namespace declaration contain exactly one type having name I and K type param¬ 
eters, then the simple-name refers to that type constructed with the given type 
arguments. 

• Otherwise, if the namespaces imported by the using-namespace-directives of the 
namespace declaration contain more than one t 5 ^e having name I and K type 
parameters, then the simple-name is ambiguous and an error occurs. 

Note that this entire step is exactly parallel to the corresponding step in the processing of 
a namespace-or-type-name (§3.8). 

• Otherwise, the simple-name is undefined and a compile-time error occurs. 

7.6.2.1 Invariartt Meaning in Blocks 

For each occurrence of a given identifier as a simple-name in an expression or declarator, 
within the local variable declaration space (§3.3) immediately enclosing that occurrence, 
every other occurrence of the same identifier as a simple-name in an expression or declara¬ 
tor must refer to the same entity. This rule ensures that the meaning of a name is always the 
same within a given block, switch block, for statement, for each statement, using- 
statement, or anonymous function. 




“■ ERIC LIPPERT One of the more subtle desirable consequences of this rule is that 
it becomes safer to undertake refactorings that involve moving around local variable 
declarations. Any such refactoring that would cause a simple name to change its 
semantics will be caught by the compiler. 


281 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


The example 

class Test 
{ 

double x; 

void F(bool b) { 

X = 1.0; 
if (b) { 
int x; 

X = l; 

} 

} 

} 

results in a compile-time error because x refers to different entities within the outer block 
(the extent of which includes the nested block in the if statement). In contrast, the 
example 

class Test 
{ 

double x; 

void F(bool b) { 
if (b) { 

X = 1.0; 

} 

else { 

int x; 

X = l; 

} 

} 

} 

is permitted because the name x is never used in the outer block. 

Note that the rule of invariant meaning applies only to simple names. It is perfectly valid 
for the same identifier fo have one meaning as a simple name and anofher meaning as the 
right operand of a member access (§7.6.4). For example: 

struct Point 
{ 

int X, y; 

public Point(int x, int y) { 
this.x = x; 
this.y = y; 

} 

} 


282 


www.it-ebooks.info 




7.6 Primary Expressions 


The example above illustrates a common pattern of using the names of fields as paramefer 
names in an insfance construcfor. In fhe example, fhe simple names x and y refer fo fhe 
paramefers, buf fhaf does nof prevenf fhe member access expressions this .x and this .y 
from accessing the fields. 

7.6.3 Parenthesized Expressions 

Aparenthesized-expression consisfs of an expression enclosed in parenfheses. 

parenthesized-expression: 

( expression ) 

Aparenthesized-expression is evaluafed by evaluating fhe expression wifhin fhe parenfheses. 
If fhe expression wifhin fhe parenfheses denofes a namespace or fype, a compile-fime error 
occurs. Ofherwise, fhe resulf of fhe parenthesized-expression is fhe resulf of fhe evaluafion of 
fhe confained expression. 

7.6 A Member Access 

A member-access consisfs of a primary-expression, a predefined-type, or a qualified-alias- 
member, followed by a "." foken, followed by an identifier, optionally followed by a type- 
argument-list. 

member-access: 

primary-expression . identifier type-argument-list 
predefined-type . identifier type-argument-list 
qualified-alias-member . identifier type-argument-list 

predefined-type: one of 

bool byte char decimal double float int long 

object sbyte short string uint ulong ushort 

The qualified-alias-member production is defined in §9.7. 

A member-access is eifher of the form E.I or of fhe form E.IcA^, ..., A|^>, where E is a 
primary-expression, I is a single identifier, and ..., A^> is an optional type-argument-list. 
When no type-argument-list is specified, consider K fo be zero. 

A member-access wifh a primary-expression of type dynamic is d 5 mamically bound (§7.2.2). In 
this case the compiler classifies fhe member access as a properfy access of type dynamic. 
The rules below to determine the meaning of fhe member-access are fhen applied af runtime, 
using fhe runfime t 5 ^e insfead of fhe compile-fime type of fhe primary-expression. If fhis 
runtime classificafion leads fo a mefhod group, fhen fhe member access musf be fhe 
primary-expression of an invocation-expression. 




283 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


The member-access is evaluated and classified as follows: 

• If K is zero, E is a namespace, and E confains a nesfed namespace wifh name I, fhen fhe 
resulf is fhaf namespace. 

• Ofherwise, if E is a namespace and E confains an accessible 15^*6 having name I and 
K fype paramefers, fhen fhe resulf is fhaf fype consfrucfed wifh fhe given fype 
argumenfs. 

• If E is a predefined-type or a primary-expression classified as a fype, if E is nof a f 5 ^e param- 
efer, and if a member lookup (§7.4) of I in E wifh K fype paramefers produces a mafch, 
fhen E. I is evaluafed and classified as follows: 

- If I idenfifies a fype, fhen fhe resulf is fhaf fype consfrucfed wifh fhe given fype 
argumenfs. 

- If I idenfifies one or more mefhods, fhen fhe resulf is a mefhod group wifh no associ- 
afed insfance expression. If a f}^’^ argumenf lisf was specified, if is used in calling a 
generic mefhod (§7.6.5.1). 

- If I idenfifies a static properfy fhen fhe resulf is a properfy access wifh no associ¬ 
ated instance expression. 

- If I idenfifies a static field: 

• If fhe field is readonly and fhe reference occurs oufside fhe sfafic consfrucfor of fhe 
class or sfrucf in which fhe field is declared, fhen fhe resulf is a value—namely, fhe 
value of fhe sfafic field I in E. 

• Ofherwise, fhe resulf is a variable—namely, fhe sfafic field I in E. 

- If I idenfifies a static evenf: 

• If fhe reference occurs wifhin fhe class or sfrucf in which fhe evenf is declared, and 
fhe evenf was declared wifhouf event-accessor-declarations (§10.8), fhen E. I is pro¬ 
cessed exacfly as if I were a sfafic field. 

• Ofherwise, fhe resulf is an evenf access wifh no associafed insfance expression. 

- If I idenfifies a consfanf, fhen fhe resulf is a value—namely, fhe value of fhaf 
consfanf. 

- If I idenfifies an enumerafion member, fhen fhe resulf is a value—namely, fhe value 
of fhaf enumerafion member. 

- Ofherwise, E. I is an invalid member reference, and a compile-fime error occurs. 


284 


www.it-ebooks.info 




7.6 Primary Expressions 


• If E is a property access, indexer access, variable, or value, the type of which is T, and a 
member lookup (§7.4) of I in T with K type arguments produces a match, then E. I is 
evaluated and classified as follows: 

- First, if E is a property or indexer access, then the value of the property or indexer 
access is obtained (§7.1.1) and E is reclassified as a value. 

- If I identifies one or more methods, then the result is a method group with an associ¬ 
ated instance expression of E. If a 1)^0 argument list was specified, it is used in calling 
a generic method (§7.6.5.1). 

- If I identifies an instance property, then the result is a property access with an associ¬ 
ated instance expression of E. 

- If T is a class-type and I identifies an instance field of that class-type: 

• If the value of E is null, then a System. NullReferenceException is thrown. 

• Otherwise, if the field is readonly and the reference occurs outside an instance 
constructor of the class in which the field is declared, then the result is a value— 
namely, the value of the field I in the object referenced by E. 

• Otherwise, the result is a variable—namely, the field I in the object referenced 
by E. 

- If T is a struct-type and I identifies an instance field of that struct-type: 

• If E is a value, or if the field is readonly and the reference occurs outside an instance 
constructor of the struct in which the field is declared, then the result is a value— 
namely, the value of the field I in the struct instance given by E. 

• Otherwise, the result is a variable—^namely, the field I in the struct instance given 
by E. 

- If I identifies an instance event: 

• If the reference occurs within the class or struct in which the event is declared, and 
the event was declared without event-accessor-declarations (§10.8), and the reference 
does not occur as the left-hand side of a += or -= operator, then E. I is processed 
exactly as if I was an instance field. 

• Otherwise, the result is an event access with an associated instance expression 
of E. 

• Otherwise, an attempt is made to process E. I as an extension method invocation 
(§7.6.5.2). If this fails, E.I is an invalid member reference, and a binding-time error 
occurs. 




285 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


“■ PETER SESTOFT The two bulleted points stating "if the field is readonly ... fhen 
fhe resulf is a value" have a slighfly surprising effecf when fhe field has sfrucf type, 
and that struct has a mutable field (not a recommended combination—see other armo- 
tations on this point). Consider the following example: 

struct S { 

public int x; 

public void SetX() { x = 2; } 

} 

class C { 

static S s; 

public static void M() { s.SetX(); } 

} 

As expecfed, affer fhe call s. SetX() fhe sfrucf's field s. x will have fhe value 2. Now 
if we add a readonly modifier fo fhe declarafion of field s, fhen suddenly fhe call 
s. SetX( ) has no effecf! Thaf is, s in fhe mefhod call is now a value, nof a variable, 
per fhe rules given earlier; fherefore SetX( ) is execufed on a copy of field s, nof on 
field s ifself. Somewhaf sfrangely, if insfead s were a local variable of sfrucf type 
declared in a using statement (§8.13), which also has the effect of making s immu- 
fable, fhen s . SetX( ) updafes s . x as expecfed. 


7.6.4.1 Identical Simple Names and Type Names 

In a member access of fhe form E. I, if E is a single idenfifier, and if fhe meaning of E as a 
simple-name (§7.6.2) is a consfanf, field, properly, local variable, or paramefer wifh fhe same 
f 5 ^e as fhe meaning of E as a type-name (§3.8), fhen bofh possible meanings of E are permif- 
fed. The fwo possible meanings of E. I are never ambiguous, since I musf necessarily be a 
member of fhe type E in both cases. In other words, the rule simply permits access to the 
static members and nested types of E where a compile-fime error would ofherwise have 
occurred. For example: 

struct Color 
{ 

public static readonly Color White = new Color(...); 
public static readonly Color Black = new Color(...); 

public Color Complement() {...} 

} 

class A 
{ 

public Color Color; // Field Color of type Color 

void F() { 

Color = Color .Black: // References Color.Black static member 


286 


www.it-ebooks.info 








7.6 Primary Expressions 


Color = Color.ComplementO; // Invokes Complement() on Color field 

} 

static void G() { 

Color c = Color .White; // References Color.White static member 

} 

} 

Within the A class, those occurrences of the Color identifier fhaf reference fhe Color f 5 ^e 
are underlined, and fhose fhaf reference fhe Color field are nof underlined. 


7.6.4.2 Grammar Ambiguities 

The producfions for simple-name (§7.6.2) and member-access (§7.6.4) can give rise fo ambi- 
guifies in fhe grammar for expressions. For example, fhe sfafemenf 

F(G<A,B>(7)); 

could be inferprefed as a call fo F wifh fwo argumenfs, G < A and B > ( 7 ). Alfernafively, 
if could be inferprefed as a call fo F wifh one argumenf, which is a call fo a generic mefhod G 
wifh fwo fype argumenfs and one regular argumenf. 

If a sequence of tokens can be parsed (in confexf) as a simple-name (§7.6.2), member-access 
(§7.6.4), or pointer-member-access (§18.5.2) ending wifh a type-argument-list (§4.4.1), fhe token 
immediafely following fhe closing > foken is examined. If if is one of 

then the type-argument-list is retained as part of fhe simple-name, member-access, or pointer- 
member-access, and any ofher possible parse of fhe sequence of tokens is discarded. Ofher- 
wise, fhe type-argument-list is nof considered fo be parf of fhe simple-name, member-access, or 
pointer-member-access, even if fhere is no ofher possible parsing of fhe sequence of tokens. 
Nofe fhaf fhese rules are nof applied when parsing a type-argument-list in a namespace-or- 
type-name (§3.8). The sfafemenf 

F(G<A,B>(7)); 

will, according fo fhis rule, be inferprefed as a call fo F wifh one argumenf, which is a call 
fo a generic mefhod G wifh fwo fype argumenfs and one regular argumenf. The 
sfafemenfs 

F(G < A, B > 7 ); 

F(G < A, B >> 7); 

will each be inferprefed as a call fo F wifh fwo argumenfs. 




287 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


The statement 

X = F < A > +y; 

will be interpreted as including a less than operator, greater than operator, and unary plus 
operator, as if the statement had been written x = (F < A) > (+y), instead of as a simple-name 
with a type-argument-list followed by a binary plus operator. In the statement 

X = y is C<T> + z; 

the tokens C<T> are interpreted as a namespace-or-type-name with a type-argument-list. 

7.6.5 Invocation Expressions 

An invocation-expression is used to invoke a method. 

invocation-expression: 

primary-expression ( argument-list ) 

An invocation-expression is dynamically boimd (§7.2.2) if at least one of fhe following holds: 

• The primary-expression has compile-time t 5 ^e dynamic. 

• At least one argument of the optional argument-list has compile-time type dynamic and 
the primary-expression does not have a delegate t 5 ^e. 


“■ VLADIMIR RESHETNIKOV One exception to this rule: ref/out arguments of 
type dynamic do not cause d 5 mamic binding. 

If an invocation-expression is dynamically bound and ifs primary-expression denotes a 
method group that resulted from a base-access, fhen a compile-time error (CS1971) 
occurs. 


In this case the compiler classifies the invocation-expression as a value of f 5 ^e dynamic. The 
rules below to determine the meaning of the invocation-expression are then applied at run¬ 
time, using the runtime type instead of fhe compile-fime type of fhose of fhe primary- 
expression and argumenfs fhaf have fhe compile-time type dynamic. If the primary-expression 
does not have compile-time t 5 ^e dynamic, then the method invocation undergoes a limited 
compile-time check as described in §7.5.4. 

The primary-expression of an invocation-expression must be a method group or a value of a 
delegate-type. If the primary-expression is a method group, the invocation-expression is a 
method invocation (§7.6.5.1). If fhe primary-expression is a value of a delegate-type, fhe 
invocation-expression is a delegafe invocation (§7.6.5.3). If fhe primary-expression is neither a 
method group nor a value of a delegate-type, a binding-time error occurs. 


288 


www.it-ebooks.info 






7.6 Primary Expressions 


The optional argument-list (§7.5.1) provides values or variable references for fhe paramefers 

of fhe mefhod. 

The resulf of evaluafing an invocation-expression is classified as follows: 

• If fhe invocation-expression invokes a mefhod or delegafe fhaf refums void, fhe resulf is 
nofhing. An expression fhaf is classified as nofhing is permiffed only in fhe confexf of a 
statement-expression (§8.6) or as fhe body of a lambda-expression (§7.15). Ofherwise, a bind- 
ing-fime error occurs. 

• Ofherwise, fhe resulf is a value of fhe type returned by the method or delegate. 


7.6.5.1 Method Invocations 

For a method invocation, the primary-expression of fhe invocation-expression musf be a 
mefhod group. The mefhod group idenfifies fhe one mefhod fo invoke or fhe sef of over¬ 
loaded mefhods from which fo choose a specific mefhod fo invoke. In fhe laffer case, defer- 
minafion of fhe specific mefhod fo invoke is based on fhe confexf provided by fhe fypes of 
fhe argumenfs in fhe argument-list. 

The binding-fime processing of a mefhod invocation of fhe form M(A), where M is a mefhod 
group (possibly including a type-argument-list) and A is an opfional argument-list, consisfs 
of fhe following sfeps: 

• The sef of candidafe mefhods for fhe mefhod invocation is consfrucfed. For each mefhod 
F associafed wifh fhe mefhod group M: 

- If F is nongeneric, F is a candidafe when: 

• M has no 1)^0 argumenf lisf, and 

• F is applicable wifh respecf fo A (§7.5.3.1). 

- If F is generic and M has no f 5 ^e argumenf lisf, F is a candidafe when: 

• T 5 ^e inference (§7.5.2) succeeds, inferring a lisf of f 5 ^e argumenfs for fhe call, and 

• Once fhe inferred t 5 ^e argumenfs are subsfifufed for fhe corresponding mefhod 
fype paramefers, all consfrucfed fypes in fhe paramefer lisf of F satisfy fheir con- 
sfrainfs (§4.4.4), and fhe paramefer lisf of F is applicable wifh respecf fo A 
(§7.5.3.1). 




"■ VLADIMIR RESHETNIKOV Nofe fhaf only consfrainfs on consfrucfed fypes 
appearing in the parameter list are checked during this step. Constraints on the generic 
method itself are checked lafer, during fhe final validation. 


289 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


- If F is generic and M includes a t 5 ^e argument list, F is a candidate when: 

• F has the same number of method type parameters as were supplied in the type 
argument list, and 

• Once the type arguments are substituted for the corresponding method type 
parameters, all constructed t 5 ^es in the parameter list of F satisfy their constraints 
(§4.4.4), and the parameter list of F is applicable with respect to A (§7.5.3.1). 

• The set of candidate methods is reduced to contain only methods from the most derived 
types: For each method C. F in the set, where C is the type in which the method F is 
declared, all methods declared in a base type of C are removed from the set. Further¬ 
more, if C is a class t 5 ^e other than object, all methods declared in an interface t 5 ^e are 
removed from the set. (This latter rule takes effect only when the method group was the 
result of a member lookup on a 1)^0 parameter having an effective base class other than 
object and a non-empty effective interface set.) 


“■ VLADIMIR RESHETNIKOV This rule implies that an applicable method from the 
most derived type is selected, even if a method with better parameter t 5 ^es exists in a 
base t 5 ^e, and even if the selected method from the most derived t 5 ^e will not pass 
the final validation. Also remember that all overrides were removed before this step, 
during member lookup (§7.4). 

class Base 
{ 

public virtual void Foo(int x) { } 

} 

class Derived : Base 
{ 

public override void Foo(int x) { } 

static void Foo(object x) { } 

static void Main() 

{ 

var d = new Derived(); 
d.Foo(l); 

// Error CS0176: Member ’Derived.Foo(object)' 

// cannot be accessed with an instance reference; 

// qualify it with a type name instead 

} 

} 


• If the resulting set of candidate methods is empty, then further processing along the fol¬ 
lowing steps are abandoned, and instead an attempt is made to process the invocation 
as an extension method invocation (§7.6.5.2). If this fails, then no applicable methods 
exist, and a binding-time error occurs. 


290 


www.it-ebooks.info 






7.6 Primary Expressions 


• The best method of the set of candidafe mefhods is idenfified using fhe overload resolu- 
fion rules of §7.5.3. If a single besf mefhod carmof be identified, fhe mefhod invocafion 
is ambiguous, and a binding-fime error occurs. When performing overload resolufion, 
fhe paramefers of a generic mefhod are considered affer subsfifufing fhe fype argumenfs 
(supplied or inferred) for fhe corresponding mefhod type parameters. 

• Final validation of fhe chosen besf mefhod is performed: 

- The mefhod is validafed in fhe confexf of fhe mefhod group: If fhe besf mefhod is a 
sfafic mefhod, fhe mefhod group musf have resulfed from a simple-name or a member- 
access through a type. If fhe besf mefhod is an insfance mefhod, fhe mefhod group 
musf have resulfed from a simple-name, a member-access fhrough a variable or value, 
or a base-access. If neifher of fhese requiremenfs is frue, a binding-fime error occurs. 


"■ VLADIMIR RESHETNIKOV If fhe besf mefhod is an insfance mefhod, and fhe 
mefhod group has resulfed from a simple-name, fhen fhe simple-name musf nof appear 
in a sfafic confexf (i.e., in sfafic members, nesfed f 5 q)es, insfance fields, or field-like 
even! initializers or constructor-initializers)-, ofherwise, a binding-fime error occurs. 


- If fhe besf mefhod is a generic mefhod, fhe t 5 q)e argumenfs (supplied or inferred) are 
checked againsf fhe consfrainfs (§4.4.4) declared on fhe generic mefhod. If any fype 
argumenf does nof safisfy fhe corresponding consfrainf(s) on fhe f 5 q)e paramefer, a 
binding-fime error occurs. 


“■ VLADIMIR RESHETNIKOV If fhis check succeeds, if automatically guarantees 
fhaf all consfrainfs on all consfrucfed fypes in fhe refurn fype and fhe body of fhe 
mefhod are also satisfied. 


ERIC LIPPERT The rule described above has provoked much debate: Why does 
fhe compiler go fhrough all fhe work of 1)^)0 inference, overload resolufion, and elimi¬ 
nation of inapplicable candidafes, only fo fhen say, "Tve chosen a mefhod fhaf doesn'f 
work affer all"? Why nof simply say fhaf mefhods fhaf don'f safisfy fheir consfrainfs 
are nof even candidafes? The reason is subfle buf imporfanf: A fundamenfal design 
principle of C# is fhaf fhe language does nof second-guess fhe user. If fhe besf possible 
choice implied by fhe argumenfs and paramefer f 5 q)es is invalid, fhen eifher fhe user 
intended fhe besf choice fo be used buf made some sorf of misfake, or fhe user intended 
fhe compiler fo choose somefhing else. The safes! fhing fo do is assume fhe former, 
rather than possibly guessing wrong. 


291 


www.it-ebooks.info 


Expressions 










Expressions 


7. Expressions 


Once a method has been selected and validated at binding time by the above steps, the 
actual runtime invocation is processed according to the rules of function member invoca¬ 
tion described in §7.5.4. 


“■ BILL WAGNER The following paragraph is key: Exfension mefhods cannof 
replace behavior defined by a t 5 ^e aufhor. 


The intuitive effect of the resolution rules described above is as follows: To locale fhe par¬ 
ticular method invoked by a method invocation, start with the type indicated by the 
method invocation and proceed up the inheritance chain until at least one applicable, 
accessible, non-override method declaration is found. Then perform type inference and 
overload resolution on the set of applicable, accessible, non-override methods declared in 
that t 5 ^e and invoke the method thus selected. If no method is found, try instead to pro¬ 
cess the invocation as an extension method invocation. 


"■ ERIC LI PPERT Under this design, even if a "better" mefhod mighf be found in a 
base class, any applicable method in a derived class gets priority. The reasoning for 
fhis design is fwofold. 

Firsf, the implementers of the derived class presumably have better information about 
the desired semantics of this operation on their class than the implementers of fhe base 
class did; fhe derived class exists because it added some functionality or specialization 
to the base class. 

Second, this design avoids one of the "brittle base class" family of problems. Suppose 
you have code thaf relies on a call to a method in a derived class. If overload resolution 
is choosing that method today, then a change to the base class tomorrow should not 
cause overload resolution to silently and suddenly start choosing the base class 
method upon recompilation. 

Of course, fhis scheme also infroduces fhe opposife scenario: If you depend on over¬ 
load resolution to choose a method of fhe base class, fhen someone who adds a method 
to a more derived class can silently change the choice overload resolution upon recom¬ 
pilation as well. However, this "brittle derived class" problem is rarely an issue in real 
production code; most of fhe fime, you wanf fhe more derived method chosen for fhe 
reasons given above. 


292 


www.it-ebooks.info 








7.6 Primary Expressions 


■■ JONSKEET While I follow Eric's reasoning for fhe mosf parf, fhis design permifs 
an unforfunafe sifuafion fo occur. If a derived class infroduces a new overload of a 
base class mefhod and overrides the base class method, fhen clearly fhaf derived class is 
aware of fhe base class mefhod—and yef fhaf override is sfill nof considered when 
selecting fhe mefhod, until fhe algorifhm reaches fhe base class. For example, consider 
fhe following mefhods in a derived class, wifh a base class declaring fhe obvious vir- 
fual mefhod: 

public void Foo(object x) { ... } 

public override void Foo(int y) { ... } 

A call fo Foo(10) on an expression of fhe derived 15^36 will pick fhe firsf mefhod— 
confrary fo fhe expecfafions of every non-Microsoff developer I've ever presenfed fhis 
design fo. 


7.6.5.2 Extension Method Invocations 

In a mefhod invocafion (§7.5.5.1) of one of fhe forms 


expr . identifier ( 
expr . identifier ( 
expr . identifier < 
expr . identifier < 


) 

args ) 

typeargs 

typeargs 


> 

> 


( ) 

( args ) 


if fhe normal processing of fhe invocafion finds no applicable mefhods, an affempf is made 
fo process fhe consfrucf as an exfension mefhod invocafion. If expr or any of fhe args has 
compile-fime type dynamic, extension methods will not apply. 


“■ VLADIMIR RESHETNIKOV The last rule does not apply to ref/out arguments of 
type dynamic. 


The objective is to find the best type-name C, so that the corresponding static method invo¬ 
cation can take place: 


C . identifier ( expr ) 

C . identifier ( expr , args ) 

C . identifier < typeargs > ( expr ) 

C . identifier < typeargs > ( expr , args ) 




293 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


An extension method C.. is eligible if: 

• C. is a nongeneric, non-nested class. 

• The name of is identifier. 

• M. is accessible and applicable when applied fo fhe argumenfs as a sfafic mefhod as 
shown above. 

• An implicif idenfify, reference, or boxing conversion exisfs from expr fo fhe type of fhe 
firsf paramefer of M^. 


“■ ERIC LIPPERT This rule ensures fhaf making a mefhod fhaf exfends double does 
nof also exfend int. If also ensures fhaf no exfension mefhods are defined on anony¬ 
mous funcfions or mefhod groups. 


The search for C proceeds as follows: 

• Sfarfing wifh fhe closesf enclosing namespace declarafion, confinuing wifh each enclos¬ 
ing namespace declarafion, and ending wifh fhe confaining compilation unif, successive 
affempfs are made fo find a candidafe sef of exfension mefhods: 

- If fhe given namespace or compilation unif direcfly confains nongeneric f 5 ^e declara- 
fions C. wifh eligible exfension mefhods M^, fhen fhe sef of fhose exfension mefhods is 
fhe candidafe sef. 

- If namespaces imporfed by using namespace direcfives in fhe given namespace or 
compilafion unif direcfly confain nongeneric type declarations C. with eligible exten¬ 
sion methods M., then the set of fhose exfension mefhods is fhe candidafe sef. 

• If no candidafe sef is found in any enclosing namespace declarafion or compilafion unif, 
a compile-fime error occurs. 

• Ofherwise, overload resolution is applied fo fhe candidafe sef as described in (§7.5.3). If 
no single besf mefhod is found, a compile-fime error occurs. 

• C is fhe t 5 ^e wifhin which fhe besf mefhod is declared as an exfension mefhod. 

Using C as a fargef, fhe mefhod call is fhen processed as a sfafic mefhod invocation 

(§7.5.4). 


“■ BILL WAGNER This processing is somewhaf complicafed, and if reinforces fhe 
recommendation fhaf you should nof creafe duplicafe exfension mefhods in differenf 
namespaces. 


294 


www.it-ebooks.info 








7.6 Primary Expressions 


■■ PETER SESTOFT It is tempting to think of an extension method as just a funny 
sorf of nonvirfual insfance mefhod fhaf is called only when no suifable ordinary 
insfance mefhod is available. Unforfunafely, an exfension mefhod SetXfthis S s) on 
a sfrucf type S is not quite the same as an instance method on S, because the call 
s. SetX( ) will be transformed fo fhe call SetX( s ) fhaf passes sfrucf s by value, hence 
copying if. Any side effecf will happen on fhe copy, nof on fhe original sfrucf s —yef 
anofher reason never fo have mufable fields in sfrucf f 5 q)es. 


■■ JONSKEET One of fhe issues wifh exfension mefhods is jusf how easy if is fo 
accidenfally imporf more fhan you expecf or wanf. I would prefer fhis process fo be 
more explicif, such as wifh a new f5q3e of using direcfive: 

using static System.Linq.Enumerable; 

This would allow class libraries fo expose exfension mefhods wifhouf adding fo 
InfelliSense confusion for users who didn'f wanf fo use fhem. Addifionally if would 
provide a nofe fo code mainfainers warning fhem fhaf fhey should expecf fo see cer- 
fain exfension mefhods used wifhin fhis compilation unif. 


The preceding rules mean fhaf insfance mefhods fake precedence over exfension mefhods, 
fhaf exfension mefhods available in inner namespace declarafions fake precedence over 
exfension mefhods available in oufer namespace declarafions, and fhaf exfension mefhods 
declared direcfly in a namespace fake precedence over exfension mefhods imporfed info 
fhaf same namespace wifh a using namespace direcfive. For example: 

public static class E 

{ 

public static void F(this object obj, int i) { } 

public static void F(this object obj, string s) { } 

} 

class A { } 

class B 

{ 

public void F(int i) { } 

} 

class C 

{ 

public void F(object obj) { } 

} 




295 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


class X 

{ 

static void Test(A a, B bj C c) { 

a.F(l); 

a. F("hello"); 

b. F(l); 

b. F("hello"); 

c. F(l); 

c.F("hello"); 

} 

} 

In the example, B's method takes precedence over the first extension method, and C's 
method takes precedence over both extension methods. 

public static class C 

{ 

public static void F(this int i) { 

Console.WriteLine("C.F({0})", i); 

} 

public static void G(this int i) { 

Console.WriteLine("C.G({0})", i); 

} 

public static void Fl(this int i) { 

Console.WriteLine("C.H({0})", i); 

} 

} 

namespace N1 

{ 

public static class D 

{ 

public static void F(this int i) { 

Console .WriteLineC'D. F({0})", i); 

} 

public static void G(this int i) { 

Console .WriteLineC'D.G({0})", i); 

} 

} 


namespace N2 

{ 

using Nl; 

public static class E 

{ 

public static void F(this int i) { 
Console .WriteLineC'E. F({0})", i); 

} 

} 


// E.F(object, int) 

// E.F(object, string) 

// B.F(int) 

// E.F(object, string) 

// C.F(object) 

// C.F(object) 


296 


www.it-ebooks.info 




7.6 Primary Expressions 


class Test 
{ 

static void Main(string[] args) 

{ 

1. F(); 

2. G(); 

3. H(); 

} 

} 

} 

The output of this example is 

E.F(l) 

D.G(2) 

C.H(3) 

D. G takes precedence over C. G, and E. F takes precedence over both D. F and C. F. 


■■ JOSEPH ALBAHARI One reason for insfance mefhods having higher precedence 
fhan exfension mefhods is fo ensure fhaf fhe infroducfion of exfension mefhods info a 
program or framework doesn'f break exisfing code. 


"■ ERIC LIPPERT The way C# looks for exfension mefhods gives rise fo a variafion 
on fhe "briffle derived class" problem menfioned earlier. If you rely on invocation 
processing fo choose an exfension mefhod, buf someone infroduces an idenfically 
named insfance mefhod upon fhe class, fhen fhe exfension mefhod will no longer be 
called upon recompilation. 

This behavior is nof really a problem—if's usually exacfly whaf you wanf. The mefhod 
on fhe class has far more informafion abouf fhe infernal sfrucfure of fhe class fhan fhe 
sfafic exfension mefhod does, so if should be given precedence. 

The Microsoff C# compiler does nof give a warning fhaf an exfension mefhod exisfs 
fhaf would be an alfernafive fo fhe insfance mefhod chosen. If fhe compiler gave such 
a warning, fhere would be no easy way fo "fix" fhe warning ofher fhan by puffing a 
#pragtna direcfive around if fo fum fhe warning off. 




297 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


■■ JONSKEET I think in this case a warning would actually be the most appropriate 
course of action, so as to alert developers to the possibility that a method with the 
same name but a different meaning would now be called with no changes (beyond 
recompilation) of clienf code. In many cases—^where fhe whole codebase relying on an 
exfension mefhod can be recompiled, so binary compafibilify is nof required—fhe 
mefhod could be removed enfirely or renamed. In ofher cases if could be converfed 
info a non-exfension mefhod, allowing binary compafibilify wifh old code. If feels 
wrong fo complefely ignore fhis change in fhe resulfs of member lookup. 


7.6.5.3 Delegate Invocations 

For a delegafe invocafion, fhe primary-expression of fhe invocation-expression musf be a value 
of a delegate-type. Furfhermore, considering fhe delegate-type fo be a function member wifh 
fhe same paramefer lisf as fhe delegate-type, fhe delegate-type musf be applicable (§7.5.3.1) 
wifh respecf fo fhe argument-list of fhe invocation-expression. 

The runfime processing of a delegafe invocafion of fhe form D(A), where D is a primary- 
expression of a delegate-type and A is an opfional argument-list, consisfs of fhe following 
sfeps: 

• D is evaluafed. If fhis evaluation causes an exception, no furfher sfeps are execufed. 

• The value of D is checked fo be valid. If fhe value of D is null, a System.NullReference- 
Exception is fhrown and no furfher sfeps are execufed. 

• Ofherwise, D is a reference fo a delegafe insfance. Funcfion member invocafions (§7.5.4) 
are performed on each of fhe callable entities in fhe invocafion lisf of fhe delegafe. For 
callable entities consisting of an insfance and insfance mefhod, fhe insfance for fhe invo¬ 
cation is the instance contained in the callable entity. 

7.6.6 Element Access 

An element-access consists of a primary-no-array-creation-expression, followed by a " [" foken, 
followed by an argument-list, followed by a "]" foken. The argument-list consisfs of one or 
more arguments, separafed by commas. 

element-access: 

primary-no-array-creation-expression [ argument-list ] 

The argument-list of an element-access is nof allowed fo confain ref or out argumenfs. 


298 


www.it-ebooks.info 






7.6 Primary Expressions 


An element-access is d 5 mamically bound (§7.2.2) if at least one of the following holds: 

• The primary-no-array-creation-expression has compile-time type dynamic. 

• At least one expression of the argument-list has compile-time type dynamic and the 
primary-no-array-creation-expression does not have an array type. 

In this case the compiler classifies the element-access as a value of t 5 ^e dynamic. The rules 
below to determine the meaning of the element-access are then applied at runtime, using the 
runtime type instead of the compile-time type of those of the primary-no-array-creation- 
expression and argument-list expressions that have the compile-time type dynamic. If the 
primary-no-array-creation-expression does not have compile-time t 5 ^e dynamic, then the ele¬ 
ment access undergoes a limited compile time check as described in §7.5.4. 

If the primary-no-array-creation-expression of an element-access is a value of an array-type, the 
element-access is an array access (§7.6.6.1). Otherwise, the primary-no-array-creation-expression 
must be a variable or value of a class, struct, or interface t 5 ^e that has one or more indexer 
members, in which case the element-access is an indexer access (§7.6. 6 .2). 


7.6.6.1 Array Access 

For an array access, the primary-no-array-creation-expression of the element-access must be a 
value of an array-type. Furthermore, the argument-list of an array access is not allowed to 
contain named arguments. The number of expressions in the argument-list must be the 
same as the rank of the array-type, and each expression must be of t 5 ^e int, uint, long, or 
along, or must be implicitly convertible to one or more of these t 5 ^es. 

The result of evaluating an array access is a variable of the element type of the array—namely, 
the array element selected by the value(s) of the expression(s) in the argument-list. 


■■ JONSKEET The fact that the result is a variable is important here: It means you 
can use array elements as ref or out arguments in method calls. In the face of array 
covariance, the actual type of the storage location is validated before the method is 
called. 




The runtime processing of an array access of the form P[A], where P is a primary-no-array- 
creation-expression of an array-type and A is an argument-list, consists of the following steps: 

• P is evaluated. If this evaluation causes an exception, no further steps are executed. 

• The index expressions of the argument-list are evaluated in order, from left to right. Fol¬ 
lowing evaluation of each index expression, an implicit conversion (§ 6 . 1 ) to one of the 
following types is performed: int, uint, long, ulong. The first t 5 ^e in this list for which 


299 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


an implicit conversion exists is chosen. For instance, if the index expression is of type 
short, then an implicit conversion to int is performed, since implicif conversions 
from short fo int and from short fo long are possible. If evaluation of an index expres¬ 
sion or the subsequent implicit conversion causes an exception, then no further index 
expressions are evaluated and no further steps are executed. 

• The value of P is checked fo be valid. If fhe value of P is null, a System. NullReference- 
Exception is fhrown and no furfher sfeps are execufed. 

• The value of each expression in fhe argument-list is checked againsf fhe acfual bounds of 
each dimension of fhe array insfance referenced by P. If one or more values are ouf of 
range, a System. IndexOutOfRangeException is fhrown and no furfher sfeps are 
execufed. 

• The location of fhe array elemenf given by fhe index expression(s) is compufed, and fhis 
location becomes the result of fhe array access. 


7.6.6.2 Indexer Access 

For an indexer access, fhe primary-no-array-creation-expression of fhe element-access musf be 
a variable or value of a class, sfrucf, or inferface type, and this type must implement one or 
more indexers that are applicable with respect to the argument-list of fhe element-access. 

The binding-fime processing of an indexer access of fhe form P [A], where P is a primary-no¬ 
array-creation-expression of a class, sfrucf, or inferface f 5 T>e T, and A is an argument-list, con- 
sisfs of fhe following sfeps: 

• The sef of indexers provided by T is consfrucfed. The sef consisfs of all indexers declared 
in T or a base type of T fhaf are nof override declarafions and are accessible in fhe currenf 
confexf (§3.5). 

• The sef is reduced fo fhose indexers fhaf are applicable and nof hidden by ofher index¬ 
ers. The following rules are applied fo each indexer S . I in fhe sef, where S is fhe fype in 
which fhe indexer I is declared: 

- If I is nof applicable wifh respecf fo A (§7.5.3.1), fhen I is removed from fhe sef. 

- If I is applicable wifh respecf fo A (§7.5.3.1), fhen all indexers declared in a base fype 
of S are removed from fhe sef. 

- If I is applicable wifh respecf fo A (§7.5.3.1) and S is a class type other than object, all 
indexers declared in an interface are removed from fhe sef. 

• If fhe resulfing sef of candidafe indexers is empfy, fhen no applicable indexers exisf, and 
a binding-fime error occurs. 


300 


www.it-ebooks.info 




7.6 Primary Expressions 


• The best indexer of the set of candidate indexers is identified using the overload resolu¬ 
tion rules of §7.5.3. If a single best indexer cannot be identified, the indexer access is 
ambiguous, and a binding-time error occurs. 

• The index expressions of the argument-list are evaluated in order, from left to right. The 
result of processing the indexer access is an expression classified as an indexer access. 
The indexer access expression references the indexer determined in the step above, and 
has an associated instance expression of P and an associated argument list of A. 

Depending on the context in which it is used, an indexer access causes invocation of either 
the get-accessor or the set-accessor of the indexer. If the indexer access is the target of an 
assignment, the set-accessor is invoked to assign a new value (§7.17.1). In all other cases, the 
get-accessor is invoked to obtain the current value (§7.1.1). 


"■ VLADIMIR RESHETNIKOV If the corresponding accessor is missing or is not 
accessible, a compile-time error occurs. 


7.6.7 this Access 

A this-access consists of the reserved word this. 

this-access: 

this 

A this-access is permitted only in the block of an instance constructor, an instance method, 

or an instance accessor. It has one of the following meanings: 

• When this is used in a primary-expression within an instance constructor of a class, it is 
classified as a value. The t 5 ^e of the value is the instance t 5 ^e (§10.3.1) of the class within 
which the usage occurs, and the value is a reference to the object being constructed. 

• When this is used in a primary-expression within an instance method or instance accessor 
of a class, it is classified as a value. The type of the value is the instance t 5 ^e (§10.3.1) of 
the class within which the usage occurs, and the value is a reference to the object for 
which the method or accessor was invoked. 

• When this is used in a primary-expression within an instance constructor of a struct, it is 
classified as a variable. The type of the variable is the instance type (§10.3.1) of the struct 
within which the usage occurs, and the variable represents the struct being constructed. 
The this variable of an instance constructor of a struct behaves exactly the same as an 
out parameter of the struct type—in particular, this means that the variable must be 
definitely assigned in every execution path of the instance constructor. 




301 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


• When t h i s is used in a primary-expression within an instance method or instance accessor 
of a struct, it is classified as a variable. The type of the variable is the instance type 
(§10.3.1) of the struct within which the usage occurs. 

- If the method or accessor is not an iterator (§10.14), the this variable represents the 
struct for which the method or accessor was invoked, and behaves exactly the same 
as a ref parameter of fhe struct type. 

- If the method or accessor is an iterator, the this variable represents a copy of the struct 
for which the method or accessor was invoked, and behaves exactly the same as a 
value parameter of the struct t 5 ^e. 


■■ JONSKEET The ability to write 

this = new CustomStruct(...); 

in a method within a value t 5 ^e always feels deeply wrong to me. Given that structs 
should almost always be immutable in the first place, I wonder how many justifiable 
uses fhis has found in fhe global corpus of C# code. 


Use of this in a primary-expression in a context other than the ones listed above is a 
compile-time error. In particular, it is not possible to refer to this in a static method, a static 
property accessor, or in a variable-initializer of a field declaration. 

7.6.8 Base Access 

A base-access consists of the reserved word base followed by either a "." token and an iden¬ 
tifier or an argument-list enclosed in square brackets: 

base-access: 

base . identifier 
base [ argument-list ] 

A base-access is used to access base class members that are hidden by similarly named 
members in the current class or struct. A base-access is permitted only in the block of an 
instance constructor, an instance method, or an instance accessor. When base. I occurs in a 
class or struct, I must denote a member of the base class of that class or struct. Likewise, 
when base[E] occurs in a class, an applicable indexer must exist in the base class. 

At binding time, base-access expressions of the form base.I and base[E] are evaluated 
exactly as if they were written (( B ) t h i s). I and ((B)this)[E], where B is the base class of 
fhe class or struct in which the construct occurs. Thus base. I and base [ E ] correspond to 
this .1 and this[E], except this is viewed as an instance of the base class. 


302 


www.it-ebooks.info 






7.6 Primary Expressions 


“■ VLADIMIR RESHETNIKOV If a base-access of fhe laffer form is d 5 mamically dis- 
pafched (i.e., if if has an argumenf of t 5 ^e dynamic), a compile-fime error (CS1972) 
occurs. 


When a base-access references a virfual function member (a mefhod, properfy, or indexer), 
fhe deferminafion of which fimcfion member fo invoke af runfime (§7.5.4) is changed. The 
funcfion member fhaf is invoked is defermined by finding fhe mosf derived implemenfa- 
fion (§10.6.3) of fhe funcfion member wifh respecf fo B (insfead of wifh respecf fo fhe run¬ 
fime type of this, as would be usual in a non-base access). Thus, within an override of a 
virtual function member, a base-access can be used to invoke the inherited implementation 
of the function member. If the function member referenced by a base-access is abstract, a 
binding-time error occurs. 


■■ ERICLIPPERT In the Microsoft C# 2.0 compiler and above, base calls to virtual 
methods are code generated as nonvirtual calls to the specific method known at com¬ 
pile time to be on a base class. If you do an end-run around the compiler by swapping 
in a new version of a library that has a new virtual override "in the middle" without 
recompiling the code that makes the base call, that code will continue to call the spe¬ 
cific method identified at compile time. In short, base calls do not use virtual dispatch. 

It is not legal for a lambda expression converted to an expression tree t 5 ^e to contain 
a base access. 


7.6.9 Postfix Increment and Decrement Operators 

post-increment-expression: 
primary-expression ++ 

post-decrement-expression: 
primary-expression - - 

The operand of a postfix increment or decrement operation must be an expression classi¬ 
fied as a variable, a property access, or an indexer access. The result of the operation is a 
value of the same t 5 ^e as the operand. 

If the primary-expression has the compile-time t 5 ^e dynamic, then the operator is d 5 mami- 
cally boimd (§7.2.2), the post-increment-expression or post-decrement-expression has the com¬ 
pile-time t 5 ^e dynamic, and the following rules are applied at runtime using the runtime 
type of the primary-expression. 




303 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


If the operand of a postfix increment or decrement operation is a property or indexer access, 
the property or indexer must have both a get and a set accessor. If this is not the case, a 
binding-time error occurs. 

Unary operator overload resolution (§7.3.3) is applied to select a specific operator imple¬ 
mentation. Predefined ++ and - - operators exist for the following types: sbyte, byte, short, 
ushort, int, uint, long, ulong, char, float, double, decimal, and any enum t 5 ^e. The pre¬ 
defined ++ operators return the value produced by adding 1 to the operand, and the 
predefined - - operators return the value produced by subtracting 1 from the operand. In a 
checked context, if the result of this addition or subtraction is outside the range of the result 
type and the result type is an integral t 5 rpe or enum type, a System.OverflowException is 
thrown. 

The runtime processing of a postfix increment or decrement operation of the form x++ or 
X - - consists of the following steps: 

• If x is classified as a variable: 

- X is evaluated to produce the variable. 

- The value of x is saved. 

- The selected operator is invoked with the saved value of x as its argument. 

- The value returned by the operator is stored in the location given by the evaluation 
of X. 

- The saved value of x becomes the result of the operation. 

• If X is classified as a property or indexer access: 

- The instance expression (if x is not static) and the argument list (if x is an indexer 
access) associated with x are evaluated, and the results are used in the subsequent get 
and set accessor invocations. 

- The get accessor of x is invoked and the returned value is saved. 

- The selected operator is invoked with the saved value of x as its argument. 

- The set accessor of x is invoked with the value returned by the operator as its value 
argument. 


“■ VLADIMIR RESHETNIKOV If either the get-accessor or the set-accessor is missing 
or is not accessible, a compile-time error occurs. 


- The saved value of x becomes the result of the operation. 


304 


www.it-ebooks.info 






7.6 Primary Expressions 


The ++ and - - operators also support prefix notation (§7.7.5). Typically, the result of x++ or 
X - - is fhe value of x before fhe operafion, whereas fhe resulf of ++x or - - x is fhe value of x 
after the operation. In either case, x itself has fhe same value affer fhe operafion. 

An operator ++ or operator -- implemenfafion can be invoked using eifher posffix or 
prefix nofafion. If is nof possible fo have separafe operafor implemenfafions for fhe fwo 
nofafions. 


7.6.10 The new Operator 

The new operafor is used fo creafe new insfances of fypes. 

There are fhree forms of new expressions: 

• Objecf creafion expressions are used fo creafe new insfances of class f 5 ^es and value 
fypes. 

• Array creafion expressions are used fo creafe new insfances of array fypes. 

• Delegafe creafion expressions are used fo creafe new insfances of delegafe f 5 ^es. 

The new operafor implies creafion of an insfance of a f5T’e, buf does nof necessarily imply 
dynamic allocafion of memory. In particular, insfances of value fypes require no additional 
memory beyond fhe variables in which fhey reside, and no dynamic allocafions occur 
when new is used fo creafe insfances of value f 5 q)es. 

7.6.10.1 Object Creation Expressions 

An object-creation-expression is used fo creafe a new insfance of a class-type or a value-type, 
object-creation-expression: 

new type ( argument-list) object-or-collection-initializer^^ 
new type object-or-collection-initializer 

object-or-collection-initializer: 

object-initializer 

collection-initializer 

The type of an object-creation-expression musf be a class-type, a value-type, or a type-parameter. 
The type carmof be an abstract class-type. 

The optional argument-list (§7.5.1) is permitted only if fhe type is a class-type or a struct-type. 

An objecf creafion expression can omif fhe consfrucfor argumenf lisf and enclosing paren- 
fheses provided if includes an objecf inifializer or collecfion inifializer. Omiffing fhe con¬ 
sfrucfor argumenf lisf and enclosing parenfheses is equivalenf fo specifying an empfy 
argumenf lisf. 




305 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


Processing of an object creation expression that includes an object initializer or collection 
initializer consists of first processing the instance constructor and then processing the 
member or element initializations specified by the object initializer (§7.6.10.2) or collection 
initializer (§7.6.10.3). 

If any of the arguments in the optional argument-list has the compile-time type dynamic, 
then the object-creation-expression is d 5 mamically bound (§7.2.2) and the following rules are 
applied at runtime using the runtime type of those arguments of the argument-list that have 
the compile-time type dynamic. However, the object creation undergoes a limited compile¬ 
time check, as described in §7.5.4. 

The binding-time processing of an object-creation-expression of the form new T( A), where T is 
a class-type or a value-type and A is an optional argument-list, consists of the following 
steps: 

• If T is a value-type and A is not present: 

- The object-creation-expression is a default constructor invocation. The result of the 
object-creation-expression is a value of type T —namely, the default value for T as defined 
in §4.1.1. 

• Otherwise, if T is a type-parameter and A is not present: 

- If no value type constraint or constructor constraint (§10.1.5) has been specified for T, 
a binding-time error occurs. 

- The result of the object-creation-expression is a value of the runtime type that the type 
parameter has been bound to—namely, the result of invoking the default constructor 
of that type. The runtime type may be a reference t 5 ^e or a value t 5 ^e. 

• Otherwise, if T is a class-type or a struct-type: 

- If T is an abstract class-type, a compile-time error occurs. 

- The instance constructor to invoke is determined using the overload resolution rules 
of §7.5.3. The set of candidate instance constructors consists of all accessible instance 
constructors declared in T that are applicable with respect to A (§7.5.3.1). If the set of 
candidate instance constructors is empty, or if a single best instance constructor can¬ 
not be identified, a binding-time error occurs. 

- The result of the object-creation-expression is a value of type T —namely, the value pro¬ 
duced by invoking the instance constructor determined in the step above. 

• Otherwise, the object-creation-expression is invalid, and a binding-time error occurs. 
Even if the object-creation-expression is d 5 mamically bound, the compile-time t 5 ^e is still T. 

The runtime processing of an object-creation-expression of the form new T( A), where T is class- 
type or a struct-type and A is an optional argument-list, consists of the following steps: 


306 


www.it-ebooks.info 




7.6 Primary Expressions 


• If T is a class-type: 

- A new instance of class T is allocated. If there is not enough memory available to 
allocate the new instance, a System. OutOf Memory Exception is thrown and no further 
steps are executed. 

- All fields of the new instance are initialized to their default values (§5.2). 

- The instance constructor is invoked according to the rules of function member invo¬ 
cation (§7.5.4). A reference to the newly allocated instance is automatically passed to 
the instance constructor and the instance can be accessed from within that construc¬ 
tor as this. 

• If T is a struct-type: 

- An instance of type T is created by allocating a temporary local variable. Since an 
instance constructor of a struct-type is required to definitely assign a value to each 
field of the instance being created, no initialization of the temporary variable is 
necessary. 

- The instance constructor is invoked according to the rules of function member invo¬ 
cation (§7.5.4). A reference to the newly allocated instance is automatically passed to 
the instance constructor and the instance can be accessed from within that construc¬ 
tor as this. 


7.6.10.2 Object Initializers 

An object initializer specifies values for zero or more fields or properties of an object. 

object-initializer: 

{ member-initializer-list , } 

{ member-initializer-list , } 

member-initializer-list: 

member-initializer 

member-initializer-list , member-initializer 

member-initializer: 

identifier - initializer-value 

initializer-value: 

expression 

object-or-collection-initializer 

An object initializer consists of a sequence of member initializers, enclosed by { and } 
tokens and separated by commas. Each member initializer must name an accessible field 
or property of the object being initialized, followed by an equals sign and an expression, 
object initializer, or collection initializer. It is an error for an object initializer to include 




307 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


more than one member initializer for the same field or properly. If is nof possible for fhe 
objecf initializer fo refer fo fhe newly creafed objecf if is inifializing. 

A member inifializer fhaf specifies an expression after fhe equals sign is processed in fhe 
same way as an assignmenf (§7.17.1) fo fhe field or properly. 

A member inifializer fhaf specifies an objecf inifializer after fhe equals sign is a nested 
object initializer —fhaf is, an inifializafion of an embedded objecf. Insfead of assigning a 
new value fo fhe field or properly fhe assignmenfs in fhe nesfed objecf inifializer are freafed 
as assignmenfs fo members of fhe field or properly Nesfed objecf initializers cannof be 
applied fo properties wifh a value type, or to read-only fields wifh a value type. 

A member initializer that specifies a collection inifializer after fhe equals sign is an inifial¬ 
izafion of an embedded collection. Insfead of assigning a new collecfion fo fhe field or 
properly fhe elemenfs given in fhe inifializer are added fo fhe collecfion referenced by fhe 
field or properly The field or properly musf be of a collecfion fype fhaf satisfies fhe require- 
menfs specified in §7.6.10.3. 

The following class represenfs a poinf wifh fwo coordinafes: 

public class Point 
{ 

int X, y; 

public int X { get { return x; } set { x = value; } } 
public int Y { get { return y; } set { y = value; } } 

} 

An insfance of Point can be creafed and initialized as follows: 

Point a = new Point { X = 0, Y = 1 }; 

which has fhe same effecf as 

Point _a = new Point(); 

_a.X = 0; 

_a.Y = 1; 

Point a = _a; 

where_a is an ofherwise invisible and inaccessible femporary variable. The following 

class represenfs a recfangle creafed from fwo poinfs: 

public class Rectangle 
{ 

Point pi, p2; 

public Point PI { get { return pi; } set { pi = value; } } 
public Point P2 { get { return p2; } set { p2 = value; } } 

} 

An insfance of Rectangle can be creafed and inifialized as follows: 


308 


www.it-ebooks.info 





7.6 Primary Expressions 


Rectangle r = new Rectangle { 

PI = new Point { X = 0, Y = 1 }, 
P2 = new Point {X=2, Y=3} 

}; 


which has the same effect as 

Rectangle _r = new Rectangle(); 

Point _pi = new Point(); 

_pl.X = 0; 

_pl.Y = l; 

_r.Pl = pi; 

Point _p2 = new Point(); 

_p2.X = 2; 

_p2.Y = 3; 

_r.P2 = p2; 

Rectangle r = _r; 

where_r,_pi, and_p2 are temporary variables that are otherwise invisible and 

inaccessible. 


■■ JOSEPH ALBAHARI The use of a hidden femporary variable eliminafes fhe pos- 
sibilify of ending up wifh a parfially inifialized objecf, should an exception be fhrown 
during inifializafion. Insfead, fhe newly consfrucfed objecf is complefely abandoned: 

Point p = null; 
int zero = 0; 

try { p = new Point {X=3, Y=4/ zero }; } 

// Throws DivideByZeroException 
catch { Console.WriteLine (p == null); } 

// True 


“■ ERIC LI PPERT The use of a hidden femporary variable also makes if clear whaf 
fhe definife assignmenf rules are. The second line here is nof equivalenf fo fhe firsf: 

Point pi = new Polnt(); pl.Y = pl.X; // Legal 

Point p2 = new Point() { Y = p2.X }; // Not legal; p2 is not assigned yet 

If Rectangle's consfrucfor allocafes fhe fwo embedded Point insfances: 

public class Rectangle 

{ 

Point pi = new Point(); 

Point p2 = new Point(); 

public Point PI { get { return pi; } } 

public Point P2 { get { return p2; } } 

} 




309 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


The following construct can be used to initialize the embedded Point instances instead of 
assigning new instances: 

Rectangle r = new Rectangle { 

PI = { X = 0, Y = 1 
P2={X=2jY=3} 

}; 


which has the same effect as 

Rectangle _r = new Rectangle(); 

_r.Pl.X = 0; 

_r.Pl.Y = 1; 

_r.P2.X = 2; 

_r.P2.Y = 3; 

Rectangle r = _ r; 


7.6.10.3 Collection Initializers 

A collection initializer specifies the elements of a collection. 

collection-initializer: 

{ element-initializer-list } 

{ element-initializer-list , } 

element-in itia I izer- list: 
element-initializer 

element-initializer-list , element-initializer 

element-initial izer: 

non-assignment-expression 
{ expression-list } 

expression-list: 

expression 

expression-list , expression 

A collection initializer consists of a sequence of element initializers, enclosed by { and } 
tokens and separated by commas. Each element initializer specifies an element to be added 
to the collection object being initialized, and consists of a list of expressions enclosed by { 
and } tokens and separated by commas. A single-expression element initializer can be 
written without braces, but cannot then be an assignment expression, to avoid ambiguity 
with member initializers. The non-assignment-expression production is defined in §7.18. 

The following is an example of an object creation expression that includes a collection 
initializer: 

List<int> digits = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; 


310 


www.it-ebooks.info 




7.6 Primary Expressions 


The collection object to which a collection initializer is applied must be of a type that imple¬ 
ments System. Collections. lEnumerable or a compile-time error occurs. For each speci¬ 
fied elemenf in order, fhe collection initializer invokes an Add mefhod on fhe fargef objecf 
wifh the expression list of fhe elemenf inifializer as fhe argumenf lisf, applying normal 
overload resolution for each invocafion. Thus fhe collecfion objecf musf confain an appli¬ 
cable Add mefhod for each elemenf inifializer. 


"■ ERIC LIPPERT The rule here is a bif odd: A collecfion inifializer is valid only 
when fhe objecf implemenfs lEnumerable and has an Add mefhod. Notice fhaf we 
never call any mefhod of lEnumerable in a collecfion inifializer! So why do we require 
if? The C# design feam did a survey of existing objecfs and made fhe following discov¬ 
eries. Firsf, almosf all objecfs fhaf have an Add mefhod eifher are collecfions or are 
implementing some kind of arifhmefic. We explicifly did nof wanf fhis design fo be a 
S 5 mfacfic sugar for arifhmefic—^jusf collection creation. Second, of fhose objecfs fhaf 
were collecfions, fhere was no one common inferface wifh an Add mefhod imple- 
menfed by all of fhem. Third, all of fhe collecfions implemenfed lEnumerable, buf 
none of fhe arifhmefic objecfs did. For all fhese reasons, we decided fo use fhe exis- 
fence of lEnumerable plus an Add mefhod as our touchstone for whefher a collecfion 
inifializer is valid. 


The following class represenfs a confacf wifh a name and a lisf of phone numbers: 
public class Contact 




string name; 

List<string> phoneNumbers = new List<string>(); 

public string Name { get { return name; } set { name = value; } } 

public List<string> PhoneNumbers { get { return phoneNumbers; } } 


A List<Contact> can be created and initialized as follows: 

var contacts = new List<Contact> { 
new Contact { 

Name = "Chris Smith", 

PhoneNumbers = { "206-555-0101", "425-882-8080" } 

new Contact { 

Name = "Bob Harris", 

PhoneNumbers = { "650-555-0199" } 

} 

}; 


311 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


which has the same effect as 

van _clist = new List<Contact>(); 

Contact _cl = new Contact(); 

_cl.Name = "Chris Smith"; 

_cl.PhoneNumbers.Add("206-555-0101"); 

_cl. PhoneNumbers.Add("425-882-8080"); 

_clist.Add(_cl); 

Contact _c2 = new Contact(); 

_c2.Name = "Bob Harris"; 

_c2.PhoneNumbers.Add("650-555-0199"); 

_clist.Add(_c2); 

var contacts = _clist; 

where_clist,_cl, and_c2 are temporary variables that are otherwise invisible and 

inaccessible. 


7.6.10.4 Array Creation Expressions 

An array-creation-expression is used to create a new instance of an array-type, 
array-creation-expression: 

new non-array-type [ expression-list ] rank-specifiersarray-initializer^^ 
new array-type array-initializer 
new rank-specifier array-initializer 

An array creafion expression of fhe firsf form allocafes an array insfance of fhe type that 
results from delefing each of fhe individual expressions from fhe expression lisf. For exam¬ 
ple, fhe array creafion expression new int[10, 20] produces an array insfance of type 
int[, ], and the array creation expression new int [10] [, ] produces an array of t 5 ^e int[ ] 
[, ]. Each expression in fhe expression lisf musf be of t 5 ^e int, uint, long, or ulong, or 
implicifly converfible fo one or more of fhese fypes. The value of each expression defer- 
mines fhe lengfh of fhe corresponding dimension in fhe newly allocafed array insfance. 
Since fhe lengfh of an array dimension musf be non-negafive, if is a compile-fime error fo 
have a constant-expression wifh a negative value in fhe expression lisf. 

Excepf in an unsafe confexf (§18.1), fhe layouf of arrays is unspecified. 

If an array creafion expression of fhe firsf form includes an array initializer, each expression 
in the expression list must be a constant, and the rank and dimension lengths specified by 
fhe expression lisf musf mafch fhose of fhe array initializer. 

In an array creafion expression of fhe second or fhird form, fhe rank of fhe specified array 
fype or rank specifier musf mafch fhaf of fhe array inifializer. The individual dimension 


312 


www.it-ebooks.info 




7.6 Primary Expressions 


lengths are inferred from fhe number of elemenfs in each of fhe corresponding nesfing 
levels of fhe array initializer. Thus fhe expression 

new int[,] {{0, 1}, {2, 3}, {4, 5}} 

exacfly corresponds fo 

new int[3, 2] {{0, 1}, {2, 3}, {4, 5}} 

An array creafion expression of fhe fhird form is referred fo as an implicitly typed array 
creation expression. If is similar fo fhe second form, excepf fhaf fhe elemenf f 5 ^e of fhe 
array is nof explicifly given, buf defermined as fhe besf common type (§7.5.2.14) of fhe sef 
of expressions in fhe array inifializer. For a mulfidimensional array—fhaf is, one where fhe 
rank-specifier confains af leasf one comma—fhis sef comprises all expressions found in nesfed 
array-initializers. 

Array inifializers are described furfher in §12.6. 

The resulf of evaluafing an array creafion expression is classified as a value—namely, a 
reference fo fhe newly allocafed array insfance. The runtime processing of an array cre¬ 
afion expression consisfs of fhe following sfeps: 

• The dimension lengfh expressions of fhe expression-list are evaluafed in order, from leff 
fo righf. Following evaluafion of each expression, an implicif conversion (§6.1) fo one of 
fhe following fypes is performed: int, uint, long, ulong. The firsf type in this list for 
which an implicif conversion exisfs is chosen. If evaluafion of an expression or fhe sub- 
sequenf implicif conversion causes an excepfion, fhen no furfher expressions are evalu¬ 
afed and no furfher sfeps are execufed. 

• The compufed values for fhe dimension lengfhs are validafed as follows. If one or more 
of fhe values are less fhan zero, a System.OverflowException is fhrown and no furfher 
sfeps are execufed. 

• An array insfance wifh fhe given dimension lengfhs is allocafed. If fhere is nof enough 
memory available fo allocafe fhe new insfance, a System. OutOf Memory Exception is 
fhrown and no furfher sfeps are execufed. 

• All elemenfs of fhe new array insfance are initialized fo fheir defaulf values (§5.2). 

• If fhe array creafion expression confains an array inifializer, fhen each expression in fhe 
array inifializer is evaluafed and assigned fo ifs corresponding array elemenf. The eval¬ 
uations and assignments are performed in fhe order fhe expressions are written in fhe 
array inifializer—in ofher words, elemenfs are inifialized in increasing index order, wifh 
fhe righfmosf dimension increasing firsf. If evaluafion of a given expression or fhe sub- 
sequenf assignmenf fo fhe corresponding array elemenf causes an excepfion, fhen no 
furfher elemenfs are inifialized (and fhe remaining elemenfs will fhus have fheir defaulf 
values). 




313 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


An array creation expression permits instantiation of an array with elements of an array 
fype, buf fhe elemenfs of such an array musf be manually inifialized. For example, fhe 
sfafemenf 

int[][] a = new int[100][]; 

creafes a single-dimensional array wifh 100 elemenfs of t 5 ^e int[ ]. The inifial value of 
each elemenf is null. If is nof possible for fhe same array creation expression to also instan¬ 
tiate the subarrays, and the statement 

int[][] a = new int[100][5]; // Error 

results in a compile-time error. Instantiation of fhe subarrays musf insfead be performed 
manually, as in 

int[][] a = new int[100][]; 

for (int i = 0; i < 100; i++) a[i] = new int[5]; 


“■ BILL WAGNER The commenf below violafes an FxCop rule, buf does explain 
under which conditions you should violafe fhaf rule. 


When an array of arrays has a "recfangular" shape—fhaf is, when fhe subarrays are all of 
fhe same lengfh—if is more efficienf fo use a mulfi-dimensional array. In fhe example 
above, insfanfiafion of the array of arrays creafes 101 objecfs—one oufer array and 
100 subarrays. In confrasf, 

int[,] = new int[100, 5]; 

creafes only a single objecf—fhaf is, a fwo-dimensional array—and accomplishes fhe allo- 
cafion in a single sfafemenf. 


"■ PETER SESTOFT If is somewhaf dubious for a language specification fo confain 
sfafemenfs abouf efficiency, which is a maffer dealing wifh implemenfafion, nof 
semanfics. Indeed, whereas if may be fasfer fo allocafe (and subsequenfly manage) a 
single block of 500 infegers fhan 100 blocks of 5 infegers, a mafrix mulfiplicafion algo- 
rifhm thaf works on fhe "slow" array-of-arrays represenfafion may be fasfer fhan one 
fhaf works on fhe "efficienf" recfangular array represenfafion—probably fhanks fo a 
combinafion of JIT-compiler cleverness and modem CPU archifecfure. 


The following are examples of implicifly fyped array creation expressions: 

var a = new[] { 1, 10, 100, 1000 }; // int[] 

var b = new[] { 1, 1.5, 2, 2.5 }; // double[] 

var c = new[,] { { "hello", null }, { "world", "!" } }; // string[,] 

var d = new[] { 1, "one", 2, "two" }; // Error 

314 


www.it-ebooks.info 








7.6 Primary Expressions 


The last expression causes a compile-time error because neither int nor string is implic¬ 
itly convertible to the other, so there is no best common type. An explicitly typed array 
creation expression must be used in this case—for example, specifying the type to be 
object[ ]. Alternatively, one of the elements can be cast to a common base type, which 
would then become the inferred element t 5 ^e. 

Implicitly typed array creation expressions can be combined with anonymous object ini¬ 
tializers (§7.6.10.6) to create anonymously typed data structures. For example: 

var contacts = new[] { 
new { 

Name = "Chris Smith", 

PhoneNumbers = new[] { "206-555-0101", "425-882-8080" } 
new { 

Name = "Bob Harris", 

PhoneNumbers = new[] { "650-555-0199" } 

} 

}; 


7.6.10.5 Delegate Creation Expressions 

A delegate-creation-expression is used to create a new instance of a delegate-type. 

delegate-creation-expression: 

new delegate-type ( expression ) 

The argument of a delegate creation expression must be a method group, an anonymous 
function, or a value of either the compile-time t 5 ^e dynamic or a delegate-type. If the argu¬ 
ment is a method group, it identifies the method and, for an insfance mefhod, the object for 
which fo creafe a delegafe. If the argument is an anonymous function, it directly defines fhe 
paramefers and mefhod body of the delegate target. If the argument is a value, it identifies 
a delegate instance of which fo create a copy. 

If fhe expression has the compile-time type dynamic, the delegate-creation-expression is dynam¬ 
ically bound (§7.2.2), and the rules below are applied at runtime using the runtime t 5 ^e of 
fhe expression. Otherwise, the rules are applied at compile time. 

The binding-time processing of a delegate-creation-expression of the form new D(E), where D 
is a delegate-type and E is an expression, consists of fhe following sfeps: 

• If E is a method group, the delegate creation expression is processed in the same way as 
a method group conversion (§6.6) from E fo D. 

• If E is an anonymous function, the delegate creation expression is processed in the same 
way as an anonymous function conversion (§6.5) from E to D. 




315 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


• If E is a value, E must be compatible (§15.1) with D, and the result is a reference to a newly 
created delegate of type D that refers to the same invocation list as E. If E is not compat¬ 
ible with D, a compile-time error occurs. 

The runtime processing of a delegate-creation-expression of the form new D(E), where D is a 
delegate-type and E is an expression, consists of the following steps: 

• If E is a method group, the delegate creation expression is evaluated as a method group 
conversion (§6.6) from E to D. 

• If E is an anonymous function, the delegate creation is evaluated as an anonymous func¬ 
tion conversion from E to D (§6.5). 

• If E is a value of a delegate-type: 

E is evaluated. If this evaluation causes an exception, no further steps are executed. 

- If the value of E is null, a System.NullReferenceException is thrown and no further 
steps are executed. 

- A new instance of the delegate t 5 ^e D is allocated. If there is not enough memory 
available to allocate the new instance, a System.OutOfMemoryException is thrown 
and no further steps are executed. 

- The new delegate instance is initialized with the same invocation list as the delegate 
instance given by E. 

The invocation list of a delegate is determined when the delegate is instantiated and then 
remains constant for the entire lifetime of the delegate. In other words, it is not possible to 
change the target callable entities of a delegate once it has been created. When two dele¬ 
gates are combined or one is removed from another (§15.1), a new delegate results; no 
existing delegate has its contents changed. 

It is not possible to create a delegate that refers to a property, indexer, user-defined opera¬ 
tor, instance constructor, destructor, or static constructor. 

As described above, when a delegate is created from a method group, the formal parame¬ 
ter list and return type of the delegate determine which of the overloaded methods to 
select. In the example 

delegate double DoubleFunc(double x); 

class A 
{ 

DoubleFunc f = new DoubleFunc(Square); 

static float Square(float x) { 
return x * x; 

} 


316 


www.it-ebooks.info 




7.6 Primary Expressions 


static double Square(double x) { 
return x * x; 

} 

} 

the A. f field is initialized with a delegate that refers to the second Square method because 
that method exactly matches the formal parameter list and return type ofDoubleFunc. Had 
the second Square method not been present, a compile-time error would have occurred. 


7.6.10.6 Anonymous Object Creation Expressions 

An anonymous-object-creation-expression is used to create an object of an anonymous t 5 ^e. 

anonymous-object-creation-expression: 
new anonymous-object-initializer 

anonymous-object-initializer: 

{ member-declarator-list , } 

{ member-declarator-list , } 

member-declarator-list: 

member-declarator 

member-declarator-list , member-declarator 

member-declarator: 

simple-name 

member-access 

base-access 

identifier = expression 


■■ VLADIMIR RESHETNIKOV A base-access can be a member-declarator only if it is of 
the form base. identifier-, that is, no base indexer access is allowed here. 


An anonymous object initializer declares an anonymous t 5 ^e and returns an instance of 
that type. An anonymous type is a nameless class t 5 ^e that inherits directly from object. 
The members of an anonymous type are a sequence of read-only properties inferred from 
the anonymous object initializer used to create an instance of the type. Specifically, an 
anonymous object initializer of the form 

new { pj = Cj , , •••?„ = e„ > 




317 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


declares an anonymous t 5 ^e of the form 

class _Anonymousl 

{ 

private readonly ; 

private readonly ; 


private readonly ; 

public _Anonymousl(Tj ..., { 

/, = ; 
f 2 = ‘>2 ’ 

} 

public Tj pj { get { return /, ; } } 

public Tj { get { return /^ ; } } 

public { get { return /„ ; } } 

public override bool Equals(object o) { ... } 
public override int GetHashCode() { ... } 


where each is the t 5 ^e of the corresponding expression e^. The expression used in a 
member-declarator must have a t 5 ^e. Thus it is a compile-time error for an expression in 
a member-declarator to be null or an anonymous fimction. It is also a compile-time error for 
the expression to have an unsafe type. 


"■ ERIC LI PPERT The actual code generated by the Microsoft implementation for an 
anonymous t 5 ^e is somewhat more complex than this discussion suggests because of 
the desire (mentioned later) to have structurally equivalent anonymous types be rep¬ 
resented by the same t 5 qie throughout a program. Because the field t 5 q)es could be 
protected nested t 5 q)es, it becomes difficult to figure out where exactly to generate the 
anonymous class so that it can be effectively shared among different derived t 5 q)es. 
For this reason, the Microsoft implementation actually generates a generic class and 
then constructs it with the appropriate t 5 q)e arguments. 


The name of an anonymous t 5 q)e is automatically generated by the compiler and carmot be 
referenced in program text. 


“■ JON SKEET Oxymoronic as it sounds, I would dearly love to see named anony¬ 
mous t 5 q)es: classes that are as easy to express as anonymous types and that possess 
the same properties of immutability, natural equality, and t 5 q)e and name safety of 
properties— but with a name. Although many tools can "expand" anonymous t 5 q)es 
into equivalent normal classes, the concise expression of the t 5 q)e is lost at that point. 


318 


www.it-ebooks.info 








7.6 Primary Expressions 


Within the same program, two anonymous object initializers that specify a sequence of 
properfies of the same names and compile-time types in the same order will produce 
instances of fhe same anonymous t 5 q)e. 

In fhe example 

van pi = new { Name = "Lawnmower", Price = 495.00 }; 
van p2 = new { Name = "Shovel", Price = 26.95 }; 
pi = p2; 

fhe assignmenf on fhe lasf line is permitted because pi and p2 are of fhe same anonymous 

type- 

The Equals and GetHashcode mefhods on anonymous f 5 q)es override fhe mefhods inher- 
ifed from object, and are defined in ferms of fhe Equals and GetHashcode of fhe properfies, 
so fhaf fwo insfances of fhe same anonymous 1)^)0 are equal if and only if all fheir proper¬ 
fies are equal. 

A member declarafor can be abbreviafed fo a simple name (§7.5.2), a member access 
(§7.5.4), or a base access (§7.6.8). This is called a projection initializer and is shorfhand for 
a declarafion of and assignmenf fo a properfy wifh fhe same name. Specifically, member 
declarafors of fhe forms 

identifier expr . identifier 

are precisely equivalenf fo fhe following, respecfively: 

identifier - identifier identifier - expr . identifier 

Thus, in a projecfion inifializer, fhe identifier selecfs bofh fhe value and fhe field or properfy 
fo which fhe value is assigned. Infuifively, a projecfion inifializer projecfs nof jusf a value, 
buf also fhe name of fhe value. 

7.6.11 The typeof Operator 

The typeof operator is used fo obfain fhe System.Type objecf for a fype. 

typeof-expression: 

typeof ( type ) 

typeof ( unbound-type-name ) 

typeof ( void ) 

unbound-type-name: 

identifier generic-dimension-specifier 

identifier :: identifier generic-dimension-specifier 

unbound-type-name . identifier generic-dimension-specifier 




319 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


generic-dimension-specifier: 
< commas , > 

Opt 

commas: 


commas , 

The first form of typeof-expression consists of a typeof keyword followed by a parenthe¬ 
sized type. The result of an expression of this form is the System.Type object for the indi¬ 
cated type. There is only one System .Type object for any given type. This means that for a 
type T, typeof (T) == typeof (T) is always true. The type carmot be dynamic. 

The second form of typeof-expression consists of a typeof ke 5 rword followed by a parenthe¬ 
sized unbound-type-name. An unbound-type-name is very similar to a type-name (§3.8) except 
that an unbound-type-name contains generic-dimension-specifiers whereas a type-name con¬ 
tains type-argument-lists. When the operand of a typeof-expression is a sequence of tokens 
that satisfies the grammars of both unbound-type-name and type-name —namely, when it 
contains neither a generic-dimension-specifier nor a type-argument-list —the sequence of 
tokens is considered to be a type-name. The meaning of an unbound-type-name is determined 
as follows: 

• Convert the sequence of tokens to a type-name by replacing each generic-dimension-specifier 
with a type-argument-list having the same number of commas and the keyword object 
as each type-argument. 

• Evaluate the resulting type-name, while ignoring all type parameter constraints. 

• The unbound-type-name resolves to the unbound generic type associated with the result¬ 
ing constructed type (§4.4.3). 

The result of the typeof-expression is the System.Type object for the resulting unbound 
generic type. 

The third form of typeof-expression consists of a typeof ke 5 rword followed by a parenthe¬ 
sized void ke 5 rword. The result of an expression of this form is the System .Type object that 
represents the absence of a type. The t 5 q)e object returned by typeof (void ) is distinct from 
the type object returned for any t 5 q)e. This special type object is useful in class libraries that 
allow reflection onto methods in the language, where those methods wish to have a way to 
represent the return type of any method, including void methods, with an instance of 
System.Type. 

The typeof operator can be used on a type parameter. The result is the System .Type object 
for the runtime t 5 q)e that was bound to the type parameter. The typeof operator can also 
be used on a constructed t 5 q)e or an unbound generic type (§4.4.3). The System. Type object 
for an unbound generic type is not the same as the System .Type object of the instance type. 


320 


www.it-ebooks.info 




7.6 Primary Expressions 


The instance t 5 ^e is always a closed constructed type at runtime, so its System .Type object 
depends on the runtime t 5 ^e arguments in use, while the unbound generic t 5 ^e has no 
type arguments. 

The example 

using System; 

class X<T> 

{ 

public static void PrintTypes() { 

Type[] t = { 

typeof(int), 
typeof(System.Int32), 
typeof(string), 
typeof(double[]), 
typeof(void), 
typeof(T), 
typeof(X<T>), 
typeof(X<X<T>>), 
typeof(X<>) 

}; 

for (int i = 0; i < t.Length; i++) { 

Console.WriteLine(t[i]); 

} 

} 

} 

class Test 

{ 

static void Main() { 

X<int>.PrintTypes(); 

} 

} 


produces the following output: 

System.Int32 
System.Int32 
System.String 
System.Double[] 

System.Void 
System.Int32 
X' l[System.Int32] 

X'l[X'l[System.Int32]] 

X'1[T] 

Note that int and System. Int32 are the same t 5 ^e. 

Also note that the result of typeof (X<>) does nof depend on fhe type argument, but the 
result of typeof (X<T>) does. 




321 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


7.6.12 The checked and unchecked Operators 

The checked and unchecked operators are used to control the overflow checking context ior 
integral-t 5 ^e arithmetic operations and conversions. 

checked-expression: 

checked ( expression ) 

unchecked-expression: 

unchecked ( expression ) 

The checked operator evaluates the contained expression in a checked context, and the 
unchecked operator evaluates the contained expression in an imchecked context A checked- 
expression or unchecked-expression corresponds exactly to a parenthesized-expression (§7.6.3), 
except that the contained expression is evaluated in the given overflow checking context. 


■■ JONSKEET In most cases, overflow indicates an error—^but in my experience, 
most developers (including myself) usually build without the checking feature on by 
default. Obviously, this approach has a performance penalty, but that's usually prefer¬ 
able to silently corrupted data. It would possibly make sense to make /checked+ the 
default for debug builds and /checked - fhe defaulf for release builds—alfhough Tm 
generally wary of behavioral changes between debug and release. This would be a 
little like the behavior of cross-fhread exceptions in Windows Forms. 

One situation where unchecked overflow behavior is almost always appropriate is 
in GetHashCode implementations, where the magnitude of the value generated doesn't 
really matter; in essence, it's just an arbitrary bit pattern. 


The overflow checking context can also be controlled through the checked and unchecked 
statements (§8.11). 

The following operations are aflecfed by the overflow checking context established by the 
checked and unchecked operators and statements: 

• The predefined ++ and - - unary operafors (§7.6.9 and §7.7.5), when the operand is of an 
infegral t 5 ^e. 

• The predefined - unary operafor (§7.7.2), when fhe operand is of an integral type. 

• The predefined +, -, *, and / binary operators (§7.8), when both operands are of infegral 
fypes. 


322 


www.it-ebooks.info 






7.6 Primary Expressions 


• Explicit numeric conversions (§6.2.1) from one integral t 5 ^e to another integral type, or 
from float or double to an integral t 5 ^e. 

When one of the above operations produces a result that is too large to represent in the 
destination t 5 ^e, the context in which the operation is performed controls the resulting 
behavior: 

• in a checked context, if the operation is a constant expression (§7.19), a compile-time 
error occurs. Otherwise, when the operation is performed at runtime, a System. 
OverflowException is thrown. 

• In an unchecked context, the result is tnmcated by discarding any high-order bits that 
do not fit in the destination type. 

For nonconstant expressions (expressions that are evaluated at runtime) that are not 
enclosed by any checked or unchecked operators or statements, the default overflow check¬ 
ing context is unchecked unless external factors (such as compiler switches and execution 
environment configuration) call for checked evaluation. 

For constant expressions (expressions that can be fully evaluated at compile time), the 
default overflow checking context is always checked. Unless a constant expression is 
explicitly placed in an unchecked context, overflows that occur during the compile-time 
evaluation of the expression always cause compile-time errors. 

The body of an anonymous function is not affected by checked or unchecked contexts in 
which the anonymous function occurs. 

In the example 

class Test 
{ 

static readonly int x = 1000000; 
static readonly int y = 1000000; 

static int F() { 

return checked(x * y); // Throws OverflowException 

} 

static int G() { 

return unchecked(x * y); // Returns -727379968 

} 

static int H() { 

return x * y; // Depends on default 

} 

} 

no compile-time errors are reported since neither of the expressions can be evaluated at 
compile time. At runtime, the F method throws a System.OverflowException and the G 




323 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


method returns -727379968 (the lower 32 bits of the out-of-range resulf). The behavior of 
fhe H mefhod depends on fhe defaulf overflow checking confexf for fhe compilafion, buf if 
is eifher the same as F or the same as G. 

In the example 

class Test 
{ 

const int x = 1000000; 
const int y = 1000000; 

static int F() { 

return checked(x * y); // Compile error^ overflow 

} 

static int G() { 

return unchecked(x * y); // Returns -727379968 

} 

static int H() { 

return x * y; // Compile error, overflow 

} 

} 

the overflows fhaf occur when evaluating fhe consfanf expressions in F and FI cause com- 
pile-fime errors fo be reporfed because fhe expressions are evaluafed in a checked confexf. 
TVn overflow also occurs when evaluating fhe consfanf expression in G, buf since fhe evalu¬ 
ation fakes place in an unchecked confexf, fhe overflow is nof reporfed. 

The checked and unchecked operators affecf fhe overflow checking confexf only for fhose 
operafions fhaf are fexfually confained wifhin fhe "(" and ")" tokens. The operators have 
no effecf on funcfion members fhaf are invoked as a resulf of evaluafing fhe confained 
expression. In fhe example 

class Test 
{ 

static int Multiply(int x, int y) { 
return x * y; 

} 

static int F() { 

return checked(Multiply(1000000, 1000000)); 

} 

} 

fhe use of checked in F does nof affecf fhe evaluation of x * y in Multiply, so x * y is evalu¬ 
ated in the default overflow checking confexf. 

The unchecked operafor is convenienf when writing consfanfs of fhe signed infegral fypes 
in hexadecimal nofafion. For example: 


324 


www.it-ebooks.info 




7.6 Primary Expressions 


class Test 
{ 

public const int AllBits = unchecked((int)0xFFFFFFFF); 
public const int HighBit = unchecked((int)0x80000000); 

} 

Both of the hexadecimal constants above are of type uint. Because the constants are out¬ 
side the int range, without the unchecked operator, the casts to int would produce com¬ 
pile-time errors. 

The checked and unchecked operators and statements allow programmers to control cer¬ 
tain aspects of some numeric calculations. However, the behavior of some numeric opera¬ 
tors depends on their operands' data types. For example, multiplying two decimals always 
results in an exception on overflow even within an explicitly unchecked construct. Similarly, 
multiplying two floats never results in an exception on overflow even within an explicitly 
checked construct. In addition, other operators are never affected by the mode of checking, 
whether default or explicit. 

7.6.13 Default Value Expressions 

A default value expression is used to obtain the default value (§5.2) of a type. Typically a 
default value expression is used for t 5 ^e parameters, since it may not be known if the type 
parameter is a value type or a reference type. (No conversion exists from the null literal to 
a t 5 ^e parameter unless the type parameter is known to be a reference t 5 ^e.) 

default-value-expression: 
default ( type ) 

If the type in a default-value-expression evaluates at runtime to a reference type, the result is 
null converted to that type. If the type in a default-value-expression evaluates at runtime to a 
value t 5 ^e, the result is the value-type's default value (§4.1.2). 

A default-value-expression is a constant expression (§7.19) if the type is a reference type or a 
type parameter that is known to be a reference t 5 ^e (§10.1.5). In addition, a default-value- 
expression is a constant expression if the t 5 ^e is one of the following value types: sbyte, 
byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, or any 
enumeration t 5 ^e. 




■■ JOSEPH ALBAHARI A default value expression is particularly useful with generic 
type parameters. Microsoft's LINQ implementation makes extensive use of this con¬ 
struct, in operators such as FirstOrDefault, SingleOrDefault, and Defaultif Empty. 


325 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


7.6.14 Anonymous Method Expressions 

An anonymous-method-expression is one of two ways of defining an anonymous function. 
These are further described in §7.15. 


7.7 Unary Operators 

The ++, - and cast operators are called the unary operators. 

unary-expression: 

primary-expression 
+ unary-expression 
- unary-expression 
! unary-expression 
~ unary-expression 
pre-increment-expression 
pre-decrement-expression 
cast-expression 

If the operand of a unary-expression has the compile-time type dynamic, it is d 5 mamically 
boimd (§7.2.2). In this case, the compile-time type of the unary-expression is dynamic, and 
the resolution described below will take place at runtime using the runtime type of the 
operand. 

7.7.1 Unary Plus Operator 

For an operation of the form +x, unary operator overload resolution (§7.3.3) is applied to 
select a specific operator implementation. The operand is converted to the parameter type 
of the selected operator, and the t 5 ^e of the result is the return type of the operator. The 
predefined unary plus operators are listed here: 

int operator +(int x); 
uint operator +(uint x); 
long operator +(long x); 
ulong operator +(ulong x); 
float operator +(float x); 
double operator +(double x); 
decimal operator +(decimal x); 

For each of these operators, the result is simply the value of the operand. 


“■ ERIC LIPPERT The unary plus operator is the world's least useful operator. It is 
included for completeness, so that you can write int x = -30; int y = +40; should 
you wish to emphasize that the value is positive for readability purposes. 


326 


www.it-ebooks.info 






7.7 Unary Operators 


7.7.2 Unary Minus Operator 

For an operation of the form -x, unary operator overload resolution (§7.3.3) is applied to 
select a specific operator implementation. The operand is converted to the parameter type 
of the selected operator, and the t 5 ^e of the result is the return type of the operator. The 
predefined negation operators are identified here: 

• Integer negation: 

int operator -(int x); 
long operator -(long x); 

The result is computed by subtracting x from zero. If the value of x is the smallest repre¬ 
sentable value of the operand type (-2^^ for int or -2® for long), then the mathematical 
negation of x is not representable within the operand type. If this occurs within a checked 
context, a System.OverflowException is thrown; if it occurs within an unchecked con¬ 
text, the result is the value of fhe operand and fhe overflow is not reported. 

If the operand of the negation operator is of type uint, it is converted to type long, and 
the type of the result is long. An exception is the rule that permits the int value 
-2147483648 (-2^^) to be written as a decimal integer literal (§2.4.4.2). 

If the operand of the negation operator is of type ulong, a compile-time error occurs. An 
exception is the rule that permits the long value -9223372036854775808 (-2®) to be writ¬ 
ten as a decimal integer literal (§2.4.4.2). 

• Floating point negation: 

float operator -(float x); 
double operator -(double x); 

The result is the value of x with its sign inverted. If x is NaN, the result is also NaN. 

• Decimal negation: 

decimal operator -(decimal x); 

The result is computed by subtracting x from zero. Decimal negation is equivalenf fo 
using the unary minus operator of type System. Decimal. 

7.7.3 Logical Negation Operator 

For an operation of the form ! x, unary operator overload resolution (§7.3.3) is applied to 
select a specific operator implementation. The operand is converted to the parameter type 
of fhe selecfed operafor, and fhe type of fhe result is the return type of fhe operator. Only 
one predefined logical negation operator exists: 

bool operator !(bool x); 




327 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


This operator computes the logical negation of the operand: If fhe operand is true, fhe 
resulf is false. If fhe operand is false, fhe resulf is true. 

7.7.4 Bitwise Complement Operator 

For an operafion of fhe form ~x, imary operator overload resolufion (§7.3.3) is applied fo 
selecf a specific operafor implemenfafion. The operand is converfed fo fhe parameter fype 
of fhe selecfed operafor, and fhe fype of fhe resulf is fhe refum fype of fhe operafor. The 
predefined bitwise complement operators are listed here: 

int operator ~(int x); 
uint operator ~(uint x); 
long operator ~(long x); 
ulong operator ~(ulong x); 

For each of fhese operators, fhe resulf of fhe operafion is fhe bitwise complemenf of x. 

Every enumerafion fype E implicifly provides fhe following bifwise complemenf 
operafor: 

E operator ~(E x); 


"■ BILL WAGNER This operafor will offen creafe an invalid value for fhe 
enumeration. 


The result of evaluafing ~x, where x is an expression of an enumerafion fype E wifh an 
underlying f 5 ^e U, is exacfly fhe same as evaluafing (E)(~(U)x). 

7.7.5 Prefix Increment and Decrement Operators 

pre-increment-expression: 

++ unary-expression 

pre-decrement-expression: 

- - unary-expression 

The operand of a prefix incremenf or decremenf operafion musf be an expression classified 
as a variable, a properly access, or an indexer access. The resulf of fhe operafion is a value 
of fhe same fype as fhe operand. 

If fhe operand of a prefix incremenf or decremenf operafion is a properly or indexer access, 
fhe properly or indexer musf have bofh a get and a set accessor. If fhis is nof fhe case, a 
binding-fime error occurs. 


328 


www.it-ebooks.info 






7.7 Unary Operators 


Unary operator overload resolution (§7.3.3) is applied to select a specific operator imple¬ 
mentation. Predefined ++ and - - operafors exisf for fhe following f 5 ^es: sbyte, byte, short, 
ushort, int, uint, long, along, char, float, double, decimal, and any enum f 5 ^e. The pre¬ 
defined ++ operafors refurn fhe value produced by adding 1 fo fhe operand, and fhe 
predefined - - operafors refurn fhe value produced by subfracfing 1 from fhe operand. In a 
checked confexf, if fhe resulf of fhis addifion or subfraction is outside the range of fhe resulf 
fype and fhe resulf fype is an infegral f 5 ^e or enum fype, a System.OverflowException is 
fhrown. 

The runfime processing of a prefix incremenf or decremenf operafion of fhe form ++x or 
- - X consisfs of fhe following sfeps: 

• If x is classified as a variable: 

- X is evaluafed fo produce fhe variable. 

- The selecfed operator is invoked wifh fhe value of x as ifs argumenf. 

- The value refumed by fhe operafor is sfored in fhe locafion given by fhe evaluafion 
of X. 

- The value refumed by fhe operator becomes the result of fhe operation. 

• If X is classified as a properfy or indexer access: 

- The insfance expression (if x is nof static) and fhe argumenf lisf (if x is an indexer 
access) associated with x are evaluated, and the results are used in the subsequent get 
and set accessor invocations. 

- The get accessor of x is invoked. 

- The selecfed operafor is invoked wifh fhe value refurned by fhe get accessor as ifs 
argumenf. 

- The set accessor of x is invoked wifh fhe value refurned by fhe operafor as ifs value 
argumenf. 

"■ VLADIMIR RESHETNIKOV If eifher fheg^ef-accessor or sef-accessor is missing or is 
nof accessible, a compile-fime error occurs. 




- The value refurned by fhe operafor becomes fhe resulf of fhe operafion. 

The ++ and - - operafors also supporf posffix nofafion (§7.6.9). Typically, fhe resulf of x++ 
or X - - is fhe value of x before fhe operafion, whereas fhe resulf of ++x or - - x is fhe value of 
X after fhe operafion. In eifher case, x ifself has fhe same value after fhe operafion. 


329 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


“■ ERIC LI PPERT Note the weasel word "t 5 ^ically" in the specification. Indeed, this 
is almost always the case, but the specification does not require that to be the case. The 
value of X after the operation could be any old thing; someone could be mutating x on 
another thread, x could be a property that returns random values when you call its 
getter, and so on. 

Consider this code: 

index = 0; value = this.arr[index++]; 

I often hear this code described as follows: "This gefs fhe elemenf af index zero and 
fhen incremenfs index fo one; fhe incremenf happens affer fhe array lookup because 
fhe ++ comes affer the index." If you read fhe specification carefully, you'll see fhaf fhis 
sfafemenf is complefely wrong. The correcf order of evenfs is (1) remember fhe currenf 
value of index, (2) incremenf index, and (3) do fhe array lookup using fhe remembered 
value. The incremenf happens before fhe lookup, nof after if. 


An operator ++ or operator -- implemenfafion can be invoked using eifher posffix or 
prefix nofafion. If is nof possible fo have separafe operafor implemenfafions for fhe fwo 
nof af ions. 


7.7.6 Cast Expressions 

A cast-expression is used fo explicifly converf an expression fo a given fype. 

cast-expression: 

( type ) unary-expression 

A cast-expression of fhe form (T) E, where T is a type and E is a unary-expression, performs an 
explicif conversion (§6.2) of fhe value of E fo 1)^0 T. If no explicif conversion exisfs from E 
fo T, a binding-time error occurs. Ofherwise, fhe resulf is fhe value produced by fhe explicif 
conversion. The resulf is always classified as a value, even if E denofes a variable. 


"■ ERIC LI PPERT The casf operafor is a bif of an odd duck, bofh because of ifs 
unusual sjmfax and because of ifs semanfics. A casf operafor is usually used fo mean 
eifher (1) I claim fhaf af runtime fhe value will not be of fhe casf f 5 ^e; do whafever if 
fakes fo make me a new value of fhe required fype; or (2) I claim fhaf af runfime fhe 
value will be of fhe casf fjqje; verify my claim by fhrowing an excepfion if Tm wrong. 
The affenfive reader will nofe fhaf fhese are opposites. Though if's a neaf frick fo have 
one operafor do fwo opposife fhings, as a resulf, if's easy fo gef confused abouf whaf 
fhe casf operafor is actually doing. 


330 


www.it-ebooks.info 








7.8 Arithmetic Operators 


The grammar for a cast-expression leads to certain syntactic ambiguities. For example, the 
expression (x) -y could be interpreted either as a cast-expression (a cast of -y to t 5 ^e x) or as 
an additive-expression combined with a parenthesized-expression (which computes the value 
x-y). 


To resolve cast-expression ambiguities, the following rule exists: A sequence of one or more 
tokens (§2.3.3) enclosed in parentheses is considered the start of a cast-expression only if at 
least one of the following conditions is true: 

• The sequence of tokens is correct grammar for a type, but not for an expression. 

• The sequence of tokens is correct grammar for a type, and the token immediately follow¬ 
ing the closing parentheses is the token the token "!", the token "(", an identifier 
(§2.4.1), a literal (§2.4.4), or any keyword (§2.4.3) except as and is. 

The term "correct grammar" above means only that the sequence of tokens must conform 
to the particular grammatical production. It specifically does not consider the actual mean¬ 
ing of any constituent identifiers. For example, if x and y are identifiers, then x. y is correct 
grammar for a type, even if x. y doesn't actually denote a t 5 q)e. 

From the disambiguation rule it follows that, if x and y are identifiers, (x)y, (x) (y), and 
(x) (-y) are cast-expressions, but (x) -y is not, even if x identifies a type. Flowever, if x is a 
keyword that identifies a predefined type (such as int), then all four forms are cast- 
expressions (because such a ke 5 rword could not possibly be an expression by itself). 




7.8 Arithmetic Operators 

The *, /, %, +, and - operators are called the arithmetic operators. 

multiplicative-expression: 
unary-express ion 

multiplicative-expression * unary-expression 
multiplicative-expression / unary-expression 
multiplicative-expression % unary-expression 

additive-expression: 

multiplicative-expression 

additive-expression + multiplicative-expression 
additive-expression - multiplicative-expression 

If an operand of an arithmetic operator has the compile-time type dynamic, then the expres¬ 
sion is dynamically bound (§7.2.2). In this case the compile-time type of the expression is 
dynamic, and the resolution described below will take place at runtime using the runtime 
type of those operands that have the compile-time type dynamic. 


331 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


“■ PETER SESTOFT When a value of a simple t 5 ^e such as double is assigned to a 
variable of t 5 ^e dynamic, it must t 5 ^ically be boxed (stored as an object in the heap) at 
runtime. Thus arithmetic computations with operands of t 5 ^e dynamic are likely to be 
slower than those with simple compile-time types. For instance, this loop is roughly 
six times slower (on Microsoft .NET 4.0) than if sum were declared to have type 
double: 


dynamic sum = 0; 
for (int i=0; i<count; i++) 
sum += (i + 1.0) * i; 


Actually, this is very fast compared to arithmetics in some other d 5 mamically typed 
languages. 


7.8.1 Multiplication Operator 

For an operation of the form x * y, binary operator overload resolution (§7.3.4) is applied 
to select a specific operator implementation. The operands are converted to the parameter 
types of the selected operator, and the type of the result is the return type of the operator. 

The predefined multiplication operators are listed below. The operators all compute the 
product of X and y. 

• Integer multiplication: 

int operator *(int x, int y); 
uint operator *(uint x, uint y); 
long operator *(long x, long y); 
ulong operator *(ulong x, ulong y); 

In a checked context, if the product is outside the range of the result t 5 ^e, a System. 
OverflowException is thrown. In an unchecked context, overflows are not reported and 
any significant high-order bits outside the range of the result t 5 ^e are discarded. 

• Floating point multiplication: 

float operator *(float x, float y); 
double operator *(double x, double y); 

The product is computed according to the rules of IEEE 754 arithmetic. The following 
table lists the results of all possible combinations of non-zero finite values, zeros, infini¬ 
ties, and NaNs. In the table, x and y are positive finite values; z is the result of x * y. If 
the result is too large for the destination type, z is infinity. If the result is too small for the 
destination type, z is zero. 


332 


www.it-ebooks.info 






7.8 Arithmetic Operators 



+y 

-y 

+0 

-0 

+00 

— 00 

NaN 

+x 

+Z 

-z 

+0 

-0 

+00 

—00 

NaN 

-X 

-z 

+z 

-0 

+0 

— 00 

+00 

NaN 

+0 

+0 

-0 

+0 

-0 

NaN 

NaN 

NaN 

-0 

-0 

+0 

-0 

+0 

NaN 

NaN 

NaN 

+00 

+00 

—00 

NaN 

NaN 

+00 

— 00 

NaN 

—00 

—00 

+00 

NaN 

NaN 

—00 

+00 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 


• Decimal multiplication: 

decimal operator *(decimal x, decimal y); 

If the resulting value is too large to represent in the decimal format, a System. Overflow- 
Exception is thrown. If fhe resulf value is too small to represenf in fhe decimal formal, 
fhe resulf is zero. The scale of fhe resulf, before any rounding, is fhe sum of fhe scales of 
fhe fwo operands. 

Decimal mulfiplicafion is equivalenf to using fhe mulfiplicafion operator of type 
System.Decimal. 


"■ PETER SESTOFT Where the text says "IEEE 754 floating point" here and else¬ 
where in this chapter, it would be more precise to say "IEEE 754 binary floating point," 
because the 2008 version of fhaf IEEE sfandard describes binary as well as decimal 
floating poinf, and fhose are very differenf fhings! 

Also, fhe following rule is prescribed by fhe IEEE 754 binary floafing poinf sfandard, 
and respected by fhe currenf Microsoft and Mono C# implemenfafions: Whenever one 
or more operands is a NaN, fhe resulf is a NaN, and the NaN payload of the result equals 
the payload of one of the NaN operands. The NaN payload of a 64-bif double consisfs of 
its 51 least significant bits (so a double can represent 251—roughly 2’*'101—different 
NaNs). The NaN payload of a 32-bif float consisfs of ifs 22 leasf significanf bifs (so a 
float can represenf 222—roughly 4*106—differenf NaNs). 

Continued 




333 


www.it-ebooks.info 


Expressions 






















Expressions 


7. Expressions 


The NaN payload preservation is important for efficient scientific computing. For fhis 
approach fo really work, in addifion fo fhe arifhmefic operafors, fhe mafhemafical 
funcfions in System. Math should respecf IEEE binary floating poinf as well. In fhe cur- 
renf implemenfafions, fhey mosfly do so. 

The .NET library provides a mefhod Sy stem. Double. IsNan(d) fo fesfwhefher a double 
is a NaN. 

Eor f 5 ^e double, if also provides mefhods DoubleToInt64Bits and Int64BitsToDouble 
fhaf can be used fo gef and sef NaN payload bifs: 

public static long GetNanPayload(double d) { 

return System.BitConverter.DoubleToInt64Bits(d) & 0X0007FFFFFFFFFFFF; 

} 

public static double MakeNanPayload(long nanbits) { 
nanbits &= 0X0007FFFFFFFFFFFF; 

nanbits |= System.BitConverter.DoubleToInt64Bits(Double.NaN); 
return System.BitConverter.Int64BitsToDouble(nanbits); 

} 

Sfrangely, fhe .NET library has no corresponding mefhods for fype float, buf one can 
use unsafe poinfer conversions fo achieve fhe same effecf. Eor fhe gory defails, see an 
annofafion on §18.4. 


7.8.2 Division Operator 

Eor an operation of fhe form x / y, binary operafor overload resolution (§7.3.4) is applied 
fo selecf a specific operafor implemenfafion. The operands are converfed fo fhe paramefer 
f57pes of fhe selecfed operafor, and fhe fype of fhe resulf is fhe refurn fype of fhe operafor. 

The predefined division operafors are lisfed below. The operafors all compufe fhe quofienf 
of X and y. 

• Infeger division: 

int operator /(int x, int y); 
uint operator /(uint x, uint y); 
long operator /(long x, long y); 
ulong operator /(ulong x, ulong y); 

If fhe value of fhe righf operand is zero, a System.DivideByZeroException is fhrown. 

The division rounds fhe resulf toward zero. Thus fhe absolufe value of fhe resulf is fhe 
largesf possible infeger fhaf is less fhan or equal fo fhe absolufe value of fhe quofienf of 
fhe fwo operands. The resulf is zero or positive when fhe fwo operands have fhe same 
sign and zero or negafive when fhe fwo operands have opposife signs. 


334 


www.it-ebooks.info 







7.8 Arithmetic Operators 


If the left operand is the smallest representable int or long value and the right operand is 
-1, an overflow occurs. In a checked context, this causes a System. ArithmeticException 
(or a subclass thereof) to be thrown. In an unchecked context, it is implementation-defined 
as to whether a System.ArithmeticException (or a subclass thereof) is thrown or the 
overflow goes imreported with the resulting value being that of the left operand. 

• Floating point division: 

float operator /(float x, float y); 
double operator /(double x, double y); 

The quotient is computed according to the rules of IEEE 754 arithmetic. The following 
table lists the results of all possible combinations of non-zero finite values, zeros, infini¬ 
ties, and NaNs. In the table, x and y are positive finite values; z is the result of x / y. If 
the result is too large for the destination t 5 q)e, z is infinity. If the result is too small for the 
destination type, z is zero. 



+y 

-y 

+0 

-0 

+00 

— 00 

NaN 

+x 

+Z 

-z 

+00 

— 00 

+0 

-0 

NaN 

-X 

-z 

+z 

— 00 

+00 

-0 

+0 

NaN 

+0 

+0 

-0 

NaN 

NaN 

+0 

-0 

NaN 

-0 

-0 

+0 

NaN 

NaN 

-0 

+0 

NaN 

+00 

+00 

—00 

+00 

— 00 

NaN 

NaN 

NaN 

—00 

— 00 

+00 

— 00 

+00 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 


• Decimal division: 

decimal operator /(decimal x, decimal y); 

If the value of the right operand is zero, a System. DivideByZeroException is thrown. If 
the resulting value is too large to represent in the decimal format, a System.Overflow- 
Exception is thrown. If the result value is too small to represent in the decimal format, 
the result is zero. The scale of the result is the smallest scale that will preserve a result 
equal to the nearest representable decimal value to the true mathematical result. 

Decimal division is equivalent to using the division operator of t 5 q)e System. Decimal. 


335 


www.it-ebooks.info 


Expressions 



















Expressions 


7. Expressions 


7.8.3 Remainder Operator 

For an operation of the form x % y, binary operator overload resolution (§7.3.4) is applied 
to select a specific operator implementation. The operands are converted to the parameter 
types of the selected operator, and the tj^e of the result is the return t 5 ^e of the operator. 

The predefined remainder operators are listed below. The operators all compute the 
remainder of the division between x and y. 

• Integer remainder: 

int operator %(int x, int y); 
uint operator %(uint x, uint y); 
long operator %(long x, long y); 
ulong operator %(ulong x, ulong y); 

The result of x % y is the value produced by x - (x / y) * y. If y is zero, a System. 
DivideByZeroException is thrown. 


"■ ERICLIPPERT Consider this code: 

static bool IsOdd(int x) { return x%2 == 1; } 

Is it correct? No! By the sentence above, this is the same as 
static bool IsOdd(int x) { return x-(x/2)*2 == 1; } 

which is false if x is -1. The correct code is 

static bool IsOdd(int x) { return x%2 [- 0; } 


If the left operand is the smallest int or long value and the right operand is -1, a Sys¬ 
tem . OvertlowException is thrown. In no case does x % y throw an exception where x / y 
would not throw an exception. 

• Floating point remainder: 

float operator %(float x, float y); 
double operator %(double x, double y); 

The following table lists the results of all possible combinafions of non-zero finite val¬ 
ues, zeros, infinities, and NaNs. In the table, x and y are positive finite values; z is the 
result of X % y and is computed as x - n * y, where n is the largest possible integer that 
is less than or equal to x / y. This method of computing the remainder is analogous to 
that used for integer operands, but differs from the IEEE 754 definition (in which n is 
the integer closest to x / y). 


336 


www.it-ebooks.info 






7.8 Arithmetic Operators 



+y 

-y 

+0 

-0 

+00 

— 00 

NaN 

+x 

+Z 

+z 

NaN 

NaN 

X 

X 

NaN 

-X 

-z 

-z 

NaN 

NaN 

-X 

-X 

NaN 

+0 

+0 

+0 

NaN 

NaN 

+0 

+0 

NaN 

-0 

-0 

-0 

NaN 

NaN 

-0 

-0 

NaN 

+00 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

—00 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 


• Decimal remainder: 

decimal operator %(decimal x, decimal y); 

If the value of the right operand is zero, a System.DivideByZeroException is thrown. 
The scale of the result, before any rounding, is the larger of the scales of the two oper¬ 
ands, and the sign of the result, if non-zero, is the same as that of x. 

Decimal remainder is equivalent to using the remainder operator of type System. 




“■ CHRIS SELLS The "remainder" operator is also known as "modulo" in other 
computer languages, sometimes denoted as "mod." If you're really a geek, you'll find 
yourself using "modulo" in (loosely) human sentences instead of the phrase "except 
for," as in "Modulo testing, debugging, and documentation, we're ready to ship!" 


7.8.4 Addition Operator 

For an operation of the form x + y, binary operator overload resolution (§7.3.4) is applied 
to select a specific operator implementation. The operands are converted to the parameter 
types of the selected operator, and the type of the result is the return type of the operator. 

The predefined addition operators are listed below. For numeric and enumeration t 5 q)es, 
the predefined addition operators compute the sum of the two operands. When one or 


337 


www.it-ebooks.info 


Expressions 





















Expressions 


7. Expressions 


both operands are of type string, the predefined addition operafors concafenafe fhe sfring 
represenfafion of fhe operands. 

• Infeger addition: 

int operator +(int x, int y); 
uint operator +(uint x, uint y); 
long operator +(long x, long y); 
ulong operator +(ulong x, ulong y); 

In a checked confexf, if fhe sum is oufside fhe range of fhe resulf type, a System. 
OvertlowException is thrown. In an unchecked context, overflows are nof reporfed and 
any significanf high-order bifs oufside fhe range of fhe resulf fype are discarded. 

• Floating poinf addition: 

float operator +(float x, float y); 
double operator +(double x, double y); 

The sum is compufed according fo fhe rules of IEEE 754 arifhmefic. The following fable 
lisfs fhe resulfs of all possible combinations of non-zero finife values, zeros, infinities, 
and NaNs. In fhe fable, x and y are non-zero finife values; z is fhe resulf of x + y. If x and 
y have fhe same magnifude buf opposife signs, z is positive zero. If x + y is foo large fo 
represenf in fhe desfinafion f 5 ^e, z is an infinify wifh fhe same sign as x + y. 



y 

+0 

-0 

+00 

— 00 

NaN 

X 

Z 

X 

X 

+00 

—00 

NaN 

+0 

y 

+0 

+0 

+00 

— 00 

NaN 

-0 

y 

+0 

-0 

+00 

— 00 

NaN 

+00 

+00 

+00 

+00 

+00 

NaN 

NaN 

— 00 

— 00 

— 00 

— 00 

NaN 

— 00 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 


• Decimal addition: 

decimal operator +(decimal x, decimal y); 

If fhe resulting value is foo large fo represenf in fhe decimal formaf, a System. Overflow- 
Exception is fhrown. The scale of fhe resulf, before any rounding, is fhe larger of fhe 
scales of fhe fwo operands. 


338 


www.it-ebooks.info 

















7.8 Arithmetic Operators 


Decimal addition is equivalent to using the addition operator of type System. Decimal. 

• Enumeration addition. Every enumeration type implicitly provides the following pre¬ 
defined operators, where E is fhe enum fype and U is fhe imderlying f 5 q)e of E: 

E operator +(E x, U y); 

E operator +(U x, E y); 

Af runfime, fhese operators are evaluated exacfly as (E)((U)x + (U)y). 


"■ BILL WAG N E R Once again, addifion on enumerations may nof resulf in a valid 
enumerafion member. The same is frue for all of fhe arifhmefic operafors. 


• Sfring concafenafion: 

string operator +(string x, string y); 
string operator +(string x, object y); 
string operator +(object x, string y); 


These overloads of fhe binary + operafor perform sfring concafenafion. If an operand of 
sfring concafenafion is null, an empfy sfring is subsfifufed. Ofherwise, any non-sfring 
argumenf is converted to ifs sfring represenfafion by invoking fhe virfual ToString 
method inherited from fype object. If ToString refurns null, an empfy sfring is 
subsfifufed. 


using System; 


class Test 
{ 

static void Main() { 


string s = null; 


Console.WritetineC's = 

>" + s 

int i = 1; 


Console.WriteLineC'i = 

" + i); 

float f = 1.2300E+15F; 


Console.WriteLineC'f = 

" + f); 

decimal d = 2.900m; 


Console.WritetineC'd = 

" + d); 


} 

} 


// Displays s = >< 

// Displays i = 1 

// Displays f = 1.23E+15 

// Displays d = 2.900 


The resulf of fhe sfring concafenafion operafor is a sfring fhaf consisfs of fhe characters 
of fhe leff operand followed by fhe characfers of fhe righf operand. The sfring concafe¬ 
nafion operafor never refums a null value. A System.OutOfMemoryException may be 
fhrown if fhere is nof enough memory available fo allocafe fhe resulting string. 




339 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


■■ JON SKEET It's slightly surprising that the .NET System.String t 5 ^e doesn't 
have an overload for + that would be used in this situation, until you consider the 
optimizations available to the compiler because it has visibility of more code. An 
expression such as a+b+c+d doesn'f have fo resulf in fhree infermediafe sfrings being 
producediAsinglecallfo String.Concatfa, b, c, d ) allows fhe concatenafion fo be 
performed more efficienfly. 


• Delegafe combination. Every delegafe f 5 ^e implicifly provides fhe following predefined 
operafor, where D is fhe delegafe f 5 ^e: 

D operator +(D x, D y); 

The binary + operafor performs delegafe combination when bofh operands are of some 
delegafe type D. (If fhe operands have differenf delegafe f 5 ^es, a binding-fime error 
occurs.) If fhe firsf operand is null, fhe resulf of fhe operafion is fhe value of fhe second 
operand (even if fhaf is also null). Ofherwise, if fhe second operand is null, fhen fhe 
resulf of fhe operafion is fhe value of fhe firsf operand. Ofherwise, fhe resulf of fhe 
operafion is a new delegafe insfance fhaf, when invoked, invokes fhe firsf operand and 
fhen invokes fhe second operand. Eor examples of delegafe combinafion, see §7.8.5 and 
§15.4. Since System.Delegate is nof a delegafe fype, operator + is nof defined for if. 

7.8.5 Subtraction Operator 

Eor an operafion of fhe form x - y, binary operafor overload resolution (§7.3.4) is applied 
fo selecf a specific operafor implemenfafion. The operands are converfed fo fhe paramefer 
f 5 ^es of fhe selecfed operafor, and fhe fype of fhe resulf is fhe refurn fype of fhe operafor. 

The predefined subfracfion operafors are lisfed below. The operafors all subfracf y from x. 

• Infeger subfracfion: 

int operator -(int x, int y); 
uint operator -(uint x, uint y); 
long operator -(long x, long y); 
ulong operator -(ulong x, ulong y); 

In a checked confexf, if fhe difference is oufside fhe range of fhe resulf fype, a System. 
OverflowException is fhrown. In an unchecked confexf, overflows are nof reporfed and 
any significanf high-order bifs oufside fhe range of fhe resulf fype are discarded. 

• Eloafing poinf subfracfion: 

float operator -(float x, float y); 
double operator -(double x, double y); 


340 


www.it-ebooks.info 






7.8 Arithmetic Operators 


The difference is compufed according fo fhe rules of IEEE 754 arifhmefic. The following 
fable lisfs fhe resulfs of all possible combinafions of non-zero finife values, zeros, infini- 
fies, and NaNs. In fhe fable, x and y are non-zero finife values; z is fhe resulf of x - y. If 
X and y are equal, z is posifive zero. If x - y is foo large fo represenf in fhe desfinafion 
fype, z is an infinify wifh fhe same sign as x - y. 



y 

+0 

-0 

+00 

— 00 

NaN 

X 

Z 

X 

X 

— 00 

+00 

NaN 

+0 

-y 

+0 

+0 

— 00 

+00 

NaN 

-0 

-y 

-0 

+0 

— 00 

+00 

NaN 

+00 

+00 

+00 

+00 

NaN 

+00 

NaN 

— 00 

— 00 

— 00 

— 00 

— 00 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 

NaN 


• Decimal subfracfion: 

decimal operator -(decimal x, decimal y); 

If fhe resulting value is foo large fo represenf in fhe decimal formaf, a System. Overflow- 
Exception is fhrown. The scale of fhe resulf, before any rounding, is fhe larger of fhe 
scales of fhe fwo operands. 

Decimal subfracfion is equivalenf fo using fhe subfracfion operator of fype System. 
Decimal. 

• Enumerafion subfracfion. Every enumerafion f 5 q)e implicifly provides fhe following 
predefined operafor, where E is fhe enum fype and U is fhe underlying f 5 q)e of E: 

U operator -(E x, E y); 

This operafor is evaluated exacfly as (U) ((U)x - (L))y). In ofher words, fhe operafor 
compufes fhe difference befween fhe ordinal values of x and y, and fhe type of the result 
is the underlying type of the enumeration. 

E operator -(E x, U y); 

This operator is evaluated exactly as (E)((U)x-y).In other words, the operator sub¬ 
tracts a value from the underlying type of the enumeration, yielding a value of the 
enumeration. 




341 


www.it-ebooks.info 


Expressions 

















Expressions 


7. Expressions 


• Delegate removal. Every delegate type implicitly provides the following predefined 
operafor, where D is fhe delegafe f 5 ^e: 

D operator -(D x, D y); 

The binary - operafor performs delegafe removal when bofh operands are of some del¬ 
egafe type D. If fhe operands have differenf delegafe fypes, a binding-time error occurs. 
If fhe firsf operand is null, fhe resulf of fhe operafion is null. Ofherwise, if fhe second 
operand is null, fhen fhe resulf of fhe operafion is fhe value of fhe firsf operand. Ofher¬ 
wise, bofh operands represenf invocafion lisfs (§15.1) having one or more enfries, and 
fhe resulf is a new invocafion lisf consisfing of fhe firsf operand's lisf wifh fhe second 
operand's enfries removed from if, provided fhe second operand's lisf is a proper con- 
figuous sublisf of fhe firsf's. (To defermine sublisf equalify corresponding enfries are 
compared as for fhe delegafe equalify operafor (§7.10.8).) Ofherwise, fhe resulf is fhe 
value of fhe leff operand. Neifher of fhe operands' lisfs is changed in fhe process. If fhe 
second operand's lisf mafches multiple sublisfs of contiguous enfries in fhe firsf oper¬ 
and's lisf, fhe righfmosf mafching sublisf of configuous enfries is removed. If removal 
resulfs in an empfy lisf, fhe resulf is null. For example: 

delegate void D(int x); 

class C 
{ 

public static void Ml(int i) {/*...*/ } 
public static void M2(int i) {/*...*/ } 

} 

class Test 
{ 

static void Main() { 

D cdl = new D(C.Ml); 

D cd2 = new D(C.M2); 


D cd3 = cdl 

+ cd2 

+ cd2 

+ cdl; 

// 

Ml 

+ 

M2 

+ 

M2 

+ 

Ml 

cd3 - 

cdl; 





// 

= > 

Ml 

+ 

M2 

+ 

M2 

cd3 = 

= cdl + 

cd2 + 

cd2 

+ 

cdl; 

// 

Ml 

+ 

M2 

+ 

M2 

+ 

Ml 

cd3 - 

•= cdl + 

cd2; 




// 

= > 

M2 

+ 

Ml 




cd3 = 

= cdl + 

cd2 + 

cd2 

+ 

cdl; 

// 

Ml 

+ 

M2 

+ 

M2 

+ 

Ml 

cd3 - 

II 

n 

Q. 

+ 

cd2; 




// 

= > 

Ml 

+ 

Ml 




cd3 = 

= cdl + 

cd2 + 

cd2 

+ 

cdl; 

// 

Ml 

+ 

M2 

+ 

M2 

+ 

Ml 

cd3 - 

•= cd2 + 

cdl; 




// 

= > 

Ml 

+ 

M2 




cd3 = 

= cdl + 

cd2 + 

cd2 

+ 

cdl; 

// 

Ml 

+ 

M2 

+ 

M2 

+ 

Ml 

cd3 - 

•= cdl + 

cdl; 




// 

= > 

Ml 

+ 

M2 

+ 

M2 + Ml 


} 

} 


342 


www.it-ebooks.info 




7.9 Shift Operators 


7.9 Shift Operators 

The << and >> operators are used to perform bit shifting operations. 

shift-expression: 

additive-expression 

shift-expression « additive-expression 
shift-expression right-shift additive-expression 

If an operand of a shift-expression has fhe compile-fime t 5 ^e dynamic, fhen fhe expression is 
dynamically bound (§7.2.2). In fhis case, fhe compile-fime fype of fhe expression is dynamic, 
and fhe resolufion described below will fake place af runfime using fhe runfime t 5 ^e of 
fhose operands fhaf have fhe compile-fime type dynamic. 

For an operation of fhe form x << count or x >> count, binary operator overload resolufion 
(§7.3.4) is applied to selecf a specific operator implemenfafion. The operands are converfed 
fo fhe paramefer fypes of fhe selecfed operafor, and fhe fype of fhe resulf is fhe refurn fype 
of fhe operafor. 

When declaring an overloaded shift operator, the t 5 ^e of fhe firsf operand musf always be 
fhe class or sfrucf confaining fhe operafor declarafion, and fhe t 5 ^e of fhe second operand 
musf always be int. 

The predefined shiff operators are lisfed below. 




int operator <<(int x, int count); 
uint operator <<(uint x, int count); 
long operator <<(long x, int count); 
ulong operator <<(ulong x, int count); 

The << operafor shiffs x left by a number of bifs compufed as described below. 

The high-order bifs oufside fhe range of fhe resulf type of x are discarded, fhe remaining 
bifs are shifted leff, and fhe low-order empfy bif positions are sef fo zero. 

• Shiff righf: 

int operator >>(int x, int count); 
uint operator >>(uint x, int count); 
long operator >>(long x, int count); 
ulong operator >>(ulong x, int count); 

The >> operafor shiffs x righf by a number of bifs compufed as described below. 


343 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


When X is of type int or long, the low-order bits of x are discarded, the remaining bits 
are shifted right, and the high-order empty bit positions are set to zero if x is non-nega¬ 
tive and set to 1 if x is negative. 

When X is of type uint or ulong, the low-order bits of x are discarded, the remaining bits 
are shifted right, and the high-order empty bit positions are set to zero. 

For the predefined operators, the number of bits to shift is computed as follows: 

• When the t 5 ^e of x is int or uint, the shift count is given by the low-order five bits of 
count. In other words, the shift count is computed from count & 0xlF. 

• When the type of x is long or ulong, the shift count is given by the low-order six bits of 
count. In other words, the shift count is computed from count & 0x3F. 

If the resulting shift count is zero, the shift operators simply return the value of x. 


“■ JON SKEET Masking the shift count may be efficient, but it can make for some 
very confusing behavior: 


for (int i = 0; i < 40; i++) 

{ 

Console.WriteLine(int.MaxValue >> i); 

} 


This code prints values that are halved on each iteration—until they cycle back to int. 
MaxValue after reaching 0. 


Shift operations never cause overflows and produce the same results in checked and 
unchecked contexts. 

When the left operand of the >> operator is of a signed integral type, the operator performs 
an arithmetic shift right wherein the value of the most significant bit (the sign bit) of the 
operand is propagated to the high-order empty bit positions. When the left operand of the 
>> operator is of an imsigned integral t 5 ^e, the operator performs a logical shift right 
wherein high-order empty bit positions are always set to zero. To perform the opposite 
operation of that inferred from the operand t 5 ^e, explicit casts can be used. For example, 
if X is a variable of type int, the operation unchecked ((int) ((uint)x >> y)) performs a 
logical shift right of x. 


7.10 Relational and Type-Testing Operators 

The ==, !=, <, >, <=, >=, is, and as operators are called the relational and type-testing 
operators. 


344 


www.it-ebooks.info 






7.10 Relational and Type-Testing Operators 


relational-expression: 

shift-expression 

relational-expression 

relational-expression 

relational-expression 

relational-expression 

relational-expression 

relational-expression 

equality-expression: 

relational-expression 

equality-expression 

equality-expression 


< shift-expression 
> shift-expression 
<= shift-expression 
>= shift-expression 
is type 
as type 


== relational-expression 
! = relational-expression 


The is operator is described in §7.10.10 and the as operator is described in §7.10.11. 


The !=, <, >, <=, and >= operators are comparison operators. 


If an operand of a comparison operator has the compile-time type dynamic, then the expres¬ 
sion is d 5 mamically bound (§7.2.2). In this case, the compile-time type of the expression is 
dynamic, and the resolution described below will take place at runtime using the runtime 
type of those operands that have the compile-time type dynamic. 

For an operation of the form x op y, where op is a comparison operator, overload resolution 
(§7.3.4) is applied to select a specific operator implementation. The operands are converted 
to the parameter types of the selected operator, and the t 5 ^e of the result is the return type 
of the operator. 

The predefined comparison operators are described in the following sections. All pre¬ 
defined comparison operators return a result of t 5 ^e bool, as described in the following 
fable. 


Operation 

Result 

x==y 

true if X is equal to y, false otherwise 

X ! = y 

true if X is not equal to y, false otherwise 

X < y 

true if X is less than y, false otherwise 

X > y 

true if X is greater than y, false otherwise 

X <= y 

true if X is less than or equal to y, false otherwise 

X >= y 

true if X is greater than or equal to y, false otherwise 




345 


www.it-ebooks.info 


Expressions 












Expressions 


7. Expressions 


7.10.1 Integer Comparison Operators 

The predefined integer comparison operators are listed here: 


bool operator 
bool operator 
bool operator 
bool operator 


==(int X, int y); 
==(uint Xj uint y); 
==(long X, long y); 
==(ulong Xj ulong y); 


bool operator 
bool operator 
bool operator 
bool operator 


=(int Xj int y); 
=(uint Xj uint y); 
=(long X, long y); 
=(ulong X, ulong y); 


bool operator 
bool operator 
bool operator 
bool operator 


<(lnt X, int y); 
<(uint X, uint y); 
<(long X, long y); 
<(ulong X, ulong y); 


bool operator 
bool operator 
bool operator 
bool operator 


>(lnt X, int y); 
>(uint X, uint y); 
>(long X, long y); 
>(ulong X, ulong y); 


bool operator 
bool operator 
bool operator 
bool operator 


<=(int X, int y); 
<=(uint X, uint y); 
<=(long X, long y); 
<=(ulong X, ulong y); 


bool operator 
bool operator 
bool operator 
bool operator 


>=(int X, int y); 
>=(uint X, uint y); 
>=(long X, long y); 
>=(ulong X, ulong y); 


Each of these operators compares the numeric values of the two integer operands and 
returns a bool value that indicates whether the particular relation is true or false. 


7.10.2 Floating Point Comparison Operators 

The predefined floating point comparison operators are listed here: 


bool operator ==(float x, float y); 
bool operator ==(double x, double y); 


bool operator !=(float x, float y); 
bool operator !=(double x, double y); 


bool operator <(float x, float y); 
bool operator <(double x, double y); 


bool operator >(float x, float y); 
bool operator >(double x, double y); 


bool operator <=(float x, float y); 
bool operator <=(double x^ double y); 


bool operator >=(float x, float y); 
bool operator >=(double x, double y); 


346 


www.it-ebooks.info 





7.10 Relational and Type-Testing Operators 


These operators compare the operands according to the rules of the IEEE 754 standard: 

• If eifher operand is NaN, fhe resulf is false for all operafors excepf ! =, for which fhe 
resulf is true. Eor any fwo operands, x ! = y always produces fhe same resulf as ! (x == 
y). However, when one or bofh operands are NaN, fhe <, >, <=, and >= operafors do not 
produce fhe same resulfs as fhe logical negation of fhe opposife operator. Eor example, 
if eifher of x and y is NaN, fhen x < y is false, buf ! (x >= y) is true. 

• When neifher operand is NaN, fhe operafors compare fhe values of fhe fwo floafing 
poinf operands wifh respecf fo fhe ordering 

< -max < ... < -min < -0.0 == +0.0 < +min < ... < +max < +~ 

where min and max are, respecfively, fhe smallesf and largesf posifive finife values fhaf 
can be represented in fhe given floafing poinf formaf. Nofable effecfs of fhis ordering are 
as follows: 

- Negative and posifive zeros are considered equal. 

- A negative infinify is considered less fhan all ofher values, buf equal fo anofher nega- 
five infinify. 

- A posifive infinify is considered greafer fhan all ofher values, buf equal fo anofher 
posifive infinify. 


"■ PETER SESTOFT If also holds fhaf posifive and negafive zero are equal by 
Object. Equals, so fheir hashcodes as computed by Object .GetHashCode should be 
equal as well. Unforfunafely, fhis is nof fhe case in all currenf implemenfafions. 


■■ JOSEPH ALBAHARl Two NaN values, alfhough unequal according fo fhe == 
operator, are equal according fo fhe Equals mefhod: 

double X = double.NaN; 

Console.WriteLine(x == x); // False 

Console.WriteLine(x != x); // True 

Console.WriteLine(x.Equals(x)); // True 

In general, a fype's Equals mefhod follows fhe principle fhaf an objecf musf equal 
ifself. Wifhouf fhis assumption, lisfs and dicfionaries could nof operafe, because fhere 
would be no means for festing elemenf membership. The == and ! = operafors, how¬ 
ever, are nof obliged fo follow fhis principle. 




"■ PETER SESTOFT Even NaNs fhaf have differenf payloads (see fhe annofafion on 
§7.8.1) are equal by Object. Equals. 


347 


www.it-ebooks.info 


Expressions 










Expressions 


7. Expressions 


7.10.3 Decimal Comparison Operators 

The predefined decimal comparison operators are listed here: 

bool operator ==(decirral x, decimal y); 
bool operator !=(decimal x, decimal y); 
bool operator <(decimal x, decimal y); 
bool operator >(decimal x, decimal y); 
bool operator <=(decimal x, decimal y); 
bool operator >=(decimal x, decimal y); 

Each of these operators compares the numeric values of the two decimal operands and 
returns a bool value that indicates whether the particular relation is true or false. Each 
decimal comparison is equivalent to using the corresponding relational or equality opera¬ 
tor of t 5 rpe System.Decimal. 


7.10.4 Boolean Equality Operators 

The predefined boolean equality operators are listed here: 

bool operator ==(bool x, bool y); 
bool operator !=(bool x, bool y); 

The result of == is true if both x and y are true or if both x and y are false. Otherwise, the 
result is false. 

The result of ! = is false if both x and y are true or if both x and y are false. Otherwise, the 
result is true. When the operands are of type bool, the ! = operator produces the same 
result as the operator. 


7.10.5 Enumeration Comparison Operators 

Every enumeration type implicitly provides the following predefined comparison 
operators: 

bool operator ==(E x, E y); 
bool operator !=(E x, E y); 
bool operator <(E x, E y); 
bool operator >(E x, E y); 
bool operator <=(E x, E y); 
bool operator >=(E x, E y); 

The result of evaluating x op y, where x and y are expressions of an enumeration type E 
with an underlying t 5 q)e U, and op is one of the comparison operators, is exactly the same 
as evaluating ((U)x) op ((U)y).In other words, the enumeration type comparison opera¬ 
tors simply compare the underlying integral values of the two operands. 


348 


www.it-ebooks.info 




7.10 Relational and Type-Testing Operators 


7.10.6 Reference Type Equality Operators 

The predefined reference type equality operators are listed here: 

bool operator ==(object x, object y); 
bool operator !=(object x, object y); 

The operators return the result of comparing the two references for equality or non¬ 
equality. 

Since the predefined reference t 5 q)e equality operators accept operands of type object, 
they apply to all tjq^es that do not declare applicable operator == and operator ! = mem¬ 
bers. Conversely, any applicable user-defined equality operators effectively hide the pre¬ 
defined reference tjqie equality operators. 

The predefined reference type equality operators require one of the following: 

• Both operands are a value of a type known to be a reference-type or the literal null. Fur¬ 
thermore, an explicit reference conversion (§6.2.4) exists from the t 5 q)e of either operand 
to the tjqie of the other operand. 

• One operand is a value of type T, where T is a type-parameter and the other operand is the 
literal null. Furthermore, T does not have the value t 5 q)e constraint. 

Unless one of these conditions are true, a binding-time error occurs. Notable implications 
of these rules are as follows: 

• It is a binding-time error to use the predefined reference t 5 q)e equality operators to com¬ 
pare two references that are known to be different at binding time. For example, if the 
binding-time t 5 q)es of the operands are two class types A and B, and if neither A nor B 
derives from the other, then it would be impossible for the two operands to reference the 
same object. Thus the operation is considered a binding-time error. 

• The predefined reference type equality operators do not permit value type operands to 
be compared. Therefore, unless a struct tjq^e declares its own equality operators, it is not 
possible to compare values of that struct type. 

• The predefined reference tjq^e equality operators never cause boxing operations to occur 
for their operands. It would be meaningless to perform such boxing operations, since 
references to the newly allocated boxed instances would necessarily differ from all other 
references. 

• If an operand of a t 5 q)e parameter tjq^e T is compared to null, and the rimtime type of T 
is a value type, the result of the comparison is false. 




349 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


The following example checks whether an argument of an unconstrained type parameter 
type is null. 

class C<T> 

{ 

void F(T x) { 

if (x == null) throw new ArgumentNullException(); 


} 

} 

The X == null construct is permitted even though T could represent a value t 5 ^e, and the 
result is simply defined to be false when T is a value type. 


"■ BILL WAGNER If C.F() is called with default (int?), it will throw an exception. 
A nullable t 5 ^e is considered equal to null if HasValue is false. 


For an operation of the form x == y or x ! = y, if any applicable operator == or operator ! = 
exists, the operator overload resolution (§7.3.4) rules will select that operator instead of the 
predefined reference type equality operator. However, it is always possible to select the 
predefined reference type equality operator by explicitly casting one or both of the oper¬ 
ands to t 5 q)e object. The example 

using System; 

class Test 
{ 

static void Main() 

{ 

string s = "Test"; 
string t = string.Copy(s); 

Console.WriteLine(s == t); 

Console.WriteLlne((object)s == t); 

Console.WriteLlne(s == (object)t); 

Console.WriteLine((object)s == (object)t); 

} 

} 

produces the output 

True 

False 

False 

False 


350 


www.it-ebooks.info 






7.10 Relational and Type-Testing Operators 


The s and t variables refer to two distinct string instances containing the same characters. 
The first comparison outputs True because the predefined string equality operator (§7.10.7) 
is selected when both operands are of type string. The remaining comparisons all output 
False because the predefined reference type equality operator is selected when one or both 
of the operands are of type object. 

Note that the above technique is not meaningful for value types. The example 

class Test 
{ 

static void Main() 

{ 

int i = 123; 
int j = 123; 

System.Console.WriteLine((object)i == (object)j); 

} 

} 

outputs False because the casts create references to two separate instances of boxed int 
values. 


7.10.7 String Equality Operators 

The predefined string equality operators are listed here: 

bool operator ==(string x, string y); 
bool operator !=(string x, string y); 

Two string values are considered equal when one of the following is true: 

• Both values are null. 

• Both values are non-null references to string instances that have identical lengths and 
identical characters in each character position. 

The string equality operators compare string values rather than string references. When two 
separate string instances contain the exact same sequence of characters, the values of the 
strings are equal, but the references are different. As described in §7.10.6, the reference type 
equality operators can be used to compare string references instead of string values. 




7.10.8 Delegate Equality Operators 

Every delegate t 5 q)e implicitly provides the following predefined comparison operators: 

bool operator ==(System.Delegate x. System.Delegate y); 
bool operator !=(System.Delegate x. System.Delegate y); 


351 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


Two delegate instances are considered equal in the following circumstances: 

• If eifher of fhe delegafe insfances is null, fhey are equal if and only if bofh are null. 

• If fhe delegafes have differenf runtime f 5 q)es, fhey are never equal. 

• If bofh of fhe delegafe insfances have an invocation lisf (§15.1), fhose insfances are equal 
if and only if fheir invocafion lisfs are fhe same lengfh, and each enfry in one's invoca- 
fion lisf is equal (as defined below) fo fhe corresponding enfry, in order, in fhe ofher's 
invocafion lisf. 

The following rules govern fhe equalify of invocation list entries: 

• If fwo invocafion lisf enfries bofh refer fo fhe same sfafic mefhod, fhen fhe enfries are 
equal. 

• If fwo invocafion lisf enfries bofh refer fo fhe same non-sfafic mefhod on fhe same fargef 
objecf (as defined by fhe reference equalify operafors), fhen fhe enfries are equal. 

• Invocafion lisf enfries produced from evaluation of semanfically idenfical anonymous- 
function-expressions wifh the same (possibly empty) set of capfured oufer variable 
insfances are permitted (buf nof required) fo be equal. 

7.10.9 Equality Operators and null 

The == and ! = operafors permif one operand fo be a value of a nullable type and the other 
to be the null literal, even if no predefined or user-defined operafor (in unliffed or tiffed 
form) exisfs for fhe operation. 

For an operafion of one of fhe forms 

X == null null == X x != null null != x 

where x is an expression of a nullable t 5 q)e, if operafor overload resolution (§7.2.4) fails fo 
find an applicable operafor, fhe resulf is insfead compufed from fhe HasValue properfy of 
X. Specifically, fhe firsf fwo forms are franslafed info ! x. HasValue, and lasf fwo forms are 
franslafed info x. HasValue. 


7.10.10 The is Operator 

The is operafor is used fo dynamically check if fhe runfime t 5 q)e of an objecf is compaf- 
ible wifh a given type. The result of fhe operafion E is T, where E is an expression and T 
is a type, is a boolean value indicating whether E can successfully be converfed fo type T 
by a reference conversion, a boxing conversion, or an unboxing conversion. The opera¬ 
fion is evaluafed as follows, affer type arguments have been substituted for all type 
parameters: 


352 


www.it-ebooks.info 




7.10 Relational and Type-Testing Operators 


• If E is an anonymous function, a compile-time error occurs. 

• If E is a method group or the null literal, of if the type of E is a reference t 5 ^e or a nullable 
type and the value of E is null, the result is false. 

• Otherwise, let D represent the d 5 mamic t 5 ^e of E as follows: 

- If the type of E is a reference type, D is the runtime type of the instance reference 
by E. 

- If the t5^e of E is a nullable type, D is the underlying type of that nullable type. 

- If the type of E is a non-nullable value t5^e, D is the type of E. 

• The result of the operation depends on D and T as follows: 

- If T is a reference type, the result is true if D and T are the same type, if D is a reference 
type and an implicit reference conversion from D to T exists, or if D is a value type and 
a boxing conversion from D to T exists. 

- If T is a nullable t5^e, the result is true if D is the underlying t5^e of T. 

- If T is a non-nullable value type, the result is true if D and T are the same type. 

- Otherwise, the result is false. 

Note that user-defined conversions are not considered by the is operator. 

7.10.11 The as Operator 

The as operator is used to explicitly convert a value to a given reference type or nullable 
type. Unlike a cast expression (§7.7.6), the as operator never throws an exception. Instead, 
if the indicated conversion is not possible, the resulting value is null. 

In an operation of the form E as T, E must be an expression and T must be a reference type, 
a t 5 ^e parameter known to be a reference type, or a nullable type. Furthermore, at least one 
of the following must be true, or otherwise a compile-time error occurs: 

• An identity (§6.1.1), implicit nullable (§6.1.4), implicit reference (§6.1.6), boxing (§6.1.7), 
explicit nullable (§6.2.3), explicit reference (§6.2.4), or unboxing (§6.2.5) conversion exists 
from E to T. 

• The t 5 ^e of E or T is an open t 5 ^e. 

• E is the null literal. 

If the compile-time type of E is not dynamic, the operation E as T produces the same 
result as 

E is T ? (T)(E) : (T)null 




353 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


except that E is evaluated only once. The compiler can be expected to optimize E as T to 
perform at most one dynamic type check as opposed to the two d 5 mamic type checks 
implied by the expansion above. 

If the compile-time t 5 ^e of E is dynamic, imlike fhe cast operator, the as operator is not 
dynamically boimd (§7.2.2). Therefore fhe expansion in fhis case is 

E is T ? (T)(object)(E) : (T)null 

Note that some conversions, such as user-defined conversions, are not possible with the as 
operator and should instead be performed using cast expressions. 

In the example 

class X 
{ 

public string F(object o) { 
return o as string; 

//Okay: string is a reference type 

} 

public T G<T>(object o) where T: Attribute { 
return o as T; 

// Okay: T has a class constraint 

} 

public U H<U>(object o) { 
return o as U; 

// Error: U is unconstrained 

} 

} 

the type parameter T of G is known to be a reference type, because it has the class con¬ 
straint. The type parameter U of H is not known, however; hence the use of fhe as operator 
in H is disallowed. 


"■ CHRIS SELLS If you're using FxCop (and you should be!) out of fhe box, it 
doesn't like it when you do this: 

if( X is Foo ) { ((Foo)x).DoFoo(); } 

Instead, it prefers thaf you do fhis: 

Foo foo = X as Foo; 

if( foo != null ) { foo.DoFooO; } 

Why? Because is, as, and casting are all essentially the same underlying .NET opera¬ 
tion, so it's better that you perform the operation once, check the result for null, and 
fhen do something with the non-null result than that you perform the operation twice. 


354 


www.it-ebooks.info 






7.11 Logical Operators 


"■ JOSEPH ALBAHARI Although Chris is technically right, this is a micro¬ 
optimization. Reference conversions are cheap. 


"■ CHRIS SELLS Although Joseph is absolutely right, I was talking more about 
keeping FxCop off my back fhan optimizing for performance. 


■■ JOSEPH ALBAHARI Some people prefer fhe as operafor over fhe casf operafor as 
a maffer of sfyle. An advanfage of fhe as operafor is fhaf ifs use makes if clear fhaf fhe 
conversion is nof a numeric or user-defined conversion. The problem wifh universally 
favoring fhe as operafor for reference conversions, however, is fhaf if's nof always 
desirable fo have a failed conversion evaluafe fo null. To illusfrafe, consider fhe ouf- 
come of fhe following code if fhe objecf referenced by s is not a siring: 

int lengthl = ((string) s).Length; // Throws InvalidCastException 

int length2 = (s as string).Length; // Throws NullReferenceException 

The firsf line fhrows a usefully populafed InvalidCastException, whereas fhe second 
line throws an (ambiguous) NullReferenceException. (Was s null or the wrong type?) 


■■ JONSKEET The as operator is almost always used with a nullity test afterward— 
to the extent that it almost deserves its own statement t 5 ^e: 

// Would be equivalent to the code in Chris's annotation 
asif (Foo foo = x) 

{ 

foo.DoFooO; 

} 

Having a whole extra kind of sfafemenf would probably be overkill—buf fhe clumsi¬ 
ness of fhe currenf pattern is irrifafing. 




7.11 Logical Operators 

The &,and | operators are called fhe logical operafors. 

and-expression: 

equality-expression 

and-expression & equality-expression 


355 


www.it-ebooks.info 


Expressions 












Expressions 


7. Expressions 


exdusive-or-expression: 

and-expression 

exdusive-or-expression and-expression 

indusive-or-expression: 

exdusive-or-expression 

indusive-or-expression | exdusive-or-expression 

If an operand of a logical operafor has fhe compile-fime type dynamic, then the expression 
is dynamically bound (§7.2.2). In this case, the compile-time type of the expression is 
dynamic, and the resolution described below will take place at runtime using the runtime 
type of those operands that have the compile-time type dynamic. 

For an operation of the form x op y, where op is one of the logical operators, overload reso¬ 
lution (§7.3.4) is applied to select a specific operator implementation. The operands are 
converted to the parameter types of the selected operator, and the type of the result is the 
return t 5 ^e of the operator. 

The predefined logical operators are described in the following sections. 


7.11.1 Integer Logical Operators 

The predefined integer logical operators are listed here: 

int operator &(int x, int y); 
uint operator &(uint x, uint y); 
long operator &(long x, long y); 
ulong operator &(ulong x, ulong y); 

int operator |(int x, int y); 
uint operator |(uint x, uint y); 
long operator |(long x, long y); 
ulong operator |(ulong x, ulong y); 

int operator ''(int x, int y); 
uint operator ''(uint x, uint y); 
long operator ''(long x, long y); 
ulong operator ''(ulong x, ulong y); 

The & operator computes the bitwise logical AND of the two operands, the | operator com¬ 
putes the bitwise logical OR of the two operands, and the operator computes the bitwise 
logical exclusive OR of the two operands. No overflows are possible from these operations. 


7.11.2 Enumeration Logical Operators 

Every enumeration t5^e E implicitly provides the following predefined logical operators: 


E operator &(E x, 
E operator |(E x, 
E operator ''(E x. 


E y); 
E y); 
E y); 


356 


www.it-ebooks.info 




7.11 Logical Operators 


The result of evaluating x op y, where x and y are expressions of an enumeration type E 
with an underlying type U, and op is one of the logical operators, is exactly the same as 
evaluating (E) ((U) x op (U) y ). In other words, the enumeration t 5 ^e logical operators sim¬ 
ply perform the logical operation on the underlying t 5 ^e of the two operands. 

7.11.3 Boolean Logical Operators 

The predefined boolean logical operators are listed here: 

bool operator &(bool x, bool y); 
bool operator |(bool x, bool y); 
bool operator ''(bool x, bool y); 

The result of x & y is true if both x and y are true. Otherwise, the result is false. 

The result of x | y is true if either x or y is true. Otherwise, the result is false. 

The result of x '' y is true if x is true and y is false, or if x is false and y is true. Otherwise, 
the result is false. When the operands are of type bool, the operator computes the same 
result as the ! = operator. 

7.11.4 Nullable Boolean Logical Operators 

The nullable boolean type bool? can represent three values: true, false, and null. It is 
conceptually similar to the three-valued type used for boolean expressions in SQL. To 
ensure that the results produced by the & and | operators for bool ? operands are consistent 
with SQL's three-valued logic, the following predefined operators are provided: 

bool? operator &(bool? x, bool? y); 
bool? operator |(bool? x, bool? y); 

The following table lists the results produced by these operators for all combinations of the 
values true, false, and null. 


X 

y 

X & y 

X 1 y 

true 

true 

true 

true 

true 

false 

false 

true 

true 

null 

null 

true 

false 

true 

false 

true 

false 

false 

false 

false 

false 

null 

false 

null 

null 

true 

null 

true 

null 

false 

false 

null 

null 

null 

null 

null 




357 


www.it-ebooks.info 


Expressions 

















Expressions 


7. Expressions 


7.12 Conditional Logical Operators 

The && and | | operators are called the conditional logical operators. They are also called 
the "short-circuiting" logical operators. 

conditional-and-expression: 
inclus ive-or-express ion 

conditional-and-expression && inclusive-or-expression 

conditional-or-expression: 

conditional-and-expression 

conditional-or-expression \ \ conditional-and-expression 
The && and | | operators are conditional versions of the & and | operators: 

• The operation x && y corresponds to the operation x & y, except that y is evaluated only 
if X is nof false. 

• The operafion x | | y corresponds fo fhe operation x | y, excepf fhaf y is evaluafed only 
if X is nof true. 

If an operand of a condifional logical operafor has fhe compile-fime t 5 ^e dynamic, fhen fhe 
expression is dynamically bound (§7.2.2). In fhis case, fhe compile-fime fype of fhe expres¬ 
sion is dynamic, and fhe resolufion described below will fake place af runtime using fhe 
runfime t 5 ^e of fhose operands fhaf have fhe compile-fime type dynamic. 

An operation of fhe form x && y or x | | y is processed by applying overload resolufion 
(§7.3.4) as if fhe operafion was wriffen x & y or x | y. Then, 

• If overload resolufion fails fo find a single besf operafor, or if overload resolufion selecfs 
one of fhe predefined infeger logical operafors, a binding-time error occurs. 

• Ofherwise, if fhe selecfed operafor is one of fhe predefined boolean logical operafors 
(§7.11.3) or nullable boolean logical operafors (§7.11.4), fhe operafion is processed as 
described in §7.12.1. 

• Ofherwise, fhe selecfed operafor is a user-defined operafor, and fhe operafion is pro¬ 
cessed as described in §7.12.2. 

If is nof possible fo direcfly overload fhe condifional logical operafors. However, because 
fhe condifional logical operafors are evaluafed in ferms of fhe regular logical operafors, 
overloads of fhe regular logical operafors are, wifh cerfain resfricfions, also considered 
overloads of fhe condifional logical operafors. This sifnation is described furfher in 
§7.12.2. 


358 


www.it-ebooks.info 




7.12 Conditional Logical Operators 


7.12.1 Boolean Conditional Logical Operators 

When the operands of && or | | are of t 5 ^e bool, or when the operands are of types that do 
not define an applicable operator & or operator | but do define implicit conversions to 
bool, the operation is processed as follows: 

• The operation x && y is evaluated as x ? y : false. In other words, x is first evaluated and 
converted to type bool. Then, if x is true, y is evaluated and converted to t 5 ^e bool, and 
this becomes the result of the operation. Otherwise, the result of the operation is false. 

• The operation x | | y is evaluated as x ? true : y. In other words, x is first evaluated and 
converted to t 5 ^e bool. Then, if x is true, the result of the operation is true. Otherwise, 
y is evaluated and converted to t 5 ^e bool, and this becomes the result of the operation. 


7.12.2 User-Defined Conditional Logical Operators 

When the operands of && or | | are of types that declare an applicable user-defined 
operator & or operator | , both of the following must be true, where T is the t 5 ^e in which 
the selected operator is declared: 

• The return type and the type of each parameter of the selected operator must be T. In 
other words, the operator must compute the logical AND or the logical OR of two operands 
of type T, and must return a result of t 5 ^e T. 

• T must contain declarations of operator true and operator false. 

A binding-time error occurs if either of these requirements is not satisfied. Otherwise, the 
&& or I I operation is evaluated by combining the user-defined operator true or operator 
false with the selected user-defined operator: 

• The operation X && y is evaluated as T.false(x) ?x : T.&(x, y), where T.false(x) is an 
invocation of the operator false declared in T, and T.&(x, y) is an invocation of the 
selected operator &. In other words, x is first evaluated and operator false is invoked 
on the result to determine if x is definitely false. Then, if x is definitely false, the result of 
the operation is the value previously computed for x. Otherwise, y is evaluated, and the 
selected operator & is invoked on the value previously computed for x and the value 
computed for y to produce the result of the operation. 

• The operation x | | y is evaluated as T.true(x) ? x : T. | (x, y), where T.true(x) is an 
invocation of the operator true declared in T, and T. | (x, y) is an invocation of the 
selected operator |. In other words, x is first evaluated and operator true is invoked on 
the result to determine if x is definitely true. Then, if x is definitely true, the result of the 
operation is the value previously computed for x. Otherwise, y is evaluated, and the 
selected operator | is invoked on the value previously computed for x and the value 
computed for y to produce the result of the operation. 




359 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


In either of these operations, the expression given by x is evaluated only once, and the 
expression given by y is either not evaluated or evaluated exactly once. 

For an example of a t 5 ^e that implements operator true and operator false, see §11.4.2. 


7.13 The Null Coalescing Operator 

The ? ? operator is called the null coalescing operator. 

null-coalescing-expression: 

conditional-or-expression 

conditional-or-expression ?? null-coalescing-expression 

A null coalescing expression of the form a ? ? b requires a to be of a nullable t 5 q)e or refer¬ 
ence t 5 q)e. If a is non-null, the result of a ? ? b is a; otherwise, the result is b. The operation 
evaluates b only if a is null. 

The null coalescing operator is right-associative, meaning that operations are grouped 
from right to left. For example, an expression of the form a??b??cis evaluated as a ? ? (b 
? ? c). In general terms, an expression of the form ?? ??...?? returns the first of the 

operands that is non-null, or returns null if all operands are null. 

The t 5 q)e of the expression a ? ? b depends on which implicit conversions are available on 
the operands. In order of preference, the type of a ? ? b is A^, A, or B, where A is the type of a 
(provided that a has a type), B is the type of b (provided that b has a t 5 q)e), and is the 
underlying type of A if A is a nullable t 5 q)e, or A otherwise. Specifically, a ? ? b is processed 
as follows: 

• If A exists and is not a nullable t5q)e or a reference type, a compile-time error occurs. 

• If b is a d 5 mamic expression, the result t 5 q)e is dynamic. At runtime, a is first evaluated. 
If a is not null, a is converted to a dynamic t 5 q)e, and this becomes the result. Otherwise, 
b is evaluated, and the outcome becomes the result. 

• Otherwise, if A exists and is a nullable t 5 q)e and an implicit conversion exists from b to 
Ag, the result t 5 q)e is A^. At runtime, a is first evaluated. If a is not null, a is unwrapped to 
type Ag, and it becomes the result. Otherwise, b is evaluated and converted to type A^, 
and it becomes the result. 

• Otherwise, if A exists and an implicit conversion exists from b to A, the result t 5 q)e is A. 
At runtime, a is first evaluated. If a is not null, a becomes the result. Otherwise, b is 
evaluated and converted to 1)^)0 A, and it becomes the result. 


360 


www.it-ebooks.info 




7.14 Conditional Operator 


• Otherwise, if b has a t 5 ^e B and an implicit conversion exists from a to B, the result type 
is B. At runtime, a is first evaluated. If a is not null, a is unwrapped to t 5 ^e (if A exists 
and is nullable) and converted to type B, and it becomes the result. Otherwise, b is 
evaluated and becomes the result. 

• Otherwise, a and b are incompatible, and a compile-time error occurs. 


"■ ERIC LIPPERT These conversion rules considerably complicate the transforma¬ 
tion of a null coalescing operator into an expression tree. In some cases, the compiler 
must emit an additional expression tree lambda specifically to handle the conversion 
logic. 


"■ CHRIS SELLS The ? ? operator is useful for setting default values for reference 
types or nullable value t5q3es. For example: 


Foo fl = ...; 

Foo f2 = fl ?? new Foo(...); 

int? il = ...; 

int i2 = il ?? 452; 


7.14 Conditional Operator 

The ?: operator is called the conditional operator or, sometimes, the ternary operator. 

conditional-expression: 

null-coalescing-expression 

null-coalescing-expression ? expression : expression 

A conditional expression of the form b ? x : y first evaluates the condition b. Then, if b is 
true, x is evaluated and becomes the result of the operation. Otherwise, y is evaluated 
and becomes the result of the operation. A conditional expression never evaluates both x 
and y. 

The conditional operator is right-associative, meaning that operations are grouped from 
right to left. For example, an expression of the form a?b:c?d:eis evaluated as a ? b : 
(c ? d : e). 




361 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


■■ JON SKEET I find myself using mulfiple condifional operafors occasionally. If 
looks odd af firsf, buf can be very readable when laid ouf appropriafely. In some ways, 
fhis is fhe closes! C# gefs fo fhe paffern mafching of languages such as F#. 

return firstCondition ? firstValue : 

secondCondition ? secondValue : 
thirdCondition ? thirdValue : 
fallbackValue; 


The firsf operand of fhe ?: operafor musf be an expression fhaf can be implicifly converfed 
fo bool, or an expression of a t5T>e fhaf implemenfs operator true. If neifher of fhese 
requiremenfs is safisfied, a compile-fime error occurs. 


■■ PETER SESTOFT In parficular, because fhere is no implicif conversion from fhe 
nullable t5T>e bool? fo bool, fhe firsf operand of fhe condifional operafor cannof have 
fype bool?. 


The second and fhird operands, x and y, of fhe ?: operafor confrol fhe type of the condi¬ 
tional expression. 

• If X has type X and y has type Y, then 

- If an implicit conversion (§6.1) exists from X to Y, but not from Y to X, then Y is the type 
of the conditional expression. 

- If an implicit conversion (§6.1) exists from Y to X, but not from X to Y, then X is the type 
of the conditional expression. 

- Otherwise, no expression type can be determined, and a compile-time error occurs. 

• If only one of x and y has a type, and both x and y are implicitly convertible to that t 5 q)e, 
then that is the type of the conditional expression. 

• Otherwise, no expression type can be determined, and a compile-time error occurs. 


"■ ERIC LIPPERT The Microsoft C# compiler actually implements a slightly differ¬ 
ent algorithm: It checks for conversions from the expressions to the types, not from 
types to types. In most cases, the difference does not matter and it would break existing 
code to change it now. 


362 


www.it-ebooks.info 










7.14 Conditional Operator 


“■ PETER SESTOFT Despite the point made in Eric's annotation, there's a small 
incompatibility between Microsoft's C# 4.0 compiler and previous versions: The com¬ 
piler cannot infer fhe f 5 ^e of fhe conditional expression in fhe righf-hand side below, 
complaining fhaf "fhere is no implicif conversion between '<null>' and '<null>'": 

int? X = args.Length>0 ? null : null; 

The C# 2.0 compiler would accepf fhis expression. The C# 4.0 compiler's message 
hinfs af fhe possible exisfence of a "null t 5 ^e" inside fhe compiler, or af leasf in fhe 
minds of fhose who wrofe fhe error message. Given fhe exfremely confrived piece of 
code, fhe incompafibilify is nofhing fo lose sleep over. 


"■ VLADIMIR RESHETNIKOV Anofion of "null type" existed in earlier versions of 
fhe C# specificafion, buf was eliminafed in C# 3.0, which resulfed in a slighfly differenf 
behavior in corner cases. Currenfly null liferal is an expression fhaf has no t 5 ^e. 


The runtime processing of a conditional expression of fhe form b ? x : y consisfs of fhe fol¬ 
lowing sfeps: 

• Firsf, b is evaluafed, and fhe bool value of b is defermined: 

- If an implicif conversion from fhe fype of b fo bool exisfs, fhen fhis implicif conver¬ 
sion is performed fo produce a bool value. 

- Ofherwise, fhe operator true defined by fhe t 5 ^e of b is invoked fo produce a bool 
value. 

• If fhe bool value produced by fhe sfep above is true, fhen x is evaluafed and converfed 
fo fhe f 5 ^e of fhe condifional expression, and fhis becomes fhe resulf of fhe conditional 
expression. 

• Ofherwise, y is evaluafed and converfed fo fhe type of fhe condifional expression, and 
fhis becomes fhe resulf of fhe condifional expression. 




“■ BILL WAG N E R To me, bofh fhe null coalescing operator and fhe condifional oper- 
afor are like sfrong spices: When used sparingly, fhey are greaf enhancers. Chris poinfs 
ouf usages where fhe null coalescing operafor creafes clearer code fhan fhe equivalenf 
if-then-else sfafemenfs. Like sfrong spices, overuse is painful and ruins whaf could 
ofherwise be very pleasanf. 


363 


www.it-ebooks.info 


Expressions 










Expressions 


7. Expressions 


7.15 Anonymous Function Expressions 

An anonymous function is an expression that represents an "in-line" method definition. 
An anonymous function does not have a value or 1)^0 in and of ifself, buf is converfible fo 
a compafible delegafe or expression free fype. The evaluation of an anonymous fimcfion 
conversion depends on fhe fargef fype of fhe conversion: If if is a delegafe fype, fhe conver¬ 
sion evaluafes fo a delegafe value referencing fhe mefhod fhaf fhe anonymous funcfion 
defines. If if is an expression free t 5 ^e, fhe conversion evaluafes fo an expression free fhaf 
represenfs fhe sfrucfure of fhe mefhod as an objecf sfrucfure. 

For hisforical reasons, fhere are fwo synfacfic flavors of anonymous funcfions—namely, 
lambda-expressions and anonymous-method-expressions. For almosf all purposes, lambda- 
expressions are more concise and expressive fhan anonymous-method-expressions, which 
remain in the language to ensure backward compatibility. 

lambda-expression: 

anonymous-function-signature => anonymous-function-body 

anonymous-method-expression: 

delegate explicit-anonymous-function-signature^^^ block 

anonymous-function-signature: 

explicit-anonymous-function-signature 

implicit-anonymous-function-signature 

explicit-anonymous-function-signature: 

( explicit-anonymous-function-parameter-list^^ ) 

explicit-anonymous-function-parameter-list: 

explicit-anonymous-function-parameter 

explicit-anonymous-function-parameter-list , explicit-anonymous-function-parameter 

explicit-anonymous-function-parameter: 

anonymous-function-parameter-modifier^^ type identifier 

anonymous-function-parameter-modifier: 

ref 

out 

implicit-anonymous-function-signature: 

( implicit-anonymous-function-parameter-list^ ) 
implicit-anonymous-function-parameter 


364 


www.it-ebooks.info 




7.15 Anonymous Function Expressions 


implicit-anonymous-function-parameter-list: 

implicit-anonymous-function-parameter 

implicit-anonymous-function-parameter-list , implicit-anonymous-function- 
parameter 

implicit-anonymous-function-parameter: 

identifier 

anonymous-function-body: 

expression 

block 

The => operator has the same precedence as assignment (=) and is right-associative. 

The parameters of an anonymous function in the form of a lambda-expression can be explic¬ 
itly or implicitly t 5 ^ed. In an explicitly typed parameter list, the t 5 ^e of each parameter is 
explicitly stated. In an implicitly typed parameter list, the types of the parameters are 
inferred from the context in which the anonymous function occurs—specifically, when the 
anonymous function is converted to a compatible delegate type or expression tree type, 
that t 5 ^e provides the parameter t 5 ^es (§6.5). 


"■ BILL WAGNER In general, your anonymous functions will be more resilient if 
you rely on implicit typing. 


In an anonymous function with a single, implicitly t 5 ^ed parameter, the parentheses may 
be omitted from the parameter list. In other words, an anonymous function of the form 

( par am ) => expr 

can be abbreviafed as 
par am => expr 

The parameter list of an anonymous function in fhe form of an anonymous-method-expression 
is optional. If given, fhe parameters must be explicitly typed. If nof, fhe anonymous function 
is convertible to a delegate with any parameter list not containing out parameters. 


Some examples of anonymous functions follow below: 


X => X + 1 

X => { return x + 1; } 

(int x) => X + 1 

(int x) => { return x + 1; } 

(x, y) => X * y 
0 => Console.WriteLineO 
delegate (int x) { return x + 1; } 
delegate { return 1 + 1; } 


// Implicitly typed, expression body 
// Implicitly typed, statement body 
// Explicitly typed, expression body 
// Explicitly typed, statement body 
// Multiple parameters 
// No parameters 
// Anonymous method expression 
// Parameter list omitted 




365 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


The behavior of lambda-expressions and anonymous-method-expressions is the same except for 

the following points: 

• The anonymous-method-expressions permit the parameter list to be omitted entirely, yield¬ 
ing convertibility to delegate types of any list of value parameters. 

• The lambda-expressions permit parameter types to be omitted and inferred, whereas the 
anonymous-method-expressions require parameter types to be explicitly stated. 

• The body of a lambda-expression can be an expression or a statement block, whereas the 
body of an anonymous-method-expression must be a statement block. 

• Since only lambda-expressions can have an expression body, no anonymous-method-expression 
can be successfully converted to an expression tree type (§4.6). 


"■ BILL WAG N E R This point is important for building queries that rely on expres¬ 
sion trees, such as those in Linq2SQL and Entity Framework. 


7.15.1 Anonymous Function Signatures 

The optional anonymous-function-signature of an anonymous function defines the names 
and optionally the types of the formal parameters for the anonymous function. The scope 
of the parameters of the anonymous function is the anonymous-function-body (§3.7). Together 
with the parameter list (if given), the anonymous-method-body constitutes a declaration space 
(§3.3). It is thus a compile-time error for the name of a parameter of the anonymous func¬ 
tion to match the name of a local variable, local constant, or parameter whose scope 
includes the anonymous-method-expression or lambda-expression. 

If an anonymous function has an explicit-anonymous-function-signature, then the set of com¬ 
patible delegate t 5 q)es and expression tree types is restricted to those that have the same 
parameter types and modifiers in the same order. In contrast to method group conversions 
(§6.6), contravariance of anonymous function parameter t 5 q)es is not supported. If an 
anonymous function does not have an anonymous-function-signature, then the set of com¬ 
patible delegate types and expression tree types is restricted to those that have no out 
parameters. 

Note that an anonymous-function-signature carmot include attributes or a parameter array. 
Nevertheless, an anonymous-function-signature may be compatible with a delegate t 5 q)e 
whose parameter list contains a parameter array. 

Note also that conversion to an expression tree t 5 q)e, even if compatible, may still fail at 
compile time (§4.6). 


366 


www.it-ebooks.info 






7.15 Anonymous Function Expressions 


“■ ERIC LIPPERT This is a subtle point. If you have two overloads—say, void 
M(Expression<Func<Giraffe>> f) and void M(Func<Animal> f) —and a call 
M( () = >myGiraffes[++i] ), then the expression tree overload is chosen as the better 
overload. In this situation, a compile-time error occurs because the increment operator 
is illegal inside an expression tree. 


7.15.2 Anonymous Function Bodies 

The body {expression or block) of an anonymous function is subject to the following rules: 

• If the anonymous function includes a signature, the parameters specified in the signa¬ 
ture are available in the body. If the anonymous function has no signature, it can be 
converted to a delegate t 5 ^e or expression type having parameters (§6.5), but the param¬ 
eters cannot be accessed in the body. 

• Except for ref or out parameters specified in the signature (if any) of the nearest enclos¬ 
ing anonymous function, it is a compile-time error for the body to access a ref or out 
parameter. 

• When the type of this is a struct type, it is a compile-time error for the body to access 
this. This is true whether the access is explicit (as in this . x) or implicit (as in x where x 
is an instance member of the struct). This rule simply prohibits such access and does not 
affect whether member lookup results in a member of the struct. 

• The body has access to the outer variables (§7.15.5) of the anonymous function. Access 
to an outer variable will reference the instance of the variable that is active at the time 
the lambda-expression or anonymous-method-expression is evaluated (§7.15.6). 

• It is a compile-time error for the body to contain a goto statement, break statement, or 
continue statement whose target is outside the body or within the body of a contained 
anonymous function. 

• A ret u rn statement in the body returns control from an invocation of the nearest enclos¬ 
ing anonymous function, not from the enclosing function member. An expression spec¬ 
ified in a return statement must be implicitly convertible to the return type of the 
delegate t 5 ^e or expression tree type to which the nearest enclosing lambda-expression or 
anonymous-method-expression is converted (§6.5). 

It is explicitly unspecified whether there is any way to execute the block of an anonymous 
function other than through evaluation and invocation of the lambda-expression or 
anonymous-method-expression. In particular, the compiler may choose to implement an 
anonymous function by S 5 mthesizing one or more named methods or t 5 ^es. The names of 
any such synthesized elements must be of a form reserved for compiler use. 




367 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


7.15.3 Overload Resolution 

Anonymous functions in an argument list participate in type inference and overload reso¬ 
lution. Please refer to §7.4.2.3 for the exact rules. 

The following example illustrates the effect of anonymous functions on overload 
resolution. 

class ItemList<T>: List<T> 

{ 

public int Sum(Func<T,int> selector) { 
int sum = 0 ; 

foreach (T item in this) sum += selector(item); 
return sum; 

} 

public double Sum(Func<T,double> selector) { 
double sum = 0 ; 

foreach (T item in this) sum += selector(item); 
return sum; 

} 

} 

The ItemList<T> class has two Sum methods. Each takes a selector argument, which 
extracts the value to sum over from a list item. The extracted value can be either an int or 
a double, and the resulting sum is likewise either an int or a double. 

The Sum methods could, for example, be used to compute sums from a list of detail lines in 
an order. 

class Detail 
{ 

public int UnitCount; 
public double UnitPrice; 

} 

void ComputeSumsO { 

ItemList<Detail> orderDetails = GetOrderDetails(...); 

int totalUnits = orderDetails.Sum(d => d.UnitCount); 

double orderTotal = orderDetails.Sum(d => d.UnitPrice * d.UnitCount); 

} 

In the first invocation of orderDetails. Sum, both Sum methods are applicable because the 
anonymous function d => d.UnitCount is compatible with both FunccDetail, int> and 
Func<Detail, double>. However, overload resolution picks the first Sum method because the 
conversion to Func<Detailjint> is better than the conversion to Func<Detail,double>. 

In the second invocation of orderDetails. Sum, only the second Sum method is applicable 
because the anonymous function d => d. UnitPrice * d. UnitCount produces a value of type 
double. Thus overload resolution picks the second Sum method for that invocation. 


368 


www.it-ebooks.info 




7.15 Anonymous Function Expressions 


7.15.4 Anonymous Functions and Dynamic Binding 

An anonymous function cannot be a receiver, argument, or operand of a dynamically 
bound operation. 

7.15.5 Outer Variables 

Any local variable, value parameter, or parameter array whose scope includes the lambda- 
expression or anonymous-method-expression is called an outer variable of the anonymous 
function. In an instance function member of a class, the this value is considered a value 
parameter and is an outer variable of any anonymous function contained within the func¬ 
tion member. 


"■ BILL WAGNER This is the formal definition of how closures are implemented in 
C#. It's a great addition. 


7.15.5.1 Captured Outer Variables 

When an outer variable is referenced by an anonymous function, the outer variable is said 
to have been captured by the anonymous fimction. Ordinarily, the lifetime of a local vari¬ 
able is limited to execution of the block or statement with which it is associated (§5.1.7). 
However, the lifetime of a captured outer variable is extended at least imtil the delegate or 
expression tree created from the anonymous function becomes eligible for garbage 
collection. 




"■ BILL WAG N E R In the next example, notice that x has a longer life than you would 
expect, because it is captured by the anonymous method result. If x were an expensive 
resource, that behavior should be avoided by limiting the lifetime of the anonymous 
method. 


In the example 

using System; 

delegate int D(); 

class Test 
{ 

static D F() { 
int X = 0; 

D result = 0 => ++x; 
return result; 

} 


369 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


static void Main() { 

D d = F(); 

Console.WriteLine(d()); 

Console.WriteLine(d()); 

Console.WriteLlne(d()); 

} 

} 

the local variable x is captured by the anonymous hmction, and the lifetime of x is extended 
at least until the delegate returned from F becomes eligible for garbage collecfion (which 
doesn'f happen until the very end of the program). Since each invocation of the anony¬ 
mous function operates on the same instance of x, fhe oufpuf of the example is 

1 

2 

3 

When a local variable or a value parameter is captured by an anonymous function, the 
local variable or parameter is no longer considered to be a fixed variable (§18.3), buf insfead 
is considered fo be a moveable variable. Thus any unsafe code thaf takes the address of a 
capfured oufer variable musf first use the fixed statement to fix the variable. 

Note that unlike an uncaptured variable, a captured local variable can be simultaneously 
exposed to multiple threads of execution. 


7.15.5.2 Instantiation of Local Variables 

A local variable is considered fo be instantiated when execution enters the scope of the 
variable. For example, when the following method is invoked, the local variable x is instan¬ 
tiated and initialized three times—once for each iferafion of fhe loop: 

static void F() { 

for (int i = 0; i < 3; i++) { 
int X = i * 2 + 1; 

} 

} 

However, moving fhe declarafion of x outside the loop results in a single instantiation 
of x: 

static void F() { 
int x; 

for (int i = 0; i < 3; i++) { 

X = i * 2 + 1; 

} 

} 


370 


www.it-ebooks.info 




7.15 Anonymous Function Expressions 


When not captured, there is no way to observe exactly how often a local variable is instan¬ 
tiated: Because the lifetimes of the instantiations are disjoint, it is possible for each 
instantiation to simply use the same storage location. However, when an anonymous 
function captures a local variable, the effects of instantiation become apparent. 

The example 

using System; 

delegate void D(); 

class Test 
{ 

static D[] F() { 

D[] result = new D[3]; 
for (int i = 0; i < 3; i++) { 
int X = i * 2 + 1; 

result[l] =()=>{ Console.WriteLine(x); }; 

} 

return result; 

} 

static void Main() { 

foreach (D d in F()) d(); 

} 


produces the following output: 




However, when the declaration of x is moved outside the loop 

static D[] F() { 

D[] result = new D[3]; 
int x; 

for (int i = 0; i < 3; i++) { 

X = i * 2 + 1; 

result[i] =()=>{ Console.WriteLine(x); }; 

} 

return result; 


the output is 

5 

5 

5 

If a for loop declares an iteration variable, that variable itself is considered to be declared 
outside of the loop. Thus, if the example is changed to capture the iteration variable itself. 


371 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


static D[] F() { 

D[] result = new D[3]; 

for (int i = 0; i < 3; i++) { 

result[i] =()=>{ Console.WriteLine(i); }; 

} 

return result; 

} 

only one instance of the iteration variable is captured, which produces the following 
output: 

3 

3 

3 


"■ ERIC LI PPERT This behavior— that anonymous functions capture loop variables, 
not the current value of that variable—is the cause of the single most common incor¬ 
rect "I think I found a bug in the compiler" report we get. For a future version of this 
specification, we are considering moving the formal definition of the foreach loop 
variable to the inside of the loop, so that an anonymous function inside the loop would 
capture a new variable every time through the loop. That would technically be a 
breaking change, but it would bring the language in line with what most people think 
its behavior ought to be. It's hard to think of a situation in which you want to capture 
the loop variable as a variable, rather than as a value. 


It is possible for anonymous funcfion delegafes to share some captured variables, yet have 
separate instances of ofhers. For example, if F is changed to 

D[] result = new D[3]; 
int X = 0; 

for (int i = 0; i < 3; i++) { 
int y = 0; 

result[i] =()=>{ Console.WriteLine("{0} {1}", ++x, ++y); }; 

} 

return result; 

} 

the three delegates capture the same instance of x but separate instances of y, and fhe 
output is 

1 1 
2 1 
3 1 

Separate anonymous functions can capture the same instance of an outer variable. In the 
example 

using System; 


372 


www.it-ebooks.info 






7.16 Query Expressions 


delegate void Setter(int value); 

delegate int Getter(); 

class Test 
{ 

static void Main() { 
int X = 0; 

Setter s = (int value) => { x = value; }; 

Getter g = () => { return x; }; 
s(5); 

Console.WriteLine(g()); 
s(10); 

Console.WriteLine(g()); 

} 

} 

the two anonymous functions capture the same instance of fhe local variable x, and fhey 
can "communicafe" fhrough fhaf variable. The oufpuf of fhe example is 

5 

10 

7.15.6 Evaluation of Anonymous Function Expressions 

An anonymous funcfion F musf always be converfed fo a delegafe type D or an expres¬ 
sion tree t 5 ^e E, either directly or through the execution of a delegafe creafion expression 
new D( F ). This conversion defermines fhe resulf of fhe anonymous funcfion, as described 
in §6.5. 




7.16 Query Expressions 

Query expressions provide a language-infegrafed S 5 mfax for queries fhaf is similar fo rela- 
fional and hierarchical query languages such as SQL and XQuery. 

query-expression: 

from-clause query-body 

from-clause: 

from type^^^ identifier in expression 
query-body: 

query-body-clauses^^i select-or-group-clause query-continuation^^ 

query-body-clauses: 

query-body-clause 

query-body-clauses query-body-clause 


373 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


query-body-clause: 

from-clause 

let-clause 

where-clause 

join-clause 

join-into-clause 

orderby-clause 

let-clause: 

let identifier = expression 
where-clause: 

where boolean-expression 
join-clause: 

join type^^^i identifier in expression on expression equals expression 
join-into-clause: 

join type^ identifier in expression on expression equals expression into identifier 

orderby-clause: 

orderby orderings 

orderings: 

ordering 

orderings , ordering 
ordering: 

expression ordering-direction^^ 

ordering-direction: 

ascending 

descending 

select-or-group-clause: 

select-clause 

group-clause 

select-clause: 

select expression 


374 


www.it-ebooks.info 




7.16 Query Expressions 


group-clause: 

group expression by expression 

query-continuation: 

into identifier query-body 

A query expression begins with a from clause and ends with either a select or group 
clause. The initial from clause can be followed by zero or more from, let, where, join, or 
orderby clauses. Each from clause is a generator introducing a range variable that ranges 
over the elements of a sequence. Each let clause introduces a range variable representing 
a value computed by means of previous range variables. Each where clause is a filter that 
excludes items from the result. Each join clause compares specified keys of the source 
sequence with keys of anofher sequence, yielding matching pairs. Each orderby clause 
reorders items according to specified criteria. The final select or group clause specifies the 
shape of the result in terms of the range variables. Einally an into clause can be used to 
"splice" queries by treating the results of one query as a generator in a subsequent query. 


“■ ERIC LIPPERT Why is the query S 5 mtax in C# "from...where...select," rather 
than the order more familiar fo SQL developers: "select...from...where"? Alfhough 
fhe SQL order has fhe benefits of being familiar to SQL developers and natural to 
English speakers, it causes many problems for the language and IDE designers that 
are not present in the C# order. 

Eirst, IntelliSense is difficult to use with the SQL order because of the scoping rules. 
Imagine you're designing an IDE for the "select first" S 5 mtax. The user has just t 5 q)ed 
"select": Now what? You don't know which data source the user is projecting from, 
so you carmot produce a sensible list of helpful options. Nor can you provide any help 
for "where." In the C# system, the "from" comes before the "select"; thus, by the time 
the user t5q3es "where" or "select," the IDE knows type information about the data 
source. 

Second, the C# order is the order in which operations are actually performed by the 
code: Eirst a collection is identified, then the filter is run over the collection, and then 
the results of the filter are projected. This order helps give a sense of how data flows 
fhrough the system. 




"■ CHRIS SELLS Now that I've seen both orders "select-from" in SQL and 
"f rom-select" in LINQ, LINQ makes much more sense to me and I'm frustrated that 
SQL doesn't allow the "f rom-select" style. 


375 


www.it-ebooks.info 


Expressions 








Expressions 


7. Expressions 


7.16.1 Ambiguities in Query Expressions 

Query expressions contain a number of "contextual ke 5 rwords"—that is, identifiers that 
have special meaning in a given context. Specifically these are from, where, join, on, equals, 
into, let, orderby, ascending, descending, select, group, and by. To avoid ambiguities in 
query expressions caused by mixed use of these identifiers as keywords or simple names, 
these identifiers are considered keywords when occurring anywhere within a query 
expression. 

For this purpose, a query expression is any expression that starts with "from identifier" 
followed by any token except , or ", 

To use these words as identifiers within a query expression, they can be prefixed with 
"@ (§2.4.2). 


7.16.2 Query Expression Translation 

The C# language does not specify the execution semantics of query expressions. Rafher, 
query expressions are translated into invocations of mefhods fhat adhere to the query 
expression pattern (§7.16.3). Specifically, query expressions are franslafed info invocations of 
methods named Where, Select, SelectMany, loin, Grouploin, OrderBy, OrderByDescending, 
ThenBy, ThenByDescending, GroupBy, and Cast. These methods are expected to have par¬ 
ticular signatures and result types, as described in §7.16.3. These methods can be instance 
methods of the object being queried or extension methods that are external to the object, 
and they implement the actual execution of the query. 

The translation from query expressions to method invocations is a S 5 mtactic mapping that 
occurs before any t 5 q)e binding or overload resolution has been performed. The translation 
is guaranteed to be S5mtactically correct, but is not guaranteed to produce semantically 
correct C# code. Following translation of query expressions, the resulting method invoca¬ 
tions are processed as regular method invocations, and this may in turn uncover errors— 
for example, if the methods do not exist, if arguments have wrong types, or if the methods 
are generic and type inference fails. 


"■ BILL WAG N E R This enfire section is a greaf way fo undersfand how query expres¬ 
sions are translated into method calls and possibly extension method calls. 


■■ jONSKEET The fact that query expressions could be introduced into C# with such 
a small addition to the specification is a source of wonder to me. Whereas some features, 
such as generics, affected nearly every area of fhe language, query expressions are amaz¬ 
ingly self-confarned—especially considering fhe expressive power fhey provide. 


376 


www.it-ebooks.info 








7.16 Query Expressions 


A query expression is processed by repeatedly applying the following translations until no 
further reductions are possible. The translations are listed in order of application: Each sec¬ 
tion assumes fhaf fhe franslafions in fhe preceding sections have been performed exhaus- 
fively; once exhausfed, a secfion will nof lafer be revisifed in fhe processing of fhe same 
query expression. 

Assignmenf fo range variables is nof allowed in query expressions. However, a C# imple- 
menfafion is permitted fo nof always enforce fhis resfricfion, since fhis may somefimes nof 
be possible wifh fhe S 5 mfacfic franslafion scheme presenfed here. 

Cerfain franslafions injecf range variables wifh transparent identifiers denofed by *. The 
special properties of fransparenf identifiers are discussed furfher in §7.16.2.7. 


"■ CHRIS SELLS As much as 1 like fhe C# 3.0 query synfax, somefimes if's difficulf 
fo keep fhe franslafions in my head. Don'f feel bad if you occasionally feel fhe need fo 
wrife ouf your queries using fhe mefhod call synfax. Also, any query mefhods fhaf 
you implemenf yourself will nof have language consfrucfs, so somefimes you won'f 
have any choice excepf fo use fhe mefhod call S 5 mfax. 

Furfher, if's complefely okay if your peers are writing queries like fhis: 

van duluthians = from c in Customers 

where c.City == "Duluth" select c; 

and you wrife your queries like fhis: 

var duluthians = Customers.Where(c => c.City == "Duluth"); 

The second S 5 mfax requires no menfal franslafion and works for all exfension mefh¬ 
ods, nof jusf fhe ones fhaf have been franslafed info ke 5 rwords. For example: 

var tenDuluthites = Customers.Where(c => c.City == "Duluth").Take(10); 
versus 

var tenDuluthites = (from c in Customers where c.City == 

"Duluth” select c).Take(10); 

Tm a simple man, so I prefer fhe synfax sfyle fhaf always works over whaf fhe cool 
kids are doing fhese days. 




377 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


■■ JONSKEET While additional query methods on IEnumerable<T> are unlikely to 
be supported by query expressions, one of the beautiful aspecfs of fheir definifion is 
fhe neufralify involved: There's nofhing in fhe specificafion fo dicfafe whaf fhe fypes 
should be. This has allowed ofher frameworks (such as Reactive Exfensions and Paral¬ 
lel Exfensions) fo wrife query mefhods againsf new f 5 q)es and sfill fake advanfage of 
query expression sjmfax. 


7.16.2.1 select and GroupBy Clauses with Continuations 

A query expression wifh a confinuafion 

from ... into x ... 
is franslafed info 

from X in ( from ... ) ... 

The franslafions in fhe following sections assume fhaf queries have no into continuations. 
The example 

from c in customers 
group c by c.Country into g 

select new { Country = g.Key, CustCount = g.Count() } 

is franslafed info 
from g in 

from c in customers 
group c by c.Country 

select new { Country = g.Key, CustCount = g.Count() } 
fhe final franslafion of which is 
customers. 

GroupBy(c => c.Country). 

Select(g => new { Country = g.Key, CustCount = g.Count() }) 


■■ JOSEPH ALBAHARI The purpose of a query confinuafion is fo allow furfher 
clauses affer aselect or group clause (which would ofherwise ferminafe fhe query). 
Affer a query confinuafion, fhe former range variable, and any variables fhaf were 
infroduced fhrough join or let clauses, are ouf of scope. In confrasf, a let clause acfs 
like a nondestructive select: It keeps the former range variable, and ofher query vari¬ 
ables, in scope. 

The idenfifier infroduced by a query confinuafion can be fhe same as fhe preceding 
range variable. 


378 


www.it-ebooks.info 








7.16 Query Expressions 


7.16.2.2 Explicit Range Variable Types 

A from clause that explicitly specifies a range variable type 

from Tx in e 
is translated into 

from X in ( e ) . Cast < T > ( ) 

A join clause that explicitly specifies a range variable fype 
join Tx in e on fcj equals 
is franslafed info 

join X in ( e ) . Cast < T >{) on equals k^ 

The franslafions in fhe following sections assume fhaf queries have no explicif range vari¬ 
able f 5 q)es. 

The example 

from Customer c in customers 
where c.City == "London" 
select c 

is franslafed info 

from c in customers.Cast<Customer>() 
where c.City == "London" 




fhe final franslafion of which is 

customers. 

Cast<Customer>(). 

Where(c => c.City == "London") 

Explicif range variable fypes are useful for querying collecfions fhaf implemenf fhe non¬ 
generic lEnumerable inferface, buf nof fhe generic IEnumerable<T > inferface. In fhe exam¬ 
ple above, fhis would be fhe case if customers were of fype ArrayList. 

7.16.2.3 Degenerate Query Expressions 

A query expression of fhe form 

from X in e select x 

is franslafed info 

( e ) . Select ( x => x ) 


379 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


The example 

from c in customers 
select c 

is translated into 

customers.Select(c => c) 

A degenerate query expression is one that trivially selects the elements of the source. A 
later phase of the translation removes degenerate queries introduced by other translation 
steps by replacing them with their source. It is important, however, to ensure that the result 
of a query expression is never fhe source objecf ifself, as that would reveal the type and 
identity of the source to the client of the query. Therefore this step protects degenerate 
queries written directly in source code by explicitly calling Select on the source. It is then 
up to the implementers of Select and ofher query operafors to ensure that these methods 
never return the source object itself. 


7.16.2.4 from, let, where, join, and orderby Clauses 


■■ JOSEPH ALBAHARI The cumbersome-looking translafions in this section are 
what make query S 5 mtax really useful: They eliminate the need to write out cumber¬ 
some queries by hand. Without this problem, there might have been little justification 
for introducing query expression S 5 mtax into C# 3.0, given the capabilities of lambda 
expressions and extension methods. 

The common theme in the more complex translations is the process of projecting into 
a temporary anonymous t 5 q)e so as to keep the former range variable in scope follow¬ 
ing a let, from, or join clause. 


A query expression with a second from clause followed by a select clause 

from Xj in 
from Xj in 
select V 

is franslafed info 

( fij ) . SelectMany( => ) => v ) 

A query expression with a second from clause followed by something other than a select 
clause 

from Xj in 
from x^ in 


380 


www.it-ebooks.info 






7.16 Query Expressions 


is translated into 

from * in ( Sj ) . SelectMany( => , { x^ , ) => new { x^ , x^ } ) 

A query expression with a let clause 

from X in e 
let y = / 

is translated into 

from * in ( e ) . Select { x -> new {x,y=/}) 


A query expression with a where clause 

from X in e 
where / 


is translated into 

from X in ( e ) . Where ( x -> f ) 


A query expression with a join clause without an into followed by a select clause 
from Xj in 

join Xj in on equals 
select V 

is translated into 

( e, ) . loin( , x, => k^ , x^ => k^ , { x^ , x^ ) => v ) 

A query expression with a join clause without an into followed by somefhing ofher fhan 
a select clause 

from Xj in 

join x^ in on k^ equals k^ 




is franslafed info 

from * in ( Sj ) . loin( , Xj => fcj , x^ => k^ , { X-^ , x^ ) => new { Xj , x^ }) 


381 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


A query expression with a join clause with an into followed by a select clause 
from Xj in 

join in on equals into g 
select V 

is translated into 

( fij ) . GrouploinC => k^ , => k^ , { x^ , g ) => v ) 

A query expression with a join clause with an into followed by somefhing ofher fhan a 
select clause 

from Xj in 

join x^ in on fcj equals k^ into g 


is franslafed info 

from * in ( Sj ) . Grouploin( , x^ => k^ , x^ => k^ , { x^ , g ) => new { x^ , g }) 
A query expression wifh an orderby clause 
from X in e 

orderby k^ , k^ , ... , k^ 


is franslafed info 

from X in ( e ) . 
OrderBy { x => k^ ) . 
ThenBy ( x => ) . 

ThenBy ( x => k^ ) 


If an ordering clause specifies a descending direcfion indicafor, an invocafion of 
OrderByDescending or ThenByDescending is produced insfead. 

The following franslafions assume fhaf fhere are no let, where, join, or orderby clauses, 
and no more fhan fhe one inifial from clause in each query expression. 

The example 

from c in customers 
from o in c.Orders 

select new { c.Name, o.OrderlD, o.Total } 
is franslafed info 
customers. 

SelectMany(c => c.Orders, (c,o) => new { c.Name, o.OrderlD, o.Total }) 


382 


www.it-ebooks.info 




7.16 Query Expressions 


The example 

from c in customers 

from o in c.Orders 

orderby o.Total descending 

select new { c.Name^ o.OrderlDj o.Total } 

is translated into 

from * in customers. 

SelectMany(c => c.OrderSj (CjO) => new { c, o }) 
orderby o.Total descending 
select new { c.Name, o.OrderlDj o.Total } 

the final translation of which is 

customers. 

SelectMany(c => c.OrderSj (c,o) => new { Cj o }). 

OrderByDescending(x => x.o.Total). 

Select(x => new { x.c.Name, x.o.OrderlDj x.o.Total }) 
where x is a compiler-generated identifier that is otherwise invisible and inaccessible. 
The example 

from o in orders 

let t = o.Details.Sum(d => d.UnitPrice * d.Quantity) 
where t >= 1000 

select new { o.OrderlD, Total = t } 

is translated into 

from * in orders. 

Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) }) 
where t >= 1000 

select new { o.OrderlD, Total = t } 
the final translation of which is 
orders. 

Select(o => new { o, t = o.Details.Sum(d => d.UnitPrice * d.Quantity) }). 

Where(x => x.t >= 1000). 

Select(x => new { x.o.DrderlDj Total = x.t }) 
where x is a compiler-generated identifier that is otherwise invisible and inaccessible. 
The example 

from c in customers 

join o in orders on c.CustomerlD equals o.CustomerlD 
select new { c.Name^ o.DrderDate, o.Total } 




383 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


is translated into 

customers.Doin(orderSj c => c.CustomerlD^ o => o.CustomerlD, 

(Cj o) => new { c.Name, o.OrderDatej o.Total }) 

The example 

from c in customers 

join o in orders on c.CustomerlD equals o.CustomerlD into co 
let n = co.CountO 
where n >= 10 

select new { c.Name, OrderCount = n } 

is translated into 

from * in customers. 

GroupDoin(orderSj c => c.CustomerlD, o => o.CustomerlD, 

(c, co) => new { c, co }) 
let n = co.CountO 
where n >= 10 

select new { c.Name, OrderCount = n } 

the final translation of which is 

customers. 

GroupDoin(orders, c => c.CustomerlD, o => o.CustomerlD, (c, co) => new { c, co }). 
Select(x => new { x, n = x.co.CountO })• 

Where(y => y.n >= 10). 

Select(y => new { y.x.c.Name, OrderCount = y.n) 

where x and y are compiler-generated identifiers fhat are otherwise invisible and 
inaccessible. 

The example 

from o in orders 

orderby o.Customer.Name, o.Total descending 
select o 

has the final translation 

orders. 

OrderBy(o => o.Customer.Name). 

ThenByDescending(o => o.Total) 


7.16.2.5 select Clauses 

A query expression of the form 

from X in e select v 

is translated into 


384 


www.it-ebooks.info 




7.16 Query Expressions 


( e ) . Select { x => v ) 

except when v is the identifier x, the translation is simply 
( e ) 

For example, 

from c in customers.Where(c => c.City == "London") 
select c 

is simply translated into 

customers.Where(c => c.City == "London") 


7.16.2.6 GroupByClauses 

A query expression of fhe form 

from X in e group u by A: 
is franslafed info 

( e ) . GroupBy ( x -> k , x => v ) 
excepf when v is fhe idenfifier x, fhe franslafion is 
( e ) . GroupBy ( x -> k ) 

The example 

from c in customers 
group c.Name by c.Country 

is franslafed info 
customers. 

GroupBy(c => c.Country, c => c.Name) 

7.16.2.7 Transparent Identifiers 

Cerfain franslafions injecf range variables wifh transparent identifiers denofed by *. Trans- 
parenf idenfifiers are nof a proper language feafure; fhey exisf only as an infermediafe sfep 
in fhe query expression franslafion process. 

When a query franslafion injecfs a transparenf identifier, furfher franslafion steps propa¬ 
gate the transparent identifier info anonymous functions and anonymous objecf inifializ- 
ers. In fhose confexfs, fransparenf idenfifiers have fhe following behavior: 

• When a fransparenf idenfifier occurs as a paramefer in an anonymous funcfion, fhe 
members of fhe associafed anonymous 1)^)0 are aufomafically in scope in fhe body of fhe 
anonymous funcfion. 




385 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


• When a member with a transparent identifier is in scope, the members of fhaf member 
are in scope as well. 

• When a fransparenf idenfifier occurs as a member declarafor in an anonymous objecf 
initializer, if infroduces a member wifh a fransparenf idenfifier. 

In fhe franslafion sfeps described above, fransparenf idenfifiers are always infroduced 
fogefher wifh anonymous f5^es, wifh fhe infenf of capfuring mulfiple range variables as 
members of a single objecf. An implemenfafion of C# is permiffed fo use a differenf mecha¬ 
nism fhan anonymous fypes fo group fogefher mulfiple range variables. The following 
franslafion examples assume fhaf anonymous f5^es are used, and show how fransparenf 
idenfifiers can be franslafed away. 

The example 

from c in customers 
from o in c.Orders 
orderby o.Total descending 
select new { c.Name, o.Total } 

is franslafed info 

from * in customers. 

SelectMany(c => c.Orders, (c,o) => new { c, o }) 
orderby o.Total descending 
select new { c.Name, o.Total } 

which is furfher franslafed info 
customers. 

SelectMany(c => c.Orders, (c,o) => new { c, o }). 

OrderByOescendingC* => o.Total). 

Select(* => new { c.Name, o.Total }) 

which, when fransparenf idenfifiers are erased, is equivalenf fo 
customers. 

SelectMany(c => c.Orders, (c,o) => new { c, o }). 

OrderByDescending(x => x.o.Total). 

Select(x => new { x.c.Name, x.o.Total }) 

where x is a compiler-generafed idenfifier fhaf is ofherwise invisible and inaccessible. 

The example 

from c in customers 

join o in orders on c.CustomerlD equals o.CustomerlD 
join d in details on o.OrderlD equals d.OrderlD 
join p in products on d.ProductID equals p.ProductID 
select new { c.Name, o.OrderOate, p.ProductName } 


386 


www.it-ebooks.info 




7.16 Query Expressions 


is translated into 

from * in customers. 

Doin(orderSj c => c.CustomerlD^ o => o.CustomerlDj (c, o) => new { Cj o }) 
join d in details on o.OrderlD equals d.OrderlD 
join p in products on d.ProductID equals p.ProductID 
select new { c.Name, o.OrderDatej p.ProductName } 

which is further reduced to 


customers. 

Doin(orders, c => c.CustomerlDj o => o.CustomerlD, (c, o) => new { c, o }). 
Doin(detailSj * => o.OrderlD, d => d.OrderlD, (*, d) => new { *, d }). 
Doin(products, * => d.ProductID, p => p.ProductID, (*, p) => new { *, p }). 
Select(* => new { c.Name, o.OrderDate, p.ProductName }) 

the final translation of which is 


customers. 

Ioin(orders, c => c.CustomerlD, o => o.CustomerlD, (c, o) => new { 
Ioin(details, x => x.o.OrderlD, d => d.OrderlD, (x, d) => new { x, 
Ioin(products, y => y.d.ProductID, p => p.ProductID, (y, p) => new 
Select(z => new { z.y.x.c.Name, z.y.x.o.OrderDate, z.p.ProductName 


c, o }). 
d }). 

{ y. p })• 
}) 


where x, y, and z are compiler-generafed identifiers thaf are otherwise invisible and 
inaccessible. 


7.16.3 The Query Expression Pattern 

The query expression pattern establishes a pattern of methods that types can implement to 
support query expressions. Because query expressions are translated to method invoca¬ 
tions by means of a syntactic mapping, t5q)es have considerable flexibility in how they 
implement the query expression pattern. For example, the methods of the pattern can be 
implemented as instance methods or as extension methods because the two have the same 
invocation syntax, and the methods can request delegates or expression trees because 
anonymous functions are convertible to both. 

The recommended shape of a generic t5q)e C<T> fhat supports the query expression pattern 
is shown below. A generic type is used to illustrate the proper relationships between 
parameter and result t5q)es, but it is possible to implement the pattern for nongeneric types 
as well. 

class C<T> : C 
{ 

public C<T> Where(Func<T,bool> predicate); 
public C<U> Select<U>(Func<T,U> selector); 




387 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


public C<V> SelectMany<UjV>(Func<T,C<U>> selector^ 

Func<T,UjV> resultSelector); 

public C<V> Doin<U,KjV>(C<U> inner, Func<T,K> outerKeySelector, 

Func<U,K> innerKeySelector, Func<T,LI,V> resultSelector); 

public C<V> GroupDointU,K,V>(C<U> inner, Func<T,K> outerKeySelector, 

Func<U,K> innerKeySelector, Func<T,C<U>,V> resultSelector); 

public 0<T> OrderBy<K>(Func<T,K> keySelector); 

public 0<T> OrderByDescending<K>(Func<T,K> keySelector); 

public C<G<K,T>> GroupBy<K>(Func<T,K> keySelector); 

public C<G<K,E>> GroupBy<K,E>(Func<T,K> keySelector, 

Func<T,E> elementSelector); 

} 

class 0<T> : C<T> 

{ 

public 0<T> ThenBy<K>(Func<T,K> keySelector); 

public 0<T> ThenByDescending<K>(Func<T,K> keySelector); 

} 

class G<K,T> : C<T> 

{ 

public K Key { get; } 

} 

The methods above use the generic delegate t5^es Func<Tl, R> and FunccTl, T2, R>, but 
they could equally well have used other delegate or expression tree types with the same 
relationships in parameter and result t5q)es. 

Notice the recommended relationship between C<T> and 0<T>, which ensures that the 
ThenBy and ThenByDescending methods are available only on the result of an OrderBy or 
OrderByDescending. Also notice the recommended shape of the result of GroupBy —a 
sequence of sequences, where each irmer sequence has an additional Key property. 


"■ BILL WAG NER ThenBy will often have better performance fhan OrderBy, because 
if needs to sort only irmer sequences that have more than one value. 


The System. Linq namespace provides an implementation of the query operator pattern for 
any t 5 q 5 e that implements the System.Collections .Generic. IEnumerable<T > interface. 


“■ BILL WAGNER There is also an implementation for any fype thaf implemenfs 
IQueryable<T >. 


388 


www.it-ebooks.info 








7.17 Assignment Operators 


“■ ERIC LIPPERT This signature for loin is one of fhe primary mofivafors of fhe 
"accumulafe bounds and fhen fix fo fhe besf one" parf of fhe mefhod fype inference 
algorithm. If fhe inner key is, say, of type int, and the outer key of type int?, then 
rather than having t5q3e inference fail due fo fhe "confradicfion," if is beffer fo simply 
pick fhe more general of fhe fwo fypes. Because every int is an int?, fhe type infer¬ 
ence algorifhm would choose int? for K. 


7.17 Assignment Operators 

The assignmenf operafors assign a new value fo a variable, a properly, an evenf, or an 
indexer elemenf. 

assignment: 

unary-expression assignment-operator expression 
assignment-operator: 

+- 

*_ 

/= 

V- 




h 

A — 

<< = 

right-shift-ass ign men t 

The leff operand of an assignmenf musf be an expression classified as a variable, a properly 
access, an indexer access, or an evenf access. 

The = operafor is called fhe simple assignment operator. If assigns fhe value of fhe righf 
operand fo fhe variable, properly or indexer elemenf given by fhe leff operand. The leff 
operand of fhe simple assignmenf operafor may nof be an evenf access (excepf as described 
in §10.8.1). The simple assignmenf operafor is described in §7.17.1. 

The assignmenf operafors ofher fhan fhe = operafor are called fhe compound assignment 
operators. These operafors perform fhe indicafed operafion on fhe fwo operands, and fhen 
assign fhe resulfing value fo fhe variable, properly, or indexer elemenf given by fhe leff 
operand. The compound assignmenf operafors are described in §7.17.2. 


389 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


The += and -= operators with an event access expression as the left operand are called the 
event assignment operators. No other assignment operator is valid with an event access as 
the left operand. The event assignment operators are described in §7.17.3. 

The assignment operators are right-associative, meaning that operations are grouped from 
righf fo leff. For example, an expression of fhe form a = b = c is evaluafed as a = (b = c). 

7.17.1 Simple Assignment 

The = operator is called fhe simple assignmenf operator. 

If fhe leff operand of a simple assignmenf is of fhe form E. P or E [ E. ], where E has fhe 
compile-time t 5 ^e dynamic, then the assignment is d 5 mamically bound (§7.2.2). In this case, 
the compile-time type of fhe assignmenf expression is dynamic, and fhe resolution described 
below will fake place af runtime based on fhe runfime f5T’e of E. 

In a simple assignmenf, fhe righf operand musf be an expression fhaf is implicifly converf- 
ible fo fhe f 5 ^e of fhe leff operand. The operafion assigns fhe value of fhe righf operand fo 
fhe variable, properly or indexer elemenf given by fhe leff operand. 

The resulf of a simple assignmenf expression is fhe value assigned fo fhe leff operand. The 
resulf has fhe same f 5 ^e as fhe leff operand and is always classified as a value. 

If fhe leff operand is a properly or indexer access, fhe properly or indexer musf have a set 
accessor. If fhis is nof fhe case, a binding-time error occurs. 

The runfime processing of a simple assignmenf of fhe form x = y consisfs of fhe following 
steps: 

• If X is classified as a variable: 

- X is evaluafed fo produce fhe variable. 

- y is evaluafed and, if required, converted fo fhe fype of x fhrough an implicif conver¬ 
sion (§6.1). 

- If fhe variable given by x is an array elemenf of a reference-type, a runfime check is 
performed fo ensure fhaf fhe value compufed for y is compafible wifh fhe array 
insfance of which x is an elemenf. The check succeeds if y is null, or if an implicif 
reference conversion (§6.1.6) exisfs from fhe acfual fype of fhe insfance referenced by 
y fo fhe acfual elemenf type of fhe array insfance confaining x. Ofherwise, a System. 
ArrayTypeMismatchException is fhrown. 

- The value resulting from fhe evaluation and conversion of y is sfored info fhe location 
given by fhe evaluation of x. 


390 


www.it-ebooks.info 




7.17 Assignment Operators 


• If X is classified as a properfy or indexer access: 

- The insfance expression (if x is nof static) and fhe argumenf lisf (if x is an indexer 
access) associafed wifh x are evaluafed, and fhe resulfs are used in fhe subsequenf set 
accessor invocation. 

- y is evaluafed and, if required, converfed fo fhe f 5 q)e of x fhrough an implicif conver¬ 
sion (§6.1). 

- The set accessor of x is invoked wifh fhe value compufed for y as ifs value 
argumenf. 

The array covariance rules (§12.5) permif a value of an array t 5 q)e A[ ] fo be a reference fo 
an insfance of an array B[ ], provided an implicif reference conversion exisfs from B fo 
A. Because of fhese rules, assignmenf fo an array elemenf of a reference-type requires a run- 
fime check fo ensure fhaf fhe value being assigned is compafible wifh fhe array insfance. In 
fhe example 

string!] sa = new string[10]; 
object!] oa = sa; 

oa!0] = null; // Okay 

oa!l] = "Hello"; // Okay 

oa!2] = new ArrayList(); // ArrayTypeMismatchException 

fhe lasf assignmenf causes a System. ArrayTypeMismatchException fo be fhrownbecause 
an insfance of Array List cannof be stored in an elemenf of a string! ]. 


“■ BILL WAG N E R This poinf implies fhaf array assignmenf does nof copy fhe array, 
buf rafher adds a new reference fo fhe same storage. 


When a properfy or indexer declared in a struct-type is fhe fargef of an assignmenf, fhe 
insfance expression associafed wifh fhe properfy or indexer access musf be classified as a 
variable. If fhe insfance expression is classified as a value, a binding-time error occurs. 
Because of §7.6.4, fhe same rule also applies fo fields. 

Given fhe declarafions: 

struct Point 
{ 

int X, y; 

public Point(int x, int y) 

{ 

this.x = x; 
thls.y = y; 

} 




391 


www.it-ebooks.info 


Expressions 






Expressions 


7. Expressions 


public int X 

{ 

get { return x; } 
set { X = value; } 

} 

public int Y 

{ 

get { return y; } 
set { y = value; } 

} 

} 

struct Rectangle 

{ 

Point a, b; 

public Rectangle(Point a. Point b) 

{ 

this.a = a; 
this.b = b; 

} 

public Point A 

{ 

get { return a; } 
set { a = value; } 

} 

public Point B 

{ 

get { return b; } 
set { b = value; } 

} 

} 

in the example 

Point p = new Point(); 
p.X = 100; 
p.Y = 100; 

Rectangle r = new Rectangle(); 
r.A = new Point(10j 10); 
r.B = p; 

the assignments to p. X, p. Y, r. A, and r. B are permitted because p and r are variables. How¬ 
ever, in the example 

Rectangle r = new Rectangle(); 

r.A.X = 10; 

r.A.Y = 10; 

r.B.X = 100; 

r.B.Y = 100; 

the assignments are all invalid because r. A and r. B are not variables. 


392 


www.it-ebooks.info 




7.17 Assignment Operators 


■■ JOSEPH ALBAHARI An early release of the C# 1.0 compiler allowed assignments 
such as r. A. X = 10 —but they failed silently because r. A returns a copy of a Point (i.e., 
a value) rather than a variable. People found this behavior confusing, so the condition 
was detected and reported as an error. 


"■ BILL WAG N E R This discussion highlights yet another reason why structs should 
be immutable. 


7.17.2 Compound Assignment 

If the left operand of a compound assignment is of the form E. P or E [ E. ], where E has the 
compile-time type dynamic, then the assignment is dynamically bound (§7.2.2). In this case, 
the compile-time type of the assignment expression is dynamic, and the resolution described 
below will take place at runtime based on the runtime t 5 ^e of E. 

An operation of the form x op= y is processed by applying binary operator overload resolu¬ 
tion (§7.3.4) as if the operation was written x op y. Then, 

• If the return type of the selected operator is implicitly convertible to the type of x, the 
operation is evaluated as x = x op y, except that x is evaluated only once. 

• Otherwise, if the selected operator is a predefined operator, if the return type of the 
selected operator is explicitly convertible to the type of x, and if y is implicitly convertible 
to the type of x or the operator is a shift operator, then the operation is evaluated as x = 
(T) (x op y), where T is the t 5 ^e of x, except that x is evaluated only once. 

• Otherwise, the compound assignment is invalid, and a binding-time error occurs. 


"■ PETER SESTOFT The condition of y being implicitly convertible to the t 5 ^e of x 
in the second item means that the compound operators are more restrictive in C# than 
in the C, C++, and Java programming languages. In those languages, the assignment 
x+=0.9 is legal even if variable x has integer type. When x is non-negative, the assign¬ 
ment has no effect; when x is negative, it adds 1 to x. In C#, the assignment is rejected— 
wisely, in my opinion. 




"■ VLADIMIR RESHETNIKOV A curious consequence of these rules is that the 
expression x <<= null is legal if the variable x has type int. Of course, it will always 
throw an exception at runtime. 


393 


www.it-ebooks.info 


Expressions 












Expressions 


7. Expressions 


The term "evaluated only once" means that in the evaluation of x op y, the results of any 
consfifuenf expressions of x are femporarily saved and fhen reused when performing fhe 
assignmenf fo x. For example, in fhe assignmenf A()[B()] +=C(), where A is a mefhod 
refurning int[], and B and C are mefhods refurning int, fhe mefhods are invoked only 
once, in the order A, B, C. 

When the left operand of a compound assignmenf is a properfy access or an indexer access, 
fhe property or indexer must have both a get accessor and a set accessor. If fhis is nof fhe 
case, a binding-fime error occurs. 

The second rule above permifs x op= y fo be evaluafed as x = (T) (x op y ) in cerfain confexfs. 
The rule exisfs such fhaf fhe predefined operafors can be used as compound operafors 
when fhe leff operand is of type sbyte, byte, short, ushort, or char. Even when both argu¬ 
ments are of one of fhose fypes, fhe predefined operafors produce a resulf of fype int, as 
described in §7.3.6.2. Thus, wifhouf a casf, if would nof be possible fo assign fhe resulf fo 
fhe leff operand. 

The infuifive effecf of fhe rule for predefined operafors is simply fhaf x op= y is permiffed 
if bofh X op y and x = y are permiffed. In fhe example 

byte b = 0; 
char ch = '\0'; 
int i = 0; 


i; 

// Okay 



1000; 

// Error: 

b = 

1000 not permitted 

1; 

// Error: 

b = 

i not permitted 

(byte)i; 

// Okay 



1; 

// Error: 

ch : 

= 1 not permitted 

: (char)l; 

// Okay 




fhe intuifive reason for each error is fhaf a corresponding simple assignmenf would also 
have been an error. 

This also means fhaf compound assignmenf operafions supporf liffed operafions. In fhe 
example 

int? i = 0; 

i += 1; // Ok 

fhe liffed operator +( int?, int?) is used. 

7.17.3 Event Assignment 

If fhe leff operand of a += or -= operafor is classified as an evenf access, fhen fhe expression 
is evaluafed as follows: 


394 


www.it-ebooks.info 




7.19 Constant Expressions 


• The instance expression, if any, of fhe evenf access is evaluafed. 

• The righf operand of fhe += or - = operafor is evaluafed, and, if required, converfed fo fhe 
fype of fhe leff operand fhrough an implicif conversion (§6.1). 

• An evenf accessor of fhe evenf is invoked, wifh argumenf lisf consisfing of fhe righf 
operand, affer evaluafion and, if necessary, conversion. If fhe operafor was +=, fhe add 
accessor is invoked; if fhe operafor was fhe remove accessor is invoked. 

An evenf assignmenf expression does nof yield a value. Thus an evenf assignmenf expres¬ 
sion is valid only in fhe confexf of a statement-expression (§8.6). 


7.18 Expression 

An expression is eifher a non-assignment-expression or an assignment, 
expression: 

non-assignment-expression 

assignment 

non-assignment-expression: 

conditional-expression 

lambda-expression 

query-expression 




7.19 Constant Expressions 

A constant-expression is an expression fhaf can be fully evaluafed af compile fime. 

constant-expression: 

expression 

A consfanf expression musf be fhe null liferal or a value wifh one of fhe following f 5 q)es: 
sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, 
string, or any enumerafion fype. Only fhe following consfrucfs are permitted in consfanf 
expressions: 

• Liferals (including fhe null liferal). 

• References fo const members of class and sfrucf f 5 q)es. 

• References fo members of enumerafion fypes. 

• References fo const paramefers or local variables. 

• Parenfhesized subexpressions, which are fhemselves consfanf expressions. 


395 


www.it-ebooks.info 


Expressions 




Expressions 


7. Expressions 


• Cast expressions, provided the target type is one of the t 5 ^es listed above. 

• checked and unchecked expressions. 

• Default value expressions. 

• The predefined !, and ~ unary operators. 

• The predefined +, *, /, %,«,>>,&, |,&&, | |, ==, ! =, <, >, <=, and >= binary operators, 

provided each operand is of a fype lisfed above. 

• The ?: condifional operafor. 

The following conversions are permiffed in consfanf expressions: 

• Identify conversions. 

• Numeric conversions. 

• Enumeration conversions. 

• Consfanf expression conversions. 

• Implicif and explicif reference conversions, provided fhaf fhe source of fhe conversions 
is a consfanf expression fhaf evaluafes fo fhe null value. 

Ofher conversions, including boxing, unboxing, and implicif reference conversions of non¬ 
null values, are nof permiffed in consfanf expressions. For example: 

class C { 

const object i = 5; // Error: boxing conversion not permitted 

const object str = "hello"; // Error: implicit reference conversion 

} 

In fhis example, fhe inifializafion of i is an error because a boxing conversion is required. 
The inifializafion of str is an error because an implicif reference conversion from a non¬ 
null value is required. 

Whenever an expression fulfills fhe requiremenfs lisfed above, fhe expression is evaluated 
af compile time. This is frue even if fhe expression is a subexpression of a larger expression 
fhaf confains nonconsfanf consfrucfs. 

The compile-fime evaluation of consfanf expressions uses fhe same rules as runtime evalu¬ 
ation of nonconsfanf expressions, excepf fhaf where runfime evaluation would have 
thrown an exception, compile-time evaluation causes a compile-time error to occur. 

Unless a constant expression is explicitly placed in an unchecked context, overflows fhaf 
occur in infegral-fjq^e arifhmefic operafions and conversions during fhe compile-fime eval¬ 
uation of fhe expression always cause compile-fime errors (§7.19). 


396 


www.it-ebooks.info 




7.20 Boolean Expressions 


Constant expressions occur in the contexts listed below. In these contexts, a compile-time 
error occurs if an expression cannot be fully evaluated at compile time. 

• Constant declarations (§10.4). 

• Enumeration member declarations (§14.3). 

• case labels of a switch statemenf (§8.7.2). 

• goto case statements (§8.9.3). 

• Dimension lengths in an array creation expression (§7.6.10.4) that includes an 
initializer. 

• Attributes (§17). 

An implicit constant expression conversion (§6.1.8) permits a constant expression of type 
int to be converted to sbyte, byte, short, ushort, uint, or ulong, provided the value of the 
constant expression is within the range of the destination t 5 ^e. 


7.20 Boolean Expressions 

A boolean-expression is an expression that yields a result of type bool, either directly or 
through application of operator true m certain contexts as specified in fhe following. 

boolean-expression: 

expression 

The controlling conditional expression of an if-statement (§8.7.1), while-statement (§8.8.1), 
do-statement (§8.8.2), or for-statement (§8.8.3) is a boolean-expression. The confrolling condi- 
fional expression of the ?: operator (§7.14) follows fhe same rules as a boolean-expression, 
buf for reasons of operator precedence is classified as a conditional-or-expression. 

A boolean-expression is required to be implicitly convertible to bool or of a t 5 q)e that imple¬ 
ments operator true. If neifher requiremenf is satisfied, a binding-fime error occurs. 

When a boolean expression carmot be implicitly converted to bool but does implement 
operator true, then following evaluation of the expression, the operator true implemen¬ 
tation provided by that t 5 q)e is invoked to produce a bool value. 

The DBBool struct t 5 q)e in §11.4.2 provides an example of a type that implements operator 
true and operator false. 




397 


www.it-ebooks.info 


Expressions 




This page intentionally left blank 


www.it-ebooks.info 


8. Statements 


C# provides a variety of statements. Most of these statements will be familiar to developers 
who have programmed in C and C++. 

statement: 

labeled-statement 

declaration-statement 

embedded-statement 

embedded-statement: 

block 

empty-statement 

expression-statement 

selection-statement 

iteration-statement 

jump-statement 

try-statement 

checked-s tatement 

unchecked-statement 

lock-statement 

using-statement 

yield-statement 

The embedded-statement nonterminal is used for statements that appear within other state¬ 
ments. The use of embedded-statement rather than statement excludes the use of declaration 
statements and labeled statements in these contexts. The example 

void F(bool b) { 
if (b) 

int i = 44; 

} 

results in a compile-time error because an if statement requires an embedded-statement 
rather than a statement for its if branch. If this code were permitted, then the variable i 


399 


www.it-ebooks.info 




Statements 


8. Statements 


would be declared, but it could never be used. Note, however, that by placing i's declara¬ 
tion in a block, the example is valid. 


00 


8.1 End Points and Reachability 

Every statement has an end point. In intuitive terms, the end point of a statement is the 
location that immediately follows the statement. The execution rules for composite state¬ 
ments (statements that contain embedded statements) specify the action that is taken when 
control reaches the end point of an embedded statement. For example, when control 
reaches the end point of a statement in a block, control is transferred to the next statement 
in the block. 

If a statement can possibly be reached by execution, the statement is said to be reachable. 
Conversely, if there is no possibility that a statement will be executed, the statement is said 
to be unreachable. 

In the example 

void F() { 

Console.WriteLine("reachable"); 
goto Label; 

Console.WriteLine("unreachable"); 

Label: 

Console.WriteLine("reachable"); 

} 

the second invocation of Console .WriteLine is unreachable because there is no possibility 
that the statement will be executed. 

A warning is reported if the compiler determines that a statement is unreachable. It is spe¬ 
cifically not an error for a statement to be unreachable. 

To determine whether a particular statement or end point is reachable, the compiler per¬ 
forms flow analysis according to the reachability rules defined for each statement. The flow 
analysis takes into account the values of constant expressions (§7.19) that control the behav¬ 
ior of sfatements, but the possible values of nonconsfant expressions are not considered. In 
other words, for purposes of control flow analysis, a nonconstant expression of a given 
type is considered to have any possible value of that t 5 ^e. 

In the example 

void F() { 

const int i = 1; 

if (i == 2) Console.WriteLineC'unreachable"); 

} 


400 


www.it-ebooks.info 




8.1 End Points and Reachability 


the boolean expression of the if statement is a constant expression because both operands 
of the == operator are constants. As the constant expression is evaluated at compile time, 
producing the value false, the Console.WriteLine invocation is considered unreachable. 
However, if i is changed to be a local variable 

void F() { 

int i = 1; 

if (i == 2) Console.WriteLineC'reachable"); 

} 

the Console .WriteLine invocation is considered reachable, even though, in reality, it will 
never be executed. 


"■ ERIC LIPPERT Many other expressions that humans know will always be false 
are not considered to be false by the flow analyzer. For example, if we replaced the 
condition of the if statement above with (i * 0 == 0), then the consequence would 
be reachable according to the specification—even though you and 1 know that it will 
not be reachable in practice. 


The block of a function member is always considered reachable. By successively evaluating 

the reachability rules of each statement in a block, the reachability of any given statement 

can be determined. 

In the example 

void F(int x) { 

Console.WriteLine("start"); 

if (x < 0) Console.WriteLineC'negative"); 

} 

the reachability of the second Console. WriteLine is determined as follows: 

• The first Console. WriteLine expression statement is reachable because the block of the 
F method is reachable. 

• The end point of the first Console. WriteLine expression statement is reachable because 
that statement is reachable. 

• The if statement is reachable because the end point of the first Con sole. Write Line 
expression statement is reachable. 

• The second Console. WriteLine expression statement is reachable because the boolean 
expression of the if statement does not have the constant value false. 


00 


401 


www.it-ebooks.info 


Statements 






Statements 


8. Statements 


There are two situations in which it is a compile-time error for the end point of a sfafemenf 
fo be reachable: 

• Because fhe switch sfafemenf does nof permif a swifch section fo "fall fhrough" fo fhe 
nexf swifch section, if is a compile-fime error for fhe end poinf of fhe sfafemenf lisf of a 
swifch secfion fo be reachable. If fhis error occurs, if is f 5 ^ically an indication that a 
break statement is missing. 

• It is a compile-time error for fhe end poinf of fhe block of a funcfion member fhaf com- 
pufes a value fo be reachable. If fhis error occurs, if f 5 ^ically is an indicafion fhaf a 
return sfafemenf is missing. 


"■ BILL WAGNER The rules for reachable code are designed fo err on fhe side of 
assuming code is reachable. For example, fhe following example does nof generafe 
any warnings for unreachable code: 

public class Program 
{ 

public static int counter = 5; 

static void Main(string[] args) 

{ 

if (counter == 6) 

Console.WriteLine("weird"); 

else 

Console.WriteLine("normal"); 

} 

} 

If's obvious fo human readers fhaf "weird" will never appear on your console. The 
language rules do nof follow fhe same reasoning. 


00 


8.2 Blocks 

A block permifs mulfiple sfafemenfs fo be wriffen in confexfs where a single sfafemenf is 
allowed. 

block: 

{ statement-list , } 

A block consisfs of an optional statement-list (§8.2.1), enclosed in braces. If fhe sfafemenf lisf 
is omitted, fhe block is said fo be empfy. 


402 


www.it-ebooks.info 






8.2 Blocks 


Ablock may contain declaration statements (§8.5). The scope of a local variable or constant 
declared in a block is the block. 

Within a block, the meaning of a name used in an expression confexf musf always be fhe 
same (§7.6.2.1). 

A block is execufed as follows: 

• If fhe block is empfy, confrol is fransferred fo fhe end poinf of fhe block. 

• If fhe block is nof empfy, confrol is fransferred fo fhe sfafemenf lisf. When and if con¬ 
frol reaches fhe end poinf of fhe sfafemenf lisf, confrol is fransferred fo fhe end poinf 
of fhe block. 

The sfafemenf lisf of a block is reachable if fhe block ifself is reachable. 

The end poinf of a block is reachable if fhe block is empfy or if fhe end poinf of fhe sfafe¬ 
menf lisf is reachable. 

A block fhaf confains one or more yield sfafemenfs (§8.14) is called an iferafor block. Ifera- 
for blocks are used fo implemenf function members as iferafors (§10.14). Some additional 
resfricfions apply fo iferafor blocks: 

• If is a compile-fime error for a return sfafemenf fo appear in an iferafor block (buf yield 
return sfafemenfs are permiffed). 

• If is a compile-fime error for an iferafor block fo confain an unsafe confexf (§18.1). An 
iferafor block always defines a safe confexf, even when ifs declarafion is nesfed in an 
unsafe confexf. 

8.2.1 Statement Lists 

A statement list consisfs of one or more sfafemenfs written in sequence. Sfafemenf lisfs 
occur in blocks (§8.2) and in switch-blocks (§8.7.2). 

statement-list: 

statement 

statement-list statement 


00 


A sfafemenf lisf is execufed by fransferring control to the first statement. When and if con¬ 
trol reaches the end point of a sfafemenf, confrol is fransferred fo fhe nexf sfafemenf. When 
and if confrol reaches fhe end poinf of fhe lasf sfafemenf, confrol is fransferred fo fhe end 
poinf of fhe sfafemenf lisf. 


403 


www.it-ebooks.info 


Statements 




Statements 


8. Statements 


A statement in a statement list is reachable if at least one of fhe following is frue: 

• The sfafemenf is fhe firsf sfafemenf and fhe sfafemenf lisf ifself is reachable. 

• The end poinf of fhe preceding sfafemenf is reachable. 

• The sfafemenf is a labeled sfafemenf and fhe label is referenced by a reachable goto 
sfafemenf. 


“■ VLADIMIR RESHETNIKOV This rule is nof applied when fhe goto sfafemenf is 
placed inside a try or catch block of a try sfafemenf fhaf includes a finally block, 
and fhe labeled sfafemenf is oufside fhe try sfafemenf, and fhe end poinf of fhe 
finally block is unreachable. For example: 

class C 
{ 

static void Main() 

{ 

int x; 
try 
{ 

goto A; // Reachable statement 

} 

finally 

{ 

throw new System.Exceptlon(); 

} 

A: x.ToStringO; // Unreachable statement 

} 

} 


The end poinf of a sfafemenf lisf is reachable if fhe end poinf of fhe lasf sfafemenf in fhe lisf 
is reachable. 


8.3 The Empty Statement 

An empty-statement does nofhing. 
empty-statement: 


00 


An empfy sfafemenf is used when fhere are no operafions fo perform in a confexf where a 
sfafemenf is required. 


404 


www.it-ebooks.info 






8.3 The Empty Statement 


■■ JONSKEET Given how easy it is to miss an empty statement when reading code, 
I wonder whether something larger might be useful for fhis relafively rare require- 
menf. For example, fhe following code is legal buf probably nof whaf's inf ended: 


while (text.IndexOf("xx") != -1); 

{ 

text = text.ReplaceC'xx", "x"); 

} 


The empfy sfafemenf for fhe while loop is fairly well camouflaged. If you had fo wrife 
somefhing like "voidj" when you acfually wanfed an empfy sfafemenf, fhe compiler 
could flag "accidenfally empfy" sfafemenfs like fhe previous example as errors. 


"■ JESSE LIBERTY Jon's example shows why empfy sfafemenfs should be rare, and 
called ouf (fhough nof necessarily wifh commenfs). The problem in his example code 
can be rectified by following fhe besf pracfice of empfy sfafemenfs exisfing eifher on a 
line by fhemselves or, even better, wifhin full braces: 


while (text.IndexOf("xx") != -1) 
{ 

J 

} 


{ 

text = text.ReplaceC'xx", "x"); 

} 


No programmer can now miss fhaf fhe while loop has an empfy sfafemenf. The pur¬ 
pose of fhe nexf sef of braces is no more (or less) ambiguous fhan if was, buf fhe whife 
space helped avoid fhe confusion. 


Execufion of an empfy sfafemenf simply fransfers confrol fo fhe end poinf of fhe sfafemenf. 
Thus fhe end poinf of an empfy sfafemenf is reachable if fhe empfy sfafemenf is 
reachable. 


00 


An empfy sfafemenf can be used when wrifing a while sfafemenf wifh a null body: 

bool ProcessMessage() {...} 

void ProcessMessagesO { 

while (ProcessMessage()) 

J 

} 


405 


www.it-ebooks.info 


Statements 








Statements 


8. Statements 


Also, an empty statement can be used to declare a label just before the closing "}" of 
a block: 

void F() { 

if (done) goto exit; 
exit: ; 

} 


00 


8.4 Labeled Statements 

A labeled-statement permifs a sfafemenf fo be prefixed by a label. Labeled sfafemenfs are 
permitted in blocks, buf are nof permitted as embedded sfafemenfs. 

labeled-statement: 

identifier : statement 

A labeled sfafemenf declares a label wifh fhe name given by fhe identifier. The scope of a 
label is fhe whole block in which fhe label is declared, including any nesfed blocks. If is a 
compile-fime error for fwo labels wifh fhe same name fo have overlapping scopes. 

A label can be referenced from goto sfafemenfs (§8.9.3) wifhin fhe scope of fhe label. This 
means fhaf goto sfafemenfs can fransfer confrol wifhin blocks and ouf of blocks, buf never 
info blocks. 

Labels have fheir own declarafion space and do nof inferfere wifh ofher idenfifiers. The 
example 

int F(int x) { 

if (x >= 0) goto x; 

X = -x; 
x: return x; 

} 

is valid and uses fhe name x as bofh a paramefer and a label. 

Execution of a labeled sfafemenf corresponds exacfly fo execution of fhe sfafemenf follow¬ 
ing fhe label. 

In addition fo fhe reachabilify provided by normal flow of confrol, a labeled sfafemenf is 
reachable if fhe label is referenced by a reachable goto sfafemenf. (Excepfion: If a goto 
sfafemenf is inside a try fhaf includes a finally block, and fhe labeled sfafemenf is oufside 
fhe try, and fhe end poinf of fhe finally block is unreachable, fhen fhe labeled sfafemenf 
is nof reachable from fhaf goto sfafemenf.) 


406 


www.it-ebooks.info 




8.5 Declaration Statements 


“■ ERIC LI PPERT For example, the finally block might always throw an exception, 
in which case there would be a reachable goto targeting a potentially unreachable 
label. 


“■ PETER SESTOFT See also the armotations in the discussion of the goto statement 
in §8.9.3. 


8.5 Declaration Statements 

A declaration-statement declares a local variable or constant. Declaration statements are 
permitted in blocks, but are not permitted as embedded statements. 

declaration-statement: 

local-variable-declaration ; 
local-constant-declaration ; 


8.5.1 Local Variable Declarations 

A local-variable-declaration declares one or more local variables. 

local-variable-declaration: 

local-variable-type local-variable-declarators 

local-variable-type: 

type 

var 

local-variable-declarators: 

local-variable-declarator 

local-variable-declarators , local-variable-declarator 

local-variable-declarator: 

identifier 

identifier = local-variable-initializer 

local-variable-initializer: 

expression 

array-initializer 


00 


407 


www.it-ebooks.info 


Statements 








Statements 


8. Statements 


The local-variable-type of a local-variable-declaration either directly specifies the type of the 
variables introduced by the declaration, or indicates with the identifier var that the type 
should be inferred based on an initializer. The t5^e is followed by a list of local-variable- 
declarators, each of which introduces a new variable. A local-variable-declarator consists of an 
identifier that names the variable, optionally followed by an token and a local-variable- 
initializer that gives the initial value of the variable. 

In the context of a local variable declaration, the identifier var acts as a contextual keyword 
(§2.4.3).When the local-variable-type is specified as var and no type named var is in scope, 
the declaration is an implicitly typed local variable declaration, whose t5^e is inferred 
from the type of the associated initializer expression. Implicitly typed local variable decla¬ 
rations are subject to the following restrictions: 

• The local-variable-declaration cannot include multiple local-variable-declarators. 

• The local-variable-declarator must include a local-variable-initializer. 

• The local-variable-initializer must be an expression. 

• The initializer expression must have a compile-time type. 

• The initializer expression carmot refer to the declared variable itself. 


00 


■■ ERICLIPPERT In an early design for this feature, it was legal to have multiple 
declarators. 

var a = 1, b = 2.5; 

When C# developers were shown this code, roughly half said that it should have the 
same semantics as 

double a = 1, b = 2.5; 

The other half said that it should have the same semantics as 
int a = 1; double b = 2.5; 

Both sides thought that their interpretation was the "obviously correct" one. 

When faced with a S5mtax that admits two incompatible "obviously correct" interpre¬ 
tations, often the best thing to do is to disallow the S5mtax entirely rather than to breed 
confusion. 


“■ CHRISSELLS I think multiple variable declarations in the same statement just to 
reuse the type name should be illegal, too. 


408 


www.it-ebooks.info 








8.5 Declaration Statements 


“■ ERIC LI PPERT This constraint stands in contrast to an explicitly t 5 ^ed local vari¬ 
able declaration, which does permit an initializer to reference itself. 

For example, int j = M(out j)j is sfrange,buf legal. If fhis expression were var j = 
M(out j), fhen overload resolufion could nof defermine fhe 1)^0 refurned by M, and 
hence fhe fype of j, until fhe fype of fhe argumenf was known. Of course, fhe f 5 ^e of 
fhe argumenf is exacfly whaf we are frying fo defermine. 

Rafher fhan affempfing fo solve fhis "chicken and egg" problem, fhe language speci¬ 
fication simply makes fhis case illegal. 


The following are examples of incorrecf implicifly fyped local variable declarations: 


x; 


// 

Error: 

no initializer to infer type from 

y = {1. 2 , 

3}; 

// 

Error: 

array initializer not permitted 

z = null; 


// 

Error: 

null does not have a type 

U = X => X 

+ I; 

// 

Error: 

anonymous functions do not have a type 

V = V++; 


// 

Error: 

initializer cannot refer to variable itself 


The value of a local variable is obfained in an expression using a simple-name (§7.6.2), and 
fhe value of a local variable is modified using an assignment (§7.17). A local variable musf 
be definifely assigned (§5.3) af each locafion where ifs value is obfained. 


"■ CHRISSELLS I really love implicifly f 5 ^ed local variable declarations when fhe 
fype is anonymous (in which case, you have fo use fhem) or when fhe f}^’^ of fhe vari¬ 
able is made explicif as parf of fhe sfafemenf fhaf initializes if, buf nof because you're 
too lazy fo f5q3e! 


For example: 


var a = new { Name = 
van b - 1; 

van V = new Person(); 
van d = GetPersonO; 


Bob", Age = 42 }; // 
// 
// 
// 


Good 

Good 

Good 

BAD! 


The compiler is perfecfly happy wifh d as an implicifly f 5 ^ed variable, buf pify fhe 
poor human reader! 


00 


409 


www.it-ebooks.info 


Statements 








Statements 


8. Statements 


“■ ERIC LIPPERT I generally agree with the annotation above but would make 
one additional point: var works well when the writer of the code is attempting to 
communicate "the storage type of fhis variable is unimporfanf; whaf is imporfanf is 
fhe meaning of fhe variable, nof ifs implemenfafion defails." For example. I'll offen 
wrife code like "var attributes = ParseMethodAttributes();" —I am saying here 
fhaf if doesn'f maffer whefher whaf comes back is AttributeSyntax[ ] or 
List<AttributeSyntax>. Whaf maffers is fhaf fhe collecfion of affribufes has been 
parsed. 


“■ BILL WAG N E R I freely admif fo being guilfy of using var exfensively. In facf, my 
habif is fo use implicifly f5^ed variables for almosf everyfhing excepf simple f5^es. I 
find fhaf if's much more imporfanf fo have a semanfic undersfanding of a variable 
rafher fhan a S5mfacfic undersfanding of a variable. In Chris's example, GetPersonf) 
would logically refurn a Person, or an IPerson, or somefhing derived from Person or 
from implemenfing IPerson. In all fhose cases. I'm fine wifh fhaf bif of ambiguify. I 
undersfand fhe concepf of "a variable fhaf represenfs somefhing person-like" wifhouf 
knowing ifs exacf 1)^0. 


00 


The scope of a local variable declared in a local-variable-declaration is fhe block in which fhe 
declarafion occurs. If is an error fo refer fo a local variable in a fexfual posifion fhaf pre¬ 
cedes fhe local-variable-declarator of fhe local variable. Wifhin fhe scope of a local variable, if 
is a compile-fime error fo declare anofher local variable or consfanf wifh fhe same name. 

A local variable declarafion fhaf declares mulfiple variables is equivalenf fo multiple dec¬ 
larations of single variables wifh fhe same fype. Furfhermore, a variable initializer in a 
local variable declarafion corresponds exacfly fo an assignmenf sfafemenf fhaf is inserfed 
immediafely affer fhe declarafion. 

The example 

void F() { 

int X = 1, y, z = X * 2; 

} 

corresponds exacfly fo 

void F() { 

int x; X = 1; 
int y; 

int z; z - X * 2; 

} 


410 


www.it-ebooks.info 








8.5 Declaration Statements 


In an implicitly typed local variable declaration, the t5^e of the local variable being declared 
is taken to be the same as the type of fhe expression used fo inifialize fhe variable. For 
example: 

van i = 5; 
van s = "Hello"; 
van d = 1.0; 

van numbers = new int[] {1, 2, 3}; 

van orders = new Dictionary<int,Order>(); 

The implicifly fyped local variable declarafions above are precisely equivalenf fo fhe fol¬ 
lowing explicifly f5q)ed declarafions: 

int 1=5; 
string s = "Hello"; 
double d = 1.0; 

int[] numbers = new int[] {1, 2, 3}; 

Dictionary<int,Order> orders = new Dictionary<int,Order>(); 


“■ PETER SESTOFT Whereas if is possible fo declare local (compile-fime) con- 
sfanfs, one cannof declare a read-only local variable or read-only mefhod paramefer 
in C#, unlike Sfandard ML's and Scala's val, F#'s let, and Java's final. Being an old 
funcfional programmer, I find fhis a bif sad; offen I jusf wanf fo name a value, nof 
declare a mufable variable. The using sfafemenf (§ 8 . 13 ) does allow me fo declare an 
immufable local variable, buf fhaf's cumbersome and unidiomafic (and hence con¬ 
fusing fo mosf C# developers), and if works only for local variables, nof for mefhod 
paramefers. 


8.5.2 Local Constant Declarations 

A local-constant-declaration declares one or more local consfanfs. 

local-constant-declaration: 

const type constant-declarators 

constant-declarators: 

constant-declarator 

constant-declarators , constant-declarator 

constant-declarator: 

identifier = constant-expression 

The type of a local-constant-declaration specifies fhe f5T>e of fhe consfanfs infroduced by fhe 
declarafion. The type is followed by a lisf of constant-declarators, each of which infroduces 


00 


411 


www.it-ebooks.info 


Statements 






Statements 


8. Statements 


a new constant. A constant-declarator consists of an identifier that names the constant, 
followed by an token, followed by a constant-expression (§7.19) fhaf gives fhe value of 
fhe consfanf. 

The type and constant-expression of a local consfanf declaration musf follow fhe same rules 
as fhose of a consfanf member declarafion (§10.4). 

The value of a local consfanf is obfained in an expression using a simple-name (§7.6.2). 

The scope of a local consfanf is fhe block in which fhe declarafion occurs. If is an error to 
refer fo a local consfanf in a fexfual position fhaf precedes ifs constant-declarator. Wifhin fhe 
scope of a local consfanf, if is a compile-fime error fo declare anofher local variable or con¬ 
sfanf wifh fhe same name. 

A local consfanf declarafion fhaf declares multiple consfanfs is equivalenf fo multiple dec¬ 
larations of single consfanfs wifh fhe same f 5 T>e. 


8.6 Expression Statements 

An expression-statement evaluafes a given expression. The value compufed by fhe expres¬ 
sion, if any, is discarded. 

exp ress ion-sta temen t: 

statement-expression ; 

statement-expression: 

invocation-expression 

object-creation-expression 

assignment 

post-increment-expression 

post-decrement-expression 

pre-increment-expression 

pre-decrement-expression 

Nof all expressions are permitted as sfafemenfs. In particular, expressions such as x + y and 
X == 1 fhaf merely compufe a value (which will be discarded) are nof permiffed as 
sfafemenfs. 

Execution of an expression-statement evaluafes fhe confained expression and fhen fransfers 
confrol fo fhe end poinf of fhe expression-statement. The end poinf of an expression-statement 
is reachable if fhaf expression-statement is reachable. 


412 


www.it-ebooks.info 




8.7 Selection Statements 


“■ JON SKEET Occasionally, someone suggests that methods should be allowed to 
declare themselves as never-ending; that is, they never return normally With this 
scheme, the only way in which they could terminate would be via an exception. An 
obvious example of such a method would be Assert. Fail in a unit testing library. 

If such a feature ever appeared, the end point of expression statements that invoked 
such methods would be unreachable. Just occasionally, this S 5 mtax would avoid the 
need for a "dummy" return or throw statement that you know will never be executed. 
I suspect the extra complexity (in terms of both the language and the implementation) 
is greater than the slight benefit afforded. 


"■ ERIC LI PPERT The committee that standardizes the ECMAScript language has in 
the past proposed a "never" t 5 ^e that has the semantics Jon is describing. I agree that 
it would be nice to have in C#, but at this point the cost probably outweighs the rela¬ 
tively small benefits. 


8.7 Selection Statements 

Selection statements select one of a number of possible statements for execution based on 
the value of some expression. 

selection-statement: 

if-statement 

switch-statement 


8.7.1 The if Statement 

The if stafement selects a statement for execution based on the value of a boolean 
expression. 

if-statement: 

if ( boolean-expression ) embedded-statement 

if ( boolean-expression ) embedded-statement else embedded-statement 

An else parf is associated with the lexically nearest preceding if that is allowed by the 
S5mtax. Thus an if statement of the form 

if (x) if (y) F(); else G(); 


00 


413 


www.it-ebooks.info 


Statements 








Statements 


8. Statements 


is equivalent to 

if (X) { 

it (y) { 

F(); 

} 

else { 

G(); 

} 

} 

An if statement is executed as follows: 

• The boolean-expression (§7.20) is evaluated. 

• If the boolean expression yields true, control is transferred to the first embedded state¬ 
ment. When and if control reaches the end point of that statement, control is transferred 
to the end point of the if statement. 

• If the boolean expression yields false and if an else part is present, control is trans¬ 
ferred to the second embedded statement. When and if control reaches the end point of 
that statement, control is transferred to the end point of the if statement. 

• If the boolean expression yields false and if an else part is not present, control is trans¬ 
ferred to the end point of the if statement. 

The first embedded statement of an if statement is reachable if the if statement is reach¬ 
able and the boolean expression does not have the constant value false. 

The second embedded statement of an if statement, if present, is reachable if the if state¬ 
ment is reachable and the boolean expression does not have the constant value true. 

The end point of an if statement is reachable if the end point of at least one of its embed¬ 
ded statements is reachable. In addition, the end point of an if statement with no else part 
is reachable if the if statement is reachable and the boolean expression does not have the 
constant value true. 


00 


8.7.2 The switch Statement 

The switch statement selects for execution a statement list having an associated switch 
label that corresponds to the value of the switch expression. 

switch-statement: 

switch ( expression ) switch-block 

switch-block: 

{ switch-sections . } 

opt J 


414 


www.it-ebooks.info 




8.7 Selection Statements 


switch-sections: 

switch-section 

switch-sections switch-section 

switch-section: 

switch-labels statement-list 

switch-labels: 

switch-label 

switch-labels switch-label 
switch-label: 

case constant-expression : 
default : 

A switch-statement consists of the ke 5 rword switch, followed by a parenthesized expression 
(called the switch expression), followed by a switch-block. The switch-block consists of zero 
or more switch-sections, enclosed in braces. Each switch-section consists of one or more 
switch-labels followed by a statement-list (§8.2.1). 

The governing type of a switch statement is established by the switch expression. 

• If the type of the switch expression is sbyte, byte, short, ushort, int, uint, long, ulong, 
bool, char, string, or an enum-type, or if it is the nullable t 5 ^e corresponding to one of 
fhese types, then that is the governing type of the switch statement. 

• Otherwise, exactly one user-defined implicif conversion (§6.4) musf exist from the type 
of fhe swifch expression fo one of the following possible governing types: sbyte, byte, 
short, ushort, int, uint, long, ulong, char, string, or, a nullable t 5 rpe corresponding to 
one of those types. 

• Otherwise, if no such implicit conversion exists, or if more than one such implicit con¬ 
version exists, a compile-time error occurs. 

The constant expression of each case label musf denofe a value fhaf is implicitly convert¬ 
ible (§6.1) to the governing type of the switch statement. A compile-time error occurs if fwo 
or more case labels in the same switch statement specify fhe same constanf value. 

There can be af most one default label in a switch statement. 

A switch statement is executed as follows: 

• The switch expression is evaluated and converted to the governing type. 

• If one of the constants specified in a case label in fhe same switch statemenf is equal fo 
fhe value of the switch expression, control is transferred fo the statement list following 
fhe mafched case label. 


00 


415 


www.it-ebooks.info 


Statements 




Statements 


8. Statements 


00 


• If none of fhe consfanfs specified in case labels in fhe same switch sfafemenf is equal fo 
fhe value of fhe swifch expression, and if a default label is presenf, confrol is fransferred 
fo fhe sfafemenf lisf following fhe default label. 

• If none of fhe consfanfs specified in case labels in fhe same switch sfafemenf is equal fo 
fhe value of fhe swifch expression, and if no default label is presenf, confrol is frans¬ 
ferred fo fhe end poinf of fhe switch sfafemenf. 

If fhe end poinf of fhe sfafemenf lisf of a swifch secfion is reachable, a compile-fime error 
occurs. This is known as fhe "no fall fhrough" rule. The example 

switch (i) { 
case 0: 

CaseZero(); 
break; 
case 1: 

CaseOne(); 
break; 
default: 

CaseOthersO; 

break; 

} 

is valid because no swifch section has a reachable end point. Unlike C and C++, execution 
of a switch section is not permitted to "fall through" to the next switch section, and the 
example 

switch (i) { 
case 0: 

CaseZero(); 
case 1: 

CaseZeroOrOne(); 
default: 

CaseAny(); 

} 

results in a compile-time error. When execution of a switch section is to be followed by 
execution of another switch section, an explicit goto case or goto default statement must 
be used: 

switch (i) { 
case 0: 

CaseZero(); 
goto case 1; 
case 1: 

CaseZeroOrOne(); 
goto default; 
default: 

CaseAny(); 
break; 

} 


416 


www.it-ebooks.info 




8.7 Selection Statements 


Multiple labels are permitted in a switch section. The example 

switch (i) { 
case 0: 

CaseZero(); 
break; 
case 1: 

CaseOne(); 
break; 
case 2: 
default: 

CaseTwo(); 
break; 

} 

is valid. The example does not violate the "no fall through" rule because the labels case 2: 
and default : are part of the same switch section. 

The "no fall through" rule prevents a common class of bugs that occur in C and C++ when 
break statements are accidentally omitted. In addition, because of this rule, the switch sec¬ 
tions of a switch statement can be arbitrarily rearranged without affecting the behavior of 
fhe statement. For example, the sections of the switch statement above can be reversed 
without affecting the behavior of the statement: 

switch (i) { 
default: 

CaseAny(); 
break; 
case 1: 

CaseZeroOrOne(); 
goto default; 
case 0: 

CaseZero(); 
goto case 1; 

} 

The statement list of a switch section t 5 ^ically ends in a break, goto case, or goto default 
statement, but any construct that renders the end point of the statement list unreachable is 
permitted. For example, a while statement controlled by the boolean expression true is 
known to never reach its end point. Likewise, a throw or return statement always transfers 
control elsewhere and never reaches its end point. Thus the following example is valid: 

switch (i) { 
case 0: 

while (true) F(); 
case 1: 

throw new ArgumentExceptlon(); 
case 2: 

return; 

} 


00 


417 


www.it-ebooks.info 


Statements 




Statements 


8. Statements 


■■ JON SKEET I wonder whether it might have been wise for the C# designers to 
have redesigned switch/ case from scrafch. The scoping rules for variables inf reduced 
in cases are somewhaf surprising, and fhe break sfafemenf feels wrong, foo. I believe 
developers fhink of cases as blocks—so why nof enforce fhaf? 

case 0: 

{ 

// Code for case 0 goes here, with no need for a break 

} 

Likewise, if would probably have been more readable fo allow a comma-separafed lisf 
of expressions for mulfiple cases fo mafch a single block, rafher fhan repealing whole 
case labels. 


00 


The governing f 5 ^e of a switch sfafemenf maybe fhe fype string. For example: 

void DoCommand(string command) { 
switch (command.ToLowerO) { 
case "run": 

DoRunO; 

break; 

case "save"; 

DoSave(); 
break; 

case "quit": 

DoQuit(); 
break; 
default: 

InvalidCommand(command); 
break; 

} 

} 

Like fhe siring equably operators (§7.10.7), fhe switch sfafemenf is case sensifive and will 
execufe a given swifch secfion only if fhe swifch expression siring exacfly mafches a case 
label consfanf. 

When fhe governing fype of a switch sfafemenf is string, fhe value null is permiffed as a 
case label consfanf. 

The statement-lists of a switch-block may confain declarafion sfafemenfs (§8.5). The scope of 
a local variable or consfanf declared in a swifch block is fhe swifch block. 


“■ BILL WAGNER This idea suggesfs fhaf implicif braces surround each swifch 
block. 


418 


www.it-ebooks.info 








8.7 Selection Statements 


Within a switch block, the meaning of a name used in an expression context must always 

be the same (§7.6.2.1). 

The statement list of a given swifch section is reachable if fhe switch stafemenf is reachable 

and af leasf one of the following is frue: 

• The switch expression is a nonconstant value. 

• The switch expression is a constant value that matches a case label in the switch 
section. 

• The switch expression is a constant value that doesn't match any case label, and the 
switch section contains the default label. 

• A switch label of fhe swifch section is referenced by a reachable goto case or goto 
default sfatement. 


“■ VLADIMIR RESHETNIKOV This rule is nof applied when the goto case or goto 
default statement is inside a try or catch block of a try stafemenf fhaf includes a 
finally block, and fhe switch label is outside the try statement, and the end point of 
the finally block is unreachable. 


The end point of a switch sfafement is reachable if af least one of the following is frue: 

• The switch sfafement contains a reachable break statement that exits the switch 
statement. 


"■ VLADIMIR RESHETNIKOV This rule is not applied when the break statement is 
inside a try or catch block of a try sfatemenf fhaf includes a finally block, and fhe 
fargef of fhe break stafemenf is outside the try statement, and the end point of fhe 
finally block is unreachable. 


• The switch sfafemenf is reachable, the switch expression is a nonconstant value, and no 
default label is present. 

• The switch statement is reachable, the switch expression is a constant value that doesn't 
match any case label, and no default label is present. 


00 


419 


www.it-ebooks.info 


Statements 








Statements 


8. Statements 


8.8 Iteration Statements 

Iteration statements repeatedly execute an embedded statement. 

iteration-statement: 

while-statement 

do-statement 

for-statement 

foreach-statement 

8.8.1 The while Statement 

The while statement conditionally executes an embedded statement zero or more times. 
while-statement: 

while ( boolean-expression ) embedded-statement 
A while statement is executed as follows: 

• The boolean-expression (§7.20) is evaluated. 

• If fhe boolean expression yields true, control is transferred fo fhe embedded sfafemenf. 
When and if control reaches the end point of fhe embedded sfatement (possibly from 
execution of a continue stafemenf), control is transferred to the beginning of fhe while 
sfafement. 

• If the boolean expression yields false, control is transferred to the end point of the while 
statement. 

Within the embedded statement of a while sfatement, a break statement (§8.9.1) may be 
used to transfer control to the end point of the while statement (thus ending iteration of 
fhe embedded sfatement), and a continue statement (§8.9.2) maybe used to transfer con- 
frol to the end point of fhe embedded sfatemenf (fhus performing another iteration of fhe 
while stafemenf). 

The embedded sfafemenf of a while sfafement is reachable if the while statement is reach¬ 
able and the boolean expression does not have the constant value false. 

The end point of a while statement is reachable if at least one of the following is true: 

• The while statement contains a reachable break statement that exits the while 
statement. 


420 


www.it-ebooks.info 




8.8 Iteration Statements 


“■ VLADIMIR RESHETNIKOV This rule is not applied when the break statement is 
inside a try or catch block of a try statement that includes a finally block, and the 
target of fhe break sfafemenf is oufside fhe try sfafemenf, and fhe end poinf of fhe 
finally block is unreachable. 


• The while sfafemenf is reachable and fhe boolean expression does nof have fhe consfanf 
value true. 


8.8.2 The do Statement 

The do sfafemenf conditionally execufes an embedded sfafemenf one or more fimes. 
do-statement: 

do embedded-statement while ( boolean-expression ) ; 

A do sfafemenf is execufed as follows: 

• Confrol is fransferred fo fhe embedded sfafemenf. 

• When and if confrol reaches fhe end poinf of fhe embedded sfafemenf (possibly from 
execution of a continue sfafemenf), fhe boolean-expression (§7.20) is evaluafed. If fhe bool¬ 
ean expression yields true, confrol is fransferred fo fhe begirming of fhe do sfafemenf. 
Ofherwise, confrol is fransferred fo fhe end poinf of fhe do sfafemenf. 

Wifhin fhe embedded sfafemenf of a do sfafemenf, a break sfafemenf (§8.9.1) may be used 
fo fransfer confrol fo fhe end poinf of fhe do sfafemenf (fhus ending iferafion of fhe embed¬ 
ded sfafemenf), and a continue sfafemenf (§8.9.2) may be used fo fransfer confrol fo fhe 
end poinf of fhe embedded sfafemenf. 

The embedded sfafemenf of a do sfafemenf is reachable if fhe do sfafemenf is reachable. 
The end poinf of a do sfafemenf is reachable if af leasf one of fhe following is frue: 

• The do sfafemenf confains a reachable break sfafemenf fhaf exifs fhe do sfafemenf. 


“■ VLADIMIR RESHETNIKOV This rule is nof applied when fhe break sfafemenf is 
inside a try or catch block of a try sfafemenf fhaf includes a finally block, and fhe 
fargef of fhe break sfafemenf is oufside fhe try sfafemenf, and fhe end poinf of fhe 
finally block is unreachable. 


• The end poinf of fhe embedded sfafemenf is reachable and fhe boolean expression does 
nof have fhe consfanf value true. 


00 


421 


www.it-ebooks.info 


Statements 








Statements 


8. Statements 


8.8.3 The for Statement 

The for statement evaluates a sequence of initialization expressions and then, while a con¬ 
dition is true, repeatedly executes an embedded statement and evaluates a sequence of 
iteration expressions. 

for-statement: 

for ( for-initializer j for-condition^^^ ; for-iterator^^ ) embedded-statement 

for-initializer: 

local-variable-declaration 

statement-expression-list 

for-condition: 

boolean-expression 

for-iterator: 

statement-expression-list 

statement-expression-list: 

statement-expression 

statement-expression-list , statement-expression 

The for-initializer, if present, consists of either a local-variable-declaration (§8.5.1) or a list of 
statement-expressions (§8.6) separated by commas. The scope of a local variable declared by 
a for-initializer starts at the local-variable-declarator for the variable and extends to the end of 
the embedded statement. The scope includes the for-condition and the for-iterator. 

The for-condition, if present, must be a boolean-expression (§7.20). 

The for-iterator, if present, consists of a list of statement-expressions (§8.6) separated by 
commas. 


A for statement is executed as follows: 


00 


• If a for-initializer is present, the variable initializers or statement expressions are executed 
in the order they are written. This step is performed only once. 

• If a for-condition is present, it is evaluated. 

• If the for-condition is not present or if the evaluation yields true, control is transferred fo 
fhe embedded stafemenf. When and if control reaches the end point of the embedded 
statement (possibly from execution of a continue statemenf), fhe expressions of the for- 
iterator, if any, are evaluated in sequence, and then another iteration is performed, sfart- 
ing with evaluation of the for-condition in the step above. 

• If the for-condition is present and the evaluation yields false, control is transferred fo the 
end point of the for statement. 


422 


www.it-ebooks.info 




8.8 Iteration Statements 


Within the embedded statement of a for statement, a break statement (§8.9.1) maybe used 
to transfer control to the end point of fhe for sfafemenf (fhus ending iferation of fhe embed¬ 
ded sfafemenf), and a continue sfafemenf (§8.9.2) may be used fo fransfer confrol fo fhe 
end poinf of fhe embedded sfafemenf (thus executing the for-iterator and performing 
anofher iferafion of fhe for sfafemenf, sfarfing wifh ihefor-condition). 

The embedded sfafemenf of a for sfafemenf is reachable if one of fhe following is frue: 

• The for sfafemenf is reachable and no for-condition is presenf. 

• The for sfafemenf is reachable and a for-condition is presenf and does nof have fhe con- 
sfanf value false. 

The end poinf of a for sfafemenf is reachable if af leasf one of fhe following is frue: 

• The for sfafemenf confains a reachable break sfafemenf fhaf exifs fhe for sfafemenf. 


“■ VLADIMIR RESHETNIKOV This rule is nof applied when fhe break sfafemenf is 
inside a try or catch block of a try sfafemenf fhaf includes a finally block, and fhe 
fargef of fhe break sfafemenf is oufside fhe try sfafemenf, and fhe end poinf of fhe 
finally block is unreachable. 


• The for sfafemenf is reachable and a for-condition is presenf and does nof have fhe con- 
sfanf value true. 


8.8.4 The foreach Statement 

The foreach sfafemenf enumerafes fhe elemenfs of a collecfion, execufing an embedded 
sfafemenf for each elemenf of fhe collection. 

for each-statement: 

foreach ( local-variable-type identifier in expression ) embedded-statement 

The type and identifier of a foreach sfafemenf declare fhe iteration variable of fhe sfafe¬ 
menf. If fhe var idenfifier is given as fhe local-variable-type, and no type named var is in 
scope, the iteration variable is said to be an implicitly typed iteration variable, and its type 
is taken to be the element t 5 ^e of fhe foreach sfafemenf, as specified below. The iferafion 
variable corresponds fo a read-only local variable wifh a scope fhaf exfends over fhe 
embedded sfafemenf. During execufion of a foreach sfafemenf, fhe iferafion variable rep- 
resenfs fhe collecfion element for which an iferafion is currenfly being performed. A 
compile-fime error occurs if fhe embedded sfafemenf affempfs fo modify fhe iferafion vari¬ 
able (via assignmenf or fhe ++ and - - operafors) or pass fhe iferafion variable as a ref or 
out paramefer. 


00 


423 


www.it-ebooks.info 


Statements 






Statements 


8. Statements 


“■ CHRIS SELLS For readability, foreach statements should be preferred over for 
statements. 


■■ JONSKEET The fact that there is one iteration variable (which is read-only and 
yet magically changes its value on each iteration) causes one of fhe mosf common 
problems wifh capfured variables. The code below looks like if would prinf "a", "b", 
"c", "d" buf if acfually prinfs "d" four times. 

List<Action> actions = new List<Action>(); 

foreach (string value in new[] { "a", "b", "c", "d" }) 

{ 

actions.Add(() => Console.WriteLine(value)); 

} 

foreach (Action action in actions) 

{ 

action(); 

} 

The solution is usually fo infroduce an exfra variable inside fhe body of fhe foreach 
sfafemenf fhaf fakes a copy of fhe iferafion variable's currenf value. Thai way each 
delegafe will capfure a differenf variable. In fhis case, fhe firsf loop would become 

foreach (string value in new[] { "a", "b", "c", "d" }) 

{ 

String copy = value; 

actions.Add(() => Console.WriteLine(copy)); 

} 


“■ PETER SESTOFT The foreach sfafemenf mighf have been defined differenfly fo 
avoid fhe variable capfure problem discussed in Jon Skeef's commenf: Simply move 
fhe declaration V v inside fhe while loop in fhe try-while-finally expansion shown 
lafer in fhis secfion. Indeed, in fhe original C# language specification, fhe declarafion 
appeared inside fhe while loop, buf during sfandardizafion of C# 2.0 if fumed ouf fhaf 
declaring v oufside fhe loop was closer fo fhe frufh, af leasf in Microsoff's implemenfa- 
fion, and fhe sfandard was changed accordingly. 


The compile-time processing of a foreach sfafemenf firsf defermines fhe collection type, 
enumerator type, and element type of fhe expression. This deferminafion proceeds as 
follows: 


424 


www.it-ebooks.info 










8.8 Iteration Statements 


• If the type X of expression is an array type, then there is an implicit reference conversion 
from X to the System.Collections.lEnumerable interface (since System.Array imple¬ 
ments this interface). The collection type is the System.Collections. lEnumerable inter¬ 
face, the enumerator type is the System.Collections. lEnumerator interface, and the 
element type is the element type of the array type X. 

• If the type X of expression is dynamic, then there is an implicit conversion from expression 
to the System.Collections.lEnumerable interface (§6.1.8). The collection type is the 
System.Collections.lEnumerable interface and the enumerator type is the System. 
Collections. lEnumerator interface. If the var identifier is given as the local-variable-type, 
then the element type is dynamic; otherwise, it is object. 

• Otherwise, determine whether the type X has an appropriate GetEnumerator method: 

- Perform member lookup on the t 5 ^e X with identifier GetEnumerator and no t 5 ^e 
arguments. If the member lookup does not produce a match, or if it produces an 
ambiguity or a match that is not a method group, check for an enumerable interface 
as described below. It is recommended that a warning be issued if member lookup 
produces anything except a method group or no match. 


“■ ERIC LIPPERT This "pattern"-based approach was specified so that back in the 
days before the generic IEnumerable<T> was available, collection authors could pro¬ 
vide stronger t 5 ^e annotations on their enumerator objects. 

Implementations of nongeneric lEnumerable always end up boxing every member of 
a collection of integers because the return type of the Current property is object. A 
provider of a collection of integers could provide non-interface-based GetEnumerator, 
MoveNext, and Current implementations such that Current returns an unboxed 
integer. 

Of course, in a world with generic IEnumerable<T >, all of this effort becomes urmeces- 
sary. The vast majority of iterated collections will implement this interface. 


- Perform overload resolution using the resulting method group and an empty argu¬ 
ment list. If overload resolution results in no applicable methods, results in an ambi¬ 
guity, or results in a single best method but that method is either static or not public, 
check for an enumerable interface as described below. It is recommended that a warn¬ 
ing be issued if overload resolution produces anything except an unambiguous 
public instance method or no applicable methods. 

- If the return type E of the GetEnumerator method is not a class, struct, or interface 
type, an error is produced and no further steps are taken. 


00 


425 


www.it-ebooks.info 


Statements 






Statements 


8. Statements 


- Member lookup is performed on E with the identifier Current and no type argu¬ 
ments. if the member lookup produces no match, the result is an error, or the result is 
anything except a public instance property that permits reading, an error is pro¬ 
duced and no further steps are taken. 

- Member lookup is performed on E with the identifier MoveNext and no type argu¬ 
ments. If the member lookup produces no match, the result is an error, or the result is 
anything except a method group, an error is produced and no further steps are 
taken. 

- Overload resolution is performed on the method group with an empty argument list. 
If overload resolution results in no applicable methods, results in an ambiguity, or 
results in a single best method but that method is either static or not public, or its 
return type is not bool, an error is produced and no further steps are taken. 

- The collection type is X, the enumerator type is E, and the element type is the t 5 ^e of 
the Current property. 

• Otherwise, check for an enumerable interface: 

- If there is exactly one type T such that there is an implicit conversion from X to the 
interface System. Collections .Generic. lEnumerablecT>, then the collection type is 
this interface, the enumerator type is the interface System.Collections.Generic. 
lEnumeratorcT>, and the element type is T. 

- Otherwise, if there is more than one such type T, then an error is produced and no 
further steps are taken. 

- Otherwise, if there is an implicit conversion from X to the System.Collections. 
lEnumerable interface, then the collection type is this interface, the enumerator type 
is the interface System.Collections. lEnumerator, and the element type is object. 

- Otherwise, an error is produced and no further steps are taken. 


“■ PETER SESTOFT Sadly, the compile-time processing of the foreach statement 
means that it is rather d 5 mamically typed. For instance, for an arbitrary non-sealed 
class C and interface I, the following is t 5 ^e correct and causes no compiler warnings 
or errors: 

C[] xs = ...; 
foreach (I x in xs) 


426 


www.it-ebooks.info 







8.8 Iteration Statements 


In fact, just recently I fell into this trap when removing a seemingly irrelevant interface 
I from the interface list of a class C. The project went through the build stage without 
errors, but at runtime the application crashed with an InvalidCastException because 
I had overlooked several foreach statements. Actually, this behavior should be 
expected, because there might be some subclass of C that implements interface I. What 
is perhaps more surprising is that I and C can be swapped in the preceding code with 
the same result. 


The above steps, if successful, unambiguously produce a collection t 5 ^e C, enumerator 
type E, and element t 5 ^e T. A foreach statement of the form 

foreach (V v in x) embedded-statement 


is then expanded to: 

{ 

E e = ((C)(x)).GetEnumerator(); 
try { 

V v; 

while (e.MoveNextO) { 

V = (V)(T)e.Current; 

embedded-statement 

} 

} 

finally { 

... // Dispose of e 

} 

} 

The variable e is not visible to or accessible to the expression x, the embedded state¬ 
ment, or any other source code of the program. The variable v is read-only in the embed¬ 
ded statement. If there is not an explicit conversion (§6.2) from T (the element t 5 ^e) to V 
(the local-variable-type in the foreach statement), an error is produced and no further 
steps are taken. If x has the value null, a System. NullReferenceException is thrown at 
runtime. 


“■ MAREK SAFAR The foreach statement is a classic example of language evolu¬ 
tion. C# 1.0 did not have the generic IEnumerable<T > and explicit conversion had to be 
used from element type to local variable. C# 2.0 introduced a generic version of the 
foreach statement with an element of a generic type. C# 3.0 brought this structure 
back to where it should have been at the begirming by introducing implicitly typed 
iteration variable, which changes explicit conversion to be implicit and avoids any 
InvalidCastException during execution. 


00 


427 


www.it-ebooks.info 


Statements 









Statements 


8. Statements 


An implementation is permitted to implement a given fo reach statement differently—for 
example, for performance reasons—as long as fhe behavior is consisfenf wifh fhe above 
expansion. 

The body of fhe finally block is consfrucfed according fo fhe following sfeps: 

• If fhere is an implicif conversion from E fo fhe System. IDisposable inferface, fhen 

- If E is a non-nullable value t 5 ^e, fhen fhe finally clause is expanded fo fhe semantic 
equivalent of 

finally { 

((System.IDisposable)e).Dispose(); 

} 

- Ofherwise, fhe finally clause is expanded fo fhe semanfic equivalenf of 
finally { 

if (e != null) ((System.IDisposable)e).Dispose(); 

} 

excepf fhaf if E is a value fype, or a 1)^)0 paramefer insfanfiafed fo a value fype, fhen 
fhe casf of e fo System. IDisposable will nof cause boxing fo occur. 

• Ofherwise, if E is a sealed t 5 q)e, fhen fhe finally clause is expanded fo an empfy block: 

finally { 

} 

• Ofherwise, fhe finally clause is expanded fo 
finally { 

System.IDisposable d = e as System.IDisposable; 
if (d != null) d.DisposeO; 

} 

The local variable d is nof visible fo or accessible fo any user code. In parficular, if does 
nof conflicf wifh any ofher variable whose scope includes fhe finally block. 


■■ JONSKEET The facf fhaf fhe foreach sfafemenf disposes of ifs iferafor makes fhe 
iferafor blocks in C# 2.0 vasfly more useful fhan fhey ofherwise would be: If is entirely 
reasonable fo acquire a resource fo iferafe over, and fhen dispose of fhaf resource when 
eifher fhe iferafor has been exhausfed or fhe caller breaks ouf of fhe loop for some 
reason. 


428 


www.it-ebooks.info 






8.9 Jump Statements 


The order in which foreach traverses the elements of an array is as follows: For single¬ 
dimensional arrays, elemenfs are fraversed in increasing index order, sfarfing wifh index 0 
and ending wifh index Length - 1. For mulfi-dimensional arrays, elemenfs are fraversed 
such fhaf fhe indices of fhe righfmosf dimension are increased firsf, then the next left 
dimension, and so on to the left. 

The following example prints out each value in a two-dimensional array, in element 
order: 

using System; 

class Test 
{ 

static void Main() 

{ 

double[,] values = { 

{1.2, 2.3, 3.4, 4.5}, 

{5.6, 6.7, 7.8, 8.9} 

}; 

foreach (double elementValue in values) 

Console.Write( "{0} ", elementValue); 

Console.WriteLlne(); 

} 

} 

The output produced is as follows: 

1.2 2.3 3.4 4.5 5.6 6.7 7.8 8.9 

In the example 

int[] numbers = { 1, 3, 5, 7, 9 }; 

foreach (var n in numbers) Console.WriteLine(n); 

the t57pe of n is inferred to be int, the element t57pe of numbers. 


8.9 Jump Statements 

Jump statements unconditionally transfer control. 


00 


jump-statement: 

break-statement 

continue-statement 

goto-statement 

return-statement 

throw-statement 


429 


www.it-ebooks.info 


Statements 




Statements 


8. Statements 


00 


The location to which a jump statement transfers control is called the target of fhe jump 
sfafemenf. 

When a jump sfafemenf occurs wifhin a block, and fhe fargef of fhaf jump sfafemenf is 
oufside fhaf block, fhe jump sfafemenf is said fo exit fhe block. While a jump sfafemenf 
may fransfer confrol ouf of a block, if can never fransfer confrol info a block. 

Execution of jump sfafemenfs is complicafed by fhe presence of infervening try sfafemenfs. 
In fhe absence of such try sfafemenfs, a jump sfafemenf uncondifionally fransfers confrol 
from fhe jump sfafemenf fo ifs fargef. In fhe presence of such infervening try sfafemenfs, 
execufion is more complex. If fhe jump sfafemenf exifs one or more try blocks wifh associ- 
afed finally blocks, control is initially transferred fo fhe finally block of fhe irmermosf 
try sfafemenf. When and if control reaches the end point of a finally block, confrol is 
fransferred fo fhe finally block of fhe nexf enclosing try sfafemenf. This process is 
repealed until the finally blocks of all infervening try sfafemenfs have been execufed. 

In fhe example 

using System; 

class Test 
{ 

static void Main() 

{ 

while (true) 

{ 

try 

{ 

try 

{ 

Console.WriteLine("Before break"); 
break; 

} 

finally 

{ 

Console.WriteLlneC'Innermost finally block"); 

} 

} 

finally 

{ 

Console.WriteLineC'Outermost finally block"); 

} 

} 

Console.WriteLine("After break"); 

} 

} 

fhe finally blocks associafed wifh fwo try sfafemenfs are execufed before confrol is frans¬ 
ferred fo fhe fargef of fhe jump sfafemenf. 

The oufpuf produced is as follows: 


430 


www.it-ebooks.info 




8.9 Jump Statements 


Before break 
Innermost finally block 
Outermost finally block 
After break 


8.9.1 The break Statement 

The break statement exits the nearest enclosing switch, while, do, for, or foreach 
statement. 

break-statement: 
break ; 

The target of a break statement is the end point of the nearest enclosing switch, while, do, 
for, or foreach statement. If a break statement is not enclosed by a switch, while, do, for, 
or foreach statement, a compile-time error occurs. 

When multiple switch, while, do, for, or foreach statements are nested within each other, 
a break statement applies only to the innermost statement. To transfer control across mul¬ 
tiple nesting levels, a goto statement (§8.9.3) must be used. 

A break statement carmot exit a finally block (§8.10). When a break statement occurs 
within a finally block, the target of the break statement must be within the same finally 
block; otherwise, a compile-time error occurs. 

A break statement is executed as follows: 

• If the break statement exits one or more try blocks with associated finally blocks, con¬ 
trol is initially transferred to the finally block of the irmermost try statement. When 
and if control reaches the end point of a finally block, control is transferred to the 
finally block of the next enclosing try statement. This process is repeated until the 
finally blocks of all intervening try statements have been executed. 

• Control is transferred fo the target of the break statement. 

Because a break statement unconditionally transfers control elsewhere, the end point of a 
break sfafement is never reachable. 


"■ JESSE LIBERTY Whenever you see unconditional transfer or (especially) exif 
from within the flow of a method, treat it as a volatile explosive (that is, run screaming 
from the room). 

While a case can be made for break, continue, and goto statements, it is rare that you 
can't rewrite or refactor them out of exisfence. The resulting code is very likely to be 
easier to read, understand, and maintain. 


00 


431 


www.it-ebooks.info 


Statements 






Statements 


8. Statements 


8.9.2 The continue Statement 

The continue statement starts a new iteration of the nearest enclosing while, do, for, or 
foreach statement. 

continue-statement: 

continue j 

The target of a continue sfatement is fhe end poinf of the embedded statement of the near¬ 
est enclosing while, do, for, or foreach statement. If a continue sfatement is not enclosed 
by a while, do, for, or foreach statement, a compile-time error occurs. 

When multiple while, do, for, or foreach statements are nested within each other, a con¬ 
tinue statement applies only to the irmermost statement. To transfer confrol across multi¬ 
ple nesting levels, a goto statement (§8.9.3) must be used. 

A continue statement cannot exit a finally block (§8.10). When a continue statement 
occurs within a finally block, the target of fhe continue sfafemenf must be within the 
same finally block; otherwise, a compile-time error occurs. 

A continue statement is executed as follows: 

• If the continue statement exits one or more try blocks with associated finally blocks, 
control is initially transferred fo the finally block of the irmermost try statement. When 
and if confrol reaches fhe end poinf of a finally block, control is transferred to the 
finally block of the next enclosing try statement. This process is repeated until the 
finally blocks of all intervening try statements have been executed. 

• Control is transferred to the target of the continue statement. 

Because a continue statement unconditionally transfers control elsewhere, the end point 
of a continue statement is never reachable. 


"■ PETER SESTOFT Some languages—notably the Java programming language— 
have generalized versions of fhe break and continue statemenfs, where a fargef label 
specifies which of mulfiple enclosing loops should be exiled or resumed. The same 
effecf can be obtained in C# using the goto statement. Moreover, although the general¬ 
ized break and continue statements are disciplined versions of goto, fhey are almost 
as difficult to understand as goto statements and, in my opinion, detrimental to read¬ 
ability even in short programs. See examples 78 and 79 in my book Java Precisely, sec¬ 
ond edition. 


432 


www.it-ebooks.info 






8.9 Jump Statements 


8.9.3 The goto Statement 

The goto statement transfers control to a statement that is marked by a label. 

goto-statement: 

goto identifier ; 

goto case constant-expression ; 

goto default ; 

The target of a goto identifier statement is the labeled statement with the given label. If a 
label wifh fhe given name does not exist in the current function member, or if the goto 
statement is not within the scope of fhe label, a compile-time error occurs. This rule per¬ 
mits the use of a goto statement to transfer confrol out of a nesfed scope, buf not into a 
nested scope. In the example 

using System; 

class Test 
{ 

static void Main(string[] args) { 
string[,] table = { 

{"Red", "Blue", "Green"}, 

{"Monday", "Wednesday", "Friday"} 

}; 

foreach (string str in args) { 
int row, colm; 

for (row = 0; row <= 1; ++row) 

for (colm = 0; colm <= 2; ++colm) 
if (str == table[row,colm]) 
goto done; 

Console.WriteLine("{0} not found", str); 
continue; 

done: 

Console.WrlteLineC'Found {0} at [{1}][{2}]", str, row, colm); 

} 

} 

} 

a goto statement is used to transfer confrol ouf of a nesfed scope. 

The target of a goto case statement is the statement list in the immediately enclosing 
switch statement (§8.7.2), which contains a case label with the given constant value. If fhe 
goto case stafemenf is not enclosed by a switch statement, if the constant-expression is not 
implicitly convertible (§6.1) to the governing type of fhe nearest enclosing switch state¬ 
ment, or if fhe nearest enclosing switch statement does not contain a case label with the 
given constant value, a compile-time error occurs. 

The target of a goto default sfatemenf is fhe statement list in the immediately enclosing 
switch statement (§8.7.2), which contains a default label. If fhe goto default sfafement is 


00 


433 


www.it-ebooks.info 


Statements 




Statements 


8. Statements 


not enclosed by a switch statement, or if the nearest enclosing switch statement does not 
contain a default label, a compile-time error occurs. 

A goto statement cannot exit a finally block (§8.10). When a goto statement occurs within 
a finally block, the target of fhe goto sfafemenf musf be wifhin fhe same finally block; 
ofherwise, a compile-fime error occurs. 


"■ BILL WAGNER These rules make goto a little less fhan pure evil in C#, buf I've 
yef fo see a good use for if. 


A goto sfafemenf is execufed as follows: 

• If fhe goto sfafemenf exifs one or more try blocks wifh associafed finally blocks, con- 
frol is initially fransferred fo fhe finally block of fhe irmermosf try sfafemenf. When 
and if confrol reaches fhe end poinf of a finally block, confrol is fransferred fo fhe 
finally block of fhe nexf enclosing try sfafemenf. This process is repeafed unfil 
fhe finally blocks of all infervening try sfafemenfs have been execufed. 

• Confrol is fransferred fo fhe fargef of fhe goto sfafemenf. 

Because a goto sfafemenf uncondifionally fransfers confrol elsewhere, fhe end poinf of a 

goto sfafemenf is never reachable. 


00 


"■ CHRIS SELLS Please don'f use labels or goto sfafemenfs. I've never read any 
code fhaf wasn'f more readable wifhouf fhem. 


"■ CHRISTIAN NAGEL Alfhough goto sfafemenfs make sense wifhin switch sfafe¬ 
menfs as explicif fall-fhrough options, you shouldn'f use fhem in ofher scenarios. 


“■ PETER SESTOFT Don Knufh's 1974 paper "Sfrucfured Programming wifh go fo 
Sfafemenfs" fhrows a lof of lighf on alfernafives fo fhe goto sfafemenf and idenfifies 
sensible uses of fhe goto sfafemenf. In fhe end, Knufh does conclude fhaf "we should, 
indeed, abolish go fo . . ., af leasf as an experimenf in fraining people fo formulafe 
fheir absfracfions more carefully." Jusf fhe acknowledgmenfs lisf of fhaf paper pres- 
enfs a "who's who" of programming language pioneers. 

The besf reason for including goto in C# probably is fhaf you may wanf fo generate 
code fhaf uses goto—for insfance, parsers, lexers, aufomafa, sfafecharfs, virfual 
machines, and similar programs. 


434 


www.it-ebooks.info 












8.9 Jump Statements 


8.9.4 The return Statement 

The return statement returns control to the caller of the function member in which the 
return statement appears. 

return-statement: 

return expression^! ; 

A return statement with no expression can be used only in a fimction member that does 
not compute a value—that is, a method with the return t 5 ^e void, the set accessor of a 
property or indexer, the add and remove accessors of an event, an instance constructor, a 
static constructor, or a destructor. 

A return statement with an expression can only be used in a function member that com¬ 
putes a value—that is, a method with a non-void return type, the get accessor of a property 
or indexer, or a user-defined operator. An implicit conversion (§6.1) must exist from the 
type of the expression to the return type of the containing function member. 


“■ VLADIMIR RESHETNIKOV If the return statement is within an anonymous func¬ 
tion, the rules from §6.5 are applied instead. 


It is a compile-time error for a return statement to appear in a finally block (§8.10). 

A return statement is executed as follows: 

• If the return statement specifies an expression, the expression is evaluated and the 
resulting value is converted to the return t 5 ^e of the containing fimction member by an 
implicit conversion. The result of the conversion becomes the value returned to the 
caller. 

• If the return statement is enclosed by one or more try blocks with associated finally 
blocks, control is initially transferred to the finally block of the irmermost try state¬ 
ment. When and if control reaches the end point of a finally block, control is transferred 
to the finally block of the next enclosing try statement. This process is repeated until 
the finally blocks of all enclosing try statements have been executed. 

• Control is returned to the caller of the containing function member. 

Because a return statement unconditionally transfers control elsewhere, the end point of a 

return statement is never reachable. 


00 


435 


www.it-ebooks.info 


Statements 






Statements 


8. Statements 


8.9.5 The throw Statement 

The throw statement throws an exception. 

throw-statement: 

throw expression^^ ; 

A throw statement with an expression throws the value produced by evaluating the expres¬ 
sion. The expression must denote a value of the class t 5 ^e System. Exception, of a class 
type that derives from System. Exception or of a t 5 ^e parameter type that has System. 
Exception (or a subclass thereof) as ifs effective base class. If evaluation of fhe expression 
produces null, a System.NullReferenceException is thrown insfead. 


"■ PETER SESTOFT For this reason, an exception thrown in C# is never null and, 
therefore, fhe try-catch mafching of an exception (on ifs class) described in §8.10 
makes sense. In fact, the .NET/CLI intermediate language instruction called throw 
behaves like the C# throw statement in this respect. Thus, even if the exception was 
thrown by code written in another .NET/ CLI language, it would be non-null when 
handled by the try-catch statement. 


A throw statement with no expression can be used only in a catch block, in which case that 
statement rethrows the exception that is currently being handled by that catch block. 


00 


■■ VLADIMIR RESHETNIKOV A throw statement with no expression is not allowed 
in a finally block or anonymous function that is nested inside the nearest enclosing 
catch block: 


delegate void F(); 
class Program 
{ 

static void Main() 

{ 

try 

{ 

} 

catch 

{ 

F f = 0 => { throw; }; // Error CS0156 
try 
{ 

} 

finally 

{ 

throw; // Error CS0724 

} 

} 

} 

} 


436 


www.it-ebooks.info 








8.9 Jump Statements 


Because a throw statement unconditionally transfers control elsewhere, the end point of 
a throw statement is never reachable. 

When an exception is thrown, control is transferred to the first catch clause in an enclos¬ 
ing try statement that can handle the exception. The process that takes place from the 
point of the exception being thrown to the point of transferring control to a suitable 
exception handler is known as exception propagation. Propagation of an exception con¬ 
sists of repeatedly evaluating the following steps until a catch clause that matches the 
exception is found. In this description, the throw point is initially the location at which 
the exception is thrown. 

• In the current function member, each try statement that encloses the throw point is 
examined. For each statement S, starting with the innermost try statement and ending 
with the outermost try statement, the following steps are evaluated: 

- If the try block of S encloses the throw point and if S has one or more catch clauses, 
the catch clauses are examined in order of appearance to locate a suitable handler 
for the exception. The first catch clause that specifies the exception type or a base 
type of the exception type is considered a match. A general catch clause (§8.10) is 
considered a match for any exception type. If a matching catch clause is located, 
the exception propagation is completed by transferring control to the block of that 
catch clause. 

- Otherwise, if the try block or a catch block of S encloses the throw point and if S 
has a finally block, control is transferred to the finally block. If the finally block 
throws another exception, processing of the current exception is terminated. Other¬ 
wise, when control reaches the end point of the finally block, processing of the 
current exception is continued. 

• If an exception handler was not located in the current function member invocation, the 
function member invocation is terminated. The steps above are then repeated for the 
caller of the function member with a throw point corresponding to the statement from 
which the function member was invoked. 

• If the exception processing terminates all function member invocations in the current 
thread, indicating that the thread has no handler for the exception, then the thread is 
itself terminated. The impact of such termination is implementation-defined. 


“■ BILL WAG N E R This process implies that you should do some basic cleanup in the 
topmost methods for all your threads. Otherwise, the behavior of your application 
will be undefined in the face of exceptions that will cause threads to be terminated. 


00 


437 


www.it-ebooks.info 


Statements 






Statements 


8. Statements 


8.10 The try Statement 

The try statement provides a mechanism for catching exceptions that occur during execu¬ 
tion of a block. Furfhermore, fhe try sfafemenf provides fhe abilify fo specify a block of 
code fhaf is always execufed when confrol leaves fhe try sfafemenf. 

try-statement: 

try block catch-clauses 
try block finally-clause 
try block catch-clauses finally-clause 

catch-clauses: 

specific-catch-clauses general-catch-clause^^^^^ 
specific-catch-clausesgeneral-catch-clause 

specific-catch-clauses: 

specific-catch-clause 

specific-catch-clauses specific-catch-clause 
specific-catch-clause: 

catch ( class-type identifier ) block 

general-catch-clause: 
catch block 

finally-clause: 

finally block 

There are fhree possible forms of try sfafemenfs: 

• A try block followed by one or more catch blocks. 

• A try block followed by a finally block. 

• A try block followed by one or more catch blocks followed by a finally block. 

When a catch clause specifies a class-type, fhe type must be System. Exception, a type that 
derives from System. Exception, or a t5rpe paramefer type that has System. Exception (or a 
subclass thereof) as ifs effective base class. 

When a catch clause specifies bofh a class-type and an identifier, an exception variable of fhe 
given name and type is declared. The exception variable corresponds to a local variable 


438 


www.it-ebooks.info 




8.10 The try Statement 


with a scope that extends over the catch block. During execution of the catch block, the 
exception variable represents the exception currently being handled. For purposes of 
definite assignment checking, the exception variable is considered definitely assigned in its 
entire scope. 

Unless a catch clause includes an exception variable name, it is impossible to access the 
exception object in the catch block. 

A catch clause that specifies neither an exception t 5 ^e nor an exception variable name is 
called a general catch clause. A try statement can have only one general catch clause, and 
if one is present it must be the last catch clause. 

Some programming languages may support exceptions that are not representable as an 
object derived from System. Exception, although such exceptions could never be gener¬ 
ated by C# code. A general catch clause may be used to catch such exceptions. Thus a 
general catch clause is semantically different from one that specifies the type System. 
Exception, in that the former may also catch exceptions from other languages. 


“■ ERIC LIPPERT In the current Microsoft implementation of C# and the CLR, by 
default a thrown object that does not derive from Exception is converted into a 
RuntimeWrappedException object. As a consequence, catch(Exception e) catches all 
exceptions. 

If you want to disable this behavior and use the C# 1.0 semantics, whereby non- 
Exception objects thrown by other languages are not caught in this manner, then use 
the following assembly attribute: 

[assembly:System.Runtime.CompilerServices.RuntimeCompatibility(WrapNonExceptionThrows 
= false)] 


To locate a handler for an exception, catch clauses are examined in lexical order. A com¬ 
pile-time error occurs if a catch clause specifies a type that is the same as, or is derived 
from, a t 5 q)e that was specified in an earlier catch clause for the same try block. Without 
this restriction, it would be possible to write unreachable catch clauses. 

Within a catch block, a throw statement (§8.9.5) with no expression can be used to rethrow 
the exception that was caught by the catch block. Assignments to an exception variable do 
not alter the exception that is rethrown. 


00 


439 


www.it-ebooks.info 


Statements 






Statements 


8. Statements 


In the example 

using System; 

class Test 
{ 

static void F() { 
try { 

GO; 

} 

catch (Exception e) { 

Console.WriteLine("Exception in F: " + e.Message); 

e = new Exception("F"); 

throw; // Rethrow 

} 

} 

static void G() { 

throw new Exception("G"); 

} 

static void Main() { 
try { 

F(); 

} 

catch (Exception e) { 

Console.WriteLine("Exception in Main: " + e.Message); 

} 

} 

} 

the method F catches an exception, writes some diagnostic information to the console, 
alters the exception variable, and rethrows the exception. The exception that is rethrown is 
the original exception, so the output produced is 

Exception in F: G 
Exception in Main: G 

If fhe firsf catch block had fhrown e insfead of refhrowing fhe currenf exception, fhe ouf- 
puf produced would be as follows: 

Exception in F: G 
Exception in Main: F 

If is a compile-fime error for a break, continue, or goto sfafemenf fo fransfer confrol ouf of 
a finally block. When a break, continue, or goto sfafemenf occurs in a finally block, fhe 
fargef of fhe sfafemenf musf be wifhin fhe same finally block; ofherwise, a compile-fime 
error occurs. 


440 


www.it-ebooks.info 




8.10 The try Statement 


It is a compile-time error for a return statement to occur in a finally block. 

A try statement is executed as follows: 

• Confrol is fransferred fo fhe try block. 

• When and if confrol reaches fhe end poinf of fhe try block: 

- If fhe try sfafemenf has a finally block, fhe finally block is execufed. 

- Confrol is fransferred fo fhe end poinf of fhe try sfafemenf. 

• If an exception is propagafed fo fhe try sfafemenf during execution of fhe try block: 

- The catch clauses, if any, are examined in order of appearance fo locafe a suifable 
handler for fhe exception. The firsf catch clause fhaf specifies fhe excepfion type or a 
base t 5 ^e of fhe excepfion fype is considered a mafch. A general catch clause is con¬ 
sidered a mafch for any excepfion type. If a mafching catch clause is locafed: 

• If fhe mafching catch clause declares an excepfion variable, fhe excepfion objecf is 
assigned fo fhe excepfion variable. 

• Confrol is fransferred fo fhe mafching catch block. 

• When and if confrol reaches fhe end poinf of fhe catch block: 

- If fhe try sfafemenf has a finally block, fhe finally block is execufed. 

- Confrol is fransferred fo fhe end poinf of fhe try sfafemenf. 

• If an excepfion is propagafed fo fhe try sfafemenf during execufion of fhe 
catch block: 

- If fhe try sfafemenf has a finally block, fhe finally block is execufed. 

- The excepfion is propagafed fo fhe nexf enclosing try sfafemenf. 

- If fhe try sfafemenf has no catch clauses or if no catch clause mafches fhe 
excepfion: 

• If fhe try sfafemenf has a finally block, fhe finally block is execufed. 

• The excepfion is propagafed fo fhe nexf enclosing try sfafemenf. 


00 


441 


www.it-ebooks.info 


Statements 




Statements 


8. Statements 


“■ ERIC LI PPERT If the call stack includes code protected by try-catch blocks writ¬ 
ten in other languages (such as Visual Basic), the runtime environment may execute 
an "exception filter" to see whether a given catch block is appropriate for the thrown 
exception. As a consequence, user code may execute after an exception is thrown but 
before the associated finally block is executed. If your exception-handling code 
depends on the global state being made consistent by a finally block before any other 
user code runs, then you should take appropriate measures to ensure that your code 
catches the exception before the runtime environment executes user-defined exception 
filters that may be on the stack. 


The statements of a finally block are always executed when control leaves a try state¬ 
ment. This is true whether the control transfer occurs as a result of normal execution; as a 
result of executing a break, continue, goto, or return statement; or as a result of propagat¬ 
ing an exception out of the try statement. 

If an exception is thrown during execution of a finally block and is not caught within the 
same finally block, the exception is propagated to the next enclosing try statement. If 
another exception was in the process of being propagated, that exception is lost. The pro¬ 
cess of propagating an exception is discussed further in the description of the throw state¬ 
ment (§8.9.5). 


"■ BILL WAGNER This behavior makes it very important to write finally clauses 
defensively to avoid raising a second exception. 


■■ JONSKEET It would be nice if we didn't have to write finally clauses defen¬ 
sively, of course. The concept of one error being caused by another is already part of 
the .NET framework with the idea of an "inner exception." Even so, the idea that two 
exceptions are likely to be related, but neither was known to cause the other, doesn't 
have a common representation at the moment. Likewise, there's the generally thorny 
question of which exceptions a method might throw. Java tried to tackle this problem 
with "checked exceptions"—mostly unsuccessfully, in my view. 

It sometimes feels as if we (as an industry) are getting quite good at success scenarios, 
but we still have a long way to go when it comes to error handling. 


442 


www.it-ebooks.info 










8.12 The lock Statement 


The try block of a try statement is reachable if the try statement is reachable. 

A catch block of a try statement is reachable if the try statement is reachable. 

The finally block of a try statement is reachable if the try statement is reachable. 

The end point of a try statement is reachable if both of the following are true: 

• The end point of the try block is reachable or the end point of at least one catch block 
is reachable. 

• If a finally block is present, the end point of the finally block is reachable. 


8.11 The checked and unchecked Statements 

The checked and unchecked statements are used to control the overflow checking context 
for integral-type arithmetic operations and conversions. 

checked-s tatement: 
checked block 

unchecked-statement: 
unchecked block 

The checked statement causes all expressions in the block to be evaluated in a checked con¬ 
text. The unchecked statement causes all expressions in the block to be evaluated in an 
unchecked context. 

The checked and unchecked statements are precisely equivalent to the checked and 
unchecked operators (§7.6.12), except that they operate on blocks instead of expressions. 


8.12 The lock Statement 

The lock statement obtains the mutual-exclusion lock for a given object, executes a state¬ 
ment, and then releases the lock. 

lock-statement: 

lock ( expression ) embedded-statement 

The expression of a lock statement must denote a value of a t 5 q)e known to be a reference- 
type. No implicit boxing conversion (§6.1.7) is ever performed for the expression of a lock 


00 


443 


www.it-ebooks.info 


Statements 




Statements 


8. Statements 


statement, and thus it is a compile-time error for the expression to denote a value of a 
value-type. 

A lock sfafemenf of fhe form 
lock (x) ... 

where x is an expression of a reference-type, is precisely equivalenf fo 

bool _lockWasTaken = false; 

try { 

System.Threading.Monitor.Enter(x, _lockWasTaken); 

} 

finally { 

if (_lockWasTaken)System.Threading.Monitor.Exit(x); 

} 

excepf fhaf x is evaluafed only once. 


■■ BILL WAGNER The lock() sfafemenf provides addifional compiler checks 
againsf frying fo lock a value t 5 qie. 


While a mufual-exclusion lock is held, code execufing in fhe same execufion fhread can 
also obfain and release fhe lock. However, code execufing in ofher fhreads is blocked from 
obfaining fhe lock unfil fhe lock is released. 

Locking System .Type objecfs so as fo S5mchronize access fo sfafic dafa is nof recommended. 
Ofher code mighf lock on fhe same type, which can result in deadlock. A better approach 
is to S5mchronize access to static data by locking a private static object. For example: 

class Cache 
{ 

private static readonly object synchronizationObject = new object(); 

public static void Add(object x) { 

lock (Cache.synchronizationObject) { 

} 

} 

public static void Remove(object x) { 
lock (Cache.synchronizationObject) { 

} 

} 


444 


www.it-ebooks.info 






8.13 The using Statement 


■■ JOSEPH ALBAHARI A good policy, when writing libraries for public consump¬ 
tion, is to make static functions thread-safe from the outset (t 5 ^ically, by implement¬ 
ing locking within your functions, as in this example). It's much more difficult (or even 
impossible) for consumers to lock around calling your static methods or properties, 
because they won't know from which other locations your functions are called. 


8.13 The using Statement 

The using statement obtains one or more resources, executes a statement, and then dis¬ 
poses of the resource. 


"■ ERIC LIPPERT As the specification explicitly calls out here, the point of a using 
statement is to ensure the acquisition of and timely disposal of a resource. Typically, 
this will consist of some unmanaged resource from the operating system, such as a file 
handle. It is polite to stop using resources as soon as possible; some other program 
might want to read that file when you're done with it. I recommend against the use of 
using statements to enforce program invariants. For example, one sometimes sees 
code like this: 

using(new TemporarilyStopReportingErrors()) AttemptSomething(); 

Here TemporarilyStopReportingErrors is a type whose constructor turns off error 
reporting as a side effect and whose disposal method turns it back on. I consider this 
(unfortunately widespread) practice to be an abuse of the using statement; a program 
side effect is not a resource, and causing global side effects in constructors and dispos¬ 
ers seems like a bad idea. I would write this code using a try-finally construct 
instead. 


using-statement: 

using ( resource-acquisition ) embedded-statement 

resource-acquisition: 

local-variable-declaration 

expression 

A resource is a class or struct that implements System. IDisposable, which includes a single 
parameterless method named Dispose. Code that is using a resource can call Dispose to 
indicate that the resource is no longer needed. If Dispose is not called, then automatic dis¬ 
posal eventually occurs as a consequence of garbage collection. 


00 


445 


www.it-ebooks.info 


Statements 








Statements 


8. Statements 


■■ JOSEPH ALBAHARI Calling Dispose doesn't influence garbage collection in any 
way: An object becomes eligible for automatic garbage collection when (and only 
when) no other object refers fo if. Likewise, garbage collection doesn'f influence dis¬ 
posal: The garbage collector will nof call Dispose unless you wrife a finalizer (desfruc- 
for) fhaf explicifly makes fhis call. 

The fwo acfivifies mosf commonly performed wifhin a Dispose mefhod are releasing 
unmanaged resources and calling Dispose on ofher referenced or "owned" objecfs. If 
is also possible fo release unmanaged resources from wifhin a finalizer, alfhough such 
an operafion means waifing an indeferminafe amounf of time for fhe garbage collector 
fo fire. This is why IDisposable exists. 


00 


If fhe form of resource-acquisition is local-variable-declaration, fhen fhe type of fhe local-vari- 
able-declaration musf be eifher dynamic or a fype fhaf can be implicifly converfed fo System. 
IDisposable. If fhe form of resource-acquisition is expression, fhen fhis expression musf be 
implicifly convertible fo System. IDisposable. 

Local variables declared in a resource-acquisition are read-only, and musf include an initial¬ 
izer. A compile-fime error occurs if fhe embedded sfafemenf affempfs fo modify fhese local 
variables (via assignmenf or fhe ++ and - - operafors), fake fhe address of fhem, or pass 
fhem as ref or out paramefers. 

A using sfafemenf is franslafed info fhree parfs: acquisifion, usage, and disposal. Usage of 
fhe resource is implicifly enclosed in a try sfafemenf fhaf includes a finally clause. This 
finally clause disposes of fhe resource. If a null resource is acquired, fhen no caU fo Dispose 
is made, and no exception is fhrown. If fhe resource is of f 5 q)e dynamic, if is dynamically con¬ 
verted through an implicit dynamic conversion (§6.1.8) to IDisposable during acquisition to 
ensure that the conversion is successful before fhe usage and disposal fake place. 

A using sfafemenf of fhe form 

using (ResourceType resource = expression) statement 

corresponds fo one of fhree possible expansions. When ResourceType is a non-nullable 
value t5q5e, fhe expansion is 

{ 

ResourceType resource = expression; 
try { 

statement; 

} 

finally { 

((IDisposable)resource).Dispose(); 

} 

} 


446 


www.it-ebooks.info 






8.13 The using Statement 


Otherwise, when ResourceType is a nullable value t 5 ^e or a reference type other than 
dynamic, the expansion is 

{ 

ResourceType resource = expression; 
try { 

statement; 

} 

finally { 

if (resource != null) ((IDisposable)resource).Dispose(); 

} 

} 

Otherwise, when ResourceType is dynamic, the expansion is 
{ 

ResourceType resource = expression; 

IDisposable d = (IDisposable)resource; 
try { 

statement; 

} 

finally { 

if (d != null) d.DisposeO; 

} 

} 

In either expansion, the resource variable is read-only in the embedded statement, and the 
d variable is inaccessible in, and invisible to, the embedded statement. 


“■ PETER SESTOFT Thanks to the above rule, the using statement could also be (ah) 
used to declare read-only local variables, in this style: 

using (MyClass v = ...) 

using (MyStruct s = ...) { 

} 

In fact, this is the only way to declare an immutable local variable in C#, but it is ugly 
and strange. Moreover, it works only for t 5 ^es MyClass and MyStruct that implement 
interface IDisposable, and not for int and string, for example. What is perhaps puz¬ 
zling from a language design point of view is that unlike a read-only field (§10.5.2 and 
§7.6.4) of struct type, an immutable resource variable s of struct t5q3e MyStruct is 
treated like a variable, not a value. Thus a method call s. SetX( ) acts on the struct 
stored in s, not on a copy of it. All in all, this behavior shows that the machinery for 
declaring immutable local variables and parameters in C# exists, but alas not in a 
usable form. 


00 


447 


www.it-ebooks.info 


Statements 






Statements 


8. Statements 


An implementation is permitted to implement a given using statement differently—for 
example, for performance reasons—as long as fhe behavior is consisfenf wifh fhe above 
expansion. 

A using sfafemenf of fhe form 
using (expression) statement 

has fhe same fhree possible expansions, buf in fhis case ResourceType is implicifly fhe 
compile-fime type of fhe expression, and fhe resource variable is inaccessible in, and 
invisible fo, fhe embedded sfafemenf. 


“■ JON SKEET 1 normally insisf on braces around everyfhing—and fhis preference 
usually exfends fo using sfafemenfs, foo. However, if you acquire multiple resources 
of differenf f 5 q)es (necessifafing mulfiple using sfafemenfs), you can nesf fhem wifh 
only one sef of braces: 

using (TextWriter output = File.CreateText("log.txt")) 
using (TextReader input = File.OpenText("log.txt")) { 

// Copy contents from one to the other 

} 

This can dramatically reduce fhe level of indenfafion required, making fhe code much 
more readable. 


When a resource-acquisition fakes fhe form of a local-variable-declaration, if is possible fo 
acquire mulfiple resources of a given f 5 q)e. A using sfafemenf of fhe form 

using (ResourceType rl = el, r2 = e2, ..., rN = eN) statement 

is precisely equivalenf fo a sequence of nesfed using sfafemenfs: 

using (ResourceType rl = el) 

using (ResourceType r2 = e2) 

using (ResourceType rN = eN) 
statement 

The example below creafes a file named log. txt and wrifes fwo lines of fexf fo fhe file. The 
example fhen opens fhaf same file for reading and copies fhe confained lines of fexf fo fhe 
console. 

using System; 
using System.10; 


448 


www.it-ebooks.info 






8.14 The yield Statement 


class Test 
{ 

static void Main() { 

using (TextWriter w = File.CreateText("log.txt")) { 
w.WriteLine("This is line one"); 
w.WriteLine("This is line two"); 

} 

using (TextReader r = File.OpenText("log.txt")) { 
string s; 

while ((s = r.ReadtineO) != null) { 

Console.WriteLine(s); 

} 

} 

} 

} 

Since the TextWriter and TextReader classes implement the IDisposable interface, the 
example can use using statements to ensure that the underlying file is properly closed fol¬ 
lowing the write or read operations. 


"■ CHRIS SELLS You should almost always wrap a using block around any resource 
you acquire that implements IDisposable (unless you're keeping that object between 
method invocations). Although the .NET garbage collector does a wonderful job with 
releasing memory resources, all other resources are yours to manage. Likewise, the 
compiler does a wonderful job of generating the proper disposing code for you, but 
only when you wrap your resource allocations in using blocks. 


8.14 The yield Statement 


"■ BILLWAGNER Theyield return and yield break statements seem to be two of 
the most under-appreciated statements in the C# language. They are incredibly useful 
whenever you are writing algorithms that work on sequences of data. Generating 
sequences, filtering sequences, combining sequences, and other algorithms are all 
built using these statements. In fact, most of LINQ to Objects is built using the yield 
statement. 

If you're not already familiar with these techniques, you should spend the time to 
make this technique part of your everyday development practices. 


00 


449 


www.it-ebooks.info 


Statements 








Statements 


8. Statements 


“■ CHRIS SELLS I agree with Bill. I didn't appreciate just how useful yield return 
was until I saw someone write code like this: 

IEnumerable<int> GetSomeNumbers() { 
yield return 1; 
yield return 2; 
yield return 3; 

} 

If you can gef your head around fhaf and whaf fhe compiler is doing for you fo make 
fhaf happen, you'll find yourself using fhis feafure a lof more. 


The yield sfafemenf is used in an iferafor block (§8.2) fo yield a value fo fhe enumerafor 
objecf (§10.14.4) or enumerable objecf (§10.14.5) of an iferafor or fo signal fhe end of fhe 
iferafion. 

yield-statement: 

yield return expression ; 
yield break ; 

Nofe fhaf yield is nof a reserved word; if has special meaning only when used immedi- 
afely before a return or break keyword. In ofher confexfs, yield can be used as an 
identifier. 

There are several resfricfions on where a yield sfafemenf can appear, as described in fhe 
following lisf: 

• If is a compile-fime error for a yield sfafemenf (of eifher form) fo appear oufside a 
method-body, operator-body, or accessor-body. 

• If is a compile-fime error for a yield sfafemenf (of eifher form) fo appear inside an 
anonymous function. 

• If is a compile-fime error for a yield sfafemenf (of eifher form) fo appear in fhe finally 
clause of a try sfafemenf. 

• If is a compile-fime error for a yield return sfafemenf fo appear anywhere in a try sfafe¬ 
menf fhaf confains any catch clauses. 

The following example shows some valid and invalid uses of yield sfafemenfs. 

delegate IEnumerable<int> D(); 

IEnumeraton<int> GetEnumerator() { 
try { 

yield return 1; // Okay 

yield break; // Okay 

} 


450 


www.it-ebooks.info 






8.14 The yield Statement 


finally { 

yield return 2; 
yield break; 

} 


// Error: yield in finally 
// Error: yield in finally 


try { 

yield return 3; // 

yield break; // 

} 

catch { 

yield return 4; // 

yield break; // 

} 


yield return in try...catch 


yield return in try...catch 


Error: 

Okay 


Error: 

Okay 


D d = delegate { 

yield return 5; // Error: yield in an anonymous function 

}; 


int MyMethodO { 
yield return 1; 

} 


// Error: wrong return type for an 
// iterator block 


An implicit conversion (§6.1) must exist from the t 5 ^e of the expression in the yield return 

statement to the yield type (§10.14.3) of the iterator. 

A yield return statement is executed as follows: 

• The expression given in the statement is evaluated, implicitly converted to the yield 
type, and assigned to the Current property of the enumerator object. 

• Execution of the iterator block is suspended. If the yield return statement is within one 
or more try blocks, the associated finally blocks are not executed at this time. 

• The MoveNext method of the enumerator object returns true to its caller, indicating that 
the enumerator object successfully advanced to the next item. 

The next call to the enumerator object's MoveNext method resumes execution of the iterator 

block from where it was last suspended. 

A yield break statement is executed as follows: 

• If the yield break statement is enclosed by one or more try blocks with associated 
finally blocks, control is initially transferred to the finally block of the innermost try 
statement. When and if control reaches the end point of a finally block, control is trans¬ 
ferred to the finally block of the next enclosing try statement. This process is repeated 
until the finally blocks of all enclosing try statements have been executed. 

• Control is returned to the caller of the iterator block. This is either the MoveNext method 
or the Dispose method of the enumerator object. 


00 


451 


www.it-ebooks.info 


Statements 




Statements 


8. Statements 


Because a yield break statement unconditionally transfers control elsewhere, the end point 
of a yield break sfafemenf is never reachable. 


■■ CHRIS SELLS I sometimes forget that yield return is not the same as return, in 
that the code after a yield return can be executed. For example, the code after the 
first return here can never be executed: 

int F() { 

return 1; 

return 2; // Can never be executed 

} 

In contrast, the code after the first yield return here can be executed: 

IEnumerable<int> F() { 
yield return 1; 

yield return 2; // Can be executed 

} 

This often bites me in an if statement: 

IEnumerable<int> F() { 

if(...) { yield return !;}//! mean this to be the only 

// thing returned 

yield return 2; // Oops! 

} 

In these cases, remembering that yield return is not "final" like return is helpful. 


“■ CHRISTIAN NAGEL Since C# 1.0, if has been easy fo use iferafors (fhe foreach 
sfafemenf). Since C# 2.0, if has been easy fo creafe iferafors (fhe yield sfafemenf). 


00 


452 


www.it-ebooks.info 








9. Namespaces 


C# programs are organized using namespaces. Namespaces are used both as an "internal" 
organization system for a program and as an "external" organization system—a way of 
presenting program elements that are exposed to other programs. 

Using directives (§9.4) are provided to facilitate the use of namespaces. 


"■ BILL WAG N E R As you read fhis, remember fhaf namespaces are a logical organi- 
zafion: Mulfiple namespaces can, and offen do, occur in one assembly, and a single 
namespace may be declared in many differenf assemblies. 


9.1 Compilation Units 

A compilation-unit defines fhe overall sfrucfure of a source file. A compilation unit consists 
of zero or more using-directives followed by zero or more global-attributes followed by zero 
or more namespace-member-declarations. 

compilation-unit: 

extern-alias-directivesusing-directivesglobal-attributes 
namespace-member-declarations^^^ 

A C# program consists of one or more compilafion units, each contained in a separate 
source file. When a C# program is compiled, all of fhe compilafion unifs are processed 
fogether. Thus compilation units can depend on each other, possibly in a circular fashion. 


“■ CHRIS SELLS This feafure alone makes C# about ten times easier to work with 
than either C or C++. 


The using-directives of a compilation unit affect the global-attributes and namespace-member- 
declarations of fhaf compilafion unit, but have no effect on other compilation units. 


453 


www.it-ebooks.info 








Namespaces 


9. Namespaces 


■■ JON SKEET Most of the time I think I like this feature—^but just occasionally, 
when I want to whip up a quick program to test just a few lines of code. I'd rather not 
have to import a bunch of namespaces. It would be interesting to know what the effect 
of having "project-level" using directives (like assembly references) would have been 
in an alternative reality 


ERIC LIPPERT Jon's point is well taken: The "ceremony" needed to write any C# 
program is disporportionately large if the program is very short. Although C# is not 
intended to be a "scripting" language per se, there is something nice about the prop¬ 
erty that a one-line program is actually one line in, say, JScript. 


The global-attributes (§17) of a compilation unit permit the specification of attributes for the 
target assembly and module. Assemblies and modules act as physical containers for types. 
An assembly may consist of several physically separate modules. 

The namespace-member-declarations of each compilation unit of a program contribute mem¬ 
bers to a single declaration space called the global namespace. For example: 

File A.cs: 

class A {} 

File B.cs: 

class B {} 

The two compilation units contribute to the single global namespace—in this case, declar¬ 
ing two classes with the fully qualified names A and B. Because the two compilation units 
contribute to the same declaration space, it would have been an error if each contained a 
declaration of a member with the same name. 


9.2 Namespace Declarations 

A namespace-declaration consists of the keyword namespace, followed by a namespace name 
and body, optionally followed by a semicolon. 

namespace-declaration: 

namespace qualified-identifier namespace-body 


454 


www.it-ebooks.info 








9.2 Namespace Declarations 


qualified-identifier: 

identifier 

qualified-identifier . identifier 
namespace-body: 

{ extern-alias-directivesusing-directivesnamespace-member-declarations } 

A namespace-declaration may occur as a top-level declaration in a compilation-unit or as a 
member declaration within another namespace-declaration. When a namespace-declaration 
occurs as a top-level declaration in a compilation-unit, the namespace becomes a member of 
the global namespace. When a namespace-declaration occurs within another namespace- 
declaration, the irmer namespace becomes a member of the outer namespace. In either case, 
the name of a namespace must be unique within the containing namespace. 

Namespaces are implicitly public and the declaration of a namespace carmot include any 
access modifiers. 

Within a namespace-body, the optional using-directives import the names of other namespaces 
and t 5 q)es, allowing them to be referenced directly instead of through qualified names. The 
optional namespace-member-declarations contribute members to the declaration space of the 
namespace. Note that all using-directives must appear before any member declarations. 

The qualified-identifier of a namespace-declaration may be a single identifier or a sequence of 
identifiers separated by "tokens. The latter form permits a program to define a nested 
namespace without lexically nesting several namespace declarations. For example, 

namespace N1.N2 
{ 

class A { } 
class B { } 

} 

is semantically equivalent to 

namespace N1 
{ 

namespace N2 
{ 

class A { } 
class B { } 

} 

} 


)0 


455 


www.it-ebooks.info 


Namespaces 




Namespaces 


9. Namespaces 


Namespaces are open-ended, and two namespace declarations with the same fully quali¬ 
fied name confribufe fo fhe same declaration space (§3.3). In fhe example 

namespace N1.N2 
{ 

class A { } 

} 

namespace N1.N2 
{ 

class B { } 

} 

fhe fwo namespace declarafions confribufe fo fhe same declarafion space—in fhis case 
declaring fwo classes wifh fhe fully qualified names N1. N2. A and N1. N2. B. Because fhe fwo 
declarafions confribufe fo fhe same declarafion space, if would have been an error if each 
confained a declarafion of a member wifh fhe same name. 

9.3 Extern Aliases 

An extern-alias-directive infroduces an identifier fhaf serves as an alias for a namespace. The 
specificafion of fhe aliased namespace is exfernal fo fhe source code of fhe program and 
also applies fo nesfed namespaces of fhe aliased namespace. 

extern-alias-directives: 

extern-alias-directive 

extern-alias-directives extern-alias-directive 

extern-alias-directive: 

extern alias identifier j 

The scope of an extern-alias-directive exfends over fhe using-directives, global-attributes, 
and namespace-member-declarations of ifs immediafely confaining compilation unif or 
namespace body. 

Wifhin a compilation unif or namespace body fhaf confains an extern-alias-directive, fhe 
idenfifier infroduced by fhe extern-alias-directive can be used fo reference fhe aliased 
namespace. If is a compile-fime error for fhe identifier fo be fhe word global. 

An extern-alias-directive makes an alias available wifhin a parficular compilafion unif or 
namespace body, buf if does nof confribufe any new members fo fhe underlying declara¬ 
fion space. In ofher words, an extern-alias-directive is nof fransifive, buf rafher affecfs only 
fhe compilafion unif or namespace body in which if occurs. 


456 


www.it-ebooks.info 




9.4 Using Directives 


The following program declares and uses two extern aliases, X and Y, each of which repre¬ 
sents the root of a distinct namespace hierarchy: 

extern alias X; 
extern alias Y; 

class Test 
{ 

X::N.A a; 

X::N.B bl; 

Y::N.B b2; 

Y::N.C c; 

} 

The program declares the existence of the extern aliases X and Y, but the actual definitions 
of the aliases are external to the program. The identically named N. B classes can now be 
referenced as X. N. B and Y. N. B, or, using the namespace alias qualifier, X :: N. B and Y :: N. B. 
An error occurs if a program declares an extern alias for which no external definition is 
provided. 


)0 


9A Using Directives 

Using directives facilitate the use of namespaces and t 5 q)es defined in other namespaces. 
Using directives impact the name resolution process of naniespace-or-type-names (§3.8) and 
simple-names (§7.6.2), but unlike declarations, using directives do not contribute new mem¬ 
bers to the underlying declaration spaces of the compilation units or namespaces within 
which they are used. 

using-directives: 

using-directive 

using-directives using-directive 

using-directive: 

using-alias-directive 

using-namespace-directive 

A using-alias-directive (§9.4.1) introduces an alias for a namespace or t 5 q)e. 

A using-namespace-directive (§9.4.2) imports the type members of a namespace. 

The scope of a using-directive extends over the namespace-member-declarations of its imme¬ 
diately containing compilation unit or namespace body. The scope of a using-directive spe¬ 
cifically does not include its peer using-directives. Thus peer using-directives do not affect 
one another, and the order in which they are written is insignificant. 


457 


www.it-ebooks.info 


Namespaces 




Namespaces 


9. Namespaces 


ON 


9.4.1 Using Alias Directives 

A using-alias-directive introduces an identifier that serves as an alias for a namespace or 
fype wifhin fhe immediafely enclosing compilation unif or namespace body. 

using-alias-directive: 

using identifier - namespace-or-type-name ; 

Wifhin member declarafions in a compilafion unif or namespace body fhaf confains a 
using-alias-directive, fhe identifier infroduced by fhe using-alias-directive can be used fo refer¬ 
ence fhe given namespace or t5^e. For example: 

namespace N1.N2 
{ 

class A { } 

} 

namespace N3 
{ 

using A = N1.N2.A; 
class B : A { } 

} 

In fhis example, wifhin fhe member declarafions in fhe N3 namespace, A is an alias for 
N1. N2. A, and fhus class N3. B derives from class N1. N2. A. The same effecf can be obfained 
by creating an alias R for N1. N2 and fhen referencing R. A: 

namespace N3 
{ 

using R = N1.N2; 
class B : R.A { } 

} 

The identifier of a using-alias-directive musf be unique wifhin fhe declaration space of fhe 
compilafion unif or namespace fhaf immediafely confains the using-alias-directive. For 
example: 

namespace N3 
{ 

class A { } 

} 

namespace N3 
{ 

using A = N1.N2.A; // Error: A already exists 

} 

In this example, N3 already contains a member A, so it is a compile-time error for a using- 
alias-directive fo use fhaf idenfifier. Likewise, if is a compile-fime error for fwo or more 


458 


www.it-ebooks.info 




9.4 Using Directives 


using-alias-directives in the same compilation unit or namespace body to declare aliases by 
the same name. 

A using-alias-directive makes an alias available within a particular compilation unit or 
namespace body, but it does not contribute any new members to the underlying declara¬ 
tion space. In other words, a using-alias-directive is not transitive, but rather affects only the 
compilation unit or namespace body in which it occurs. In the example 

namespace N3 
{ 

using R = N1.N2; 

} 

namespace N3 
{ 

class B : R.A { } // Error: R unknown 

} 

the scope of fhe using-alias-directive fhaf infroduces R exfends only fo member declarafions 
in fhe namespace body in which if is confained, so R is unknown in fhe second namespace 
declarafion. However, placing fhe using-alias-directive in fhe confarning compilafion unif 
causes fhe alias fo become available wifhin bofh namespace declarafions: 

using R = N1.N2; 

namespace N3 
{ 

class B: R.A {} 

} 

namespace N3 
{ 

class C: R.A {} 

} 

Jusf like regular members, names infroduced by using-alias-directives are hidden by simi¬ 
larly named members in nesfed scopes. In fhe example 

using R = N1.N2; 

namespace N3 
{ 

class R {} 

class B: R.A {} // Error: R has no member A 

} 

fhe reference fo R. A in fhe declarafion of B causes a compile-fime error because R refers fo 
N3.R, nof N1.N2. 

The order in which using-alias-directives are wriffen has no significance, and resolufion 
of fhe namespace-or-type-name referenced by a using-alias-directive is nof affecfed by fhe 


)0 


459 


www.it-ebooks.info 


Namespaces 




Namespaces 


9. Namespaces 


using-alias-directive itself or by other using-directives in the immediately containing compila¬ 
tion unit or namespace body. In other words, the namespace-or-type-name of a using-alias- 
directive is resolved as if the immediately containing compilation unit or namespace body 
had no using-directives. A using-alias-directive may, however, be affected by extern-alias- 
directives in the immediately containing compilation unit or namespace body. In the 
example 

namespace N1.N2 { } 

namespace N3 
{ 

extern alias E; 
using R1 = E.N; 
using R2 = Nl; 
using R3 = N1.N2; 
using R4 = R2.N2; 

} 

the last using-alias-directive results in a compile-time error because it is not affected by the 
first using-alias-directive. The first using-alias-directive does not result in an error since the 
scope of the extern alias E includes the using-alias-directive. 

A using-alias-directive can create an alias for any namespace or type, including the namespace 
within which it appears and any namespace or type nested within that namespace. 

Accessing a namespace or t5^e through an alias yields exactly the same result as accessing 
that namespace or type through its declared name. For example, given 

namespace N1.N2 
{ 

class A { } 

} 

namespace N3 
{ 

using R1 = Nl; 
using R2 = N1.N2; 

class B 
{ 

N1.N2.A a; 

R1.N2.A b; 

R2.A c; 

} 

} 

the names Nl. N2. A, R1. N2. A, and R2. A are equivalent and all refer to the class whose fully 
qualified name is Nl. N2. A. 


// Refers to N1.N2.A 
// Refers to N1.N2.A 
// Refers to N1.N2.A 


// Okay 
// Okay 
// Okay 

// Error: R2 unknown 


460 


www.it-ebooks.info 




9.4 Using Directives 


Using aliases can name a closed constructed type, but cannot name an unbound generic 
type declaration without supplying type arguments. For example: 


namespace N1 
{ 

class A<T> 


{ 

class B {} 

} 

} 

namespace N2 
{ 

using W = Nl.A; 
using X = Nl.A.B; 
using Y = Nl.A<int>; 
using Z<T> = N1.A<T>; 


// Error: cannot name unbound generic type 
// Error, cannot name unbound generic type 
// Okay: can name closed constructed type 
// Error: using alias cannot have type parameters 


} 

9.4.2 Using Namespace Directives 


A using-namespace-directive imports the t 5 ^es contained in a namespace into the immedi¬ 
ately enclosing compilation unit or namespace body, enabling the identifier of each type to 
be used without qualification. 


using-namespace-directive: 
using namespace-name ; 


Within member declarations in a compilation unit or namespace body that contains a 
using-namespace-directive, the types contained in the given namespace can be referenced 
directly. For example: 

namespace N1.N2 
{ 

class A { } 

} 

namespace N3 
{ 

using N1.N2; 
class B : A { } 

} 

In this example, within the member declarations in the N3 namespace, the type members 
of N1. N2 are directly available, and thus class N3. B derives from class N1. N2. A. 


)0 


461 


www.it-ebooks.info 


Namespaces 




Namespaces 


9. Namespaces 


ON 


A using-namespace-directive imports the types contained in the given namespace, but spe¬ 
cifically does not import nested namespaces. In the example 

namespace N1.N2 
{ 

class A { } 

} 

namespace N3 
{ 

using Nl; 

class B : N2.A { } // Error: N2 unknown 

} 


the using-namespace-directive imports the types contained in Nl, but not the namespaces 
nested in Nl. Thus the reference to N2.A in the declaration of B results in a compile-time 
error because no members named N2 are in scope. 

Unlike a using-alias-directive, a using-namespace-directive may import types whose identifiers 
are already defined within the enclosing compilation unit or namespace body. In effect, 
names imported by a using-namespace-directive are hidden by similarly named members in 
the enclosing compilation unit or namespace body. For example: 

namespace N1.N2 
{ 

class A { } 
class B { } 

} 

namespace N3 
{ 

using N1.N2; 
class A { } 

} 


Here, within the member declarations in the N3 namespace, A refers to N3. A rather than 
N1.N2.A. 


When more than one namespace imported by using-namespace-directives in the same com¬ 
pilation unit or namespace body contain types by the same name, references to that name 
are considered ambiguous. In the example 

namespace Nl 
{ 

class A { } 

} 

namespace N2 
{ 

class A { } 

} 


462 


www.it-ebooks.info 




9.5 Namespace Members 


namespace N3 

{ 

using Nl; 
using N2; 

class B : A { } // Error: A is ambiguous 

} 


both N1 and N2 contain a member A, and because N3 imports both, referencing A in N 3 is a 
compile-time error. In this situation, the conflict can be resolved either through qualifica¬ 
tion of references to A or by introducing a using-alias-directive that picks a particular A. For 
example: 


namespace N3 

{ 

using Nl; 
using N2; 
using A = Nl.A; 

class B : A { } //A means Nl.A 

} 


Like a using-alias-directive, a using-namespace-directive does not contribute any new mem¬ 
bers to the underlying declaration space of the compilation unit or namespace, but rather 
affects only the compilation unit or namespace body in which it appears. 

The namespace-name referenced by a using-namespace-directive is resolved in the same way 
as the namespace-or-type-name referenced by a using-alias-directive. Thus using-namespace- 
directives in the same compilation unit or namespace body do not affect one another and 
can be written in any order. 


)0 


9.5 Namespace Members 

A namespace-member-declaration is either a namespace-declaration (§9.2) or a type-declaration 
(§9.6). 

namespace-member-declarations: 

namespace-member-declaration 

namespace-member-declarations namespace-member-declaration 

namespace-member-declaration: 

namespace-declaration 

type-declaration 


463 


www.it-ebooks.info 


Namespaces 




Namespaces 


9. Namespaces 


os 


A compilation unit or a namespace body can contain namespace-member-declarations, and 
such declarations contribute new members to the underlying declaration space of the con¬ 
taining compilation unit or namespace body. 


9.6 Type Declarations 

A type-declaration is a class-declaration (§10.1), a struct-declaration (§11.1), an interface- 
declaration (§13.1), an enum-declaration (§14.1), or a delegate-declaration (§15.1). 

type-declaration: 

class-declaration 

struct-declaration 

interface-declaration 

enum-declaration 

delegate-declaration 

A type-declaration can occur as a top-level declaration in a compilation unit or as a member 
declaration within a namespace, class, or struct. 

When a t 5 ^e declaration for a t 5 ^e T occurs as a top-level declaration in a compilation unit, 
the fully qualified name of the newly declared type is simply T. When a type declaration 
for a t 5 q)e T occurs within a namespace, class, or struct, the fully qualified name of the 
newly declared t 5 q)e is N. T, where N is the fully qualified name of the containing namespace, 
class, or struct. 

A t 5 q)e declared within a class or struct is called a nested type (§10.3.8). 

The permitted access modifiers and fhe defaulf access for a type declaration depend on the 
context in which the declaration takes place (§3.5.1): 

• Types declared in compilation emits or namespaces can have public or internal access. 
The default is internal access. 

• Types declared in classes can have public, protected internal, protected, internal, or 
private access. The default is private access. 

• Types declared in structs can have public, internal, or private access. The default is 
private access. 


9.7 Namespace Alias Qualifiers 

The namespace alias qualifier :: makes it possible to guarantee that type name lookups 
are unaffected by the introduction of new types and members. The namespace alias 


464 


www.it-ebooks.info 




9.7 Namespace Alias Qualifiers 


qualifier always appears between two identifiers, referred to as the left-hand and right- 
hand identifiers. Unlike the regular . qualifier, the left-hand identifier of the :: qualifier is 
looked up only as an extern or using alias. 

A qualified-alias-member is defined as follows: 

qualified-alias-member: 

identifier :: identifier type-argument-list 

A qualified-alias-member can be used as a namespace-or-type-name (§3.8) or as the left operand 
in a member-access (§7.6.4). 

A qualified-alias-member has one of two forms: 

• N: :I<Ajj ..., A^>, where N and I represent identifiers, and <Ajj ..., A^> is a type argument 
list. (K is always at least one.) 

• N:: I, where N and I represent identifiers. (In this case, K is considered to be zero.) 

Using this notation, the meaning of a qualified-alias-member is determined as follows: 

• If N is the identifier global, then the global namespace is searched for I: 

- If the global namespace contains a namespace named I and K is zero, then the 
qualified-alias-member refers to that namespace. 

- Otherwise, if the global namespace contains a nongeneric type named I and K is zero, 
then the qualified-alias-member refers to that type. 

- Otherwise, if the global namespace contains a type named I that has K type parame¬ 
ters, then the qualified-alias-member refers to that type constructed with the given type 
arguments. 

- Otherwise, the qualified-alias-member is undefined and a compile-time error occurs. 

• Otherwise, starting with the namespace declaration (§9.2) immediately containing the 
qualified-alias-member (if any), continuing with each enclosing namespace declaration (if 
any), and ending with the compilation unit containing the qualified-alias-member, the fol¬ 
lowing steps are evaluated until an entity is located: 

- If the namespace declaration or compilation unit contains a using-alias-directive that 
associates N with a t 5 q)e, then the qualified-alias-member is undefined and a compile¬ 
time error occurs. 

- Otherwise, if the namespace declaration or compilation unit contains an extern-alias- 
directive or using-alias-directive that associates N with a namespace, then: 

• If the namespace associated with N contains a namespace named I and K is zero, 
then the qualified-alias-member refers to that namespace. 


)0 


465 


www.it-ebooks.info 


Namespaces 




Namespaces 


9. Namespaces 


• Otherwise, if the namespace associated with N contains a nongeneric type named I 
and K is zero, then the qualified-alias-member refers to that type. 

• Otherwise, if the namespace associated with N contains a type named I that has 
K type parameters, then the qualified-alias-member refers to that t 5 ^e constructed 
with the given type arguments. 

• Otherwise, the qualified-alias-member is undefined and a compile-time error 
occurs. 

• Otherwise, the qualified-alias-member is undefined and a compile-time error occurs. 

Note that using the namespace alias qualifier with an alias that references a type causes a 
compile-time error. Also note that if the identifier N is global, then lookup is performed in 
the global namespace, even if there is a using alias associating global with a type or 
namespace. 

9.7.1 Uniqueness of Aliases 

Each compilation unit and namespace body has a separate declaration space for extern 
aliases and using aliases. Thus, while the name of an extern alias or using alias must be 
unique within the set of extern aliases and using aliases declared in the immediately con¬ 
taining compilation emit or namespace body, an alias is permitted to have the same name 
as a t 5 q)e or namespace as long as it is used only with the :: qualifier. 

In the example 

namespace N 
{ 

public class A { } 
public class B { } 

} 

namespace N 
{ 

using A = System.10; 

class X 
{ 

A.Stream si; 

A;:Stream s2; 

} 

} 

the name A has two possible meanings in the second namespace body because both the 
class A and the using alias A are in scope. For this reason, use of A in the qualified name 
A. Stream is ambiguous and causes a compile-time error to occur. However, use of A with 
the :: qualifier is not an error because A is looked up only as a namespace alias. 


// Error: A is ambiguous 
// Okay 


466 


www.it-ebooks.info 




10. Classes 


A class is a data structure that may contain data members (constants and fields), function 
members (methods, properties, events, indexers, operators, instance constructors, destruc¬ 
tors, and static constructors), and nested types. Class types support inheritance, a mecha¬ 
nism whereby a derived class can extend and specialize a base class. 


10.1 Class Declarations 

A class-declaration is a type-declaration (§9.6) that declares a new class. 
class-declaration: 

attributes^^^ class-modifiers partial^p^ class identifier type-parameter-list 
class-basetype-parameter-constraints-clauses^^ class-body 

A class-declaration consists of an opfional sef of attributes (§17), followed by an optional set 
of class-modifiers (§10.1.1), followed by an opfional partial modifier, followed by fhe key¬ 
word class and an identifier thaf names fhe class, followed by an opfional type-parameter- 
list (§10.1.3), followed by an opfional class-base specification (§10.1.4), followed by an 
opfional set of type-parameter-constraints-clauses (§10.1.5), followed by a class-body (§10.1.6), 
optionally followed by a semicolon. 

A class declaration carmot supply type-parameter-constraints-clauses unless it also supplies a 
type-parameter-list. 

A class declaration that supplies a type-parameter-list is a generic class declaration. Addi¬ 
tionally, any class nested inside a generic class declaration or a generic struct declaration is 
itself a generic class declaration, since type parameters for fhe confaining t 5 ^e musf be 
supplied to create a constructed type. 

10.1.1 Class Modifiers 

A class-declaration may optionally include a sequence of class modifiers: 

class-modifiers: 

class-modifier 

class-modifiers class-modifier 


467 


www.it-ebooks.info 




10. Classes 


10. Classes 


class-modifier: 

new 

public 

protected 

internal 

private 

abstract 

sealed 

static 

It is a compile-time error for the same modifier fo appear mulfiple fimes in a class 
declarafion. 

The new modifier is permiffed on nesfed classes. If specifies fhaf fhe class hides an inherifed 
member by fhe same name, as described in §10.3.4. If is a compile-fime error for fhe new 
modifier fo appear on a class declarafion fhaf is nof a nesfed class declarafion. 

The public, protected, internal, and private modifiers confrol fhe accessibilify of fhe 
class. Depending on fhe confexf in which fhe class declarafion occurs, some of fhese modi¬ 
fiers may nof be permiffed (§3.5.1). 

The abstract, sealed, and static modifiers are discussed in fhe following sections. 

10.1.1.1 Abstract Classes 

The abstract modifier is used fo indicafe fhaf a class is incomplefe and fhaf if is infended 
fo be used only as a base class. An absfracf class differs from a nonabsfracf class in fhe fol¬ 
lowing ways: 

• An absfracf class carmof be insfanfiafed direcfly, and if is a compile-fime error fo use fhe 
new operafor on an absfracf class. While if is possible fo have variables and values whose 
compile-fime fypes are absfracf, such variables and values will necessarily eifher be null 
or confain references fo insfances of nonabsfracf classes derived from fhe absfracf f 5 ^es. 

• An absfracf class is permiffed (buf nof required) fo confain absfracf members. 

• An absfracf class carmof be sealed. 

When a nonabsfracf class is derived from an absfracf class, fhe nonabsfracf class musf 
include acfual implemenfafions of all inherifed absfracf members, fhereby overriding fhose 
absfracf members. In fhe example 

abstract class A 
{ 

public abstract void F(); 

} 

abstract class B: A 


468 


www.it-ebooks.info 




10.1 Class Declarations 


{ 

public void G() {} 

} 

class C: B 
{ 

public override void F() { 

// Actual implementation of F 

} 

} 

the abstract class A introduces an abstract method F. Class B introduces an additional 
method G, but since it doesn't provide an implementation of F, B must also be declared 
abstract. Class C overrides F and provides an actual implementation. Since there are no 
abstract members in C, C is permitted (but not required) to be nonabstract. 

10.1.1.2 Sealed Classes 

The sealed modifier is used to prevent derivation from a class. A compile-time error occurs 
if a sealed class is specified as the base class of another class. 

A sealed class carmot also be an abstract class. 

The sealed modifier is primarily used fo prevent unintended derivation, but it also enables 
certain runtime optimizations. In particular, because a sealed class is known to never have 
any derived classes, it is possible to transform virtual function member invocations on 
sealed class instances into nonvirtual invocations. 


■■ JON SKEET The choice to make classes unsealed (but methods nonvirtual) by 
default has always been a hotly disputed one. I agree with the maxim "Design for 
inheritance or prohibit it," but there are arguments both ways. The odd point is how 
powerful a defaulf is: Even fhough I usually choose fo seal classes if I think about it, it's 
all too easy to ignore the choice entirely. It obviously doesn't affect what can be 
expressed, but I'm certain it affects the code that is actually produced. 


"■ JESSE LIBERTY I will take the risk of disagreeing with Jon. 

It is demonstrably false thaf you can accurafely anficipafe whaf will be needed even 
months in advance. Thus good programming practice would dictate letting your 
design emerge, building little or nothing before if is explicifly needed, and avoiding 
closing off avenues you believe you'll never need. 

Sealed is a minefield laid down fo sfafe, "You'll never need fo go here." I don't think 
you can know that or should presume to try. 


469 


www.it-ebooks.info 


10. Classes 








10. Classes 


10. Classes 


10.1.1.3 Static Classes 

The static modifier is used to mark the class being declared as a static class. Astatic class 
carmot be instantiated, carmot be used as a t 5 ^e, and can contain only static members. Only 
a static class can contain declarations of extension methods (§10.6.9). 

A static class declaration is subject to the following restrictions: 

• A static class may not include a sealed or abstract modifier. Note, however, that since 
a static class carmot be instantiated or derived from, it behaves as if it was both sealed 
and abstract. 

• A static class may not include a class-base specification (§10.1.4) and carmot explicitly 
specify a base class or a list of implemented interfaces. A static class implicitly inherits 
from type object. 

• A static class can only contain static members (§10.3.7). Note that constants and nested 
t 5 ^es are classified as static members. 

• A static class carmot have members with protected or protected internal declared 
accessibility. 

It is a compile-time error to violate any of these restrictions. 

A static class has no instance constructors. It is not possible to declare an instance con¬ 
structor in a static class, and no default instance constructor (§10.11.4) is provided for a 
static class. 

The members of a static class are not automatically static, and the member declarations 
must explicitly include a static modifier (except for constants and nested types). When a 
class is nested within a static outer class, the nested class is not a static class unless it explic¬ 
itly includes a static modifier. 


“■ MAREK SAFAR A sealed class with a private constructor had to be used to simu¬ 
late static classes in C# l.O.That is no longer needed, as static classes offer a more ele¬ 
gant way to express this intention, plus the benefit of many compiler checks for 
operations that are not allowed in a static context. 


10.1.1.3.1 Referencing Static Class Types 

A namespace-or-type-name (§3.8) is permitted to reference a static class if 

• The namespace-or-type-name is the T in a namespace-or-type-name of the form T. I, or 

• The namespace-or-type-name is the T in a typeof-expression (§7.5.11) of the form 
typeof (T). 


www.it-ebooks.info 






10.1 Class Declarations 


A primary-expression (§7.5) is permitted to reference a static class if 

• The primary-expression is fhe E in a member-access (§7.5.4) of fhe form E. I. 

In any ofher confexf, if is a compile-time error to reference a sfafic class. For example, if is 
an error for a sfatic class fo be used as a base class, a consfifuenf fype (§10.3.8) of a member, 
a generic fype argumenf, or a f 5 ^e paramefer consfrainf. Likewise, a sfafic class carmof be 
used in an array type, a pointer t 5 ^e, a new expression, a cast expression, an is expression, 
an as expression, a sizeof expression, or a default value expression. 

10.1.2 partial Modifier 

The partial modifier is used fo indicafe fhaf fhis class-declaration is a parfial fype decla- 
rafion. Mulfiple parfial type declarations with the same name within an enclosing 
namespace or t 5 ^e declaration combine to form one type declaration, following fhe rules 
specified in §10.2. 

Having fhe declarafion of a class disfribufed over separafe segmenfs of program fexf can 
be useful if fhese segmenfs are produced or mainfained in differenf confexfs. For insfance, 
one parf of a class declarafion may be machine generafed, whereas fhe ofher is aufhored 
manually. Texfual separafion of fhe fwo prevenfs updafes by one from conflicfing wifh 
updafes by fhe ofher. 


"■ CHRIS SELLS I love parfial classes'abilify fo splif fhaf parf fhaf's machine gener¬ 
afed from fhe parf fhaf's human generafed. Unforfunafely, you can abuse parfial 
classes by splitting a class across more fhan fwo files. As a reader of code, I find fhis 
pracfice exfremely difficulf fo follow, and I sfrongly discourage if. 


10.1.3 Type Parameters 

A f 5 ^e paramefer is a simple idenfifier fhaf denofes a placeholder for a type argument sup¬ 
plied to create a constructed t 5 ^e. A t 5 ^e parameter is a formal placeholder for a fype fhaf 
will be supplied lafer. By confrasf, a fype argumenf (§4.4.1) is fhe acfual fype fhaf is subsfi- 
fufed for fhe type parameter when a constructed type is created. 

type-parameter-list: 

< type-parameters > 

type-parameters: 

attributes^^^ type-parameter 

type-parameters , attributes^^ type-parameter 

type-parameter: 

identifier 


471 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


Each t 5 ^e parameter in a class declaration defines a name in the declaration space (§3.3) of 
fhaf class. Thus if cannof have fhe same name as anofher fype paramefer or a member 
declared in fhaf class. A f 5 ^e paramefer also cannof have fhe same name as fhe fype ifself. 

10.1.4 Class Base Specification 

A class declarafion may include a class-base specificafion, which defines fhe direcf base 
class of fhe class and fhe inferfaces (§13) direcfly implemenfed by fhe class. 

class-base: 

: class-type 

: interface-type-list 

: class-type , interface-type-list 

interface-type-list: 

interface-type 

interface-type-list , interface-type 

The base class specified in a class declarafion can be a consfrucfed class fype (§4.4). Abase 
class cannof be a fype paramefer on ifs own, alfhough if can involve fhe fype paramefers 
fhaf are in scope. 

class Extend<V>: V {} // Error: type parameter used as base class 


“■ BILL WAG N E R I wish fhis resfricfion could be removed. If would be a greaf way 
fo creafe mixins. I realize if's a very difficulf problem because V may confain any arbi- 
frary mefhods and properties. Depending on any concrefe f 5 T>e used for V in a closed 
generic Extend<V> may nof compile. 


10.1.4.1 Base Classes 

When a class-type is included in fhe class-base, if specifies fhe direcf base class of fhe class 
being declared. If a class declarafion has no class-base, or if fhe class-base lisfs only inferface 
fypes, fhe direcf base class is assumed fo be ob j ect. A class inherifs members from ifs direcf 
base class, as described in §10.3.3. 

In fhe example 
class A {} 
class B: A {} 

class A is said fo be fhe direcf base class of B, and B is said fo be derived from A. Since A does 
nof explicifly specify a direcf base class, ifs direcf base class is implicifly object. 

For a consfrucfed class f 5 T>e, if a base class is specified in fhe generic class declarafion, fhe 
base class of fhe consfrucfed fype is obfained by subsfifufing, for each type-parameter in 

472 


www.it-ebooks.info 







10.1 Class Declarations 


the base class declaration, the corresponding type-argument of the constructed type. 
Given the generic class declarations 

class B<U,V> {...} 

class G<T>: B<string,T[]> {...} 

the base class of fhe consfrucfed fype G<int> would be B<string, int[ ] >. 

The direcf base class of a class 1)^0 musf be af leasf as accessible as fhe class fype ifself 
(§3.5.2). For example, if is a compile-fime error for a public class fo derive from a private 
or internal class. 

The direcf base class of a class type must not be any of fhe following f 5 ^es: System. Array, 
System.Delegate, System.MulticastDelegate, System.Enum, or System.ValueType.Fur- 
fhermore, a generic class declaration carmof use System.Attribute as a direcf or indirecf 
base class. 

While defermining fhe meaning of fhe direcf base class specification A of a class B, fhe direcf 
base class of B is femporarily assumed fo be object. Infuifively, fhis ensures fhaf fhe mean¬ 
ing of a base class specification carmof recursively depend on ifself. The example 

class A<T> { 

public class B{} 

} 

class C : A<C.B> {} 

is in error since in fhe base class specification A<C. B>, fhe direcf base class of C is considered 
fo be object; hence (by fhe rules of §3.8), C is nof considered fo have a member B. 

The base classes of a class type are the direct base class and its base classes. In other words, 
the set of base classes is fhe fransifive closure of fhe direcf base class relationship. Referring 
fo fhe example above, fhe base classes of B are A and object. In fhe example 

class A {...} 

class B<T>; A {...} 

class C<T>: B<IComparable<T>> {...} 

class D<T>: C<T[]> {...} 

fhe base classes of D<int> are C<int[] >, B<IComparable<int[ ] >>, A, and object. 

Excepf for class object, every class fype has exacfly one direcf base class. The object class 
has no direcf base class and is fhe ulfimafe base class of all ofher classes. 

When a class B derives from a class A, if is a compile-fime error for A fo depend on B. A class 
directly depends on ifs direcf base class (if any) and directly depends on fhe class wifhin 
which if is immediafely nesfed (if any). Given fhis definifion, fhe complefe sef of classes 


473 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


upon which a class depends is the reflexive and transitive closure of the directly depends 
on relationship. 


"■ VLADIMIR RESHETNIKOV For the purposes of fhis rule, f 5 ^e argumenfs, if any, 
are ignored. For insfance, alfhough A<T> and A<A<T>> are diflerenf f 5 ^es, fhe following 
declaration is still invalid: 

class A<T> ; A<A<T>> { } 

Conversely, if is perfecfly valid for a class fo appear wifhin a type argument for a con- 
sfrucfed f 5 ^e specified as ifs base class: 

class A<T> { } 

class B : A<B[]> { } // Okay 


The example 

class A: A {} 

is erroneous because fhe class depends on ifself. Likewise, fhe example 
class A: B {} 
class B: C {} 
class C: A {} 

is in error because fhe classes circularly depend on fhemselves. Finally, fhe example 

class A: B.C {} 

class B: A 
{ 

public class C {} 

} 

resulfs in a compile-fime error because A depends on B. C (ifs direcf base class), which 
depends on B (ifs immediafely enclosing class), which circularly depends on A. 

Nofe fhaf a class does nof depend on fhe classes fhaf are nesfed wifhin if. In fhe example 

class A 
{ 

class B: A {} 

} 

B depends on A (because A is bofh ifs direcf base class and ifs immediafely enclosing class), 
buf A does nof depend on B (because B is neifher a base class nor an enclosing class of A). 
Thus fhe example is valid. 

If is nof possible fo derive from a sealed class. In fhe example 


474 


www.it-ebooks.info 






10.1 Class Declarations 


sealed class A {} 

class B: A {} // Error: cannot derive from a sealed class 

class B is in error because it attempts to derive from the sealed class A. 


10.1.4.2 Interface Implementations 

A class-base specification may include a list of interface types, in which case the class is said 
to directly implement the given interface f 5 ^es. Interface implementations are discussed 
further in §13.4. 


10.1.5 Type Parameter Constraints 

Generic t 5 ^e and method declarations can optionally specify type parameter constraints 
by including type-parameter-constraints-clauses. 

type-parameter-constraints-clauses: 

type-parameter-constraints-clause 

type-parameter-constraints-clauses type-paranieter-constraints-clause 

type-parameter-constraints-clause: 

where type-parameter : type-parameter-constraints 


type-parameter-constraints, 
primary-constraint 
secondary-constraints 
constructor-constraint 
primary-constraint , 
primary-constraint , 
secondary-constraints 
primary-constraint , 


secondary-constraints 
constructor-constraint 
, constructor-constraint 
secondary-constraints , 


constructor-constraint 


primary-constraint: 

class-type 

class 

struct 


secondary-constraints: 

interface-type 

type-parameter 

secondary-constraints , interface-type 
secondary-constraints , type-parameter 


constructor-constraint: 
new ( ) 


475 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


Each type-parameter-constraints-clause consists of the token where, followed by the name of 
a type parameter, followed by a colon and the list of constraints for that t 5 ^e parameter. 
There can be at most one where clause for each t 5 ^e parameter, and the where clauses can 
be listed in any order. Like the get and set tokens in a property accessor, the where token 
is not a ke 5 rword. 

The list of constraints given in a where clause can include any of the following components, 
in this order: a single primary constraint, one or more secondary constraints, and the con¬ 
structor constraint, new(). 

A primary constraint can be a class type or the reference type constraint class or the value 
type constraint struct. A secondary constraint can be a type-parameter or interface-type. 

The reference type constraint specifies that a type argument used for the type parameter 
must be a reference type. All class types, interface types, delegate types, array types, and 
t 5 ^e parameters known to be a reference type (as defined below) satisfy this constraint. 

The value type constraint specifies that a type argument used for the t 5 ^e parameter must 
be a non-nullable value t 5 ^e. All non-nullable struct types, enum types, and type param¬ 
eters having the value t 5 ^e constraint satisfy this constraint. Although it is classified as a 
value type, a nullable type (§4.1.10) does not satisfy the value t 5 ^e constraint. A t 5 ^e 
parameter having the value t 5 ^e constraint carmot also have the constructor-constraint. 


"■ BILL WAG N E R At one point, 1 found this set of constraints very limiting. 1 wanted 
to do meta-programming with generics, being able to specify any arbitrary set of 
members as constraints—things like other constructor signatures, or operators. Now 
that C# 3.0 has lambdas and more natural support for the use of methods as parame¬ 
ters, that feeling is gone. By specifying delegate signatures as type parameters, or as 
parameters to methods, C# programmers can achieve almost anything. 


Pointer t 5 ^es are never allowed to be t 5 ^e arguments and are not considered to satisfy 
either the reference t 5 ^e or value t 5 ^e constraints. 

If a constraint is a class type, an interface t 5 ^e, or a type parameter, that type specifies a 
minimal "base t 5 ^e" that every t 5 ^e argument used for that t 5 ^e parameter must support. 
Whenever a constructed type or generic method is used, the type argument is checked 
against the constraints on the t 5 ^e parameter at compile time. The type argument supplied 
must satisfy the conditions described in §4.4.4. 

A class-type constraint must satisfy the following rules: 

• The t 5 ^e must be a class type. 

• The t 5 ^e must not be sealed. 


476 


www.it-ebooks.info 






10.1 Class Declarations 


• The 1)^6 must not be one of the following fypes: System.Array, System.Delegate, 
System.Enum, or System.ValueType. 


■■ JONSKEET I know of no reason fo prohibif System. Enum or System.Delegate as 
fhe t 5 ^e here—alfhough if would cerfainly be more friendly fo be able fo wrife "where 
T : enum" fhan "where T : struct, Enum", which would be fhe mosf common use. 
Alfhough C# is specified separafely from fhe CLl, you mighf suspecf fhaf fhis is a CLl 
limifafion—^buf if's nof. Indeed, ECMA-335 explicifly lisfs fhis and ofher consfrainfs 
fhaf are prohibifed in C#. Perhaps fhis resfricfion will be removed from a fufure ver¬ 
sion of fhe language; fhere are plenfy of sifuafions where if would be useful. 


• The type must not be object. Because all types derive from object, such a consfrainf 
would have no effecf if if were permiffed. 

• Af mosf one consfrainf for a given fype paramefer can be a class fj^e. 

A fype specified as an interface-type consfrainf musf safisfy fhe following rules: 

• The f 5 ^e musf be an inferface type. 

• A type must not be specified more fhan once in a given where clause. 

In eifher case, fhe consfrainf can involve any of fhe fype paramefers of fhe associafed t 5 ^e 
or mefhod declarafion as parf of a consfrucfed fj^e, and can involve fhe type being 
declared. 

Any class or interface type specified as a type parameter constraint must be at least as 
accessible (§3.5.4) as the generic type or method being declared. 

A type specified as a type-parameter consfrainf musf safisfy fhe following rules: 

• The f 5 ^e musf be a fype paramefer. 

• A f 5 ^e musf nof be specified more fhan once in a given where clause. 

In addifion, fhere musf be no cycles in fhe dependency graph of fj^e paramefers, where 
dependency is a fransifive relafion defined as follows: 

• If a fype paramefer T is used as a consfrainf for fype paramefer S, fhen S depends on T. 

• If a f 5 ^e paramefer S depends on a f 5 ^e paramefer T and T depends on a fype paramefer 
L), fhen S depends on U. 

Given fhis relafion, if is a compile-fime error for a fype paramefer fo depend on ifself 
(direcfly or indirecfly). 


477 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


Any constraints must be consistent among dependent t 5 ^e parameters. If type parameter 
S depends on type parameter T, then 

• T must not have the value t 5 ^e constraint. Otherwise, T is effectively sealed so S would 
be forced fo be fhe same t 5 ^e as T, eliminafing fhe need for two type parameters. 

• If S has fhe value t 5 ^e consfrainf, fhen T musf nof have a class-type consfrainf. 

• If S has a class-type consfrainf A and T has a class-type consfrainf B, fhen fhere musf be an 
identify conversion or implicif reference conversion from A fo B or an implicif reference 
conversion from B fo A. 

• If S also depends on fype paramefer U and L) has a class-type consfrainf A and T has a 
class-type consfrainf B, fhen fhere musf be an idenfify conversion or implicif reference 
conversion from A fo B or an implicif reference conversion from B fo A. 

If is valid for S fo have fhe value fype consfrainf and T fo have fhe reference f 5 ^e consfrainf. 
Effectively, fhis limifs T fo fhe fypes System.Object, System.ValueType, System. Enum, and 
any inferface type. 

If fhe where clause for a fj^e paramefer includes a consfrucfor consfrainf (which has fhe 
form new( )), if is possible fo use fhe new operator fo create insfances of fhe fype (§7.6.10.1). 
Any fype argumenf used for a fype paramefer wifh a consfrucfor consfrainf musf have a 
public parameferless consfrucfor (fhis consfrucfor implicifly exisfs for any value fj^e) or 
be a fype paramefer having fhe value type constraint or constructor constraint (see 
§10.1.5 for defails). 

The following are examples of consfrarnfs: 

interface IPrintable 
{ 

void PrintO; 

} 

interface IComparable<T> 

{ 

int CompareTo(T value); 

} 

interface IKeyProvider<T> 

{ 

T GetKeyO; 

} 

class Printer<T> where T: IPrintable {...} 
class SortedList<T> where T; IComparable<T> {...} 


478 


www.it-ebooks.info 




10.1 Class Declarations 


class Dictionary<K,V> 

where K: IComparable<K> 

where V: IPrintablej IKeyProvider<K>j new() 

{ 

} 

The following example is in error because it causes a circularity in the dependency graph 
of the type parameters: 

class Circular<S,T> 
where S: T 

where T: S // Error: circularity in dependency graph 

{ 

} 

The following examples illustrate additional invalid situations: 

class Sealed<S,T> 
where S: T 

where T: struct // Error: T is sealed 

{ 

} 

class A {...} 

class B {...} 

class Incompat<SjT> 
where S: A, T 

where T: B // Error: incompatible class-type constraints 

{ 

} 

class StructWithClass<S,TjU> 
where S: struct, T 
where T: U 

where U: A // Error: A incompatible with struct 

{ 

} 

The effective base class of a t 5 ^e parameter T is defined as follows: 

• If T has no primary constraints or type parameter constraints, its effective base class is 
object. 

• If T has the value t 5 ^e constraint, its effective base class is System. ValueType. 

• If T has a class-type constraint C but no type-parameter constraints, its effective base 
class is C. 


479 


www.it-ebooks.info 


10. Classes 





10. Classes 


10. Classes 


• If T has no class-type constraint but has one or more type-parameter constraints, its effec¬ 
tive base class is the most encompassed type (§6.4.2) in the set of effective base classes 
of its type-parameter constraints. The consistency rules ensure that such a most encom¬ 
passed t 5 ^e exists. 

• If T has both a class-type constraint and one or more type-parameter constraints, its effec¬ 
tive base class is the most encompassed type (§6.4.2) in the set consisting of the class-type 
constraint of T and the effective base classes of its type-parameter constraints. The consis¬ 
tency rules ensure that such a most encompassed type exists. 

• If T has the reference t 5 ^e constraint but no class-type constraints, its effective base class 
is object. 

For the purpose of these rules, if T has a constraint V that is a value-type, use instead the 
most specific base type of V that is a class-type. This can never happen in an explicitly given 
constraint, but may occur when the constraints of a generic method are implicitly inherited 
by an overriding method declaration or an explicit implementation of an interface 
method. 

These rules ensure that the effective base class is always a class-type. 

"■ ERIC LIPPERT For example, suppose you have 

class B<T> { public virtual void M<U>() where U : T {} } 
class D : B<DateTlme> { public override void M<V>() } 

Then the effective base class of V is the class t 5 ^e System. ValueType, not the struct 
type DateTime. Similarly, if instead of DateTime, we had DateTime[], then the effective 
base class would be the class t 5 ^e System. Array, not the array type Date!ime [ ]. 


The effective interface set of a t 5 ^e parameter T is defined as follows: 

• If T has no secondary-constraints, its effective interface set is empty. 

• If T has interface-type constraints but no type-parameter constraints, its effective interface 
set is its set of interface-type constraints. 

• If T has no interface-type constraints but has type-parameter constraints, its effective inter¬ 
face set is the union of the effective interface sets of its type-parameter constraints. 

• If T has both interface-type constraints and type-parameter constraints, its effective inter¬ 
face set is the union of its set of interface-type constraints and the effective interface sets 
of its type-parameter constraints. 


480 


www.it-ebooks.info 






10.2 Partial Types 


A type parameter is known to be a reference type if it has the reference fype consfrainf or 
ifs effecfive base class is nof object or System.ValueType. 

Values of a consfrained fj^e paramefer fj^e can be used fo access fhe insfance members 
implied by fhe consfrainfs. In fhe example 

interface IPrintable 
{ 

void Print(); 

} 

class Printer<T> where T: IPrintable 
{ 

void PrintOne(T x) { 
x.PrintO; 

} 

} 

fhe mefhods of IPrintable can be invoked direcfly on x because T is consfrained fo always 
implemenf IPrintable. 

10.1.6 Class Body 

The class-body of a class defines fhe members of fhaf class. 
class-body: 

{ class-member-declarations , } 

10.2 Partial Types 

A fype declaration can be splif across multiple partial type declarations. The fype declara- 
fion is consfrucfed from ifs parfs by following fhe rules in fhis secfion, whereupon if is 
freafed as a single declaration during fhe remainder of fhe compile-fime and runfime pro¬ 
cessing of fhe program. 

A class-declaration, struct-declaration, or interface-declaration represenfs a parfial fype declara¬ 
tion if if includes a partial modifier. Nofe fhaf partial is nof a ke 5 rword, and acfs as a 
modifier only if if appears immediafely before one of fhe keywords class, struct, or 
interface in a fj^e declaration, or before fhe type void in a method declaration. In other 
contexts, it can be used as a normal identifier. 

Each parf of a parfial type declaration must include a partial modifier. If musf have fhe 
same name and be declared in fhe same namespace or fype declarafion as fhe ofher parfs. 
The partial modifier indicafes fhaf addifional parfs of fhe t 5 ^e declarafion may exisf else¬ 
where, buf fhe exisfence of such addifional parfs is nof a requiremenf; if is valid for a type 
with a single declaration to include the partial modifier. 


481 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


All parts of a partial type must be compiled together such that the parts can be merged at 
compile time into a single type declaration. Partial types specifically do not allow already 
compiled t 5 ^es to be extended. 

Nested types may be declared in multiple parts by using the partial modifier. Typically, 
the containing type is declared using partial as well, and each part of the nested type is 
declared in a different part of the containing type. 

The partial modifier is not permitted on delegate or enum declarations. 


“■ BILL WAG N E R This feature was clearly added to support code generators, but it 
has many other uses. I've put nested classes in separate compilation units, and broken 
apart classes on other logical boundaries. However, in the general case, splitting 
classes simply to let multiple developers work on the same class is not advised. 


"■ BRAD ABRAMS The traditional model employed by visual software design tools 
is to provide some user interface that developers use to express their intent; the tool 
then generates source code based on that intent. This approach is a time-tested and 
widely applicable model. The data design time, ASP.NET design time, and WinForms 
design time, for example, all use this basic model. However, this model does present 
some challenges—namely, developers often need to tweak, modify, or extend the code 
generated by the tool. Editing the generated code directly is a popular solution, but it 
has the major disadvantage of making the visual design tool unusable. Subclassing 
from the generated code is another approach, but it is often complicated by t 5 ^e issues. 
Partial t 5 ^es and methods allow for a class to be partially generated by a design tool 
and partially customized to better suit a given scenario. 


10.2.1 Attributes 

The attributes of a partial 1)^0 are determined by combining, in an unspecified order, the 
attributes of each of the parts. If an attribute is placed on multiple parts, it is equivalent to 
specifying the attribute multiple times on the type. For example, the two parts 

[Attrlj Attr2("hello")] 
partial class A {} 

[AttrS, Attr2("goodbye")] 
partial class A {} 


482 


www.it-ebooks.info 








10.2 Partial Types 


are equivalent to the following declaration: 

[Attrlj Attr2("hello")j Attr3j Attr2("goodbye")] 
class A {} 

Attributes on t 5 q)e parameters may be combined in a similar fashion. 

10.2.2 Modifiers 

When a parfial type declaration includes an accessibility specification (the public, 
protected, internal, and private modifiers), if musf agree wifh all ofher parfs fhaf include 
an accessibilify specificafion. If no parf of a parfial type includes an accessibility specifica¬ 
tion, the type is given the appropriate default accessibility (§3.5.1). 

If one or more parfial declarafions of a nesfed type include a new modifier, no warning is 
reporfed if fhe nesfed type hides an inherited member (§3.7.1.2). 

If one or more parfial declarafions of a class include an abstract modifier, fhe class is con¬ 
sidered absfracf (§10.1.1.1). Ofherwise, fhe class is considered nonabsfracf. 

If one or more parfial declarafions of a class include a sealed modifier, fhe class is consid¬ 
ered sealed (§10.1.1.2). Ofherwise, fhe class is considered unsealed. 

Nofe fhaf a class carmof be bofh absfracf and sealed. 

When fhe unsafe modifier is used on a parfial type declaration, only that particular part is 
considered an unsafe confexf (§18.1). 

10.2.3 Type Parameters and Constraints 

If a generic fype is declared in mulfiple parfs, each parf musf sfafe fhe fype paramefers. 
Each parf musf have fhe same number of type parameters, and the same name for each 
fype paramefer, in order. 

When a parfial generic t 5 q)e declarafion includes consfrainfs (where clauses), fhe consfrainfs 
musf agree wifh all ofher parfs fhaf include consfrainfs. Specifically, each parf fhaf includes 
consfrainfs musf have consfrainfs for fhe same sef of 1)^)0 paramefers, and for each type 
parameter the sets of primary, secondary, and consfrucfor consfrainfs musf be equivalenf. 
Two sefs of consfrainfs are equivalenf if fhey confain fhe same members. If no parf of a 
parfial generic fype specifies fype paramefer consfrainfs, fhe f 5 q)e paramefers are consid¬ 
ered unconsf rained. 


483 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


The example 

partial class Dictionary<K,V> 
where K: IComparable<K> 
where V: IKeyProvicler<K>j IPersistable 

{ 

} 

partial class Dictionary<KjV> 

where V: IPersistable, IKeyProvider<K> 
where K: IComparable<K> 

{ 

} 

partial class Dictionary<K,V> 

{ 

} 

is correct because those parts that include constraints (the first two) effectively specify fhe 
same sef of primary, secondary, and consfrucfor consfrainfs for fhe same sef of fype param- 
efers, respecfively. 


"■ BILL WAGNER When possible, 1 prefer specifying fhe f}^’^ paramefers and con¬ 
sfrainfs on all copies. This fechnique improves readabilify. 


10.2.4 Base Class 

When a parfial class declarafion includes a base class specificafion, if musf agree wifh all 
ofher parfs fhaf include a base class specificafion. If no parf of a parfial class includes a base 
class specificafion, fhe base class becomes System.Object (§10.1.4.1). 

10.2.5 Base Interfaces 

The sef of base inferfaces for a f 5 q)e declared in multiple parfs is fhe union of fhe base infer- 
faces specified on each parf. A parficular base inferface may be named only once on each 
parf, buf if is permiffed for mulfiple parfs fo name fhe same base inferface(s). There musf 
be only one implemenfafion of fhe members of any given base inferface. 

In fhe example 

partial class C: lA, IB {...} 
partial class C; IC {...} 
partial class C; lA, IB {...} 

fhe sef of base inferfaces for class C is lA, IB, and IC. 


484 


www.it-ebooks.info 







10.2 Partial Types 


Typically, each part provides an implementation of the interface(s) declared on that part; 
however, this is not a requirement. Apart may provide the implementation for an inferface 
declared on a differenf parf: 

partial class X 
{ 

int IComparable.CompareTo(object o) {...} 

} 

partial class X; IComparable 
{ 

} 

10.2.6 Members 

Wifh fhe excepfion of parfial mefhods (§10.2.7), fhe sef of members of a type declared in 
multiple parts is simply the union of fhe sef of members declared in each parf. The bodies of 
all parfs of fhe fype declaration share fhe same declaration space (§3.3), and fhe scope of each 
member (§3.7) exfends fo fhe bodies of all fhe parfs. The accessibilify domain of any member 
always includes all fhe parfs of fhe enclosing fype; a private member declared in one parf is 
freely accessible from anofher parf. If is a compUe-fime error fo declare fhe same member in 
more fhan one parf of fhe unless fhaf member is a f 5 q)e wifh fhe partial modifier. 


"■ BILL WAGNER Logically, you can fhink of fhe following example as one long 
source file, excepf you don'f know fhe order in which fhe class confenfs are 
combined. 


partial class A 
{ 

int x; // Error: cannot declare x more than once 

partial class Inner // Okay: Inner is a partial type 
{ 

int y; 

} 

} 

partial class A 
{ 

int x; // Error: cannot declare x more than once 

partial class Inner // Okay: Inner is a partial type 
{ 

int z; 

} 

} 

The ordering of members wifhin a fype is rarely significanf fo C# code, buf may be signifi- 
canf when inferfacing wifh ofher languages and environmenfs. In fhese cases, fhe ordering 
of members wifhin a fype declared in mulfiple parfs is undefined. 

485 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


■■ JON SKEET One area where ordering is important in C# is static and instance 
variable initializers: They are guaranteed to be executed in the "textual order" (§10.5.5) 
in which they appear in the class. This is no great loss, as relying on such ordering is 
usually a bad idea: A class that breaks when you just reorder declarations is too brittle 
to start with. 

It wouldn't be unreasonable to expect that members declared within the same part 
are handled in the obvious order, although the specification doesn't explicitly 
guarantee it. 


10.2.7 Partial Methods 

Partial methods can be defined in one parf of a t 5 ^e declarafion and implemenfed in 
anofher. The implemenfafion is opfional; if no parf implemenfs fhe parfial mefhod, fhe 
parfial mefhod declarafion and all calls fo if are removed from fhe type declaration result¬ 
ing from fhe combinafion of fhe parfs. 


“■ VLADIMIR RESHETNIKOV A parfial mefhod can be declared only in a parfial 
class or parfial sfrucf. If cannof be declared in a nonparfial f 5 ^e or in an inferface. 


Parfial mefhods cannof define access modifiers, buf are implicifly private. Their refurn 
fype musf be void, and fheir paramefers cannof have fhe out modifier. The idenfifier 
partial is recognized as a special ke 5 rword in a mefhod declarafion only if if appears righf 
before fhe void fype; ofherwise, if can be used as a normal idenfifier. A parfial mefhod can¬ 
nof explicifly implemenf inferface mefhods. 

There are fwo kinds of parfial mefhod declarafions: If fhe body of fhe mefhod declarafion 
is a semicolon, fhe declarafion is said fo be a defining partial method declaration. If fhe 
body is given as a block, fhe declarafion is said fo be an implementing partial method 
declaration. Across fhe parfs of a fype declarafion, fhere can be only one defining parfial 
mefhod declarafion wifh a given signafure, and fhere can be only one implemenfing par¬ 
fial mefhod declarafion wifh a given signafure. If an implemenfing parfial mefhod decla¬ 
rafion is given, a corresponding defining parfial mefhod declarafion musf exisf, and fhe 
declarafions musf mafch as specified in fhe following: 

• The declarafions musf have fhe same modifiers (alfhough nof necessarily in fhe same 
order), mefhod name, number of 1)^0 paramefers, and number of paramefers. 

• Corresponding paramefers in fhe declarafions musf have fhe same modifiers (alfhough 
nof necessarily in fhe same order) and fhe same fypes (modulo differences in f 5 ^e 
paramefer names). 

486 


www.it-ebooks.info 








10.2 Partial Types 


• Corresponding type parameters in the declarations must have the same constraints 
(modulo differences in t 5 ^e parameter names). 

An implementing partial method declaration can appear in the same part as the corre¬ 
sponding defining partial method declaration. 

Only a defining partial method participates in overload resolution. Thus, whether or not 
an implementing declaration is given, invocation expressions may resolve to invocations 
of fhe partial method. Because a partial method always returns void, such invocation 
expressions will always be expression statements. Furthermore, because a partial method 
is implicitly private, such statements will always occur within one of the parts of the t 5 ^e 
declaration within which the partial method is declared. 

If no part of a parfial f 5 ^e declarafion confains an implementing declaration for a given 
partial method, any expression statement invoking it is simply removed from the com¬ 
bined type declaration. Thus the invocation expression, including any constituent expres¬ 
sions, has no effect at runtime. The partial method itself is also removed and will not be a 
member of the combined t 5 ^e declaration. 

If an implementing declaration exists for a given partial method, the invocations of the 
partial methods are retained. The partial method gives rise to a method declaration similar 
to the implementing partial method declaration except for the following: 

• The partial modifier is not included. 

• The attributes in the resulting method declaration are the combined attributes of the 
defining and fhe implementing parfial mefhod declaration in unspecified order. Dupli¬ 
cates are not removed. 

• The attributes on the parameters of the resulting method declaration are the combined 
attributes of the corresponding parameters of the defining and the implementing partial 
method declaration in unspecified order. Duplicates are not removed. 

If a defining declaration but not an implementing declaration is given for a partial method 
M, the following restrictions apply: 

• It is a compile-time error to create a delegate to method (§7.6.10.5). 

• It is a compile-time error to refer to M inside an anonymous function that is converted to 
an expression tree t 5 ^e (§6.5.2). 

• Expressions occurring as part of an invocation of M do not affect the definite assignment 
state (§5.3), which can potentially lead to compile-time errors. 

• M carmot be the entry point for an application (§3.1). 


487 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


Partial methods are useful for allowing one parf of a type declaration to customize the 
behavior of anofher parf—for example, one fhaf is generafed by a fool. Consider fhe fol¬ 
lowing partial class declaration: 

partial class Customer 
{ 

string name; 
public string Name { 

get { return name; } 
set { 

OnNameChanging(value); 
name = value; 

OnNameChangedO; 

} 

} 

partial void OnNameChanging(string newName); 
partial void OnNameChangedO; 

} 

If fhis class is compiled wifhouf any ofher parfs, fhe defining parfial mefhod declarafions 
and fheir invocafions will be removed, and fhe resulfing combined class declaration will 
be equivalenf fo fhe following: 

class Customer 
{ 

string name; 
public string Name { 

get { return name; } 
set { name = value; } 

} 

} 

Assume fhaf anofher parf is given, however, which provides implementing declarations of 
fhe parfial mefhods: 

partial class Customer 
{ 

partial void OnNameChanging(string newName) 

{ 

Console.WriteLineC'Changing " + name + " to " + newName); 

} 

partial void OnNameChangedO 
{ 

Console.WriteLineC'Changed to " + name); 

} 

} 

Then fhe resulfing combined class declaration will be equivalenf fo fhe following: 

488 


www.it-ebooks.info 




10.2 Partial Types 


class Customer 

{ 

string name; 
public string Name { 

get { return name; } 
set { 

OnNameChanging(value); 
name = value; 
OnNameChangedO; 


} 

void OnNameChanging(string newName) 

{ 

Console.WriteLineC'Changing " + name + " to " + newName); 

} 

void OnNameChangedO 

{ 

Console.WriteLineC'Changed to " + name); 

} 

} 


"■ CHRIS SELLS Before the introduction of partial methods, the pattern was to use 
virtual methods like so: 

class Base { 

public void Foo() { HelpWithFoo(); ... } 

// Dynamically bound 
protected virtual void HelpWithFoo() {} 

// Do nothing in the base 

} 

class Derived : Base { 

protected override void FlelpWithFoo() { ... } 

} 

This approach required machine-generated code to use less efficient dynamically 
bound virtual methods to "call over" to the other part of the partial class, even though 
the implementation was available at compile time. With partial methods, the pattern 
becomes the more efficient: 

partial class MyClass { // Machine generated 

public void Foo() { HelpWithFoo(); ... } 

// Statically bound 
partial void HelpWithFoo(); 

// Declare the partial method 

} 

partial class MyClass { // Human generated 

partial void HelpWithFoo() { ... } 

// Implement the partial method 

} 


489 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


“■ ERIC LIPPERT Chris's point is well taken. I would add that there are more costs 
to consider than the extra couple of nanoseconds required to perform fhe virfual call. 
Suppose you have a machine-generafed class wifh pofenfially hundreds of poinfs of 
exfensibilify, where fhe machine-generafed code wanfs fo call a helper mefhod defined 
in the user-generated side. If fhe aufhor of fhe user-generafed side wanfs fo implemenf 
only one of fhose hundreds, all fhe code for fhe call sifes and all fhe mefadafa for fhe 
mefhods are sfill generated. Partial methods are truly "pay for play": You fake on fhe 
additional code size only for fhe exfensibilify poinfs you acfually use. 


10.2.8 Name Binding 

Alfhough each parf of an exfensible f 5 q>e musf be declared wifhin fhe same namespace, fhe 
parfs are f 5 q)ically wriffen wifhin differenf namespace declarafions. Thus differenf using 
directives (§9.4) may be presenf for each parf. When inferprefing simple names (§7.5.2) 
wifhin one parf, only fhe using direcfives of fhe namespace declarafion(s) enclosing fhaf 
parf are considered. This may resulf in fhe same idenfifier having differenf meanings in 
differenf parfs: 

namespace N 
{ 

using List = System.Collections.ArrayList; 

partial class A 
{ 

List x; // X has type System.Collections.ArrayList 

} 

} 

namespace N 
{ 

using List = Widgets.LinkedList; 

partial class A 
{ 

List y; // y has type Widgets.LinkedList 

} 

} 


10.3 Class Members 

The members of a class consisf of fhe members infroduced by ifs class-member-declarations 
and fhe members inherifed from fhe direcf base class. 

class-member-declarations: 

class-member-declaration 

class-member-declarations class-member-declaration 


490 


www.it-ebooks.info 






10.3 Class Members 


class-member-dedaration: 

constant-dedaration 

fidd-dedaration 

method-dedaration 

property-dedaration 

event-dedaration 

indexer-dedaration 

operator-dedaration 

construdor-dedaration 

destrudor-dedamtion 

static-construdor-dedaration 

type-dedaration 

The members of a class type are divided into the following categories: 

• Constants, which represent constant values associated with the class (§10.4). 

• Fields, which are the variables of the class (§10.5). 

• Methods, which implement the computations and actions that can be performed by the 
class (§10.6). 

• Properties, which define named characteristics and the actions associated with reading 
and writing those characteristics (§10.7). 

• Events, which define notifications that can be generated by the class (§10.8). 

• Indexers, which permit instances of the class to be indexed in the same way (syntacti¬ 
cally) as arrays (§10.9). 

• Operators, which define the expression operators that can be applied to instances of the 
class (§10.10). 

• Instance constructors, which implement the actions required to initialize instances of the 
class (§10.11). 

• Destructors, which implement the actions to be performed before instances of the class 
are permanently discarded (§10.13). 

• Static constructors, which implement the actions required to initialize the class itself 

(§ 10 . 12 ). 

• Types, which represent the tjq^es that are local to the class (§10.3.8). 

Members that can contain executable code are collectively known as the fundion members 

of the class type. The function members of a class type are the methods, properties, 

events, indexers, operators, instance constructors, destructors, and static constructors of 

that class type. 


491 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


A class-declaration creates a new declaration space (§3.3), and the class-member-declarations 
immediately contained by the class-declaration introduce new members into this declara¬ 
tion space. The following rules apply to class-member-declarations: 

• Instance constructors, destructors, and static constructors must have the same name as 
the immediately enclosing class. All other members must have names that differ from 
fhe name of the immediately enclosing class. 

• The names of constanfs, fields, properties, events, or types must differ from fhe names 
of all other members declared in the same class. 

• The name of a method must differ from the names of all other nonmethods declared in 
the same class. In addition, the signature (§3.6) of a method must differ from the signa¬ 
tures of all other methods declared in the same class, and two methods declared in the 
same class may not have signatures that differ solely by ref and out. 

• The signature of an instance constructor must differ from the signatures of all other 
instance constructors declared in the same class, and two constructors declared in the 
same class may not have signatures that differ solely by ref and out. 

• The signature of an indexer musf differ from fhe signatures of all ofher indexers declared 
in the same class. 

• The signature of an operator must differ from the signatures of all other operators 
declared in the same class. 

The inherited members of a class 1)^0 (§10.3.3) are not part of the declaration space of a 
class. Thus a derived class is allowed to declare a member with the same name or signature 
as an inherited member (which, in effect, hides the inherited member). 

10.3.1 The Instance Type 

Each class declaration has an associated bound t 5 ^e (§4.4.3), known as the instance type. 
For a generic class declaration, the instance type is formed by creating a constructed t 5 ^e 
(§4.4) from the t 5 ^e declaration, with each of the supplied type arguments being the cor¬ 
responding type parameter. Since the instance type uses the type parameters, it can be 
used only where the type parameters are in scope—that is, inside the class declaration. The 
instance t 5 ^e is the t 5 ^e of this for code written inside the class declaration. For non¬ 
generic classes, the instance t 5 ^e is simply the declared class. The following shows several 
class declarations along with their instance types: 


class A<T> 

{ 

class B {} 

// 

Instance 

type: 

A<T> 

// 

Instance 

type: 

A<T>.B 

class C<U> {} 

} 

// 

Instance 

type: 

A<T>.C<U> 

class D {} 

// 

Instance 

type: 

D 


492 


www.it-ebooks.info 




10.3 Class Members 


10.3.2 Members of Constructed Types 

The non-inherited members of a constructed type are obtained by substituting, for each 
type-parameter in the member declaration, the corresponding type-argument of the con¬ 
structed t 5 ^e. The substitution process is based on the semantic meaning of t 5 ^e declara¬ 
tions, and is not simply textual substitution. 

For example, given the generic class declaration 

class Gen<T,U> 

{ 

public T[,] a; 

public void G(int i, T t, Gen<U,T> gt) {...} 
public U Prop { get {...} set {...} } 
public int H(double d) {...} 

} 

the constructed t 5 ^e Gen<int[ ], IComparable<string>> has the following members: 
public int[,][] a; 

public void G(int i, int[] t, Gen<IComparable<string>,int[]> gt) {...} 
public IComparable<string> Prop { get {...} set {...} } 
public int H(double d) {...} 

The type of the member a in the generic class declaration Gen is "two-dimensional array of 
T," so the type of the member a in the constructed t 5 ^e above is "two-dimensional array 
of one-dimensional array of int," or int [, ] [ ]. 

Within instance function members, the type of this is the instance type (§10.3.1) of the 
containing declaration. 


■■ JONSKEET This treatment of generics via substitution leads to obvious tricky I 
situations. What would the following code do? 

public class Puzzle<T> { 

public void Method(int i) {} 
public void Method(T t) {} 

} 

new Puzzle<int>().Method(10); 

The "substitution" results in two methods with exactly the same signature—so which 
one is called by the Method(10) expression? 1 readily admit that 1 wouldn't know the 
answer without looking it up or trying it. 1 strongly suggest that such ambiguity should 
be avoided wherever possible. In my experience, it's most likely to occur with a pair of 
indexers that can look an item up either by position (an int) or key (a type parameter). 

493 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


■■ ERICLIPPERT In an early design of generics in C# 2.0, the language designers 
considered making it illegal to even declare a class that could possibly be constructed so 
as to produce a signature ambiguity like the one Jon describes. Unfortunately, that 
restriction then makes illegal certain patterns that seem obviously desirable: 

class C<T> { public C(T t) { ... } public C(Stream serializedState) { ... } } 

Should it be illegal to declare C<T> just because someone might someday make a 
C<Stream>? This seems like overkill. 

Even so, it is an extremely poor programming practice to create t 5 ^es that can have 
ambiguous signatures under construction and then actually make such construc¬ 
tions. Doing so can, in some contrived cases, expose implementation-defined behav¬ 
ior in the CLR. 


All members of a generic class can use type parameters from any enclosing class, either 
directly or as part of a constructed type. When a particular closed constructed type (§4.4.2) 
is used at runtime, each use of a type parameter is replaced with the actual t 5 ^e argument 
supplied to the constructed type. For example: 

class C<V> 

{ 

public V fl; 

public C<V> f2 = null; 

public C(V x) { 
this.fl = x; 
this.f2 = this; 

} 

} 

class Application 
{ 

static void Main() { 

C<lnt> xl = new C<int>(l); 

Console.WriteLine(xl.fl); // Prints 1 

C<double> x2 = new C<double>(3.1415); 

Console.WriteLine(x2.fl); // Prints 3.1415 

} 

} 

10.3.3 Inheritance 

A class inherits the members of its direct base class t 5 ^e. Inheritance means that a class 
implicitly contains all members of its direct base class type, except for the instance con¬ 
structors, destructors, and static constructors of the base class. Some important aspects of 
inheritance are profiled here: 


494 


www.it-ebooks.info 






10.3 Class Members 


• Inheritance is transitive. If C is derived from B, and B is derived from A, fhen C inherifs 
fhe members declared in B as well as fhe members declared in A. 

• A derived class extends ifs direcf base class. A derived class can add new members fo 
fhose if inherifs, buf if carmof remove fhe definifion of an inherifed member. 

• Insfance consfrucfors, destrucfors, and sfatic consfrucfors are nof inherifed, buf all ofher 
members are, regardless of fheir declared accessibilify (§3.5). However, depending on fheir 
declared accessibilify, inherifed members mighf nof be accessible in a derived class. 


"■ JON SKEET Occasionally, developers ask why insfance consfrucfors aren'f inher¬ 
ifed. My view is fhaf only fhe parficular class knows which informafion if needs fo 
creafe a valid insfance. For example, if insfance consfrucfors were inherifed, all classes 
would have fo have a parameferless consfrucfor (because object does). Whaf would 
if mean fo creafe a new FileStream wifhouf specifying a filename or handle? 


• A derived class can hide (§3.7.1.2) inherifed members by declaring new members wifh 
fhe same name or signature. Note, however, that hiding an inherited member does not 
remove that member—it merely makes that member inaccessible directly through the 
derived class. 

• An instance of a class confains a sef of all insfance fields declared in fhe class and ifs base 
classes, and an implicif conversion (§6.1.6) exisfs from a derived class type to any of ifs 
base class f 5 ^es. Thus a reference fo an insfance of some derived class can be treafed as 
a reference fo an insfance of any of ifs base classes. 

• A class can declare virfual mefhods, properfies, and indexers, and derived classes can 
override fhe implemenfafion of fhese function members. This enables classes fo exhibif 
polymorphic behavior wherein fhe actions performed by a fimcfion member invocation 
varies depending on fhe runtime fype of fhe insfance fhrough which fhaf fimcfion mem¬ 
ber is invoked. 

The inherifed members of a consfrucfed class fj^e are fhe members of fhe immediafe base 
class fype (§10.1.4.1), which is found by subsfifufing fhe fype argumenfs of fhe consfrucfed 
fype for each occurrence of fhe corresponding fype paramefers in fhe base-class-specification. 
These members, in furn, are fransformed by subsfifufing, for each type-parameter in fhe 
member declaration, fhe corresponding type-argument of fhe base-class-specification. 

class B<u> 

{ 

public U F(long index) {...} 

} 

class D<T>: B<T[]> 

{ 

public T G(string s) {...} 

} 


495 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


In the above example, the constructed type D<int> has a non-inherited member public int 
G(string s) obtained by substituting the type argument int for the type parameter T. 
D<int> also has an inherited member from the class declaration B. This inherited member 
is determined by first determining the base class t 5 ^e B<int[ ] > of D<int> by substituting 
int for T in the base class specification B<T [ ] >. Then, as a type argument to B, int [ ] is sub¬ 
stituted for U in public U Fflong index), yielding the inherited member public int[] 
Fflong index). 

10.3.4 The new Modifier 

A class-member-declaration is permitted to declare a member with the same name or signa¬ 
ture as an inherited member. When this occurs, the derived class member is said to hide the 
base class member. Hiding an inherited member is not considered an error, but it does 
cause the compiler to issue a warning. To suppress the warning, the declaration of the 
derived class member can include a new modifier to indicate that the derived member is 
intended to hide the base member. This topic is discussed further in §3.7.1.2. 

If a new modifier is included in a declaration that doesn't hide an inherited member, a 
warning to that effect is issued. This warning is suppressed by removing the new 
modifier. 

10.3.5 Access Modifiers 

A class-member-declaration can have any one of fhe five possible kinds of declared accessibil¬ 
ity (§3.5.1): public, protected internal, protected, internal, or private. Except for the 
protected internal combination, it is a compile-time error to specify more than one access 
modifier. When a class-member-declaration does not include any access modifiers, private is 
assumed. 

10.3.6 Constituent Types 

Types that are used in the declaration of a member are called the constituent t 5 ^es of fhat 
member. Possible consfituent fypes are fhe f 5 ^e of a consfanf, field, property, event, or 
indexer; the return t 5 ^e of a method or operator; and the parameter types of a method, 
indexer, operator, or instance constructor. The constituent t 5 ^es of a member must be at 
least as accessible as that member itself (§3.5.4). 

10.3.7 Static and Instance Members 

Members of a class are eifher static members or instance members. Generally speaking, if 
is useful to think of sfatic members as belonging fo class t 5 ^es and insfance members as 
belonging to objects (instances of class types). 


496 


www.it-ebooks.info 




10.3 Class Members 


When a field, method, property, event, operator, or constructor declaration includes a 
static modifier, it declares a static member. In addition, a constant or type declaration 
implicitly declares a static member. Static members have the following characteristics: 

• When a static member M is referenced in a member-access (§7.6.4) of the form E . M, E must 
denote a t 5 ^e containing M. It is a compile-time error for E to denote an instance. 

• A static field identifies exactly one storage location to be shared by all instances of a 
given closed class type. No matter how many instances of a given closed class type are 
created, there is only ever one copy of a static field. 

• A static function member (method, property, event, operator, or constructor) does not 
operate on a specific instance, and it is a compile-time error to refer to this in such a 
function member. 

When a field, method, property, event, indexer, constructor, or destructor declaration does 
not include a static modifier, it declares an instance member. (An instance member is 
sometimes called a nonstatic member.) Instance members have the following 
characteristics: 

• When an instance member M is referenced in a member-access (§7.6.4) of the form E. M, E 
must denote an instance of a type containing M. It is a binding-time error for E to denote 
a type. 

• Every instance of a class contains a separate set of all instance fields of the class. 

• An instance function member (method, property, indexer, instance constructor, or 
destructor) operates on a given instance of the class, and this instance can be accessed as 
this (§7.6.7). 

The following example illustrates the rules for accessing static and instance members: 


class Test 


{ 


int x; 

static int y; 


void F() { 


X = l; 

y = i; 


// Okay: same as this.x = 1 
// Okay: same as Test.y = 1 


} 


static void G() { 


X = l; 

y = i; 


// Error: cannot access this.x 
// Okay: same as Test.y = 1 


} 


497 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


static void Main() { 


Test t = 

new Test(); 


t.x = 1; 


// 

t.y = l; 


// 



// 

Test.x = 

1; 

// 



// 

Test.y = 

i; 

// 


Okay 

Error: cannot access static 

member through instance 

Error: cannot access instance member 

through type 

Okay 


The F method shows that in an instance function member, a simple-name (§7.6.2) can be 
used to access both instance members and static members. The G method shows that in a 
static function member, it is a compile-time error to access an instance member through a 
simple-name. The Main method shows that in a member-access (§7.6.4), instance members 
must be accessed through instances, and static members must be accessed through types. 

10.3.8 Nested Types 

A t 5 ^e declared within a class or struct declaration is called a nested type. A type that is 
declared within a compilation unit or namespace is called a non-nested type. 


■■ JONSKEET I've heard the phrase "top-level type" used more often than "non¬ 
nested t 5 ^e"—and I've no doubt spread this nonstandard terminology myself. Con¬ 
sidering fhaf fhe vasf majorify of fypes are non-nesfed, if feels like fhe descripfive ferm 
should be somefhing posifive, rafher fhan jusf an absence of nesting. Thaf's my excuse, 
an 5 rway, and ofhers are welcome fo borrow if. 


In fhe example 

using System; 

class A 
{ 

class B 
{ 

static void F() { 

Console.WriteLine("A.B.F"); 

} 

} 

} 

class B is a nesfed type because it is declared within class A, and class A is a non-nested type 
because it is declared within a compilation unit. 


498 


www.it-ebooks.info 






10.3 Class Members 


■■ BRAD ABRAMS I am not a big fan of publicly accessible nesfed fypes in a 
reusable library Discoverabilify for nesfed f 5 ^es isn'f greaf. Even more imporfanfly, 
we already have a group mechanism—namespaces—fhaf should be used fo indicafe 
relafed fypes. 


10.3.8.1 Fully Qualified Names 

The fully qualified name (§3.8.1) for a nesfed 15^*6 is S. N, where S is fhe fully qualified 
name of fhe t 5 T’e in which f 5 q)e N is declared. 

10.3.8.2 Declared Accessibility 

Non-nesfed fypes can have public or internal declared accessibilify and have internal 
declared accessibilify by defaulf. Nesfed fypes can have fhese forms of declared accessibil¬ 
ify as well, plus one or more addifional forms of declared accessibilify, depending on 
whefher fhe containing type is a class or struct: 

• A nested t 5 q)e that is declared in a class can have any of five forms of declared accessibil¬ 
ify (public, protected internal, protected, internal, or private) and, like ofher class 
members, defaulfs fo private declared accessibilify. 

• A nesfed f 5 T>e fhaf is declared in a sfrucf can have any of fhree forms of declared acces¬ 
sibilify (public, internal, or private) and, like ofher sfrucf members, defaulfs fo 
private declared accessibilify. 

The example 

public class List 
{ 

// Private data structure 
private class Node 
{ 

public object Data; 
public Node Next; 

public Node(object data. Node next) { 
this.Data = data; 
this.Next = next; 

} 

} 

private Node first = null; 
private Node last = null; 

// Public interface 

public void AddToFront(object o) {...} 


499 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


public void AddToBack(object o) {...} 
public object RemoveFrorrFront() {...} 
public object RemoveFromBack() {...} 
public int Count { get {...} } 

} 

declares a private nested class Node. 

10.3.8.3 Hiding 

A nested tj^e may hide (§3.7.1) a base member. The new modifier is permitted on nested 
type declarations so that hiding can be expressed explicitly. The example 

class Base 
{ 

public static void M() { 

Console.WriteLine("Base.M"); 

} 

} 

class Derived: Base 
{ 

new public class M 
{ 

public static void F() { 

Console.WriteLine("Derived.M. F"); 

} 

} 

} 

class Test 
{ 

static void Main() { 

Derived.M.F(); 

} 

} 

shows a nested class M that hides the method M defined in Base. 


10.3.8.4 this Access 

A nesfed type and its containing type do not have a special relationship with regard to 
this-access (§7.6.7). Specifically, this wifhin a nesfed type cannot be used to refer 
fo insfance members of fhe confaining type. In cases where a nested type needs access to 
the instance members of ifs confaining fype, access can be provided by providing fhe 


500 


www.it-ebooks.info 




10.3 Class Members 


this for the instance of the containing type as a constructor argument for the nested 
type. The following example 

using System; 

class C 
{ 

int i = 123; 

public void F() { 

Nested n = new Nested(this); 
n.G(); 

} 

public class Nested 
{ 

C this_c; 

public Nested(C c) { 
this_c = c; 

} 

public void G() { 

Console.WriteLine(this_c.i); 

} 

} 

} 

class Test 
{ 

static void Main() { 

C c = new C(); 
c.F(); 

} 

} 

shows this technique. An instance of C creates an instance of Nested and passes its own 
this to Nested's constructor to provide subsequent access to C's instance members. 


■■ JON SKEET This section of the specification may seem strange at first sight: 
Why bother to specify what you can't do? Why would anyone expect to be able to 
get at an instance of the containing t 5 qie from an instance of a nested type? Well, in 
Java, that's exactly how inner classes do work. To achieve C#-like nested type behav¬ 
ior, you need to declare the nested type as static—which is nothing like a static 
class in C#! 


501 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


10.3.8.5 Access to Private and Protected Members of the Containing Type 

A nested type has access to all of the members that are accessible to its containing type, 
including members of fhe confaining f 5 ^e fhaf have private and protected declared 
accessibilify. The example 

using System; 

class C 
{ 

private static void F() { 

Console.WriteLine("C.F"); 

} 

public class Nested 
{ 

public static void G() { 

F(); 

} 

} 

} 

class Test 
{ 

static void Main() { 

C.Nested.G(); 

} 

} 

shows a class C fhaf confains a nesfed class Nested. Wifhin Nested, fhe mefhod G calls fhe 
static mefhod F defined in C, and F has private declared accessibilify. 


"■ JON SKEET Again, fhis behavior is differenf from fhaf in Java, where an oufer 
fype has access fo fhe private members of a nesfed t 5 ^e, buf nof vice versa. I find fhe 
C# approach fo be more sensible. If also allows for some nice pafferns, such as creafing 
an absfracf class wifh a private consfrucfor: All fhe derived classes have fo be nesfed 
within the abstract class. Oddly enough, I find fhe main use case for fhis behavior is 
emulating Java enums. 


A nesfed type also may access protected members defined in a base type of ifs confaining 
fype. In fhe example 

using System; 

class Base 
{ 

protected void F() { 

Console.WriteLine("Base.F"); 

} 

} 


502 


www.it-ebooks.info 






10.3 Class Members 


class Derived: Base 
{ 

public class Nested 
{ 

public void G() { 

Derived d = new Derived(); 
d.F(); // Okay 

} 

} 

} 

class Test 
{ 

static void Main() { 

Derived.Nested n = new Derived.Nested(); 
n.G(); 

} 

} 

the nested class Derived.Nested accesses the protected method F defined in Derived's 
base class. Base, by calling through an instance of Derived. 

10.3.8.6 Nested Types in Generic Classes 

A generic class declarafion can confain nesfed fype declarafions. The fype paramefers of 
fhe enclosing class can be used wifhin fhe nesfed f 5 ^es. A nesfed f 5 ^e declarafion can con- 
fain addifional fype paramefers fhaf apply only fo fhe nesfed fype. 

Every fype declarafion confained wifhin a generic class declarafion is implicifly a generic 
fype declarafion. When wrifing a reference fo a fype nesfed wifhin a generic fype, fhe con- 
faining consfrucfed fype, including ifs f 5 ^e argumenfs, musf be named. However, from 
wifhin fhe oufer class, fhe nesfed fype can be used wifhouf qualificafion; fhe insfance fype 
of fhe oufer class can be implicifly used when consfrucfing fhe nesfed f 5 q>e. The following 
example shows fhree differenf—and correcf—ways fo refer fo a consfrucfed f 5 q>e creafed 
from Inner; fhe firsf two are equivalenf: 

class Outer<T> 

{ 

class Inner<U> 

{ 

public static void F(T t, U u) {...} 

} 

static void F(T t) { 

0uter<T>.Inner<string>.F(t, "abc"); 

Inner<string>.F(t, "abc"); 

0uter<int>.Inner<string>.F(3, "abc"); 

Outer.Inner<String>.F(t, "abc"); 

} 

} 


// These two statements 
// have the same effect 

// This type is different 

// Error: Outer needs type arg 


503 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


Although it is bad programming style, a 1)^6 parameter in a nested type can hide a mem¬ 
ber or type parameter declared in the outer t 5 ^e: 

class Outen<T> 

{ 

class Inner<T> 

{ 

public T t; 

} 

} 

10.3.9 Reserved Member Names 

To facilitate the underlying C# runtime implementation, for each source member declara¬ 
tion that is a property, event, or indexer, the implementation must reserve two method 
signatures based on the kind of the member declaration, its name, and its type. It is a 
compile-time error for a program to declare a member whose signature matches one of 
these reserved signatures, even if the underlying runtime implementation does not make 
use of fhese reservafions. 

The reserved names do not introduce declarations; thus they do not participate in member 
lookup. However, a declaration's associated reserved method signatures do participate in 
inheritance (§10.3.3) and can be hidden with the new modifier (§10.3.4). 

The reservation of these names serves three purposes: 

• It allows the underlying implementation to use an ordinary identifier as a method name 
for get or set access to the C# language feature. 

• It allows other languages to interoperate use of an ordinary identifier as a mefhod name 
for get or set access to the C# language feature. 

• It helps ensure that the source accepted by one conforming compiler is accepted by 
another, by making the specifics of reserved member names consistent across all C# 
implementations. 

The declaration of a destructor (§10.13) also causes a signature to be reserved (§10.3.9.4). 

10.3.9.1 Member Names Reserved for Properties 

For a property P (§10.7) of type T, the following signafures are reserved: 

T get_P(); 

void set_P(T value); 

Bofh signatures are reserved, even if fhe property is read-only or write-only. 


// Valid: hides Outer's T 
// Refers to Inner's T 


504 


www.it-ebooks.info 




10.3 Class Members 


“■ BILL WAGNER Even though you could write methods that are named 
get_<something> and set_<something>, if <something> is not a property name, this 
technique is not recommended. Avoiding it will minimize the need to update the code 
in the future. 


In the example 

using System; 

class A 

{ 

public int P { 

get { return 123; } 

} 

} 

class B: A 

{ 

new public int get_P() { 
return 456; 

} 

new public void set_P(int value) { 

} 

} 

class Test 

{ 

static void Main() { 

B b = new B(); 

A a = b; 

Console.WriteLine(a.P); 

Console.WriteLine(b.P); 

Console.WriteLine(b.get_P()); 

} 

} 

a class A defines a read-only properly P, fhus reserving signafures for get_P and set_P 
mefhods. The class B derives from A and hides bofh of fhese reserved signafures. The exam¬ 
ple produces fhe following oufpuf: 

123 

123 

456 


505 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


10.3.9.2 Member Names Reserved for Events 

For an event E (§10.8) of delegate t 5 ^e T, the following signatures are reserved: 

void add_E(T handler); 
void remove_E(T handler); 


10.3.9.3 Member Names Reserved for Indexers 

For an indexer (§10.9) of type T with parameter-list L, the following signatures are 
reserved: 

T get_Item(L); 

void set_Item(L, T value); 

Both signatures are reserved, even if the indexer is read-only or write-only. Furthermore, 
the member name Item is reserved. 

10.3.9.4 Member Names Reserved for Destructors 

For a class containing a destructor (§10.13), the following signature is reserved: 
void FinalizeO; 

I 10.4 Constants 

A constant is a class member that represents a constant value—a value that can be 
computed at compile time. A constant-declaration introduces one or more constants of a 
given type. 

constant-declaration: 

attributes^^i constant-modifiers const type constant-declarators ; 

constant-modifiers: 

constant-modifier 

constant-modifiers constant-modifier 

constant-modifier: 

new 

public 

protected 

internal 

private 

constant-declarators: 

constant-declarator 

constant-declarators , constant-declarator 

506 


www.it-ebooks.info 




10.4 Constants 


constant-declarator: 

identifier - constant-expression 

A constant-declaration may include a set of attributes (§17), a new modifier (§10.3.4), and a 
valid combination of the four access modifiers (§10.3.5). The attributes and modifiers apply 
to all of the members declared by the constant-declaration. Even though constants are con¬ 
sidered static members, a constant-declaration neither requires nor allows a static modifier. 
It is an error for the same modifier to appear multiple times in a constant declaration. 

The type of a constant-declaration specifies the t 5 q)e of the members introduced by the dec¬ 
laration. The t 5 q)e is followed by a list of constant-declarators, each of which introduces a 
new member. A constant-declarator consists of an identifier that names the member, followed 
by an token, followed by a constant-expression (§7.19) that gives the value of the 
member. 

The type specified in a constant declaration must be either sbyte, byte, short, ushort, int, 
uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference- 
type. Each constant-expression must yield a value of the target type or of a type that can be 
converted to the target type by an implicit conversion (§6.1). 


■■ JONSKEET The inclusion of decimal here is interesting when targeting the Com¬ 
mon Language Infrastructure. All of the other t 5 q)es have literal representations within 
the CLI, whereas decimal doesn't. The Microsoft C# compiler achieves the appropri¬ 
ate behavior by creating a static read-only field declaration, albeit decorated with 
DecimalConstantAttribute. A similar attribute exists for DateTime, but C# doesn't 
allow DateTime constants. 


The type of a constant must be at least as accessible as the constant itself (§3.5.4). 

The value of a constant is obtained in an expression using a simple-name (§7.6.2) or a 
member-access (§7.6.4). 

A constant can itself participate in a constant-expression. Thus a constant may be used in any 
construct that requires a constant-expression. Examples of such constructs include case 
labels, goto case statements, enum member declarations, attributes, and other constant 
declarations. 

As described in §7.19, a constant-expression is an expression that can be fully evaluated at 
compile time. Since the only way to create a non-null value of a reference-type other than 
string is to apply the new operator, and since the new operator is not permitted in a 
constant-expression, the only possible value for constants of reference-types other than 
string is null. 


507 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


When a symbolic name for a constant value is desired, but when the type of that value is 
not permitted in a constant declaration, or when the value carmot be computed at compile 
time by a constant-expression, a readonly field (§10.5.2) may be used instead. 


A constant declaration that declares multiple constants is equivalent to multiple declara¬ 
tions of single constants with the same attributes, modifiers, and type. For example. 


class A 
{ 

public const double X = 1.0, Y = 2.0, Z = 3.0; 

} 


is equivalent to 

class A 
{ 

public const double X = 1.0; 
public const double Y = 2.0; 
public const double Z = 3.0; 

} 


"■ CH RIS SELLS From a readability point of view, I find multiple declarations on 
the same line—whether constants or nonconstants, static or instance, fields or local 
variables—to be difficult to decipher. I prefer to place only a single declaration on each 
line, ideally keeping the locality of reference in mind. 


Constants are permitted to depend on other constants within the same program as long as 
the dependencies are not of a circular nature. The compiler automatically arranges to eval¬ 
uate the constant declarations in the appropriate order. In the example 

class A 
{ 

public const int X = B.Z + 1; 

public const int Y = 10; 

} 

class B 
{ 

public const int Z = A.Y + 1; 

} 

the compiler first evaluates A. Y, then evaluates B. Z, and finally evaluates A. X, producing 
the values 10, 11, and 12, in that order. Constant declarations may depend on constants 
from other programs, but such dependencies are only possible in one direction. Referring 
to the example above, if A and B were declared in separate programs, it would be possible 
for A. X to depend on B. Z, but B. Z could then not simultaneously depend on A. Y. 


508 


www.it-ebooks.info 






10.5 Fields 


10.5 Fields 

Afield is a member that represents a variable associated with an object or class. A field- 
declaration introduces one or more fields of a given fype. 

field-declaration: 

attributes^^i field-modifiers^^ type variable-declarators ; 

field-modifiers: 

field-modifier 

field-modifiers field-modifier 

field-modifier: 

new 

public 

protected 

internal 

private 

static 

readonly 

volatile 

variable-declarators: 

variable-declarator 

variable-declarators , variable-declarator 

variable-declarator: 

identifier 

identifier - variable-initializer 

variable-initializer: 

expression 

array-initializer 

Afield-declaration may include a sef of attributes (§17), a new modifier (§10.3.4), a valid com- 
binafion of fhe four access modifiers (§10.3.5), and a static modifier (§10.5.1). In addifion, 
afield-declaration may include a readonly modifier (§10.5.2) or a volatile modifier (§10.5.3), 
buf nof bofh. The affribufes and modifiers apply fo all of fhe members declared by the field- 
declaration. If is an error for fhe same modifier fo appear mulfiple fimes in a field 
declarafion. 

The type of afield-declaration specifies fhe type of fhe members infroduced by fhe declara¬ 
fion. The t 5 ^e is followed by a lisf of variable-declarators, each of which infroduces a new 


509 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


member. A variable-declarator consists of an identifier that names that member, optionally 
followed by an token and a variable-initializer (§10.5.5) that gives the initial value of that 
member. 


The type of a field must be at least as accessible as the field itself (§3.5.4). 


The value of a field is obtained in an expression using a simple-name (§7.6.2) or a member- 
access (§7.6.4). The value of a non-read-only field is modified using an assignment (§7.17). 
The value of a non-read-only field can be both obtained and modified using postfix incre¬ 
ment and decrement operators (§7.6.9) and prefix increment and decrement operators 
(§7.7.5). 


A field declaration that declares multiple fields is equivalent to multiple declarations of 
single fields with the same attributes, modifiers, and type. For example. 


class A 
{ 

public static int X = 1, Y, Z = 100; 

} 

is equivalent to 


class A 
{ 

public static int X = 1; 
public static int Y; 
public static int Z = 100; 


} 


10.5.1 Static and Instance Fields 

When a field declaration includes a static modifier, the fields introduced by the declara¬ 
tion are static fields. When no static modifier is present, the fields introduced by the 
declaration are instance fields. Static fields and instance fields are two of the several kinds of 
variables (§5) supported by C#, and at times they are referred to as static variables and 
instance variables, respectively. 

A static field is not part of a specific instance; instead, it is shared among all instances of a 
closed type (§4.4.2). No matter how many instances of a closed class type are created, there 
is only ever one copy of a static field for the associated application domain. 

For example: 

class C<V> 

{ 

static int count = 0; 

public C() { 
count++; 

} 


510 


www.it-ebooks.info 




10.5 Fields 


public static int Count { 


get { return count; } 

} 


} 


class Application 
{ 


static void Main() { 

C<int> xl = new C<int>(); 
Console.WriteLine(C<int>.Count) 


// Prints 1 


C<double> x2 = new C<double>(); 
Console.WriteLine(C<int>.Count) 


// Prints 1 


C<int> x3 = new C<int>(); 
Console.WriteLine(C<int>.Count) 


// Prints 2 


} 

} 


An instance field belongs to an instance. Specifically, every instance of a class contains a 
separate set of all the instance fields of that class. 

When a field is referenced in a member-access (§7.6.4) of the form E . M, if M is a static field, E 
must denote a type containing M; if M is an instance field, E must denote an instance of a 
type containing M. 

The differences between static and instance members are discussed further in §10.3.7. 

10.5.2 Read-only Fields 

When a field-declaration includes a readonly modifier, the fields introduced by the declara¬ 
tion are read-only fields. Direct assignments to readonly fields can occur only as part of 
that declaration or in an instance constructor or static constructor in the same class. (A 
readonly field can be assigned to multiple times in these contexts.) Specifically, direct 
assignments to a readonly field are permitted only in the following contexts: 

• In the variable-declarator that introduces the field (by including a variable-initializer in the 
declaration). 

• For an instance field, in the instance constructors of the class that contains the field 
declaration; for a static field, in the static constructor of the class that contains the 
field declaration. These are also the only contexts in which it is valid to pass a readonly 
field as an out or ref parameter. 

Attempting to assign to a readonly field or pass it as an out or ref parameter in any other 
context is a compile-time error. 


511 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


“■ VLADIMIR RESHETNIKOV Only instance readonly fields of fhe this objecf 
can be assigned in insfance consfrucfors, buf nof fields of any ofher objecfs of fhe 
same f 5 ^e: 

class A 

{ 

readonly int x; 


} 


A(A a) 

{ 

this.x = 1; 
a.x = 1; 

} 


// Okay 

// Error CS0191: A read-only field 
// cannot be assigned to 


Also, a readonly field cannof be assigned fo (or passed as a ref or out paramefer) in 
an anonymous funcfion, even if fhe funcfion is locafed wifhin a consfrucfor. 


10.5.2.1 Using Static Read-only Fields for Constants 

A static readonly field is useful when a symbolic name for a consfanf value is desired, buf 
when fhe type of fhe value is nof permiffed in a const declarafion, or when fhe value can¬ 
nof be compufed af compile time. In fhe example 


public class Color 

{ 

public static readonly Color Black = new Color(0, 0, 0); 

public static readonly Color White = new Color(255, 255, 255); 

public static readonly Color Red = new Color(255, 0, 0); 

public static readonly Color Green = new Color(0, 255, 0); 

public static readonly Color Blue = new Color(0, 0, 255); 

private byte red, green, blue; 

public Color(byte r, byte g, byte b) { 
red = r; 
green = g; 
blue = b; 

} 

} 


fhe Black, White, Red, Green, and Blue members cannof be declared as const members 
because fheir values cannof be compufed af compile time. Declaring fhem as static 
readonly insfead has much fhe same effecf. 


10.5.2.2 Versioning of Constants and Static Read-only Fields 

Consfanfs and readonly fields have differenf binary versioning semantics. When an expres¬ 
sion references a consfanf, fhe value of fhe consfanf is obfained af compile time, buf when 


512 


www.it-ebooks.info 






10.5 Fields 


an expression references a readonly field, the value of the field is not obtained until run¬ 
time. Consider an application that consists of two separate programs: 

using System; 

namespace Programl 

{ 

public class Utils 
{ 

public static readonly int X = 1; 

} 

} 

namespace Program2 

{ 

class Test 
{ 

static void Main() { 

Console.WriteLine(Programl.Utils.X); 

} 

} 

} 

The Programl and Program2 namespaces denote two programs that are compiled sepa¬ 
rately. Because Programl. Utils .X is declared as a static readonly field, the value output 
by the Console.WriteLine statement is not known at compile time, but rather is obtained 
at runtime. Thus, if the value of X is changed and Programl is recompiled, the Console. 
WriteLine statement will output the new value even if Program2 isn't recompiled. How¬ 
ever, had X been a constant, the value of X would have been obtained at the time Program2 
was compiled, and would remain unaffected by changes in Programl until Program2 is 
recompiled. 


“■ BILL WAGN ER This discussion justifies why readonly should often be preferred 
to const. 


■■ JONSKEET While 1 largely agree with Bill that readonly should usually be pre¬ 
ferred, there is a benefit to const in some situations. Expressions that are built up of 
constants can be evaluated at compile time, rather than being recomputed on every 
access. For cases computing a string constant, this practice can avoid new strings being 
created each time the expression is evaluated, too. Some numbers really are natural 
constants: the number of milliseconds in a second, or the minimum value of an int, 
for example. When there is absolutely no chance that a value will ever change, const 
makes sense. When there is any doubt at all, readonly is safer. 


513 


www.it-ebooks.info 


10. Classes 








10. Classes 


10. Classes 


10.5.3 Volatile Fields 

When a field-declaration includes a volatile modifier, the fields introduced by that declara¬ 
tion are volatile fields. 

For non-volatile fields, optimization techniques that reorder instructions can lead to unex¬ 
pected and unpredictable results in multithreaded programs that access fields without 
S 5 mchronization, such as that provided by the lock-statement (§8.12). These optimizations 
can be performed by the compiler, by the runtime system, or by hardware. For volatile 
fields, such reordering optimizations are restricted: 

• Aread of a volatile field is called a volatile read. A volatile read has "acquire semantics"; 
that is, it is guaranteed to occur prior to any references to memory that occur after it in 
the instruction sequence. 

• A write of a volatile field is called a volatile write. A volatile write has "release seman¬ 
tics"; that is, it is guaranteed to happen after any memory references prior to the write 
instruction in the instruction sequence. 

These restrictions ensure that all threads will observe volatile writes performed by any 
other thread in the order in which they were performed. A conforming implementation is 
not required to provide a single total ordering of volatile writes as seen from all threads of 
execution. The type of a volatile field must be one of the following: 

• A reference-type. 

• The t 5 q)e byte, sbyte, short, ushort, int, uint, char, float, bool. System. IntPtr, or 
System.UIntPtr. 

• An enum-type having an enum base type of byte, sbyte, short, ushort, int, or uint. 

The example 

using System; 

using System.Threading; 

class Test 
{ 

public static int result; 

public static volatile bool finished; 

static void Thread2() { 
result = 143; 
finished = true; 

} 

static void Main() { 
finished = false; 

// Run Thread2() in a new thread 

new Thread(new ThreadStart(Thread2)).Start(); 

514 


www.it-ebooks.info 




10.5 Fields 


// Wait for Threacl2 to signal that it has a 
// result by setting finished to true 
for (;;) { 

if (finished) { 

Console.WriteLineC'result = {0}"j result); 
return; 

} 

} 

} 

} 

produces the following output: 
result = 143 

In this example, the method Main starts a new thread that runs the method Thread2. This 
method stores a value into a non-volatile field called result, then stores true into the 
volatile field finished. The main thread waits for the field finished to be set to true, 
then reads the field result. Since finished has been declared volatile, the main thread 
must read the value 143 from the field result. If the field finished had not been declared 
as volatile, then it would be permissible for the store to result to be visible to the 
main thread after the store to finished, and hence for the main thread to read the value 
0 from the field result. Declaring finished as a volatile field prevents any such 
inconsistency. 


■■ JOSEPH ALBAHARI Fields that are always accessed within a lock statement 
(§8.12) do not need to be declared with the volatile keyword. As a consequence, 
the runtime must ensure that any ordering optimization of fields used between 
Monitor. Enter and Monitor. Exit does not extend outside the scope of these 
statements. 


■■ jONSKEET Lock-free concurrent code is hard to get right. The precise guaran¬ 
tees of volatility are hard to reason about, making it far from obvious that code is 
truly correct when reading it. I tend to leave the details of low-level lock-free code to 
the experts, instead preferring to build on higher-level libraries written by experts. 
It's still important that the specification details the behavior for those experts' benefit, 
of course. 


10.5.4 Field Initialization 

The initial value of a field, whether it be a static field or an instance field, is the default 
value (§5.2) of the field's type. It is not possible to observe the value of a field before 

515 


www.it-ebooks.info 


10. Classes 








10. Classes 


10. Classes 


this default initialization has occurred; thus a field is never "uninifialized." The 
example 

using System; 

class Test 
{ 

static bool b; 

Int i; 

static void Main() { 

Test t = new Test(); 

Console.WriteLineC'b = {0}, i = {1}", t-i); 

} 

} 

produces fhe oufpuf 

b = Falsej i = 0 

because b and i are bofh automatically initialized fo defaulf values. 

10.5.5 Variable Initializers 

Field declarations may include variable-initializers. For sfafic fields, variable initializers cor¬ 
respond fo assignmenf sfafemenfs fhaf are execufed during class initialization. For insfance 
fields, variable initializers correspond fo assignmenf sfafemenfs fhaf are execufed when an 
insfance of fhe class is creafed. 

The example 

using System; 

class Test 
{ 

static double x = Math.Sqnt(2.0); 
int i = 100; 
string s = "Hello"; 

static void Main() { 

Test a = new Test(); 

Console.WriteLineC'x = {0}, i = {1}, s = {2}", x, a.i, a.s); 

} 

} 

produces fhe oufpuf 

X = 1.4142135623731, i = 100, s = Hello 

because an assignmenf fo x occurs when sfafic field initializers execufe, and assignmenfs 
fo i and s occur when fhe insfance field initializers execufe. 


516 


www.it-ebooks.info 




10.5 Fields 


The default value initialization described in §10.5.4 occurs for all fields, including fields 
that have variable initializers. Thus, when a class is initialized, all static fields in that class 
are first initialized to their default values, and then the static field initializers are executed 
in textual order. Likewise, when an instance of a class is created, all instance fields in that 
instance are first initialized to their default values, and then the instance field initializers 
are executed in textual order. 

It is possible for static fields with variable initializers to be observed in their default value 
state, but this is strongly discouraged as a matter of style. The example 

using System; 

class Test 
{ 

static int a = b + 1; 
static int b = a + 1; 

static void Main() { 

Console.WriteLineC'a = {0}, b = {!}", a, b); 

} 

} 

exhibits this behavior. Despite the circular definitions of a and b, the program is valid. It 
results in the output 

a = 1, b = 2 

because the static fields a and b are initialized to 0 (the default value for int) before 
their initializers are executed. When the initializer for a runs, the value of b is zero, so a 
is initialized to 1. When the initializer for b runs, the value of a is already 1, so b is initial¬ 
ized to 2. 


“■ BILL WAG N E R This case is easier to understand when static variables are declared 
in partial classes in multiple source units. Furthermore, because you don't know in 
which order the source units will be included, you carmot know which variable will 
be initialized first. 


10.5.5.1 Static Field Initialization 

The static field variable initializers of a class correspond to a sequence of assignments that 
are executed in the textual order in which they appear in the class declaration. If a static 
constructor (§10.12) exists in the class, execution of the static field initializers occurs imme¬ 
diately prior to executing that static constructor. Otherwise, the static field initializers are 


517 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


executed at an implementation-dependent time prior to the first use of a sfafic field of fhaf 
class. The example 

using System; 

class Test 
{ 

static void Main() { 

Console.WriteLine("{0} flf'h B.Y^ A-X); 

} 

public static int F(string s) { 

Console.WriteLine(s); 
return 1; 

} 

} 

class A 
{ 

public static int X = Test.F("Init A"); 

} 

class B 
{ 

public static int Y = Test.F("Init B"); 

} 

mighf produce eifher fhis oufpuf: 

Init A 
Init B 
1 1 

or fhis oufpuf: 

Init B 
Init A 
1 1 

The variation is possible because fhe execution of X's inifializer and Y's inifializer could 
occur in eifher order; fhey are consfrained only fo occur before fhe references fo fhose 
fields. However, in fhe example 

using System; 

class Test 
{ 

static void Main() { 

Console.WriteLine("{0} {!}", B.Y, A.X); 

} 

public static int F(string s) { 

Console.WriteLine(s); 


518 


www.it-ebooks.info 




10.5 Fields 


return 1; 

} 

} 

class A 
{ 

static A() {} 

public static int X = Test.F("Init A"); 

} 

class B 
{ 

static B() {} 

public static int Y = Test.F("Init B"); 

} 

the output must be 

Init B 
Init A 
1 1 

because the rules for when static constructors execute (as defined in §10.12) provide that 
B's static constructor (and hence B's static field initializers) must run before A's static con¬ 
structor and field initializers. 

10.5.5.2 Instance Field Initialization 

The instance field variable inifializers of a class correspond fo a sequence of assignmenfs 
fhat are executed immediately upon entry to any one of the instance constructors (§10.11.1) 
of thaf class. The variable inifializers are execufed in the textual order in which they appear 
in the class declaration. The class instance creation and initialization process is described 
further in §10.11. 

A variable initializer for an insfance field carmot reference the instance being created. Thus 
it is a compile-time error to reference this in a variable initializer, because if is a compile- 
fime error for a variable initializer fo reference any instance member through a simple-name. 
In the example 

class A 
{ 

int X = 1; 

int y = X + 1; // Error: reference to instance member of this 

} 

the variable initializer for y results in a compile-time error because it references a member 
of the instance being created. 


519 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


10.6 Methods 

A method is a member that implements a computation or action that can be performed by 
an object or class. Methods are declared using method-declarations: 

method-declaration: 

method-header method-body 

method-header: 

attributes , method-modifiers , partial . return-type member-name 

opt J opt ~ opt j* 

type-parameter-list( formal-parameter-list ) 
type-parameter-constraints-clauses^^^^ 

method-modifiers: 

method-modifier 

method-modifiers method-modifier 

method-modifier: 

new 

public 

protected 

internal 

private 

static 

virtual 

sealed 

override 

abstract 

extern 

return-type: 

type 

void 

member-name: 

identifier 

interface-type . identifier 

method-body: 

block 


520 


www.it-ebooks.info 




10.6 Methods 


A method-declaration may include a set of attributes (§17) and a valid combination of the four 
access modifiers (§10.3.5) and the new (§10.3.4), static (§10.6.2), virtual (§10.6.3), override 
(§10.6.4), sealed (§10.6.5), abstract (§10.6.6), and extern (§10.6.7) modifiers. 

A declaration has a valid combination of modifiers if all of the following are true: 

• The declaration includes a valid combination of access modifiers (§10.3.5). 

• The declaration does not include the same modifier multiple times. 

• The declaration includes at most one of the following modifiers: static, virtual, and 
override. 

• The declaration includes at most one of the following modifiers: new and override. 

• If the declaration includes the abstract modifier, then the declaration does not include 
any of the following modifiers: static, virtual, sealed, or extern. 

• If the declaration includes the private modifier, then the declaration does not include 
any of the following modifiers: virtual, override, or abstract. 

• If the declaration includes the sealed modifier, then the declaration also includes the 
override modifier. 

• If the declaration includes the partial modifier, then it does not include any of the 
following modifiers: new, public, protected, internal, private, virtual, sealed, 
override, abstract, or extern. 

The return-type of a method declaration specifies the t 5 ^e of the value computed and 
returned by the method. The return-type is void if the method does not return a value. If the 
declaration includes the partial modifier, then the return type must be void. 

The member-name specifies the name of the method. Unless the method is an explicit inter¬ 
face member implementation (§13.4.1), the member-name is simply an identifier. For an 
explicit interface member implementation, the member-name consists of an interface-type 
followed by a "." and an identifier. 

The optional type-parameter-list specifies the type parameters of the method (§10.1.3). If a 
type-parameter-list is specified, the method is a generic method. If the method has an extern 
modifier, a type-parameter-list carmot be specified. 

The optional formal-parameter-list specifies the parameters of the method (§10.6.1). 

The optional type-parameter-constraints-clauses specify constraints on individual type 
parameters (§10.1.5) and maybe specified only if a type-parameter-list is also supplied, and 
if the method does not have an override modifier. 


521 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


The return-type and each of the types referenced in the formal-parameter-list of a method 
must be at least as accessible as the method itself (§3.5.4). 

For abstract and extern methods, the method-body consists simply of a semicolon. For 
partial methods, the method-body may consist of either a semicolon or a block. For all other 
methods, the method-body consists of a block, which specifies the statements to execute when 
the method is invoked. 

The name, the type parameter list, and the formal parameter list of a method define the 
signature (§3.6) of the method. Specifically, the signature of a method consists of its name, 
the number of type parameters, and the number, modifiers, and t 5 ^es of its formal param- 
I eters. For these purposes, any t 5 ^e parameter of the method that occurs in the t 5 ^e of a 
formal parameter is identified not by its name, but rather by its ordinal position in the t 5 ^e 
argument list of the method. The return t 5 ^e is not part of a method's signature, nor are the 
names of the type parameters or the formal parameters. 

The name of a method must differ from the names of all other nonmethods declared in the 
same class. In addition, the signature of a method must differ from the signatures of all 
other methods declared in the same class, and two methods declared in the same class may 
not have signatures that differ solely by ref and out. 

The method's type-parameters are in scope throughout the method-declaration, and can be 
used to form t 5 ^es throughout that scope in return-type, method-body, and type-parameter- 
constraints-clauses but not in attributes. 

All formal parameters and type parameters must have different names. 

10.6.1 Method Parameters 

The parameters of a method, if any, are declared by the method's formal-parameter-list. 

formal-parameter-list: 

fixed-parameters 

fixed-parameters , parameter-array 
parameter-array 

fixed-parameters: 

fixed-parameter 

fixed-parameters , fixed-parameter 
fixed-parameter: 

attributesparameter-modifier^^^ type identifier default-argument 

default-argument: 

= expression 

522 


www.it-ebooks.info 




10.6 Methods 


parameter-modifier: 

ref 

out 

this 

parameter-array: 

attributes^^^ params array-type identifier 

The formal parameter list consists of one or more comma-separated parameters, of which 
only the last may be a parameter-array. 

A fixed-parameter consists of an optional set of attributes (§17); an optional ref, out, or this 
modifier; a type', an identifier; and an optional default-argument. Each fixed-parameter declares 
a parameter of the given type with the given name. The this modifier designates the 
method as an extension method and is allowed only on the first parameter of a static 
method. Extension methods are further described in §10.6.9. 

A fixed-parameter with a default-argument is known as an optional parameter, whereas a 
fixed-parameter without a default-argument is a required parameter. A required parameter 
may not appear after an optional parameter in a formal-parameter-list. 


“■ CHRISTIAN NAGEL Attention must be paid to optional parameters in regard to 
versioning. The compiler takes default arguments and adds them to the caller in the 
assembly of the caller. If the default argument changes to a new value with a new ver¬ 
sion of the code, the caller still contains the old value if the code is not recompiled. 


A ref or out parameter carmot have a default-argument. The expression in a default-argument 
must be one of the following: 

• A constant-expression. 

• An expression of the form new S (), where S is a value type. 

• An expression of the form default(S), where S is a value t 5 q)e. 

The expression must be implicitly convertible by an identity or nullable conversion to the 
type of the parameter. 

If optional parameters occur in an implementing partial method declaration (§10.2.7), in an 
explicit interface member implementation (§13.4.1), or in a single-parameter indexer dec¬ 
laration (§10.9), the compiler should give a warning, since these members can never be 
invoked in a way that permits arguments to be omitted. 


523 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


A parameter-array consists of an optional set of attributes (§17), a pa rams modifier, an array- 
type, and an idenfz/ier. A parameter array declares a single parameter of the given array type 
with the given name. The array-type of a parameter array must be a single-dimensional 
array type (§12.1). In a method invocation, a parameter array permits either a single argu¬ 
ment of the given array type or zero or more arguments of the array element type to be 
specified. Parameter arrays are described further in §10.6.1.4. 

A parameter-array may occur after an optional parameter, but carmot have a default value— 
the omission of arguments for a parameter-array would instead result in the creation of an 
empty array. 

The following example illustrates different kinds of parameters: 


public void 

M( 

ref int 

i:. 

decimal 

d. 

bool 

b = false. 

bool? 

n = false. 

string 

s = "Hello", 

object 

0 = null. 

T 

t = default(T), 

params 

int[] a 


) { } 


I In the formal-parameter-list for M, i is a required ref parameter; d is a required value param¬ 
eter; b, s, o, and t are optional value parameters; and a is a parameter array. 

A method declaration creates a separate declaration space for parameters, t 5 q)e parameters, 
and local variables. Names are introduced into this declaration space by the t 5 q)e parame¬ 
ter list and the formal parameter list of the method and by local variable declarations in the 
block of the method. It is an error for two members of a method declaration space to have 
the same name. It is an error for the method declaration space and the local variable decla¬ 
ration space of a nested declaration space to contain elements with the same name. 

A method invocation (§7.6.5.1) creates a copy, specific to that invocation, of the formal 
parameters and local variables of the method, and the argument list of the invocation 
assigns values or variable references to the newly created formal parameters. Within the 
block of a method, formal parameters can be referenced by their identifiers in simple-name 
expressions (§7.6.2). 

There are four kinds of formal parameters: 

• Value parameters, which are declared without any modifiers. 

• Reference parameters, which are declared with the ref modifier. 

• Output parameters, which are declared with the out modifier. 

• Parameter arrays, which are declared with the pa rams modifier. 

524 


www.it-ebooks.info 




10.6 Methods 


As described in §3.6, the ref and out modifiers are part of a method's signature, but the 
params modifier is not. 

10.6.1.1 Value Parameters 

A parameter declared with no modifiers is a value parameter. A value parameter corre¬ 
sponds to a local variable that gets its initial value from the corresponding argument sup¬ 
plied in the method invocation. 

When a formal parameter is a value parameter, the corresponding argument in a method 
invocation must be an expression that is implicitly convertible (§6.1) to the formal param¬ 
eter t 5 ^e. 

A method is permitted to assign new values to a value parameter. Such assignments affect 
only the local storage location represented by the value parameter; they have no effect on 
the actual argument given in the method invocation. 

10.6.1.2 Reference Parameters 

A parameter declared with a ref modifier is a reference parameter. Unlike a value param¬ 
eter, a reference parameter does not create a new storage location. Instead, a reference 
parameter represents the same storage location as the variable given as the argument in the 
method invocation. 

When a formal parameter is a reference parameter, the corresponding argument in a 
method invocation must consist of the keyword ref followed by a variable-reference (§5.3.3) 
of the same type as the formal parameter. A variable must be definitely assigned before it 
can be passed as a reference parameter. 

Within a method, a reference parameter is always considered definitely assigned. 

A method declared as an iterator (§10.14) carmot have reference parameters. 

The example 

using System; 

class Test 
{ 

static void Swap(ref int x, ref int y) { 
int temp = x; 

X = y; 
y = temp; 

} 

static void Main() { 
int i = 1, j = 2; 

Swap(ref i, ref j); 

Console.WriteLineC'i = {0}, j = {1}", 1, j); 

} 

} 


525 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


produces the following output: 
i = 2, j = 1 

For the invocation of Swap in Main, x represents i and y represents j. Thus the invocation 
has the effect of swapping the values of i and j . 

in a method that takes reference parameters, it is possible for multiple names to represent 
the same storage location. In the example 

class A 
{ 

string s; 

void F(ref string a, ref string b) { 
s = "One"; 
a = "Two"; 
b = "Three"; 

} 

void G() { 

F(ref s, ref s); 

} 

} 

the invocation of F in G passes a reference to s for both a and b. Thus, for that invocation, 
the names s, a, and b all refer to the same storage location, and the three assignments all 
modify the instance field s. 

10.6.1.3 Output Parameters 

A parameter declared with an out modifier is an output parameter. Similar to a reference 
parameter, an output parameter does not create a new storage location. Instead, an output 
parameter represents the same storage location as the variable given as the argument in the 
method invocation. 

When a formal parameter is an output parameter, the corresponding argument in a method 
invocation must consist of the keyword out followed by a variable-reference (§5.3.3) of the 
same type as the formal parameter. A variable need not be definitely assigned before it can 
be passed as an output parameter, but following an invocation where a variable was passed 
as an output parameter, the variable is considered definitely assigned. 

Within a method, just like a local variable, an output parameter is initially considered 
unassigned and must be definitely assigned before its value is used. 

Every output parameter of a method must be definitely assigned before the method 
returns. 


526 


www.it-ebooks.info 




10.6 Methods 


A method declared as a partial method (§10.2.7) or an iterator (§10.14) cannot have output 
parameters. 

Output parameters are typically used in methods that produce multiple return values. 


“■ BILL WAGNER Of course, you could create a struct or class to return the mul¬ 
tiple values, and that would obviate the need for oufpuf paramefers. In addition, fhe 
new Tupleo generic classes can be used fo refum multiple values. 


■■ JON SKEET One example of Bill's poinf could have been int.TryParse in fhe 
.NET Framework. If effectively refurns fwo values: fhe parsed infeger and a boolean 
flag fo indicafe whefher fhe operafion was successful. Nullable value fypes in C# 
already provide exacfly fhis combination, so fhe currenf mefhod signafure of fhis: 

bool TryParse(string s, out int result) 

could have insfead been fhis: 
int? TryParse(string s) 

The same is frue of similar calls such as decimal. TryParse and so on. 


For example: 

using System; 

class Test 
{ 

static void SplitPath(string path, out string dir, out string name) { 
int i = path.Length; 
while (i > 0) { 

char ch = path[i - 1]; 

if (ch == '\\' II ch == '/’ II ch == ':') break; 

i--; 

} 

dir = path.Substring(0, i); 
name = path.Substring(i); 

} 

static void Main() { 
string dir, name; 

SplitPath("c:\\Windows\\System\\hello.txt", out dir, out name); 
Console.WriteLine(dir); 

Console.WriteLine(name); 

} 

} 


527 


www.it-ebooks.info 


10. Classes 








10. Classes 


10. Classes 


The example produces the following output: 

c:\Windows\System\ 
hello.txt 

Note that the dir and name variables can be unassigned before they are passed to 
SplitPath, and that they are considered definitely assigned following the call. 

10.6.1.4 Parameter Arrays 

A parameter declared with a pa rams modifier is a parameter array. If a formal parameter 
list includes a parameter array, it must be the last parameter in the list and it must be of a 
single-dimensional array type. For example, the t 5 ^es string[ ] and string[ ] [ ] can be 
used as the type of a parameter array, but the type string [, ] cannot. It is not possible to 
combine the params modifier with the modifiers ref and out. 

A parameter array permits arguments to be specified in one of two ways in a method 
invocation: 

• The argument given for a parameter array can be a single expression that is implicitly 
convertible (§6.1) to the parameter array t 5 ^e. In this case, the parameter array acts pre¬ 
cisely like a value parameter. 

• Alternatively, the invocation can specify zero or more arguments for the parameter array, 
where each argument is an expression that is implicitly convertible (§6.1) to the element 
type of the parameter array. In this case, the invocation creates an instance of the param¬ 
eter array type with a length corresponding to the number of arguments, initializes the 
elements of the array instance with the given argument values, and uses the newly cre¬ 
ated array instance as the actual argument. 

Except for allowing a variable number of arguments in an invocation, a parameter array is 
precisely equivalent to a value parameter (§10.6.1.1) of the same type. 

The example 

using System; 

class Test 
{ 

static void F(params int[] args) { 

Console.Write("Array contains {0} elements:", args.Length); 
foreach (int i in args) 

Console.Write(" {0}", i); 

Console.WriteLlne(); 

} 


528 


www.it-ebooks.info 




10.6 Methods 


static void Main() { 

int[] arr = {1, 2, 3}; 

F(arr); 

F(10, 20, 30, 40); 

F(); 

} 

} 

produces the following output: 

Array contains 3 elements: 123 
Array contains 4 elements: 10 20 30 40 
Array contains 0 elements: 

The first invocation of F simply passes the array a as a value parameter. The second invoca¬ 
tion of F automatically creates a four-element int[ ] with the given element values and 
passes that array instance as a value parameter. Likewise, the third invocation of F creates 
a zero-element int [ ] and passes that instance as a value parameter. The second and third 
invocations are precisely equivalent to writing 

F(new int[] {10, 20, 30, 40}); 

F(new int[] {}); 

When performing overload resolution, a method with a parameter array may be applicable 
either in its normal form or in its expanded form (§7.5.3.1). The expanded form of a method 
is available only if the normal form of the method is not applicable and only if a method 
with the same signature as the expanded form is not already declared in the same type. 

The example 

using System; 

class Test 
{ 

static void F(params object[] a) { 

Console .WriteLineC'F (object [ ])"); 

} 

static void F() { 

Console.WriteLine("F()"); 

} 

static void F(object a0, object al) { 

Console.WriteLine("F(object,object)"); 

} 

static void Main() { 

F(); 

F(1); 

F(l, 2); 

F(l, 2, 3); 

F(l, 2, 3, 4); 

} 

} 


529 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


produces the following output: 
F(); 

F(object[]); 

F(object,object); 
F(object[]); 

F(object[]); 


“■ BILL WAGNER The more methods you create that could possibly be suitable 
methods, the more trouble you create for your users. More compiler ambiguity creates 
more ambiguity for your client developers as well. 


In the example, two of the possible expanded forms of the method with a parameter array 
are already included in the class as regular methods. These expanded forms are, therefore, 
not considered when performing overload resolution, and the first and third method invo¬ 
cations select the regular methods. When a class declares a method with a parameter array, 
it is not uncommon to also include some of the expanded forms as regular methods. By 
doing so, it is possible to avoid the allocation of an array instance that occurs when an 
expanded form of a method with a parameter array is invoked. 

When the type of a parameter array is object [ ], a potential ambiguity arises between the 
normal form of the method and the expended form for a single object parameter. The 
reason for the ambiguity is that an object [ ] is itself implicitly convertible to type object. 
The ambiguity presents no problem, however, since it can be resolved by inserting a cast if 
needed. 

The example 

using System; 

class Test 
{ 

static void F(params object[] args) { 
foreach (object o in args) { 

Console.Write(o.GetType().FullName); 

Console.Write(" "); 

} 

Console.WriteLine(); 

} 

static void Main() { 

object[] a = {1, "Flello", 123.456}; 
object o = a; 


530 


www.it-ebooks.info 






10.6 Methods 


F(a); 

F((object)a); 

F(o); 

F((object[])o); 

} 

} 

produces the following output: 

System.Int32 System.String System.Double 
System.Object[] 

System.Object[] 

System.Int32 System.String System.Double 

In the first and last invocations of F, the normal form of F is applicable because an implicit 
conversion exists from the argument t 5 ^e to the parameter type (both are of type object [ ]). 
Thus overload resolution selects the normal form of F, and the argument is passed as a 
regular value parameter. In the second and third invocations, the normal form of F is not 
applicable because no implicit conversion exists from the argument type to the parameter 
type (t 5 ^e object cannot be implicitly converted to t 5 ^e object [ ]). However, the expanded 
form of F is applicable, so it is selected by overload resolution. As a result, a one-element 
ob j ect [ ] is created by the invocation, and the single element of the array is initialized with 
the given argument value (which itself is a reference to an ob j ect [ ]). 

10.6.2 Static and Instance Methods 

When a method declaration includes a static modifier, that method is said to be a 
static method. When no static modifier is present, the method is said to be an instance 
method. 

A static method does not operate on a specific instance, and it is a compile-time error to 
refer to this in a static method. 

An instance method operates on a given instance of a class, and that instance can be 
accessed as this (§7.6.7). 

When a method is referenced in a member-access (§7.6.4) of the form E .M, if M is a static 
method, E must denote a type containing M; if M is an instance method, E must denote an 
instance of a type containing M. 

The differences between static and instance members are discussed further in §10.3.7. 


531 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


10.6.3 Virtual Methods 

When an instance method declaration includes a virtual modifier, that method is said to 
be a virtual method. When no virtual modifier is present, the method is said to be a non¬ 
virtual method. 


“■ BILL WAGNER You can create virtual generic methods, even in a nongeneric 
class. When you do so, any overrides must also be generic. You carmot override a 
particular instantiation. 


■■ JONSKEET Private methods cannot be virtual, even though there is one corner 
case where it would make sense: A nested class derived from ifs own container class 
could override it (with another private method). While it's a tiny bit inelegant for 
fhis possibilify to be forbidden by fhe specificafion, if means thaf methods that are 
accidentally private and virtual can be treated as errors—and this is a far more com¬ 
mon case. 


The implementation of a nonvirtual method is invariant: The implementation is the same 
whether the method is invoked on an instance of the class in which it is declared or an 
instance of a derived class. In confrasf, the implementation of a virfual method can be 
superseded by derived classes. The process of superseding the implementation of an inher- 
ifed virfual method is known as overriding that method (§10.6.4). 

In a virtual method invocation, the runtime type of the instance for which that invocation 
takes place determines the actual method implementation to invoke. In a nonvirtual 
method invocation, the compile-time type of fhe insfance is the determining factor. In pre¬ 
cise terms, when a method named N is invoked with an argument list A on an instance with 
a compile-time t 5 ^e C and a runtime type R (where R is either C or a class derived from C), 
fhe invocafion is processed as follows: 

• First, overload resolution is applied to C, N, and A to select a specific method M from the 
set of mefhods declared in and inherited by C. This is described in §7.6.5.1. 

• Then, if M is a nonvirtual method, M is invoked. 

• Otherwise, M is a virtual method, and the most derived implementation of M wifh respect 
to R is invoked. 

For every virtual method declared in or inherited by a class, there exists a most derived 
implementation of the method with respect to that class. The most derived implementation 
of a virtual method M with respect to a class R is determined as follows: 


532 


www.it-ebooks.info 








10.6 Methods 


• If R contains the introducing virtual declaration of M, then it is the most derived imple¬ 
mentation of M. 

• Otherwise, if R contains an override of M, then it is the most derived implementa¬ 
tion of M. 

• Otherwise, the most derived implementation of M with respect to R is the same as the 
most derived implementation of M with respect to the direct base class of R. 

The following example illustrates the differences between virtual and nonvirtual methods: 

using System; 

class A 
{ 

public void F() { Console.WriteLine("A.F"); } 
public virtual void G() { Console.WriteLine("A.G"); } 

} 

class B: A 
{ 

new public void F() { Console.WriteLine("B.F"); } 
public override void G() { Console.WriteLine("B.G"); } 

} 

class Test 
{ 

static void Main() { 

B b = new B(); 

A a = b; 

a. F(); 

b. F(); 

a. GO; 

b. G(); 

} 

} 

In the example, A introduces a nonvirtual method F and a virtual method G. The class B 
introduces a new non-virtual method F, thus hiding the inherited F, and also overrides the 
inherited method G. The example produces the following output: 

A. F 

B. F 
B.G 
B.G 

Notice that the statement a.G() invokes B.G, not A.G. This outcome occurs because the 
runtime t5^e of the instance (which is B), not the compile-time type of the instance (which 
is A), determines the actual method implementation to invoke. 


533 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


Because methods are allowed to hide inherited methods, it is possible for a class to contain 
several virtual methods with the same signature. This does not present an ambiguity prob¬ 
lem, since all but the most derived method are hidden, in the example 

using System; 

class A 
{ 

public virtual void F() { Console.WriteLine("A.F"); } 

} 

class B: A 
{ 

public override void F() { Console.WriteLine("B.F"); } 

} 

class C: B 
{ 

new public virtual void F() { Console.WriteLine("C.F"); } 

} 

class D: C 
{ 

public override void F() { Console.WriteLine("D.F"); } 

} 

class Test 
{ 

static void Main() { 

D d = new D(); 

A a = d; 

B b = d; 

C c = d; 

a. F(); 

b. F(); 

c. F(); 

d. F(); 

} 

} 

the C and D classes contain two virtual methods with the same signature: the one intro¬ 
duced by A and the one introduced by C. The method introduced by C hides the method 
inherited from A. Thus fhe override declaration in D overrides fhe mefhod infroduced by C, 
and if is nof possible for D fo override fhe mefhod infroduced by A. The example produces 
fhe following oufpuf: 

B.F 

B.F 

D.F 

D.F 

Nofe fhaf if is possible fo invoke fhe hidden virfual mefhod by accessing an insfance of D 
fhrough a less derived t5^e in which fhe mefhod is nof hidden. 


534 


www.it-ebooks.info 




10.6 Methods 


10.6.4 Override Methods 

When an instance method declaration includes an override modifier, the method is said to 
be an override method. An override method overrides an inherited virtual method with the 
same signature. Whereas a virtual method declaration introduces a new method, an over¬ 
ride method declaration specializes an existing inherited virtual method by providing a 
new implementation of that method. 

The method overridden by an override declaration is known as the overridden base 
method. For an override method M declared in a class C, the overridden base method is 
determined by examining each base class type of C, starting with the direct base class t5^e 
of C and continuing with each successive direct base class type, until in a given base class 
type at least one accessible method is located that has the same signature as M after substi¬ 
tution of type arguments. For the purposes of locating the overridden base method, a 
method is considered accessible if it is public, if it is protected, if it is protected internal, 
or if it is internal and declared in the same program as C. 

A compile-time error occurs unless all of the following are true for an override 
declaration: 

• An overridden base method can be located as described above. 

• There is exactly one such overridden base method. This restriction has effect only if the 
base class type is a constructed t5^e where the substitution of type arguments makes the 
signature of two methods the same. 

• The overridden base method is a virtual, abstract, or override method. In other words, 
the overridden base method cannot be static or non-virtual. 

• The overridden base method is not a sealed method. 

• The override method and the overridden base method have the same return t5^e. 

• The override declaration and the overridden base method have the same declared acces¬ 
sibility. In other words, an override declaration carmot change the accessibility of the 
virtual method. However, if the overridden base method is protected internal and it 
is declared in a different assembly than the assembly containing the override method, 
then the override method's declared accessibility must be protected. 

• The override declaration does not specify t5^e-parameter-constraints-clauses. Instead, 
the constraints are inherited from the overridden base method. Note that constraints 
that are type parameters in the overridden method may be replaced by t5^e arguments 
in the inherited constraint. This can lead to constraints that are not legal when explicitly 
specified, such as value types or sealed t5^es. 


535 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


The following example demonstrates how the overriding rules work for generic classes: 

abstract class C<T> 


{ 


public virtual T F() 

public virtual C<T> G() {...} 

public virtual void H(C<T> x) {...} 

} 

class D: C<string> 


{ 

public override string F() {...} 
public override C<string> G() 
public override void FI(C<T> x) {...} 

} 

class E<TjU>: C<U> 

{ 

public override U F() {...} 
public override C<U> G() {...} 
public override void H(C<T> x) {...} 

} 


// Okay 
// Okay 

// Error: should be C<string> 

// Okay 
// Okay 

// Error: should be C<U> 


An override declaration can access the overridden base method using a base-access (§ 7 . 6 . 8 ). 
In the example 

class A 


Int x; 

public virtual void PrintFields() { 
Console.WriteLineC'x = {0}'h x); 

} 


class B: A 


{ 

int y; 

public override void PrintFields() { 
base.PrintFields(); 

Console.WriteLineC'y = {0}", y); 

} 

} 


the base. PrintFields( ) invocation in B invokes the PrintFields method declared in A. A 
base-access disables the virtual invocation mechanism and simply treats the base method as 
a non-virtual method. Had the invocation in B been written ( (A)this). PrintFields (), it 


536 


www.it-ebooks.info 




10.6 Methods 


would recursively invoke the PrintFields method declared in B, not the one declared in A, 
since PrintFields is virtual and the runtime t5^e of ( (A)this) is B. 

Only by including an override modifier can a method override another method. In all 
other cases, a method with the same signature as an inherited method simply hides the 
inherited method. In the example 

class A 
{ 

public virtual void F() {} 

} 

class B: A 
{ 

public virtual void F() {} // Warning: hiding inherited F() 

} 

the F method in B does not include an override modifier and, fherefore, does nof override 
fhe F mefhod in A. Rafher, the F method in B hides the method in A, and a warning is 
reported because the declaration does not include a new modifier. 

In the example 

class A 
{ 

public virtual void F() {} 

} 

class B: A 
{ 

new private void F() {} 

} 

class C: B 
{ 

public override void F() {} 

} 

the F method in B hides the virtual F method inherited from A. Since fhe new F in B has 
private access, ifs scope includes only the class body of B and does nof extend to C. There¬ 
fore, the declaration of F in C is permitted to override the F inherited from A. 

10.6.5 Sealed Methods 

When an instance method declaration includes a sealed modifier, fhat mefhod is said to be 
a sealed method. If an instance method declaration includes the sealed modifier, if must 
also include the override modifier. Use of the sealed modifier prevenfs a derived class 
from further overriding the method. 


// Hides A.F within body of B 


// Okay: overrides A.F 


537 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


In the example 

using System; 

class A 
{ 

public virtual void F() { 

Console.WriteLine("A.F"); 

} 

public virtual void G() { 

Console.WriteLine("A.G"); 

} 

} 

class B: A 
{ 

sealed override public void F() { 

Console.WriteLine("B.F"); 

} 

override public void G() { 

Console. WriteLineC'B.G"); 

} 

} 

class C: B 
{ 

override public void G() { 

Console. WriteLlneC'C.G"); 

} 

} 

the class B provides two override methods: an F method that has the sealed modifier and 
a G method that does not. Class B's use of fhe sealed modifier prevenfs class C from furfher 
overriding F. 


■■ CHRIS SELLS When I wanf fo derive from a class, if drives me crazy if fhaf class 
is sealed or if a mefhod is sealed, because fhose resfricfions limif how I can use fhe 
class. 

When I wanf fo build a base class, I wanf if fo be as locked down as possible so fhaf I 
can fesf fhe possible derivation scenarios I wanf fo supporf. I don'f wanf fo be frapped 
info supporfing somefhing crazy fhaf some cusfomer has done and fhaf I never 
inf ended. 

As wifh all fhings in software design, fhe use of fhe sealed modifier involves a bal¬ 
ance. I fend fo avoid fhe use of fhe sealed ke5rword unless I have fo use if. If customers 
gef crazy, well, fhaf's whaf keeps fhings inferesfing. 


538 


www.it-ebooks.info 






10.6 Methods 


10.6.6 Abstract Methods 

When an instance method declaration includes an abstract modifier, that method is said 
to be an abstract method. Although an abstract method is implicitly also a virtual method, 
it cannot have the modifier virtual. 

An abstract method declaration introduces a new virtual method but does not provide an 
implementation of that method. Instead, nonabstract derived classes are required to pro¬ 
vide their own implementation by overriding that method. Because an abstract method 
provides no actual implementation, the method-body of an abstract method simply consists 
of a semicolon. 

Abstract method declarations are permitted only in abstract classes (§10.1.1.1). 

In the example 

public abstract class Shape 
{ 

public abstract void Paint(Graphics g. Rectangle r); 

} 

public class Ellipse: Shape 
{ 

public override void Paint(Graphics g. Rectangle r) { 
g.DrawEllipse(r); 

} 

} 

public class Box: Shape 
{ 

public override void Paint(Graphics g. Rectangle r) { 
g.DrawRect(r); 

} 

} 

the Shape class defines the abstract notion of a geometrical shape object that can paint itself. 
The Paint method is abstract because there is no meaningful default implementation. The 
Ellipse and Box classes are concrete Shape implementations. Because these classes are 
nonabstract, they are required to override the Paint method and provide an actual 
implementation. 

It is a compile-time error for a base-access (§7.6.8) to reference an abstract method. In the 
example 

abstract class A 
{ 

public abstract void F(); 

} 


539 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


class B: A 
{ 

public override void F() { 

base.F(); // Error: base.F is abstract 

} 

} 

a compile-time error is reported for the base.F() invocation because it references an 
abstract method. 

An abstract method declaration is permitted to override a virtual method. This allows an 
abstract class to force reimplementation of the method in derived classes, and makes the 
original implementation of the method unavailable. In the example 

using System; 

class A 
{ 

public virtual void F() { 

Console.WriteLine("A.F"); 

} 

} 

abstract class B: A 
{ 

public abstract override void F(); 

} 

class C: B 
{ 

public override void F() { 

Console.WriteLine("C.F"); 

} 

} 

class A declares a virtual method, class B overrides this method with an abstract method, 
and class C overrides the abstract method to provide its own implementation. 


"■ MAREK SAFAR There are no visibility restrictions on abstract methods except 
that they carmot be private. That access choice can cause trouble when someone acci¬ 
dentally declares an internal abstract method within a public abstract class; such 
a class, even though it is declared public, cannot be used outside the class assembly. 


10.6.7 External Methods 

When a method declaration includes an extern modifier, that method is said to be an 
external method. External methods are implemented externally t 5 ^ically using a language 


540 


www.it-ebooks.info 






10.6 Methods 


other than C#. Because an external method declaration provides no actual implementation, 
the method-body of an external method simply consists of a semicolon. An external method 
may not be generic. 

The extern modifier is typically used in conjunction with the Dllimport attribute (§17.5.1), 
allowing external methods to be implemented by Dynamic Link Libraries (DLLs). The 
execution environment may support other mechanisms whereby implementations of exter¬ 
nal methods can be provided. 

When an external method includes a Dllimport attribute, the method declaration must 
also include a static modifier. This example demonsfrates the use of fhe extern modifier 
and the Dllimport attribute: 

using System.Text; 

using System.Security.Permissions; 

using System.Runtime.InteropServices; 

class Path 

{ 

[DllImport("kernel32", SetLastError=true)] 

static extern bool CreateDirectory(string name, SecurityAttribute sa); 

[DllImport("kernel32", SetLastError=true)] 
static extern bool RemoveDirectory(string name); 

[DllImport("kernel32", SetLastError=true)] 

static extern int GetCurrentDirectory(int bufSize, StringBuilder buf); 

[DllImport("kernel32", SetLastError=true)] 

static extern bool SetCurrentDirectory(string name); 

} 

10.6.8 Partial Methods 

When a method declaration includes a partial modifier, fhaf mefhod is said fo be a 
partial method. Partial methods can be declared only as members of partial types 
(§10.2) and are subject to a number of restrictions. Partial methods are further described 
in §10.2.7. 


10.6.9 Extension Methods 

When the first parameter of a mefhod includes the this modifier, fhat method is said to be 
an extension method. Extension methods can be declared only in nongeneric, non-nested 
static classes. The first parameter of an extension method can have no modifiers ofher fhan 
this, and the parameter t 5 ^e cannot be a pointer type. 


541 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


“■ PETER SESTOFT The parameter type also cannot be dynamic (although that 
would really just mean object). But it can be T, where T is a t 5 ^e parameter of the 
extension method, like so: 

public static void Foo<T>(this T x) { ... } 

This is potentially useful, especially if T has a fype consfrainf and fhere are more 
paramefers whose t 5 ^e involves T. 


The following is an example of a sfafic class fhaf declares fwo exfension mefhods: 
using System; 

public static class Extensions 
{ 

public static int ToInt32(this string s) { 
return Int32.Parse(s); 

} 

public static T[] Slice<T>(this T[] source, int index, int count) { 
if (index < 0 || count < 0 || source.Length - index < count) 
throw new ArgumentException(); 

T[] result = new T[count]; 

Array.Copy(source, index, result, 0, count); 
return result; 

} 

} 

An exfension mefhod is a regular sfafic mefhod. In addition, where ifs enclosing sfafic class 
is in scope, an exfension mefhod can be invoked using insfance mefhod invocation S 5 mfax 
(§7.6.5.2), using fhe receiver expression as fhe firsf argumenf. 

The following program uses fhe exfension mefhods declared above: 

static class Program 
{ 

static void Main() { 

string!] strings = { "1", "22", "333", "4444" }; 
foreach (string s in strings.Slice(l, 2)) { 

Console.WriteLine(s.ToInt32()); 

} 

} 

} 

The Slice mefhod is available on fhe string[ ], and fhe ToInt32 mefhod is available on 
string, because fhey have been declared as exfension mefhods. The meaning of fhe pro¬ 
gram is fhe same as fhe following, using ordinary sfafic mefhod calls: 

static class Program 
{ 

static void Main() { 


542 


www.it-ebooks.info 






10.6 Methods 


string[] strings = { "1", "22", "333", "4444" }; 
foreach (string s in Extensions.Slice(strings, 1, 2)) { 
Console.WriteLine(Extensions.ToInt32(s)); 

} 

} 

} 


■■ PETER SESTOFT The Slice extension method is generic: It works on any array 
of T, regardless of which f 5 ^e paramefer T is. You can also define generic exfension 
mefhods fhaf involve f5T’e bounds (mefhod IsSorted below) and exfension mefhods 
fhaf work on parficular f 5 ^e insfances of a generic t5T’e (mefhod ConcatWith). The laf- 
fer also shows fhaf an exfension mefhod may, of course, have defaulf argumenfs 
(§10.6.1): 

public static bool IsSorted<T>(this IEnumerable<T> xs) 
where T : IComparable<T> 

{ ... } 

public static string ConcatWith(this IEnumerable<String> xs, string glue = ", ") 

{ } 


"■ CHRISSELLS On fhe one hand, exfension mefhods are a greaf way fo add mefh¬ 
ods fhaf a f5T’e designer forgof, while sfill keeping fhe S 5 mfax as if fhe designer had 
your every whim in mind. On fhe ofher hand, fhese mefhods are easy fo abuse. I saw 
an exfension mefhod on object in an experimenfal sysfem once, and if became an 
ongoing joke in our group fo see if we could fop if for confusing design. 


"■ PETER SESTOFT Here's a shof af a mosf widely applicable exfension mefhod. 
Any affempf af calling a nonexisfenf mefhod toString, wifh lowercase t, on any 
objecf, wifh any number of argumenfs of any fj^e, will call fhis insfead: 

public static string toString(this object x, params object[] args) { 
return "Make that ToStringO, mate!"; 

} 

Exfension mefhods are non-virfual and do nof override anyfhing; hence one cannof 
replace fhe ToString mefhod (wifh uppercase T) of an exisfing fype YourType by 
declaring an exfension mefhod. The following declarafion is legal buf has no effecf. A 
call o.ToString( ) will pick up Object.ToString () or some mefhod fhaf overrides or 
hides if, nof fhis one: 

public static string ToString(this YourType x) { ... } 


543 


www.it-ebooks.info 


10. Classes 










10. Classes 


10. Classes 


10.6.10 Method Body 

The method-body of a method declaration consists of either a block or a semicolon. 

Abstract and external method declarations do not provide a method implementation, so 
their method bodies simply consist of a semicolon. For any other method, the method body 
is a block (§8.2) that contains the statements to execute when that method is invoked. 

When the return t 5 ^e of a method is void, return statements (§8.9.4) in that method's body 
are not permitted to specify an expression. If execution of the method body of a void 
method completes normally (that is, if control flows off the end of the method body), that 
method simply returns to its caller. 

When the return type of a method is not void, each return statement in that method's 
body must specify an expression that is implicitly convertible to the return t 5 ^e. The end 
point of the method body of a value-returning method must not be reachable. In other 
words, in a value-returning method, control is not permitted to flow off the end of the 
method body. 

In the example 

class A 
{ 

public int F() {} // Error: return value required 

public int G() { 
return 1; 

} 

public int H(bool b) { 
if (b) { 

return 1; 

} 

else { 

return 0; 

} 

} 

} 

the value-returning F method results in a compile-time error because control can flow off 
the end of the method body. The G and H methods are correct because all possible execution 
paths end in a return statement that specifies a return value. 

10.6.11 Method Overloading 

The method overload resolution rules are described in §7.5.2. 


544 


www.it-ebooks.info 




10.7 Properties 


10.7 Properties 

A property is a member that provides access to a characteristic of an object or a class. 
Examples of properties include the length of a string, the size of a font, the caption of a 
window, the name of a customer, and so on. Properties are a natural extension of fields— 
both are named members with associated types, and the S 5 mtax for accessing fields and 
properties is the same. However, unlike fields, properties do not denote storage locations. 
Instead, properties have accessors that specify the statements to be executed when their 
values are read or written. Properties thus provide a mechanism for associating actions 
with the reading and writing of an object's attributes; furthermore, they permit such attri¬ 
butes to be computed. 

Properties are declared using property-declarations: 
property-declaration: 

attributes^^^ property-modifiers^^^ type member-name { accessor-declarations } 

property-modifiers: 

property-modifier 

property-modifiers property-modifier 

property-modifier: 

new 

public 

protected 

internal 

private 

static 

virtual 

sealed 

override 

abstract 

extern 

member-name: 

identifier 

interface-type . identifier 

A property-declaration may include a set of attributes (§17), a valid combination of the four 
access modifiers (§10.3.5), and the new (§10.3.4), static (§10.6.2), virtual (§10.6.3), 
override (§10.6.4), sealed (§10.6.5), abstract (§10.6.6), and extern (§10.6.7) modifiers. 


545 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


Property declarations are subject to the same rules as method declarations (§10.6) with 
regard to valid combinations of modifiers. 

The type of a property declaration specifies the t 5 ^e of the property introduced by the dec¬ 
laration, and the member-name specifies the name of the property. Unless the property is an 
explicit interface member implementation, the member-name is simply an identifier. For 
an explicit interface member implementation (§13.4.1), the member-name consists of an 
interface-type followed by a "." and an identifier. 

The type of a properfy musf be at least as accessible as the property itself (§3.5.4). 

The accessor-declarations, which musf be enclosed in "{" and "}" fokens, declare the acces¬ 
sors (§10.7.2) of the property. The accessors specify fhe execufable stafemenfs associafed 
with reading and writing the property. 

Even though the S 5 mtax for accessing a property is the same as that for a field, a property 
is not classified as a variable. Thus if is not possible to pass a property as a ref or out 
argument. 

When a property declaration includes an extern modifier, the property is said to be an 
external property. Because an external property declaration provides no actual implemen¬ 
tation, each of its accessor-declarations consists of a semicolon. 

10.7.1 Static and Instance Properties 

When a property declaration includes a static modifier, the property is said to be a static 
property. When no static modifier is present, the property is said to be an instance 
property. 

A static property is not associated with a specific instance, and it is a compile-time error to 
refer to this in the accessors of a static property. 

An instance property is associated with a given instance of a class, and thaf instance can be 
accessed as this (§7.6.7) in the accessors of that property. 

When a property is referenced in a member-access (§7.6.4) of the form E .M, if M is a sfafic 
property, E must denote a type containing M; if M is an instance property, E must denote an 
instance of a type containing M. 

The differences befween static and instance members are discussed further in §10.3.7. 


546 


www.it-ebooks.info 




10.7 Properties 


10.7.2 Accessors 

The accessor-declarations of a property specify the executable statements associated with 
reading and writing that property 

accessor-declarations: 

get-accessor-declaration set-accessor-declaration 
set-accessor-declaration get-accessor-declaration 

get-accessor-declaration: 

attributes^^i accessor-modifier^^^ get accessor-body 
set-accessor-declaration: 

attributes^^i accessor-modifier^^^ set accessor-body 

accessor-modifier: 

protected 

internal 

private 

protected internal 
internal protected 

accessor-body: 

block 


The accessor declarations consist of a get-accessor-declaration, a set-accessor-declaration, or 
both. Each accessor declaration consists of the token get or set followed by an optional 
accessor-modifier and an accessor-body. 

The use of accessor-modifiers is governed by the following restrictions: 

• An accessor-modifier may not be used in an interface or in an explicit interface member 
implementation. 

• For a property or indexer that has no override modifier, an accessor-modifier is permitted 
only if the property or indexer has both a get and set accessor, and then is permitted 
on only one of those accessors. 

• For a property or indexer that includes an override modifier, an accessor must match 
the accessor-modifier, if any, of the accessor being overridden. 


547 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


• The accessor-modifier must declare an accessibility that is strictly more restrictive than the 
declared accessibility of the property or indexer itself. To be precise: 

- If the property or indexer has a declared accessibility of public, fhe accessor-modifier 
maybe either protected internal, internal, protected, or private. 

- If the property or indexer has a declared accessibility of protected internal, the 
accessor-modifier maybe either internal, protected, or private. 

- If the property or indexer has a declared accessibility of internal or protected, fhe 
accessor-modifier must be private. 

- If the property or indexer has a declared accessibility of private, no accessor-modifier 
may be used. 

For abstract and extern properties, fhe accessor-body for each accessor specified is simply 
a semicolon. Anon-abstract, non-extern property maybe an automatically implemented 
property, in which case both get and set accessors must be given, both with a semicolon 
body (§10.7.3). For the accessors of any other non-abstract, non-extern property, the 
accessor-body is a block that specifies the statements to be executed when the corresponding 
accessor is invoked. 

A get accessor corresponds to a parameterless method with a return value of the property 
type. Except as the target of an assignment, when a property is referenced in an expression, 
fhe get accessor of the property is invoked to compute the value of the property (§7.1.1). 
The body of a get accessor must conform to the rules for value-returning methods described 
in §10.6.10. In particular, all return statements in the body of a get accessor must specify 
an expression that is implicitly convertible to the property t 5 ^e. Furthermore, the end point 
of a get accessor must not be reachable. 

A set accessor corresponds to a method with a single value parameter of the property t 5 ^e 
and a void return t 5 ^e. The implicit parameter of a set accessor is always named value. 
When a property is referenced as the target of an assignment (§7.17) or as the operand of 
++ or - - (§7.6.9, §7.7.5), fhe set accessor is invoked with an argument (whose value is that 
of the right-hand side of the assignment or the operand of fhe ++ or - - operator) that pro¬ 
vides the new value (§7.17.1). The body of a set accessor musf conform to the rules for 
void methods described in §10.6.10. In particular, return statements in the set accessor 
body are not permitted to specify an expression. Since a set accessor implicifly has a 
paramefer named value, if is a compile-fime error for a local variable or constanf declara¬ 
tion in a set accessor to have that name. 

Based on the presence or absence of fhe get and set accessors, a property is classified as 
follows: 


548 


www.it-ebooks.info 




10.7 Properties 


• A property that includes both a get accessor and a s et accessor is said to be a read-write 
property. 

• A property that has only a get accessor is said to be a read-only property. It is a compile¬ 
time error for a read-only property to be the target of an assignment. 

• A property that has only a set accessor is said to be a write-only property. Except as the 
target of an assignment, it is a compile-time error to reference a write-only property in 
an expression. 

In the example 

public class Button: Control 
{ 

private string caption; 

public string Caption { 
get { 

return caption; 

} 

set { 

if (caption != value) { 
caption = value; 

Repaint(); 

} 

} 

} 

public override void Paint(Graphics g. Rectangle r) { 

// Painting code goes here 

} 

} 

the Button control declares a public Caption property. The get accessor of the Caption 
property returns the string stored in the private caption field. The set accessor checks 
whether the new value is different from the current value, and if so, it stores the new value 
and repaints the control. Properties often follow the pattern shown above: The get accessor 
simply returns a value stored in a private field, and the set accessor modifies that private 
field and then performs any additional actions required to fully update the state of the 
object. 

Given the Button class above, the following is an example of use of the Caption property: 
Button okButton = new Button(); 

okButton.Caption = "OK"; // Invokes set accessor 

string s = okButton.Caption; // Invokes get accessor 

Here, the set accessor is invoked by assigning a value to the property, and the get accessor 
is invoked by referencing the property in an expression. 


549 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


The get and set accessors of a property are not distinct members, and it is not possible to 
declare the accessors of a property separately. As such, it is not possible for the two acces¬ 
sors of a read-write property to have different accessibility. The example 

class A 
{ 

private string name; 

public string Name { // Error: duplicate member name 

get { return name; } 

} 

public string Name { // Error: duplicate member name 

set { name = value; } 

} 

} 

does not declare a single read-write property. Rather, it declares two properties with the 
same name, one read-only and one write-only. Since two members declared in the same 
class carmot have the same name, the example causes a compile-time error to occur. 

When a derived class declares a property by the same name as an inherited property, the 
derived property hides the inherited property with respect to both reading and writing. In 
the example 

class A 
{ 

public int P { 
set {...} 

} 

} 

class B: A 
{ 

new public int P { 
get {...} 

} 

} 

the P property in B hides the P property in A with respect to both reading and writing. Thus, 
in the statements 

B b = new B(); 

b.P = 1; // Error: B.P is read-only 

((A)b).P = 1; // Okay: reference to A.P 

the assignment to b. P causes a compile-time error to be reported, since the read-only P 
property in B hides the write-only P property in A. Note, however, that a cast can be used 
to access the hidden P property. 


550 


www.it-ebooks.info 




10.7 Properties 


Unlike public fields, properties provide a separation between an object's internal state and 
its public interface. Consider the following example: 

class Label 

{ 

private int x, y; 

private string caption; 

public Label(int x, int y, string caption) { 
this.x = x; 
this.y = y; 

this.caption = caption; 

} 

public int X { 

get { return x; } 

} 

public int Y { 

get { return y; } 

} 

public Point Location { 

get { return new Point(x, y); } 

} 

public string Caption { 

get { return caption; } 

} 

} 

Here, the Label class uses two int fields, x and y, to store its location. The location is pub¬ 
licly exposed both as an X and a Y property and as a Location property of t 5 ^e Point. If, in 
a future version of Label, it becomes more convenient to store the location as a Point inter¬ 
nally, the change can be made without affecting the public interface of the class: 

class Label 

{ 

private Point location; 

private string caption; 

public Label(int x, int y, string caption) { 
this.location = new Point(x, y); 
this.caption = caption; 

} 

public int X { 

get { return location.x; } 

} 

public int Y { 

get { return location.y; } 

} 


551 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


public Point Location { 

get { return location; } 

} 

public string Caption { 

get { return caption; } 

} 

} 

Had X and y instead been public readonly fields, it would have been impossible to make 
such a change to the Label class. 

Exposing state through properties is not necessarily any less efficient than exposing fields 
directly In particular, when a property is non-virtual and contains only a small amount of 
code, the execution environment may replace calls to accessors with the actual code of the 
accessors. This process is known as inlining, and it makes property access as efficient as 
field access, yet preserves the increased flexibility of properties. 

Since invoking a get accessor is conceptually equivalent to reading the value of a field, it 
is considered bad programming style for get accessors to have observable side effects. In 
the example 

class Counter 
{ 

private int next; 

public int Next { 

get { return next++; } 

} 

} 

the value of the Next property depends on the number of times the property has previously 
been accessed. Thus accessing the property produces an observable side effect, and the 
property should be implemented as a method instead. 

The "no side effects" convention for get accessors doesn't mean that get accessors should 
always be written to simply return values stored in fields. Indeed, get accessors often com¬ 
pute the value of a property by accessing multiple fields or invoking methods. However, a 
properly designed get accessor performs no actions that cause observable changes in the 
state of the object. 

Properties can be used to delay initialization of a resource until the moment it is first refer¬ 
enced. For example: 

using System.10; 

public class Console 
{ 

private static TextReader reader; 
private static TextWriter writer; 
private static TextWriter error; 


552 


www.it-ebooks.info 




10.7 Properties 


public static TextReader In { 
get { 

if (reader == null) { 

reader = new StreamReader(Console.OpenStandardInput()); 

} 

return reader; 

} 

} 

public static TextWriter Out { 
get { 

if (writer == null) { 

writer = new StreamWriter(Console.OpenStandardOutput()); 

} 

return writer; 

} 

} 

public static TextWriter Error { 
get { 

if (error == null) { 

error = new StreamWriter(Console.OpenStandardError()); 

} 

return error; 

} 

} 

} 

The Console class contains three properties— In, Out, and Error —that represent the stan¬ 
dard input, output, and error devices, respectively. By exposing these members as proper¬ 
ties, the Console class can delay their initialization until they are actually used. For example, 
upon first referencing the Out property, as in 

Console.Out.WriteLine("hello, world"); 

the underlying TextWriter for the output device is created. But if the application makes no 
reference to the In and Error properties, then no objects are created for those devices. 


10.7.3 Automatically Implemented Properties 


■■ JONSKEET An early draft of the C# 3.0 specification referred to these properties 
as "automatic properties." This name was around for just long enough to stick, and is 
now much more widely used in the community than the full name. 


When a property is specified as an automatically implemented property, a hidden backing 
field is automatically available for the property, and the accessors are implemented to read 
from and write to that backing field. 


553 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


The example 

public class Point { 

public int X { get; set; } // Automatically implemented 

public int Y { get; set; } // Automatically implemented 

} 

is equivalent to the following declaration: 

public class Point { 
private int x; 
private int y; 

public int X { get { return x; } set { x = value; } } 

public int Y { get { return y; } set { y = value; } } 

} 

Because the backing field is inaccessible, if can be read and wriffen only fhrough fhe prop¬ 
erly accessors, even wifhin fhe confaining type. This means that automatically imple¬ 
mented read-only or write-only properties do not make sense and, therefore, are disallowed. 
If is possible fo sef fhe access level of each accessor differenfly. Thus fhe effecf of a read¬ 
only properly wifh a privafe backing field can be mimicked like fhis: 

public class ReadOnlyPoint { 

public int X { get; private set; } 

public int Y { get; private set; } 

public ReadOnlyPoint(int x, int y) { X = x; Y = y; } 

} 


“■ BILL WAGNER While fhe properfies are read-only, fhe underlying backing sfore 
is nof. Code inside ReadOnlyPoint does nof have fo obey fhe rules of immufabilify. 


■■ JON SKEET While fhis behavior mimics fhe effecf of a read-only properly fo 
ofher f 5 q)es, if's nof fhe same as fhe properly (or, indeed, fhe backing field) being 
genuinely read-only. I would welcome fhe abilify fo specify read-only properfies, 
perhaps in fhis form: 

public int X { get; readonly set; } 

This code would resulf in a read-only field being produced; use of fhe seller would be 
permiffed only wifhin fhe consfrucfor, where if would be compiled info direcf wrifes 
fo fhe backing field. If's unforfunafe fhaf creafing a genuinely immufable f 5 qie is cur- 
renfly more long-winded fhan creafing a mufable one. 


554 


www.it-ebooks.info 








10.7 Properties 


“■ PETER SESTOFT Automatically implemented properties are great because the 
properties can be used in object initializers (§7.6.10.2). Object initializers are particu¬ 
larly great for classical values such as coordinate pairs and triples, complex numbers, 
and similar items—that is, struct values. In general, however, we prefer structs to have 
immutable fields because they are copied on assignment and during parameter pass¬ 
ing. For this reason, I whole-heartedly support Jon's wish for a terse notation for read¬ 
only fields with automatically implemented accessors, with the proviso that the set 
accessor can be used in the constructor and in object initializers. 


This restriction also means that definite assignment of struct t 5 ^es with auto-implemented 
properties can be achieved only using the standard constructor of the struct, since assign¬ 
ing to the property itself requires the struct to be definitely assigned. This means that user- 
defined constructors must call the default constructor. 

10.7.4 Accessibility 

If an accessor has an accessor-modifier, the accessibility domain (§3.5.2) of the accessor is 
determined using the declared accessibility of the accessor-modifier. If an accessor does not 
have an accessor-modifier, the accessibility domain of the accessor is determined from the 
declared accessibility of the property or indexer. 

The presence of an accessor-modifier never affects member lookup (§7.3) or overload resolu¬ 
tion (§7.5.3). The modifiers on the property or indexer always determine which property 
or indexer is bound to, regardless of the context of the access. 

Once a particular property or indexer has been selected, the accessibility domains of the 
specific accessors involved are used to determine whether that usage is valid: 

• If the usage is as a value (§7.1.1), the get accessor must exist and be accessible. 

• If the usage is as the target of a simple assignment (§7.17.1), the set accessor must exist 
and be accessible. 

• If the usage is as the target of compound assignment (§7.17.2) or as the target of the ++ 
or - - operators (§7.5.9, §7.6.5), both the get accessor and the set accessor must exist and 
be accessible. 

In the following example, the property A. Text is hidden by the property B. Text, even in 
contexts where only the set accessor is called. In contrast, the property B.Count is not 
accessible to class M, so the accessible property A.Count is used instead. 


555 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


class A 

{ 

public string Text { 

get { return "hello"; } 
set { } 

} 

public int Count { 
get { return 5; } 
set { } 

} 

} 


class B: A 


{ 

private string text = "goodbye"; 

private int count = 0; 

new public string Text { 
get { return text; } 
protected set { text = value; } 

} 

new protected int Count { 
get { return count; } 
set { count = value; } 

} 

} 


class M 


static void Main() { 

B b = new B(); 
b.Count = 12; 
int i = b.Count; 
b.Text = "howdy"; 
string s = b.Text; 

} 

} 


// Calls A.Count set accessor 
// Calls A.Count get accessor 
// Error: B.Text set accessor is not accessible 
// Calls B.Text get accessor 


An accessor that is used to implement an interface may not have an accessor-modifier. If only 
one accessor is used to implement an interface, fhe ofher accessor may be declared wifh an 
accessor-modifier: 


public interface I 

{ 

string Prop { get; } 

} 


public class C: I 

{ 

public Prop { 

get { return "April"; } // Must not have a modifier here 
internal set {...} // Okay, because I.Prop has no set accessor 

} 

} 


556 


www.it-ebooks.info 




10.7 Properties 


10.7.5 Virtual, Sealed, Override, and Abstract Accessors 

A virtual property declaration specifies that the accessors of the property are virtual. The 
virtual modifier applies to both accessors of a read-write property—it is not possible for 
only one accessor of a read-write property to be virtual. 

An abstract property declaration specifies that the accessors of the property are virtual, 
but does not provide an actual implementation of the accessors. Instead, non-abstract 
derived classes are required to provide their own implementation for the accessors by 
overriding the property. Because an accessor for an abstract property declaration pro¬ 
vides no actual implementation, its accessor-body simply consists of a semicolon. 

A property declaration that includes both the abstract and override modifiers specifies 
that the property is abstract and overrides a base property. The accessors of such a property 
are also abstract. 

Abstract property declarations are permitted only in abstract classes (§10.1.1.1). The acces¬ 
sors of an inherited virtual property can be overridden in a derived class by including a 
property declaration that specifies an override directive. This is known as an overriding 
property declaration. An overriding property declaration does not declare a new property. 
Instead, it simply specializes the implementations of the accessors of an existing virtual 
property. 

An overriding property declaration must specify the exact same accessibility modifiers, 
type, and name as the inherited property. If the inherited property has only a single acces¬ 
sor (i.e., if the inherited property is read-only or write-only), the overriding property must 
include only that accessor. If the inherited property includes both accessors (i.e., if the 
inherited property is read-write), the overriding property can include either a single acces¬ 
sor or both accessors. 

An overriding property declaration may include the sealed modifier. Use of this modifier 
prevents a derived class from further overriding the property. The accessors of a sealed 
property are also sealed. 

Except for differences in declaration and invocation S 5 mtax, virtual, sealed, override, and 
abstract accessors behave exactly like virtual, sealed, override, and abstract methods. Spe¬ 
cifically, the rules described in §10.6.3, §10.6.4, §10.6.5, and §10.6.6 apply as if accessors 
were methods of a corresponding form: 

• A get accessor corresponds to a parameterless method with a return value of the prop¬ 
erty t 5 q)e and the same modifiers as the containing property. 

• A set accessor corresponds to a method with a single value parameter of the property 

type, a void return tyV^' same modifiers as the containing property. 


557 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


In the example 

abstract class A 
{ 

int y; 

public virtual int X { 
get { return 0; } 

} 

public virtual int Y { 
get { return y; } 
set { y = value; } 

} 

public abstract int Z { get; set; } 

} 

X is a virtual read-only property, Y is a virtual read-write property, and Z is an abstract 
read-write property. Because Z is abstract, the containing class A must also be declared as 
abstract. 

A class that derives from A is show below: 

class B: A 
{ 

int z; 

public override int X { 

get { return base.X + 1; } 

} 

public override int Y { 

set { base.Y = value < 0? 0: value; } 

} 

public override int Z { 
get { return z; } 
set { z - value; } 

} 

} 

Here, the declarations of X, Y, and Z are overriding properfy declarafions. Each properfy 
declarafion exactly matches the accessibility modifiers, type, and name of fhe correspond¬ 
ing inherifed properfy. The get accessor of X and fhe set accessor of Y use fhe base key¬ 
word fo access fhe inherifed accessors. The declarafion of Z overrides bofh absfracf 
accessors—fhus fhere are no oufsfanding absfracf function members in B, and B is permif- 
fed fo be a nonabsfracf class. 

When a properfy is declared as an override, any overridden accessors musf be accessible 
fo fhe overriding code. In addition, fhe declared accessibilify of bofh fhe properfy or 
indexer ifself, and of fhe accessors, musf mafch fhaf of fhe overridden member and acces¬ 
sors. For example: 


558 


www.it-ebooks.info 




10.8 Events 


public class B 

{ 

public virtual int P { 
protected set {... } 
get {...} 

} 

} 

public class D: B 

{ 

public override int P { 

protected set {...} // Must specify protected here 

get {...} // Must not have a modifier here 

} 

} 

10.8 Events 

An event is a member that enables an object or class to provide notifications. Clients can 
attach executable code for events by supplying event handlers. 

Events are declared using event-declarations: 

event-declaration: 

attributes^^i event-modifiers event type variable-declarators ; 
attributes^^i event-modifiers event type member-name 
{ event-accessor-declarations } 

event-modifiers: 

event-modifier 

event-modifiers event-modifier 

event-modifier: 

new 

public 

protected 

internal 

private 

static 

virtual 

sealed 

override 

abstract 

extern 


559 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


event-accessor-declarations: 

add-accessor-declaration remove-accessor-declaration 
remove-accessor-declaration add-accessor-declaration 

add-accessor-declaration: 
attributes , add block 

remove-accessor-declaration: 
attributes , remove block 

An event-declaration may include a set of attributes (§17), a valid combination of the four 
access modifiers (§10.3.5), and the new (§10.3.4), static (§10.6.2), virtual (§10.6.3), 
override (§10.6.4), sealed (§10.6.5), abstract (§10.6.6), and extern (§10.6.7) modifiers. 

Event declarations are subject to the same rules as method declarations (§10.6) with regard 
to valid combinations of modifiers. 

The type of an evenf declaration must be a delegate-type (§4.2), and that delegate-type must be 
at least as accessible as the event itself (§3.5.4). 

An evenf declaration may include event-accessor-declarations. However, if it does not, for 
non-extern, non-abstract events, the compiler supplies them automatically (§10.8.1); for 
extern events, the accessors are provided externally. 

An event declaration that omits event-accessor-declarations defines one or more events—one 
for each of the variable-declarators. The attributes and modifiers apply to all of the members 
declared by such an event-declaration. 

It is a compile-time error for an event-declaration to include both the abstract modifier and 
brace-delimited event-accessor-declarations. 

When an event declaration includes an extern modifier, the event is said to be an external 
event. Because an external event declaration provides no actual implementation, it is an 
error for it to include both the extern modifier and event-accessor-declarations. 

An event can be used as the left-hand operand of the += and -= operators (§7.17.3). These 
operators are used, respectively, to attach event handlers to or to remove event handlers 
from an event, and the access modifiers of fhe event control the contexts in which such 
operations are permitted. 

Since += and -= are the only operations that are permitted on an event outside the type that 
declares the event, external code can add and remove handlers for an event, but carmot in 
any other way obtain or modify fhe underlying list of evenf handlers. 


560 


www.it-ebooks.info 




10.8 Events 


In an operation of the form x += y or x -= y, when x is an event and the reference takes place 
outside the t 5 ^e that contains the declaration of x, the result of the operation has type void 
(as opposed to having the type of x, with the value of x after the assignment). This rule 
prohibits external code from indirectly examining the underlying delegate of an event. 

The following example shows how event handlers are attached to instances of the 
Button class: 

public delegate void EventHandler(object sender, EventArgs e); 

public class Button: Control 

{ 

public event EventHandler Click; 

} 

public class LoglnDialog: Form 

{ 

Button OkButton; 

Button CancelButton; 

public LoginDialogO { 

OkButton = new Button(...); 

OkButton.Click += new EventFlandler(OkButtonClick); 

CancelButton = new Button(...); 

CancelButton.Click += new EventHandler(CancelButtonClick); 

} 

void OkButtonClick(object sender, EventArgs e) { 

// Flandle OkButton.Click event 

} 

void CancelButtonClick(object sender, EventArgs e) { 

// Flandle CancelButton.Click event 

} 

} 

Here, the LoginDialog instance constructor creates two Button instances and attaches 
event handlers to the Click events. 


"■ CHRISTIAN NAGEL Memory leaks often result from wrong usage of events. If 
client objects attach to events but do not detach from them, and the reference to the 
client object is no longer used, the client object still carmot be reclaimed by the garbage 
collector because the reference by the publisher remains. This can be avoided by (1) 
detaching of events when the client object is no longer used, (2) a custom implementa¬ 
tion of the add and remove accessors using the WeakReference class holding the del¬ 
egate, or (3) the Weak Event pattern that is used by WPF with the IWeakEventListener 
interface. 


561 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


■■ JON SKEET I tend to think of (and explain) events as being like properties: 
They're a pair of mefhods (add and remove) fhaf fhe compiler knows how fo call 
using a shorfhand (+= and -=). Evenfs are more resfricfive fhan properfies in fhaf fhe 
fype has fo be a delegafe arid fhere musf always be bofh add and remove mefh¬ 
ods; fhere is no such thing as an "add-only" event in the way that you can have a 
read-only property. Other than those points, the similarities are strong—and yet prop¬ 
erties are generally very well understood, whereas events cause heaps of confusion. 1 
surmise fhaf field-like evenfs are fhe source of fhis problem. 


10.8.1 Field-like Events 

Wifhin fhe program fexf of fhe class or sfrucf fhaf confains fhe declarafion of an evenf, 
cerfain evenfs can be used like fields. To be used in fhis way, an evenf musf nof be abstract 
or extern, and musf nof explicifly include event-accessor-declarations. Such an evenf can be 
used in any confexf fhaf permifs a field. The field confains a delegafe (§15), which refers fo 
fhe lisf of evenf handlers fhaf have been added fo fhe evenf. If no evenf handlers have been 
added, fhe field confains null. 


■■ jON SKEET If aufomafically implemenfed properfies had been presenf in C# 
from fhe sfarf, 1 believe if would have made more sense for field-like evenfs fo be 
called "aufomafically implemenfed evenfs" wifh a synfax like fhis: 

public event EventHandler Click { add; remove; } 

This mighf have creafed less confusion around whaf an evenf really is. 


In fhe example 

public delegate void EventHandler(object sender, EventArgs e); 

public class Button: Control 
{ 

public event EventHandler Click; 

protected void OnClick(EventArgs e) { 
if (Click != null) Click(this, e); 

} 

public void Reset() { 

Click = null; 

} 

} 


562 


www.it-ebooks.info 








10.8 Events 


Click is used as a field within the Button class. As the example demonstrates, the field can 
be examined, modified, and used in delegate invocation expressions. The OnClick method 
in the Button class "raises" the Click event. The notion of raising an event is precisely 
equivalent to invoking the delegate represented by the event—thus there are no special 
language constructs for raising events. Note that the delegate invocation is preceded by a 
check that ensures the delegate is non-null. 

Outside the declaration of the Button class, the Click member can be used only on the left- 
hand side of the += and operators, as in 

b.Click += new EventHandler(...); 

which appends a delegate to the invocation list of the Click event, and 
b.Click -= new EventHandler(...); 

which removes a delegate from the invocation list of the Click event. 

When compiling a field-like event, the compiler automatically creates storage to hold the 
delegate, and creates accessors for the event that add or remove event handlers to the del¬ 
egate field. The addition and removal operations are thread safe, and may (but are not 
required to) be done while holding the lock (§8.12) on the containing object for an instance 
event, or the t 5 q)e object (§7.6.10.6) for a static event. 

Thus an instance event declaration of the form 

class X 
{ 

public event D Ev; 

} 

will be compiled to something equivalent to 

class X 
{ 

private D _Ev; // Field to hold the delegate 

public event D Ev { 
add { 

/* Add the delegate in a thread-safe way */ 

} 

remove { 

/* Remove the delegate in a thread-safe way */ 

} 

} 

} 


563 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


Within the class X, references to Ev on the left-hand side of fhe += and -= operafors cause 
fhe add and remove accessors fo be invoked. All ofher references fo Ev are compiled fo 

reference fhe hidden field_ Ev insfead. The name "_ Ev" is arbifrary; fhe hidden field 

could have any name or no name af all. 

10.8.2 Event Accessors 

Even! declarafions fypically omif event-accessor-declarations, as in fhe Button example 
above. One sifuafion for doing so involves fhe case in which fhe storage cosf of one field 
per even! is nof accepfable. In such cases, a class can include event-accessor-declarations and 
use a privafe mechanism for sforing fhe lisf of evenf handlers. 

The event-accessor-declarations of an evenf specify fhe execufable sfafemenfs associafed wifh 
adding and removing evenf handlers. 

The accessor declarafions consisf of an add-accessor-declaration and a remove-accessor- 
declaration. Each accessor declarafion consisfs of fhe token add or remove followed by a 
block. The block associafed wifh an add-accessor-declaration specifies fhe sfafemenfs fo exe- 
cufe when an evenf handler is added, and fhe block associafed wifh a remove-accessor- 
declaration specifies fhe sfafemenfs fo execufe when an evenf handler is removed. 

Each add-accessor-declaration and remove-accessor-declaration corresponds fo a mefhod wifh 
a single value paramefer of fhe evenf fype and a void refurn fype. The implicif paramefer 
of an evenf accessor is named value. When an evenf is used in an evenf assignmenf, fhe 
appropriate evenf accessor is used. Specifically, if fhe assignmenf operator is +=, fhen 
fhe add accessor is used; if fhe assignmenf operator is fhen fhe remove accessor is 
used. In eifher case, fhe righf-hand operand of fhe assignmenf operafor is used as fhe 
argumenf to the event accessor. The block of an add-accessor-declaration or a remove- 
accessor-declaration musf conform fo fhe rules for void mefhods described in §10.6.10. In 
parficular, return sfafemenfs in such a block are nof permiffed fo specify an expression. 

Since an evenf accessor implicifly has a paramefer named value, if is a compile-fime error 
for a local variable or consfanf declared in an evenf accessor fo have fhaf name. 

In fhe example 

class Control: Component 
{ 

// Unique keys for events 

static readonly object mouseDownEventKey = new object(); 
static readonly object mouseUpEventKey = new object(); 

// Return event handler associated with key 
protected Delegate GetEventHandler(object key) {...} 

// Add event handler associated with key 

protected void AddEventHandler(object key. Delegate handler) {...} 


564 


www.it-ebooks.info 




10.8 Events 


// Remove event handler associated with key 

protected void RemoveEventHandler(object key^ Delegate handler) {...} 
// MouseDown event 

public event MouseEventHandler MouseDown { 

add { AddEventHandler(mouseDownEventKeyj value); } 
remove { RemoveEventHandler(mouseDownEventKeyj value); } 

} 


// MouseUp event 

public event MouseEventHandler MouseUp { 

add { AddEventHandler(mouseUpEventKey, value); } 
remove { RemoveEventHandler(mouseUpEventKey, value); } 

} 

// Invoke the MouseUp event 

protected void OnMouseUp(MouseEventArgs args) { 

MouseEventHandler handler; 

handler = (MouseEventHandler)GetEventHandler(mouseUpEventKey); 
if (handler != null) 

handler(thlSj args); 

} 

} 

the Control class implements an internal storage mechanism for events. The 
AddEventHandler method associates a delegate value with a key, the GetEventHandler 
method returns the delegate currently associated with a key, and the RemoveEventHandler 
method removes a delegate as an event handler for the specified event. Presumably, the 
underlying storage mechanism is designed such that there is no cost for associating a null 
delegate value with a key, and thus unhandled events consume no storage. 


10.8.3 Static and Instance Events 

When an event declaration includes a static modifier, the event is said to be a static event. 
When no static modifier is present, the event is said to be an instance event. 

A static event is not associated with a specific instance, and it is a compile-time error to 
refer to this in the accessors of a static event. 

An instance event is associated with a given instance of a class, and this instance can be 
accessed as this (§7.6.7) in the accessors of that event. 

When an event is referenced in a member-access (§7.6.4) of the form E. M, if M is a static event, 
E must denote a t 5 ^e containing M; if M is an instance event, E must denote an instance of a 
type containing M. 

The differences between static and instance members are discussed further in §10.3.7. 


565 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


10.8.4 Virtual, Sealed, Override, and Abstract Accessors 

A virtual event declaration specifies that the accessors of fhat event are virtual. The 
virtual modifier applies to both accessors of an event. 

An abstract event declaration specifies fhat the accessors of the event are virtual, but does 
not provide an actual implementation of fhe accessors. Instead, non-abstract derived 
classes are required to provide their own implementation for the accessors by overriding 
the event. Because an abstract event declaration provides no actual implementation, it 
cannot provide brace-delimited event-accessor-declarations. 

An event declaration that includes both the abstract and override modifiers specifies that 
the event is abstract and overrides a base event. The accessors of such an event are also 
abstract. 

Abstract event declarations are permitted only in abstract classes (§10.1.1.1). 

The accessors of an inherifed virfual evenf can be overridden in a derived class by includ¬ 
ing an evenf declaration that specifies an override modifier. This is known as an overrid¬ 
ing event declaration. An overriding event declaration does not declare a new event. 
Instead, it simply specializes the implementations of the accessors of an exisfing virfual 
evenf. 

An overriding evenf declarafion must specify fhe exact same accessibility modifiers, t 5 q)e, 
and name as fhe overridden event. 

An overriding event declaration may include the sealed modifier. Use of this modifier 
prevenfs a derived class from furfher overriding fhe evenf. The accessors of a sealed event 
are also sealed. 

It is a compile-time error for an overriding event declaration to include a new modifier. 

Except for differences in declaration and invocation S 5 mtax, virtual, sealed, override, and 
abstract accessors behave exactly like virtual, sealed, override, and abstract methods. Spe¬ 
cifically, the rules described in §10.6.3, §10.6.4, §10.6.5, and §10.6.6 apply as if accessors 
were mefhods of a corresponding form. Each accessor corresponds to a method with a 
single value parameter of the event type, a void return type, and the same modifiers as the 
containing event. 


10,9 Indexers 

An indexer is a member that enables an object to be indexed in the same way as an array. 
Indexers are declared using indexer-declarations: 


566 


www.it-ebooks.info 




10.9 Indexers 


indexer-declaration: 

attributesindexer-modifiers^^^ indexer-declarator { accessor-declarations } 

indexer-modifiers: 

indexer-modifier 

indexer-modifiers indexer-modifier 

indexer-modifier: 

new 

public 

protected 

internal 

private 

virtual 

sealed 

override 

abstract 

extern 

indexer-declarator: 

type this [ formal-parameter-list ] 

type interface-type . this [ formal-parameter-list ] 

An indexer-declaration may include a set of attributes (§17), a valid combination of the four 
access modifiers (§10.3.5), and the new (§10.3.4), virtual (§10.6.3), override (§10.6.4), 
sealed (§10.6.5), abstract (§10.6.6), and extern (§10.6.7) modifiers. 

Indexer declarations are subject to the same rules as method declarations (§10.6) with 
regard to valid combinations of modifiers, with the one exception being that the static 
modifier is not permitted on an indexer declaration. 

The modifiers virtual, override, and abstract are mutually exclusive except in one case. 
The abstract and override modifiers maybe used together so that an abstract indexer can 
override a virtual one. 

The type of an indexer declaration specifies the element type of the indexer introduced by 
the declaration. Unless the indexer is an explicit interface member implementation, the 
type is followed by the keyword this. For an explicit interface member implementation, 
the type is followed by an interface-type, a ".", and the keyword this. Unlike other mem¬ 
bers, indexers do not have user-defined names. 

The formal-parameter-list specifies the parameters of the indexer. The formal parameter list 
of an indexer corresponds to that of a method (§10.6.1), except that at least one parameter 
must be specified, and that the ref and out parameter modifiers are not permitted. 


567 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


The type of an indexer and each of fhe f 5 ^es referenced in the formal-parameter-list musf be 
af leasf as accessible as fhe indexer if self (§3.5.4). 

The accessor-declarations (§10.7.2), which musf be enclosed in "{" and "}" tokens, declare 
fhe accessors of fhe indexer. The accessors specify fhe execufable sfafemenfs associafed 
wifh reading and wrifing indexer elemenfs. 

Even fhough fhe S 5 mfax for accessing an indexer elemenf is fhe same as fhaf for an array 
elemenf, an indexer elemenf is nof classified as a variable. Thus if is nof possible fo pass an 
indexer elemenf as a ref or out argumenf. 

The formal parameter lisf of an indexer defines fhe signafure (§3.6) of fhe indexer. Specifi¬ 
cally, fhe signafure of an indexer consisfs of fhe number and fypes of ifs formal parameters. 
The elemenf fype and names of fhe formal paramefers are nof parf of an indexer's 
signafure. 

The signafure of an indexer musf differ from fhe signafures of all ofher indexers declared 
in fhe same class. 

Indexers and properties are very similar in concepf, buf differ in fhe following ways: 

• A properly is identified by ifs name, whereas an indexer is identified by ifs signafure. 

• A properly is accessed fhrough a simple-name (§7.6.2) or a member-access (§7.6.4), whereas 
an indexer elemenf is accessed fhrough an element-access (§7.6.6.2). 

• A properly can be a static member, whereas an indexer is always an insfance 
member. 

• A get accessor of a properly corresponds fo a mefhod wifh no paramefers, whereas a get 
accessor of an indexer corresponds fo a mefhod wifh fhe same formal parameter lisf as 
fhe indexer. 

• A set accessor of a properly corresponds fo a mefhod wifh a single paramefer named 
value, whereas a set accessor of an indexer corresponds fo a mefhod wifh fhe same 
formal paramefer lisf as fhe indexer, plus an additional paramefer named value. 

• If is a compile-time error for an indexer accessor to declare a local variable with the same 
name as an indexer parameter. 

• In an overriding property declaration, the inherited property is accessed using the S 5 m- 
tax base.P, where P is the property name. In an overriding indexer declaration, the 
inherited indexer is accessed using the S 5 mtax base[E], where E is a comma-separated 
list of expressions. 

Aside from these differences, all rules defined in §10.7.2 and §10.7.3 apply to indexer acces¬ 
sors as well as to property accessors. 


568 


www.it-ebooks.info 




10.9 Indexers 


■■ JONSKEET I find it odd that events can be static (but almost never are) but index¬ 
ers can't. For example, it might have made sense for Encoding.GetEncoding(string) 
to be present as a static indexer. Indeed, I'd expect static indexers to primarily act as 
factory members for the t5q3e they're declared in. A method is a perfectly adequate 
alternative in most places, but the prohibition is a little strange. 


When an indexer declaration includes an extern modifier, the indexer is said to be an 
external indexer. Because an external indexer declaration provides no actual implementa¬ 
tion, each of its accessor-declarations consists of a semicolon. 

The example below declares a BitArray class that implements an indexer for accessing the 
individual bits in the bit array. 

using System; 

class BitArray 
{ 

int[] bits; 
int length; 

public BitArray(int length) { 

if (length < 0) throw new ArgumentException(); 
bits = new int[((length - 1) >> 5) + 1]; 
this.length = length; 

} 

public int Length { 

get { return length; } 

} 

public bool this[int index] { 
get { 

if (index < 0 || index >= length) { 

throw new IndexOutOfRangeException(); 

} 

return (bits[index >> 5] & 1 << index) != 0; 

} 

set { 

if (index < 0 || index >= length) { 

throw new IndexOutOfRangeException(); 

} 

if (value) { 

bits[index >> 5] |= 1 << index; 

} 

else { 

bits[index >> 5] &= ~(1 << index); 

} 

} 

} 

} 


569 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


An instance of the BitArray class consumes substantially less memory than a correspond¬ 
ing bool [ ] (since each value of the former occupies only one bit instead of the latter's one 
byte), but it permits the same operations as a bool [ ]. 

The following CountPrimes class uses a BitArray and the classical "sieve" algorithm to 
compute the number of primes between 1 and a given maximum: 

class CountPrimes 

{ 

static int Count(int max) { 

BitArray flags = new BitArray(max + 1); 
int count = 1; 

for (int i = 2; i <= max; i++) { 
if (!flags[i]) { 

for (int j = i * 2; j <= max; j += i) flags[j] = true; 
count++; 

} 

} 

return count; 

} 

static void Main(string[] args) { 
int max = int.Parse(args[0]); 
int count = Count(max); 

Console.WriteLineC'Found {0} primes between 1 and {1}", count, max); 

} 

} 

Note that the syntax for accessing elements of the BitArray is precisely the same as for a 
bool[]. 

The following example shows a 26 x 10 grid class that has an indexer with two parameters. 
The first parameter is required to be an uppercase or lowercase letter in the range A-Z, and 
the second is required to be an integer in the range 0-9. 

using System; 

class Grid 

{ 

const int NumRows = 26; 
const int NumCols = 10; 

int[,] cells = new int[NumRows, NumCols]; 

public int this[char c, int col] { 
get { 

c = Char.ToUpper(c); 
if (c < 'A' I I c > 'Z') { 

throw new ArgumentException(); 

} 


570 


www.it-ebooks.info 




10.10 Operators 


if (col < 0 I I col >= NumCols) { 

throw new InclexOutOfRangeException(); 

} 

return cells[c - 'A', col]; 

} 

set { 

c = Char.ToUpper(c); 
if (c < 'A' I I c > 'Z') { 

throw new ArgumentException(); 

} 

if (col < 0 I I col >= NumCols) { 

throw new InclexOutOfRangeException(); 

} 

cells[c - 'A'j col] = value; 

} 

} 

} 

10.9.1 Indexer Overloading 

The indexer overload resolution rules are described in §7.5.2. 

10.10 Operators 

An operator is a member that defines the meaning of an expression operafor fhaf can be 
applied fo insfances of fhe class. Operafors are declared using operator-declarations: 

operator-declaration: 

attributes^^i operator-modifiers operator-declarator operator-body 

operator-modifiers: 

operator-modifier 

operator-modifiers operator-modifier 

operator-modifier: 

public 

static 

extern 

operator-declarator: 

unary-operator-declarator 

binary-operator-declarator 

conversion-operator-declarator 


571 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


unary-operator-declarator: 

type operator overloadable-unary-operator ( type identifier ) 

overloadable-unary-operator: one of 

+ - ! ~ ++ -- true false 

binary-operator-declarator: 

type operator overloadable-binary-operator ( type identifier , type identifier ) 

overloadable-binary-operator: 

+ 

* 

/ 

% 

St 

I 

A 

<< 

right-shift 

! = 

> 

< 

< = 

conversion-operator-declarator: 

implicit operator type ( type identifier ) 

explicit operator type ( type identifier ) 

operator-body: 

block 


There are three categories of overloadable operators: unary operators (§10.10.1), binary 
operators (§10.10.2), and conversion operators (§10.10.3). 

When an operator declaration includes an extern modifier, the operator is said to be an 
external operator. Because an external operator provides no actual implementation, its 
operator-body consists of a semicolon. For all ofher operafors, fhe operator-body consists of a 
block, which specifies fhe sfafements to execute when the operator is invoked. The block of 
an operator must conform to the rules for value-refuming mefhods described in §10.6.10. 


572 


www.it-ebooks.info 




10.10 Operators 


The following rules apply to all operator declarations: 

• An operator declaration must include both a public and a static modifier. 

• The parameter(s) of an operator must be value parameters. It is a compile-time error for 
an operator declaration to specify ref or out parameters. 

• The signature of an operator (§10.10.1, §10.10.2, §10.10.3) must differ from the signatures 
of all other operators declared in the same class. 

• All types referenced in an operator declaration must be at least as accessible as the 
operator itself (§3.5.4). 

• It is an error for the same modifier to appear multiple times in an operator declaration. 

Each operator category imposes additional restrictions, as described in the following 
sections. 

Like other members, operators declared in a base class are inherited by derived classes. 
Because operator declarations always require the class or struct in which the operator 
is declared to participate in the signature of the operator, it is not possible for an operator 
declared in a derived class to hide an operator declared in a base class. Thus the new modi¬ 
fier is never required, and therefore never permitted, in an operator declaration. 

Additional information on unary and binary operators can be found in §7.3. 

Additional information on conversion operators can be found in §6.4. 

10.10.1 Unary Operators 

The following rules apply to unary operator declarations, where T denotes the instance 
type of the class or struct that contains the operator declaration: 

• A unary +, -, !, or ~ operator must take a single parameter of type T or T ? and can return 
any t 5 q)e. 

• A unary ++ or - - operator must take a single parameter of type T or T ? and must return 
that same t 5 q)e or a t 5 q)e derived from it. 

• A unary true or false operator must take a single parameter of type T or T? and must 
return t 5 q)e bool. 

The signature of a unary operator consists of the operator token (+, -, !, ~, ++, --, true, or 
false) and the type of the single formal parameter. The return type is not part of a unary 
operator's signature, nor is the name of the formal parameter. 


573 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


The true and false unary operators require pairwise declaration. A compile-time error 
occurs if a class declares one of these operators without also declaring the other. The true 
and false operators are described further in §7.12.2 and §7.20. 

The following example shows an implemenfafion and subsequenf usage of operator ++ for 
an infeger vector class: 

public class IntVector 
{ 

public IntVector(int length) {...} 

public int Length {...} // Read-only property 

public int this[int index] {...} // Read-write indexer 

public static IntVector operator ++(IntVector iv) { 

IntVector temp = new IntVector(iv.Length); 
for (int i = 0; i < iv.Length; i++) 
temp[i] = iv[i] + 1; 
return temp; 

} 

} 

class Test 
{ 

static void Main() { 

IntVector ivl = new IntVector(4); // Vector of 4 x 0 

IntVector iv2; 

iv2 = ivl++; 
iv2 = ++ivl; 

} 

} 

Nofe how fhe operator mefhod refums fhe value produced by adding 1 to fhe operand, jusf 
like the postfix increment and decrement operators (§7.6.9) and the prefix increment and 
decrement operators (§7.7.5). Unlike in C++, this method need not modify the value of its 
operand directly. In fact, modifying the operand value would violate the standard seman¬ 
tics of the postfix increment operator. 

10.10.2 Binary Operators 

The following rules apply to binary operator declarations, where T denotes the instance 
type of the class or struct that contains the operator declaration: 

• A binary nonshift operator must take two parameters, at least one of which must have 
type T or T?, and can return any t 5 y)e. 

• A binary << or >> operator must take two parameters, the first of which must have type 
T or T? and the second of which must have t 5 q)e int or int ?, and can return any type. 


// iv2 contains 4x0, ivl contains 4x1 
// iv2 contains 4x2, ivl contains 4x2 


574 


www.it-ebooks.info 




10.10 Operators 


The signature of a binary operator consists of the operator token (+, *, /, %,&, \,«, >>, 

=-, ! >, <, >=, or <=) and the t 5 ^es of the two formal parameters. The return t 5 ^e and the 

names of the formal parameters are not part of a binary operator's signature. 

Certain binary operators require pairwise declaration. For every declaration of either oper¬ 
ator of a pair, there must be a matching declaration of the other operator of the pair. Two 
operator declarations match when they have the same return type and the same type for 
each parameter. The following operators require pairwise declaration: 

• operator == and operator ! = 

• operator > and operator < 

• operator >= and operator < = 


“■ ERIC LIPPERT It is tempting to make a comparison operator on class Clothing 
that can represent Socks, Shoes, Shirt, Tie, and Hat, and then define a user-defined 
comparison that makes Socks < Shoes, Shirt < Tie, and everything else equal. The 
hope is that sorting an array of these items will produce a sensible ordering—that 
Socks always go on before Shoes, Shirts go on before Ties, but everything else can be 
in any order. But this comparison is not logically consistent: If Hat equals Socks, Hat 
equals Shoes, and Socks is smaller than Shoes then logically Hat must be smaller than 
Hat, which is nonsensical. Most sorting algorithms are written with the assumption 
that the comparison operator defines a total ordering-, some algorithms crash, run for¬ 
ever, or give nonsensical results when given a broken comparison operator. If you 
want to implement a partial order sort, it is wise to do it via some mechanism other than 
overloading the comparison operators. 


10.10.3 Conversion Operators 

A conversion operator declaration introduces a user-defined conversion (§6.4), which aug¬ 
ments the predefined implicit and explicit conversions. 

A conversion operator declaration that includes the implicit keyword introduces a user- 
defined implicit conversion. Implicit conversions can occur in a variety of situations, 
including function member invocations, cast expressions, and assignments. This is 
described further in §6.1. 


“■ BILL WAG N E R Implicit conversions should always succeed and never lose infor¬ 
mation because they will be called automatically, without the client coders knowing it. 
Implicit conversions should never involve expensive operations for the same reason. 


575 


www.it-ebooks.info 


10. Classes 








10. Classes 


10. Classes 


■■ JONSKEET As noted in §6.1.2, some implicit conversions from integral types to 
float or double can lose information. That possibility shouldn't be used as an excuse 
for your own user-defined implicif conversions losing informafion, fhough. 


A conversion operafor declarafion fhat includes fhe explicit keyword infroduces a user- 
defined explicif conversion. Explicif conversions can occur in casf expressions, and are 
described further in §6.2. 


“■ BILL WAG N E R In contrast to implicit conversions, explicit conversions can fail, 
or can lose informafion, because fhe user musf explicifly ask for fhe conversion. 


A conversion operator converts from a source type, indicated by the parameter t 5 ^e of fhe 
conversion operafor, to a target type, indicated by the return type of the conversion 
operator. 

For a given source type S and target type T, if S or T are nullable f 5 ^es, lef and refer fo 
fheir underlying types; otherwise, and are equal to S and T, respectively. A class or 
struct is permitted to declare a conversion from a source type S to a target type T only if all 
of the following are frue: 

• Sg and Tg are differenf f 5 q)es. 

• Eifher or is fhe class or sfrucf type in which the operator declaration takes place. 

• Neither nor is an interface-type. 

• Excluding user-defined conversions, a conversion does nof exisf from S fo T or from 
T fo S. 


For fhe purposes of fhese rules, any t 5 q)e paramefers associafed wifh S or T are considered 
fo be unique fypes fhaf have no inherifance relafionship wifh ofher t 5 q)es, and any con- 
sfrainfs on fhose f 5 q)e paramefers are ignored. 

In fhe example 

class C<T> {...} 
class D<T>; C<T> 


} 


public static 
public static 
public static 


implicit 

implicit 

implicit 


operator C<int>(D<T> value) {...} 
operator C<string>(D<T> value) {. 
operator C<T>(D<T> value) {...} 


// Okay 
} // Okay 
// Error 


576 


www.it-ebooks.info 








10.10 Operators 


the first two operator declarations are permitted because, for fhe purposes of §10.9.3, T has 
no relafionship fo int and string, respectively; in both cases, they are considered unique 
types. However, the third operator is an error because C<T> is the base class of D<T>. 

From fhe second rule, if follows fhaf a conversion operator musf converf eifher fo or from 
fhe class or sfrucf type in which the operator is declared. For example, it is possible for a 
class or strucf type C to define a conversion from C fo int and from int fo C, buf nof from 
int fo bool. 

If is nof possible fo direcfly redefine a predefined conversion. Thus conversion operafors 
are nof allowed fo converf from or fo object because implicif and explicif conversions 
already exisf between object and all ofher fypes. Likewise, neifher fhe source nor fhe far- 
gef fypes of a conversion can be a base type of fhe ofher, since a conversion would fhen 
already exisf. 

However, if is possible fo declare operafors on generic fypes fhaf, for parficular f 5 q)e argu- 
menfs, specify conversions fhaf already exisf as predefined conversions. In fhe example 

struct Convertible<T> 

{ 

public static implicit operator Convertible<T>(T value) {...} 
public static explicit operator T(Convertible<T> value) {...} 

} 

when fjq^e object is specified as a fype argumenf for T, fhe second operator declares a 
conversion fhaf already exisfs (an implicif, and fherefore also an explicif, conversion exisfs 
from any fjq^e fo type object). 

In cases where a predefined conversion exisfs befween two fjq^es, any user-defined conver¬ 
sions between fhose fypes are ignored. Specifically: 

• If a predefined implicif conversion (§6.1) exisfs from fype S fo type T, all user-defined 
conversions (implicif or explicif) from S fo T are ignored. 

• If a predefined explicif conversion (§6.2) exisfs from f 5 q)e S fo fjq^e T, any user-defined 
explicif conversions from S fo T are ignored. Furfhermore: 

- If T is an inferface t 5 q)e, user-defined implicif conversions from S fo T are ignored. 

- Ofherwise, user-defined implicif conversions from S fo T are still considered. 

For all f 5 q)es excepf object, fhe operafors declared by fhe ConvertiblecT> fype above do 
nof conflicf wifh predefined conversions. For example: 

void F(int i, Convertible<int> n) { 


n; 

// 

Error 



(int)n; 

// 

User-defined 

explicit 

conversion 

i; 

// 

User-defined 

implicit 

conversion 

(Convertible<int>)i; 

// 

User-defined 

implicit 

conversion 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


However, for type object, predefined conversions hide the user-defined conversions in all 
cases but one: 

void F(object o, Convertible<object> n) { 

o = n; // Predefined boxing conversion 

o = (object)n; // Predefined boxing conversion 

n = o; // User-defined implicit conversion 

n = (Convertible<object>)o; // Predefined unboxing conversion 

} 

User-defined conversions are not allowed to convert from or to interface-types. In particular, 
this restriction ensures that no user-defined transformations occur when converting to an 
interface-type, and that a conversion to an interface-type succeeds only if the object being 
converted actually implements the specified interface-type. 

The signature of a conversion operator consists of the source type and the target type. 
(Note that this is the only form of member for which the return type participates in the 
signature.) The implicit or explicit classification of a conversion operator is not part of 
the operator's signature. Thus a class or struct carmot declare both an implicit and an 
explicit conversion operator with the same source and target t 5 ^es. 

In general, user-defined implicit conversions should be designed to never throw excep¬ 
tions and never lose information. If a user-defined conversion can give rise to exceptions 
(for example, because the source argument is out of range) or loss of information (such as 
discarding high-order bits), then that conversion should be defined as an explicit 
conversion. 

In the example 

using System; 

public struct Digit 
{ 

byte value; 

public Digit(byte value) { 

if (value < 0 || value > 9) throw new ArgumentException(); 
this.value = value; 

} 

public static implicit operator byte(Digit d) { 
return d.value; 

} 

public static explicit operator Digit(byte b) { 
return new Digit(b); 

} 

} 


578 


www.it-ebooks.info 




10.11 Instance Constructors 


the conversion from Digit to byte is implicit because it never throws exceptions or loses 
information, but the conversion from byte to Digit is explicit because Digit can represent 
only a subset of the possible values of a byte. 


10.11 Instance Constructors 

An instance constructor is a member that implements the actions required to initialize an 
instance of a class. Instance constructors are declared using constructor-declarations: 

constructor-declaration: 

attributes^^i constructor-modifiers^^^ constructor-declarator constructor-body 

constructor-modifiers: 

constructor-modifier 

constructor-modifiers constructor-modifier 

constructor-modifier: 

public 

protected 

internal 

private 

extern 

constructor-declarator: 

identifier ( formal-parameter-list) constructor-initializer^^ 

constructor-initializer: 

: base ( argument-list ) 

: this ( argument-list ) 

constructor-body: 

block 


A constructor-declaration may include a set of attributes (§17), a valid combination of the four 
access modifiers (§10.3.5), and an extern (§10.6.7) modifier. A constructor declaration is not 
permitted to include the same modifier multiple times. 

The identifier of a constructor-declarator must name the class in which the instance construc¬ 
tor is declared. If any other name is specified, a compile-time error occurs. 


579 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


The optional formal-parameter-Ust of an instance constructor is subject to the same rules as 
the formal-parameter-list of a method (§10.6). The formal parameter list defines the signature 
(§3.6) of an instance constructor and governs the process whereby overload resolution 
(§7.5.2) selects a particular instance constructor in an invocation. 

Each of the t 5 ^es referenced in the formal-parameter-list of an instance constructor must be 
at least as accessible as the constructor itself (§3.5.4). 

The optional constructor-initializer specifies another instance constructor to invoke before 
executing the statements given in the constructor-body of this instance constructor. This is 
described further in §10.11.1. 

When a constructor declaration includes an extern modifier, the constructor is said to be 
an external constructor. Because an external constructor declaration provides no actual 
implementation, its constructor-body consists of a semicolon. For all other constructors, the 
constructor-body consists of a block that specifies the statements to initialize a new instance 
of the class. This corresponds exactly to the block of an instance method with a void return 
type (§10.6.10). 

Instance constructors are not inherited. Thus a class has no instance constructors other 
than those actually declared in the class. If a class contains no instance constructor declara¬ 
tions, a default instance constructor is automatically provided (§10.11.4). 

Instance constructors are invoked by object-creation-expressions (§7.6.10.1) and through con¬ 
structor-initializers. 

10.11.1 Constructor Initializers 

All instance constructors (except those for class object) implicitly include an invocation of 
another instance constructor immediately before the constructor-body. The constructor to 
implicitly invoke is determined by the constructor-initializer: 

• An instance constructor initializer of the form base {argument-list causes an instance 
constructor from the direct base class to be invoked. That constructor is selected using 
argument-list and the overload resolution rules of §7.5.3. The set of candidate instance 
constructors consists of all accessible instance constructors contained in the direct base 
class, or the default constructor (§10.11.4) if no instance constructors are declared in the 
direct base class. If this set is empty, or if a single best instance constructor carmot be 
identified, a compile-time error occurs. 

• An instance constructor initializer of the form this {argument-list causes an instance 
constructor from the class itself to be invoked. The constructor is selected using 
argument-list and the overload resolution rules of §7.5.3. The set of candidate instance 


www.it-ebooks.info 




10.11 Instance Constructors 


constructors consists of all accessible instance constructors declared in the class itself. If 
this set is empty, or if a single best instance constructor carmot be identified, a compile¬ 
time error occurs. If an instance constructor declaration includes a constructor initializer 
that invokes the constructor itself, a compile-time error occurs. 


■■ VLADIMIR RESHETNIKOV An argument in a constructor-initializer can be of t 5 ^e 
dynamic only if the argument has a ref or out modifier; otherwise, a compile-time 
error occurs (CS1975). Thus a constructor-initializer is never d 5 mamically dispatched. 


If an instance constructor has no constructor initializer, a constructor initializer of the form 
base() is implicitly provided. Thus an instance constructor declaration of the form 

c(...) {...} 

is exactly equivalent to 
C(...): baseO {...} 

The scope of the parameters given by the formal-parameter-list of an instance constructor 
declaration includes the constructor initializer of that declaration. Thus a constructor ini¬ 
tializer is permitted to access the parameters of the constructor. For example: 

class A 
{ 

public A(int x, int y) {} 

} 

class B: A 
{ 

public B(int x, int y): base(x + y, x - y) {} 

} 

An instance constructor initializer carmot access the instance being created. Therefore it is 
a compile-time error to reference this in an argument expression of the constructor initial¬ 
izer, as is it a compile-time error for an argument expression to reference any instance 
member through a simple-name. 

10.11.2 Instance Variable Initializers 

When an instance constructor has no constructor initializer, or it has a constructor initial¬ 
izer of the form base (...), that constructor implicitly performs the initializations specified 
by the variable-initializers of the instance fields declared in its class. This corresponds to a 
sequence of assignments that are executed immediately upon entry to the constructor and 
before the implicit invocation of the direct base class constructor. The variable initializers 
are executed in the textual order in which they appear in the class declaration. 


581 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


10.11.3 Constructor Execution 

Variable initializers are transformed into assignment statements, and these assignment 
statements are executed before the invocation of the base class instance constructor. This 
ordering ensures that all instance fields are initialized by their variable initializers before 
any statements that have access to that instance are executed. 

Given the example 

using System; 

class A 
{ 

public A() { 

PrintFieldsO; 

} 

public virtual void PrintFieldsO {} 

} 

class B: A 
{ 

int X = 1; 
int y; 

public B() { 

y = -I; 

} 

public override void PrintFieldsO { 

Console.WriteLlneC'x = {0}, y = {1}", x, y); 

} 

} 

when new B() is used to create an instance of B, the following output is produced: 

X = 1, y = 0 

The value of x is 1 because fhe variable initializer is executed before fhe base class instance 
constructor is invoked. However, the value of y is 0 (the default value of an int) because 
fhe assignment to y is not executed until after the base class constructor returns. 

It is useful to think of instance variable initializers and constructor initializers as state¬ 
ments that are automatically inserted before the constructor-body. The example 

using System; 

using System.Collections; 

class A 
{ 

int X = 1, y = -1, count; 

public A() { 
count = 0; 

} 


582 


www.it-ebooks.info 




10.11 Instance Constructors 


public A(int n) { 
count = n; 

} 

} 

class B: A 

{ 

double sqrt2 = Math.Sqrt(2.0); 

ArrayList items = new ArrayList(100); 
int max; 

public B(): this(100) { 
items.Add("default"); 

} 

public B(int n): base(n - 1) { 
max = n; 

} 

} 

contains several variable initializers; it also contains constructor initializers of both forms 
(base and this). The example corresponds to the code shown below, where each comment 
indicates an automatically inserted statement (the syntax used for the automatically 
inserted constructor invocations isn't valid, but merely serves to illustrate the 
mechanism). 

using System.Collections; 

class A 

{ 

int Xj y, count; 
public A() { 

X = l; 

y = -i; 

objectO; 
count = 0; 

} 

public A(int n) { 

X = I; 

y = -i; 

ObjectO; 
count = n; 

} 

} 

class B: A 

{ 

double sqrt2; 

ArrayList items; 
int max; 


// Variable initializer 
// Variable initializer 
// Invoke object() constructor 


// Variable initializer 
// Variable initializer 
// Invoke objectO constructor 


public BO: this(100) { 

B(100); // Invoke B(int) constructor 

items.Add("default"); 

} 


583 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


public B(int n): base(n - 1) { 

sqrt2 = Math.Sqrt(2.0); // Variable initializer 

items = new ArrayList(100); // Variable initializer 
A(n - 1); // Invoke A(int) constructor 

max = n; 

} 

} 

10.11.4 Default Constructors 

If a class contains no instance constructor declarations, a default instance constructor is 
automatically provided. That default constructor simply invokes the parameterless con¬ 
structor of the direct base class. If the direct base class does not have an accessible param¬ 
eterless instance constructor, a compile-time error occurs. If the class is abstract, then the 
declared accessibility for the default constructor is protected. Otherwise, the declared 
accessibility for the default constructor is public. Thus the default constructor is always of 
the form 

protected C(): base() {} 
or 

public C(): base() {} 
where C is the name of the class. 

In the example 

class Message 
{ 

object sender; 
string text; 

} 

a default constructor is provided because the class contains no instance constructor decla¬ 
rations. Thus the example is precisely equivalent to 

class Message 
{ 

object sender; 
string text; 

public Message(): base() {} 

} 

10.11.5 Private Constructors 

When a class T declares only private instance constructors, it is not possible for classes 
outside the program text of T to derive from T or to directly create instances of T. Thus, if a 


584 


www.it-ebooks.info 




10.11 Instance Constructors 


class contains only static members and isn't intended to be instantiated, adding an empty 
private instance constructor will prevent instantiation. For example: 

public class Trig 
{ 

private Trig() {} // Prevent instantiation 

public const double PI = 3.14159265358979323846; 

public static double Sin(double x) {...} 
public static double Cos(double x) {...} 
public static double Tan(double x) {...} 

} 

The Trig class groups related methods and constants, but is not intended to be instantiated. 
Therefore it declares a single empty private instance constructor. At least one instance con¬ 
structor must be declared to suppress the automatic generation of a default constructor. 


“■ BILL WAGNER If a class is not meant to be instantiated, it would be better to 
make it a static class. However, if you are implementing the singleton pattern, a 
private constructor ensures that only your factory method can create the singleton 
object. 


■■ JOSEPH ALBAHARI If the goal is simply to prevent instantiation, an easier option 
is to declare the class as static. 

Private constructors also have a subtler purpose, which relies on the fact that a private 
constructor can still be invoked from static members of the same class. Sometimes 
exposing static methods as the only public means of insfantiating a class offers certain 
advantages. For example, with immutable objects, this approach can be used to imple¬ 
ment a transparent object caching system. 


10.11.6 Optional Instance Constructor Parameters 

The this (...) form of constructor initializer is commonly used in conjunction with over¬ 
loading to implement optional instance constructor parameters. In the example 

class Text 
{ 

public Text(): this(0, 0, null) {} 

public Text(int x, int y): this(x, y, null) {} 

public Text(int x, int y, string s) { 

// Actual constructor implementation 

} 

} 


585 


www.it-ebooks.info 


10. Classes 








10. Classes 


10. Classes 


the first two instance constructors merely provide the default values for the missing argu¬ 
ments. Both use a this (...) constructor initializer to invoke the third instance constructor, 
which actually does the work of initializing the new instance. The effect is that of optional 
constructor parameters: 

Text tl = new Text(); // Same as Text(0, 0, null) 

Text t2 = new Text(5, 10); // Same as Text(5, 10, null) 

Text t3 = new Text(5, 20, "Hello"); 

10.12 Static Constructors 

A static constructor is a member that implements the actions required to initialize a closed 
class type. Static constructors are declared using static-constructor-declarations: 

static-constructor-declaration: 

attributes^^^ static-constructor-modifiers identifier ( ) static-constructor-body 

static-constructor-modifiers: 
extern , static 

opt 

static extern , 

opt 

static-constructor-body: 

block 


Astatic-constructor-declaration may include a set of attributes (§17) and an extern modifier 
(§10.6.7). 

The identifier of a static-constructor-declaration must name the class in which the static con¬ 
structor is declared. If any other name is specified, a compile-time error occurs. 

When a static constructor declaration includes an extern modifier, the static constructor is 
said to be an external static constructor. Because an external static constructor declaration 
provides no actual implementation, its static-constructor-body consists of a semicolon. For 
all other static constructor declarations, the static-constructor-body consists of a block that 
specifies the statements to execute to initialize the class. This corresponds exactly to the 
method-body of a static method with a void return t 5 q)e (§10.6.10). 

Static constructors are not inherited, and cannot be called directly. 

The static constructor for a closed class t 5 q)e executes at most once in a given application 
domain. The execution of a static constructor is triggered by the first of the following events 
to occur within an application domain: 


586 


www.it-ebooks.info 




10.12 Static Constructors 


• An instance of the class t 5 ^e is created. 

• Any of the static members of the class type are referenced. 


■■ JON SKEET It's very possible for the presence of an empty static constructor to 
affect the behavior of the code, as it can change the point at which static field initial¬ 
izers are executed. If you choose to take advantage of this behavior, I would highly 
recommend that you at least include a comment in the static constructor to explain 
why and how you're relying on its presence, to avoid it being removed by an eager 
maintainer at a later date. 


If a class contains the Main method (§3.1) in which execution begins, the static constructor 
for that class executes before the Main method is called. 

To initialize a new closed class type, first a new set of static fields (§10.5.1) for that particu¬ 
lar closed t 5 ^e is created. Each of the static fields is initialized to its default value (§5.2). 
Next, the static field initializers (§10.4.5.1) are executed for those static fields. Finally, the 
static constructor is executed. 

The example 

using System; 

class Test 
{ 

static void Main() 

{ 

A. F(); 

B. F(); 

} 

} 

class A 
{ 

static A() 

{ 

Console.WriteLineC'Init A"); 

} 

public static void F() 

{ 

Console.WriteLine("A.F"); 

} 

} 

class B 
{ 

static B() 

{ 

Console.WriteLineC'Init B"); 

} 


587 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


public static void F() 

{ 

Console.WriteLine("B.F"); 

} 

} 

must produce the output 

Init A 

A. F 

Init B 

B. F 

because the execution of A's static constructor is triggered by the call to A. F, and the execu¬ 
tion of B's static constructor is triggered by the call to B. F. 

It is possible to construct circular dependencies that allow static fields with variable initial¬ 
izers to be observed in their default value state. 

The example 

using System; 

class A 
{ 

public static int X; 

static A() 

{ 

X = B.Y + 1; 

} 

} 

class B 
{ 

public static int Y = A.X + 1; 
static B() { } 

static void Main() 

{ 

Console.WriteLineC'X = {0}^ Y = {!}", A.X, B.Y); 

} 

} 

produces the following output: 

X = 1, Y = 2 

To execute the Main method, the system first runs the initializer for B.Y, prior to class B's 
static constructor. Y's initializer causes A's static constructor to be run because the value of 
A.X is referenced. The static constructor of A, in turn, proceeds to compute the value of X, 
and in doing so fetches the default value of Y, which is zero. A. X is thus initialized to 1. The 


588 


www.it-ebooks.info 




10.13 Destructors 


process of running A's static field initializers and static constructor then completes, return¬ 
ing to the calculation of the initial value of Y, the result of which becomes 2. 

Because the static constructor is executed exactly once for each closed constructed class 
type, it is a convenient place to enforce runtime checks on the type parameter that carmot 
be checked at compile-time via constraints (§10.1.5). For example, the following type uses 
a static constructor to enforce that the t 5 ^e argument is an enum: 

class Gen<T> where T : struct 
{ 

static Gen() 

{ 

if (Itypeof(T).IsEnum) 

{ 

throw new ArgumentException("T must be an enum"); 

} 

} 

} 

10.13 Destructors 

A destructor is a member that implements the actions required to destruct an instance of a 
class. A destructor is declared using a destructor-declaration: 

destructor-declaration: 

attributes^^^ extern^^j ~ identifier ( ) destructor-body 

destructor-body: 

block 


A destructor-declaration may include a set of attributes (§17). 

The identifier of a destructor-declarator must name the class in which the destructor is 
declared. If any other name is specified, a compile-time error occurs. 

When a destructor declaration includes an extern modifier, the destructor is said to be an 
external destructor. Because an external destructor declaration provides no actual imple¬ 
mentation, its destructor-body consists of a semicolon. For all other destructors, the 
destructor-body consists of a block that specifies the statements to execute to destruct an 
instance of the class. A destructor-body corresponds exactly to the method-body of an instance 
method with a void return t 5 q)e (§10.6.10). 

Destructors are not inherited. Thus a class has no destructors other than the one which may 
be declared in that class. 


589 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


Since a destructor is required to have no parameters, it cannot be overloaded, so a class can 
have, at most, one destructor. 

Destructors are invoked automatically, and cannot be invoked explicitly. An instance 
becomes eligible for destruction when it is no longer possible for any code fo use fhaf 
insfance. Execufion of fhe desfrucfor for fhe insfance may occur af any fime affer fhe 
insfance becomes eligible for desfrucfion. When an insfance is desfrucfed, fhe desfrucfors 
in fhaf insfance's inherifance chain are called, in order, from mosf derived fo leasf derived. 
A destrucfor may be execufed on any fhread. For furfher discussion of fhe rules fhaf gov¬ 
ern when and how a desfrucfor is execufed, see §3.9. 


“■ ERICLIPPERT Clearly, code running in a desfrucfor is rurming in a pofenfially 
very differenf environmenf fhan code an 5 rwhere else in your program. If is a really bad 
idea fo do anyfhing complicafed, dangerous, side-effecfing, or lengfhy. In parficular, 
fhe following code, which produces a complicafed side effecf of wrifing fo fhe console 
is for pedagogic purposes, is not an example of whaf you should do in a real 
desfrucfor. 


The example 

using System; 

class A 
{ 

~A() 

{ 

Console.WriteLine("A's destructor"); 

} 

} 

class B : A 
{ 

~B() 

{ 

Console .WriteLineC'B' s destructor"); 

} 

} 

class Test 
{ 

static void Main() 

{ 

B b = new B(); 
b = null; 

GC.CollectO; 

GC.WaitForPendingFinalizers(); 

} 

} 


590 


www.it-ebooks.info 






10.13 Destructors 


produces the output 

B's destructor 
A's destructor 

since destructors in an inheritance chain are called in order, from most derived to least 
derived. 


“■ ERICLIPPERT Traditionally, the term "destructor" refers fo a deferministic 
cleanup method and a "finalizer" refers to a nondeterministic cleanup method called 
by a garbage collector. "Destructor" is a bit of an unforfunafe misnomer in C#; ideally 
fhese mefhods would be called "finalizers" and the Dispose method of IDisposable 
would be called a "desfrucfor." 


Destructors are implemented by overriding the virtual method Finalize on System. 
Object. C# programs are not permitted to override this method or call it (or overrides of it) 
directly. For instance, the program 

class A 
{ 

override protected void Finalize() { } // Error 

public void F() 

{ 

this.Finalize(); // Error 

} 

} 

contains two errors. 

The compiler behaves as if this method, and overrides of if, do not exist at all. Thus the 
program 

class A 
{ 

void FinalizeO { } // Permitted 

} 

is valid, and the method shown hides System. Object's Finalize method. 

For a discussion of the behavior when an exception is thrown from a destructor, 
see §16.3. 


591 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


10.14 Iterators 

A function member (§7.5) implemented using an iterator block (§8.2) is called an iterator. 

An iterator block may be used as the body of a function member as long as the return type 
of the corresponding function member is one of the enumerator interfaces (§10.14.1) or one 
of the enumerable interfaces (§10.14.2). It can occur as a method-body, operator-body, or 
accessor-body, whereas events, instance constructors, static constructors, and destructors 
cannot be implemented as iterators. 

When a function member is implemented using an iterator block, it is a compile-time error 
for the formal parameter list of the function member to specify any ref or out 
parameters. 

10.14.1 Enumerator Interfaces 

The enumerator interfaces are the nongeneric interface System. Collections. lEnumerator 
and all instantiations of the generic interface System. Collections .Generic. IEnumerator<T>. 
For the sake of brevity, in this chapter these interfaces are referenced as lEnumerator and 
IEnumerator<T>, respectively. 


■■ JONSKEET I wish the "enumerable" and "enumerator" terminology had been 
"iterable" and "iterator," including IIterable<T> and IIterator<T> interfaces. Admit¬ 
tedly, the double-I part is ugly, but it would have kept more lexical space between 
iterators and enumerations. It's bizarrely long-winded to enumerate over an 
enumeration. 


10.14.2 Enumerable Interfaces 

The enumerable interfaces are the nongeneric interface System.Collections. lEnumerable 
and all instantiations of the generic interface System. Collections .Generic. IEnumerable<T>. 
For the sake of brevity, in this chapter these interfaces are referenced as lEnumerable and 
IEnumerable<T>, respectively. 

10.14.3 Yield Type 

An iterator produces a sequence of values, all of the same type. This type is called the yield 
type of the iterator. 

• The yield t 5 rpe of an iterator that returns lEnumerator or lEnumerable is object. 

• The yield type of an iterator that returns lEnumeratorcT > or lEnumerablecT > is T. 

592 


www.it-ebooks.info 






10.14 Iterators 


10.14.4 Enumerator Objects 

When a function member returning an enumerator interface type is implemented using an 
iterator block, invoking the function member does not immediately execute the code in the 
iterator block. Instead, an enumerator object is created and returned. This object encapsu¬ 
lates the code specified in the iterator block, and execution of the code in the iterator block 
occurs when the enumerator object's MoveNext method is invoked. An enumerator object 
has the following characteristics: 

• It implements lEnumerator and IEnumerator<T>, where T is the yield type of the 
iterator. 

• It implements System. IDisposable. 

• It is initialized with a copy of the argument values (if any) and instance value passed to 
the fimction member. 

• It has four potential states— before, running, suspended, and after —and is initially in the 
before state. 


■■ JONSKEET The fact that none of the code within an iterator block runs until the 
first call to MoveNext () is irritating. It means that if you need to check any parameter 
values, you should really use two methods: a normal method that performs the appro¬ 
priate validation and calls the second method, which is then implemented with an 
iterator block. Ideally, some construct would be available to indicate a section of 
the iterator block that should be executed immediately, before constructing the state 
machine. 


An enumerator object is typically an instance of a compiler-generated enumerator class 
that encapsulates the code in the iterator block and implements the enumerator interfaces, 
but other methods of implementation are possible. If an enumerator class is generated by 
the compiler, that class will be nested, directly or indirectly, in the class containing the 
function member; it will have private accessibility; and it will have a name reserved for 
compiler use (§2.4.2). 

An enumerator object may implement more interfaces than those specified above. 

The following sections describe the exact behavior of the MoveNext, Current, and Dispose 
members of the lEnumerable and IEnumerable<T > interface implementations provided by 
an enumerator object. 

Note that enumerator objects do not support the lEnumerator.Reset method. Invoking 
this method causes a System.NotSupportedException to be thrown. 


593 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


10.14.4.1 The MoveNext Method 

The MoveNext method of an enumerator object encapsulates the code of an iterator block. 
Invoking the MoveNext method executes code in the iterator block and sets the Current 
property of the enumerator object as appropriate. The precise action performed by MoveNext 
depends on the state of the enumerator object when MoveNext is invoked: 

• If the state of the enumerator object is before, invoking MoveNext: 

- Changes the state to running. 

- Initializes the parameters (including this) of the iterator block to the argument val¬ 
ues and instance value saved when the enumerator object was initialized. 

- Executes the iterator block from the beginning until execution is interrupted (as 
described below). 

• If the state of the enumerator object is running, the result of invoking MoveNext is 

unspecified. 

• If the state of the enumerator object is suspended, invoking MoveNext: 

- Changes the state to running. 

- Restores the values of all local variables and parameters (including this) to the val¬ 
ues saved when execution of the iterator block was last suspended. Note that the 
contents of any objects referenced by these variables may have changed since the 
previous call to MoveNext. 

- Resumes execution of the iterator block immediately following the yield return 
statement that caused the suspension of execution and continues until execution is 
interrupted (as described below). 

• If the state of the enumerator object is after, invoking MoveNext returns false. 

When MoveNext executes the iterator block, execution can be interrupted in four ways: by 
a yield return statement, by a yield break statement, by encountering the end of the itera¬ 
tor block, and by an exception being thrown and propagated out of the iterator block. 

• When a yield return statement is encountered (§8.14): 

- The expression given in the statement is evaluated, implicitly converted to the yield 
type, and assigned to the Current property of the enumerator object. 

- Execution of the iterator body is suspended. The values of all local variables and 
parameters (including this) are saved, as is the location of this yield return statement. 


594 


www.it-ebooks.info 




10.14 Iterators 


If the yield return statement is within one or more try blocks, the associated finally 
blocks are not executed at this time. 

- The state of the enumerator object is changed to suspended. 

- The MoveNext method returns true to its caller, indicating that the iteration success¬ 
fully advanced to the next value. 

• When a yield break statement is encountered (§8.14): 

- If the yield break statement is within one or more try blocks, the associated finally 
blocks are executed. 

- The state of the enumerator object is changed to after. 

- The MoveNext method returns false to its caller, indicating that the iteration is 
complete. 

• When the end of the iterator body is encountered: 

- The state of the enumerator object is changed to after. 

- The MoveNext method returns false to its caller, indicating that the iteration is 
complete. 

• When an exception is thrown and propagated out of the iterator block: 

- Appropriate finally blocks in the iterator body will have been executed by the 
exception propagation. 

- The state of the enumerator object is changed to after. 

- The exception propagation continues to the caller of the MoveNext method. 

10.14.4.2 The Current Property 

An enumerator object's Current property is affected by yield return statements in the 
iterator block. 

When an enumerator object is in the suspended state, the value of Current is the value set 
by the previous call to MoveNext. When an enumerator object is in the before, running, or 
after states, the result of accessing Current is unspecified. 

For an iterator with a yield type other than object, the result of accessing Current through 
the enumerator object's lEnumerable implementation corresponds to accessing Current 
through the enumerator object's IEnumerator<T> implementation and casting the result to 
object. 


595 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


10.14.4.3 The Dispose Method 

The Dispose method is used to clean up the iteration by bringing the enumerator object to 
the after state. 

• If the state of fhe enumerafor objecf is before, invoking Dispose changes fhe sfafe fo 
after. 

• If fhe sfafe of fhe enumerafor objecf is running, fhe resulf of invoking Dispose is 
unspecified. 

• If fhe sfafe of fhe enumerafor objecf is suspended, invoking Dispose: 

- Changes fhe sfafe fo running. 

- Execufes any finally blocks as if fhe lasf execufed yield return sfafemenf were a 
yield break sfafemenf. If fhis causes an exception fo be fhrown and propagafed ouf 
of fhe iferafor body, fhe sfafe of fhe enumerafor objecf is sef fo after and fhe exception 
is propagafed fo fhe caller of fhe Dispose mefhod. 

- Changes fhe sfafe fo after. 

• If fhe sfafe of fhe enumerafor objecf is after, invoking Dispose has no effecf. 

10.14.5 Enumerable Objects 

When a function member refuming an enumerable inferface fype is implemenfed using an 
iferafor block, invoking fhe funcfion member does nof immediafely execufe fhe code in fhe 
iferafor block. Insfead, an enumerable object is creafed and refurned. The enumerable 
objecf's GetEnumerator mefhod refurns an enumerafor objecf fhaf encapsulafes fhe code 
specified in fhe iferafor block, and execution of fhe code in fhe iferafor block occurs when 
fhe enumerafor objecf's MoveNext mefhod is invoked. An enumerable objecf has fhe follow¬ 
ing characferisfics: 

• If implemenfs lEnumerable and IEnumerable<T>, where T is fhe yield type of fhe 
iferafor. 

• If is initialized wifh a copy of fhe argumenf values (if any) and insfance value passed fo 
fhe funcfion member. 

An enumerable objecf is fypically an insfance of a compiler-generafed enumerable class 
fhaf encapsulafes fhe code in fhe iferafor block and implemenfs fhe enumerable inferfaces, 
buf ofher mefhods of implemenfafion are possible. If an enumerable class is generafed by 
fhe compiler, fhaf class will be nesfed, direcfly or indirecfly, in fhe class confaining fhe 
funcfion member, if will have private accessibilify, and if will have a name reserved for 
compiler use (§2.4.2). 


596 


www.it-ebooks.info 




10.14 Iterators 


An enumerable object may implement more interfaces than those specified above. In par- 
ficular, an enumerable objecf may also implemenf lEnumerator and IEnumerator<T>, 
enabling if fo serve as bofh an enumerable and an enumerafor. In fhaf type of implemenfa- 
fion, fhe firsf fime an enumerable objecf's GetEnumerator mefhod is invoked, fhe enumer¬ 
able objecf ifself is refurned. Subsequenf invocafions of fhe enumerable objecf's 
GetEnumerator, if any, refum a copy of fhe enumerable objecf. Thus each refurned enu¬ 
merafor has ifs own sfafe and changes in one enumerafor will nof affecf anofher. 

10.14.5.1 The GetEnumerator Method 

An enumerable objecf provides an implemenfafion of fhe GetEnumerator mefhods of fhe 
lEnumerable and IEnumerable<T> inferfaces. The fwo GetEnumerator mefhods share a 
common implemenfafion fhaf acquires and refums an available enumerafor objecf. The 
enumerafor objecf is initialized wifh fhe argumenf values and insfance value saved when 
fhe enumerable objecf was inifialized, buf ofherwise fhe enumerafor objecf functions as 
described in §10.14.4. 

10.14.6 Implementation Example 

This section describes a possible implementation of iferafors in ferms of sfandard C# con- 
strucfs. The implemenfafion described here is based on fhe same principles used by fhe 
Microsoff C# compiler, buf if is by no means a mandafed implemenfafion or fhe only one 
possible. 


“■ BILL WAGNER As you look af fhis example, notice fhaf fhe compiler is simply 
creating all fhe code you would generafe if you were fo creafe your own nesfed enu¬ 
merafor class. The iferafor mefhod saves you from a greaf deal of repeafed work, and 
if improves fhe readabilify of your code. 


The following Stacl«T > class implemenfs ifs GetEnumerator mefhod using an iferafor. The 
iferafor enumerafes fhe elemenfs of fhe sfack in fop fo bottom order. 

using System; 

using System.Collections; 

using System.Collections.Generic; 

class Stacl«T> : IEnumerable<T> 

{ 

T[] items; 
int count; 


597 


www.it-ebooks.info 


10. Classes 






10. Classes 


10. Classes 


public void Push(T item) 

{ 

if (items == null) 

{ 

items = new T[4]; 

} 

else if (items.Length == count) 

{ 

T[] newitems = new T[count * 2]; 

Array.Copy(items, 0 , newitems, 0 , count); 
items = newitems; 

} 

items[count++] = item; 

} 

public T PopO 

{ 

T result = items[--count]; 
items[count] = default(T); 
return result; 

} 

public IEnumerator<T> GetEnumerator() 

{ 

for (int i = count - 1; i >= 0; --i) yield return items[i]; 

} 

} 

The GetEnumerator method can be translated into an instantiation of a compiler-generated 
enumerator class that encapsulates the code in the iterator block, as shown in the following 
example: 

class Stacl«T>: IEnumerable<T> 

{ 


public IEnumerator<T> GetEnumerator() { 
return new _Enumeratorl(this); 

} 

class _Enumerator!: IEnumerator<T>, lEnumerator 

{ 

int _state; 

T _current; 

Stacl«T> _this; 

int i; 

public _Enumeratorl(Stacl«T> _this) { 

this._this = _this; 

} 

public T Current { 

get { return _current; } 

} 


598 


www.it-ebooks.info 




10.14 Iterators 


object lEnumerator.Current { 
get { return _current; } 

} 

public bool MoveNextO { 

switch (_state) { 

case 1: goto statel; 

case 2: goto state2; 

} 

i = _this.count - 1; 

_loop: 

if (i < 0) goto _state2; 

_current = _this.items[i]; 

_state = 1; 

return true; 

_statel: 

--i; 

goto _loop; 

_state2: 

_state = 2; 

return false; 

} 

public void Dispose() { 

_state = 2; 

} 

void lEnumerator.Reset() { 

throw new NotSupportedException(); 

} 

} 

} 

In the preceding translation, the code in the iterator block is turned into a state machine 
and placed in the MoveNext method of the enumerator class. Furthermore, the local vari¬ 
able i is turned into a field in the enumerator object so it can continue to exist across invo¬ 
cations of MoveNext. 

The following example prinfs a simple multiplication table of fhe integers 1 through 10. 
The FromTo method in the example returns an enumerable object and is implemented using 
an iterator. 

using System; 

using System.Collections.Generic; 

class Test 

{ 

static IEnumerable<int> FromTo(int from, int to) 

{ 

while (from <= to) yield return from++; 

} 


599 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


static void Main() 

{ 

IEnumerable<int> e = FromTo(lj 10); 
foreach (int x in e) 

{ 

foreach (int y in e) 

{ 

Console.Write("{0j3} ", x * y); 

} 

Console. WriteLineO; 

} 

} 

} 

The FromTo method can be translated into an instantiation of a compiler-generated enu¬ 
merable class that encapsulates the code in the iterator block, as shown in the following 
example: 

using System; 

using System.Threading; 

using System.Collections; 

using System.Collections.Generic; 

class Test 

{ 

static IEnumerable<int> FromTo(int from, int to) { 
return new _Enumerablel(from, to); 

} 

class _Enumerable!: 

IEnumerable<int>, lEnumerable, 

IEnumerator<int>, lEnumerator 

{ 

int _state; 

int _current; 

int _from; 

int from; 
int to; 
int i; 

public _Enumerablel(int _from, int to) { 

this._from = _from; 

this.to = to; 

} 

public IEnumerator<int> GetEnumerator() { 

_Enumerable! result = this; 

if (Interlocked.CompareExchange(ref _state, !, 0) != 0) { 

result = new _Enumerable!(_from, to); 

result._state = 1; 

} 

result.from = result._from; 

return result; 

} 


600 


www.it-ebooks.info 




10.14 Iterators 


lEnumerator IEnumerable.GetEnumerator() { 
return (IEnumerator)GetEnumerator(); 

} 

public int Current { 

get { return _current; } 

} 

object lEnumerator.Current { 
get { return _current; } 

} 

public bool MoveNextO { 

switch (_state) { 

case 1: 

if (from > to) goto case 2; 

_current = from++; 

_state = 1; 

return true; 
case 2: 

_state = 2; 

return false; 
default: 

throw new InvalidOperationException(); 

} 

} 

public void Dispose() { 

_state = 2; 

} 

void lEnumerator.Reset() { 

throw new NotSupportedException(); 

} 

} 

} 

The enumerable class implements both the enumerable interfaces and the enumerator 
interfaces, enabling if fo serve as bofh an enumerable and an enumerator. The firsf fime fhe 
GetEnumerator mefhod is invoked, fhe enumerable objecf ifself is refurned. Subsequenf 
invocafions of fhe enumerable objecf's GetEnumerator, if any, refurn a copy of fhe enumer¬ 
able objecf. Thus each refurned enumerator has ifs own sfafe and changes in one enumera¬ 
tor will nof affecf anofher. The Interlocked .CompareExchange mefhod is used fo ensure 
fhread-safe operafion. 

The from and to parameters are fumed info fields in fhe enumerable class. Because from is 

modified in fhe iferafor block, an addifional_from field is infroduced fo hold fhe inifial 

value given fo from in each enumerafor. 

The MoveNext mefhod fhrows an InvalidOperationException if if is called when_ state 

is 0. This profecfs againsf use of fhe enumerable objecf as an enumerafor objecf wifhouf 
firsf calling GetEnumerator. 


601 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


The following example shows a simple tree class. The Tree<T> class implements its 
GetEnumerator method using an iterator. The iterator enumerates the elements of the tree 
in infix order. 

using System; 

using System.Collections.Generic; 

class Tree<T> : IEnumerable<T> 

{ 

T value; 

Tree<T> left; 

Tree<T> right; 

public Tree(T value^ Tree<T> left, Tree<T> right) 

{ 

this.value = value; 
this.left = left; 
this.right = right; 

} 

public IEnumerator<T> GetEnumerator() { 

if (left != null) foreach (T x in left) yield x; 
yield value; 

if (right != null) foreach (T x in right) yield x; 

} 

} 

class Program 

{ 

static Tree<T> MakeTree<T>(T[] items, int left, Int right) 

{ 

if (left > right) return null; 
int i = (left + right) / 2; 
return new Tree<T>(items[i], 

Makerree(items, left, 1 - 1), 

Makerree(items, 1+1, right)); 

} 

static rree<r> Makerree<r>(params r[] items) 

{ 

return Makerree(items, 0, items.Length - 1); 

} 

// rhe output of the program is: 

// 123456789 

// Hon rue Wed rhu Fri Sat Sun 

static void Main() 

{ 

rree<int> ints = Makerree(l, 2, 3, 4, 5, 6, 7, 8, 9); 
foreach (int i in ints) Console.Write( "{0} ", i); 

Console.WriteLlne(); 


602 


www.it-ebooks.info 




10.14 Iterators 


Tree<string> strings = MakeTree( 

"Mon"j "Tue"j "Wed"j "Thu", "Fri", "Sat", "Sun"); 
foreach (string s in strings) Console.Write("{0} ", s); 

Console.WriteLine(); 

} 

} 

The GetEnumerator method can be translated into an instantiation of a compiler-generated 
enumerator class that encapsulates the code in the iterator block, as shown in the following 
example: 

class Tree<T>: IEnumerable<T> 

{ 

public IEnumerator<T> GetEnumerator() { 
return new _Enumeratorl(this); 

} 

class _Enumerator! : IEnumerator<T>, lEnumerator 

{ 

Node<T> _this; 

IEnumerator<T> _left, _right; 

int _state; 

T _current; 

public _Enumeratorl(Node<T> _this) { 

this._this = _this; 

} 

public T Current { 

get { return _current; } 

} 

object lEnumerator.Current { 
get { return _current; } 

} 

public bool MoveNextO { 
try { 

switch (_state) { 

case 0: 

_state = -1; 

if (_this.left == null) 

goto _yield_value; 

_left = this. left. GetEnumeratorO; 

goto case 1; 

case 1: 

_state = -2; 

if (!_left .MoveNextO) 

goto _left_dispose; 

_current = _left.Current; 

_state = 1; 

return true; 


603 


www.it-ebooks.info 


10. Classes 




10. Classes 


10. Classes 


_left_dispose: 

_state = -1; 

_left.Dispose (); 

_yielcl_value: 

_current = _this.value; 

_state = 2; 

return true; 

case 2: 

_state = -1; 

if (_this.right == null) goto _end; 

_right = _this.right.GetEnumerator(); 

goto case 3; 

case 3: 

_state = -3; 

if (!_right.MoveNextO) goto _right_dispose; 

_current = _right.Current; 

_state = 3; 

return true; 

_right_dispose: 

_state = -1; 

_right.Dispose(); 

_end; 

_state = 4; 

break; 

} 

} 

finally { 

if (_state < 0) DisposeO; 

} 

return false; 

} 

public void Dispose() { 
try { 

switch (_state) { 

case 1: 
case -2: 

_left.Dispose(); 

break; 

case 3: 
case -3: 

_right. DisposeO j 

break; 

} 

} 

finally { 

_state = 4; 

} 

} 


604 


www.it-ebooks.info 




10.14 Iterators 


void lEnumerator.ResetO { 

throw new NotSupportedException(); 

} 

} 

} 

The compiler generated temporaries used in the foreach statements are lifted into the 

_left and_ right fields of fhe enumerator object. The_ state field of the enumerator 

object is carefully updated so that the Disposef ) method will be called correctly if an 
exception is thrown. Note that it is not possible to write the translated code with simple 
foreach statements. 


605 


www.it-ebooks.info 


10. Classes 




This page intentionally left blank 


www.it-ebooks.info 


11. Structs 


Structs are similar to classes in that they represent data structures that can contain data 
members and function members. However, unlike classes, structs are value types and do 
not require heap allocation. A variable of a sfrucf type directly contains the data of fhe 
sfrucf, whereas a variable of a class 1)^)0 confains a reference fo fhe dafa, fhe laffer known 
as an objecf. 


“■ ERIC LIPPERT The sfafemenf fhaf "sfrucfs do nof require heap allocation" is nof 
fhe sfafemenf "all insfances of all sfrucfs are always allocafed on fhe sfack." Firsf, fhe 
second sfafemenf is nof frue: The memory for a Date!ime field of a Customer class will 
be allocafed on fhe heap along wifh fhe resf of fhe memory of fhe Customer class. Sec¬ 
ond, whefher a local variable of value t 5 q)e is allocafed by changing fhe sfack regisfer 
in fhe CPU is an implemenfafion defail of a parficular version of fhe framework. The 
specification is poinfing ouf fhe opporfunify for an opfimizafion here, nof sfafing fhaf 
a parficular allocation pattern is required. 


Sfrucfs are parficularly useful for small dafa sfrucfures fhaf have value semantics. Complex 
numbers, poinfs in a coordinafe sysfem, or key-value pairs in a dicfionary are all good 
examples of sfrucfs. Key fo fhese dafa sfrucfures is fhaf fhey have few dafa members, fhaf 
fhey do nof require use of inherifance or referenfial identify and fhaf fhey can be conve- 
nienfly implemenfed using value semantics where assignmenf copies fhe value insfead of 
fhe reference. 

As described in §4.1.4, fhe simple f 5 q)es provided by C#, such as int, double, and bool, are, 
in facf, all sfrucf f 5 q)es. Jusf as fhese predefined f 5 q)es are sfrucfs, so if is also possible fo use 
sfrucfs and operafor overloading fo implemenf new "primifive" fypes in fhe C# language. 
Two examples of such fypes are given af fhe end of fhis chapfer (§11.4). 


"■ BILL WAGNER All simple f 5 q)es are immufable. Any sfrucfs you creafe should 
also be immufable. 


607 


www.it-ebooks.info 








11. Structs 


11. Structs 


■■ JON SKEET While I have always appreciated the ability to create user-defined 
value t 5 ^es. I've almost never found myself needing to do so. When it's appropriate, 
though it can be extremely useful. For example. I'm currently involved in porting a 
date/time API from Java, and we have three different value t 5 ^es all wrapping just a 
long. In the Java code, these are often represented as plain long values for efficiency— 
but using different t 5 ^es with different operations (and operators) available has made 
the C# code vastly more readable. 


11.1 Struct Declarations 

A struct-declaration is a type-declaration (§9.6) that declares a new struct: 
struct-declaration: 

attributes^^i struct-modifiers^^ partial^^j struct identifier type-parameter-list 
struct-interfaces^^^i type-parameter-constraints-clauses^i struct-body 

A struct-declaration consists of an optional set of attributes (§17), followed by an optional set 
of struct-modifiers (§11.1.1), followed by an optional partial modifier, followed by the key¬ 
word struct and an identifier that names the struct, followed by an optional type-parameter- 
list specification (§10.1.3), followed by an optional struct-interfaces specification (§11.1.2), 
followed by an optional type-parameters-constraints-clauses specification (§10.1.5), followed 
by a struct-body (§11.1.4), optionally followed by a semicolon. 

11.1.1 Struct Modifiers 

A struct-declaration may optionally include a sequence of struct modifiers: 

struct-modifiers: 

struct-modifier 

struct-modifiers struct-modifier 

struct-modifier: 

new 

public 

protected 

internal 

private 

It is a compile-time error for the same modifier to appear multiple times in a struct 
declaration. 

The modifiers of a struct declaration have the same meaning as those of a class declaration 

(§ 10 . 1 ). 


608 


www.it-ebooks.info 






11.2 Struct Members 


11.1.2 partial Modifier 

The partial modifier indicates that this struct-declaration is a partial t 5 ^e declaration. Mul¬ 
tiple partial struct declarations with the same name within an enclosing namespace or t 5 ^e 
declaration combine to form one struct declaration, following the rules specified in §10.2. 

11.1.3 Struct Interfaces 

A struct declaration may include a struct-interfaces specification, in which case the struct is 
said to directly implement the given interface types. 

struct-interfaces: 

: interface-type-list 

Interface implementations are discussed further in §13.4. 

11.1.4 Struct Body 

The struct-body of a struct defines the members of the struct. 

struct-body: 

{ struct-member-declarations^^ } 

11.2 Struct Members I 

The members of a struct consist of the members introduced by its struct-member-declarations 
and the members inherited from the t 5 ^e System.ValueType. 

struct-member-declarations: 

struct-member-declaration 

struct-member-declarations struct-member-declaration 

struct-member-declaration: 

constant-declaration 

field-declaration 

method-declaration 

property-declaration 

event-declaration 

indexer-declaration 

operator-declaration 

constructor-declaration 

static-constructor-declaration 

type-declaration 

Except for the differences nofed in §11.3, fhe descriptions of class members provided in 
§10.3 fhrough §10.14 apply to struct members as well. 

609 


www.it-ebooks.info 


11. Structs 




11. Structs 


11. Structs 


11.3 Class and Struct Differences 

Structs differ from classes in several imporfanf ways: 

• Sfrucfs are value fypes (§11.3.1). 

• All sfrucf fypes implicifly inherif from fhe class System.ValueType (§11.3.2). 

• Assignmenf fo a variable of a sfrucf type creates a copy of the value being assigned 
(§11.3.3). 

• The default value of a struct is the value produced by setting all value type fields to their 
default values and all reference type fields to null (§11.3.4). 

• Boxing and unboxing operations are used to convert between a struct type and object 
(§11.3.5). 

• The meaning of this is different for structs (§7.6.7). 

• Instance field declarations for a struct are not permitted to include variable initializers 
(§11.3.7). 

• A struct is not permitted to declare a parameterless instance constructor (§11.3.8). 

• A struct is not permitted to declare a destructor (§11.3.9). 


■■ JESSE LIBERTY Note that these differences are semantically significant, unlike 
the trivial differences between structs and classes in C++. 


11.3.1 Value Semantics 

Structs are value types (§4.1) and are said to have value semantics. Classes, in contrast, are 
reference t 5 ^es (§4.2) and are said to have reference semantics. 


“■ BILL WAGNER The statement below that a variable of a struct type directly con¬ 
taining the data of the struct is one of those correct but misleading specification state¬ 
ments. A struct may contain members of reference t 5 ^es. The data of the struct is a 
reference to the class t 5 ^e. For example: 

struct Message 
{ 

int code; 
string message; 

// message contains a reference to a string 
// object, not the characters in the message 

} 

Assignment copies the reference to message, not the characters themselves. 


610 


www.it-ebooks.info 








11.3 Class and Struct Differences 


A variable of a struct t5^e directly contains the data of the struct, whereas a variable of a 
class t5^e contains a reference to the data, the latter known as an object. When a struct B 
contains an instance field of type A and A is a struct t5^e, it is a compile-time error for A to 
depend on B. A struct X directly depends on a struct Y if X contains an instance field of type 
Y. Given this definition, the complete set of structs upon which a struct depends is the 
transitive closure of the directly depends on relationship. For example, 

struct Node 
{ 

int data; 

Node next; // Error: Node directly depends on itself 

} 

is an error because Node contains an instance field of its own type. Another example 
struct A { B b; } 
struct B { C c; } 
struct C { A a; } 

is an error because each of the t5^es A, B, and C depend on each other. 

With classes, it is possible for two variables to reference the same object, and thus possible 
for operations on one variable to affect the object referenced by the other variable. With 
structs, each of the variables has its own copy of the data (except in the case of ref and out 
parameter variables), and it is not possible for operations on one to affect the others. Fur¬ 
thermore, because structs are not reference types, it is not possible for values of a struct 
type to be null. 

Given the declaration 

struct Point 
{ 

public int x, y; 

public Point(int x, int y) { 
this.x = x; 
this.y = y; 

} 

} 

the code fragment 

Point a = new Point(10, 10); 

Point b = a; 
a.x = 100; 

System.Console.WriteLine(b.x); 


611 


www.it-ebooks.info 


11. Structs 




11. Structs 


11. Structs 


outputs the value 10. The assignment of a to b creates a copy of the value, and b is thus 
unaffected by the assignment to a. x. Had Point instead been declared as a class, the output 
would be 100 because a and b would reference the same object. 

11.3.2 Inheritance 

All struct types implicitly inherit from the class System.ValueType, which in turn inherits 
from class object. A struct declaration may specify a list of implemented interfaces, but it 
is not possible for a struct declaration to specify a base class. 

Struct types are never abstract and are always implicitly sealed. The abstract and sealed 
modifiers are, therefore, not permitted in a struct declaration. 

Since inheritance isn't supported for structs, the declared accessibility of a struct member 
cannot be protected or protected internal. 

Function members in a struct cannot be abstract or virtual, and the override modifier is 
allowed only to override methods inherited from System. ValueType. 

11.3.3 Assignment 

Assignment to a variable of a struct t 5 ^e creates a copy of the value being assigned. This 
differs from assignment to a variable of a class type, which copies the reference but not the 
object identified by the reference. 

Similar to an assignment, when a struct is passed as a value parameter or returned as the 
result of a fimction member, a copy of the struct is created. A struct may be passed by refer¬ 
ence to a function member using a ref or out parameter. 


"■ ERIC LIPPERT Another way of looking at this issue is that ref and out 
parameters create an alias to variables. Rather than thinking, "I'm going to use a 
ref parameter to pass this struct by reference," I prefer to think, "I'm going to use 
a ref parameter to make this parameter an alias for the variable that contains this 
struct." 


When a property or indexer of a struct is the target of an assignment, the instance expres¬ 
sion associated with the property or indexer access must be classified as a variable. If the 
instance expression is classified as a value, a compile-time error occurs. This is described 
in further detail in §7.17.1. 

11.3.4 Default Values 

As described in §5.2, several kinds of variables are automatically initialized to their default 
values when they are created. For variables of class t 5 ^es and other reference types, this 


612 


www.it-ebooks.info 






11.3 Class and Struct Differences 


default value is null. However, since structs are value t 5 ^es that cannot be null, the default 
value of a struct is the value produced by setting all value type fields to their default value 
and all reference type fields to null. 

Referring to the Point struct declared above, the example 
Point[] a = new Point[100]; 

initializes each Point in the array to the value produced by setting the x and y fields 
to zero. 

The default value of a struct corresponds to the value returned by the default constructor 
of the struct (§4.1.2). Unlike a class, a struct is not permitted to declare a parameterless 
instance constructor. Instead, every struct implicitly has a parameterless instance construc¬ 
tor, which always returns the value that results from setting all value type fields to their 
default value and all reference t 5 ^e fields to null. 

Structs should be designed to consider the default initialization state a valid state. In the 
example 

using System; 

struct KeyValuePair 
{ 

string key; 
string value; 

public KeyValuePair(string key, string value) { 
if (key == null || value == null) 
throw new ArgumentException(); 
this.key = key; 
this.value = value; 

} 

} 

the user-defined instance constructor protects against null values only where it is explicitly 
called. In cases where a KeyValuePair variable is subject to default value initialization, the 
key and value fields will be null, and the struct must be prepared to handle this state. 

11.3.5 Boxing and Unboxing 


"■ BILL WAG N E R Since the introduction of C# 2.0, you have often been able to avoid 
boxing and unboxing by using generics. 


A value of a class 1)^0 can be converted to type object or to an interface type that is 
implemented by the class simply by treating the reference as another t 5 ^e at compile time. 


613 


www.it-ebooks.info 


11. Structs 






11. Structs 


11. Structs 


Likewise, a value of type object or a value of an interface type can be converted back to 
a class type without changing the reference (but, of course, a runtime type check is 
required in this case). 

Since structs are not reference types, these operations are implemented differently for 
struct types. When a value of a struct t 5 q)e is converted to type object or to an interface 
type that is implemented by the struct, a boxing operation takes place. Likewise, when a 
value of t 5 q)e object or a value of an interface t 5 q)e is converted back to a struct t 5 q)e, an 
unboxing operation takes place. A key difference from the same operations on class types 
is that boxing and unboxing copy the struct value either into or out of the boxed instance. 
Thus, following a boxing or unboxing operation, changes made to the unboxed struct are 
not reflected in the boxed struct. 


"■ ERIC LI PPERT This is yet another reason why value types should be immutable: 
If a change is impossible, then the fact that changes made to an unboxed struct are not 
reflected in the boxed struct becomes irrelevant. Rather than dealing with the unex¬ 
pected and confusing semantics, avoid them altogether. 


When a struct type overrides a virtual method inherited from System.Object (such as 
Equals, GetHashCode, or ToString), invocation of the virtual method through an instance 
of the struct type does not cause boxing to occur. This is true even when the struct is used 
as a t 5 q)e parameter and the invocation occurs through an instance of the type parameter 
type. For example: 

using System; 

struct Counter 
{ 

int value; 

public override string ToString() { 
value++; 

return value.ToStringO; 

} 

} 

class Program 
{ 

static void Test<T>() where T: new() { 

T X = new T(); 

Console.WriteLine(x.ToString()); 

Console.WriteLlne(x.ToString()); 

Console.WriteLlne(x.ToString()); 

} 

static void Main() { 

Test<Counter>(); 

} 

} 


614 


www.it-ebooks.info 






11.3 Class and Struct Differences 


The output of this program is 

1 

2 

3 

Although it is bad style for ToString fo have side effecfs, fhe example demonsfrafes fhaf 
no boxing occurred for fhe fhree invocafions of x.ToStringf). 

Similarly, boxing never implicifly occurs when accessing a member on a consfrained t 5 ^e 
paramefer. For example, suppose an inferface ICounter confains a mefhod Increment fhaf 
can be used fo modify a value. If ICounter is used as a consfrainf, fhe implemenfafion of 
fhe Increment mefhod is called wifh a reference fo fhe variable fhaf Increment was called 
on—never a boxed copy. 

using System; 

interface ICounter 

{ 

void IncrementO; 

} 

struct Counter: ICounter 

{ 

int value; 

public override string ToString() { 
return value.ToString(); 

} 

void ICounter.IncrementO { 
value++; 

} 

} 

class Program 

{ 

static void Test<T>() where T; ICounter, new() { 

T X = new T(); 

Console.WriteLine(x); 

X. IncrementO; 

// Modify X 

Console.WriteLine(x); 

((ICounter)x) .IncrementO; 

// Modify boxed copy of x 
Console.WriteLine(x); 

} 

static void MainO { 

Test<Counter>0; 

} 

} 


615 


www.it-ebooks.info 


11. Structs 




11. Structs 


11. Structs 


The first call to Increment modifies the value in the variable x. This is not equivalent to the 
second call to Increment, which modifies the value in a boxed copy of x. Thus the output 
of the program is 

0 

1 

1 

For further details on boxing and unboxing, see §4.3. 

11.3.6 Meaning of this 

Within an instance constructor or instance function member of a class, this is classified as 
a value. Thus, while this can be used to refer to the instance for which the function mem¬ 
ber was invoked, it is not possible to assign to this in a function member of a class. 

Within an instance constructor of a struct, this corresponds to an out parameter of the 
struct type; within an instance function member of a struct, this corresponds to a ref 
parameter of the struct type. In both cases, this is classified as a variable, and it is possible 
to modify the entire struct for which the function member was invoked by assigning to 
this or by passing this as a ref or out parameter. 


"■ VLADIMIR RESHETNIKOV Anonymous functions and query expressions inside 
structs cannot access this or instance members of this. 


11.3.7 Field Initializers 

As described in §11.3.4, the default value of a struct consists of the value that results from 
setting all value type fields to their default values and all reference type fields to null. For 
this reason, a struct does not permit instance field declarations to include variable initial¬ 
izers. This restriction applies only to instance fields. Static fields of a struct are permitted 
to include variable initializers. 

The example 

struct Point 
{ 

public int x = 1; // Error: initializer not permitted 
public int y = 1; // Error: initializer not permitted 

} 

is in error because the instance field declarations include variable initializers. 


616 


www.it-ebooks.info 






11.3 Class and Struct Differences 


■■ JOSEPH ALBAHARI The following pattern provides a work-around, giving X a 
default value of 1: 

struct Point 
{ 

bool initialized; // Default value false 
int x; 

public int X { 
get { 

if (!initialized) { x = 1; initialized = true; } 
return x; 

} 

} 

} 


■■ ERICLIPPERT A more terse version of Joseph's technique would be to hide the 
flag in a nullable and use the null coalescing operator: 

struct Point 
{ 

private int? x; // Default value is null 
public int X { get { return x ?? 1; }} 

} 

Because a nullable int is actually implemented as a struct containing an int and a 
bool, this is essentially the same technique, just a bit more concise. 


11.3.8 Constructors 

Unlike a class, a struct is not permitted to declare a parameterless instance constructor. 
Instead, every struct implicitly has a parameterless instance constructor, which always 
returns the value that results from setting all value type fields to their default values and 
all reference type fields to null (§4.1.2). A struct can declare instance constructors having 
parameters. For example: 

struct Point 
{ 

int X, y; 

public Point(int x, int y) { 
this.x = x; 
this.y = y; 

} 

} 


617 


www.it-ebooks.info 


11. Structs 








11. Structs 


11. Structs 


Given the above declaration, the statements 
Point pi = new Point(); 

Point p2 = new Point(0, 0); 

both create a Point with x and y initialized to zero. 

A struct instance constructor is not permitted to include a constructor initializer of the form 
base(...). 

If the struct instance constructor doesn't specify a constructor initializer, the this variable 
corresponds to an out parameter of the struct t 5 ^e; similar to an out parameter, this must 
be definitely assigned (§5.3) at every location where the constructor returns. If the struct 
instance constructor specifies a constructor initializer, the this variable corresponds to a 
ref parameter of the struct t 5 ^e; similar to a ref parameter, this is considered definitely 
assigned on entry to the constructor body. Consider the instance constructor implementa¬ 
tion below: 

struct Point 

{ 

int X, y; 

public int X { 

set { X = value; } 

} 

public int Y { 

set { y = value; } 

} 

public Point(int x, int y) { 

X = x; // Error: this is not yet definitely assigned 
Y = y; // Error: this is not yet definitely assigned 

} 

} 

No instance member function (including the set accessors for the properties X and Y) can 
be called until all fields of the struct being constructed have been definitely assigned. Note, 
however, that if Point were a class instead of a struct, the instance constructor implementa¬ 
tion would be permitted. 


"■ ERIC LIPPERT The specification does not mention that the way to make this work 
is to simply force a call to the default constructor to ensure that the fields are 
inifialized: 

public Point(int x, int y) : this() { // Struct is guaranteed to be initialized 


618 


www.it-ebooks.info 






11.4 Struct Examples 


11.3.9 Destructors 

A struct is not permitted to declare a destructor. 

11.3.10 Static Constructors 

Static constructors for structs follow mosf of fhe same rules as for classes. The execufion of 
a sfafic consfrucfor for a sfrucf f 5 ^e is friggered by fhe firsf of fhe following evenfs fo occur 
wifhin an applicafion domain: 

• A sfafic member of fhe sfrucf fype is referenced. 

• An explicifly declared consfrucfor of fhe sfrucf fype is called. 

The creafion of defaulf values (§11.3.4) of sfrucf fypes does nof frigger fhe sfafic consfruc¬ 
for. (An example of fhis is fhe inifial value of elemenfs in an array.) 


11.4 Struct Examples 

The following shows fwo significanf examples of using struct fypes fo creafe fypes fhaf 
can be used similarly fo fhe builf-in f 5 ^es of fhe language, buf wifh modified semantics. 


“■ BILL WAGNER These examples are nof as compelling now fhaf nullable f 5 ^es 
have been added fo fhe language and fhe framework. Even so, I find fhaf I sfill creafe 
struct f 5 ^es for holding insfances of fypes when I creafe very large collecfions of dafa 
values. 


11.4.1 Database Integer Type 

The DBInt sfrucf below implemenfs an infeger f 5 ^e fhaf can represenf fhe complefe sef of 
values of fhe int f 5 ^e, plus an addifional sfafe fhaf indicafes an unknown value. A fype 
with these characteristics is commonly used in databases. 

using System; 

public struct DBInt 
{ 

// The Null member represents an unknown DBInt value. 

public static readonly DBInt Null = new DBInt(); 

// When the defined field is true, this DBInt represents a 
// known value that is stored in the value field. When 
// the defined field is false, this DBInt represents an 
// unknown value, and the value field is 0. 


619 


www.it-ebooks.info 


11. Structs 






11. Structs 


11. Structs 


int value; 
bool defined; 

// Private instance constructor. 

// Creates a DBInt with a known value. 

DBInt(lnt value) { 

this.value = value; 
this.defined = true; 

} 

// The IsNull property is true if this 
// DBInt represents an unknown value. 

public bool IsNull { get { return !defined; } } 

// The Value property is the known value of this DBInt, 

// or 0 if this DBInt represents an unknown value. 

public int Value { get { return value; } } 

// Implicit conversion from int to DBInt. 

public static implicit operator DBInt(int x) { 
return new DBInt(x); 

} 

// Explicit conversion from DBInt to int. Throws an 
// exception if the given DBInt represents an unknown value. 

public static explicit operator int(DBInt x) { 

if (!x.defined) throw new InvalidOperationException(); 
return x.value; 

} 

public static DBInt operator +(DBInt x) { 
return x; 

} 

public static DBInt operator -( DBInt x) { 
return x.defined ? -x.value : Null; 

} 

public static DBInt operator +( DBInt x, DBInt y) { 

return x.defined && y.defined? x.value + y.value: Null; 

} 

public static DBInt operator -( DBInt x, DBInt y) { 

return x.defined && y.defined? x.value - y.value: Null; 

} 

public static DBInt operator *( DBInt x, DBInt y) { 

return x.defined && y.defined? x.value * y.value: Null; 

} 

public static DBInt operator /(DBInt x, DBInt y) { 

return x.defined && y.defined? x.value / y.value: Null; 

} 

public static DBInt operator %(DBInt x, DBInt y) { 

return x.defined && y.defined? x.value % y.value: Null; 

} 

620 


www.it-ebooks.info 




11.4 Struct Examples 


public static DBBool operator ==(DBInt x, DBInt y) { 
return x.defined && 

y.defined? x.value == y.value: DBBool.Null; 

} 

public static DBBool operator !=(DBInt x, DBInt y) { 
return x.defined && 

y.defined? x.value != y.value: DBBool.Null; 

} 

public static DBBool operator >(DBInt x, DBInt y) { 
return x.defined && 

y.defined? x.value > y.value: DBBool.Null; 

} 

public static DBBool operator <(DBInt x^ DBInt y) { 
return x.defined && 

y.defined? x.value < y.value: DBBool.Null; 

} 

public static DBBool operator >=(DBInt x, DBInt y) { 
return x.defined && 

y.defined? x.value >= y.value: DBBool.Null; 

} 

public static DBBool operator <=(DBInt x, DBInt y) { 
return x.defined && 

y.defined? x.value <= y.value: DBBool.Null; 

} 

public override bool Equals(object obj) { 
if (!(obj is DBInt)) return false; 

DBInt X = (DBInt)obj; 

return value == x.value && defined == x.defined; 

} 

public override int GetHashCode() { 
return value; 

} 

public override string ToStringO { 

return defined? value.ToStringO : "DBInt.Null"; 

} 


CHRISTIAN NAGEL In the namespace System.Data.SqlTypes, the .NET contains 
mapping structs such as SqlBoolean and Sqllnt32 that are somewhat similar to the 
examples DBInt and DBBool here. These tj^es have been available since .NET 1.0 and 
have been created to allow for a null value, as it is possible with the native database 
types. Given that nullable tjqies have been available since .NET 2.0, creation of custom 
fypes can be avoided and int? and bool? used instead. 


621 


www.it-ebooks.info 


11. Structs 






11. Structs 


11. Structs 


11.4.2 Database Boolean Type 

The DBBool struct below implements a three-valued logical t 5 ^e. The possible values of 
this type are DBBool. T rue, DBBool .False, and DBBool. Null, where the Null member indi¬ 
cates an unknown value. Such three-valued logical types are commonly used in 
databases. 

using System; 

public struct DBBool 

{ 

// The three possible DBBool values. 

public static readonly DBBool Null = new DBBool(0); 
public static readonly DBBool False = new DBBool(-l); 
public static readonly DBBool True = new DBBool(l); 

// Private field that stores -1, 0, 1 for False, Null, True. 

sbyte value; 

// Private instance constructor. 

// The value parameter must be -1, 0, or 1. 

DBBool(int value) { 

this.value = (sbyte)value; 

} 

// Properties to examine the value of a DBBool. Return true 
// if this DBBool has the given value, false otherwise. 

public bool IsNull { get { return value == 0; } } 

public bool IsFalse { get { return value < 0; } } 

public bool IsTrue { get { return value > 0; } } 

// Implicit conversion from bool to DBBool. Maps true to 
// DBBool.True and false to DBBool.False. 

public static implicit operator DBBool(bool x) { 
return x? True: False; 

} 

// Explicit conversion from DBBool to bool. 

// Throws an exception if the given DBBool 
// is Null; otherwise, returns true or false. 

public static explicit operator bool(DBBool x) { 

if (x.value == 0) throw new InvalidOperationExceptlon(); 
return x.value > 0; 

} 

// Equality operator. Returns Null if either operand is Null; 

// otherwise, returns True or False. 

public static DBBool operator ==(DBBool x, DBBool y) { 
if (x.value == 0 || y.value == 0) return Null; 
return x.value == y.value? True: False; 

} 

622 


www.it-ebooks.info 




11.4 Struct Examples 


// Inequality operator. Returns Null if either operand is Null; 

// otherwise^ returns True or False. 

public static DBBool operator !=(DBBool x, DBBool y) { 
if (x.value == 0 || y.value == 0) return Null; 
return x.value != y.value? True; False; 

} 

// Logical negation operator. Returns True if the operand is 
// FalsBj Null if the operand is Nullj 
// or False if the operand is True. 

public static DBBool operator !(DBBool x) { 
return new DBBool(-x.value); 

} 

// Logical AND operator. Returns False if either operand is False; 
// otherwise^ Null if either operand is Null; otherwise^ True. 

public static DBBool operator &(DBBool x, DBBool y) { 

return new DBBool(x.value < y.value? x.value: y.value); 

} 

// Logical OR operator. Returns True if either operand is True; 

// otherwise. Null if either operand is Null; otherwise. False. 

public static DBBool operator |(DBBool x, DBBool y) { 

return new DBBool(x.value > y.value? x.value: y.value); 

} 

// Definitely true operator. Returns true if the 
// operand is True, false otherwise. 

public static bool operator true(DBBool x) { 
return x.value > 0; 

} 

// Definitely false operator. Returns true if the 
// operand is False, false otherwise. 

public static bool operator false(DBBool x) { 
return x.value < 0; 

} 

public override bool Equals(object obj) { 
if (!(obj is DBBool)) return false; 
return value == ((DBBool)obj).value; 

} 

public override int GetFlashCode() { 
return value; 

} 

public override string ToStringO { 

if (value > 0) return "DBBool.True"; 
if (value < 0) return "DBBool.False"; 
return "DBBool.Null"; 

} 

} 


623 


www.it-ebooks.info 


11. Structs 




11. Structs 


11. Structs 


“■ CH RIS SELLS When .NET was first introduced, user-defined value types were an 
important differentiator of this system from Java. In practice, I find these t 5 ^es mostly 
used as an optimization after profiling has revealed the garbage collector overworking 
itself toward no worthy goal. 


"■ ERIC LIPPERT The fact that some local variables of value t 5 ^e can be cheaply 
allocated on the stack does not automatically make them "higher performance" than 
reference t 5 ^es. Heap allocation is somewhat more expensive than stack allocation, but 
still pretty cheap. The real cost savings t 5 ^ically come through the deallocation: The 
fewer objects that are allocated on the heap, the less potential garbage the garbage col¬ 
lector has to identify and compact. Even so, any cost savings in allocation and dealloca¬ 
tion is often eaten up by the need to copy value types by value. Processors are optimized 
for copying things whose size approximates the size of a reference. Value types can be 
of an odd size and copied a lot, which can in some cases increase the total cost. 

My advice is to make the value-versus-reference choice based on whether copy-by- 
value or copy-by-reference makes more sense, then do performance testing with a 
profiler. Only change a reference t 5 ^e to a value t 5 ^e (or vice versa) if you have good, 
empirical, repeatable data that indicates that doing so makes a measurable and impor¬ 
tant difference. 


624 


www.it-ebooks.info 








12. Arrays 


An array is a data structure that contains a number of variables that are accessed through 
computed indices. The variables contained in an array, also called the elements of fhe array, 
are all of the same t 5 ^e, and this type is called the element t 5 ^e of the array. 

An array has a rank that determines the number of indices associated with each array ele¬ 
ment. The rank of an array is also referred to as the dimensions of the array. An array with 
a rank of 1 is called a single-dimensional array. An array with a rank greater than 1 is 
called a multi-dimensional array. Specific-sized multi-dimensional arrays are often 
referred fo as two-dimensional arrays, three-dimensional arrays, and so on. 

Each dimension of an array has an associated length that is an integral number greater 
than or equal to zero. The dimension lengths are not part of the type of fhe array, but rather 
are established when an instance of the array type is created at runtime. The length of a 
dimension defermines the valid range of indices for that dimension: For a dimension of 
length N, indices can range from 0 to N - 1 inclusive. The total number of elemenfs in an 
array is the product of the lengths of each dimension in fhe array. If one or more of the 
dimensions of an array have a lengfh of zero, the array is said to be empty. 

The element type of an array can be any t 5 q)e, including an array t 5 q)e. 


12.1 Array Types 

An array type is written as a non-array-type followed by one or more rank-specifiers: 


array-type: 

non-array-type rank-specifiers 


non-array-type: 

type 

rank-specifiers: 

rank-specifier 

rank-specifiers rank-specifier 


625 


www.it-ebooks.info 




12. Arrays 


12. Arrays 


rank-specifier: 

[ dim-separators^^ ] 

dim-separators: 

J 

dim-separators , 

A non-array-type is any type that is not itself an array-type. 

The rank of an array f 5 T’e is given by fhe leffmosf rank-specifier in fhe array-type: A rank- 
specifier indicafes fhaf fhe array is an array wifh a rank of one plus fhe number of " j" 
fokens in fhe rank-specifier. 

The elemenf f 5 ^e of an array fype is fhe type that results from delefing fhe leffmosf rank- 
specifier: 

• An array type of fhe form T [ R ] is an array wifh rank R and a non-array elemenf f 5 ^e T. 

• An array type of fhe form T [ R ] [ R J ... [ R^^ ] is an array wifh rank R and an elemenf fype 
T[RJ...[RJ. 

In effecf, fhe rank-specifiers are read from leff fo righf before fhe final non-array elemenf fype. 
The t 5 ^e int [ ] [ j ^ ] [, ] is a single-dimensional array of fhree-dimensional arrays of fwo- 
dimensional arrays of int. 


"■ ERIC LI PPERT The facf fhaf fhe rank specifiers of arrays-of-arrays are read "back¬ 
ward" is frequenfly confusing fo people. In realify fhis scheme has fhe nice properfy 
fhaf fhe indexing operafions go in fhe same order as fhe declarations; you would index 
fhaf complicafed array as arr[a] [b^ Cjd] [e^f ]. 


Af runfime, a value of an array type can be null or a reference fo an insfance of fhaf 
array fype. 

12.1.1 The System .Array Type 

The type System. Array is the abstract base type of all array fypes. An implicif reference 
conversion (§6.1.6) exisfs from any array fype fo System.Array, and an explicif refer¬ 
ence conversion (§6.2.4) exisfs from System. Array fo any array fype. Nofe fhaf System. 
Array is nof ifself an array-type. Rafher, if is a class-type from which all array-types are 
derived. 

Af runfime, a value of t 5 q)e System. Array can be null or a reference fo an insfance of any 
array fype. 


626 


www.it-ebooks.info 






12.1 Array Types 


12.1.2 Arrays and the Generic IList Interface 

A one-dimensional array T[] implements the interface System.Collections.Generic. 
IList<T> (IList<T> for short) and its base interfaces. Accordingly, there is an implicit 
conversion from T[] to IList<T> and its base interfaces. In addition, if there is an 
implicit reference conversion from S to T, then S[] implements IList<T> and there is 
an implicit reference conversion from S[ ] to IList<T> and its base interfaces (§6.1.6). If 
fhere is an explicit reference conversion from S to T, then there is an explicit reference 
conversion from S[ ] fo IList<T> and its base interfaces (§6.2.4). For example: 

using System.Collections.Generic; 

class Test 
{ 

static void Main() { 

string!] sa = new string[5]; 
object!] = new object!5]; 
object!] oa2 = sa; 

IList<string> Istl = sa; 

IList<string> lst2 = oal; 

IList<object> lst3 = sa; 

IList<object> lst4 = oal; 

IList<string> IstS = (IList<string>)oal; // Exception 
IList<string> lst6 = (IList<string>)oa2; // Okay 

} 

} 

The assignment lst2 = oal generates a compile-time error since the conversion from 
object[]toIList<string>is an explicit conversion, not implicit. The cast(IList<string>) 
oal will cause an exception to be thrown at runtime since oal references an object [ ] and 
not a string[]. However, the cast (IList<string>)oa2 will not cause an exception to be 
thrown since oa2 references a string! ]. 

Whenever there is an implicit or explicit reference conversion from S[ ] to IListcT >, there 
is also an explicit reference conversion from IList<T> and its base interfaces to S[] 
(§6.2.4). 

When an array type S[ ] implements IListcT >, some of the members of the implemented 
interface may throw exceptions. The precise behavior of the implementation of the inter¬ 
face is beyond the scope of this specification. 


■■ ERIC UPPER! It's interesting to consider the counterfactual world in which the 
CLR had generic types in version 1. In that counterfactual world, there would proba¬ 
bly be generic array tj^es Array<T>, Array2<T >, and so on. In this world, declarations 
of complicated array types become more clear: An Anray<Array2<int>> is a one¬ 
dimensional array where every element is a two-dimensional array of integers. 


// Okay 

// Error: cast needed 
// Okay 
// Okay 


627 


www.it-ebooks.info 


12. Arrays 






12. Arrays 


12. Arrays 


“■ BILL WAGNER The fact that an array T [ ] implements the IList<T>by throwing 
exceptions for some methods is one of those troubling real-world problems for which 
there isn't a good solution. I List<T> has methods that add or remove elements. Arrays 
have a fixed size, however, and carmot support some of those methods. Even so, you 
want to use the random access to elements that exists in the IList<T > interface. 


12.2 Array Creation 

Array instances are created by array-creation-expressions (§7.6.10.4) or by field or local vari¬ 
able declarations that include an array-initializer (§12.6). 

When an array instance is created, the rank and length of each dimension are established 
and then remain constant for the entire lifetime of the instance. In other words, it is not 
possible to change the rank of an existing array instance, nor is it possible to resize its 
dimensions. 

An array instance is always of an array type. The System. Array type is an abstract t 5 ^e that 
cannot be instantiated. 

Elements of arrays created by array-creation-expressions are always initialized to their default 
values (§5.2). 


12.3 Array Element Access 

Array elements are accessed using element-access expressions (§7.6.6.1) of the form A[Ijj 1^, 

..., I^], where A is an expression of an array type and each is an expression of type int, 
uint, long, or along, or can be implicitly converted to one or more of these types. The result 
of an array element access is a variable—namely, the array element selected by the 
indices. 

The elements of an array can be enumerated using a foreach statement (§8.8.4). 

12.4 Array Members 

Every array type inherits the members declared by the System. Array type. 


628 


www.it-ebooks.info 






12.5 Array Covariance 


12.5 Array Covariance 

For any two reference-types A and B, if an implicit reference conversion (§6.1.6) or explicit 
reference conversion (§6.2.4) exists from A to B, then the same reference conversion also 
exists from the array type A[R] to the array type B[R], where R is any given rank-specifier 
(but the same for both array t 5 ^es). This relationship is known as array covariance. Array 
covariance, in particular, means that a value of an array t 5 ^e A[ R] may actually be a refer¬ 
ence to an instance of an array type B[R], provided an implicit reference conversion exists 
from B to A. 

Because of array covariance, assignments to elements of reference t 5 ^e arrays include a 
runtime check that ensures the value being assigned to the array element is actually of 
a permitted type (§7.17.1). For example: 

class Test 
{ 

static void Fill(object[] array, int index, int count, object value) { 
for (int i = index; i < index + count; i++) 
array[i] = value; 

} 

static void Main() { 

string!] strings = new string[100]; 

Fill(strings, 0, 100, "Undefined"); 

Fill(strings, 0, 10, null); 

Fill(strlngs, 90, 10, 0); 

} 

} 

The assignment to array [i] in the Fill method implicitly includes a runtime check that 
ensures the object referenced by value is either null or an instance that is compatible with 
the actual element tj^e of array. In Main, the first two invocations of Fill succeed, but the 
third invocation causes a System. ArrayTypeMismatchException to be thrown upon execut¬ 
ing the first assignment to array[i]. The exception occurs because a boxed int cannot be 
stored in a string array. 


“■ ERIC LI PPERT This is my candidate for "worst feature" of C#. It allows assign¬ 
ments to fail at runtime without any indication in the source code that such failure is 
possible. It imposes a performance cost on extremely common code to make a rare 
scenario go quickly; accessing an array of unsealed reference type safely happens 
much more often than covariant array conversions do. I much prefer the type-safe 
covariance that has been added to IEnumenable<T>. 


629 


www.it-ebooks.info 


12. Arrays 






12. Arrays 


12. Arrays 


“■ CHRIS SELLS I find myself using arrays so seldomly—even single-dimensional 
arrays, lef alone mulfi-dimensional or jagged arrays—fhaf fhe sfrange comer cases 
don'f fend fo maffer much. Given fhe availabilify of List<T>, Dictionary<K, V>, and 
IEnumerable<T >, I'd be a happy guy wifhouf arrays af all. 


"■ PETER SESTOFT The necessify for fhe runfime check fhaf Eric lamenfs sfems 
from fhe array fype being covarianf in fhe elemenf f 5 ^e (Student [ ] being a subf 5 ^e of 
Person [ ] when Student is a subfype of Person). This array covariance design weak¬ 
ness is shared with the Java programming language, where the situation is even worse: 
Because Java implements generics by erasure, there is no t 5 ^e object representing a 
generic t 5 ^e parameter at runtime, so the check carmot be performed if fhe array was 
creafed as new T[ ... ] for some fype paramefer T, or as new Stack<Person>[... ]. 
Hence Java musf forbid fhe creafion of an array whose elemenf f 5 ^e is a f5T’e param¬ 
efer or a f 5 ^e consfrucfed as a fype insfance of a generic fype. In C#, f 5 ^e paramefers 
and consfrucfed f 5 ^es are represenfed faifhfully af runfime, so fhese resfricfions on 
array creafion do nof exisf. 

In fhe Scala language, which was bom wifh generic f 5 ^es, fhe array f 5 T’e is invarianf 
in fhe elemenf f 5 ^e and fhe runfime check is nof needed (buf is likely fo be performed 
an 5 rway, when Scala is compiled fo Java byfecode). 


■■ BILLWAGNER Eric's commenfs go a long way foward explaining why fhe safe 
covariance and confravariance added for generics in C# 4.0 are so imporfanf. Improv¬ 
ing bofh speed and correcfness wifh fhe same change is generally rare. 


Array covariance specifically does nof exfend fo arrays of value-types. Eor example, no 
conversion exisfs fhaf permifs an int [ ] fo be freafed as an object [ ]. 

12.6 Array Initializers 

Array initializers may be specified in field declarations (§10.5), local variable declarations 
(§8.5.1), and array creafion expressions (§7.6.10.4): 

array-initializer: 

{ variable-initializer-list , } 

{ variable-initializer-list , } 


630 


www.it-ebooks.info 










12.6 Array Initializers 


variable-initializer-list: 

variable-initializer 

variable-initializer-list , variable-initializer 

variable-initializer: 

expression 

array-initializer 

An array initializer consists of a sequence of variable initializers, enclosed by "{"and "}" 
tokens and separated by "," tokens. Each variable initializer is an expression or, in the case 
of a multi-dimensional array, a nested array initializer. 

The context in which an array initializer is used determines the type of the array being 
initialized. In an array creation expression, the array type immediately precedes the initial¬ 
izer, or is inferred from the expressions in the array initializer. In a field or variable declara¬ 
tion, the array type is the type of the field or variable being declared. When an array 
initializer is used in a field or variable declaration, such as 

int[] a = {0, 2, 4, 6, 8}; 

it is simply shorthand for an equivalenf array creation expression: 
int[] a = new int[] {0, 2, A, 6, 8}; 

For a single-dimensional array, the array initializer must consist of a sequence of expres¬ 
sions that are assignment compatible with the element type of the array. The expressions 
initialize array elements in increasing order, starting with the element at index 0. The num¬ 
ber of expressions in the array initializer determines the length of the array instance being 
created. For example, the array initializer above creates an int[ ] instance of length 5 and 
then initializes the instance with the following values: 

a[0] = 0; a[l] = 2; a[2] = 4; a[3] = 6; a[4] = 8; 

For a mulfi-dimensional array, the array initializer must have as many levels of nesting as 
there are dimensions in the array. The outermost nesting level corresponds to the leftmost 
dimension and the irmermost nesting level corresponds to the rightmost dimension. The 
length of each dimension of the array is determined by the number of elements at the cor¬ 
responding nesting level in the array initializer. For each nested array initializer, the num¬ 
ber of elements must be the same as the other array initializers at the same level. The 
example 

int[,] b = {{0, 1}, {2, 3}, {4, 5}, {6, 7}, {8, 9}}; 

creates a two-dimensional array with a length of 5 for the leftmost dimension and a length 
of 2 for fhe righfmost dimension: 

int[,] b = new int[5, 2]; 


631 


www.it-ebooks.info 


12, Arrays 




12. Arrays 


12. Arrays 


It then initializes the array instance with the following values: 


b[0, 0] = 0; b[0, 1] = l; 
b[l, 0] = 2; b[l, 1] = 3; 
b[2, 0] = 4; b[2, 1] = 5; 
b[3, 0] = 6; b[3, 1] = 7; 
b[4, 0] = 8; b[4, 1] = 9; 


If a dimension ofher fhan fhe righfmosf is given wifh lengfh 0, fhe subsequenf dimensions 
are assumed fo also have lengfh 0. The example 

int[J c = {}; 

creafes a fwo-dimensional array wifh a lengfh of 0 for bofh fhe leffmosf and righfmosf 
dimensions: 

int[j] c = new int[0, 0]; 

When an array creafion expression includes bofh explicif dimension lengfhs and an array 
inifializer, fhe lengfhs musf be consfanf expressions and fhe number of elemenfs af each 
nesting level musf mafch fhe corresponding dimension lengfh. Here are some examples: 

int i = 3; 

int[] X = new int[3] {0, 1, 2}; // Okay 

int[] y = new int[i] {0, 1, 2}; // Error: i not a constant 

int[] z = new int[3] {0, 1, 2, 3}; // Error: length/initializer mismatch 

Here, fhe inifializer for y resulfs in a compile-fime error because fhe dimension lengfh 
expression is nof a consfanf, and fhe inifializer for z resulfs in a compile-fime error because 
fhe lengfh and fhe number of elemenfs in fhe inifializer do nof agree. 


632 


www.it-ebooks.info 






13. Interfaces 


An interface defines a contract. A class or struct that implements an interface must adhere 
to its contract. An interface may inherit from mulfiple base inferfaces, and a class or struct 
may implement multiple interfaces. 


“ BILL WAGNER Interfaces work besf when fhey are small in scope and few in 
number. Larger inferfaces creafe more work for implemenfers. Larger numbers of 
inferfaces provide more opporfunifies for ambiguity and collisions. 


“■ ERIC LI PPERT The trope that interfaces are confracfs is undoubfedly bofh useful 
and frequenfly sfafed. It's worth pointing out an interface is actually a pretty weak 
way to represent a contract. All an interface fells you is which mefhods are available, 
whaf fheir names are, which fypes they take, and which t 5 q)es they return. Nothing 
whatsoever about the semantics of the operation is represented in the contract: that 
an object complying with this contract must be disposed aggressively, that Drive() 
throws an exception if not called after StartEnginef), that the first parameter must 
be null and the second parameter must be non-zero, and so on. All that stuff goes in 
fhe documenfafion, nof somewhere thaf an analysis fool can dig into. The new code 
contract system that ships with version 4.0 of the CLR enables you both to specify 
contracts in more detail than interfaces do alone and fo do interesfing analysis on 
fhese contracts at compile time. 


Interfaces can contain methods, properties, events, and indexers. The interface itself does 
not provide implementations for the members that it defines. The interface merely speci¬ 
fies the members that must be supplied by classes or structs that implement the interface. 


13.1 Interface Declarations 

An interface-declaration is a type-declaration (§9.6) fhat declares a new inferface t 5 q)e. 


633 


www.it-ebooks.info 








13. Interfaces 


13. Interfaces 


interface-declaration: 

attributes , interface-modifiers , partial , interface 
identifier variant-type-parameter-listinterface-base 
type-parameter-constraints-clauses^^ interface-body 

An interface-declaration consists of an optional set of attributes (§17), followed by an optional 
set of interface-modifiers (§13.1.1), followed by an optional partial modifier, followed by 
the ke 5 rword interface and an identifier that names the interface, followed by an optional 
variant-type-parameter-list specification (§13.1.3), followed by an optional interface-base spec¬ 
ification (§13.1.4), followed by an optional type-parameter-constraints-clauses specification 
(§10.1.5), followed by an interface-body (§13.1.5), optionally followed by a semicolon. 

13.1.1 Interface Modifiers 

An interface-declaration may optionally include a sequence of interface modifiers: 

interface-modifiers: 

interface-modifier 

interface-modifiers interface-modifier 

interface-modifier: 

new 

public 

protected 

internal 

private 

It is a compile-time error for the same modifier to appear multiple times in an interface 
declaration. 

The new modifier is permitted only on interfaces defined wifhin a class. It specifies that the 
interface hides an inherited member by the same name, as described in §10.3.4. 

The public, protected, internal, and private modifiers confrol the accessibility of fhe 
interface. Depending on the context in which the interface declaration occurs, only some of 
fhese modifiers may be permitted (§3.5.1). 

13.1.2 partial Modifier 

The partial modifier indicates that this interface-declaration is a partial t 5 q)e declaration. 
Multiple partial interface declarafions wifh the same name within an enclosing namespace 
or type declaration combine to form one interface declaration, following fhe rules specified 
in §10.2. 


634 


www.it-ebooks.info 




13.1 Interface Declarations 


13.1.3 Variant Type Parameter Lists 

Variant t 5 ^e parameter lists can occur only on interface and delegate t 5 ^es. The difference 
from ordinary type-parameter-lists is the optional variance-annotation on each type 
parameter. 

variant-type-parameter-list: 

< variant-type-parameters > 

variant-type-parameters: 

attributes^^ variance-annotation^^ type-parameter 

variant-type-parameters , attributes^^ variance-annotationtype-parameter 

variance-annotation: 

in 

out 

If the variance annotation is out, the t 5 ^e parameter is said to be covariant. If the vari¬ 
ance annotation is in, the type parameter is said to be contravariant. If there is no 
variance annotation, the t 5 ^e parameter is said to be invariant. 


“■ ERIC LIPPERT Covariance is the property that a mapping from a t 5 ^e argument 
to a generic t 5 ^e preserves assignment compatibility For example, a string may be 
assigned to a variable of 1)^0 object. A mapping from T fo I Enumerable<T> preserves 
fhe assignmenf compatibility; an IEnumerable<string> can be assigned to a variable 
of IEnumerable<object>. Thus the nomenclature that "the t 5 ^e parameter is covari¬ 
ant" is a shorthand; the thing that is actually covariant is the relationship between the 
type argument and the constructed type. Properly we ought to say, "The mapping 
from —any reference type T to IEnumerable<T > is covariant in T" but that is rather a 
mouthful compared to simply saying, "T is covariant," and understanding that the 
longer statement is what is meant by it. 


In the example 

interface C<out X, in Y, Z> 

{ 

X M(Y y); 

Z P { get; set; } 

} 

X is covariant, Y is contravariant, and Z is invariant. 


635 


www.it-ebooks.info 


13. Interfaces 






13. Interfaces 


13. Interfaces 


13.1.3.1 Variance Safety 

The occurrence of variance annotations in the type parameter list of a type restricts the 
places where types can occur within the type declaration. 

A type T is output-unsafe if one of the following holds: 

• T is a contravariant t5^e parameter. 

• T is an array t5^e with an output-unsafe element type. 

• T is an interface or delegate t5^e S<A^j... A^> constructed from a generic type S<Xjj .. 
X^> where for at least one A. one of the following holds: 

- X. is covariant or invariant and A. is output-unsafe. 

- X. is contravariant or invariant and A. is input-safe. 

A type T is input-unsafe if one of the following holds: 

• T is a covariant t5^e parameter. 

• T is an array type with an input-unsafe element type. 

• T is an interface or delegate type S<A^j... A^> constructed from a generic type S<Xjj .. 
X^> where for at least one A. one of the following holds: 

- X. is covariant or invariant and A. is input-unsafe. 

- X. is contravariant or invariant and A. is output-unsafe. 

Intuitively, an output-unsafe t5^e is prohibited in an output position, and an input-unsafe 
type is prohibited in an input position. 

A t5^e is output-safe if it is not output-unsafe, and input-safe if it is not input-unsafe. 

13.1.3.2 Variance Conversion 

The purpose of variance annotations is to provide for more lenient (but still t5^e-safe) 
conversions to interface and delegate types. To this end, the definitions of implicit (§6.1) 
and explicit conversions (§ 6 . 2 ) make use of the notion of variance convertibility, which is 
defined as follows: 

AtypeT<Aj, ..., A^> is variance convertible to a type T<Bjj ..., B^> if T is either an 
interface or a delegate type declared with the variant t5^e parameters T<X^, ..., X^>, and 
for each variant type parameter X. one of the following holds: 

• X. is covariant and an implicit reference or identity conversion exists from A. to B.. 

• X. is contravariant and an implicit reference or identity conversion exists from B. 

to A.. 

1 

• X. is invariant and an identity conversion exists from A. to B.. 

636 


www.it-ebooks.info 




13.1 Interface Declarations 


“■ JON SKEET I suspect many developers will never need to declare their own 
variant interfaces or delegates. In fact, my guess is that a lot of fhe fime we won'f 
even nofice when we're using variance—if will jusf mean code fhaf we would infui- 
fively expecf fo work will now do so, even fhough if would have failed fo compile 
in C# 3.0. 


13.1.4 Base Interfaces 

An inferface can inherif from zero or more inferface fypes, which are called fhe explicit 
base interfaces of fhe inferface. When an inferface has one or more explicif base inferfaces, 
fhen in fhe declarafion of fhaf inferface, fhe inferface idenfifier is followed by a colon and 
a comma-separafed lisf of base inferface fypes. 

interface-base: 

: interface-type-list 

For a consfrucfed inferface type, the explicit base interfaces are formed by faking fhe 
explicif base inferface declarations on fhe generic type declaration, and substituting, for 
each type-parameter in fhe base inferface declarafion, fhe corresponding type-argument of fhe 
consfrucfed type. 

The explicit base interfaces of an inferface musf be af leasf as accessible as fhe inferface 
ifself (§3.5.4). For example, if is a compile-fime error fo specify a private or internal infer¬ 
face in fhe interface-base of a public inferface. 

If is a compile-fime error for an inferface fo direcfly or indirecfly inherif from ifself. 


"■ VLAD IMIR R ES H ETNIKOV For fhe purposes of fhis rule, t 5 ^e argumenfs (if any) 
are ignored. For insfance, alfhough I<T>and I<I<T>> are differenf f 5 ^es, fhe following 
declarafion is still invalid: 

interface I<T> : I<I<T>> { } 

Conversely, if is perfecfly valid for an inferface fo appear wifhin a t 5 ^e argumenf for 
ifs base inferface: 

interface IA<T> { } 

interface IB : IA<IB[]> { } // Okay 


The base interfaces of an inferface are fhe explicif base inferfaces and fheir base inferfaces. 
In ofher words, fhe sef of base inferfaces is fhe complefe fransifive closure of fhe explicif 


637 


www.it-ebooks.info 


13. Interfaces 








13. Interfaces 


13. Interfaces 


base interfaces, their explicit base interfaces, and so on. An interface inherits all members 
of its base interfaces. In the example 

interface IControl 
{ 

void Paint(); 

} 

interface ITextBox : IControl 
{ 

void SetText(string text); 

} 

interface IListBox : IControl 
{ 

void Setlterrs(string[] items); 

} 

interface IComboBox : ITextBox, IListBox { } 

the base interfaces of IComboBox are IControl, ITextBox, and IListBox. 

In other words, the IComboBox interface above inherits members SetText and Setitems as 
well as Paint. 

Every base interface of an interface must be output-safe (§13.1.3.1). A class or struct that 
implements an interface also implicitly implements all of the interface's base interfaces. 


"■ ERIC LIPPERT "Inheritance" is an unfortunate choice of words for interfaces. 
One normally thinks of inheritance from a base as sharing implementation, which 
interfaces plainly do not do. I prefer to think of interfaces as contracts that may specify 
other contracts that must also be fulfilled, rather than as contracts that "inherit" other 
contracts. 


"■ JESSE LIBE RTY A naming convention has arisen of prefixing all interfaces with 
the letter "I" (IControl, IWriteable, IClaudius). There is no compelling reason to do 
so, yet it has persisted for at least a decade as a last remnant of "Hungarian" notation. 
Removing the "I", in the end, makes for more readable code. 


13.1.5 Interface Body 

The interface-body of an interface defines the members of the interface. 
interface-body: 

{ interface-member-declarations } 


638 


www.it-ebooks.info 








13.2 Interface Members 


13.2 Interface Members 

The members of an interface are the members inherited from the base interfaces and the 
members declared by the interface itself. 

interface-member-declarations: 

interface-member-declaration 

interface-member-declarations interface-member-declaration 

interface-member-declaration: 

interface-method-declaration 

interface-property-declaration 

interface-event-declaration 

interface-indexer-declaration 

An interface declaration may declare zero or more members. The members of an interface 
must be methods, properties, events, or indexers. An interface cannot contain constants, 
fields, operators, instance constructors, destructors, or types, nor can an interface contain 
static members of any kind. 

All interface members implicitly have public access. It is a compile-time error for interface 
member declarations to include any modifiers. In particular, interfaces members cannot be 
declared with the modifiers abstract, public, protected, internal, private, virtual, 
override, or static. 


■■ JONSKEET It would occasionally be nice to be able to create an internal interface 
with internal members that could be implemented implicitly by internal methods. 
Currently an internal interface forces implementing types either to expose public 
methods or to use explicit interface implementation; in some cases, neither of these 
choices is particularly pleasant. 


The example 

public delegate void StringListEvent(IStringList sender); 

public interface IStringList 
{ 

void Add(string s); 
int Count { get; } 
event StringListEvent Changed; 
string this[lnt index] { get; set; } 

} 

declares an interface that contains one each of the possible kinds of members: a method, a 
property, an event, and an indexer. 

639 


www.it-ebooks.info 


13. Interfaces 






13. Interfaces 


13. Interfaces 


An interface-declaration creates a new declaration space (§3.3), and the mterface-memher- 
declarations immediately contained by the interface-declaration introduce new members into 
this declaration space. The following rules apply to interface-member-declarations: 

• The name of a method must differ from the names of all properties and events declared 
in the same interface. In addition, the signature (§3.6) of a method must differ from the 
signatures of all other methods declared in the same interface, and two methods declared 
in the same interface may not have signatures that differ solely by ref and out. 

• The name of a properfy or evenf musf differ from fhe names of all other members 
declared in the same interface. 

• The signature of an indexer must differ from the signatures of all other indexers declared 
in the same interface. 

The inherited members of an interface are specifically not part of the declaration space of 
fhe interface. Thus an interface is allowed to declare a member with the same name or 
signature as an inherited member. When this occurs, the derived interface member is said 
fo hide the base interface member. Hiding an inherifed member is not considered an error, 
but it does cause the compiler to issue a warning. To suppress the warning, the declaration 
of fhe derived interface member musf include a new modifier fo indicafe thaf the derived 
member is intended to hide the base member. This topic is discussed further in §3.7.1.2. 

If a new modifier is included in a declaration that doesn't hide an inherited member, a 
warning is issued to that effect. This warning is suppressed by removing the new 
modifier. 

Note that the members in class object are not, strictly speaking, members of any interface 
(§13.2). However, the members in class object are available via member lookup in any 
interface f 5 ^e (§7.4). 

13.2.1 Interface Methods 

Interface methods are declared using interface-method-declarations: 
interface-method-declaration: 

attributes^^ return-type identifier type-parameter-list 

( formal-parameter-list ) type-parameter-constraints-clauses^^ j 

The attributes, return-type, identifier, and formal-parameter-list of an interface mefhod decla- 
rafion have the same meaning as those of a method declaration in a class (§10.6). An inter¬ 
face method declaration is not permitted to specify a method body, so the declaration 
always ends with a semicolon. 


640 


www.it-ebooks.info 




13.2 Interface Members 


“■ VLADIMIR RESHETNIKOV In contrast to class or struct method declarations, 
the identifier of an interface-method-declaration can be the same as the name of the enclos¬ 
ing interface declaration. The same applies to interface-property-declarations and 
interface-event-declarations. 


Each formal parameter type of an interface method must be input-safe (§13.1.3.1), and the 
return type must be either void or output-safe. Furthermore, each class type constraint, 
interface type constraint, and type parameter constraint on any type parameter of the 
method must be input-safe. 

These rules ensure that any covariant or contravariant usage of the interface remains type- 
safe. For example, 

interface I<out T> { void M<U>() where U : T; } 

is illegal because the usage of T as a type parameter constraint on U is not input-safe. 

Were this restriction not in place, it would be possible to violate t 5 ^e safety in the following 
manner: 

class B {} 
class D : B {} 
class E : B {} 

class C : I<D> { public void M<U>() {...} } 

I<B> b = new C(); 
b.M<E>(); 

This is actually a call to C.M<E>. That call requires that E derive from D, however, so t 5 qie 
safety would be violated here. 

13.2.2 Interface Properties 

Interface properties are declared using interface-property-declarations: 
interface-property-declaration: 

attributes^^^ type identifier { interface-accessors } 

interface-accessors: 

attributes^^ get ; 
attributes , set : 

attributes^^^ get j attributes^^^ set ; 
attributes , set : attributes , get : 

The attributes, type, and identifier of an interface property declaration have the same mean¬ 
ing as those of a property declaration in a class (§10.7). 


641 


www.it-ebooks.info 


13. Interfaces 







13. Interfaces 


13. Interfaces 


The accessors of an interface property declaration correspond to the accessors of a class 
property declaration (§10.7.2), except that the accessor body must always be a semicolon. 
Thus the accessors simply indicate whether the property is read-write, read-only, or 
write-only. 

The t 5 ^e of an interface property must be output-safe if there is a get accessor, and must 
be input-safe if there is a set accessor. 

13.2.3 Interface Events 

Interface events are declared using interface-event-declarations: 

interface-event-declaration: 

attributes^^ event type identifier ; 

The attributes, type, and identifier of an interface event declaration have the same meaning 
as those of an event declaration in a class (§10.8). 

The type of an interface event must be input-safe. 

13.2.4 Interface Indexers 

Interface indexers are declared using interface-indexer-declarations: 
interface-indexer-declaration: 

attributes^^ type this [ formal-parameter-list ] { interface-accessors } 

The attributes, type, and formal-parameter-list of an interface indexer declaration have the 
same meaning as those of an indexer declaration in a class (§10.9). 

The accessors of an interface indexer declaration correspond to the accessors of a class 
indexer declaration (§10.9), except that the accessor body must always be a semicolon. Thus 
the accessors simply indicate whether the indexer is read-write, read-only, or write-only. 

All the formal parameter types of an interface indexer must be input-safe. In addition, any 
out or ref formal parameter t 5 ^es must also be output-safe. Note that even out parameters 
are required to be input-safe, due to a limitation of the underlying execution platform. 

The t 5 q)e of an interface indexer must be output-safe if there is a get accessor, and must be 
input-safe if there is a set accessor. 

13.2.5 Interface Member Access 

Interface members are accessed through member access (§ 7 . 6 . 4 ) and indexer access 
(§ 7 . 6 . 6 . 2 ) expressions of the form I .M and I [A], where I is an interface type; M is a method, 
property, or event of that interface type; and A is an indexer argument list. 


642 


www.it-ebooks.info 




13.2 Interface Members 


For interfaces that are strictly single-inheritance (each interface in the inheritance chain has 
exactly zero or one direct base interface), the effects of the member lookup (§7.4), method 
invocation (§7.6.5.1), and indexer access (§7.6.6.2) rules are exactly the same as for classes 
and structs: More derived members hide less derived members with the same name or 
signature. However, for multiple-inheritance interfaces, ambiguities can occur when two 
or more unrelated base interfaces declare members with the same name or signature. This 
section shows several examples of such situations. In all cases, explicit casts can be used to 
resolve the ambiguities. 

In the example 

interface IList 
{ 

int Count { get; set; } 

} 

interface ICounter 
{ 

void Count(int i); 

} 

interface IListCounter : IList, ICounter { } 

class C 
{ 

void Test(IListCounter x) 

{ 

x.Count(l); 

X. Count = 1; 

((IList)x).Count = 1; 

((ICounter)x).Count(1); 

} 

} 

the first two statements cause compile-time errors because the member lookup (§7.4) of 
Count in IListCounter is ambiguous. As illustrated by the example, the ambiguity is 
resolved by casting x to the appropriate base interface type. Such casts have no runtime 
costs—they merely consist of viewing the instance as a less derived type at compile time. 

In the example 

interface Ilnteger 
{ 

void Add(int i); 

} 

interface IDouble 
{ 

void Add(double d); 

} 

interface INumber : Ilnteger, IDouble { } 


// Error 
// Error 

// Okay: invokes IList.Count.set 
// Okay: invokes ICounter.Count 


643 


www.it-ebooks.info 


13. Interfaces 




13. Interfaces 


13. Interfaces 


class C 

{ 

void Test(INumber n) 

{ 

n.Add(l); 

n.Add(1.0); 

((Ilnteger)n).Add(l); 
((IDouble)n).Add(l); 

} 


// Invokes Ilnteger.Add 
// Only IDouble.Add is applicable 
// Only Ilnteger.Add is a candidate 
// Only IDouble.Add is a candidate 


the invocation n .Add(l) selects Ilnteger.Add by applying the overload resolution rules of 
§7.5.3. Similarly, the invocation n.Add(1.0) selects IDouble.Add. When explicit casts are 
inserted, there is only one candidate method and, therefore, no ambiguify. 


In fhe example 


interface IBase 

{ 

void F(int i); 

} 

interface ILeft: IBase 

{ 

new void F(int i); 

} 

interface IRight: IBase 

{ 

void G(); 

} 


interface IDerived: ILeft, IRight {} 


class A 

{ 

void Test(IDerived d) { 
d.F(l); 

((IBase)d).F(l); 

((ILeft)d).F(l); 

((IRight)d).F(l); 

} 

} 


// Invokes ILeft.F 
// Invokes IBase.F 
// Invokes ILeft.F 
// Invokes IBase.F 


fhe IBase. F member is hidden by fhe ILeft. F member. The invocafion d. F(l) fhus selecfs 
ILeft. F, even fhough IBase. F appears fo nof be hidden in fhe access pafh fhaf leads 
fhrough IRight. 


The infuifive rule for hiding in mulfiple-inherifance inferfaces is simply fhis: If a member 
is hidden in any access pafh, if is hidden in all access pafhs. Because fhe access pafh from 
IDerived fo ILeft fo IBase hides IBase. F, fhe member is also hidden in fhe access pafh 
from IDerived fo IRight fo IBase. 


644 


www.it-ebooks.info 




13.4 Interface Implementations 


13.3 Fully Qualified Interface Member Names 

An interface member is sometimes referred to by its fully qualified name. The fully quali¬ 
fied name of an interface member consists of the name of the interface in which the mem¬ 
ber is declared, followed by a dot, followed by the name of the member. The fully qualified 
name of a member references the interface in which the member is declared. For example, 
given the declarations 

interface IControl 
{ 

void PaintO; 

} 

interface ITextBox : IControl 
{ 

void SetText(string text); 

} 

the fully qualified name of Paint is IControl. Paint and the fully qualified name of 
SetTextisITextBox.SetText. 

In the example above, it is not possible to refer to Paint as ITextBox. Paint. 

When an interface is part of a namespace, the fully qualified name of an interface member 
includes the namespace name. For example: 

namespace System 
{ 

public interface ICloneable 
{ 

object CloneO; 

} 

} 

Flere, the fully qualified name of the Clone method is System. ICloneable. Clone. 


13.4 Interface Implementations 

Interfaces may be implemented by classes and structs. To indicate that a class or struct 
directly implements an interface, the interface identifier is included in the base class list of 
the class or struct. For example: 

interface ICloneable 
{ 

object CloneO; 

} 


645 


www.it-ebooks.info 


13. Interfaces 




13. Interfaces 


13. Interfaces 


interface IComparable 
{ 

int CompareTo(object other); 

} 

class ListEntry : ICloneable^ IComparable 
{ 

public object Clone() {...} 

public int CompareTo(object other) {...} 

} 


■■ JON SKEET It bugs me that the interface implementation is usually so totally 
implicit. There's no indication that the CompareTo and Clone methods have anything 
to do with the interfaces for which they're providing implementations. When overrid¬ 
ing virtual methods inherited from a base class, the override modifier makes this 
behavior obvious: Anyone refactoring a class and wanting to rename a method is 
informed fhaf if's linked fo a method elsewhere. No such indication is given for 
inf erf aces. 

Unfortunafely, the design of inferface implementafion wouldn't quite be consistent 
with adding a modifier to the declaration. The code declaring a method doesn't neces¬ 
sarily even know that it may be used to implement an interface: 

interface IFoo { void Foo(); } 
class Base 
{ 

public void Foo(); 

} 

// IFoo.Foo is implemented by Base.Foo 
class Derived : Base, IFoo { } 

This is probably fhe mosf pragmatic approach to interfaces, buf from a purity (or con¬ 
trol freak) sfandpoint, if feels slighfly wrong. 


A class or struct that directly implements an interface also direcfly implemenfs all of fhe 
inferface's base interfaces implicitly. This is true even if fhe class or sfruct doesn'f explicifly 
lisf all base inferfaces in fhe base class list. For example: 

interface IControl 
{ 

void Paint(); 

} 

interface ITextBox : IControl 
{ 

void SetText(string text); 

} 


646 


www.it-ebooks.info 






13.4 Interface Implementations 


class TextBox : ITextBox 
{ 

public void Paint() {...} 

public void SetText(string text) {...} 

} 

Here, class TextBox implements both IControl and ITextBox. 

When a class C directly implements an interface, all classes derived from C also implemenf 
fhe inferface implicifly. The base inferfaces specified in a class declarafion can be con- 
sfrucfed inferface f 5 ^es (§4.4). A base inferface cannof be a type parameter on its own, 
although it can involve the t 5 ^e parameters that are in scope. The following code illus- 
frafes how a class can implemenf and exfend consfrucfed fypes: 

class C<U, V> { } 
interface I1<V> { } 

class D : Ccstringj int>, Il<string> { } 
class E<T> : C<int, T>, I1<T> { } 

The base inferfaces of a generic class declarafion musf safisfy fhe uniqueness rule described 
in §13.4.2. 

13.4.1 Explicit Interface Member Implementations 

For purposes of implemenfing inferfaces, a class or sfrucf may declare explicit interface 
member implementations. An explicif inferface member implemenfafion is a mefhod, 
properfy, evenf, or indexer declaration that references a fully qualified inferface member 
name. For example: 

interface IList<T> 

{ 

T[] GetElements(); 

} 

interface IDictionarycK,V> 

{ 

V this[K key]; 

void Add(K key, V value); 

} 

class List<T>: IList<T>, IDictionary<int,T> 

{ 

T[] IList<T>.GetElements() {...} 

T IDictionary<int,T>.this[int index] {...} 
void IDictionary<int,T>.Add(int index, T value) {...} 

} 


647 


www.it-ebooks.info 


13. Interfaces 




13. Interfaces 


13. Interfaces 


Here IDictionary<intjT>-this and IDictionary<intjT>.Add are explicit interface mem¬ 
ber implementations. 

In some cases, the name of an inferface member may nof be appropriafe for fhe implemenf- 
ing class, in which case fhe inferface member may be implemenfed using explicif inferface 
member implemenfafion. A class implemenfing a file absfracfion, for example, would 
likely implemenf a Close member funcfion fhaf has fhe effecf of releasing fhe file resource, 
and implemenf fhe Dispose mefhod of fhe IDisposable inferface using explicif inferface 
member implemenfafion: 

interface IDisposable 
{ 

void DisposeO; 

} 

class MyFile : IDisposable 
{ 

void IDisposable.DisposeO 
{ 

CloseO; 

} 

public void Close() 

{ 

// Do what's necessary to close the file 
System.GC.SuppressFinalize(this); 

} 

} 

If is nof possible fo access an explicif inferface member implemenfafion fhrough ifs fully 
qualified name in a mefhod invocafion, properfy access, or indexer access. An explicif 
inferface member implemenfafion can be accessed only fhrough an inferface insfance, and 
is in fhaf case referenced simply by ifs member name. 

If is a compile-fime error for an explicif inferface member implemenfafion fo include access 
modifiers, and if is a compile-fime error fo include fhe modifiers abstract, virtual, 
override, or static. 

Explicif inferface member implemenfafions have differenf accessibilify characferisfics fhan 
ofher members. Because explicif inferface member implemenfafions are never accessible 
fhrough fheir fully qualified names in a mefhod invocafion or a properfy access, fhey are, 
in a sense, privafe. However, because fhey can be accessed fhrough an inferface insfance, 
fhey are, in a sense, also public. 


“■ VLAD IMIR R ES H ETNIKOV For fhe purposes of accessibilify consfraints checking 
(see §3.5.4), explicif inferface implemenfafions are considered privafe. 


648 


www.it-ebooks.info 






13.4 Interface Implementations 


Explicit interface member implementations serve two primary purposes: 

• Because explicit interface member implemenfafions are nof accessible fhrough class or 
sfrucf insfances, fhey allow inferface implemenfafions fo be excluded from fhe public 
inferface of a class or sfrucf. This is parficularly useful when a class or sfrucf implemenfs 
an infernal inferface fhaf is of no inferesf fo a consumer of fhaf class or strucf. 

• Explicif inferface member implemenfafions allow disambiguafion of inferface members 
wifh fhe same signafure. Wifhouf explicif inferface member implemenfafions, if would 
be impossible for a class or sfrucf fo have differenf implemenfafions of inferface mem¬ 
bers wifh fhe same signafure and refurn fype, as would if be impossible for a class or 
sfrucf fo have any implemenfafion af all of inferface members wifh fhe same signafure 
buf wifh differenf refurn f 5 ^es. 


■■ JON SKEET The somewhaf canonical example of fhis second case is 
IEnumerable<T >, which exfends fhe confracf of lEnumerable. Thaf means implemenfa¬ 
fions have fo provide fwo mefhods: 

lEnumerator GetEnumerator() 

IEnumerator<T> GetEnumerator() 

This is fypically done by explicifly implemenfing fhe nongeneric lEnumerable. 
GetEnumeratorf ) fo call fhe generic version—^which works because IEnumerator<T> 
and lEnumerator have fhe same kind of relafionship. 


Eor an explicif inferface member implemenfafion fo be valid, fhe class or sfrucf musf name 
an inferface in ifs base class lisf fhaf confains a member whose fully qualified name, type, 
and parameter types exactly match those of fhe explicif inferface member implemenfafion. 
Thus, in fhe following class 

class Shape: ICloneable 
{ 

object ICloneable.CloneO {...} 

int IComparable.CompareTo(object other) {...} // Invalid 

} 

fhe declarafion of IComparable.CompareTo resulfs in a compile-fime error because 
IComparable is nof lisfed in fhe base class lisf of Shape and is nof a base inferface 
of ICloneable. Likewise, in fhe declarafions 


class Shape: ICloneable 
{ 

object ICloneable.CloneO {■••} 

} 


649 


www.it-ebooks.info 


13. Interfaces 






13. Interfaces 


13. Interfaces 


class Ellipse: Shape 
{ 

object ICloneable.CloneO {...} // Invalid 

} 

the declaration of ICloneable.Clone in Ellipse results in a compile-time error because 
ICloneable is not explicitly listed in the base class list of Ellipse. 

The fully qualified name of an inferface member musf reference fhe inferface in which fhe 
member was declared. Thus, in fhe declarations 

interface IControl 
{ 

void Paint(); 

} 

interface ITextBox: IControl 
{ 

void SetText(string text); 

} 

class TextBox: ITextBox 
{ 

void IControl.PaintO {...} 

void ITextBox.SetText(string text) {...} 

} 

fhe explicif inferface member implemenfafion of Paint musf be wriffen as IControl. 
Paint. 

13.4.2 Uniqueness of Implemented Interfaces 

The interfaces implemented by a generic type declaration must remain unique for all pos¬ 
sible constructed types. Without this rule, it would be impossible to determine the correct 
method to call for certain constructed tjq^es. For example, suppose a generic class declara¬ 
tion were permitted to be written as follows: 

interface I<T> 

{ 

void F(); 

} 

class X<U,V>: I<U>, I<V> // Error: I<U> and I<V> conflict 
{ 

void I<U>.F() {...} 
void I<V>.F() {...} 

} 


www.it-ebooks.info 




13.4 Interface Implementations 


Were this permitted, it would be impossible to determine which code would execute in the 
following case: 

I<int> X = new X<int,int>(); 
x.F(); 

To determine if the interface list of a generic t 5 ^e declaration is valid, the following steps 
are performed: 

• Let L be the list of interfaces directly specified in a generic class, struct, or interface dec¬ 
laration C. 

• Add to L any base interfaces of the interfaces already in L. 

• Remove any duplicates from L. 

• If any possible constructed t 5 ^e created from C would, affer type arguments are substi¬ 
tuted into L, cause two interfaces in L to be identical, then the declaration of C is invalid. 
Constraint declarations are not considered when determining all possible constructed 
types. 

In the class declaration X above, the interface lisf L consists of I<L)> and I<V>. The declara- 
fion is invalid because any consfructed type with U and V being the same t 5 ^e would cause 
these two interfaces to be identical t 5 ^es. 

It is possible for interfaces specified at different inheritance levels to unify: 

interface I<T> 

{ 

void F(); 

} 

class Base<U>: I<U> 

{ 

void I<U>.F() {...} 

} 

class Derived<U,V>: BasecUx, I<V> // Okay 
{ 

void I<V>.F() {...} 

} 

This code is valid even though Derived<U, V> implements both I<U> and I<V>. The code 

I<int> X = new Derived<int,int>(); 
x.F(); 

invokes the method in Derived, since Derivedcint, int> effectively reimplements I<int> 
(§13.4.6). 


651 


www.it-ebooks.info 


13. Interfaces 




13. Interfaces 


13. Interfaces 


“■ ERIC LIPPERT Although it is not legal to create classes such that two interfaces 
can become identical under construction, it is possible in C# 4.0 to create classes that 
are ambiguous in various, more subtle ways thanks to generic covariance and contra- 
variance. Imagine, for example, a base class fhaf implemenfs IEnumerable<object> 
and a derived class fhaf implemenfs IEnumerable<string>. These were incompatible 
fypes in C# 3.0, buf fhaf is no longer fhe case. Because IEnumerable<string> is now 
convertible fo IEnumerable<object>, if's nof entirely clear which implemenfafion will 
be called when a mefhod of IEnumerable<object> is invoked on fhe derived class. 
These sorfs of bizarre scenarios fend fo expose implemenfafion-defined behavior of 
fhe runfime and should be avoided whenever possible. 


13.4.3 Implementation of Generic Methods 

When a generic method implicitly implements an interface method, the constraints given 
for each method type parameter must be equivalent in both declarations (after any inter¬ 
face t 5 q)e parameters are replaced with the appropriate type arguments), where method 
type parameters are identified by ordinal positions, left to right. 

When a generic method explicitly implements an interface method, however, no con¬ 
straints are allowed on the implementing method. Instead, the constraints are inherited 
from the interface method: 

interface I<A, B, C> 

{ 

void F<T>(T t) where T ; A; 
void G<T>(T t) where T ; B; 
void H<T>(T t) where T : C; 

} 

class C : Icobject, C, string> 

{ 

public void F<T>(T t) {...} 
public void G<T>(T t) where T 
public void FI<T>(T t) where T 

} 

The method C. F<T> implicitly implements I<object,C, string>. F<T>. In this case, C. F<T> 
is not required (nor permitted) to specify the constraint T : object since object is an implicit 
constraint on all type parameters. The method C.G<T> implicitly implements 
I<object,C,string>.G<T> because the constraints match those in the interface, after the 
interface type parameters are replaced with the corresponding type arguments. The con¬ 
straint for method C. H<T > is an error because sealed t 5 q)es (string in this case) carmot be 
used as constraints. Omitting the constraint would also be an error since constraints of 


// Okay 

: C {...} // Okay 

: string {...} // Error 


652 


www.it-ebooks.info 







13.4 Interface Implementations 


implicit interface method implementations are required to match. Thus it is impossible to 
implicitly implement I<objectjCjString>.H<T>. This interface method can be imple¬ 
mented only using an explicit interface member implemenfafion: 

class C: I<objectjCjString> 

{ 

public void H<U>(U u) where U: class {...} 

void I<objectjCjString>.H<T>(T t) { 
string s = t; // Okay 
H<T>(t); 

} 

} 

In fhis example, the explicit interface member implemenfafion invokes a public mefhod 
having stricfly weaker consfrainfs. Nofe fhaf fhe assignmenf from t fo s is valid since 
T inherifs a consfrainf of T : string, even though this constraint is not expressible in 
source code. 

13.4.4 Interface Mapping 

A class or struct must provide implementations of all members of fhe inferfaces fhaf are 
lisfed in fhe base class lisf of fhe class or sfrucf. The process of locafing implemenfafions of 
inferface members in an implemenfing class or strucf is known as interface mapping. 

Inferface mapping for a class or sfrucf C locafes an implemenfafion for each member of 
each inferface specified in fhe base class lisf of C. The implemenfafion of a parficular infer¬ 
face member I . M, where I is fhe inferface in which fhe member M is declared, is defermined 
by examining each class or sfrucf S, sfarfing wifh C and repeating for each successive base 
class of C, until a mafch is locafed: 

• If S confains a declarafion of an explicif inferface member implemenfafion fhaf mafches 
I and M, fhen fhis member is fhe implemenfafion of I. M. 

• Ofherwise, if S confains a declarafion of a nonsfafic public member fhaf mafches M, fhen 
fhis member is fhe implemenfafion of I. M. If more fhan one member mafches, if is 
imspecified which member is fhe implemenfafion of I. M. This sifuafion can occur only 
if S is a consfrucfed type where the two members as declared in the generic t 5 q)e have 
different signatures, but the type arguments make their signatures identical. 

A compile-time error occurs if implemenfafions cannof be locafed for all members of all 
inferfaces specified in fhe base class lisf of C. Nofe fhaf fhe members of an inferface include 
fhose members fhaf are inherifed from base inferfaces. 


653 


www.it-ebooks.info 


13. Interfaces 




13. Interfaces 


13. Interfaces 


For purposes of interface mapping, a class member A matches an interface member 
B when: 

• A and B are methods, and the name, type, and formal parameter lists of A and B are 
identical. 

• A and B are properties, the name and t 5 ^e of A and B are identical, and A has the same 
accessors as B (A is permitted to have additional accessors if it is not an explicit interface 
member implementation). 

• A and B are events, and the name and t 5 ^e of A and B are identical. 

• A and B are indexers, the type and formal parameter lists of A and B are identical, and A 
has the same accessors as B (A is permitted to have additional accessors if it is not an 
explicit interface member implementation). 

Notable implications of the interface mapping algorithm are as follows: 

• Explicit interface member implementations take precedence over other members in the 
same class or struct when determining the class or struct member that implements an 
interface member. 

• Neither non-public nor static members participate in interface mapping. 

In the example 

interface ICloneable 
{ 

object CloneO; 

} 

class C : ICloneable 
{ 

object ICloneable.CloneO {...} 
public object Clone() {...} 

} 

the ICloneable.Clone member of C becomes the implementation of Clone in ICloneable 
because explicit interface member implementations take precedence over other members. 

If a class or struct implements two or more interfaces containing a member with the same 
name, type, and parameter types, it is possible to map each of those interface members 
onto a single class or struct member. For example: 

interface IControl 
{ 

void PaintO; 

} 


654 


www.it-ebooks.info 




13.4 Interface Implementations 


interface IForm 
{ 

void PaintO; 

} 

class Page : IControlj IForm 
{ 

public void Paint() {...} 

} 

Here, the Paint methods of both IControl and IForm are mapped onto the Paint method 
in Page. It is, of course, also possible to have separate explicit interface member implemen- 
fafions for the two methods. 

If a class or sfruct implements an interface that contains hidden members, then some mem¬ 
bers must necessarily be implemented through explicit interface member implementations. 
For example: 

interface IBase 
{ 

int P { get; } 

} 

interface IDerived : IBase 
{ 

new int P(); 

} 

An implementation of this interface would require at least one explicit interface member 
implementation, and would take one of the following forms: 

class C : IDerived 
{ 

int IBase.P { get {...} } 
int IDerived.P() {...} 

} 

class C : IDerived 
{ 

public int P { get {...} } 
int IDerived.P() {...} 

} 

class C : IDerived 
{ 

int IBase.P { get {...} } 
public int P() {... } 

} 


655 


www.it-ebooks.info 


13. Interfaces 




13. Interfaces 


13. Interfaces 


When a class implements multiple interfaces that have the same base interface, fhere can 
be only one implemenfafion of fhe base inferface. In fhe example 

interface IControl 
{ 

void Paint(); 

} 

interface ITextBox : IControl 
{ 

void SetText(string text); 

} 

interface IListBox : IControl 
{ 

void Setlterrs(string[] items); 

} 

class ComboBox ; IControl, ITextBox, IListBox 
{ 

void IControl.Paint() {...} 

void ITextBox.SetText(string text) {...} 

void IListBox.Setltems(string[] items) {...} 

} 

if is nof possible fo have separafe implemenfafions for fhe IControl named in fhe base 
class lisf, fhe IControl inherifed by ITextBox, and fhe IControl inherifed by IListBox. 
Indeed, fhere is no notion of a separafe identify for fhese inferfaces. Rafher, fhe implemen¬ 
fafions of ITextBox and IListBox share fhe same implemenfafion of IControl, and 
ComboBox is simply considered fo implemenf fhree inferfaces: IControl, ITextBox, and 
IListBox. 

The members of a base class parficipafe in inferface mapping. In fhe example 

interface Interfacel 
{ 

void F(); 

} 

class Classl 
{ 

public void F() { } 
public void G() { } 

} 

class Class2 : Classl, Interfacel 
{ 

new public void G() { } 

} 

fhe mefhod F in Classl is used in Class2's implemenfafion of Interfacel. 


656 


www.it-ebooks.info 




13.4 Interface Implementations 


13.4.5 Interface Implementation Inheritance 

A class inherits all interface implementations provided by its base classes. 


“■ BILL WAG N E R Eric's earlier comment about "inheritance" being an unfortunate 
word choice is even more true in this section. Interface methods behave differently 
than either virtual or non-virtual methods declared in base classes. It can take some 
time to get your mind around exactly which method is the best choice when multiple 
classes in a hierarchy declare implementation of an interface. As you read this section, 
you'll see many different rules for selecting the best method when that method is 
defined in an interface. 


Without explicitly reimplementing an interface, a derived class cannot in any way alter 
the interface mappings it inherits from its base classes. For example, in the 
declarations 

interface IControl 
{ 

void Paint(); 

} 

class Control : IControl 
{ 

public void Paint() {...} 

} 

class TextBox : Control 
{ 

new public void Paint() {...} 

} 


the Paint method in TextBox hides the Paint method in Control, but it does not alter the 
mapping of Control. Paint onto IControl. Paint, and calls to Paint through class instances 
and interface instances will have the following effects: 


Control c = 
TextBox t = 
IControl ic 
IControl it 
c.PaintO; 
t.Paint(); 
ic.Paint(); 
it.PaintO; 


new ControlO; 
new TextBoxO; 
= c; 

= t; 

// 

// 

// 

// 


Invokes 

Invokes 

Invokes 

Invokes 


Control. 
TextBox. 
Control. 
Control. 


Paint(); 
Paint(); 
Paint(); 
Paint(); 


657 


www.it-ebooks.info 


13. Interfaces 






13. Interfaces 


13. Interfaces 


However, when an interface method is mapped onto a virtual method in a class, it is pos¬ 
sible for derived classes to override the virtual method and alter the implementation of the 
interface. For example, after rewriting the declarations above to 

interface IControl 
{ 

void PaintO; 

} 

class Control: IControl 
{ 

public virtual void Paint() {...} 

} 

class TextBox: Control 
{ 

public override void Paint() {...} 

} 


the following effects will now be observed: 


Control c = new Control(); 
TextBox t = new TextBox(); 


IControl ic 
IControl it 
c. PaintO; 
t. PaintO; 
ic. PaintO > 
it.PaintO; 


c; 

t; 


// Invokes Control.PaintO; 
// Invokes TextBox.PaintO; 
// Invokes Control.PaintO; 
// Invokes TextBox.PaintO; 


Since explicit interface member implementations carmot be declared as virtual, it is not 
possible to override an explicit interface member implementation. However, it is perfectly 
valid for an explicit interface member implementation to call another method, and that 
other method can be declared as virtual to allow derived classes to override it. For 
example: 

interface IControl 
{ 

void PaintO; 

} 

class Control: IControl 
{ 

void IControl.PaintO t PaintControlO; } 

protected virtual void PaintControlO {■••} 

} 

class TextBox: Control 
{ 

protected override void PaintControlO {•••} 

} 


658 


www.it-ebooks.info 




13.4 Interface Implementations 


Here, classes derived from Control can specialize the implementation of IControl.Paint 
by overriding the PaintControl method. 

13.4.6 Interface Reimplementation 

A class that inherits an interface implementation is permitted to reimplement the interface 
by including it in the base class list. 

A reimplementation of an interface follows exactly the same interface mapping rules as an 
initial implementation of an interface. Thus the inherited interface mapping has no effect 
whatsoever on the interface mapping established for the reimplementation of the interface. 
For example, in the declarations 

interface IControl 
{ 

void Paint(); 

} 

class Control: IControl 
{ 

void IControl.Paint() {...} 

} 

class MyControl: Control, IControl 
{ 

public void Paint() {} 

} 

the fact that Control maps IControl. Paint onto Control. IControl. Paint doesn't affect 
the reimplementation in MyControl, which maps IControl. Paint onto MyControl. Paint. 

Inherited public member declarations and inherited explicit interface member declarations 
participate in the interface mapping process for reimplemented interfaces. For example: 

interface IMethods 
{ 

void F(); 
void G(); 
void H(); 
void I(); 

} 

class Base: IMethods 
{ 

void IMethods.F() {} 
void IMethods.G() {} 
public void H() {} 
public void I() {} 

} 


659 


www.it-ebooks.info 


13. Interfaces 




13. Interfaces 


13. Interfaces 


class Derived: Base, IMethods 
{ 

public void F() {} 
void IMethods.H() {} 

} 

Here, the implementation of IMethods in Derived maps the interface mefhods onfo 
Derived.F, Base.IMethods.G, Derived.IMethods.H, and Base. I. 

When a class implemenfs an inferface, if implicifly also implemenfs all of fhaf inferface's 
base inf erf aces. Likewise, a reimplemenfafion of an inferface is also implicifly a reimple- 
menfafion of all of fhe inferface's base inferfaces. For example: 

interface IBase 
{ 

void F(); 

} 

interface IDerived: IBase 
{ 

void G(); 

} 

class C: IDerived 
{ 

void IBase.F() {... } 
void IDerived.G() {...} 

} 

class D: C, IDerived 
{ 

public void F() {...} 
public void G() {...} 

} 

Here, fhe reimplemenfafion of IDerived also reimplemenfs IBase, mapping IBase. F 
onfo D.F. 


■■ JONSKEET While fhis sorf of fhing is genuinely useful on cerfain occasions, if 
should f5^ically be avoided because if is a source of greaf confusion. Usually, every 
call using fhe same mefhod name and fhe same argumenf lisf on fhe same objecf 
should resulf in fhe same mefhod being invoked. There are any number of ways fo 
sfray from fhis happy sifuafion, and fhey should all be used wifh exfreme caufion, and 
only where absolufely necessary. 


660 


www.it-ebooks.info 






13.4 Interface Implementations 


13.4.7 Abstract Classes and Interfaces 

Like a nonabstract class, an abstract class must provide implementations of all members of 
fhe interfaces that are listed in the base class list of the class. However, an abstract class is 
permitted to map interface methods onto abstract methods. For example: 

interface IMethods 
{ 

void F(); 
void G(); 

} 

abstract class C: IMethods 
{ 

public abstract void F(); 
public abstract void G(); 

} 

Here, the implementation of IMethods maps F and G onto abstract methods, which must be 
overridden in nonabstract classes that derive from C. 

Note that explicit interface member implementations carmot be abstract, but explicit inter¬ 
face member implementations are, of course, permitted to call abstract methods. For 
example: 

interface IMethods 
{ 

void F(); 
void G(); 

} 

abstract class C: IMethods 
{ 

void IMethods.F() { FF(); } 
void IMethods.G() { GG(); } 
protected abstract void FF(); 
protected abstract void GG(); 

} 

Here, nonabstract classes that derive from C would be required fo override FF and GG, fhus 
providing the actual implementation of IMethods. 


661 


www.it-ebooks.info 


13. Interfaces 




This page intentionally left blank 


www.it-ebooks.info 


14. Enums 


An enum type is a distinct value t5^e (§ 4 . 1 ) that declares a set of named constants. 


"■ JON SKEET Notably, these "named constants" are effectively just numbers. They 
cannot express behavior, contrary to almost everything else in C#. This is one of the 
very few areas where Java is more expressive than C#. In Java, enums have a lot more 
power: An enum can declare methods and then override them for specific values, for 
example. While if's possible to emulate some of the features of Java enums within C#, 
language (and framework) supporf in a future version would be extremely welcome. 


The example 

enum Color 
{ 

Red, 

Green, 

Blue 

} 

declares an enum t5^e named Color with members Red, Green, and Blue. 


14.1 Enum Declarations 

An enum declaration declares a new enum t5^e. An enum declaration begins with the 
ke5rword enum, and defines the name, accessibility, underlying type, and members of 
fhe enum. 

enum-declaration: 

attributes^^^ enum-modifiers^^ enum identifier enum-base^^ enum-body 

enum-base: 

: integral-type 

enum-body: 

{ enum-member-declarations , } 

{ enum-member-declarations , } 


663 


www.it-ebooks.info 






14. Enums 


14. Enums 


Each enum t5^e has a corresponding integral type called the underlying type of the enum 
type. This underlying type must be able to represent all the enumerator values defined in 
fhe enumeration. An enum declarafion may explicifly declare an underlying fype of byte, 
sbyte, short, ushort, int, uint, long, or ulong. Nofe fhaf char carmof be used as an under¬ 
lying fype. An enum declarafion fhaf does nof explicifly declare an underlying fype has an 
underlying f5^e of int. 


■■ JON SKEET This is one of fhe only places in fhe language where you cannof 
replace fhe "shorfhand" version of a t5^e wifh ifs full equivalenf. For example, you 
carmof declare fhe Color enum as follows: 

enum Color; System.Int64 { ... } 


The example 

enum Color : long 
{ 

Red, 

Green, 

Blue 

} 

declares an enum with an underlying t5q)e of long. A developer mighf choose fo use an 
underlying f5qie of long, as in fhe example, fo enable fhe use of values fhaf are in fhe range 
of long buf nof in fhe range of int, or fo preserve fhis option for fhe fufure. 


14.2 Enum Modifiers 

An enum-declaration may opfionally include a sequence of enum modifiers: 

enum-modifiers: 

enum-modifier 

enum-modifiers enum-modifier 

enum-modifier: 

new 

public 

protected 

internal 

private 

If is a compile-fime error for fhe same modifier fo appear mulfiple fimes in an enum 
declarafion. 


664 


www.it-ebooks.info 






14.3 Enum Members 


The modifiers of an enum declarafion have fhe same meaning as fhose of a class declara- 
fion (§ 10 . 1 . 1 ). Nofe, however, fhaf fhe abstract and sealed modifiers are nof permiffed in 
an enum declaration. Enums carmot be abstract and do not permit derivation. 


14.3 Enum Members 

The body of an enum type declaration defines zero or more enum members, which are the 
named constants of the enum tj^e. No two enum members can have the same name. 

enum-member-declarations: 

enum-member-declaration 

enum-member-declarations , enum-member-declaration 

enum-member-declaration: 
attributes^^i identifier 

attributes^^i identifier - constant-expression 


"■ VLADIMIR RESHETNIKOV In the Microsoft implementation of C#, an enum 

member cannot have the name value_, because this name is reserved for the internal 

representation of enums. 


Each enum member has an associated constant value. The t5^e of this value is the under¬ 
lying t5^e for the containing enum. The constant value for each enum member must be in 
the range of the underlying t5^e for the enum. The example 

enum Color : uint 
{ 

Red = - 1 , 

Green = - 2 , 

Blue = -3 

} 

results in a compile-time error because the constant values - 1 , - 2 , and -3 are not in the 
range of the underlying integral type uint. 

Multiple enum members may share the same associated value. The example 

enum Color 
{ 

Red, 

Green, 

Blue, 

Max = Blue 

} 


665 


www.it-ebooks.info 


14. Enums 






14. Enums 


14. Enums 


shows an enum in which two enum members— Blue and Max —have the same associated 
value. 

The associated value of an enum member is assigned either implicitly or explicitly. If fhe 
declarafion of fhe enum member has a constant-expression initializer, fhe value of fhaf con- 
sfanf expression, implicifly converfed fo fhe underlying fype of fhe enum, is fhe associafed 
value of fhe enum member. If fhe declarafion of fhe enum member has no inifializer, ifs 
associafed value is sef implicifly, as follows: 

• If fhe enum member is fhe firsf enum member declared in fhe enum f5^e, ifs associafed 
value is 0. 

• Ofherwise, fhe associafed value of fhe enum member is obfained by increasing fhe asso¬ 
ciafed value of fhe fexfually preceding enum member by 1. This increased value musf 
be wifhin fhe range of values fhaf can be represenfed by fhe underlying fype; ofherwise, 
a compile-fime error occurs. 


"■ JON SKEET Using fhe defaulf values is almosf always fhe wrong fhing fo do for 
a [Flags] enum where f5^ically values should be 1, 2, 4, 8, and so on—of fen wifh a 
"None" value for 0. The language could have helped fo avoid developers from acci- 
denfally using inappropriafe values, buf if's hard fo judge how well fhis goal could be 
achieved wifhouf adding more complexify fhan is merifed. 


“■ BILL WAGNER I would prefer fo see fhe following example implemenfed using 
exfension mefhods. "Color.Red.StringFromColor()" jusf reads better fo me fhan 
"StringFromColorfColor.Red)". 

Thaf fechnique also sfarfs fo address Jon's commenf abouf nof being able fo express 
behavior. 


The example 

using System; 

enum Color 
{ 

Red, 

Green = 10, 
Blue 


666 


www.it-ebooks.info 








14.3 Enum Members 


class Test 
{ 

static void Main() 

{ 

Console.WriteLine(StringFromColor(Color.Red)); 
Console.WriteLine(StringFromColor(Color.Green)); 
Console.WriteLlne(StringFromColor(Color.Blue)); 

} 


static string StringFromColor(Color c) 
{ 

switch (c) 

{ 


case Color.Red: 

return String.Forrrat("Red = {0}", (int)c); 
case Color.Green: 

return String.Forrrat("Green = {0}", (int)c); 
case Color.Blue: 

return String.Format("Blue = {0}"j (Int)c); 


} 


} 


} 


default: 

return "Invalid color"; 


prints out the enum member names and their associated values. The output is 


Red = 0 
Green = 10 
Blue = 11 


for the following reasons: 

• The enum member Red is automatically assigned the value zero (since it has no initial¬ 
izer and is the first enum member). 

• The enum member Green is explicitly given the value 10. 

• The enum member Blue is automatically assigned the value 1 greater than the member 
that textually precedes it. 

The associated value of an enum member may not, directly or indirectly, use the value of 
its own associated enum member. Other than this circularity restriction, enum member 
initializers may freely refer to other enum member initializers, regardless of fheir fexfual 
position. Within an enum member initializer, values of ofher enum members are always 
treated as having the t5^e of their underlying type, so that casts are not necessary when 
referring fo ofher enum members. 

The example 


667 


www.it-ebooks.info 


14. Enums 




14. Enums 


14. Enums 


enum Circular 
{ 

A = Bj 
B 

} 

results in a compile-time error because the declarations of A and B are circular. A depends 
on B explicitly, and B depends on A implicitly. 

Enum members are named and scoped in a manner exactly analogous to fields within 
classes. The scope of an enum member is the body of its containing enum t 5 ^e. Within that 
scope, enum members can be referred to by their simple names. From all other code, the 
name of an enum member must be qualified wifh fhe name of its enum t 5 qie. Enum mem¬ 
bers do not have any declared accessibility—an enum member is accessible if ifs confain- 
ing enum t 5 q)e is accessible. 

14.4 The System.Enum Type 

The type System. Enum is the abstract base class of all enum types (this is distinct and differ¬ 
ent from fhe underlying t 5 q)e of the enum type), and the members inherited from System. 
Enum are available in any enum fype. A boxing conversion (§4.3.1) exisfs from any enum 
fype to System. Enum, and an unboxing conversion (§4.3.2) exists from System. Enum to any 
enum t 5 q)e. 

Note that System. Enum is not itself an enum-type. Rather, it is a class-type from which all 
enum-types are derived. The type System. Enum inherits from the t 5 q)e System.ValueType 
(§4.1.1), which in turn inherits from f 5 q)e object. Af runtime, a value of type System. Enum 
can be null or a reference to a boxed value of any enum type. 


14.5 Enum Values and Operations 

Each enum type defines a distinct type; an explicit enumeration conversion (§6.2.2) is 
required to convert between an enum type and an integral type, or between two enum 
types. The set of values that an enum type can take on is not limited by its enum members. 
In particular, any value of the underlying type of an enum can be cast to the enum type, 
and is a distinct valid value of that enum type. 

Enum members have the type of their containing enum type (except within other enum 
member initializers; see §14.3). The value of an enum member declared in enum type E 
with associated value v is ( E ) v. 


668 


www.it-ebooks.info 




14.5 Enum Values and Operations 


The following operators can be used on values of enum t 5 ^es: ==, ! =, <, >, <=, >= (§7.10.5), 
binary + (§7.8.4), binary - (§7.8.5), &, | (§7.11.2), ~ (§7.7.4), and ++ and -- (§7.6.9 and 

§7.7.5). 


■■ JONSKEET Some of these operators really make sense just for enums decorated 
with [Flags], but the language does not enforce this limitation in any sense. 


Every enum t 5 ^e automatically derives from the class System .Enum (which, in turn, derives 
from System. ValueType and object). Thus inherited methods and properties of this class 
can be used on values of an enum t 5 ^e. 


669 


www.it-ebooks.info 


14. Enums 






This page intentionally left blank 


www.it-ebooks.info 


15. Delegates 


Delegates enable scenarios that other languages—such as C++, Pascal, and Modula—have 
addressed with function pointers. Unlike C++ function pointers, however, delegates are 
fully objecf orienfed. Also, unlike C++ poinfers fo member fimcfions, delegafes encapsu- 
lafe bofh an objecf insfance and a mefhod. 


“■ BILL WAGNER I experience a sfrange sense of amazemenf upon reading fhis 
small chapfer in fhe language specification. Delegafes have been parf of C# since fhe 
1.0 release. Af fhaf time, mosf of fhe C# communify (including me) saw delegates as a 
little extra ceremony around events. Ten years later, I can't imagine the C# language 
without delegates. They are something most of us use every day in LINQ queries, 
funcfion composition, closures, and more. Delegafes and fhe concepf of freafing code 
as dafa are an infegral parf of so much of fhe modern .NET ecosysfem fhaf 1 can'f 
imagine programming in a language fhaf does nof allow me fo express fhe concepf of 
funcfions (and acfions) as dafa. 


Adelegafe declaration defines a class fhaf is derived from fhe class System.Delegate. A 
delegafe insfance encapsulafes an invocation lisf, which is a lisf of one or more mefhods, 
each of which is referred fo as a callable enfify. For insfance mefhods, a callable enfify con- 
sisfs of an insfance and a mefhod on fhaf insfance. For sfafic mefhods, a callable entify 
consisfs of jusf a mefhod. Invoking a delegafe insfance wifh an appropriafe sef of argu- 
menfs causes each of fhe delegafe's callable entities fo be invoked wifh fhe given sef of 
argumenfs. 

An inferesfing and useful properly of a delegafe insfance is fhaf if does nof know or care 
abouf fhe classes of fhe mefhods if encapsulafes; all fhaf maffers is fhaf fhose mefhods be 
compatible (§15.1) wifh fhe delegafe's t 5 q)e. This makes delegafes perfecfly suifed for 
"anonymous" invocation. 


671 


www.it-ebooks.info 






15. Delegates 


15. Delegates 


“■ ERICLIPPERT Delegates are typically quite confusing the first time a developer 
encounters them. I like to think of a delegafe type as something akin to an interface 
wifh exacfly one mefhod on if; an insfance of a delegafe f 5 q)e is an objecf fhaf imple- 
menfs fhis mefhod. 


15.1 Delegate Declarations 

A delegate-declaration is a type-declaration (§9.6) fhaf declares a new delegafe type. 
delegate-declaration: 

attributes^^i delegate-modifiers delegate return-type 
identifier variant-type-parameter-list 

( formal-parameter-list) type-parameter-constraints-clauses^^ ; 

delegate-modifiers: 

delegate-modifier 

delegate-modifiers delegate-modifier 

delegate-modifier: 

new 

public 

protected 

internal 

private 

It is a compile-time error for fhe same modifier fo appear mulfiple times in a delegate 
declaration. 

The new modifier is permiffed only on delegafes declared wifhin anofher type, in which 
case it specifies fhaf such a delegafe hides an inherifed member by fhe same name, as 
described in §10.3.4. 

The public, protected, internal, and private modifiers confrol fhe accessibilify of fhe 
delegafe type. Depending on the context in which the delegate declaration occurs, some of 
fhese modifiers may nof be permiffed (§3.5.1). 

The delegafe's type name is identifier. 

The optional formal-parameter-list specifies fhe paramefers of fhe delegafe, and fhe return- 
type indicafes fhe refum fype of fhe delegafe. 


672 


www.it-ebooks.info 






15.1 Delegate Declarations 


The optional variant-type-parameter-Ust (§13.1.3) specifies the type parameters to the dele¬ 
gate itself. 

The return type of a delegate type must be either void or output-safe (§13.1.3.1). 

All of the formal parameter types of a delegate type must be input-safe. Additionally, any 
out or ref parameter types must be output-safe. Note that even out parameters are required 
to be input-safe, due to a limitation of the imderlying execution platform. 


“■ ERIC LI PPERT The limitation mentioned here is that out parameters are actually 
implemented as ref parameters behind the scenes: You can both read and write out 
parameters. The rule enforced by the compiler is that an out parameter must be writ¬ 
ten to before it is read from, but that is a rule of the C# language, not of the runtime. If 
out parameters were truly "write-only" and this restriction was enforced by the run¬ 
time, then they could, in theory, be made covariant. Keep that point in mind the next 
time you design a new t5q3e system. 


Delegate types in C# are name equivalent, not structurally equivalent. Specifically, two dif¬ 
ferent delegate types that have the same parameter lists and return type are considered 
different delegate types. However, instances of two distinct but structurally equivalent 
delegate types may compare as equal (§7.9.8). 

For example: 

delegate int Dl(int i, double d); 

class A 
{ 

public static int Ml(int a, double b) {...} 

} 

class B 
{ 

delegate int D2(int c, double d); 
public static int Ml(int f, double g) {...} 
public static void M2(int k, double 1) {...} 
public static int M3(int g) {...} 


public static void M4(int g) {...} 


The delegate types D1 and D2 are both compatible with the methods A. Ml and B. Ml, since 
they have the same return type and parameter list; however, these delegate t 5 q)es are two 
different types, so they are not interchangeable. The delegate types D1 and D2 are 


673 


www.it-ebooks.info 


15. Delegates 






15. Delegates 


15. Delegates 


incompatible with the methods B. M2, B. M3, and B. M4, since they have different return types 
or parameter lists. 


"■ ERIC LIPPERT When you're designing a new type system, you don't know 
exactly how it will be used in the future. One might imagine future scenarios involv¬ 
ing different categories of delegafes (such as "delegafe fo mefhod wifh observable side 
effecfs" or "delegafe fo mefhod fhaf can be called concurrenfly"). If would fhen make 
sense fo disallow assignmenfs befween fhese cafegories. In practice, as if fumed ouf, 
sfrucfural fyping on delegafes is very useful; fhere is really no semantic difference 
befween Predicate<int> and Func<int , bool> fhaf needs fo be enforced by fhe run- 
fime. If we were fo do if all over again, delegafe fypes would be more sfrucfurally 
compatible fhan fhey are foday. 


Like ofher generic type declarations, t 5 ^e arguments must be given to create a constructed 
delegate type. The parameter types and return t 5 ^e of a consfrucfed delegafe f 5 ^e are cre- 
afed by subsfifufing, for each f 5 ^e paramefer in fhe delegafe declaration, fhe correspond¬ 
ing f 5 ^e argumenf of fhe consfrucfed delegafe type. The resulting return type and parameter 
types are used in determining which methods are compatible with a constructed delegate 
type. For example: 

delegate bool Predicate<T>(T value); 

class X 
{ 

static bool F(int i) {...} 
static bool G(string s) {...} 

} 

The delegate type Predicate<int> is compatible with the method X. F and the delegate 
t 5 ^e Predicate<string> is compatible with the method X.G. 

The only way to declare a delegate t 5 ^e is via a delegate-declaration. A delegate type is a 
class t 5 ^e that is derived from System. Delegate. Delegafe f 5 ^es are implicifly sealed, so if 
is nof permissible fo derive any f 5 ^e from a delegafe type. It is also not permissible to 
derive a non-delegate class type from System.Delegate. Nofe fhaf System.Delegate is nof 
ifself a delegafe f 5 ^e; if is a class fype from which all delegafe fypes are derived. 

C# provides special S 5 mfax for delegafe insfanfiafion and invocation. Excepf for insfanfia- 
fion, any operafion fhaf can be applied fo a class or class insfance can also be applied fo a 
delegafe class or insfance, respecfively. In particular, if is possible fo access members of fhe 
System. Delegate f 5 ^e via fhe usual member access synfax. 


674 


www.it-ebooks.info 






15.1 Delegate Declarations 


The set of methods encapsulated by a delegate instance is called an invocation list. When 
a delegate instance is created (§15.2) from a single method, it encapsulates that method, 
and its invocation list contains only one entry. However, when two non-null delegate 
instances are combined, their invocation lists are concatenated—in the order left operand 
then right operand—to form a new invocation list, which contains two or more entries. 


■■ JON SKEET This single-cast/multicast duality is terribly awkward in some 
ways—and wonderfully useful in others. For example, it makes sense to talk about 
"the target" of a single-cast delegate, whereas each entry in the invocation list for a 
multicast delegate may have a separate target. This rarely presents a practical prob¬ 
lem, but can make hard to describe delegates both simply and accurately. 


Delegates are combined using the binary + (§7.8.4) and += operators (§7.17.2). A delegate 
can be removed from a combination of delegates by using the binary - (§7.8.5) and 
-= operators (§7.17.2). Delegates can also be compared for equality (§7.10.8). 

The following example shows the instantiation of a number of delegates, and their corre¬ 
sponding invocation lists: 

delegate void D(int x); 

class C 
{ 

public static void Ml(int i) {...} 
public static void M2(int i) {...} 

} 

class Test 
{ 

static void Main() 

{ 


D 

cdl = 

new 

D(C.Ml); 

// 

Ml 




D 

Cd2 = 

new 

D(C.M2); 

// 

M2 




D 

cd3 = 

cdl 

+ cd2; 

// 

Ml 

+ 

M2 


D 

cd4 = 

cd3 

+ cdl; 

// 

Ml 

+ 

M2 + 

Ml 

D 

cd5 = 

cd4 

+ cd3; 

// 

Ml 

+ 

M2 + 

Ml + Ml + M2 


} 

} 

When cdl and cd2 are instantiated, they each encapsulate one method. When cd3 is 
instantiated, it has an invocation list of two methods. Ml and M2, in that order. cd4's invo¬ 
cation list contains Ml, M2, and Ml, in that order. Finally, cdS's invocation list contains Ml, 
M2, Ml, Ml, and M2, in that order. For more examples of combining (as well as removing) 
delegates, see §15.4. 


675 


www.it-ebooks.info 


15. Delegates 






15. Delegates 


15. Delegates 


15.2 Delegate Compatibility 


A method or delegate M is compatible with a delegate type D if all of fhe following 

are frue: 

• D and M have fhe same number of paramefers, and each paramefer in D has fhe same ref 
or out modifiers as fhe corresponding paramefer in M. 

• For each value paramefer (a paramefer wifh no ref or out modifier), an identify conver¬ 
sion (§6.1.1) or implicif reference conversion (§6.1.6) exisfs from fhe paramefer type in D 
to the corresponding parameter type in M. 

• For each ref or out parameter, the parameter t 5 ^e in D is the same as the parameter 
type in M. 

• An identity or implicit reference conversion exisfs from fhe refum type of M fo fhe refum 
fype of D. 


15.3 Delegate Instantiation 


An insfance of a delegafe is creafed by a delegate-creation-expression (§7.6.10.5) or a conver¬ 
sion fo a delegafe type. The newly created delegate instance then refers fo eifher 

• The sfafic mefhod referenced in fhe delegate-creation-expression, or 

• The fargef objecf (which cannof be null) and insfance mefhod referenced in fhe delegate- 
creation-expression, or 

• Anofher delegafe. 

For example: 

delegate void D(int x); 

class C 
{ 

public static void Ml(int i) {...} 
public void M2(int i) {...} 


} 


class Test 


{ 

static void Main() 
{ 


D cdl = new D(C.Ml); 
C t = new C(); 

D cd2 = new D(t.M2); 


// Static method 


// Instance method 
// Another delegate 


D cd3 = new D(cd2); 

} 


} 


676 


www.it-ebooks.info 




15.4 Delegate Invocation 


Once instantiated, delegate instances always refer to the same target object and method. 
Remember, when two delegates are combined, or one is removed from another, a new 
delegate results with its own invocation list; the invocation lists of the delegates combined 
or removed remain unchanged. 

15.4 Delegate Invocation 

C# provides special syntax for invoking a delegate. When a non-null delegate instance 
whose invocation list contains one entry is invoked, it invokes the one method with the 
same arguments it was given, and returns the same value as the referred to method. (See 
§7.6.5.3 for detailed information on delegate invocation.) If an exception occurs during the 
invocation of such a delegate, and that exception is not caught within the method that was 
invoked, the search for an exception catch clause continues in the method that called the 
delegate, as if thaf method had directly called the method to which that delegate referred. 

Invocafion of a delegafe insfance whose invocafion lisf confains multiple entries proceeds 
by invoking each of fhe mefhods in fhe invocafion lisf, S 5 mchronously, in order. Each 
method so called is passed the same set of argumenfs as was given to the delegate instance. 
If such a delegafe invocafion includes reference parameters (§10.6.1.2), each method invo¬ 
cation will occur with a reference to the same variable; changes to that variable by one 
method in the invocation list will be visible to methods further down the invocation list. If 
fhe delegate invocation includes output parameters or a return value, their final value will 
come from the invocation of the last delegate in the list. 

If an excepfion occurs during processing of fhe invocation of such a delegate, and that 
exception is not caught within the method that was invoked, the search for an exception 
catch clause continues in the method that called the delegate, and any methods further 
down the invocation list are not invoked. 


"■ BILL WAG N E R This behavior is why, in the general case, you should strive to cre¬ 
ate methods that implement delegates that do not throw exceptions under any cir¬ 
cumstances. It introduces errors from which you likely carmot safely recover. This 
consideration is less important when you know your delegate will be used in a single¬ 
cast scenario only. 


“■ CHRISTIAN NAGEL There's a way to deal with exceptions that are thrown from 
handler methods that are referenced by the delegate. Instead of invoking the delegate 
instance directly, the GetInvocationList method of the delegate can be used to invoke 
each delegate of the invocation list separately. This invocation can be guarded from a 
try-catch block. In case of an exception, one way to deal with the failing handler 
mefhod is to remove it from fhe invocation list. 


677 


www.it-ebooks.info 


15. Delegates 








15. Delegates 


15. Delegates 


Attempting to invoke a delegate instance whose value is null results in an exception of 
type System.NullReferenceException. 


■■ JONSKEET In some ways, this outcome makes perfect sense; in other ways, it's 
inconsistent with a null reference's sfafus as fhe normal represenfafion of an empfy 
invocation list. This confusion could perhaps have been avoided by each delegafe f 5 ^e 
having a static Invoke mefhod—perhaps even an exfension mefhod—fhaf could have 
performed fhe appropriafe nullify check. This solufion would be more eleganf fhan 
fhe C# compiler aufomafically performing a null check on each invocation expression. 
Admittedly, fhings gef more complicafed when fhe delegafe type has a non-void 
return t 5 ^e or uses an out parameter. 

Whatever the best solution would have been, it's undeniably a pain in the neck to 
have to check for nullify ever 5 rwhere fhaf you wanf fo invoke a delegafe. 


■■ ERICLIPPERT A common paffern for "fhread-safe" delegafes is fo do somefhing 
like fhis: 

van temp = this.mydelegate; 
if (temp != null) temp(); 

insfead of fhe more obvious solufion: 

if (this.mydelegate != null) this.mydelegate(); 

The former is safer because if mydelegate can be changed on anofher fhread, fhen if 
mighf be changed fo null between fhe fesf and fhe invocation. Moreover, fhis approach 
eliminafes only one race. Suppose we are using fhe former code. The temporary caches 
the current value of mydelegate. On fhaf ofher fhread, mydelegate is sef fo null, and 
fhe global sfate fhaf fhe previous confenfs of mydelegate needs fo execufe successfully 
is desfroyed. Buf if is fhe previous confenfs fhaf are abouf fo be invoked! If your del¬ 
egates (particularly delegates associated with events) are susceptible to this problem, 
then some other mechanism must be implemented to ensure that nothing bad hap¬ 
pens if fhis race occurs. Probably fhe besf fhing fo do is fo wrife fhe code fo ensure fhaf 
if a "sfale" delegafe is invoked, nofhingbad happens. 


The following example shows how fo insfanfiafe, combine, remove, and invoke delegafes: 
using System; 
delegate void D(int x); 


678 


www.it-ebooks.info 








15.4 Delegate Invocation 


class C 

{ 

public static void Ml(int i) 

{ 

Console.WriteLineC'C.Ml: " + i); 

} 

public static void M2(int i) 

{ 

Console.WriteLineC'C.M2: " + i); 

} 

public void M3(int i) 

{ 

Console.WriteLineC'C.M3: " + i); 

} 


class Test 

{ 

static void Main() 

{ 

D cdl = new D(C.Ml)j 

cdl(-l); // Call Ml 

D cd2 = new D(C.M2); 

cd2(-2); // Call M2 


D cd3 = cdl + cd2; 

cd3(10); // Call Ml then M2 


cd3 += cdl; 

cd3(20); // Call Ml^ M2, then Ml 

C c = new C(); 

D cd4 = new D(c.M3); 
cd3 += cd4; 

cd3(30); // Call Ml, M2, Ml, then M3 


cd3 cdl; // Remove last Ml 

cd3(40); // Call Ml, M2, then M3 


cd3 cd4; 

cd3(50); // Call Ml then M2 


cd3 cd2; 

cd3(60); // Call Ml 


cd3 cd2; // Impossible removal is benign 

cd3(60); // Call Ml 


cd3 


// 


} 


} 


cd3 


cdl; // Invocation list is empty so cd3 is null 

cd3(70); // System.NullReferenceException thrown 

cdl; // Impossible removal is benign 


679 


www.it-ebooks.info 


15. Delegates 




15. Delegates 


15. Delegates 


As shown in the statement cd3 += cdlj,a delegate can be present in an invocation list 
multiple times. In this case, it is simply invoked once per occurrence. In such an invocation 
list, when that delegate is removed, the last occurrence in the invocation list is the one actu¬ 
ally removed. 

Immediately prior to the execution of the final sfafemenf cd3 -= cdlj, fhe delegafe cd3 
refers fo an empfy invocation list. Attempting to remove a delegate from an empfy lisf (or 
fo remove a nonexisfenf delegafe from a non-empfy lisf) is nof an error. 

The oufpuf produced is 


C.Ml 

-1 

C.M2 

-2 

C.Ml 

10 

C.M2 

10 

C.Ml 

20 

C.M2 

20 

C.Ml 

20 

C.Ml 

30 

C.M2 

30 

C.Ml 

30 

C.M3 

30 

C.Ml 

40 

C.M2 

40 

C.M3 

40 

C.Ml 

50 

C.M2 

50 

C.Ml 

60 

C.Ml 

60 


680 


www.it-ebooks.info 





16. Exceptions 


Exceptions in C# provide a structured, uniform, and t 5 ^e-safe way of handling both 
system-level and application-level error conditions. The exception mechanism in C# is 
quite similar to that of C++, with a few importanf differences. 


" ERIC LIPPERT The guidance on system-level and application-level exceptions 
used to be that all application exceptions should be derived from Application- 
Exception. This turned out to be a bad idea, and we no longer recommend this 
approach: Whether an exception comes from an applicafion or the framework class 
library is almost always irrelevant. 


• In C#, all exceptions must be represented by an instance of a class type derived from 
System. Exception. In C++, any value of any type can be used to represent an 
exception. 


■■ ERIC LIPPERT In the first version of fhe CLR, it was possible to throw a non¬ 
exception and catch it in C# using the empty catch clause. This made for some confus¬ 
ing excepfion-handling code in C# programs thaf needed to catch non-exception 
exceptions. In newer versions of the CLR, a thrown object that is not an exception is 
automatically wrapped in an exception object that can be caught normally. 


• In C#, a finally block (§8.10) can be used to write termination code that executes in 
both normal execution and exceptional conditions. Such code is difficult to write in 
C++ without duplicating code. 


681 


www.it-ebooks.info 








16. Exceptions 


16. Exceptions 


“■ ERIC LI PPERT One occasionally hears the myth that "the finally block always 
executes." Of course, it doesn't. The finally block does not execute if (1) fhe 
try-protected region goes info an infinife loop, (2) fhe program is ferminafed before 
fhe finally block runs, via a "fail fasf" condition or an adminisfrafor killing fhe pro¬ 
cess, or (3) someone kicks fhe power cord ouf of fhe wall. Indeed, fhere are times when 
you do nof wanf finally blocks fo run. If fhe exception is indicafive of program sfafe 
being so messed up fhaf rurming finally blocks will make fhe sifuafion worse, fhen 
sometimes fhe righf fhing fo do is fo simply fail fasf and fake fhe process down before 
any more harm can be done. 


• In C#, sysfem-level exceptions such as overflow, divide-by-zero, and null dereferences 
have well-defined excepfion classes and are on a par wifh application-level error 
conditions. 


"■ BILL WAGNER This poinf highlighfs an imporfanf advanfage—namely, fhaf C# 
excepfions have a greaf deal in common wifh C++ excepfions. Thaf commonalify 
enables fhe C# communify fo leverage all fhe work done by fhe C++ communify (nofa- 
bly Dave Abrahams and Herb Suffer) fo define a sef of pracfices fhaf make code more 
robusf in fhe face of excepfions. 


“■ CHRIS SELLS The value of having a single unified way fo communicafe and 
handle errors is one of fhe big advanfages fhaf .NET provides, buf if's somefimes for- 
goffen. When I see a .NET design fhaf communicafes errors in some ofher way, I 
assume if's wrong unfil I can be shown ofherwise. I can fhink of only one such occa¬ 
sion—and fhaf was somefhing I designed myself, so I'm hardly an unbiased judge. 


"■ PETE R S ESTOFT One big excepfion (sorry) fo Chris's rule is numeric code, where 
NaNs are used fo reporf and propagafe errors, and fo encode informafion abouf fhe 
error in the NaN payload bits (see the annotation in §7.8.1). Throwing an exception 
may be three to four orders of magnifude slower fhan propagating a NaN. The speed 
is, of course, immaferial if fhe program musf ferminafe wifh an error reporf even when 
jusf one excepfion is fhrown. In some confexfs, however, a numeric "error" may sim¬ 
ply represenf fhe absence of an inpuf, so millions or billions of "errors" may happen 
during a compufafion; in fhaf case, fhe cosf maffers. 


682 


www.it-ebooks.info 












16.2 The System.Exception Class 


16.1 Causes of Exceptions 

Exceptions can be thrown in two different ways. 

• A throw statement (§8.9.5) throws an exception immediately and imconditionally. Con¬ 
trol never reaches the statement immediately following the throw. 

• Certain exceptional conditions that arise during the processing of C# statements and 
expression cause an exception in certain circumstances when the operation cannot be 
completed normally. For example, an integer division operation (§7.8.2) throws a 
System. DivideByZeroException if the denominator is zero. See §16.4 for a list of the 
various exceptions that can occur in this way. 


“■ CH RISTIAN NAGEL When throwing exceptions, you should not throw an excep¬ 
tion of t 5 ^e Exception, but rather throw an exception of a t 5 ^e that derives from the 
Exception class. 


16.2 The System.Exception Class 

The System. Exception class is the base t 5 ^e of all exceptions. This class has a few notable 

properties that all exceptions share: 

• Message is a read-only property of type string that contains a human-readable descrip¬ 
tion of the reason for the exception. 

• InnerException is a read-only property of type Exception. If its value is non-null, it 
refers to the exception that caused the current exception—that is, the current exception 
was raised in a catch block handling the InnerException. Otherwise, its value is null, 
indicating that this exception was not caused by another exception. The number of 
exception objects chained together in this marmer can be arbitrary. 

The value of these properties can be specified in calls to the instance constructor for 

System.Exception. 


"■ ERIC LIPPERT From this description, it sounds like exceptions are immutable 
objects, which they are not. Every time you throw a particular instance of an exception 
object, the call stack captured by that exception is reset. For example, if you create one 
exception instance and then throw it from multiple threads, the call stack of the excep¬ 
tion will be observed to change on all threads that handle it, which is likely to be 
confusing. Create a new exception every time you need one. 


683 


www.it-ebooks.info 


16. Exceptions 








16. Exceptions 


16. Exceptions 


16.3 How Exceptions Are Handled 

Exceptions are handled by a try statement (§8.10). 

When an exception occurs, the system searches for the nearest catch clause that can handle 
the exception, as determined by the runtime type of fhe excepfion. Firsf, fhe current method 
is searched for a lexically enclosing try sfafement, and the associated catch clauses of the 
try statement are considered in order. If fhat fails, fhe method that called the current 
method is searched for a lexically enclosing try statement that encloses the point of fhe call 
fo the current method. This search continues until a catch clause is found fhat can handle 
the current exception, by naming an exception class that is of fhe same class, or a base class, 
of the runtime type of the exception being thrown. A catch clause that doesn't name an 
exception class can handle any exception. 

Once a matching catch clause is foimd, the system prepares to transfer confrol to the first 
statement of the catch clause. Before execution of the catch clause begins, the system first 
executes, in order, any finally clauses that were associated with try statements more 
nested than the one that caught the exception. 

If no matching catch clause is found, one of two things occurs: 

• If fhe search for a mafching catch clause reaches a stafic constructor (§10.12) or static 
field initializer, then a System. TypelnitializationException is thrown at the point that 
triggered the invocation of fhe sfatic consfructor. The inner excepfion of fhe System. 
TypelnitializationException contains the exception that was originally thrown. 

• If fhe search for mafching catch clauses reaches the code that initially started the 
thread, then execution of the thread is terminated. The impact of such termination is 
implementation-defined. 


■■ ERICLIPPERT In earlier versions of fhe CLR, fhe implementation-defined behav¬ 
ior was fo take down the application if fhe unhandled exception occurred on the main 
thread. If if appeared on a worker fhread, then the policy was to kill the worker thread 
but keep rurming the main thread. This turned out to be a bad policy, because applica¬ 
tions with buggy code on the worker thread would gradually lose all of their worker 
threads and be left with a running application that was doing no work, to the confu¬ 
sion of its users. The new policy is more aggressive: An unhandled exception on any 
thread takes down the application. Failing catestrophically is often a better policy than 
continuing on as if nothing had happened; if you fail noisily enough times, fhen even- 
fually someone figures ouf fhere is a problem and fixes if. 


684 


www.it-ebooks.info 






16.4 Common Exception Classes 


Exceptions that occur during destructor execution are worth special mention. If an excep¬ 
tion occurs during destructor execution and that exception is not caught, then the execu¬ 
tion of fhaf desfrucfor is ferminafed and fhe desfrucfor of fhe base class (if any) is called. If 
fhere is no base class (as in fhe case of fhe object fype) or if fhere is no base class desfrucfor, 
fhen fhe exception is discarded. 


“■ CH RISTIAN NAG EL The C# compiler creafes a finalizer from a desfrucfor. Wifhin 
fhe finalizer, a try-f inally block is added where fhe finalizer from fhe base class is 
called in fhe finally block. 


16.4 Common Exception Classes 

The following excepfions are fhrown by cerfain C# operafions. 


Exception 

Description 

System.ArithmeticException 

A base class for exceptions that occur during 
arithmetic operations, such as System. 
DivideByZeroException and System. 
OverflowException. 

System.ArrayTypeMismatchException 

Thrown when a store into an array fails 
because the actual type of the stored element is 
incompatible with the actual type of the array. 

System.DivideByZeroException 

Thrown when an attempt to divide an integral 
value by zero occurs. 

System.IndexOutOfRangeException 

Thrown when an attempt to index an array via 
an index that is less than zero or outside the 
bounds of the array occurs. 

System.InvalidCastException 

Thrown when an explicit conversion from a 
base type or interface to a derived type fails at 
runtime. 

System.NullReferenceException 

Thrown when a null reference is used in a way 
that causes the referenced object to be required. 

System.OutOfMemoryException 

Thrown when an attempt to allocate memory 
(via new) fails. 


Continued 


685 


www.it-ebooks.info 


16. Exceptions 















16. Exceptions 


16. Exceptions 


Exception 

Description 

System.OvertlowException 

Thrown when an arithmetic operation in a 
checked context overflows. 

System.StackOverflowException 

Thrown when the execution stack is exhausted 
by having too many pending method calls; 
typically indicative of very deep or 
unbounded recursion. 

System.TypelnitializationException 

Thrown when a static constructor throws an 
exception, and no catch clauses exists to 
catch it. 


■■ JONSKEET This table does not list the most commonly encountered exceptions, 
but rather the exceptions that can occur naturally within the execution environment 
as the result of C# operations. You should very rarely (if ever) explicifly fhrow fhese 
exceptions yourself. By confrasf, fhe more commonly encounfered exceptions such as 
System. Argument Except ion and ifs subclasses aren'f lisfed here—fhey're fhrown by a 
higher level of code, whefher sysfem libraries or applicafion code. 


"■ ERIC LIPPERT 1 cafegorize exceptions as fatal, boneheaded, vexing, and exogenous. 

Fatal excepfions you neifher fhrow nor cafch; fhey include ouf of memory, fhread 
aborf, and so on. You did nof cause fhe problem and you carmof fix if; fhe exception is 
jusf fhe mechanism by which you are nofified fhaf fhe world is abouf fo end. 

Boneheaded excepfions are avoidable and, fherefore, are fhrown only by buggy pro¬ 
grams; fhey include null dereferenced, invalid argumenf, and so on. Never cafch fhem; 
cafching a boneheaded exception is hiding someone's bug. Insfead, fix fhe bug. 

Vexing excepfions are excepfions fhaf you have fo handle because fhe API is designed 
fo communicafe facfs via excepfions. For example, previous versions of fhe frame¬ 
work lacked an "Is fhis sfring a legal GUID?" mefhod; fo answer fhaf quesfion, you 
mighf fry fo call fhe GUID consfrucfor and cafch fhe vexing excepfion fo see if if suc¬ 
ceeded or failed. Try fo nof wrife code fhaf fhrows vexing excepfions. 

Exogenous excepfions are fhose you musf cafch because fhey indicafe unexpecfed facfs 
abouf fhe real world: fhe GD has been removed from fhe drive, fhe nefwork roufer has 
been unplugged, and so on. 


686 


www.it-ebooks.info 













17. Attributes 


Much of the C# language enables the programmer to specify declarative information about 
the entities defined in the program. For example, the accessibility of a method in a class is 
specified by decorating it with the method-modifiers public, protected, internal, and 
private. 

C# enables programmers to invent new kinds of declarative information, called attributes. 
Programmers can then attach attributes to various program entities, and retrieve attribute 
information in a runtime environment. For instance, a framework might define a 
HelpAttribute attribute that can be placed on certain program elements (such as classes and 
methods) to provide a mapping from those program elements to their documentation. 


■■ JESSE LIBERTY A common and powerful use of attributes can be seen through¬ 
out Silverlight and WPF, where attributes are used to indicate the available view states 
associated with a class. 

Similarly, Test Libraries use attributes to differentiate test methods from supporting 
methods. Web services use attributes to designate which methods are exposed to 
clients. 


Attributes are defined through the declaration of attribute classes (§17.1), which may have 
positional and named parameters (§17.1.2). Attributes are attached to entities in a C# pro¬ 
gram using attribute specifications (§17.2), and can be retrieved at runtime as attribute 
instances (§17.3). 


“■ ERIC LIPPERT Try to use attributes only to talk about the type itself rather than 
representing details about the semantics of that t 5 ^e. For example, suppose you have 
a class Book with a property Author. That is part of the semantics of the class: The 
class represents books, and books have authors. If you put an AuthorAttribute on 
the class Book, that doesn't represent the author of the book, but rather the author of 
the class. A class Television might have a property Obsolete that indicates whether 
a particular model is out of production. If you put an ObsoleteAttribute on the 
class, it means that the class itself is obsolete, not that it represents an obsolete product. 


687 


www.it-ebooks.info 








17. Attributes 


17. Attributes 


17.1 Attribute Classes 

A class that derives from the abstract class System. Attribute, whether directly or indi¬ 
rectly, is an attribute class. The declaration of an affribufe class defines a new kind of 
attribute fhaf can be placed on a declarafion. By convenfion, affribufe classes are named 
wifh a suffix of Attribute. Uses of an affribufe may eifher include or omif fhis suffix. 

17.1.1 Attribute Usage 

The attribute AttributeUsage (§17.4.1) is used to describe how an attribute class can 
be used. 

AttributeUsage has a positional parameter (§17.1.2) that enables an attribute class to 
specify the kinds of declarations on which it can be used. The example 

using System; 

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface)] 
public class SimpleAttribute: Attribute 
{ 

} 

defines an attribute class named SimpleAttribute that can be placed on class-declarations 
and interface-declarations only. The example 

[Simple] class Classl {...} 

[Simple] interface Interfacel {...} 

shows several uses of the Simple attribute. Although this attribute is defined with the 
name SimpleAttribute, when this attribute is used, the Attribute suffix may be omitted, 
resulting in the short name Simple. Thus the example above is semantically equivalent to 
the following: 

[SimpleAttribute] class Classl {...} 

[SimpleAttribute] interface Interfacel {...} 

AttributeUsage has a named parameter (§17.1.2) called AllowMultiple, which indicates 
whether the attribute can be specified more than once for a given entity. If AllowMultiple 
for an attribute class is true, then that attribute class is a multi-use attribute class, and can 
be specified more than once on an entity. If AllowMultiple for an attribute class is false or 
it is unspecified, then that attribute class is a single-use attribute class, and can be specified 
at most once on an entity. 


688 


www.it-ebooks.info 




17.1 Attribute Classes 


The example 
using System; 

[AttributeUsage(AttributeTargets.ClasSj AllowMultiple = true)] 
public class AuthorAttribute: Attribute 
{ 

private string name; 

public AuthorAttribute(string name) { 
this.name = name; 

} 

public string Name { 

get { return name; } 

} 

} 

defines a multi-use attribute class named AuthorAttribute. The example 

[AuthorC'Brian Kernighan"), Author("Dennis Ritchie")] 
class Classl 
{ 

} 

shows a class declaration with two uses of the Author attribute. 


"■ CHRIS SELLS For those of you who are reading this example and don't know 
who Brian Kernighan or Dennis Ritchie is: For shame! They are true software 
legends. 


■■ JONSKEET While 1 agree with Chris, 1 certainly hope that neither of the esteemed 
gentlemen in question would ever write a class named Classl. 


AttributeUsage has another named parameter called Inherited, which indicates whether 
the attribute, when specified on a base class, is also inherited by classes that derive from 
that base class. If Inherited for an attribute class is true, then that attribute is inherited. If 
Inherited for an attribute class is false, then that attribute is not inherited. If it is imspeci- 
fied, its default value is true. 

An attribute class X not having an AttributeUsage attribute attached to it, as in 
using System; 
class X: Attribute {...} 


689 


www.it-ebooks.info 


17. Attributes 








17. Attributes 


17. Attributes 


is equivalent to the following: 

using System; 

[AttributeUsage( 

AttributeTargets.Allj 
AllowMultiple = falsBj 
Inherited = true) 

] 

class X: Attribute {...} 

17.1.2 Positional and Named Parameters 


“■ BILL WAGNER In most cases, using named parameters will result in a clearer, 
more easily understood program. Positional parameters should be used only for affri- 
bufes wifh one properfy, where fhe properfy is made clear by fhe affribufe name, such 
as AuthorAttribute. 


Affribufe classes can have positional parameters and named parameters. Each public 
insfance consfrucfor for an affribufe class defines a valid sequence of posifional paramefers 
for fhaf affribufe class. Each nonsfafic public read-wrife field and properfy for an affribufe 
class defines a named paramefer for fhe affribufe class. 

The example 
using System; 

[AttributeUsage(AttributeTargets.Class)] 
public class HelpAttribute: Attribute 
{ 

public HelpAttribute(strlng url) { // Positional parameter 

} 

public string Topic { // Named parameter 

get {...} 
set {...} 

} 

public string Url { 
get {...} 

} 

} 

defines an affribufe class named HelpAttribute fhaf has one posifional paramefer, url, 
and one named paramefer. Topic. Alfhough if is nonsfafic and public, fhe properfy Url 
does nof define a named paramefer, since if is nof read-wrife. 


690 


www.it-ebooks.info 






17.1 Attribute Classes 


This attribute class might be used as follows: 

[Help("http://www.mycompany.com/.../Classl.htm")] 
class Classl 
{ 

} 

[Help("http: //WWW. mycompany.com/.../Misc.htm". Topic = "Class2")] 
class Class2 
{ 

} 

17.1.3 Attribute Parameter Types 

The types of positional and named parameters for an attribute class are limited to the 
attribute parameter types: 

• One of the following types: bool, byte, char, double, float, int, long, sbyte, short, 
string, uint, ulong, ushort. 

• The t 5 ^e object. 

• The t 5 rpe System .Type. 

• An enum t 5 ^e, provided it has public accessibility and the types in which it is nested (if 
any) also have public accessibility (§17.2). 

• Single-dimensional arrays of the above types. 


■■ JONSKEET Note that decimal cannot be used as a parameter t 5 ^e, even though 
you can declare decimal constants. This is one example of CLl rules leaking into C#. 


"■ MAREK SAFAR Although arrays are supported, array covariance is not allowed 
for attributes of reference types. Similarly, the C# 4.0 dynamic t 5 ^e cannot be used 
where type object is expected. 


A constructor argument or public field that does not have one of these t 5 ^es cannot be 
used as a positional or named parameter in an attribute specification. 


691 


www.it-ebooks.info 


17. Attributes 








17. Attributes 


17. Attributes 


17.2 Attribute Specification 

Attribute specification is the application of a previously defined affribufe fo a declarafion. 
An affribufe is a piece of additional declarative information fhaf is specified for a declara¬ 
fion. Affribufes can be specified af global scope (fo specify affribufes on fhe confaining 
assembly or module) and for type-declarations (§9.6), class-member-declarations (§10.1.5), 
interface-member-declarations (§13.2), struct-member-declarations (§11.2), enum-member- 
declarations (§14.3), accessor-declarations (§10.7.2), event-accessor-declarations (§10.8.1), and 
formal-parameter-lists (§10.6.1). 

Affribufes are specified in attribute sections. An affribufe secfion consisfs of a pair of 
square brackefs, which surround a comma-separafed lisf of one or more affribufes. The 
order in which affribufes are specified in such a lisf, and fhe order in which secfions 
attached fo fhe same program enfify are arranged, is nof significanf. For insfance, fhe affri¬ 
bufe specifications [A][B], [B][A], [A, B],and [Bj A] are all equivalenf. 

global-attributes: 

global-attribute-sections 

global-attribute-sections: 

global-attribute-section 

global-attribute-sections global-attribute-section 
global-attribute-section: 

[ global-attribute-target-specifier attribute-list ] 

[ global-attribute-target-specifier attribute-list , ] 

global-attribute-target-specifier: 
global-attribute-target : 

global-attribute-target: 

assembly 

module 

attributes: 

attribute-sections 

attribute-sections: 

attribute-section 

attribute-sections attribute-section 
attribute-section: 

[ attribute-target-specifierattribute-list ] 

[ attribute-target-specifierattribute-list , ] 


692 


www.it-ebooks.info 




17.2 Attribute Specification 


attribute-target-specifier: 
attribute-target : 

attribute-target: 

field 

event 

method 

param 

property 

return 

type 

attribute-list: 

attribute 

attribute-list , attribute 
attribute: 

attribute-name attribute-arguments 

attribute-name: 

type-name 

attribute-arguments: 

( positional-argument-list) 

( positional-argument-list , named-argument-list ) 
( named-argument-list ) 

positional-argument-list: 

positional-argument 

positional-argument-list , positional-argument 
positional-argument: 

argument-nameattribute-argument-expression 

named-argument-list: 

named-argument 

named-argument-list , named-argument 
named-argument: 

identifier - attribute-argument-expression 

attribute-argument-expression: 

expression 


693 


www.it-ebooks.info 


17. Attributes 




17. Attributes 


17. Attributes 


An attribute consists of an attribute-name and an optional list of positional and named argu- 
menfs. The positional argumenfs (if any) precede fhe named argumenfs. A positional 
argument consists of an attribute-argument-expression; a named argumenf consisfs of a 
name, followed by an equal sign, followed by an attribute-argument-expression, which 
fogefher are consfrained by fhe same rules as simple assignmenf. The order of named argu¬ 
menfs is nof significanf. 

The attribute-name idenfifies an affribufe class. If fhe form of attribute-name is type-name, 
fhen fhis name musf refer fo an affribufe class. Ofherwise, a compile-fime error occurs. The 
example 

class Classl {} 

[Classl] class Class2 {} // Error 

resulfs in a compile-fime error because if affempfs fo use Classl as an affribufe class when 
Classl is nof an affribufe class. 

Cerfain confexfs permif fhe specificafion of an affribufe on more fhan one fargef. A pro¬ 
gram can explicifly specify fhe fargef by including an attribute-target-specifier. When an 
affribufe is placed af fhe global level, a global-attribute-target-specifier is required. In all ofher 
locations, a reasonable defaulf is applied, buf an attribute-target-specifier can be used fo 
affirm or override fhe defaulf in cerfain ambiguous cases (or fo jusf affirm fhe defaulf in 
non-ambiguous cases). Thus, f 5 q)ically, attribute-target-specifiers can be omitted excepf af fhe 
global level. The pofenfially ambiguous confexfs are resolved as follows: 

• An affribufe specified af fhe global scope can apply eifher fo fhe fargef assembly or fhe 
fargef module. No defaulf exisfs for fhis confexf, so an attribute-target-specifier is always 
required in this context. The presence of fhe assembly attribute-target-specifier indicafes 
fhaf fhe affribufe applies fo fhe fargef assembly; fhe presence of fhe module attribute- 
target-specifier indicafes fhaf fhe affribufe applies fo fhe fargef module. 

• An affribufe specified on a delegafe declarafion can apply eifher fo fhe delegafe being 
declared or fo ifs refurn value. In fhe absence of an attribute-target-specifier, fhe affribufe 
applies fo fhe delegafe. The presence of fhe type attribute-target-specifier indicafes fhaf fhe 
affribufe applies fo fhe delegafe; fhe presence of fhe return attribute-target-specifier indi¬ 
cafes fhaf fhe affribufe applies fo fhe refurn value. 

• An affribufe specified on a mefhod declarafion can apply eifher fo fhe mefhod being 
declared or fo ifs refurn value. In fhe absence of an attribute-target-specifier, fhe affribufe 
applies fo fhe mefhod. The presence of fhe method attribute-target-specifier indicafes fhaf 
fhe affribufe applies fo fhe mefhod; fhe presence of fhe return attribute-target-specifier 
indicafes fhaf fhe affribufe applies fo fhe refurn value. 


www.it-ebooks.info 




17.2 Attribute Specification 


• An attribute specified on an operator declaration can apply either to the operator being 
declared or to its return value. In the absence of an attribute-target-specifier, the attribute 
applies to the operator. The presence of the method attribute-target-specifier indicates that 
the attribute applies to the operator; the presence of the return attribute-target-specifier 
indicates that the attribute applies to the return value. 

• An attribute specified on an event declaration that omits event accessors can apply to 
the event being declared, to the associated field (if the event is not abstract), or to the 
associated add and remove methods. In the absence of an attribute-target-specifier, the 
attribute applies to the event. The presence of the event attribute-target-specifier indicates 
that the attribute applies to the event; the presence of the field attribute-target-specifier 
indicates that the attribute applies to the field; and the presence of the method attribute- 
target-specifier indicates that the attribute applies to the methods. 

• An attribute specified on a get accessor declaration for a property or indexer declara¬ 
tion can apply either to the associated method or to its return value. In the absence of 
an attribute-target-specifier, the attribute applies to the method. The presence of the 
method attribute-target-specifier indicates that the attribute applies to the method; 
the presence of the return attribute-target-specifier indicates that the attribute applies 
to the return value. 

• An attribute specified on a set accessor for a property or indexer declaration can apply 
either to the associated method or to its lone implicit parameter. In the absence of 
an attribute-target-specifier, the attribute applies to the method. The presence of the method 
attribute-target-specifier indicates that the attribute applies to the method; the presence of 
the param attribute-target-specifier indicates that the attribute applies to the parameter; 
and the presence of the return attribute-target-specifier indicates that the attribute applies 
to the return value. 

• An attribute specified on an add or remove accessor declaration for an event declaration 
can apply either to the associated method or to its lone parameter. In the absence of 
an attribute-target-specifier, the attribute applies to the method. The presence of the method 
attribute-target-specifier indicates that the attribute applies to the method; the presence of 
the param attribute-target-specifier indicates that the attribute applies to the parameter; 
and the presence of the return attribute-target-specifier indicates that the attribute applies 
to the return value. 

In other contexts, inclusion of an attribute-target-specifier is permitted but urmecessary. For 

instance, a class declaration may either include or omit the specifier type: 

[type: Author("Brian Kernighan")] 
class Classl {} 

[AuthorC'Dennis Ritchie")] 
class Class2 {} 


695 


www.it-ebooks.info 


17. Attributes 




17. Attributes 


17. Attributes 


It is an error to specify an invalid attribute-target-specifier. For instance, the specifier pa ram 
cannot be used on a class declaration: 

[param: Author("Brian Kernighan")] // Error 

class Classl {} 

By convention, attribute classes are named with a suffix of Attribute. An attribute-name of 
fhe form type-name may either include or omit this suffix. If an attribute class is found both 
with and without this suffix, an ambiguity is present, and a compile-time error results. If 
the attribute-name is spelled such that its rightmost identifier is a verbatim identifier (§2.4.2), 
fhen only an attribute without a suffix is matched, thus enabling such an ambiguity to be 
resolved. The example 


using System; 

[AttributeUsage(AttributeTargets.All)] 
public class X: Attribute 
{} 


[AttributeUsage(AttributeTargets.All)] 
public class XAttribute: Attribute 
{} 

[X] // Error: ambiguity 

class Classl {} 

[XAttribute] // Refers to XAttribute 

class Class2 {} 


[@X] // Refers to X 

class ClassB {} 

[@XAttribute] // Refers to XAttribute 

class Class4 {} 


shows two attribute classes named X and XAttribute. The attribute [X] is ambiguous, since 
it could refer fo either X or XAttribute. Using a verbatim identifier allows the exact intent 
to be specified in such rare cases. The atfribute [XAttribute] is nof ambiguous (although 
it would be if there was an attribute class named XAttributeAttribute!). If the declaration 
for class X is removed, fhen both attributes refer to the attribute class named XAttribute, 
as follows: 


using System; 

[AttributeUsage(AttributeTargets.All)] 
public class XAttribute: Attribute 
{} 

[X] // Refers to XAttribute 

class Classl {} 

[XAttribute] // Refers to XAttribute 

class Class2 {} 

[@X] // Error: no attribute named "X" 

class ClassB {} 


696 


www.it-ebooks.info 




17.2 Attribute Specification 


It is a compile-time error to use a single-use attribute class more than once on the same 
entity. The example 

using System; 

[AttributeUsage(AttributeTargets.Class)] 
public class HelpStringAttribute: Attribute 
{ 

string value; 

public HelpStringAttribute(string value) { 
this.value = value; 

} 

public string Value { 
get {...} 

} 

} 

[HelpString("Description of Classl")] 

[HelpString("Another description of Classl")] 
public class Classl {} 

results in a compile-time error because it attempts to use Helpstring, which is a single-use 
attribute class, more than once on the declaration of Classl. 

An expression E is an attribute-argument-expression if all of the following statements 
are true: 

• The t 5 ^e of E is an attribute parameter type (§17.1.3). 

• At compile time, the value of E can be resolved to one of the following: 

- A constant value. 

- A System.Type object. 

- A one-dimensional array of attribute-argument-expressions. 

For example: 

using System; 

[AttributeUsage(AttributeTargets.Class)] 
public class TestAttribute: Attribute 
{ 

public int PI { 
get {...} 
set {...} 

} 

public Type P2 { 
get {...} 
set {...} 

} 


697 


www.it-ebooks.info 


17. Attributes 




17. Attributes 


17. Attributes 


public object P3 { 
get {...} 
set {...} 

} 

} 

[Test(Pl = 1234j P3 = new int[] { 1 , 3 , 5}, P2 = typeof(float))] 
class MyClass {} 

A typeof-expression (§7.6.11) used as an attribute argument expression can reference a non¬ 
generic type, a closed constructed type, or an unboimd generic type, but it cannot reference 
an open fj^e. This is fo ensure fhaf fhe expression can be resolved af compile fime. 

class A: Attribute 
{ 

public A(Type t) {...} 

} 

class G<T> 

{ 

[A(typeof(T))] T t; 

} 

class X 
{ 

[A(typeof(List<int>))] int x; 

[A(typeof(List<>))] int y; 

} 


17.3 Attribute Instances 

An attribute instance is an insfance fhaf represenfs an affribufe af runfime. An affribufe is 
defined wifh an affribufe class, positional argumenfs, and named argumenfs. An affribufe 
insfance is an insfance of fhe affribufe class fhaf is initialized wifh fhe posifional and named 
argumenfs. 

Refrieval of an affribufe insfance involves bofh compile-fime and runfime processing, as 
described in fhe following sections. 

17.3.1 Compilation of an Attribute 

The compilation of an attribute wifh affribufe class T, positional-argument-list P, and named- 
argument-list N, consisfs of fhe following sfeps: 

• Follow fhe compile-fime processing sfeps for compiling an object-creation-expression of 
fhe form new T(P). These sfeps eifher resulf in a compile-fime error or defermine an 
insfance consfrucfor C on T fhaf can be invoked af runfime. 

• If C does nof have public accessibilify, fhen a compile-fime error occurs. 


698 


// Error: open type in attribute 


// Okay: closed constructed type 
// Okay: unbound generic type 


www.it-ebooks.info 




17.4 Reserved Attributes 


• For each named-argument Arg in N: 

- Let Name be the identifier of the named-argument Ang. 

Name must identify a nonstatic read-write public field or property on T. If T has no 
such field or property, then a compile-time error occurs. 

• Keep the following information for runtime instantiation of the attribute: the attribute 
class T, the instance constructor C on T, the positional-argument-list P, and the named- 
argument-list N. 


“■ MAREK SAFAR The public accessibility restriction is a little bit confusing in this 
case. For instance, class attributes are declared lexically outside the class but they can 
still use private constants declared within the same class. 


17.3.2 Runtime Retrieval of an Attribute Instance 

Compilation of an attribute yields an attribute class T, an instance constructor C on T, a 
positional-argument-list P, and a named-argument-list N. Given this information, an attribute 
instance can be retrieved at runtime using the following steps: 

• Follow the runtime processing steps for executing an object-creation-expression of the 
form new T(P), using the instance constructor C as determined at compile time. These 
steps either result in an exception, or produce an instance 0 of T. 

• For each named-argument Arg in N, in order: 

- Let Name be the identifier of the named-argument Arg. If Name does not identify a non¬ 
static public read-write field or property on 0, then an exception is thrown. 

- Let Value be the result of evaluating the attribute-argument-expression of Arg. 

- If Name identifies a field on 0, then set this field to Value. 

- Otherwise, Name identifies a property on 0. Set this property to Value. 

- The result is 0, an instance of the attribute class T that has been initialized with the 
positional-argument-list P and the named-argument-list N. 

17.4 Reserved Attributes 

A small number of attributes affect the language in some way. These attributes include: 

• System. AttributeUsageAttribute (§17.4.1), which is used to describe the ways in which 
an attribute class can be used. 


699 


www.it-ebooks.info 


17. Attributes 






17. Attributes 


17. Attributes 


• System. Diagnostics. ConditionalAttribute (§17.4.2), which is used to define condi¬ 
tional methods. 

• System.ObsoleteAttribute (§17.4.3), which is used to mark a member as obsolete. 

17.4.1 The AttributeUsage Attribute 

The attribute AttributeUsage is used to describe the manner in which the attribute class 
can be used. 

A class that is decorated with the AttributeUsage attribute must derive from System. 
Attribute, either directly or indirectly. Otherwise, a compile-time error occurs. 

namespace System 

{ 

[AttributeUsage(AttributeTargets.Class)] 
public class AttributeUsageAttribute: Attribute 
{ 

public AttributeUsageAttribute(AttributeTargets validOn) { 


} 

public virtual bool AllowMultiple { get {...} set {...} } 
public virtual bool Inherited { get {...} set {...} } 
public virtual AttributeTargets ValidOn { get {...} } 


public enum AttributeTargets 

{ 


Assembly 

Module 

Class 

Struct 

Enum 

Constructor 

Method 

Property 

Field 

Event 

Interface 

Parameter 

Delegate 

ReturnValue 


0X0001, 

0x0002, 

0x0004, 

0x0008, 

0X0010, 

0X0020, 

0x0040, 

0x0080, 

0x0100, 

0x0200, 

0x0400, 

0X0800, 

0x1000, 

0x2000, 


All = Assembly | Module | Class | Struct | Enum | 

Constructor | Method | Property | Field | Event | 
Interface | Parameter | Delegate | ReturnValue 

} 

} 


700 


www.it-ebooks.info 




17.4 Reserved Attributes 


17.4.2 The Conditional Attribute 

The attribute Conditional enables the definition of conditional methods and conditional 
attribute classes. 

namespace System.Diagnostics 
{ 

[AttributeUsage(AttributeTargets.Method | AttributeTargets.Class, 

AllowMultiple = true)] 

public class ConditionalAttribute: Attribute 
{ 

public ConditionalAttribute(string conditionstring) {...} 
public string Conditionstring { get {...} } 

} 

} 

17.4.2.1 Conditional Methods 

Amethod decorated with the Conditional attribute is a conditional method. The Conditional 
attribute indicates a condition by testing a conditional compilation symbol. Calls to a con¬ 
ditional method are either included or omitted depending on whether this symbol is defined 
at the point of the call. If the symbol is defined, the call is included; otherwise, the call 
(including evaluation of the receiver and parameters of the call) is omitted. 

A conditional method is subject to the following restrictions: 

• The conditional method must be a method in a class-declaration or struct-declaration. A 
compile-time error occurs if the Conditional attribute is specified on a method in an 
interface declaration. 

• The conditional method must have a return type of void. 

• The conditional method must not be marked with the override modifier. A conditional 
method maybe marked with the virtual modifier, however. Overrides of such a method 
are implicitly conditional, and must not be explicitly marked with a Conditional 
attribute. 

• The conditional method must not be an implementation of an interface method. Other¬ 
wise, a compile-time error occurs. 

In addition, a compile-time error occurs if a conditional method is used in a delegate- 
creation-expression. The example 

#define DEBUG 

using System; 

using System.Diagnostics; 

class Classl 


701 


www.it-ebooks.info 


17. Attributes 




17. Attributes 


17. Attributes 


{ 

[Conditional("DEBUG")] 
public static void M() { 

Console.WriteLine("Executed Classl.M"); 

} 

} 

class Class2 
{ 

public static void Test() { 

Classl.M(); 

} 

} 

declares Classl.M as a conditional method. Class2's Test method calls this method. Since 
the conditional compilation symbol DEBUG is defined, if Class2. Test is called, if will call M. 
If fhe symbol DEBUG had nof been defined, fhen Class2.Test would nof call Classl.M. 

If is imporfanf fo nofe fhaf fhe inclusion or exclusion of a call fo a condifional mefhod is 
confrolled by fhe condifional compilation symbols af fhe poinf of fhe call. In fhe example 

File classl.cs: 

using System.Diagnostics; 

class Classl 
{ 

[Conditional("DEBUG")] 
public static void F() { 

Console.WriteLine("Executed Classl.F"); 

} 

} 

File class2.cs: 

#define DEBUG 

class Classl 
{ 

public static void G() { 

Classl.F(); // F is called 

} 

} 

File classB.cs: 

#undef DEBUG 

class ClassB 
{ 

public static void H() { 

Classl.F(); // F is not called 

} 

} 


702 


www.it-ebooks.info 




17.4 Reserved Attributes 


the classes Class2 and ClassB each contain calls to the conditional method Classl. F, which 
is conditional based on whether DEBUG is defined. Since this symbol is defined in the con¬ 
text of Class2 but not ClassB, the call to F in Class2 is included, while the call to F in 
ClassB is omitted. 

The use of conditional methods in an inheritance chain can be confusing. Calls made to a 
conditional method through base, of the form base. M, are subject to the normal conditional 
method call rules. In the example 

File classl.cs: 

using System; 

using System.Diagnostics; 

class Classl 
{ 

[Conditional("DEBUG")] 
public virtual void M() { 

Console.WriteLine("Classl.M executed"); 

} 

} 

File class2.cs: 

using System; 

class Class2: Classl 
{ 

public override void M() { 

Console.WriteLine("Class2.M executed"); 
base.MO; // base.M is not called! 

} 

} 

File classB.cs: 

#deflne DEBUG 

using System; 

class ClassB 
{ 

public static void Test() { 

Class2 c = new Class2(); 

c.M(); // M is called 

} 

} 

Class2 includes a call to the M defined in its base class. This call is omitted because the base 
method is conditional based on the presence of the symbol DEBUG, which is undefined. 
Thus the method writes to the console "Class2.M executed" only. Judicious use of pp- 
declarations can eliminate such problems. 


703 


www.it-ebooks.info 


17. Attributes 




17. Attributes 


17. Attributes 


17.4.2.2 Conditional Attribute Classes 

An attribute class (§17.1) decorated with one or more Conditional attributes is a 
conditional attribute class. A conditional attribute class is thus associated with the con¬ 
ditional compilation symbols declared in its Conditional attributes. The example 

using System; 

using System.Diagnostics; 

[Conditional("ALPHA")] 

[Conditional("BETA")] 

public class TestAttribute : Attribute {} 

declares TestAttribute as a conditional attribute class associated with the conditional 
compilations symbols ALPHA and BETA. 

Attribute specifications (§17.2) of a conditional attribute are included if one or more of its 
associated conditional compilation symbols are defined at the point of specification; other¬ 
wise, the attribute specification is omitted. 

It is important to note that the inclusion or exclusion of an attribute specification of a con¬ 
ditional attribute class is controlled by the conditional compilation symbols at the point of 
fhe specification. In the example 

File test. cs: 

using System; 

using System.Diagnostics; 

[Conditional("DEBUG")] 

public class TestAttribute ; Attribute {} 

File classl.cs: 

#define DEBUG 

[Test] // TestAttribute is specified 

class Classl {} 

File class2.cs: 

#undef DEBUG 

[Test] // TestAttribute is not specified 

class Class2 {} 

the classes Classl and Class2 are each decorated with attribute Test, which is conditional 
based on whether DEBUG is defined. Since this symbol is defined in the context of Classl 
but not Class2, the specification of the Test attribute on Classl is included, while the 
specification of the Test attribute on Class2 is omitted. 


704 


www.it-ebooks.info 




17.4 Reserved Attributes 


“■ ERIC LI PPERT The conditional attribute clearly has a strong connection to condi¬ 
tional compilation symbols—^but it is important to remember that they are very differ¬ 
ent. A common error is to write something like this: 

#if DEBUG 
int counter; 

#endif 

[Conditional("DEBUG")] void DoIt(int x) { ... } 

DoIt(this.counter); 

The definition of the field counter is removed from the program entirely if the DEBUG 
symbol is not defined. How does the compiler know to remove the call to Dolt? 
Because Dolt (int ) is conditional and DEBUG is not defined. But how does the compiler 
know that Dolt (int ) is being called, as opposed to some other overload? Because this 
counter is declared as an int —oh, wait, that field definition has been removed. There is no 
such field, so compilation will fail in the non-debug build. 


17.4.3 The Obsolete Attribute 

The attribute Obsolete is used to mark t 5 ^es and members of types that should no longer 
be used. 

namespace System 

{ 

[AttributeUsage( 

AttributeTargets.Class | 

AttributeTargets.Struct | 

AttributeTargets.Enum | 

AttributeTargets.Interface | 

AttributeTargets.Delegate | 

AttributeTargets.Method | 

AttributeTargets.Constructor | 

AttributeTargets.Property | 

AttributeTargets.Field | 

AttributeTargets.Event, 

Inherited = false) 

1 

public class ObsoleteAttribute : Attribute 

{ 

public ObsoleteAttribute() {...} 

public ObsoleteAttribute(string message) {...} 

public ObsoleteAttribute(string message, bool error) {...} 

public string Message { get {...} } 

public bool IsError { get {...} } 

} 

} 


705 


www.it-ebooks.info 


17. Attributes 






17. Attributes 


17. Attributes 


If a program uses a 1)^6 or member that is decorated with the Obsolete attribute, the com¬ 
piler issues a warning or an error. Specifically, the compiler issues a warning if no error 
parameter is provided, or if the error parameter is provided and has the value false. The 
compiler issues an error if the error parameter is specified and has the value true. 

In the example 

[Obsolete("This class is obsolete; use class B instead")] 
class A 
{ 

public void F() { } 

} 

class B 
{ 

public void F() { } 

} 

class Test 
{ 

static void Main() 

{ 

A a = new A(); // Warning 

a.F(); 

} 

} 

the class A is decorated with the Obsolete attribute. Each use of A in Main results in a warn¬ 
ing that includes the specified message, "This class is obsolete; use class B instead." 


■■ JONSKEET There's an important lesson in this example: When you make some¬ 
thing obsolete, always give guidance as to the new, preferred way of achieving a simi¬ 
lar effect. Ideally, provide some indication (potentially in the documentation instead 
of the attribute message) of why the "old" code is being declared obsolete as well. It's 
extremely annoying when code that has worked for a long time suddenly starts spout¬ 
ing warnings with no good explanation. 


"■ MAREK SAFAR The compiler does not automatically obsolete overrides of vir¬ 
tual methods. Therefore, when a virtual method is marked as Obsolete, every method 
that overrides it has to be manually decorated with the Obsolete attribute as well. 


706 


www.it-ebooks.info 








17.5 Attributes for Interoperation 


17.5 Attributes for Interoperation 

Note: This section is applicable only to the Microsoft .NET implementation ofC#. 

17.5.1 Interoperation with COM and Win32 Components 

The .NET runtime provides a large number of attributes that enable C# programs to 
interoperate with components written using COM and Win32 DLLs. For example, the 
Dllimport attribute can be used on a static extern method to indicate that the imple¬ 
mentation of fhe mefhod is to be found in a Win32 DLL. These attributes are found in fhe 
System.Runtime.InteropServices namespace, and detailed documentation for fhese 
attribufes is found in the .NET runtime documentation. 

17.5.2 Interoperation with Other .NET Languages 

17.5.2.1 The IndexerName Attribute 

Indexers are implemented in .NET using indexed properties, and have a name in the .NET 
metadata. If no IndexerName attribute is present for an indexer, then the name Item is used 
by default. The IndexerName attribute enables a developer to override this default and 
specify a different name. 

namespace System.Runtime.CompilerServices.CSharp 
{ 

[AttributeUsage(AttributeTargets.Property)] 
public class IndexerNameAttribute : Attribute 
{ 

public IndexerNameAttribute(string indexerName) {...} 
public string Value { get {...} } 

} 

} 


707 


www.it-ebooks.info 


17. Attributes 




This page intentionally left blank 


www.it-ebooks.info 


18. Unsafe Code 


The core C# language, as defined in the preceding chapters, differs notably from C and 
C++ in its omission of pointers as a data type. Instead, C# provides references and the abil¬ 
ity to create objects that are managed by a garbage collector. This design, coupled with 
other features, makes C# a much safer language than C or C++. In the core C# language, it 
is simply not possible to have an uninitialized variable, a "dangling" pointer, or an expres¬ 
sion that indexes an array beyond its bounds. Whole categories of bugs that routinely 
plague C and C++ programs are thus eliminated. 

While practically every pointer type construct in C or C++ has a reference type counter¬ 
part in C#, there are still some situations in which access to pointer types becomes a 
necessity. For example, interfacing with the underlying operating system, accessing a 
memory-mapped device, or implementing a time-critical algorithm may not be possible 
or practical without access to pointers. To address this need, C# provides the ability to 
write unsafe code. 


■■ CHRIS SELLS In all the time since I've been programming .NET (starting before 
the RTM of 1.0), I've never once found a need to write unsafe code. Not once. 


In unsafe code, it is possible to declare and operate on pointers, to perform conversions 
between pointers and integral t 5 ^es, to take the address of variables, and so forth. In a 
sense, writing unsafe code is much like writing C code within a C# program. 

Unsafe code is, in fact, a "safe" feature from the perspective of both developers and users. 
Unsafe code must be clearly marked with the modifier unsafe, so developers carmot pos¬ 
sibly use unsafe features accidentally, and the execution engine works to ensure that unsafe 
code cannot be executed in an untrusted environment. 


709 


www.it-ebooks.info 






18. Unsafe Code 


18. Unsafe Code 


18.1 Unsafe Contexts 

The unsafe features of C# are available only in unsafe contexts. An unsafe context is intro¬ 
duced by including an unsafe modifier in the declaration of a type or member or by 
employing an unsafe-statement: 

• A declaration of a class, struct, interface, or delegate may include an unsafe modifier, in 
which case the entire textual extent of that type declaration (including the body of the 
class, struct, or interface) is considered an unsafe context. 

• A declaration of a field, method, property, event, indexer, operator, instance constructor, 
destructor, or static constructor may include an unsafe modifier, in which case the entire 
textual extent of that member declaration is considered an unsafe context. 

• An unsafe-statement enables the use of an unsafe context within a block. The entire textual 
extent of the associated block is considered an unsafe context. 

The associated grammar extensions are shown below. For brevity, ellipses (...) are used to 
represent productions that appear in preceding chapters. 

class-modifier: 

unsafe 

struct-modifier: 

unsafe 

interface-modifier: 

unsafe 

delegate-modifier: 

unsafe 

field-modifier: 

unsafe 

method-modifier: 

unsafe 

property-modifier: 

unsafe 


www.it-ebooks.info 




18.1 Unsafe Contexts 


event-modifier: 

unsafe 

indexer-modifier: 

unsafe 

operator-modifier: 

unsafe 

constructor-modifier: 

unsafe 

destructor-declaration: 

attributes extern^^^ unsafe^^^ ~ identifier ( ) destructor-body 

attributes^^^ unsafe^^^ extern^^j ~ identifier ( ) destructor-body 

static-constructor-modifiers: 

extern , unsafe , static 

Opt Opt 

unsafe , extern , static 

Opt opt 

extern , static unsafe , 

Opt opt 

unsafe , static extern . 

Opt opt 

static extern , unsafe . 

opt opt 

static unsafe , extern . 

opt opt 

embedded-statement: 

unsafe-statement 

unsafe-statement: 
unsafe block 

In the example 

public unsafe struct Node 

{ 

public int Value; 
public Node* Left; 
public Node* Right; 

} 


711 


www.it-ebooks.info 


18. Unsafe Code 




18. Unsafe Code 


18. Unsafe Code 


the unsafe modifier specified in fhe sfrucf declaration causes fhe entire fexfual exfenf of fhe 
sfrucf declaration to become an unsafe confexf. Thus if is possible fo declare fhe Left and 
Right fields fo be of a poinfer fype. The example above could also be written as follows: 

public struct Node 
{ 

public int Value; 
public unsafe Node* Left; 
public unsafe Node* Right; 

} 

Here, fhe unsafe modifiers in fhe field declarations cause fhose declarations fo be consid¬ 
ered unsafe confexfs. 

Ofher than establishing an unsafe confexf, fhereby permiffing fhe use of poinfer fypes, fhe 
unsafe modifier has no effecf on a fype or a member. In fhe example 

public class A 
{ 

public unsafe virtual void F() { 
char* p; 

} 

} 

public class B : A 
{ 

public override void F() { 
base.F(); 

} 

} 

fhe unsafe modifier on fhe F mefhod in A simply causes fhe fexfual exfenf of F fo become 
an unsafe confexf in which fhe unsafe feafures of fhe language can be used. In fhe override 
of F in B, fhere is no need fo re-specify fhe unsafe modifier—unless, of course, fhe F mefhod 
in B ifself needs access fo unsafe feafures. 

The sifuafion is slightly different when a pointer t 5 ^e is part of fhe mefhod's signafure: 

public unsafe class A 
{ 

public virtual void F(char* p) {...} 

} 

public class B : A 
{ 

public unsafe override void F(char* p) {...} 

} 

Here, because F's signafure includes a poinfer fype, if can be wriffen only in an unsafe 
confexf. However, fhe unsafe confexf can be infroduced eifher by making fhe enfire class 


712 


www.it-ebooks.info 




18.2 Pointer Types 


unsafe, as is the case in A, or by including an unsafe modifier in the method declaration, as 
is the case in B. 


18.2 Pointer Types 

In an unsafe context, a type (§4) may be a pointer-type as well as a value-type or a reference- 
type. However, a pointer-type may also be used in a typeof expression (§7.6.10.6) outside of 
an unsafe context, as such usage is not unsafe. 

type: 

pointer-type 

A pointer-type is written as an unmanaged-type or the ke 5 rword void, followed by a * token: 

pointer-type: 

unmanaged-type 

void 

unmanaged-type: 

type 

The type specified before the * in a pointer type is called the referent type of the pointer 
type. It represents the type of the variable to which a value of the pointer type points. 

Unlike references (values of reference t 5 ^es), pointers are not tracked by the garbage 
collector—the garbage collector has no knowledge of pointers and the data to which they 
point. For this reason a pointer is not permitted to point to a reference or to a struct that 
contains references, and the referent type of a pointer must be an unmanaged-type. 

An unmanaged-type is any t 5 ^e that isn't a reference-type or constructed t 5 ^e, and doesn't 
contain reference-type or constructed type fields at any level of nesting. In other words, an 
unmanaged-type is one of the following: 

• sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, 
or bool. 

• Any enum-type. 

• Any pointer-type. 

• Any user-defined struct-type that is not a constructed type and contains fields of 
unmanaged-types only. 


713 


www.it-ebooks.info 


18. Unsafe Code 




18. Unsafe Code 


18. Unsafe Code 


The intuitive rule for mixing of poinfers and references is fhaf referenfs of references 
(objecfs) are permiffed fo confain poinfers, buf referenfs of poinfers are nof permiffed fo 
confain references. 

Some examples of poinfer fypes are given in fhe fable below: 


Example 

Description 

byte* 

Pointer to byte 

char* 

Pointer to char 

int** 

Pointer to pointer to int 

int*[] 

Single-dimensional array of pointers to int 

void* 

Pointer to unknown type 


For a given implemenfafion, all poinfer f 5 ^es musf have fhe same size and represenfafion. 

Unlike C and C++, when multiple poinfers are declared in fhe same declaration, in C# fhe 
* is wriffen along wifh fhe underlying f 5 ^e only, nof as a prefix puncfuafor on each poinfer 
name. For example: 

int* pi, pj; // NOT as int *pi, *pj; 

The value of a poinfer having fype T* represenfs fhe address of a variable of type T. The 
pointer indirection operator * (§18.5.1) may be used to access this variable. For example, 
given a variable P of t 5 ^e int*, fhe expression *P denofes fhe int variable found af fhe 
address confained in P. 

Like an objecf reference, a poinfer may be null. Applying fhe indirection operator fo a null 
poinfer resulfs in implemenfafion-defined behavior. A poinfer wifh value null is repre¬ 
sented by all-bifs-zero. 

The void* fype represenfs a poinfer fo an unknown fype. Because fhe referenf f 5 ^e is 
unknown, fhe indirecfion operator cannof be applied fo a poinfer of type void*, nor can 
any arithmetic be performed on such a poinfer. However, a poinfer of type void* can be 
cast to any other pointer type (and vice versa). 


714 


www.it-ebooks.info 











18.2 Pointer Types 


Pointer types are a separate category of types. Unlike reference types and value types, 
pointer t 5 ^es do not inherit from object and no conversions exist between pointer types 
and object. In particular, boxing and unboxing (§4.3) are not supported for pointers. How¬ 
ever, conversions are permitted between different pointer t 5 ^es and between pointer types 
and the integral t 5 ^es. This is described in §18.4. 

A pointer-type cannot be used as a type argument (§4.4), and t 5 ^e inference (§7.5.2) fails on 
generic method calls that would have inferred a type argument to be a pointer t 5 ^e. 

A pointer-type may be used as the type of a volatile field (§10.5.3). 

Although pointers can be passed as ref or out parameters, doing so can cause undefined 
behavior, since the pointer may well be set to point to a local variable that no longer exists 
when the called method returns, or when the fixed object to which it used to point is no 
longer fixed. For example: 

using System; 

class Test 
{ 

static int value = 20; 

unsafe static void F(out int* pil, ref int* pi2) 

{ 

int i = 10; 
pil = &i; 

fixed (int* pj = Svalue) 

{ 

n ... 

Pi2 = pj; 

} 

} 

static void Main() 

{ 

int i = 10; 

unsafe 

{ 

int* pxl; 
int* px2 = &i; 

F(out pxl, ref px2); 

Console.WriteLine("*pxl = {0}, *px2 = {!}", *pxl, *px2); 

// Undefined behavior 

} 

} 

} 


715 


www.it-ebooks.info 


18. Unsafe Code 




18. Unsafe Code 


18. Unsafe Code 


A method can return a value of some type, and that t 5 ^e can be a pointer. For example, 
when given a pointer to a contiguous sequence of ints, fhaf sequence's elemenf counf, and 
some ofher int value, fhe following mefhod refurns fhe address of thaf value in fhaf 
sequence, if a mafch occurs; ofherwise, if refurns null: 

unsafe static int* Find(int* pi, int size, int value) { 
for (int i = 0; i < size; ++i) { 
if (*pi == value) 
return pi; 

++pi; 

} 

return null; 


In an unsafe confexf, several consfrucfs are available for operating on poinfers: 

• The * operator may be used fo perform poinfer indirecfion (§18.5.1). 

• The - > operator may be used fo access a member of a sfrucf fhrough a poinfer (§18.5.2). 

• The [ ] operafor may be used fo index a poinfer (§18.5.3). 

• The & operafor may be used fo obfain fhe address of a variable (§18.5.4). 

• The ++ and - - operators may be used fo incremenf and decremenf poinfers (§18.5.5). 

• The + and - operafors may be used fo perform poinfer arifhmefic (§18.5.6). 

• The ==, ! =, <, >, <=, and => operafors may be used fo compare poinfers (§18.5.7). 

• The stackalloc operafor may be used fo allocate memory from fhe call slack (§18.7). 

• The fixed sfafemenf may be used fo temporarily fix a variable so ifs address can be 
obfained (§18.6). 


18.3 Fixed and Moveable Variables 

The address-of operafor (§18.5.4) and fhe fixed sfafemenf (§18.6) divide variables info fwo 
categories:/ibed variables and moveable variables. 

Fixed variables reside in sforage locafions fhaf are unaffecfed by operafion of fhe garbage 
collecfor. (Examples of fixed variables include local variables, value paramefers, and vari¬ 
ables created by dereferencing poinfers.) In confrasf, moveable variables reside in sforage 
locafions fhaf are subjecf fo relocafion or disposal by fhe garbage collecfor. (Examples of 
moveable variables include fields in objecfs and elemenfs of arrays.) 


716 


www.it-ebooks.info 




18.4 Pointer Conversions 


The & operator (§18.5.4) permits the address of a fixed variable fo be obfained wifhouf 
resfricfions. However, because a moveable variable is subjecf fo relocafion or disposal by 
fhe garbage collector, fhe address of a moveable variable can be obfained only by using a 
fixed sfafemenf (§18.6), and fhaf address remains valid only for fhe duration of fhaf fixed 
sfafemenf. 

In precise ferms, a fixed variable is one of fhe following: 

• A variable resulting from a simple-name (§7.6.2) fhaf refers fo a local variable or a value 
paramefer, unless fhe variable is capfured by an anonymous funcfion. 

• A variable resulting from a member-access (§7.6.4) of fhe form V. I, where V is a fixed vari¬ 
able of a struct-type. 

• A variable resulting from a pointer-indirection-expression (§18.5.1) of fhe form *P, a 
pointer-member-access (§18.5.2) of fhe form P->I, or a pointer-element-access (§18.5.3) of 
fhe form P [ E ]. 

All ofher variables are classified as moveable variables. 

Note fhaf a sfafic field is classified as a moveable variable. Also note fhaf a ref or out 
paramefer is classified as a moveable variable, even if fhe argumenf given for fhe param¬ 
efer is a fixed variable. Finally, note fhaf a variable produced by dereferencing a pointer is 
always classified as a fixed variable. 


18.4 Pointer Conversions 

In an unsafe confexf, fhe sef of available implicif conversions (§6.1) is exfended fo include 
fhe following implicif pointer conversions: 

• From any pointer-type fo fhe type void*. 

• From the null literal to any pointer-type. 

Additionally, in an unsafe confexf, fhe sef of available explicif conversions (§6.2) is exfended 
fo include fhe following explicif pointer conversions: 

• From any pointer-type fo any ofher pointer-type. 

• From sbyte, byte, short, ushort, int, uint, long, or ulong fo any pointer-type. 

• From any pointer-type fo sbyte, byte, short, ushort, int, uint, long, or ulong. 


717 


www.it-ebooks.info 


18. Unsafe Code 




18. Unsafe Code 


18. Unsafe Code 


Finally, in an unsafe context, the set of standard implicit conversions (§6.3.1) includes the 
following pointer conversion: 

• From any pointer-type to the type void*. 

Conversions between two pointer types never change the actual pointer value. In other 
words, a conversion from one pointer type to another has no effect on the underlying 
address given by the pointer. 

When one pointer type is converted to another, if the resulting pointer is not correctly 
aligned for the pointed-to type, the behavior is undefined if the result is dereferenced. In 
general, the concept "correctly aligned" is transitive: If a pointer to type A is correctly 
aligned for a pointer to type B, which in turn is correctly aligned for a pointer to type C, 
then a pointer to type A is correctly aligned for a pointer to t 5 ^e C. 

Consider the following case in which a variable having one type is accessed via a pointer 
to a different type: 

char c = 'A'; 

char* pc = &c; 

void* pv = pc; 

int* pi = (int*)pv; 

int i = *pi; // Undefined 

*pi = 123456; // Undefined 

When a pointer t 5 ^e is converted to a pointer to byte, the result points to the lowest 
addressed byte of the variable. Successive increments of the result, up to the size of the 
variable, yield pointers to the remaining bytes of that variable. For example, the following 
method displays each of the eight bytes in a double as a hexadecimal value: 

using System; 

class Test 
{ 

unsafe static void Main() 

{ 

double d = 123.456e23; 

unsafe 

{ 

byte* pb = (byte*)&d; 

for (int i = 0; i < sizeof(double); ++i) 

Console.Write("{0:X2} ", *pb++); 

Console. WrlteLineO; 

} 

} 

} 

Of course, the output produced depends on endianness. 


718 


www.it-ebooks.info 




18.4 Pointer Conversions 


“■ PETER SESTOFT One use of unsafe code is fo perform conversions by reinfer- 
prefing bif pafferns fhaf represenf primitive dafa, sfrucfs, or references, by unsafely 
fype-casfing poinfers. In mosf cases, fhe resulf will be unporfable or meaningless. 
However, such reinferprefafion can be used fo porfably gef and sef fhe NaN payload 
bifs of IEEE floating poinf numbers (see fhe armofafion in §7.8.1): 

unsafe static int GetNaNPayload(float f) { 
float* p = &f; 

return *((int*)p) & 0X003FFFFF; 

} 

unsafe static float MakeNaNPayload(lnt nanbits) { 
float nan = Single.NaN; 
float* p = &nan; 

*((lnt*)p) 1= (nanbits & 0X003FFFFF); 
return nan; 

} 

Unsafe code does nof have fo be fhis obscure, buf if is likely fo be wrong because fhe 
sfandard sanify checks are fumed off. 

Mappings befween poinfers and infegers are implemenfation-defined. However, on 
32- and 64-bif CPU archifecfures wifh a linear address space, conversions of poinfers fo or 
from infegral fypes fypically behave exacfly like conversions of uint or along values, 
respectively, fo or from fhose infegral fypes. 

18.4.1 Pointer Arrays 

In an unsafe confexf, arrays of poinfers can be consfrucfed. Only some of fhe conversions 
fhaf apply fo ofher array fypes are allowed on poinfer arrays: 

• The implicif reference conversion (§6.1.6) from any array-type fo System .Array and fhe 
inferfaces if implemenfs also applies fo poinfer arrays. However, any affempf fo access 
fhe array elemenfs fhrough System. Array or fhe inferfaces if implemenfs will resulf in 
an excepfion af runtime, as poinfer fypes are nof convertible fo object. 

• The implicif and explicif reference conversions (§6.1.6, §6.2.4) from a single-dimensional 
array fype S[ ] fo System.Collections.Generic. I List<T> and ifsbase inferfaces never 
apply fo poinfer arrays, since poinfer fypes carmof be used as fype argumenfs, and fhere 
are no conversions from poinfer fypes fo non-poinfer fypes. 

• The explicif reference conversion (§6.2.4) from System. Array and fhe inferfaces if imple¬ 
menfs fo any array-type applies fo poinfer arrays. 


719 


www.it-ebooks.info 


18. Unsafe Code 






18. Unsafe Code 


18. Unsafe Code 


• The explicit reference conversions (§6.2.4) from System. Collections. Generic. I List<S> 
and ifs base inferfaces fo a single-dimensional array t 5 ^e T [ ] never apply fo poinfer 
arrays, since poinfer fypes cannof be used as type arguments, and there are no conver¬ 
sions from poinfer f 5 ^es fo non-poinfer f 5 ^es. 

These resfricfions mean fhaf fhe expansion for fhe foreach sfafemenf over arrays described 
in §8.8.4 carmof be applied fo poinfer arrays. Insfead, a foreach sfafemenf of fhe form 

foreach (V v in x) embedded-statement 

where fhe fype of x is an array type of fhe form T n is fhe number of dimensions 

minus 1, and T or V is a poinfer fype, is expanded using nesfed for loops as follows: 

{ 

T[,,...,] a 
V v; 

for (int i0 
for (int il 

for (int in = a.GetLowerBound(n); in <= a.GetUpperBound(n); in++) { 

V = (V)a.GetValue(i0,il,...,in); 
embedded-statement 

} 

} 

The variables a, i0, il, ... in are nof visible fo or accessible fo x or fhe embedded-statement 
or any ofher source code of fhe program. The variable v is read-only in fhe embedded sfafe¬ 
menf. If fhere is nof an explicif conversion (§18.4) from T (fhe elemenf fype) fo V, an error is 
produced and no furfher sfeps are faken. If x has fhe value null, a System. NullRef erence- 
Exception is fhrown af runfime. 


= x; 

= a.GetLowerBound(0); i0 
= a.GetLowerBound(l); il 


<= a.GetUpperBound(0); i0++) 
<= a.GetUpperBound(l); il++) 


18.5 Pointers in Expressions 

In an unsafe confexf, an expression may yield a resulf of a poinfer fype. Oufside an unsafe 
confexf, if is a compile-fime error for an expression fo be of a poinfer fype. In precise ferms, 
oufside an unsafe confexf, a compile-time error occurs if any simple-name (§7.6.2), member- 
access (§7.6.4), invocation-expression (§7.6.5), or element-access (§7.6.6) is of a poinfer fype. 

In an unsafe confexf, fhe primary-no-array-creation-expression (§7.6) and unary-expression 
(§7.7) productions permif fhe following addifional consfrucfs: 

primary-no-array-creation-expression: 

pointer-member-access 

pointer-element-access 

sizeof-expression 


720 


www.it-ebooks.info 




18.5 Pointers in Expressions 


unary-expression: 

pointer-indirection-expression 

addressof-expression 

These constructs are described in the following sections. The precedence and associativity 
of the unsafe operators are implied by the grammar. 

18.5.1 Pointer Indirection 

A pointer-indirection-expression consists of an asterisk (*) followed by a unary-expression. 

pointer-indirection-expression: 

unary-expression 

The unary * operator denotes pointer indirection and is used to obtain the variable to which 
a pointer points. The result of evaluating *P, where P is an expression of a pointer type T*, 
is a variable of t 5 ^e T. It is a compile-time error to apply the unary * operator to an expres¬ 
sion of t 5 ^e void* or fo an expression fhaf isn'f of a poinfer type. 

The effect of applying the unary * operator to a null pointer is implementation-defined. 
In particular, there is no guarantee that this operation throws a System.Null- 
Ref erenceExcept ion. 

If an invalid value has been assigned to the pointer, the behavior of fhe unary * operafor is 
undefined. Among the invalid values for dereferencing a pointer by the unary * operator 
are an address inappropriately aligned for fhe t 5 ^e pointed to (see example in §18.4), and 
the address of a variable affer fhe end of ifs lifetime. 

For purposes of definite assignment analysis, a variable produced by evaluating an expres¬ 
sion of fhe form *P is considered initially assigned (§5.3.1). 

18.5.2 Pointer Member Access 

A pointer-member-access consists of a primary-expression, followed by a " - >" token, followed 
by an identifier. 

pointer-member-access: 

primary-expression -> identifier type-argument-list 

In a pointer member access of the form P - >1, P must be an expression of a pointer type 
other than void*, and I must denote an accessible member of the t 5 ^e to which P points. 


“■ VLAD IMIR R ES H ETNIKOV You cannot apply pointer-member-access to pointer-to- 
pointer t 5 ^es (like int**), because pointers have no members. 


721 


www.it-ebooks.info 


18. Unsafe Code 






18. Unsafe Code 


18. Unsafe Code 


A pointer member access of the form P - > I is evaluated exactly as (*P).I.Fora description 
of the pointer indirection operator (*), see §18.5.1. For a description of the member access 
operator (.), see §7.6.4. 

In the example 

using System; 

struct Point 
{ 

public int x; 
public int y; 

public override string ToString() 

{ 

return "(" + x + + y + 

} 

} 

class Test 
{ 

static void Main() 

{ 

Point point; 

unsafe 

{ 

Point* p = Spoint; 
p->x = 10; 
p->y = 20; 

Console.WriteLine(p->ToString()); 

} 

} 

} 

the - > operator is used to access fields and invoke a method of a struct through a pointer. 
Because the operation P->I is precisely equivalent to (*P) .1, the Main method could 
equally well have been written like this: 

class Test 
{ 

static void Main() 

{ 

Point point; 

unsafe 

{ 

Point* p = Spoint; 

(*p).x = 10; 

(*p).y = 20; 

Console.WriteLine((*p) .ToStringO); 

} 

} 

} 


722 


www.it-ebooks.info 




18.5 Pointers in Expressions 


18.5.3 Pointer Element Access 

A pointer-element-access consists of a primary-no-array-creation-expression followed by an 
expression enclosed in " [" and " ] 

pointer-element-access: 

primary-no-array-creation-expression [ expression ] 

In a pointer element access of the form P [ E ], P must be an expression of a pointer type 
other than void*, and E must be an expression that can be implicitly converted to int, uint, 
long, or ulong. 

A pointer element access of the form P [ E ] is evaluated exactly as * ( P + E ). For a description 
of the pointer indirection operator (*), see §18.5.1. For a description of the pointer addition 
operator (+), see §18.5.6. 

In the example 

class Test 
{ 

static void Main() 

{ 

unsafe 

{ 

char* p = stackalloc char[256]; 

for (int i = 0; i < 256; i++) p[i] = (char)i; 

} 

} 

} 

a pointer element access is used to initialize the character buffer in a for loop. Because the 
operation P[E] is precisely equivalent to *(P + E), the example could equally well have 
been written like this: 

class Test 
{ 

static void Main() 

{ 

unsafe 

{ 

char* p = stackalloc char[256]; 

for (int i = 0; i < 256; i++) *(p + i) = (char)i; 

} 

} 

} 

The pointer element access operator does not check for out-of-bounds errors, and the 
behavior when accessing an out-of-bounds element is undefined. This is the same approach 
as used in C and C++. 


723 


www.it-ebooks.info 


18. Unsafe Code 




18. Unsafe Code 


18. Unsafe Code 


18.5.4 The Address-of Operator 

An addressof-expression consists of an ampersand (&) followed by a unary-expression. 

addressof-expression: 

& unary-expression 

Given an expression E that is of a type T and is classified as a fixed variable (§18.3), the 
construct &E computes the address of fhe variable given by E. The type of the result is T* 
and is classified as a value. A compile-fime error occurs if E is not classified as a variable, if 
E is classified as a read-only local variable, or if E denotes a moveable variable. In the last 
case, a fixed statement (§18.6) can be used to temporarily "fix" the variable before obtain¬ 
ing its address. As stated in §7.6.4, outside an instance constructor or static constructor for 
a struct or class that defines a readonly field, that field is considered a value, not a variable. 
As such, its address cannot be taken. Similarly, the address of a constant cannot be taken. 

The & operator does not require its argument to be definitely assigned, but following an & 
operation, fhe variable to which the operator is applied is considered definitely assigned in 
the execution path in which the operation occurs. It is the responsibility of the programmer 
to ensure that correct initialization of the variable actually does take place in this 
situation. 

In the example 

using System; 

class Test 
{ 

static void Main() 

{ 

int i; 
unsafe 
{ 

int* p = &i; 

*p = 123; 

} 

Console.WriteLine(i); 

} 

} 

i is considered definitely assigned following the &i operation used to initialize p. The 
assignment to *p in effect initializes i, but the inclusion of this initialization is the respon¬ 
sibility of the programmer, and no compile-time error would occur if the assignment was 
removed. 

The rules of definite assignment for fhe & operator exist such that redundant initialization 
of local variables can be avoided. For example, many external APIs take a pointer to a 
structure that is filled in by fhe API. Calls fo such APIs typically pass the address of a local 


724 


www.it-ebooks.info 




18.5 Pointers in Expressions 


struct variable, and without the rule, redundant initialization of the struct variable would 
be required. 


18.5.5 Pointer Increment and Decrement 

In an unsafe context, the ++ and - - operators (§7.6.9 and §7.7.5) can be applied to pointer 
variables of all types except void*. Thus, for every pointer t 5 q)e T*, the following operators 
are implicitly defined: 

T* operator ++(T* x); 

T* operator --(T* x); 

The operators produce the same results as x + 1 and x - 1, respectively (§18.5.6). In other 
words, for a pointer variable of type T*, the ++ operator adds sizeof (T) to the address 
contained in the variable, and the -- operator subtracts sizeof (T) from the address con¬ 
tained in the variable. 

If a pointer increment or decrement operation overflows the domain of the pointer t 5 q)e, 
the result is implementation-defined, but no exceptions are produced. 

18.5.6 Pointer Arithmetic 

In an unsafe context, the + and - operators (§7.8.4 and §7.8.5) can be applied to values of all 
pointer types except void*. Thus, for every pointer type T*, the following operators are 
implicitly defined: 

T* operator +(T* x, int y); 

T* operator +(T* x, uint y); 

T* operator +(T* x, long y); 

T* operator +(T* x, ulong y); 

T* operator +(int x, T* y); 

T* operator +(uint x, T* y); 

T* operator +(long x, T* y); 

T* operator +(ulong x, T* y); 

T* operator -(T* x, int y); 

T* operator -(T* x, uint y); 

T* operator -(T* x, long y); 

T* operator -(T* x, ulong y); 

long operator -(T* x, T* y); 

Given an expression P of a pointer type T* and an expression N of t5q5e int, uint, long, or 
ulong, the expressions P + N and N + P compute the pointer value of type T* that results from 
adding N * sizeof (T) to the address given by P. Likewise, the expression P - N computes 
the pointer value of type T* that results from subtracting N * sizeof (T) from the address 
given by P. 


725 


www.it-ebooks.info 


18. Unsafe Code 




18. Unsafe Code 


18. Unsafe Code 


Given two expressions, P and Q, of a pointer t 5 ^e T*, the expression P - Q computes the dif¬ 
ference between the addresses given by P and Q and then divides that difference by 
sizeof (T). The t 5 ^e of the result is always long. In effect, P - Qis computed as ( (long) (P) 
- (long)(Q)) / sizeof(T). 

For example, 

using System; 

class Test 
{ 

static void Main() 

{ 

unsafe 

{ 

int* values = stackalloc int[20]; 
int* p = &values[l]; 
int* q = &values[15]; 

Console.WriteLine("p - q = {0}", p - q); 

Console.WriteLine("q - p = {0}", q - p); 

} 

} 

} 

produces the following output: 

p - q = -14 
q - p = 14 

If a pointer arithmetic operation overflows the domain of the pointer type, the result is 
truncated in an implementation-defined fashion, but no exceptions are produced. 


18.5.7 Pointer Comparison 

In an unsafe context, the ==, ! =, <, >, <=, and => operators (§7.10) can be applied to values 
of all pointer types. The pointer comparison operators are: 

bool operator ==(void* x, void* y); 
bool operator !=(void* x, void* y); 
bool operator <(void* x, void* y); 
bool operator >(void* x, void* y); 
bool operator <=(void* x, void* y); 
bool operator >=(void* x, void* y); 

Because an implicit conversion exists from any pointer type to the void* type, operands of 
any pointer type can be compared using these operators. The comparison operators com¬ 
pare the addresses given by the two operands as if they were unsigned integers. 


726 


www.it-ebooks.info 




18.5 Pointers in Expressions 


18.5.8 The sizeof Operator 

The sizeof operator returns the number of bytes occupied by a variable of a given type. 
The t 5 ^e specified as an operand to sizeof must be an unmanaged-type (§18.2). 

sizeof-expression: 

sizeof ( unmanaged-type ) 

The result of the sizeof operator is a value of type int. For certain predefined types, the 
sizeof operator yields a constant value as shown in the table below. 


Expression 

Result 

sizeof(sbyte) 

1 

sizeof(byte) 

1 

sizeof(short) 

2 

sizeof(ushort) 

2 

sizeof(int) 

4 

sizeof(uint) 

4 

sizeof(long) 

8 

sizeof(ulong) 

8 

sizeof(char) 

2 

sizeof(float) 

4 

sizeof(double) 

8 

sizeof(bool) 

1 


For all other t 5 ^es, the result of the sizeof operator is implementation-defined and is clas¬ 
sified as a value, not a constant. 

The order in which members are packed into a struct is unspecified. 

For alignment purposes, there may be unnamed padding at the beginning of a struct, 
within a struct, and at the end of the struct. The contents of the bits used as padding are 
indeterminate. 

When applied to an operand that has struct type, the result is the total number of bytes in 
a variable of that t 5 ^e, including any padding. 

727 


www.it-ebooks.info 


18. Unsafe Code 


















18. Unsafe Code 


18. Unsafe Code 


18.6 The fixed Statement 

In an unsafe context, the embedded-statement (§8) production permits an additional con¬ 
struct, the fixed statement, which is used to "fix" a moveable variable such that its address 
remains constant for the duration of the statement. 

embedded-statement: 

fixed-statement 

fixed-statement: 

fixed ( pointer-type fixed-pointer-declarators ) embedded-statement 

fixed-pointer-declarators: 

fixed-pointer-declarator 

fixed-pointer-declarators , fixed-pointer-declarator 

fixed-pointer-declarator: 

identifier = fixed-pointer-initializer 

fixed-pointer-initializer: 

& variable-reference 
expression 

Each fixed-pointer-declarator declares a local variable of the given pointer-type and initializes 
that local variable with the address computed by the corresponding fixed-pointer-initializer. 
A local variable declared in a fixed statement is accessible in any fixed-pointer-initializers 
occurring to the right of that variable's declaration, and in the embedded-statement of the 
fixed statement. A local variable declared by a fixed statement is considered read-only. A 
compile-time error occurs if the embedded statement attempts to modify this local variable 
(via assignment or the ++ and - - operators) or pass it as a ref or out parameter. 

A fixed-pointer-initializer can be one of the following: 

• The token followed by a variable-reference (§5.3.3) to a moveable variable (§18.3) of 
an unmanaged type T, provided the type T* is implicitly convertible to the pointer type 
given in the fixed statement. In this case, the initializer computes the address of the 
given variable, and the variable is guaranteed to remain at a fixed address for the dura¬ 
tion of the fixed statement. 

• An expression of an array-type with elements of an unmanaged type T, provided the type 
T* is implicitly convertible to the pointer t 5 ^e given in the fixed statement. In this case, 
the initializer computes the address of the first element in the array, and the entire array 
is guaranteed to remain at a fixed address for the duration of the fixed statement. The 


728 


www.it-ebooks.info 




18.6 The fixed Statement 


behavior of the fixed statement is implementation-defined if the array expression is null 
or if the array has zero elements. 

• An expression of type string, provided the type char* is implicitly convertible to the 
pointer type given in the fixed statement. In this case, the initializer computes the 
address of the first character in the string, and the entire string is guaranteed to remain 
at a fixed address for the duration of the fixed statement. The behavior of the fixed 
statement is implementation-defined if the string expression is null. 

• A simple-name or member-access that references a fixed size buffer member of a moveable 
variable, provided the type of the fixed size buffer member is implicitly convertible to 
the pointer type given in the fixed statement. In this case, the initializer computes a 
pointer to the first element of the fixed size buffer (§18.7.2), and the fixed size buffer is 
guaranteed to remain at a fixed address for the duration of the fixed statement. 


"■ ERIC LIPPERT This point demonstrates a potentially confusing conflation: The 
keyword fixed is used to mean both "fixed in location" and "fixed in size." Adding 
to the confusion is the fact that a fixed-in-size array member must be fixed-in¬ 
location to be used. Try to keep in mind that a fixed-in-size block is not automati¬ 
cally fixed-in-place. 


For each address computed by a fixed-pointer-initializer, the fixed statement ensures that 
the variable referenced by the address is not subject to relocation or disposal by the gar¬ 
bage collector for the duration of the fixed statement. For example, if the address com¬ 
puted by a fixed-pointer-initializer references a field of an object or an element of an array 
instance, the fixed statement guarantees that the containing object instance will not be 
relocated or disposed of during the lifetime of the statement. 

It is the programmer's responsibility to ensure that pointers created by fixed statements 
do not survive beyond execution of those statements. For example, when pointers created 
by fixed statements are passed to external APIs, it is the programmer's responsibility to 
ensure that the APIs retain no memory of these pointers. 


“■ E RIC LIP P E RT If you are in the unfortunate position of having to keep a block of 
managed memory fixed in place for longer than the duration of a fixed statement, 
then you can do so via the GCHandle t 5 ^e. That said, it is best to avoid getting into that 
situation in the first place. 


Fixed objects may cause fragmentation of the heap (because they carmot be moved). For 
that reason, objects should be fixed only when absolutely necessary, and then only for the 
shortest amount of time possible. 


729 


www.it-ebooks.info 


18. Unsafe Code 








18. Unsafe Code 


18. Unsafe Code 


The example 

class Test 
{ 

static int x; 
int y; 

unsafe static void F(int* p) 

{ 

*p = i; 

} 

static void Main() 

{ 

Test t = new Test(); 
int[] a = new int[10]; 
unsafe 
{ 

fixed (int* p = &x) F(p); 
fixed (int* p = &t.y) F(p); 
fixed (int* p = &a[0]) F(p); 
fixed (int* p = a) F(p); 

} 

} 

} 

demonstrates several uses of the fixed statement. The first statement fixes and obfains fhe 
address of a sfafic field, fhe second sfafemenf fixes and obfains fhe address of an insfance 
field, and fhe fhird sfafemenf fixes and obfains fhe address of an array elemenf. In each 
case if would have been an error fo use fhe regular & operafor since fhe variables are all 
classified as moveable variables. 

The fourfh fixed sfafemenf in fhe example above produces a similar resulf fo fhe fhird. 

This example of fhe fixed sfafemenf uses string: 

class Test 
{ 

static string name = "xx"; 

unsafe static void F(char* p) 

{ 

for (int i = 0; p[i] != ’\0’; ++i) 

Console.WriteLine(p[i]); 

} 

static void Main() 

{ 

unsafe 

{ 

fixed (char* p = name) F(p); 
fixed (char* p = "xx") F(p); 

} 

} 

} 


730 


www.it-ebooks.info 




18.6 The fixed Statement 


In an unsafe context, array elements of single-dimensional arrays are stored in increasing 
index order, starting with index 0 and ending with index Length - 1. For multi-dimen¬ 
sional arrays, array elements are stored such that the indices of the rightmost dimension 
are increased first, then the next left dimension, and so on to the left. Within a fixed 
statement that obtains a pointer p to an array instance a, the pointer values ranging from 
p to p + a. Length - 1 represent addresses of the elements in the array. Likewise, the vari¬ 
ables ranging from p[0] to p[a. Length - 1] represent the actual array elements. Given 
the way in which arrays are stored, we can treat an array of any dimension as though it 
were linear. 

For example, 

using System; 

class Test 
{ 

static void Main() 

{ 

int[, ,] a = new int[2, 3, 4]; 

unsafe 

{ 

fixed (int* p = a) 

{ 

for (int i = 0; i < a.Length; ++i) // Treat as linear 

P[i] = i; 

} 

} 

for (int i = 0; i < 2; ++i) 

for (int j = 0; j < 3; ++j) 

{ 

for (int k = 0; k < 4; ++k) 

Console.Write("[{0},{l},{2}] = {3,2} ", i, j, k, a[i, j, k]); 

Console.WriteLine(); 

} 

} 

} 

produces the following output: 


[0,0,0] 

= 0 

[0.0.1] 

= 1 

[0.0.2] 

= 2 

[0.0.3] 

= 3 

[0,1,0] 

= 4 

[0.1.1] 

= 5 

[0.1.2] 

= 6 

[0.1.3] 

= 7 

[0,2,0] 

= 8 

[0.2.1] 

= 9 

[0.2.2] 

= 10 

[0.2.3] 

= 11 

[1,0,0] 

= 12 

[1.0.1] 

= 13 

[1.0.2] 

= 14 

[1.0.3] 

= 15 

[1.1,0] 

= 16 

[1.1.1] 

= 17 

[1.1.2] 

= 18 

[1.1.3] 

= 19 

[1.2,0] 

= 20 

[1.2.1] 

= 21 

[1.2.2] 

= 22 

[1.2.3] 

= 23 


731 


www.it-ebooks.info 


18. Unsafe Code 




18. Unsafe Code 


18. Unsafe Code 


In the example 

class Test 

{ 

unsafe static void Fill(int* p, int count, int value) 

{ 

for (; count != 0; count--) *p++ = value; 

} 

static void Main() 

{ 

int[] a = new int[100]; 

unsafe 

{ 

fixed (int* p = a) Fill(p, 100, -1); 

} 

} 

} 

a fixed statement is used to fix an array so its address can be passed to a method that takes 
a pointer. 

In the example 

unsafe struct Font 

{ 

public int size; 

public fixed char name[32]; 

} 

class Test 

{ 

unsafe static void PutString(string s, char* buffer, int bufSize) 

{ 

int len = s.Length; 

if (len > bufSize) len = bufSize; 

for (int i = 0; i < len; i++) buffer[i] = s[l]; 

for (int i = len; i < bufSize; i++) buffer[i] = (char)0; 

} 

Font f; 

unsafe static void Main() 

{ 

Test test = new Test(); 

test.f.size = 10; 

fixed (char* p = test.f.name) 

{ 

PutString("Times New Roman", p, 32); 

} 

} 


732 


www.it-ebooks.info 




18.7 Fixed-Size Buffers 


a fixed statement is used to fix a fixed-size buffer of a sfrucf so fhaf ifs address can be used 
as a poinfer. 

A char* value produced by fixing a sfring insfance always poinfs fo a null-ferminafed 
sfring. Wifhin a fixed sfafemenf fhaf obfains a poinfer p fo a sfring insfance s, fhe poinfer 
values ranging from p fo p + s. Length - 1 represenf addresses of fhe characfers in fhe 
sfring, and fhe poinfer value p + s. Length always poinfs fo a null characfer (fhe characfer 
with value '\0')- 

Modifying objecfs of managed type through fixed poinfers can resulf in undefined behav¬ 
ior. For example, because sfrings are immufable, if is fhe programmer's responsibilify fo 
ensure fhaf fhe characfers referenced by a poinfer fo a fixed sfring are nof modified. 

The aufomafic null-ferminafion of sfrings is particularly convenienf when calling exfemal 
APIs fhaf expecf "C-sfyle" sfrings. Nofe, however, fhaf a sfring insfance is permiffed fo 
confain null characfers. If such null characfers are presenf, fhe sfring will appear fruncafed 
when freafed as a null-ferminafed char*. 

18.7 Fixed-Size Buffers 

Fixed-size buffers are used fo declare "C sfyle" in-line arrays as members of sfrucfs, and 
are primarily useful for inferfacing wifh unmanaged APIs. 

18.7.1 Fixed-Size Buffer Declarations 

Afixed-size buffer is a member fhaf represenfs storage for a fixed-lengfh buffer of variables 
of a given fype. A fixed-size buffer declarafion infroduces one or more fixed-size buffers of 
a given elemenf fype. Fixed-size buffers are permiffed only in sfrucf declarafions and can 
occur only in unsafe confexfs (§18.1). 

struct-member-declaration: 

fixed-size-buffer-declaration 

fixed-size-buffer-declaration: 

attributes^^^ fixed-size-buffer-modifiers fixed buffer-element-type 
fixed-size-buffer-declarators ; 

fixed-size-buffer-modifiers: 

fixed-size-buffer-modifier 

fixed-size-buffer-modifier fixed-size-buffer-modifiers 


733 


www.it-ebooks.info 


18. Unsafe Code 




18. Unsafe Code 


18. Unsafe Code 


fixed-size-buffer-modifier: 

new 

public 

protected 

internal 

private 

unsafe 

buffer-element-type: 

type 

fixed-size-buffer-declarators: 

fixed-size-buffer-declarator 

fixed-size-buffer-declarator , fixed-size-buffer-declarators 

fixed-size-buffer-declarator: 

identifier [ constant-expression ] 

A fixed-size buffer declarafion may include a sef of aftributes (§17), a new modifier (§10.2.2), 
a valid combination of the four access modifiers (§10.2.3), and an unsafe modifier (§18.1). 
The attributes and modifiers apply to all of the members declared by the fixed-size buffer 
declaration. It is an error for the same modifier to appear multiple times in a fixed-size buf¬ 
fer declaration. 

A fixed-size buffer declaration is not permitted to include the static modifier. 

The buffer element t 5 ^e of a fixed-size buffer declaration specifies the element type of the 
buffer(s) introduced by the declaration. The buffer element type must be one of the pre¬ 
defined types sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, 
or bool. 

The buffer element t 5 ^e is followed by a list of fixed-size buffer declarators, each of which 
introduces a new member. A fixed-size buffer declarator consists of an identifier that names 
the member, followed by a constant expression enclosed in " [" and "]" tokens. The con¬ 
stant expression denotes the number of elements in the member introduced by that fixed- 
size buffer declarator. The t 5 ^e of the constant expression must be implicitly convertible to 
type int, and the value must be a non-zero positive integer. 

The elements of a fixed-size buffer are guaranteed to be laid out sequentially in memory. 

A fixed-size buffer declaration that declares multiple fixed-size buffers is equivalent to 
multiple declarations of a single fixed-size buffer with the same attributes and element 
types. For example. 


734 


www.it-ebooks.info 




18.7 Fixed-Size Buffers 


unsafe struct A 
{ 

public fixed int x[5], y[10], z[100]; 

} 


is equivalent to 

unsafe struct A 
{ 

public fixed int x[5]; 
public fixed int y[10]; 
public fixed int z[100]; 

} 

18.7.2 Fixed-Size Buffers in Expressions 

Member lookup (§7.3) of a fixed-size buffer member proceeds exacfly like member lookup 
of a field. 

A fixed-size buffer can be referenced in an expression using a simple-name (§7.5.2) or a 
member-access (§7.5.4). 

When a fixed-size buffer member is referenced as a simple name, fhe effecf is fhe same as 
a member access of fhe form this. I, where I is fhe fixed-size buffer member. 

In a member access of fhe form E. I, if E is of a sfrucf t 5 q)e and a member lookup of I in fhaf 
sfrucf t 5 q)e idenfifies a fixed-size member, fhen E. I is evaluafed and classified as follows: 


• If fhe expression E. I does nof occur in an unsafe confexf, a compile-fime error occurs. 

• If E is classified as a value, a compile-fime error occurs. 

• Ofherwise, if E is a moveable variable (§18.3) and fhe expression E. I is nof a fixed-pointer- 
initializer (§18.6), a compile-fime error occurs. 

• Ofherwise, E references a fixed variable and fhe resulf of fhe expression is a poinfer fo 
fhe firsf elemenf of fhe fixed-size buffer member I in E. The resulf is of t 5 q)e S*, where S 
is fhe elemenf fype of I, and is classified as a value. 


The subsequenf elemenfs of fhe fixed-size buffer can be accessed using poinfer operations 
from the first element. Unlike access to arrays, access to the elements of a fixed-size buffer 
is an unsafe operation and is nof range checked. 

The following example declares and uses a sfrucf wifh a fixed-size buffer member: 

unsafe struct Font 
{ 

public int size; 

public fixed char name[32]; 

} 


735 


www.it-ebooks.info 


18. Unsafe Code 




18. Unsafe Code 


18. Unsafe Code 


class Test 
{ 

unsafe static void PutString(string s, char* buffer, int bufSize) 

{ 

int len = s.Length; 

if (len > bufSize) len = bufSize; 

for (int i = 0; i < len; i++) buffer[i] = s[l]; 

for (int i = len; i < bufSize; i++) buffer[i] = (char)0; 

} 

unsafe static void Main() 

{ 

Font f; 
f.size = 10; 

PutStringC'Times New Roman", f.name, 32); 

} 

} 

18.7.3 Definite Assignment Checking 

Fixed-size buffers are nof subjecf fo defiriife assignmenf checking (§5.3), and fixed-size buf¬ 
fer members are ignored for purposes of definife assignmenf checking of sfrucf type 
variables. 

When the outermost containing struct variable of a fixed-size buffer member is a static 
variable, an instance variable of a class instance, or an array element, the elements of the 
fixed-size buffer are automatically initialized to their default values (§5.2). In all other 
cases, the initial content of a fixed-size buffer is undefined. 


18.8 Stack Allocation 

In an unsafe context, a local variable declaration (§8.5.1) may include a stack allocation 
initializer that allocates memory from the call stack. 


“■ ERIC LI PPERT This is a bit overspecific; there is no requirement that a particular 
CPU allow allocation of arbitrary memory on its call stack. For example, the CLR could 
be implemented on a CPU architecture that keeps two stacks—one for storage of local 
variables and one for tracking return addresses. (Such architectures prevent the stack¬ 
rewriting attacks that plagued the x86 architecture.) Really, what we ought to say here 
is simply that an immobile local memory store is associated with each method invoca¬ 
tion, and that stackalloc allocates memory out of that store. In a t 5 q)ical implementa¬ 
tion, that store will be the call stack, but that's an implementation detail. 


736 


www.it-ebooks.info 






18.8 Stack Allocation 


local-variahle-initializer: 

stackalloc-initializer 

stackalloc-initializer: 

stackalloc unmanaged-type [ expression ] 

The unmanaged-type indicates the type of the items that will be stored in the newly allo¬ 
cated location, and the expression indicates the number of these items. Taken together, these 
specify the required allocation size. Since the size of a stack allocation cannot be negative, 
it is a compile-time error to specify the number of items as a constant-expression that evalu¬ 
ates to a negative value. 

A stack allocation initializer of the form stackalloc T[E] requires T to be an unmanaged 
type (§18.2) and E to be an expression of type int. The construct allocates E * sizeof (T) 
bytes from the call stack and returns a pointer, of type T*, to the newly allocated block. If E 
is a negative value, then the behavior is undefined. If E is zero, then no allocation is made, 
and the pointer returned is implementation-defined. If there is not enough memory avail¬ 
able to allocate a block of the given size, a System. StackOverflowException is thrown. 

The content of the newly allocated memory is undefined. 

Stack allocation initializers are not permitted in catch or finally blocks (§8.10). 

There is no way to explicitly free memory allocated using stackalloc. All stack allocated 
memory blocks created during the execution of a function member are automatically dis¬ 
carded when that function member returns. This corresponds to the a Hoc a function, an 
extension commonly found in C and C++ implementations. 

In the example 

using System; 

class Test 
{ 

static string IntToString(int value) 

{ 

int n = value >= 0 ? value : -value; 

unsafe 

{ 

char* buffer = stackalloc char[16]; 
char* p = buffer + 16; 
do 
{ 

*--p = (char)(n % 10 + '0'); 
n /= 10; 

} while (n != 0); 


737 


www.it-ebooks.info 


18. Unsafe Code 




18. Unsafe Code 


18. Unsafe Code 


if (value < 0) *--p = 

return new string(pj 0, (int)(buffer + 16 - p)); 

} 

} 

static void Main() 

{ 

Console.WriteLine(IntToString(12345)); 

Console .WriteLine(IntToString(-999)); 

} 

} 

a stackalloc initializer is used in the IntToString method to allocate a buffer of 16 char- 
acfers on fhe sfack. The buffer is aufomafically discarded when fhe mefhod returns. 

18.9 Dynamic Memory Allocation 

Except for fhe stackalloc operator, C# provides no predefined constructs for managing 
non-garbage-collecfed memory. Such services are typically provided by supporting class 
libraries or imported directly from the underlying operating system. For example, the 
Memory class below illustrates how the heap functions of an underlying operating system 
might be accessed from C#: 

using System; 

using System.Runtime.InteropServices; 

public unsafe class Memory 

{ 

// Handle for the process heap. This handle is used 

// in all calls to the 

// HeapXXX APIs in the methods below. 

static int ph = GetProcessHeapO; 

// Private instance constructor to prevent instantiation, 
private Memory() { } 

// Allocates a memory block of the given size. 

// The allocated memory is 
// automatically initialized to zero. 

public static void* Alloc(int size) 

{ 

void* result = HeapAlloc(ph, HEAP_ZERO_MEMORY, size); 
if (result == null) throw new OutOfMemoryException(); 
return result; 

} 

// Copies count bytes from src to dst. The source and destination 
// blocks are permitted to overlap. 


738 


www.it-ebooks.info 




18.9 Dynamic Memory Allocation 


public static void Copy(void* src, void* dstj int count) 

{ 

byte* ps = (byte*)src; 
byte* pd = (byte*)dst; 
if (ps > pd) 

{ 

for (; count != 0; count--) *pd++ = *ps++; 

} 

else if (ps < pd) 

{ 

for (ps += count, pd += count; count != 0; count--) *--pd = *--ps; 

} 

} 

// Frees a memory block. 

public static void Free(void* block) 

{ 

if (!HeapFree(ph, 0, block)) throw new InvalidOperationException(); 

} 

// Reallocates a memory block. If the reallocation 
// request is for a larger size, the additional region of 
// memory is automatically initialized to zero. 

public static void* ReAlloc(void* block, int size) 

{ 

void* result = FleapReAlloc(ph, FIEAP_ZERO_MEMORY, block, size); 
if (result == null) throw new OutOfMemoryException(); 
return result; 

} 

// Returns the size of a memory block. 

public static int SizeOf(void* block) 

{ 

int result = FleapSize(ph, 0, block); 

if (result == -1) throw new InvalidOperationExceptlon(); 
return result; 

} 

// Fleap API flags 

const int HEAP_ZERO_MEMORY = 0X00000008; 

// Heap API functions 

[DllImport("kernel32") ] 

static extern int GetProcessHeap(); 

[DllImport("kernel32")] 

static extern void* HeapAlloc(int hHeap, int flags, int size); 

[DllImport("kernel32") ] 

static extern bool HeapFree(int hHeap, int flags, void* block); 


739 


www.it-ebooks.info 


18. Unsafe Code 




18. Unsafe Code 


18. Unsafe Code 


[DllImport("kernel32")] 

static extern void* HeapReAlloc(int hHeap, int flags, 
void* block, int size); 

[DllImport("kernel32")] 

static extern int HeapSize(int hHeap, int flags, void* block); 

} 

An example that uses the Memory class is given below: 

class Test 

{ 

static void Main() 

{ 

unsafe 

{ 

byte* buffer = (byte*)Memory.Alloc(256); 
try 
{ 

for (int i = 0; i < 256; i++) buffer[i] = (byte)i; 
byte[] array = new byte[256]; 

fixed (byte* p = array) Memory.Copy(buffer, p, 256); 

} 

finally 

{ 

Memory.Free(buffer); 

} 

for (int i = 0; i < 256; i++) Console.WriteLine(array[i]); 

} 

} 

} 

This example allocates 256 bytes of memory through Memory. Alloc and initializes the 
memory block with values increasing from 0 fo 255. If fhen allocafes a 256-elemenf byfe 
array and uses Memory. Copy fo copy fhe confenfs of fhe memory block info fhe byfe array. 
Finally, fhe memory block is freed using Memory .Free and fhe confenfs of fhe byfe array are 
oufpuf on fhe console. 


740 


www.it-ebooks.info 




A. Documentation Comments 


C# provides a mechanism for programmers to document their code using a special com¬ 
ment syntax that contains XML text. In source code files, comments having a certain form 
can be used to direct a tool to produce XML from those comments and the source code ele¬ 
ments, which they precede. Comments using such S 5 mtax are called documentation com¬ 
ments. They must immediately precede a user-defined type (such as a class, delegate, or 
interface) or a member (such as a field, event, property, or method). The XML generation 
tool is called the documentation generator. (This generator could be, but need not be, the 
C# compiler itself.) The output produced by the documentation generator is called the 
documentation file. A documentation file is used as input to a documentation viewer —a 
tool intended to produce some sort of visual display of type information and its associated 
documentation. 

This specification suggests a set of tags to be used in documentation comments. Use of 
these tags is not required, and other tags may be used if desired, as long the rules of well- 
formed XML are followed. 


A.l Introduction 

Comments having a special form can be used to direct a tool to produce XML from those 
comments and the source code elements, which they precede. Such comments are single- 
line comments that start with three slashes (///), or delimited comments that start with a 
slash and two stars (/**). They must immediately precede a user-defined type (such as a 
class, delegate, or interface) or a member (such as a field, event, property, or method) that 
they annotate. Attribute sections (§17.2) are considered part of declarations, so documenta¬ 
tion comments must precede attributes applied to a type or member. 

Syntax: 

single-line-doc-comment: 

III input-characters^^ 

delimited-doc-comment: 

!** delimited-comment-text . */ 

opt 


741 


www.it-ebooks.info 




Do^m^athQBOtenments 


A. Documentation Comments 



In a single-line-doc-comment, if there is a whitespace character following the III characters on 
each of the single-line-doc-comments adjacent to the current single-line-doc-comment, then that 
whitespace character is not included in the XML output. 

In a delimited-doc-comment, if the first non-whitespace character on the second line is an aster¬ 
isk and the same pattern of optional whitespace characters and an asterisk character is 
repeated at the beginning of each of the lines within the delimited-doc-comment, then the 
characters of the repeated pattern are not included in the XML output. The pattern may 
include whitespace characters after, as well as before, the asterisk character. 

Example: 

III <summary>Class <c>Point</c> models a point in a two-dimensional 
III plane.</summary> 

/// 

public class Point 
{ 

III <summary>method <c>draw</c> renders the point.</summary> 
void draw() {...} 

} 

The text within documentation comments must be well formed according to the rules of 
XML (http:/ /www.w3.org/TR/REC-xml). If the XML is ill formed, a warning is generated 
and the documentation file will contain a comment saying that an error was encountered. 

Although developers are free to create their own set of tags, a recommended set is defined 
in §A.2. Some of the recommended tags have special meanings: 

• The <param> tag is used to describe parameters. If such a tag is used, the documentation 
generator must verify that the specified parameter exists and that all parameters are 
described in documentation comments. If such verification fails, the documentation gen¬ 
erator issues a warning. 

• The cref attribute can be attached to any tag to provide a reference to a code element. 
The documentation generator must verify that this code element exists. If the verifica¬ 
tion fails, the documentation generator issues a warning. When looking for a name 
described in a cref attribute, the documentation generator must respect namespace vis¬ 
ibility according to using statements appearing within the source code. For code ele¬ 
ments that are generic, the normal generic S 5 mtax (i.e., "List<T >") cannot be used because 
it produces invalid XML. Braces can be used instead of brackets (i.e., "List{T}"), or the 
XML escape S 5 mtax can be used (i.e., "List&lt jT&gt;"). 

• The <summary> tag is intended to be used by a documentation viewer to display addi¬ 
tional information about a type or member. 

• The <include> tag includes information from an external XML file. 


742 


www.it-ebooks.info 



A.2 Recommended Tags 


Note that the documentation file does not provide full informafion abouf fhe t 5 ^e and 
members (for example, if does nof confain any type information). To get such information 
about a t 5 ^e or member, the documentation file musf be used in conjuncfion wifh reflec- 
fion on fhe acfual t 5 ^e or member. 

A.2 Recommended Tags 

The documenfafion generafor musf accepf and process any fag fhaf is valid according fo 
fhe rules of XML. The following fags provide commonly used funcfionalify in user docu¬ 
menfafion. (Of course, ofher fags are possible.) 


Tag 

Section 

Purpose 

<c> 

A.2.1 

Set text in a code-like font 

<code> 

A.2.2 

Set one or more lines of source code or program output 

<example> 

A.2.3 

Indicate an example 

<exception> 

A.2.4 

Identifies the exceptions a method can throw 

<include> 

A.2.5 

Includes XML from an external file 

<list> 

A.2.6 

Create a list or table 

<para> 

A.2.7 

Permit structure to be added to text 

<param> 

A.2.8 

Describe a parameter for a method or constructor 

<paramref> 

A.2.9 

Identify that a word is a parameter name 

<permission> 

A.2.10 

Document the security accessibility of a member 

<remark> 

A.2.11 

Describe additional information about a type 

<returns> 

A.2.12 

Describe the return value of a method 

<see> 

A.2.13 

Specify a link 

<seealso> 

A.2.14 

Generate a See Also entry 

<summary> 

A.2.15 

Describe a type or a member of a type 

<value> 

A.2.16 

Describe a property 


Continued 

743 


www.it-ebooks.info 


Comments 























Do^m^athQBOtenments 


A. Documentation Comments 


Tag 

Section 

Purpose 

<typeparam> 

A.2.17 

Describe a generic type parameter 

<typeparamref> 

A.2.18 

Identify that a word is a type parameter name 



A.2.1 <c> 

This tag provides a mechanism to indicate that a fragment of text within a description 
should be set in a special font such as that used for a block of code. For lines of actual code, 
use <code> (§A.2.2). 

Syntax: 

<c>text</c> 

Example: 

III <summary>Class <c>Point</c> models a point in a two-dimensional 
III plane.</summary> 
public class Point 
{ 

n ... 

} 

A.2.2 <code> 

This tag is used to set one or more lines of source code or program oufpuf in some special 
font. For small code fragments in narrative, use <c> (§A.2.1). 

Syntax: 

<code>source code or program output<lcode> 

Example: 

III <summary>This method changes the point's location by 
III the given x- and y-offsets. 

Ill <example>For example: 

III <code> 

III Point p = new Point(3,5); 

III p.Translate(-l,3); 

III </code> 

III results in <c>p</c>'s having the value (2,8). 

Ill </example> 

III </summary> 

public void Translate(int xor, int yor) { 

X += xor; 

Y += yor; 

} 


744 


www.it-ebooks.info 








A.2 Recommended Tags 


A.2.3 <example> 

This tag allows example code within a comment to specify how a method or other library 
member may be used. Ordinarily, this would also involve use of the tag <code> (§A.2.2). 

Syntax: 

<example>description</example> 

Example: 

See <code> (§A.2.2) for an example. 

A.2.4 <exception> 

This tag provides a way to document the exceptions a method can throw. 

Syntax: 

<exception cref="member">description</exception> 
where 

cref-"member" 

The name of a member. The documenfation generator checks that the given member 
exists and translates member to the canonical element name in the documentation file. 

description 

A description of the circumstances in which the exception is thrown. 

Example: 

public class DataBaseOperations 
{ 

III cexception cref="MasterFileFormatCorruptException"></exception> 

III cexception cref="MasterFileLockedOpenException"></exception> 
public static void ReadRecord(int flag) { 
if (flag == 1) 

throw new MasterFileFormatCorruptException(); 
else if (flag == 2) 

throw new MasterFileLockedOpenException(); 

// ... 

} 

} 


> 


A.2.5 <include> 

This tag allows including information from an XML document that is external to the source 
code file. The external file must be a well-formed XML document, and an XPath expression 
is applied to that document to specify which XML from that document to include. The 
<include> tag is then replaced with the selected XML from the external document. 


745 


www.it-ebooks.info 


Comments 




Do^m^athQBOtenments 


A. Documentation Comments 


Syntax: 

<include file="fiLename" path=’'xpath" /> 

where 

file-"fiLename " 

The file name of an external XML file. The file name is interpreted relative to the file 
that contains the include tag. 

path-"xpath" 



An XPath expression that selects some of the XML in the external XML file. 
Example: 

If the source code contained a declaration like this: 

III <include file="docs.xml" path='extradoc/class[@name="IntList"]/*’ /> 
public class IntList { ... } 

and the external file "docs.xml" had the following contents: 

<?xrrl version="1.0"?> 

<extradoc> 

<class name="IntList"> 

<summary> 

Contains a list of integers. 

</summary> 

</class> 

<class name="StringList"> 

<summary> 

Contains a list of integers. 

</summary> 

</class> 

</extradoc> 

then the same documentation is output as if the source code contained: 

III <summary> 

III Contains a list of integers. 

Ill </summary> 

public class IntList { ... } 


A.2.6 <list> 

This tag is used to create a list or table of items. It may contain a <listheader> block to 
define the heading row of either a table or definition list. (When defining a table, only an 
entry for term in the heading need be supplied.) 


746 


www.it-ebooks.info 



A.2 Recommended Tags 


Each item in the list is specified with an <item> block. When creating a definition list, both 
term and description must be specified. However, for a fable, bullefed lisf, or numbered 
lisf, only description need be specified. 

Syntax: 

<list type="bullet" | "number" | "table"> 

<listheader> 

<term>term</term> 

< descript ion >descriptior7</descript ion > 

</listheader> 

<item> 

<term>term</term> 

<description>description</description> 

</item> 

<item> 

<term>term</term> 

<description>description</description> 

</item> 

</list> 

where 

term 

The term to define, whose definition is in description, 

description 

Eifher an ifem in a bullef or numbered lisf, or fhe definition of a term. 

Example: 

public class MyClass 

{ 

III <summary>Here is an example of a bulleted list: 

III <llst type="bullet"> 

III <item> 

III <description>Item 1.</description> 

III </item> 

III <item> 

III <description>Item 2.</description> 

III </ltem> 

/// </list> 

III </summary> 

public static void Main () { 

II... 

} 

} 


> 


747 


www.it-ebooks.info 


Comments 




Do^m^athQBOtenments 


A. Documentation Comments 


A.2.7 <para> 

This tag is for use inside other tags, such as <summary> (§A.2.11) or <returns> (§A.2.12), 
and permits structure to be added to text. 

Syntax: 

<para>content</para> 

where 

content 

The text of the paragraph. 

Example: 

III <summary>This is the entry point of the Point class testing program. 

Ill <para>This program tests each method and operator, and 
III is intended to be run after any nontrivial maintenance has 
III been performed on the Point class.</para></summary> 
public static void Main() { 

H ... 

} 



A.2.8 <param> 

This tag is used to describe a parameter for a method, constructor, or indexer. 

Syntax: 

<param name="nome">description</param> 
where 
name 

The name of fhe parameter. 

description 

A description of the parameter. 

Example: 

III <summary>This method changes the point's location to 
III the given coordinates.</summary> 

III <param name="xor">the new x-coordinate.</param> 

III <param name="yor">the new y-coordinate.</param> 
public void Move(int xor, int yor) { 

X = xor; 

Y = yor; 

} 


748 


www.it-ebooks.info 



A.2 Recommended Tags 


A.2.9 <paramref> 

This tag is used to indicate that a word is a parameter. The documentation file can be pro¬ 
cessed to format this parameter in some distinct way. 

Syntax: 

<paramref name="name"/> 
where 
name 

The name of fhe parameter. 

Example: 

III <summary>This constructor initializes the new point to 
III (<paramref name="xor"/>,<paramref name="yor"/>)•</summary> 

III <pararr name="xor">the new point’s x-coordinate.</param> 

III <param name="yor">the new point’s y-coordinate.</param> 
public Point(int xor, int yor) { 

X = xor; 

Y = yor; 

} 

A.2.10 <permission> 

This tag allows the security accessibility of a member to be documented. 


> 


<permission cref="member">description<Ipermission> 
where 

cref="member" 

The name of a member. The documentation generator checks that the given code 
element exists and translates member to the canonical element name in the documen¬ 
tation file. 

description 

A description of the access to the member. 

Example: 

III <permission cref="System.Security.PermissionSet”>Everyone can 
III access this method.</permission> 
public static void Test() { 

H ... 

} 


749 


www.it-ebooks.info 


Comments 




Do^m^athQBOtenments 


A. Documentation Comments 


A.2.11 <remarl<> 

This tag is used to specify extra information about a t 5 ^e. (Use <summary> (§A.2.15) to 
describe the type itself and the members of a t 5 ^e.) 

Syntax: 

<remark>descriptior7</remark> 

where 

description 

The text of the remark. 

Example: 

III <summary>Class <c>Point</c> models a point in a 
III two-dimensional plane.</summary> 

III <remark>Uses polar coordinates</remark> 
public class Point 
{ 

n ... 

} 



A.2.12 <returns> 

This tag is used to describe the return value of a method. 

Syntax: 

<returns>description</returns> 

where 

description 

A description of the return value. 

Example: 

III <summary>Report a point's location as a string.</summary> 

III <returns>A string representing a point's location, in the form (x,y), 
III without any leading, trailing, or embedded whitespace.</returns> 
public override string ToStringO { 
return "(" + X + "," + Y + 

} 


750 


www.it-ebooks.info 



A.2 Recommended Tags 


A.2.13 <see> 

This tag allows a link to be specified within text. Use <seealso> (§A.2.14) to indicate text 
that is to appear in a See Also section. 

Syntax: 

<see cref="member"/> 
where 

cref-"member" 

The name of a member. The documenfafion generafor checks fhaf fhe given code 
elemenf exisfs and changes member fo fhe elemenf name in fhe generafed documenfa¬ 
fion file. 

Example: 

III <summary>This method changes the point's location to 
III the given coordinates.</summary> 

III <see cref="Translate"/> 
public void Move(int xor, int yor) { 

X = xor; 

Y = yor; 

} 

III <summary>This method changes the point's location by 
III the given x- and y-offsets. 

Ill </summary> 

III <see cref="Move"/> 

public void Translate(int xor^ int yor) { 

X += xor; 

Y += yor; 

} 

A.2.14 <seealso> 

This fag allows an entry to be generated for fhe See Also secfion. Use <see> (§A.2.13) fo 
specify a link from within text. 

Syntax: 

<seealso cref="member"!> 
where 

cref="member" 

The name of a member. The documenfafion generafor checks fhaf fhe given code 
elemenf exisfs and changes member fo fhe elemenf name in fhe generafed documenfa¬ 
fion file. 


> 


751 


www.it-ebooks.info 


Comments 




Do^m^athQBOtenments 


A. Documentation Comments 



Example: 

III <summary>This method determines whether two points have the same 
III location.</summary> 

III <seealso cref="operator=="/> 

III <seealso cref="operator!="/> 
public override bool Equals(object o) { 

H ... 

} 

A.2.15 <summary> 

This tag can be used to describe a type or a member of a type. Use <remark> (§A.2.11) to 
describe the type itself. 

Syntax: 

<summary>description</summary> 

where 

description 

A summary of the t 5 ^e or member. 

Example: 

III <summary>This constructor initializes the new point to (0^0).</summary> 
public PointO ; this(0j0) { 

} 

A.2.16 <value> 

This tag allows a property to be described. 

Syntax: 

<value>property description</value> 

where 

property description 

A description for the property. 

Example: 

III <value>Property <c>X</c> represents the point's x-coordinate.</value> 
public int X 
{ 

get { return x; } 
set { X = value; } 

} 


752 


www.it-ebooks.info 



A.2 Recommended Tags 


A.2.17 <typeparam> 

This tag is used to describe a generic t 5 ^e parameter for a class, struct, interface, delegate, 
or method. 

Syntax: 

<typeparam name=''name">clescription</typeparam> 
where 
name 

The name of fhe type parameter. 
description 

A description of the t 5 ^e parameter. 

Example: 

III <summary>A generic list class.</sumrrary> 

III <typeparam name="T">The type stored by the list.</typeparam> 
public class MyLlst<T> { 

} 

A.2.18 <typeparamref> 

This tag is used to indicate that a word is a t 5 ^e parameter. The documentation file can be 
processed to format this type parameter in some distinct way. 

Syntax: 

<typeparamref name="nome"/> 
where 
name 

The name of the t 5 ^e parameter. 

Example: 

III <summary>This method fetches data and returns a 
III list of <typeparamref name="T"> "/>"> .</summary> 

III <param name="string">query to execute</param> 

public List<T> FetchData<T>(string query) { 

} 


> 


753 


www.it-ebooks.info 


Comments 




Do^m^atiaB6tenments 


A. Documentation Comments 


A.3 Processing the Documentation File 

The documentation generator generates an ID string for each element in the source code 
that is tagged with a documentation comment. This ID string uniquely identifies a source 
elemenf. A documenfafion viewer can use an ID sfring fo idenfify fhe corresponding mefa- 
dafa or reflecfion ifem fo which fhe documenfafion applies. 

The documenfafion file is nof a hierarchical represenfafion of fhe source code; rafher, if is a 
flaf lisf wifh a generafed ID sfring for each elemenf. 

A.3.1 ID String Format 

The documenfafion generafor observes fhe following rules when if generafes fhe ID 
sfrings: 

• No while space is placed in fhe sfring. 

• The firsf parf of fhe sfring identifies fhe kind of member being documenfed, via a single 
characfer followed by a colon. The following fable lisfs fhe kinds of members defined. 


Character 

Description 

E 

Event 

F 

Field 

M 

Method (including constructors, destructors, and operators) 

N 

Namespace 

P 

Property (including indexers) 

T 

Type (such as class, delegate, enum, interface, and struct) 

! 

Error string; the rest of the string provides information about the 
error. For example, the documentation generator generates error infor¬ 
mation for links that cannot be resolved. 



• The second parf of fhe sfring is fhe fully qualified name of fhe elemenf, sfarfing af fhe 
roof of fhe namespace. The name of fhe elemenf, ifs enclosing fype(s), and namespace 
are separafed by periods. If fhe name of fhe ifem if self has periods, fhey are replaced by 
# (U+0023) characfers. (If is assumed fhaf no elemenf has fhis characfer in ifs name.) 


754 


www.it-ebooks.info 












A.3 Processing the Documentation File 


• For methods and properties with arguments, the argument list follows, enclosed in 
parentheses. For those without arguments, the parentheses are omitted. The arguments 
are separated by commas. The encoding of each argumenf is fhe same as a CLI signa- 
fure, as follows: 

- Argumenfs are represenfed by fheir documenfafion name, which is based on fheir 

fully qualified name, modified as follows: 

• Argumenfs fhaf represenf generic fypes have an appended characfer followed 
by fhe number of 1)^)0 paramefers. 

• Argumenfs having fhe out or ref modifier have an @ following fheir type name. 
Arguments passed by value or via pa rams have no special notation. 

• Arguments that are arrays are represented as [ loiverbound : size , , lowerbound : 

size ] where the number of commas is fhe rank less 1, and fhe lower bounds and size 
of each dimension, if known, are represenfed in decimal. If a lower bound or size is 
nof specified, if is omiffed. If fhe lower bound and size for a particular dimension 
are omiffed, fhe ":" is omiffed as well. Jagged arrays are represenfed by one " [ ]" 
per level. 

• Argumenfs fhaf have poinfer f 5 q)es ofher fhan void are represenfed using a * fol¬ 
lowing fhe type name. A void pointer is represented using a type name of 
System.Void. 

• Argumenfs fhaf refer fo generic type parameters defined on f 5 q)es are encoded 
using fhe characfer followed by fhe zero-based index of fhe type parameter. 

• Arguments that use generic type parameters defined in mefhods use a double- 
backfick """ insfead of fhe used for fypes. 

• Argumenfs fhaf refer fo consfrucfed generic fypes are encoded using fhe generic 
fype, followed by "{", followed by a comma-separafed lisf of fype argumenfs, 
followed by "}". 

A.3.2 ID String Examples 

The following examples each show a fragmenf of C# code, along wifh fhe ID sfring pro¬ 
duced from each source elemenf capable of having a documenfafion commenf: 

• Types are represenfed using fheir fully qualified name, augmenfed wifh generic 
informafion: 

enum Color { Red, Blue, Green } 
namespace Acme 
{ 

interface IProcess {...} 
struct ValueType {...} 


> 


755 


www.it-ebooks.info 


Comments 




Do^m^athQBOtenments 


A. Documentation Comments 



class Widget: IProcess 

{ 

public class NestedClass {...} 

public interface IMenuItem {...} 

public delegate void Del(int i); 

public enurr Direction { North, South, East, West } 

} 

class MyLlst<T> 

{ 

class Helper<U,V> {...} 

} 

} 

"T:Color" 

"T:Acme.IProcess" 

"TlAcme.ValueType" 

"T:Acme.Widget" 

"T:Acme.Widget.NestedClass" 

"T:Acme.Widget.IMenuItem" 

"T:Acme.Widget.Del" 

"T:Acme.Widget.Direction" 

"TlAcme.MyList'1" 

"TlAcme.MyList'1.Helper'2" 

Fields are represented by their fully qualified name: 

namespace Acme 

{ 

struct ValueType 

{ 

private int total; 

} 

class Widget: IProcess 

{ 

public class NestedClass 

{ 

private int value; 

} 

private string message; 
private static Color defaultColor; 
private const double PI = 3.14159; 
protected readonly double monthlyAverage; 
private long[] arrayl; 
private Widget[,] array2; 
private unsafe int *pCount; 
private unsafe float **ppValues; 

} 

} 


756 


www.it-ebooks.info 



A.3 Processing the Documentation File 


"F:Acme.ValueType.total" 

"F:Acme.Widget.NestedClass.value" 

"F:Acme.Widget.message" 

"F:Acme.Widget.defaultColor" 

"F:Acme.Widget.PI" 

"F:Acme.Widget.monthlyAverage" 

"F:Acme.Widget.arrayl" 

"F:Acme.Widget.array2" 

"F:Acme.Widget.pCount" 

"F:Acme.Widget.ppValues" 

• Constructors, 
namespace Acme 
{ 

class Widget: IProcess 

{ 

static WidgetO {...} 
public WidgetO {•••} 
public Widget(string s) {...} 

} 

} 

"M:Acme.Widget.Sector" 

"M:Acme.Widget.#ctor" 

"M:Acme.Widget.#ctor(System.String)" 

• Destructors, 
namespace Acme 
{ 

class Widget: IProcess 

{ 

-WidgetO {•••} 

} 

} 

"M:Acme.Widget.Finalize" 

• Methods. 

namespace Acme 

{ 

struct ValueType 

{ 

public void M(int i) {...} 

} 

class Widget: IProcess 

{ 

public class NestedClass 

{ 

public void M(int i) {...} 

} 


> 


757 


www.it-ebooks.info 


Comments 




Do^m^athQBOtenments 


A. Documentation Comments 



public static void M0() {...} 

public void Ml(char c, out float fj ref ValueType v) {...} 
public void M2(short[] xlj int[j] x2j long[][] x3) {...} 
public void M3(long[][] x3, Widget[][j,] x4) {...} 
public unsafe void M4(char *pc. Color **pf) {...} 
public unsafe void M5(void *pv, double *[][j] pd) 
public void M6(int i, params object[] args) {...} 

} 

class MyLlst<T> 

{ 

public void Test(T t) { } 

} 

class UseList 

{ 

public void Process(MyList<int> list) { } 

public MyList<T> GetValues<T>(T inputValue) { return null; } 

} 

} 

"M:Acme.ValueType.M(System.Int32)" 

"M:Acme.Widget.NestedClass.M(System.Int32)" 

"M:Acme.Widget.M0" 

"M:Acme.Widget.Ml(SyStem.ChatjSyStem.Single@,Acme.ValueType@)" 

"M:Acme.Widget.M2(System.Intl6[]^System.Int32[0:,0:]^System.Int64[][]) 
"M:Acme.Widget.M3(System.Int64[][]jAcme.Widget[0:,0:,0:][])" 

"M:Acme.Widget.M4(System.Char* j Color**)" 

"M:Acme.Widget.MS(System.Void*jSystem.Double*[0:j0:][])" 

"M:Acme.Widget.M6(System.Int32,System.Object[])" 

"M:Acme.MyList'l.Test('0)" 

"M:Acme.UseList.Process(Acme.MyListjSystem.Int32})" 

"M:Acme.UseList .GetValues'' (" 0)" 

Properties and indexers, 
namespace Acme 
{ 

class Widget: IProcess 

{ 

public int Width { get {...} set {...} } 

public int this[int i] { get {...} set {...} } 

public int this[string s, int i] { get {...} set {...} } 

} 


"P:Acme.Widget.Width" 

"P:Acme.Widget.Item(System.Int32)" 

"P:Acme.Widget.Item(System.String,System.Int32) 

• Events. 

namespace Acme 

{ 

class Widget: IProcess 

{ 


758 


www.it-ebooks.info 



A.3 Processing the Documentation File 


public event Del AnEvent; 

} 

} 

"E:Acme.Widget.AnEvent" 

• Unary operators. 

namespace Acme 

{ 

class Widget: IProcess 

{ 

public static Widget operator+(Widget x) {...} 

} 

} 

"M: Acme. Widget. op_Unary Plus (Acme. Widget)" 

The complete set of unary operator function names used is as follows: op_UnaryPlus, 
op_UnaryNegation, op_LogicalNot, op_OnesComplement, op_Increment, op_Decrement, 
op_True, and op_False. 

• Binary operators. 

namespace Acme 

{ 

class Widget: IProcess 

{ 

public static Widget operator+(Widget xl. Widget x2) {...} 

} 


> 


"M: Acme. Widget. op_Addit ion (Acme. Widget j Acme. Widget)" 

The complete set of binary operator function names used is as follows: op_Addition, 
op_Subtraction, op_Multiply,op_Division, op_Modulus, op_BitwiseAnd, op_BitwiseOr, 
op_ExclusiveOr, op_LeftShift, op_RightShift, op_Equality, op_Inequality, 
op_LessThan, op_LessThanOrEqual, op_GreaterThan, and op_GreaterThanOrEqual. 

• Conversion operators have a trailing followed by the return type. 

namespace Acme 

{ 

class Widget: IProcess 

{ 

public static explicit operator int(Widget x) {...} 
public static implicit operator long(Widget x) {...} 

} 

} 

"M:Acme.Widget.op_Explicit(Acme.Widget)~System. Int32" 

"M:Acme.Widget.op_Implicit(Acme.Widget)~System.Int64" 


759 


www.it-ebooks.info 


Comments 




Do^m^athaeOtenments 


A. Documentation Comments 


A.4 An Example 

A.4.1 C# Source Code 

The following example shows the source code of a Point class: 

namespace Graphics 

{ 



III <summary>Class <c>Point</c> models a point in a two-dimensional plane. 

Ill </summary> 
public class Point 
{ 

III <summary>Instance variable <c>x</c> represents the point’s 
III x-coordinate.</summary> 
private int x; 

III <summary>Instance variable <c>y</c> represents the point's 
III y-coordinate.</summary> 
private int y; 

III <value>Property <c>X</c> represents the point's x-coordinate.</value> 
public int X 
{ 

get { return x; } 
set { X = value; } 

} 

III <value>Property <c>Y</c> represents the point's y-coordinate.</value> 
public int Y 
{ 

get { return y; } 
set { y = value; } 

} 

III <summary>This constructor initializes the new point to 

III (0J0).</summary> 

public Point() : this(0j 0) { } 

III <summary>This constructor initializes the new point to 
III (<paramref name="xor"/>^<paramref name="yor"/>).</summary> 

III <param><c>xor</c> is the new point's x-coordinate.</param> 

III <param><c>yor</c> is the new point's y-coordinate.</param> 
public Point(int xor, int yor) 

{ 

X = xor; 

Y = yor; 

} 

III <summary>This method changes the point’s location to 
III the given coordinates.</summary> 

III <param><c>xor</c> is the new x-coordinate.</param> 

III <param><c>yor</c> is the new y-coordinate.</param> 

III <see cref="Translate"/> 
public void Move(lnt xor, int yor) 

{ 

X = xor; 

Y = yor; 

} 


760 


www.it-ebooks.info 



A.4 An Example 


III <summary>This method changes the point’s location by 
III the given x- and y-offsets. 

Ill <example>For example: 

III <code> 

III Point p = new Point(3,5); 

III p.Translate(-lj3); 

III </code> 

III results in <c>p</c>'s having the value (2^8). 

Ill </example> 

III </summary> 

III <param><c>xor</c> is the relative x-offset.</param> 

III <param><c>yor</c> is the relative y-offset.</param> 

III <see cref="Move"/> 

public void Translate(int xor, int yor) 

{ 

X += xor; 

Y += yor; 

} 

III <summary>This method determines whether two points have the same 
III location.</summary> 

III <param><c>o</c> is the object to be compared to the current object. 
Ill </param> 

III <returns>True if the points have the same location and they have 
III the exact same type; otherwisej false.</returns> 

III cseealso cref="operator=="/> 

III <seealso cref="operator!="/> 
public override bool Equals(object o) 

{ 

if (o == null) 

{ 


> 


if (this == o) 

{ 

return true; 

} 

if (GetTypeO == o.GetTypeO) 

{ 

Point p = (Point)o; 

return (X == p.X) && (Y == p.Y); 

} 

return false; 

} 

III <summary>Report a point’s location as a string.</summary> 

III <returns>A string representing a point’s location, in the form (x,y), 
III without any leading, trailing, or embedded whitespace.</returns> 
public override string ToString() 

{ 

return "(" + X + "," + Y + ")"; 

} 

III <summary>This operator determines whether two points have the same 
III location.</summary> 

III <param><c>pl</c> is the first point to be compared.</param> 


761 


www.it-ebooks.info 


Comments 




Do^m^athQBOtenments 


A. Documentation Comments 



III <param><c>p2</c> is the second point to be compared.</param> 

III <returns>True if the points have the same location and they have 
III the exact same type; otherwisej false.</returns> 

III <seealso cref="Equals"/> 

III <seealso cref="operator!="/> 

public static bool operator ==(Point pi. Point p2) 

{ 

if ((object)pl == null || (object)p2 == null) 

{ 

return false; 

} 

if (pl.GetTypeO == p2.GetType()) 

{ 

return (pl.X == p2.X) && (pl.Y == p2.Y); 

} 

return false; 

} 

III <summary>This operator determines whether two points have the same 
III location.</summary> 

III <param><c>pl</c> is the first point to be compared.</param> 

III <param><c>p2</c> is the second point to be compared.</param> 

III <returns>True if the points do not have the same location and the 
III exact same type; otherwise, false.</returns> 

III <seealso cref="Equals"/> 

III <seealso cref="operator=="/> 

public static bool operator !=(Point pi. Point p2) 

{ 

return !(pi == p2); 

} 

III <summary>This is the entry point of the Point class testing 
III program. 

Ill <para>This program tests each method and operator, and 
III is intended to be run after any nontrivial maintenance has 
III been performed on the Point class.</para></summary> 
public static void Main() 

{ 

// Class test code goes here 

} 

} 

} 

A.4.2 Resulting XML 

Here is the output produced by one documentation generator when given the source code 
for class Point, shown above: 

<?xml version="1.0"?> 

<doc> 

<assembly> 

<name>Point</name> 

</assembly> 


762 


www.it-ebooks.info 



A.4 An Example 


<members> 

<member name="T:Graphics.Point"> 

<summary> 

Class <c>Point</c> models a point in a two-dimensional 
plane. 

</summary> 

</member> 

<member name="F:Graphics.Point.x"> 

<summary> 

Instance variable <c>x</c> represents the point's 
x-coordinate. 

</summary> 

</member> 

<member name="F:Graphics.Point.y"> 

<summary> 

Instance variable <c>y</c> represents the point's 
y-coordinate. 

</summary> 

</member> 

<member name="M:Graphics.Point.#ctor"> 

<summary> 

This constructor initializes the new point to 

( 0 , 0 ). 


</summary> 

</member> 

<member name="M:Graphics.Point.#ctor(System.Int32,System.Int32)"> 
<summary> 

This constructor initializes the new point to 

(<paramref name="xor"/>,<paramref name="yor"/>). 

</summary> 

<param> 

<c>xor</c> is the new point's x-coordinate. 

</param> 

<param> 

<c>yor</c> is the new point's y-coordinate. 

</param> 

</member> 

<member name="M:Graphics.Point.Move(System.Int32,System.Int32)"> 
<summary> 

This method changes the point's location to 

the given coordinates. 

</summary> 

<param> 

<c>xor</c> is the new x-coordinate. 

</param> 

<param> 

<c>yor</c> is the new y-coordinate. 

</param> 

<see cref="M:Graphics.Point.Translate(System.Int32,System.Int32)"/> 
</member> 


> 


763 


www.it-ebooks.info 


Comments 




Do^m^athQBOtenments 


A. Documentation Comments 



<member 

name="M;Graphics.Point.Translate(System.Int32jSystem.Int32)"> 
<summary> 

This method changes the point's location by 
the given x- and y-offsets. 

<example> 

For example; 

<code> 

Point p = new Point(3j5); 
p.Translate(-lj3); 

</code> 

results in <c>p</c>'s having the value (2,8). 

</example> 

</summary> 

<param> 

<c>xor</c> is the relative x-offset. 

</param> 

<param> 

<c>yor</c> is the relative y-offset. 

</param> 

<see cref="M:Graphics.Point.Move(System.Int32,System.Int32)"/> 
</member> 

<member name="M:Graphics.Point.Equals(System.Object)"> 

<summary> 

This method determines whether two points have the same 
location. 

</summary> 

<param> 

<c>o</c> is the object to be compared to the current 
object. 

</param> 

<returns> 

True if the points have the same location and they have 
the exact same type; otherwise, false. 

</returns> 

<seealso 

cref="M:Graphics.Point.op_Equality(Graphics.Point,Graphics.Point)"/> 
<seealso 

cref="M:Graphics.Point.op_Inequality(Graphics.Point,Graphics.Point)"/> 
</member> 

<member name="M:Graphics.Point.ToString"> 

<summary>Report a point’s location as a string.</summary> 
<returns> 

A string representing a point's location, in the form 

(x.y). 

without any leading, trailing, or embedded whitespace. 
</returns> 

</member> 

<member 

name="M:Graphlcs.Point.op_Equallty(Graphics.Point,Graphlcs.Point)"> 
<summary> 

This operator determines whether two points have the 
same 

location. 


764 


www.it-ebooks.info 



A.4 An Example 


</summary> 

<param> 

<c>pl</c> is the first point to be compared. 

</param> 

<param> 

<c>p2</c> is the second point to be compared. 

</param> 

<returns> 

True if the points have the same location and they have 

the exact same type; otherwisej false. 

</returns> 

<seealso cref="M:Graphics.Point.Equals(System.Object)"/> 

<seealso 

cref="M:Graphics.Point.op_Inequality(Graphics.Point,Graphics.Point)"/> 
</member> 

<member 

name="M:Graphics.Point.op_Inequality(Graphics.Point,Graphics.Point)"> 
<summary> 

This operator determines whether two points have the 

same 

location. 

</summary> 

<param> 

<c>pl</c> is the first point to be compared. 

</param> 

<param> 

<c>p2</c> is the second point to be compared. 

</param> 

<returns> 

True if the points do not have the same location and 


> 


exact same type; otherwise, false. 

</returns> 

<seealso cref="M:Graphics.Point.Equals(System.Object)"/> 
cseealso 

cref="M:Graphics.Point.op_Equality(Graphics.Point, Graphics.Point)"/> 
</member> 

<member name="M:Graphics.Point.Main"> 

<summary> 

This is the entry point of the Point class testing 
program. 

<para> 

This program tests each method and operator, and 
is intended to be run after any nontrivial maintenance has 
been performed on the Point class. 

</para> 

</summary> 

</member> 

<member name="P:Graphics.Point.X"> 

<value> 

Property <c>X</c> represents the point's 
x-coordinate. 

</value> 

</member> 


765 


www.it-ebooks.info 


Comments 




Do^m^atiaB6tenments 


A. Documentation Comments 


<member name="P:Graphics.Point.Y"> 

<value> 

Property <c>Y</c> represents the point's 
y-coordinate. 

</value> 

</member> 

</members> 

</doc> 



766 


www.it-ebooks.info 




B. Grammar 


This appendix contains summaries of the lexical and syntactic grammars found in the 
main document, and of fhe grammar exfensions for unsafe code. Grammar productions 
appear here in fhe same order fhat they appear in the main document. 


B.l Lexical Grammar 

input: 

input-section^ 

input-section: 

input-section-part 
input-section input-section-part 

input-section-part: 

input-elementsnew-line 
pp-directive 

input-elements: 

input-element 

input-elements input-element 

input-element: 

whitespace 

comment 

token 

B.1.1 Line Terminators 

new-line: 

Carriage return character (U+000D) 

Line feed character (U+000A) 

Carriage return character (U+000D) followed by line feed character (U+000A) 
Next line character (U+0085) 

Line separator character (U+2028) 

Paragraph separator character (U+2029) 


767 


www.it-ebooks.info 




Grammar 


B. Grammar 


B.1.2 Comments 

comment: 

single-line-comment 

delimited-comment 

single-line-comment: 

II input-characters^^ 

input-characters: 

input-character 

input-characters input-character 
input-character: 

Any Unicode character except a new-line-character 

new-line-character: 

Carriage return character (U+000D) 

Line feed character (U+000A) 

Next line character (U+0085) 

Line separator character (U+2028) 

Paragraph separator character (U+2029) 

delimited-comment: 

!* delimited-comment-text , asterisks / 

delimited-comment-text: 

delimited-comment-section 

delimited-comment-text delimited-comment-section 

delimited-comment-section: 

I 

asterisks , not-slash-or-asterisk 

opt 

asterisks: 

* 

asterisks * 

not-slash-or-asterisk: 

Any Unicode character except / or * 


768 


www.it-ebooks.info 




B.l Lexical Grammar 


B.1.3 White Space 

whitespace: 

Any character with Unicode class Zs 
Horizontal tab character (U+0009) 
Vertical tab character (U+000B) 

Form feed character (U+000C) 


B.1.4 Tokens 

token: 

identifier 

keyword 

integer-literal 

real-literal 

character-literal 

string-literal 

operator-or-punctuator 


B.l. 5 Unicode Character Escape Sequences 

unicode-escape-sequence: 

\u hex-digit hex-digit hex-digit hex-digit 

\L) hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit hex-digit 

B.1.6 Identifiers 

identifier: 

available-identifier 
@ identifier-or-keyword 

available-identifier: 

An identifier-or-keyword that is not a keyword 
iden tifier-or-keyword: 

identifier-start-character identifier-part-characters 

identifier-start-character: 

letter-character 

_ (the underscore character U+005F) 

identifier-part-characters: 

identifier-part-character 

identifier-part-characters identifier-part-character 


DO 


769 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


identifier-part-character: 

letter-character 

decimal-digit-character 

connecting-character 

combining-character 

formatting-character 

letter-character: 

A Unicode character of classes Lu, LI, Lt, Lm, Lo, or N1 

A unicode-escape-sequence representing a character of classes Lu, LI, Lt, Lm, Lo, or N1 
combining-character: 

A Unicode character of classes Mn or Me 

A unicode-escape-sequence representing a character of class Mn or Me 

decimal-digit-character: 

A Unicode character of the class Nd 

A unicode-escape-sequence representing a character of the class Nd 

connecting-character: 

A Unicode character of the class Pc 

A unicode-escape-sequence representing a character of the class Pc 

formatting-character: 

A Unicode character of the class Cf 

A unicode-escape-sequence representing a character of the class Cf 

B.1.7 Keywords 

keyword: one of 


abstract 

as 

base 

bool 

break 

byte 

case 

catch 

char 

checked 

class 

const 

continue 

decimal 

default 

delegate 

do 

double 

else 

enum 

event 

explicit 

extern 

false 

finally 

fixed 

float 

for 

foreach 

goto 

if 

implicit 

in 

int 

interface 

internal 

is 

lock 

long 

namespace 

new 

null 

object 

operator 

out 

override 

params 

private 

protected 

public 

readonly 

ref 

return 

sbyte 

sealed 

short 

sizeof 

stackalloc 

static 

string 

struct 

switch 

this 

throw 

true 

try 

typeof 

uint 

ulong 

unchecked 

unsafe 

ushort 

using 

virtual 

void 

volatile 

while 





www.it-ebooks.info 




B.l Lexical Grammar 


B.1.8 Literals 

literal: 

boolean-literal 

integer-literal 

real-literal 

character-literal 

string-literal 

null-literal 

boolean-literal: 

true 

false 

integer-literal: 

decimal-integer-literal 

hexadecimal-integer-literal 

decimal-integer-literal: 

decimal-digits integer-type-suffix 

decimal-digits: 

decimal-digit 

decimal-digits decimal-digit 

decimal-digit: one of 

0123456789 

integer-type-suffix: one of 

U u L 1 UL U1 uL ul LU Lu lU lu 

hexadecimal-integer-literal: 

0x hex-digits integer-type-suffix 
0X hex-digits integer-type-suffix 

hex-digits: 

hex-digit 

hex-digits hex-digit 
hex-digit: one of 

0123456789ABCDEFabcdef 


DO 


771 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


OQ 


real-literal: 

decimal-digits . decimal-digits exponent-partreal-type-sujfix^^ 

. decimal-digits exponent-partreal-type-suffix 
decimal-digits exponent-part real-type-suffix 
decimal-digits real-type-suffix 

exponent-part: 

e sign^^ decimal-digits 
E sign^^ decimal-digits 

sign: one of 

+ 

real-type-suffix: one of 
F f D d M m 

character-literal: 

' character ' 

character: 

single-character 

simple-escape-sequence 

hexadecimal-escape-sequence 

unicode-escape-sequence 

single-character: 

Any character except ' (U+0027), \ (U+00SC), and neiv-line-character 

simple-escape-sequence: one of 

V V \\ \0 \a \b \f \n \r \t \v 

hexadecimal-escape-sequence: 

\x hex-digit hex-digit^^ hex-digit^^ hex-digit^^ 

string-literal: 

regular-string-literal 

verbatim-string-literal 

regular-string-literal: 

" regular-string-literal-characters^^ " 

regular-string-literal-characters: 

regular-string-literal-character 

regular-string-literal-characters regular-string-literal-character 


772 


www.it-ebooks.info 




B.l Lexical Grammar 


regular-strmg-literal-character: 

single-regular-string-literal-character 

simple-escape-sequence 

hexadecimal-escape-sequence 

unicode-escape-sequence 

single-regular-string-literal-character: 

Any character except" (U+0022)j \ {U+00SC), and new-line-character 

verbatim-string-literal: 

verbatim-string-literal-characters^^ " 

verbatim-string-literal-characters: 

verbatim-string-literal-character 

verbatim-string-literal-characters verbatim-string-literal-character 

verbatim-string-literal-character: 

single-verbatim-string-literal-character 

quote-escape-sequence 

single-verbatim-string-literal-character: 

Any character except" 

quote-escape-sequence: 


null-literal: 

null 


& I ^ ! ~ 

I : ++ — && I I 

+= -= *= /= %= 

= > 

right-shift: 

>l> 

right-shift-assignment: 

>l>= 


B.1.9 Operators and Punctuators 


operator-or-punctuator: 

one of 


{ 

} 

[ 

] 

( 

+ 

- 

* 

/ 

% 

= 

< 

> 

? 

?? 

-> 

== 

! = 

<= 

>= 

&= 

1 = 

A_ 

<< 

<< 


DO 


773 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


OQ 


B.1.10 Preprocessing Directives 

pp-directive: 

pp-declaration 

pp-conditional 

pp-line 

pp-diagnostic 

pp-region 

pp-pragma 


conditional-symbol: 

Any identifier-or-keyivord except true or false 


pp-expression: 

whitespace^^ pp-or-expression whitespace^^ 


pp-or-expression: 

pp-and-expression 

pp-or-expression whitespace\ \ ivhitespace^^ pp-and-expression 


pp-and-expression: 

pp-equality-expression 

pp-and-expression ivhitespace^i && whitespace^^^ pp-equality-expression 


pp-equality-expression: 
pp-unary-expression 
pp-equality-expression whitespace^^ 
pp-equality-expression whitespace^^ 


== whitespace^^^ pp-unary-expression 
! = ivhitespace^^ pp-unary-expression 


pp-unary-expression: 

pp-primary-expression 
! ivhitespace^i pp-unary-expression 


pp-primary-expression: 

true 

false 

conditional-symbol 

( whitespace^^i pp-expression whitespace^^ ) 


pp-declaration: 

whitespace^^ 

whitespace^^ 


# whitespace 

# whitespace 


define whitespace conditional-symbol pp-new-line 
undef whitespace conditional-symbol pp-new-line 


774 


www.it-ebooks.info 




B.l Lexical Grammar 


pp-new-line: 

whitespace^^ single-line-comment^^ new-line 
pp-conditional: 

pp-if-section pp-elif-sections^^ pp-else-section^^^ pp-endif 
pp-if-section: 

whitespace^^ # whitespace^^ if whitespace pp-expression pp-new-line 
conditional-section , 

opt 

pp-elif-sections: 

pp-elif-section 

pp-elif-sections pp-elif-section 


pp-elif-section: 

whitespace^^ # whitespace^^ elif whitespace pp-expression pp-new-line 
conditional-section , 

opt 

pp-else-section: 

whitespace^^ # whitespace^^ else pp-new-line conditional-section 
pp-endif: 

whitespace^^ # whitespace^^ endif pp-new-line 


conditional-section: 

input-section 

skipped-section 


skipped-section: 

skipped-section-part 
skipped-section skipped-section-part 


skipped-section-part: 

skipped-characters^^ new-line 
pp-directive 


skipped-characters: 

ivhitespace^^ not-number-sign input-characters^^ 

not-number-sign: 

Any input-character except # 


pa 


775 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


pp-diagnostic: 

whitespace^^ # whitespace^^ error pp-message 
whitespace^^ # whitespace^^ warning pp-message 

pp-message: 

new-line 

whitespace input-charactersnew-line 


pp-region: 

pp-start-region conditional-section^^^ pp-end-region 
pp-start-region: 

whitespace^^ # whitespace^^ region pp-message 


pp-end-region: 

whitespace^^ # 


whitespace^^^ end region pp-message 


pp-line: 

whitespace^^ # 


whitespace^^^ 


line whitespace line-indicator pp-new-line 


line-indicator: 

decimal-digits whitespace file-name 

decimal-digits 

default 

hidden 


OQ 


file-name: 

" file-name-characters " 

file-name-characters: 

file-name-character 

file-name-characters file-name-character 

file-name-character: 

Any input-character except " 

pp-pragma: 

ivhitespace^^ # ivhitespace^^ pragma whitespace pragma-body pp-new-line 

pragma-body: 

pragma-warning-body 

pragma-warning-body: 

warning whitespace warning-action 

warning whitespace warning-action whitespace warning-list 


776 


www.it-ebooks.info 




B.2 Syntactic Grammar 


warning-action: 

disable 

restore 

warning-list: 

decimal-digits 

warning-list whitespace^^ , whitespace^^ decimal-digits 


B.2 Syntactic Grammar 

B.2.1 Basic Concepts 

namespace-name: 

namespace-or-type-name 

type-name: 

namespace-or-type-name 

namespace-or-type-name: 

identifier type-argument-list 

namespace-or-type-name . identifier type-argument-list 
qualified-alias-member 

B.2.2 Types 

type: 

value-type 

reference-type 

type-parameter 

value-type: 

struct-type 

enum-type 

struct-type: 

type-name 

simple-type 

nullable-type 

simple-type: 

numeric-type 

bool 


DO 


in 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


yiumeric-type: 

integral-type 

floating-point-type 

decimal 

integral-type: 

sbyte 

byte 

short 

ushort 

int 

uint 

long 

ulong 

char 

floating-point-type: 

float 

double 

nullable-type: 

non-nullable-value-type ? 

non-nullable-value-type: 

type 

enum-type: 

type-name 

reference-type: 

class-type 

interface-type 

array-type 

delegate-type 

class-type: 

type-name 

object 

dynamic 

string 

interface-type: 

type-name 


778 


www.it-ebooks.info 




B.2 Syntactic Grammar 


array-type: 

non-array-type rank-specifiers 

non-array-type: 

type 

rank-specifiers: 

rank-specifier 

rank-specifiers rank-specifier 

rank-specifier: 

[ dim-separators^^ ] 

dim-separators: 

3 

dim-separators , 

delegate-type: 

type-name 

type-argument-list: 

< type-arguments > 

type-arguments: 

type-argument 

type-arguments , type-argument 

type-argument: 

type 

type-parameter: 

identifier 

B.2.3 Variables 

variable-reference: 

expression 


B.2.4 Expressions 

argument-list: 

argument 

argument-list , argument 


DO 


779 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


OQ 


argument: 

argument-nameargument-value 

argument-name: 
identifier : 

argument-value: 

expression 

ref variable-reference 
out variable-reference 


primary-expression: 

primary-no-array-creation-expression 

array-creation-expression 

primary-no-array-creation-expression: 

literal 

simple-name 

parenthesized-expression 

member-access 

invocation-expression 

element-access 

this-access 

base-access 

post-increment-expression 

post-decrement-expression 

object-creation-expression 

delegate-creation-expression 

anonymous-object-creation-expression 

typeof-express ion 

checked-expression 

unchecked-express ion 

default-value-expression 

anonymous-method-expression 


simple-name: 

identifier type-argument-list 


parenthesized-expression: 
( expression ) 


780 


www.it-ebooks.info 




B.2 Syntactic Grammar 


member-access: 

primary-expression . identifier type-argument-list 
predefined-type . identifier type-argument-list 
qualified-alias-member . identifier type-argument-list 


predefined-type: one of 
bool byte 

object sbyte 


char decimal 

short string 


double float 
uint ulong 


int long 

ushort 


invocation-expression: 

primary-expression ( argument-list ) 


element-access: 

primary-no-array-creation-expression [ argument-list ] 


this-access: 

this 

base-access: 

base . identifier 
base [ argument-list ] 


post-increment-expression: 
primary-expression ++ 


post-decrement-expression: 
primary-expression - - 


object-creation-expression: 

new type ( argument-list^ ) object-or-collection-initializer^ 
new type object-or-collection-initializer 


object-or-collection-initializer: 

object-initializer 

collection-initializer 

object-initializer: 

{ member-initializer-list , } 

{ member-initializer-list , } 

member-initializer-list: 

member-initializer 

member-initializer-list , member-initializer 


DO 


781 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


OQ 


member-initializer: 

identifier - initializer-value 

initializer-value: 

expression 

object-or-collection-initializer 

collection-initializer: 

{ element-initializer-list } 

{ element-initializer-list , } 

element-initializer-list: 

element-initializer 

element-initializer-list , element-initializer 

element-initializer: 

non-assignment-expression 
{ expression-list } 

expression-list: 

expression 

expression-list , expression 
array-creation-expression: 

new non-array-type [ expression-list ] rank-specifiers^^ 
new array-type array-initializer 
new rank-specifier array-initializer 

delegate-creation-expression: 

new delegate-type ( expression ) 

anonymous-object-creation-expression: 
new anonymous-object-initializer 

anonymous-object-initializer: 

{ member-declarator-list , } 

{ member-declarator-list , } 

member-declarator-list: 

member-declarator 

member-declarator-list , member-declarator 


782 


array-in itial izer^^^ 


www.it-ebooks.info 




B.2 Syntactic Grammar 


member-declarator: 

simple-name 

member-access 

base-access 

identifier - expression 

typeof-expression: 

typeof ( type ) 

typeof ( unbound-type-name ) 

typeof ( void ) 

unbound-type-name: 

identifier generic-dimension-specifier 

identifier :: identifier generic-dimension-specifier 

unbound-type-name . identifier generic-dimension-specifier 

generic-dimension-specifier: 

< commas , > 

Opt 

commas: 

3 

commas , 

checked-expression: 

checked ( expression ) 

unchecked-expression: 

unchecked ( expression ) 

default-value-expression: 
default ( type ) 

unary-expression: 

primary-expression 
+ unary-expression 
- unary-expression 
! unary-expression 
~ unary-expression 
pre-increment-expression 
pre-decrement-expression 
cast-expression 


DO 


783 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


OQ 


pre-increment-expression: 

++ unary-expression 

pre-decrement-expression: 

- - unary-expression 

cast-expression: 

( type ) unary-expression 

multiplicative-expression: 

unary-expression 

multiplicative-expression * unary-expression 
multiplicative-expression / unary-expression 
multiplicative-expression % unary-expression 

additive-expression: 

multiplicative-expression 

additive-expression + multiplicative-expression 
additive-expression - multiplicative-expression 

shift-expression: 

additive-expression 

shift-expression « additive-expression 
shift-expression right-shift additive-expression 


relational-expression: 


shift-expression 

relational-expression 

< 

shift-expression 

relational-expression 

> 

shift-expression 

relational-expression 

< = 

shift-expression 

relational-expression 

> = 

shift-expression 

relational-expression 

is 

type 

relational-expression 

as 

type 

equality-expression: 



relational-expression 
equality-expression ■ 

== 

relational-expression 

equality-expression 

1 = 

relational-expression 


and-expression: 

equality-expression 

and-expression & equality-expression 


784 


www.it-ebooks.info 




B.2 Syntactic Grammar 


exdusive-or-expression: 

and-expression 

exdusive-or-expression and-expression 

indusive-or-expression: 

exdusive-or-expression 

indusive-or-expression \ exdusive-or-expression 

conditionai-and-expression: 
indus ive-or-express ion 

conditionai-and-expression && indusive-or-expression 


conditionai-or-expression: 

conditionai-and-expression 

conditionai-or-expression \ \ conditionai-and-expression 

nuii-coaiescing-expression: 

conditionai-or-expression 

conditionai-or-expression ?? nuii-coaiescing-expression 


conditionai-expression: 

nuii-coaiescing-expression 

nuii-coaiescing-expression ? expression : expression 


iambda-expression: 

anonymous-function-signature => anonymous-function-body 


anonymous-method-expression: 

delegate expiicit-anonymous-function-signature^^ Mock 

anonymous-function-signature: 

expiicit-anonymous-function-signature 

impiicit-anonymous-function-signature 

expiicit-anonymous-function-signature: 

( expiicit-anonymous-function-parameter-iist^^ ) 

expiicit-anonymous-function-parameter-iist: 

expiicit-anonymous-function-parameter 

expiicit-anonymous-function-parameter-iist , expiicit-anonymous-function-parameter 

expiicit-anonymous-function-parameter: 

anonymous-function-parameter-modifier^^ type identifier 


DO 


785 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


anonymous-function-parameter-modifier: 

ref 

out 

implicit-anonymous-function-signature: 

( implicit-anonymous-function-parameter-list^ ) 
implicit-anonymous-function-parameter 

implicit-anonymous-function-parameter-list: 
implicit-anonymous-function-parameter 
implicit-anonymous-function-parameter-list , 
implicit-anonymous-function-parameter 

implicit-anonymous-function-parameter: 

identifier 

anonymous-function-body: 

expression 

block 

query-expression: 

from-clause query-body 

from-clause: 

from type^^^i identifier in expression 
query-body: 

query-body-clauses^i select-or-group-clause query-continuation^^ 

query-body-clauses: 

query-body-clause 

query-body-clauses query-body-clause 

query-body-clause: 

from-clause 

I let-clause 

where-clause 

join-clause 

join-into-clause 

orderby-clause 

let-clause: 

let identifier = expression 
where-clause: 

where boolean-expression 
join-clause: 

join type ^ identifier in expression on expression equals expression 

786 


www.it-ebooks.info 




B.2 Syntactic Grammar 


join-into-clause: 

join type^^i identifier in expression on expression equals expression 
into identifier 

orderby-clause: 

orderby orderings 

orderings: 

ordering 

orderings , ordering 
ordering: 

expression ordering-direction^^ 

ordering-direction: 

ascending 

descending 

select-or-group-clause: 

select-clause 

group-clause 

select-clause: 

select expression 

group-clause: 

group expression by expression 

query-continuation: 

into identifier query-body 

assignment: 

unary-expression assignment-operator expression 
assignment-operator: 

+= 

*- 


DO 


/ = 

%= 

1 = 

A_ 

<< = 

right-shift-ass ign ment 


787 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


expression: 

non-assignment-expression 

assignment 

non-assignment-expression: 

conditional-expression 

lambda-expression 

query-expression 

constant-expression: 

expression 

boolean-expression: 

expression 


OQ 


B.2.5 Statements 

statement: 

labeled-statement 

declaration-statement 

embedded-statement 

embedded-statement: 

block 

empty-statement 

exp ress ion-sta temen t 

selection-statement 

iteration-statement 

jump-statement 

try-statement 

checked-s tatement 

unchecked-statement 

lock-statement 

using-statement 

yield-statement 

block: 

{ statement-list , } 

statement-list: 

statement 

statement-list statement 


788 


www.it-ebooks.info 




B.2 Syntactic Grammar 


empty-statement: 


labeled-statement: 

identifier : statement 

declaration-statement: 

local-variable-declaration ; 
local-constant-declaration ; 

local-variable-declaration: 

local-variable-type local-variable-declarators 

local-variable-type: 

type 

var 

local-variable-declarators: 

local-variable-declarator 

local-variable-declarators , local-variable-declarator 

local-variable-declarator: 

identifier 

identifier = local-variable-initializer 

local-variable-initializer: 

expression 

array-initializer 

local-constant-declaration: 

const type constant-declarators 

constant-declarators: 

constant-declarator 

constant-declarators , constant-declarator 

constant-declarator: 

identifier = constant-expression 

expression-statement: 

statement-expression ; 


DO 


789 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


OQ 


statement-expression: 

invocation-expression 

object-creation-expression 

assignment 

post-increment-expression 

post-decrement-expression 

pre-increment-expression 

pre-decrement-expression 

selection-statement: 

if-statement 

switch-statement 

if-statement: 

if ( boolean-expression ) embedded-statement 

if ( boolean-expression ) embedded-statement else embedded-statement 
switch-statement: 

switch ( expression ) sivitch-block 

switch-block: 

{ switch-sections , } 

switch-sections: 

switch-section 

switch-sections switch-section 

switch-section: 

switch-labels statement-list 

switch-labels: 

switch-label 

switch-labels switch-label 
switch-label: 

case constant-expression : 
default : 

iteration-statement: 

while-statement 

do-statement 

for-statement 

foreach-statement 


790 


www.it-ebooks.info 




B.2 Syntactic Grammar 


while-statement: 

while ( boolean-expression ) embedded-statement 
do-statement: 

do embedded-statement while ( boolean-expression ) j 
for-statement: 

for ( for-initializer ; for-condition^^ ; for-iterator^^ ) embedded-statement 

for-initializer: 

local-variable-declaration 

statement-expression-list 

for-condition: 

boolean-expression 

for-iterator: 

statement-expression-list 

statement-expression-list: 

statement-expression 

statement-expression-list , statement-expression 
foreach-statement: 

foreach ( local-variable-type identifier in expression ) embedded-statement 

jump-statement: 

break-statement 

continue-statement 

goto-statement 

return-statement 

throw-statement 

break-statement: 
break j 

continue-statement: 

continue ; 

goto-statement: 

goto identifier ; 

goto case constant-expression ; 

goto default ; 


DO 


791 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


OQ 


return-statement: 

return expression; 

throw-statement: 

throw expression^^ ; 

try-statement: 

try block catch-clauses 
try block finally-clause 
try block catch-clauses finally-clause 

catch-clauses: 

specific-catch-clauses general-catch-clause 
specific-catch-clausesgeneral-catch-clause 

specific-catch-clauses: 

specific-catch-clause 

specific-catch-clauses specific-catch-clause 
specific-catch-clause: 

catch ( class-type identifier ) block 

general-catch-clause: 
catch block 

finally-clause: 

finally block 

checked-statement: 
checked block 

unchecked-statement: 
unchecked block 

lock-statement: 

lock ( expression ) embedded-statement 
using-statement: 

using ( resource-acquisition ) embedded-statement 

resource-acquisition: 

local-variable-declaration 

expression 


792 


www.it-ebooks.info 




B.2 Syntactic Grammar 


yield-statement: 

yield return expression ; 
yield break ; 

B.2.6 Namespaces 

compilation-unit: 

extern-alias-directivesusing-directivesglobal-attributes 
namespace-member-declarations 

namespace-declaration: 

namespace qualified-identifier namespace-body 

qualified-identifier: 

identifier 

qualified-identifier . identifier 
namespace-body: 

{ extern-alias-directivesusing-directivesnamespace-member-declarations } 

extern-alias-directives: 

extern-alias-directive 

extern-alias-directives extern-alias-directive 

extern-alias-directive: 

extern alias identifier ; 

using-directives: 

using-directive 

using-directives using-directive 

using-directive: 

using-alias-directive 

using-namespace-directive 

using-alias-directive: 

using identifier = namespace-or-type-name ; 

using-namespace-directive: 
using namespace-name ; 

namespace-member-declarations: 

namespace-member-declaration 

namespace-member-declarations namespace-member-declaration 


DO 


793 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


namespace-member-declaration: 

namespace-declaration 

type-declaration 

type-declaration: 

class-declaration 

struct-declaration 

interface-declaration 

enum-declaration 

delegate-declaration 

qualified-alias-member: 

identifier :: identifier type-argument-list 

B.2.7 Classes 

class-declaration: 

attributesclass-modifiers^^ partial^^^ class identifier type-parameter-list^ 
class-basetype-parameter-constraints-clauses^^ class-body 

class-modifiers: 

class-modifier 

class-modifiers class-modifier 

class-modifier: 

new 

public 

protected 

internal 

private 

abstract 

sealed 

static 

type-parameter-list: 

< type-parameters > 

type-parameters: 

attributes^^^ type-parameter 

type-parameters , attributes^^ type-parameter 


794 


www.it-ebooks.info 




B.2 Syntactic Grammar 


type-parameter: 

identifier 

class-base: 

: class-type 
: interface-type-list 
: class-type , interface-type-list 

interface-type-list: 

interface-type 

interface-type-list , interface-type 

type-parameter-constraints-clauses: 

type-parameter-constraints-clause 

type-parameter-constraints-clauses type-parameter-constraints-clause 

type-parameter-constraints-clause: 

where type-parameter : type-parameter-constraints 


type-parameter-constraints: 
primary-constraint 
secondary-constraints 
constructor-constraint 
primary-constraint , 
primary-constraint , 
secondary-constraints 
primary-constraint , 


secondary-constraints 
constructor-constraint 
, constructor-constraint 
secondary-constraints , 


constructor-constraint 


primary-constraint: 

class-type 

class 

struct 


secondary-constraints: 

interface-type 

type-parameter 

secondary-constraints , interface-type 
secondary-constraints , type-parameter 

constructor-constraint: 
new ( ) 


DO 


795 


www.it-ebooks.info 


Grammar 





Grammar 


B. Grammar 


OQ 


class-body: 

{ class-member-declarations , } 

class-member-declarations: 

class-member-declaration 

class-member-declarations class-member-declaration 

class-member-declaration: 

constant-declaration 

field-declaration 

method-declaration 

property-declaration 

event-declaration 

indexer-declaration 

operator-declaration 

constructor-declaration 

destructor-declaration 

static-constructor-declaration 

type-declaration 

constant-declaration: 

attributes^^^ constant-modifiers const type constant-declarators ; 

constant-modifiers: 

constant-modifier 

constant-modifiers constant-modifier 

constant-modifier: 

new 

public 

protected 

internal 

private 

constant-declarators: 

constant-declarator 

constant-declarators , constant-declarator 

constant-declarator: 

identifier = constant-expression 


796 


www.it-ebooks.info 




B.2 Syntactic Grammar 


field-declaration: 

attributes^^^ field-modifierstype variable-declarators ; 

field-modifiers: 

field-modifier 

field-modifiers field-modifier 

field-modifier: 

new 

public 

protected 

internal 

private 

static 

readonly 

volatile 

variable-declarators: 

variable-declarator 

variable-declarators , variable-declarator 

variable-declarator: 

identifier 

identifier = variable-initializer 

variable-initializer: 

expression 

array-initializer 

method-declaration: 

method-header method-body 

method-header: 

attributes , method-modifiers , partial , return-type member-name 

opt J opt ~ opt j * 

type-parameter-list 

( formal-parameter-list^ ) type-parameter-constraints-clauses^^ 

method-modifiers: 

method-modifier 

method-modifiers method-modifier 


DO 


797 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


method-modifier: 

new 

public 

protected 

internal 

private 

static 

virtual 

sealed 

override 

abstract 

extern 

return-type: 

type 

void 

member-name: 

identifier 

interface-type . identifier 

method-body: 

block 


OQ 


formal-parameter-list: 

fixed-parameters 

fixed-parameters , parameter-array 
parameter-array 

fixed-parameters: 

fixed-parameter 

fixed-parameters , fixed-parameter 


fixed-parameter: 

attributes^^^ parameter-modifiertype identifier default-argument 

default-argument: 

- expression 


798 


www.it-ebooks.info 




B.2 Syntactic Grammar 


parameter-modifier: 

ref 

out 

this 

parameter-array: 

attributes^^^ params array-type identifier 
property-declaration: 

attributes^^^ property-modifierstype member-name { accessor-declarations } 

property-modifiers: 

property-modifier 

property-modifiers property-modifier 

property-modifier: 

new 

public 

protected 

internal 

private 

static 

virtual 

sealed 

override 

abstract 

extern 

member-name: 

identifier 

interface-type . identifier 
accessor-declarations: 

get-accessor-declaration set-accessor-declaration 
set-accessor-declaration get-accessor-declaration 

get-accessor-declaration: 

attributes^^^ accessor-modifier get accessor-body 
set-accessor-declaration: 

attributes , accessor-modifier , set accessor-body 

opt J opt J 


DO 


799 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


accessor-modifier: 

protected 

internal 

private 

protected internal 
internal protected 

accessor-body: 

block 


OQ 


event-declaration: 

attributes^^i event-modifiers event type variable-declarators ; 
attributesevent-modifiers event type member-name 
{ event-accessor-declarations } 

event-modifiers: 

event-modifier 

event-modifiers event-modifier 

event-modifier: 

new 

public 

protected 

internal 

private 

static 

virtual 

sealed 

override 

abstract 

extern 

event-accessor-declarations: 

add-accessor-declaration remove-accessor-declaration 
remove-accessor-declaration add-accessor-declaration 

add-accessor-declaration: 
attributes , add block 

remove-accessor-declaration: 
attributes , remove block 

opt 


800 


www.it-ebooks.info 




B.2 Syntactic Grammar 


indexer-declaration: 

attributes^^^ indexer-modifiers^^^ indexer-declarator { accessor-declarations } 

indexer-modifiers: 

indexer-modifier 

indexer-modifiers indexer-modifier 

indexer-modifier: 

new 

public 

protected 

internal 

private 

virtual 

sealed 

override 

abstract 

extern 

indexer-declarator: 

type this [ formal-parameter-list ] 

type interface-type . this [ formal-parameter-list ] 

operator-declaration: 

attributes^^i operator-modifiers operator-declarator operator-body 

operator-modifiers: 

operator-modifier 

operator-modifiers operator-modifier 

operator-modifier: 

public 

static 

extern 

operator-declarator: 

unary-operator-declarator 

binary-operator-declarator 

conversion-operator-declarator 

unary-operator-declarator: 

type operator overloadable-unary-operator ( type identifier ) 

overloadable-unary-operator: one of 

+ - ! ~ ++ -- true false 


DO 


801 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


binary-operator-dedarator: 

type operator overloadable-binary-operator ( type identifier , type identifier ) 

overloadable-binary-operator: 

+ 

* 

/ 

% 

St 

I 

A 

<< 

right-shift 

! = 

> 

< 

< = 

conversion-operator-declarator: 

implicit operator type ( type identifier ) 

explicit operator type ( type identifier ) 

operator-body: 

block 


OQ 


constructor-declaration: 

attributes , constructor-modifiers , constructor-declarator constructor-body 

opt d opt d 

constructor-modifiers: 

constructor-modifier 

constructor-modifiers constructor-modifier 

constructor-modifier: 

public 

protected 

internal 

private 

extern 


802 


www.it-ebooks.info 




B.2 Syntactic Grammar 


constructor-declarator: 

identifier ( formal-parameter-list 


constructor-initializer: 

: base ( argument-list) 
: this ( argument-list) 


constructor-initializer , 

opt 


constructor-body: 

block 


static-constructor-declaration: 

attributes^^^ static-constructor-modifiers identifier ( 


static-constructor-modifiers: 
extern , static 

Opt 

static extern , 

opt 


static-constructor-body: 

block 


) static-constructor-body 


destructor-declaration: 

attributes^^^ extern^^j ~ identifier ( 


destructor-body: 

block 


) destructor-body 


B.2.8 Structs 

struct-declaration: 

attributes^^i struct-modifiers^^ partial^^^ struct identifier type-parameter-list 
struct-interfaces^i type-parameter-constraints-clauses^^ struct-body 

struct-modifiers: 

struct-modifier 

struct-modifiers struct-modifier 

struct-modifier: 

new 

public 

protected 

internal 

private 


DO 


803 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


struct-interfaces: 

: interface-type-list 

struct-body: 

{ struct-member-declarations , } 

struct-member-declarations: 

struct-member-declaration 

struct-member-declarations struct-member-declaration 

struct-member-declaration: 

constant-declaration 

field-declaration 

method-declaration 

property-declaration 

event-declaration 

indexer-declaration 

operator-declaration 

constructor-declaration 

static-constructor-declaration 

type-declaration 


OQ 


B.2.9 Arrays 

array-type: 

non-array-type rank-specifiers 

non-array-type: 

type 

rank-specifiers: 

rank-specifier 

rank-specifiers rank-specifier 

rank-specifier: 

[ dim-separators ] 

dim-separators: 

3 

dim-separators , 

array-initializer: 

{ variable-initializer-list } 

{ variable-initializer-list , } 


804 


www.it-ebooks.info 




B.2 Syntactic Grammar 


variable-initializer-list: 

variable-initializer 

variable-initializer-list , variable-initializer 

variable-initializer: 

expression 

array-initializer 

B.2.10 Interfaces 

interface-declaration: 

attributes , interface-modifiers , partial , interface 
identifier variant-type-parameter-listinterface-base^^ 
type-parameter-constraints-clauses^^ interface-body 

interface-modifiers: 

interface-modifier 

interface-modifiers interface-modifier 

interface-modifier: 

new 

public 

protected 

internal 

private 

variant-type-parameter-list: 

< variant-type-parameters > 

variant-type-parameters: 

attributes^^^ variance-annotation^^ type-parameter 

variant-type-parameters , attributes^! variance-annotation^^! type-parameter 

variance-annotation: 

in 

out 


DO 


interface-base: 

: interface-type-list 

interface-body: 

{ interface-member-declarations^! } 


805 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


OQ 


interface-member-declarations: 

interface-member-declaration 

interface-member-declarations interface-member-declaration 

interface-member-declaration: 

interface-method-declaration 

interface-property-declaration 

interface-event-declaration 

interface-indexer-declaration 

interface-method-declaration: 

attributes^^^ return-type identifier type-parameter-list 

( formal-parameter-list ) type-parameter-constraints-clauses^^ ■, 


interface-property-declaration: 


attributes 


opt 


opt 


type identifier { interface-accessors } 


interface-accessors: 


attributes 

attributes 

attributes 

attributes 


get 

set 

get 

set 


attributes 

attributes 


set 

get 


interface-event-declaration: 

attributes^^^ event type identifier ; 

interface-indexer-declaration: 

attributes^^ type this [ formal-parameter-list ] { interface-accessors } 


B.2.11 Enums 

enum-declaration: 

attributes , enum-modifiers . enum identifier enum-base , enum-body : . 

opt j opt d opt J * opt 

enum-base: 

: integral-type 

enum-body: 

{ enum-member-declarations , } 

{ enum-member-declarations , } 

enum-modifiers: 

enum-modifier 

enum-modifiers enum-modifier 


806 


www.it-ebooks.info 




B.2 Syntactic Grammar 


enum-modifier: 

new 

public 

protected 

internal 

private 

enum-member-declarations: 

enum-member-declaration 

enum-member-declarations , enum-member-declaration 

enum-member-declaration: 
attributes^^^ identifier 

attributes^^i identifier - constant-expression 

B.2.12 Delegates 

delegate-declaration: 

attributes^^^ delegate-modifiers delegate return-type 
identifier variant-type-parameter-list 

( formal-parameter-list^ ) type-parameter-constraints-clauses^^ ; 

delegate-modifiers: 

delegate-modifier 

delegate-modifiers delegate-modifier 

delegate-modifier: 

new 

public 

protected 

internal 

private 

B.2.13 Attributes 

global-attributes: 

global-attribute-sections 

global-attribute-sections: 

global-attribute-section 

global-attribute-sections global-attribute-section 
global-attribute-section: 

[ global-attribute-target-specifier attribute-list ] 

[ global-attribute-target-specifier attribute-list , ] 


DO 


807 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


OQ 


global-attribute-target-specifier: 
global-attribute-target : 

global-attribute-target: 

assembly 

module 

attributes: 

attribute-sections 

attribute-sections: 

attribute-section 

attribute-sections attribute-section 
attribute-section: 

[ attribute-target-specifierattribute-list ] 

[ attribute-target-specifierattribute-list , ] 

attribute-target-specifier: 
attribute-target : 

attribute-target: 

field 

event 

method 

param 

property 

return 

type 

attribute-list: 

attribute 

attribute-list , attribute 
attribute: 

attribute-name attribute-arguments 

attribute-name: 

type-name 

attribute-arguments: 

( positional-argument-list ) 

( positional-argument-list , named-argument-list ) 
( named-argument-list ) 


808 


www.it-ebooks.info 




B.3 Grammar Extensions for Unsafe Code 


positional-argument-list: 

positional-argument 

positional-argument-list , positional-argument 


positional-argument: 

argument-nameattribute-argument-expression 

named-argument-list: 

named-argument 

named-argument-list , named-argument 


named-argument: 

identifier - attribute-argument-expression 


attribute-argument-expression: 

expression 


B.3 Grammar Extensions for Unsafe Code 

class-modifier: 

unsafe 

struct-modifier: 

unsafe 

interface-modifier: 

unsafe 

delegate-modifier: 

unsafe 

field-modifier: 

unsafe 

method-modifier: 

unsafe 


DO 


809 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


property-modifier: 

unsafe 

event-modifier: 

unsafe 

indexer-modifier: 

unsafe 

operator-modifier: 

unsafe 

constructor-modifier: 

unsafe 

destructor-declaration: 

attributes , extern , unsafe , ~ identifier ( 

attributes , unsafe . extern , ~ identifier ( 

opt Opt opt d ' 

static-constructor-modifiers: 

extern , unsafe , static 

Opt opt 

unsafe , extern , static 

Opt opt 

extern , static unsafe , 

opt opt 

unsafe , static extern , 

Opt opt 

static extern , unsafe , 

opt opt 

static unsafe , extern , 

opt opt 

embedded-statement: 

unsafe-statement 

fixed-statement 

unsafe-statement: 
unsafe block 


pointer-type 


810 


) destructor-body 
) destructor-body 


www.it-ebooks.info 




B.3 Grammar Extensions for Unsafe Code 


pointer-type: 

unmanaged-type * 

void 

unmanaged-type: 

type 

primary-no-array-creation-expression: 

pointer-member-access 

pointer-element-access 

sizeof-expression 

unary-expression: 

pointer-indirection-expression 

addressof-expression 

pointer-indirection-expression: 

* unary-expression 

pointer-member-access: 

primary-expression -> identifier type-argument-list 
pointer-element-access: 

primary-no-array-creation-expression [ expression ] 

addressof-expression: 

& unary-expression 

sizeof-expression: 

sizeof ( unmanaged-type ) 

fixed-statement: 

fixed ( pointer-type fixed-pointer-declarators ) embedded-statement 

fixed-pointer-declarators: 

fixed-pointer-declarator 

fixed-pointer-declarators , fixed-pointer-declarator 

fixed-pointer-declarator: 

identifier = fixed-pointer-initializer 


DO 


811 


www.it-ebooks.info 


Grammar 




Grammar 


B. Grammar 


fixed-pointer-initializer: 

& variable-reference 
expression 

struct-member-declaration: 

fixed-size-buffer-declaration 

fixed-size-buffer-declaration: 

attributes^^^ fixed-size-buffer-modifiers fixed buffer-element-type 
fixed-size-buffer-declarators ; 

fixed-size-buffer-modifiers: 

fixed-size-buffer-modifier 

fixed-size-buffer-modifier fixed-size-buffer-modifiers 

fixed-size-buffer-modifier: 

new 

public 

protected 

internal 

private 

unsafe 

buffer-element-type: 

type 

fixed-size-buffer-declarators: 

fixed-size-buffer-declarator 

fixed-size-buffer-declarator , fixed-size-buffer-declarators 

fixed-size-buffer-declarator: 

identifier [ constant-expression ] 

local-variable-initializer: 

stackalloc-initializer 

stackalloc-initializer: 

stackalloc unmanaged-type [ expression ] 


812 


www.it-ebooks.info 




C. References 


IEEE. IEEE Standard for Binary Floating-Point Arithmetic. ANSI/IEEE Standard 754-1985. 
Available fromhttp://www.ieee.org. 

ISO/IEC. C++. ANSI/ISO/IEC 14882:1998. 

Unicode Consortium. The Unicode Standard, Version 3.0. Addison-Wesley, Reading, 
Massachusetts, 2000, ISBN 0-201-616335-5. 


813 


www.it-ebooks.info 




This page intentionally left blank 


www.it-ebooks.info 


Index 


A 

\a escape sequence,81 
Abstract accessors, 46, 557-558 
Abstract classes 

and interfaces, 661 
overview, 468^69 
Abstract events, 566 
Abstract indexers, 567 
Abstract methods, 35, 539-540 
Access and accessibility 
array elements, 628 
containing types, 502-503 
events, 253 

indexers, 253, 300-301 
members, 23-24,107,496 

accessibility domains, 110-113 
constraints, 116-117 
declared accessibility, 107-409 
interface, 642-644 
pointer, 721-722 
in primary expressions, 283-288 
protected, 113-116 
nested types, 499-503 
pointer elements, 723 
primary expression elements, 298-301 
properties, 252, 555-556 
Accessors 

abstract, 46, 557-558 
attribute, 695 


event, 564-565 
property, 43,46, 547-553 
Acquire semantics, 514 
Acquisition in using statement, 445^46 
add accessors 
attributes, 695 
events, 49,564 
Add method 

lEnumerable, 311 
List, 42 

AddEventHandler method, 565 
Addition operator 
described, 15 
uses, 337-340 

Address-of operator, 724-725 
Addresses 

fixed variables, 728-733 
pointers for, 714, 7244^25 
after state for enumerator objects, 593^96 
Alert escape sequence, 81 
Aliases 

for namespaces and types, 456-461 
qualifiers, 464^66 
uniqueness, 466 
Alignment enumeration, 58-59 
Alloc method, 738 
Allocation, stack, 736-738 
AllowMultiple parameter, 688 


■ 815 


www.it-ebooks.info 


Ambiguities ■ Asterisks (*) 


Ambiguities 

grammar, 287-288 
in query expressions, 376 

Ampersands (&) 
for addresses, 716 
in assignment operators, 389 
definite assignment rules, 188-189 
for logical operators, 355-359 
for pointers, 724-725 
in preprocessing expressions,87 

AND operators, 15 

Angle brackets (<>) for type arguments,160 
Anonymous functions 
bodies, 367 
conversions, 219-221 

evaluation to delegate types, 165A66, 
221-222 

evaluation to expression tree types,222 
implementation example, 222-226 
implicit, 204 

definite assignment rules, 192 
delegate creation, 61 
dynamic binding, 369 
evaluation of, 373 
expressions, 165-166, 326, 364-366 
outer variables, 369-373 
overloaded, 368 
signatures, 365-366 

Anonymous objects, 317-319 

AppendFormat method, 31 

Applicable function members, 271-272 
Application domains, 99 

ApplicationExcpetion class, 681 

Applications, 4 
startup, 99-100 
termination, 100-101 

Apply method, 60 

Arguments, 28. See also Parameters 
command-line, 99 
for function members, 254-259 
type, 161-162 
type inference, 259-270 

Arithmetic operators, 331-332 
addition, 337-340 
division, 334-335 

multiplication, 332-333 
pointer, 725-726 
remainder, 336-337 
shift, 344 

subtraction, 340-342 
ArithmeticException class, 335,685 
Arrays and array types, 625 
access to, 299-300,628 
content, 13 
conversions, 200 
covariance, 200, 629-630 
creating, 628 
description, 8,155 
elements, 53, 171,628 
with foreach, 429 

IList interface, 627-628 
initializers, 55, 630-632 
members, 106,628 
new operator for, 53, 55, 312-315 
overview, 53-55 
parameter, 31, 528-531 
and pointers, 719-720, 730-731 
rank specifiers, 625-626 
syntactic grammar, 804-805 
ArrayTypeMismatchExcephon class 
description, 685 
type mismatch, 390-391,629 
as operator, 353-355 

Assemblies, 4-5 

Assignment 

in classes vs. structs, 612 
definite. See Definite assignment 
fixed size buffers, 736 
Assignment operators, 16 
compound, 393-394 
event, 394-395 
overview, 389-390 
simple, 390-393 

Associativity of operators, 238-240 
Asterisks (*) 

assignment operators, 389 
comments, 69-70, 741-742 
multiplication, 332-333 
pointers, 713-716,721 
transparent identifiers, 385 

816 



www.it-ebooks.info 



At sign characters (@) for identifiers ■ Box class 


At sign characters (@) for identifiers, 72^4 
Atomicity of variable references,193 
Attribute class, 62,688 
Attributes, 687 

classes, 688-691, 704-705 
compilation of, 698-699 
compilation units, 454 
instances, 698-699 
for interoperation, 707 
overview, 61-63 
parameters for, 690-691 
partial types, 482^83 
reserved, 699-700 
AttributeUsage, 700 
Conditional, 701-705 
Obsolete, 705-706 
sections for, 692 
specifications, 692-698 
syntactic grammar, 807-809 
AttributeUsage attribute, 688-690,700 
Automatic memory management, 132-137 
Automatically implemented properties,548, 
553-555 


B 

\b escape sequence, 81 
Backslash characters (\) 
for characters, 80-81 
escape sequence, 80-81 
for strings, 82 

Backspace escape sequence, 81 
Backtick character ('),83 
Banker's rounding, 150 
Base access, 302-303 
Base classes, 22,25-26 
partial types, 484 
specifications for, 472^75 
type parameter constraints, 476 
Base interfaces 

inheritance from, 637-638 
partial types, 484^85 
Base types, 249-250 

before state for enumerator objects, 593^96 
Better conversions, 274-275 
Better function members, 272-273 


Binary operators, 238 
declarations, 574-575 
in ID string format, 759 
lifted, 246 

numeric promotions, 244-245 
overload resolution, 243 
overloadable, 241 
Binary point types, 9 
Bind method, 56 
Binding 

constituent expressions, 237 
dynamic, 166, 234-237 
name, 490 
static, 234-235 
time, 235 

BitArray class, 569-570 

Bitwise complement operator,328 

Blocks 

in declarations, 102-104 
definite assignment rules, 179 
exiting, 430 

in grammar notation, 66 
invariant meaning in, 281-283 
in methods, 544 
reachability of, 401 
in statements, 402^04 
for unsafe code, 710 
Bodies 

classes, 481 
interfaces, 638 
methods, 32-33,544 
struct, 609 

Boneheaded exceptions, 686 
bool type, 8-9,150-151 
Boolean values 
expressions, 397 
literals, 76 
operators 

conditional logical, 359 
equality, 348 
logical, 357 

in struct example, 622-623 
Boss class, 47 
Bound types, 162 
Box class, 539 


817 


www.it-ebooks.info 



Boxed instances ■ Classes 


Boxed instances, invocations on,278 
Boxing, 12,155-156 

in classes vs. structs, 613-616 
conversions, 156-158,201 
break statement 

definite assignment rules, 182 

example, 19 

for for statements, 423 

overview, 431 

for switch, 416^17 

for while, 420 

yield break, 449^52, 594-595 
Brittle base class syndrome, 35,292 
Brittle derived class syndrome, 292,297 
Buffers, fixed-size 

declarations, 733-735 
definite assignment, 736 
in expressions, 735-736 
Bugs. See Unsafe code 
Button class, 549,561 
byte type, 10 

c 

<c> tag, 744 

Cache class, 444 

Callable entities, 671 

Candidate user-defined operators, 243 

Captured outer variables, 369-370 

Carets (^) 

in assignment operators, 389 
for logical operators, 355-357 
Carriage-return characters 
escape sequence, 81 
as line terminators, 68-69 
Case labels, 415^19 
Cast expressions, 330-331 
cast operator vs. as operator,355 
catch blocks 

definite assignment rules, 183-185 
for exceptions, 684-685 
throw statements, 436^37 
try statements, 438^43 
char type, 146 


Character literals, 80-81 
Characters, 9 
checked statement 

definite assignment rules, 179 
example, 20 
overview, 443 

in primary expressions, 322-325 
Chooser class, 259-260 
Classes 

accessibility, 23 
attribute, 688-691, 704-705 
base, 25-26, 472^75 
bodies, 481 
constants for, 506-508 
constructors for, 42^3 
instance, 579-586 
static, 586-589 
declarations, 467 

base specifications, 472^75 
bodies, 481 
modifiers, 467-^71 
partial type, 471 

type parameter constraints, 475^81 
type parameters, 471^72 
defined, 467 

destructors for, 50, 589^91 
events in, 47-49 
accessors, 564-565 
declaration, 559-562 
field-like, 562-564 
instance and static, 565 
fields in, 26-27 

declarations, 509-510 
initializing, 515-516 
read-only, 511^13 
static and instance, 510-511 
variable initializers, 516-519 
volatile, 514-515 
fimction members in, 40-50 
indexers in, 46^7,566-571 
instance variables in, 170-171 
interface implementation by,57 
iterators. See Iterators 


818 


www.it-ebooks.info 



Classes ■ Comparison operators 


members in, 22-23,106, 490^92 
access modifiers for,496 
constituent types for,496 
constructed types, 493^94 
inheritance of, 494^96 
instance types, 492 
nested types for, 498^04 
new modifier for,496 
reserved names for, 504^06 
static and instance, 496^98 
methods in, 28^0 
abstract, 539-540 
bodies, 544 
declaration, 520-522 
extension, 541-543 
external, 539-540 
parameters, 522-531 
partial, 541 
sealed, 537-538 
static and instance, 531 
virtual, 532-534 
operators in, 49-50 
binary, 574-575 
conversion, 575-578 
declaration, 571-573 
imary, 573-574 
overview, 21-22 
partial types. See Partial types 
in program structure, 4r-5 
properties in, 43^6 
accessibility, 555-556 
accessors for, 547-553 
automatically implemented, 553-555 
declarations, 545-546 
static and instance, 546 
vs. structs, 610-619 
syntactic grammar, 794-803 
type parameters, 24-25 
types, 6-13,153-154 
Classifications, expression, 231-234 
Click events, 562-563 
Closed types, 162 

CLS (Common Language Specification),9 
<code> tag, 744 


Collections 

for f oreach, 425 
initializers, 310-312 
Colons (:) 

alias qualifiers, 464-465 
grammar productions, 66 
Interface identifiers, 637 
ternary operators, 191, 361-362 
type parameter constraints, 476 
Color class, 27,512 
Color enumeration, 58, 664-666 
Color struct, 286 
COM, interoperation with, 707 
Combining delegates, 340,675 
Command-line arguments, 99 
Commas (,) 
arrays, 54 
attributes, 692 
collection initializers, 310 
ID string format, 755 
interface identifiers, 637 
method parameter lists, 522 
object initializers, 307 
Comments, 741 

documentation file processing, 754-759 

example, 760-766 

lexical grammar, 69-70,768 

overview, 741-743 

tags, 743-753 

XML for, 741-742, 762-765 
Commit method, 92 

Common Language Specification (CLS),9 
Common types for type inference,270 
CompareExchange method, 600 
Comparison operators, 49 
booleans, 348 
decimal numbers, 348 
delegates, 351-352 
enumerations, 348 
floating point numbers, 346-347 
integers, 346 
overview, 344-345 
pointers, 726 
reference types, 349-351 
strings, 351 


819 


www.it-ebooks.info 



Compatibility of delegates and methods ■ Conversions 


Compatibility of delegates and methods,676 
Compilation 

attributes, 698-699 
binding, 235 

dynamic overload resolution checking, 
275-276 
just-in-time, 5 

Compilation directives, 90-93 
Compilation symbols, 87 
Compilation unit productions, 67 
Compilation units, 65, 453-454 
Compile-time type of instances, 35,532 
Complement operator, 328 
Component-oriented programming, 1-2 
Compound assignment 
operator, 389 
process, 393-394 
Concatenation, string, 339 
Conditional attribute, 701-705 
Conditional classes, 704-705 
Conditional compilation directives, 90-93 
Conditional compilation symbols, 87 
Conditional logical operators, 15, 358^60 
Conditional methods, 701-703 
Conditional operator, 15, 361-363 
Console class, 31, 552-553 
Constant class, 35-36 
Constants, 41 

declarations, 411-412, 506-508 
enums for. See Enumerations and enum 
types 

expressions, 203, 395-397 
static fields for, 512^13 
versioning of, 512-513 
Constituent expressions, 237 
Constituent types, 496 
Constraints 

accessibility, 116417 
constructed types, 162-164 
partial types, 483^84 
type parameters, 4754:81 
Constructed types, 160-161 
boimd and unbound, 162 
constraints, 162-164 
members, 493494 


open and closed, 162 
type arguments, 161 
Constructors, 41 
for classes, 4243 
for classes vs. structs, 617-618 
default, 141-142,584 
in ID string format,757 
instance. See Instance constructors 
invocation, 254 
static, 42, 586-589 
Contact class, 311 
Contexts 

for attributes, 694-696 
unsafe, 710-713 
Contextual keywords, 75 
continue statement 

definite assignment rules, 182 

for do, 421 

example, 19 

for for statements, 423 

overview, 432 

for while, 420 

Contracts, interfaces as, 633 
Contra variant type parameters, 635 
Control class, 564-565 
Control-Z character,68 
Conversions, 195 

anonymous functions, 165-166, 219-226, 
365-366 

boxing, 156-158,201 
constant expression, 203 
dynamic, 202,210 
enumerations, 198,207 
explicit, 204-213 
expressions, 330-331 
fimction members, 274-275 
identity, 196-197 
implicit, 195-204 
standard, 213 
user-defined, 217-219 
method groups, 226-229 
null literal, 199 

nullable, 198-199, 207-208, 360-361 
numeric, 197,205-207 
as operator for, 353455 


820 


www.it-ebooks.info 



Conversions ■ default expressions 


operators, 575-578,759 
for pointers, 717-720 
reference, 199-201, 208-210 
standard, 213-214 
type parameters, 203-204, 211-212 
unboxing, 158-160,210 
user-defined. See User-defined 
conversions 
variance, 636 
Convert class, 207 
Copy method, 739 
Counter class, 552 
Counter struct, 614 
CountPrimes class, 570 
Covariance 

array, 200, 629-630 
type parameters, 635 
cref attribute, 742 
Critical execution points, 137 
•cs extension, 3 
Curly braces ({}) 
arrays, 55 

collection initializers, 310 
grammar notation, 66 
object initializers, 307 
Currency type, 150 
Current property,595 
Customer class, 488^89 

D 

Database structure example 
boolean type, 622-623 
integer type, 619-621 
DBBool struct, 622-623 
DBlnt struct, 619-621 
Decimal numbers and type, 9A0 
addition, 338-339 
comparison operators, 348 
division, 335 
multiplication, 333 
negation, 327 
remainder operator, 337 
subtraction, 341 
working with, 149-150 


decimall28 type, 149 
Declaration directives, 88-89 
Declaration space, 101 
Declaration statements, 407-412 
Declarations 
classes, 467 

base specifications, 4724:75 
bodies, 481 
modifiers, 467471 
partial type, 471 

type parameter constraints, 475481 
type parameters, 471472 
constants, 411-412, 506-508 
definite assignment rules, 180 
delegates, 672-675 
enums, 59, 663-664 
events, 559-562 
fields, 509-510 
fixed-size buffers, 733-735 
indexer, 566-571 
instance constructors, 579-580 
interfaces, 633-638 
methods, 520-522 
namespaces, 103,454456 
operators, 571-573 
order, 6,103 
overview, 101-104 
parameters, 522-525 
pointers, 714 
properties, 545-546 
property accessors, 547 
static constructors, 586-589 
struct members, 609 
structs, 608-609 
types, 10,464 
variables, 175,407411 
Declared accessibility 
nested types, 499-500 
overview, 107-109 
Decrement operators 
pointers, 725 
postfix, 303-305 
prefix, 328-330 
default expressions, 142 


821 


www.it-ebooks.info 



Defaults ■ DoubleTolnt64Bits method 


Defaults 

constructors, 141-142,584 
switch statement labels, 415^16 
values, 141,175-176 

classes vs. structs, 612-613 
expressions, 325 
#define directive, 87,89 
Defining partial method declarations,486 
Definite assignment, 33,169,176^77 
fixed size buffers, 736 
initially assigned variables, 177 
initially unassigned variables, 177 
rules for, 178-192 

Degenerate query expressions, 379-380 
Delegate class, 671 

Delegates and delegate type, 671-672 
combining, 340,675 
compatible, 676 
contents, 13 

conversions, 165-166, 221-222 
declarations, 672-675 
description, 8,11,155 
equality, 351-352 
instantiation, 676-677 
invocations, 298, 677-680 
members of, 107 
new operator for, 315^17 
overview, 60-61 
removing, 342 
syntactic grammar, 807 
Delimited comments, 69-70, 741-742 
Dependence 

on base classes, 473^74 
in structures, 611 
type inference, 263 

Depends on relationships, 473^74,611 
Derived classes, 22, 25-26 
Destructors 

for classes, 50, 589-591 
for classes vs. structs, 619 
exceptions for, 685 
garbage collection, 132-137 
in ID string format, 757 


member names reserved for,506 
members, 23 

Diagnostic directives, 93-94 
Digit struct, 578 

Dimensions, array, 11, 54, 625, 631-632 
Direct base classes, 472^73 
Directives 

preprocessing. See Preprocessing 
directives 

using. See Using directives 
Directly depends on relationships, 
473^74,611 

Disposal in using statement,446 
Dispose method, 591 

for enumerator objects, 596, 604-605 
for resources, 445^46 
Divide method, 30 

DivideByZeroException class, 333-334, 
683,685 

Division operator, 334-335 
Dllimport attribute, 541 
DLLs (Dynamic Link Libraries),541 
do statement 

definite assignment rules, 181-182 
example, 18 
overview, 421 

Documentation comments, 741 
documentation files for, 741,754 
ID string examples, 755-759 
ID string format, 754-756 
example, 760-766 
overview, 741-743 
tags for, 743-753 
XML files for, 741-742, 7624^65 
Documentation generators, 741 
Documentation viewers, 741 
Domains 

accessibility, 110413 
application, 99 
Double quotes (") 
characters, 80 
strings, 80 

double type, 9-10,146-149 
DoubleTolnt64Bits method,334 


822 


www.it-ebooks.info 



Dynamic binding ■ Event handlers 


Dynamic binding 

anonymous functions, 369 
overview, 234-237 
Dynamic Link Libraries (DLLs),541 
Dynamic memory allocation, 738-740 
Dynamic overload resolution, 275-276 
dynamic type, 154 

conversions, 202,210 
identity conversions, 197 
overview, 166-167 

E 

ECMA-334 standard, 1 
EditBox class, 56-57 
Effective base classes, 480 
Effective interface sets, 480 
Elements 

array, 53,171,628 
foreach, 425^27 
pointer, 723 

primary expression, 298-301 
#elif directive, 87-88,91 
Ellipse class, 539 
#else directive, 87, 90-93 
Embedded statements and expressions 
general rules, 186-187 
in grammar notation, 66 
Empty statements, 404^06 
Encompassed types, 216 
Encompassing types, 216 
End-of-file markers, 68 
End points, 400^02 
#endif directive, 91 
#endregion directive, 94 
Entity class, 33-34 
Entry class, 5 
Entry points, 99 
Enumerable interfaces, 592 
Enumerable objects for iterators, 596^97 
Enumerations and enum types 
addition of, 339 
comparison operators, 348 
conversions 
explicit, 207 
implicit, 198 


declarations, 663-664 
description, 8,11, 663,668 
logical operators, 356-357 
members, 106, 665-668 
modifiers, 664-665 
overview, 58-59 
subfracfion of, 341 
syntactic grammar, 806-807 
types for, 151 

values and operations, 668-669 
Enumerator interfaces, 592 
Enumerator objects for iterafors, 593-596 
Enumerator types for foreach, 425^26 
Equal signs (=) 

assignment operators, 389 
comparisons, 345 
operator ==, 49-50 
pointers, 726 

preprocessing expressions, 87 
Equality operators, 15 
boolean values, 348 
delegates, 351-352 
lifted, 246-247 
and null, 352 
reference types, 349-351 
strings, 351 
Equals method 

on anonymous types, 319 
DBBool, 623 
DBlnt, 621 
List, 42 

with NaN values, 347 
Point, 761 
#error directive, 94 
Error property,553 
Error strings in ID string format,754 
Escape sequences 
characters, 81 
lexical grammar, 769 
strings, 81 

Unicode character, 71^2 
Evaluate method, 37 
Evaluation of user-defined conversions, 
215-216 

Even! handlers, 48, 559,562 


823 


www.it-ebooks.info 



Events ■ Expressions 


Events, 4 

access to, 253 
accessors, 564-565 
assignment operator, 394-395 
declarations, 559-562 
example, 42 
field-like, 562-564 
in ID string format, 754, 758-759 
instance and static, 565 
interface, 642 

member names reserved for,506 
overview, 47-49 

Exact parameter type inferences,264 
<example> tag, 745 
Exception class, 436, 438, 682-684 
Exception propagation, 437 
<exception> tag, 745 
Exception variables, 438 
Exceptions 
causes, 683 
classes for, 685-686 
for delegates, 677 
handling, 1, 684-685 
overview, 681-682 
throwing, 436^37 
try statement for, 438443 
Exclamation points (!) 
comparisons, 345 
definite assignment rules, 190 
logical negation, 327 
operator I=,49 
pointers, 726 

preprocessing expressions, 87 
Execution 

instance constructors, 582-584 
order of, 137-138 
Exiting blocks, 430 
Exogenous exceptions, 686 
Expanded form function members,272 
Explicit base interfaces, 637 
Explicif conversions, 204-205 
dynamic, 210 
enumerations, 207 
nullable types, 207-208 
numeric, 205-207 


reference, 208-210 
standard, 214 
type parameters, 211-212 
imboxing, 210 
user-defined, 213, 218-219 
Explicit interface member implementations, 
57, 647-650 

explicit keyword, 576-578 

Explicit parameter type inferences,264 

Expression class, 35-37 

Expression statements, 17,179, 412413 

Expressions, 231 

anonymous function. See Anonymous 
functions 
binding, 234-237 
boolean, 397 
cast, 330-331 
classifications, 231-234 
constant, 203, 395-397 
constituent, 237 

definite assignment rules, 186-191 
dynamic, 166 

fixed-size buffers in, 735-736 
function members 

argument lists, 254-259 
categories, 250-254 
invocation, 276-278 
overload resolution, 270-275 
type inference, 259-270 
member lookup, 247-250 
operators for, 238 

arithmetic. See Arithmetic operators 
assignment, 389-395 
logical, 355-357 
numeric promotions, 244-246 
overloading, 240-243 
precedence and associativity, 238^40 
relational, 345 
shift, 343-344 
imary, 326-331 
overview, 13-16 
pointers in, 720-727 
preprocessing, 87-88 
primary. See Primary expressions 


824 


www.it-ebooks.info 



Expressions ■ Function members 


query, 373-375 

ambiguities in, 376 
patterns, 387-389 
translations in, 376-387 
syntactic grammar, 779-788 
tree types, 165-166,222 
values of, 233 

Extensible Markup Language (XML), 
741-742, 762-765 
Extension methods 
example, 541-543 
invocation, 293-297 
Extensions class, 542 
extern aliases, 456M57 
External constructors, 580,586 
External destructors, 589 
External events, 560 
External indexers, 569 
External methods, 539-540 
External operators, 572 
External properties, 546 

F 

\f escape sequence,81 
Ealse value, 76 
Eatal exceptions, 686 
Eield-like events, 562-564 
Eields, 4 

declarations, 509-510 
example, 41 

in ID string format, 754, 756-757 
initializing, 515-516, 616-617 
instance, 26-27, 510-511 
overview, 26-27 
read-only, 27-28, 511^13 
static, 510-511 

variable initializers, 516-519 
volatile, 514-515 
Eill method, 629 
Eilters, 442 
Einalize method, 591 
Einalizers, 50 
finally blocks 

definite assignment rules, 184-185 
for exceptions, 684 
execution, 682 


with goto, 434 
with try, 438M43 
Eixed-size buffers 

declarations, 733-735 
definite assignment, 736 
in expressions, 735-736 
fixed statement, 716, 728-733 
Eixed variables, 716-717 
Eixing type inferences, 266^67 
float type, 9-10,146-149 
Eloating point numbers 
addition, 338 

comparison operators, 346-347 
division, 334-335 
multiplication, 332 
NaN payload, 333-334 
negation, 327 
remainder operator,336 
subtraction, 340-341 
types, 9-10,146-149 
for statement 

definite assignment rules, 182 
example, 19 
overview, 422M23 
foreach statement 

definite assignment rules, 185 
example, 19 
overview, 423M29 
Eorm feed escape sequence,81 
Eorward declarations, 6 
Eragmentation, heap, 729 
Eree method, 739 
from clauses, 375, 379-387 
EromTo method, 599-600 
Eully qualified names 
described, 131 
interface members, 645 
nested types, 499 
Eunction members 

argument lists, 254-259 
in classes, 40-50 

dynamic overload resolution checking, 

275-276 

overload resolution, 270-275 
overview, 250-254 
type inference, 259-270 

825 


www.it-ebooks.info 



Function pointers ■ Hello, World program 


Function pointers, 671 
Functional notation, 241 
Functions, anonymous. See Anonymous 
functions 

G 

Garbage collection, 1 

at application termination, 101 
for desfructors, 50 

in memory management, 132-137,176 
and pointers, 713 
for variables, 716 
GC class, 133,136 
Generic classes and types, 25,139 
anonymous objects, 318 
boxing, 156,613 
constraints, 162, 475^77,483 
declarations, 467,473 
delegates, 220 
instance type, 492 
interfaces, 650-651 
member lookup, 247 
methods, 521, 532, 652-653 
nested, 247,503 
overloading, 275 
overriding, 536 

query expression patterns, 387 
signatures, 28 
static fields, 26 
type inferences, 259-261,267 
unboimd, 160 
Generic inferface, 627-628 
get accessors 

for attributes, 695 
defined, 45 
description, 557 
working with, 547-553 
GetEnumerator method 
for f oreach, 425 
for iterators, 596-603 
GetEventFlandler method, 565 


GetldashCode method 

on anonymous types, 319 
comparisons, 347 
DBBool, 623 
DBlnt, 621 

GetldourlyRate method, 38 
GetlnvocationList method, 677 
GetNextSerialNo method, 34 
GetProcessHeap method, 739 
Global declaration space, 101 
Global namespace, 105 
goto statement 

definite assignment rules, 182 
example, 19 
for switch, 416^17,419 
working with, 433^34 
Governing types of switch statements, 
415,418 
Grammars, 65 

ambiguities, 287-288 
lexical. See Lexical grammar 
notation, 65-67 

syntactic. See Syntactic grammar 
for unsafe code, 809-812 
Greafer than signs (>) 

assignment operators, 389 
comparisons, 345 
pointers, 716, 721-722,726 
shift operators, 343-344 
Grid class, 570-571 
group clauses, 375, 378,385 

H 

Flandlers, event, 48, 559,562 
Idas Value property ,152 
Ideap, 7 

accessing fimctions of, 738-740 
fragmentation, 729 
Ideap Alloc method, 739 
IdeapFree method, 739 
IdeapReAlloc method, 740 
IdeapSize method, 740 
Idello, World program,3 


826 


www.it-ebooks.info 



Hello class ■ Inaccessible members 


Hello class, 93 

Help Attribute class, 61-62,690 
HelpStringAttribute class, 697 
Hexadecimal escape sequences 
for characters, 80 
for strings, 83 
Hiding 

inherited members, 102,125-127,495 
in multiple-inheritance interfaces, 644 
in nesting, 124-127,500 
properties, 550 
in scope, 120 

Hindley-Milner-style algorithms, 261 
Horizontal tab escape sequence,81 

I 

IBase interface, 644, 655,660 
ICloneable interface, 645-646, 649,654 
IComboBox interface, 56,638 
IComparable interface, 646 
IControl interface, 56-57,638 
implementations, 646 
inheritance, 657-659 
mapping, 654-656 
member implementations, 650 
member names, 645 
reimplementations, 659-660 
ICounter interface, 643 
ICoimter struct, 615 
ID string format 

for documentation files, 754-756 
examples, 755-759 
IDataBound Interface, 56-57 
Identical simple names and type names, 
286-287 
Identifiers 

interface, 634 
lexical grammar, 769-770 
rules for, 72-74 
Identity conversions, 196-197 
IDerived interface, 655 
IDictionary Interface, 648 


IDisposable interface, 136, 428,445^47, 

591,648 

IDouble interface, 644 

lEnumerable interface, 311, 427-428, 596^97 
lEnumerator interface, 592 
#if directive, 87-88, 90-93 
if statement 

definite assignment rules, 180 
example, 18 
working with, 4134:14 
lEorm interface, 655 
Ilnteger interface, 643-644 
IE (Intermediate Language) instructions,5 
IList interface, 627-628, 643,647 
IListBox interface, 56, 638,656 
IListCounter interface, 643 
IMethods interface, 659-661 
Implementing partial method 
declarations, 486 
Implicit conversions, 195-196 

anonymous functions and method 
groups, 204 
boxing, 201 

constant expression, 203 
dynamic, 202 
enumerations, 198 
identity, 196 
null literal, 199 
nullable, 198-199 
numeric, 197 
operator for, 575-578 
standard, 213 
type parameters, 203-204 
user-defined, 204,217 
implicit keyword, 575-578 
Implicitly typed array creation 
expressions, 313 

Implicitly typed iteration variables, 423,427 
Implicitly typed local variable declarations, 
408409 

Importing types, 461463 
In-line methods, 61 
In property,553 
Inaccessible members, 107 


827 


www.it-ebooks.info 



<include>tag ■ Interface sets 


<include> tag, 742, 745-746 
Increment operators 
for pointers, 725 
postfix, 303-305 
prefix, 328-330 
IndexerName Attribute, 707 
Indexers 

access to, 253,300-301 
declarations, 566-571 
example, 42 
in ID string format, 758 
interface, 642 

member names reserved for,506 
overview, 46^7 
signatures in, 119 
IndexOf method, 39^0 
IndexOutOfRangeException class, 300,685 
Indices, array,53 
Indirection, pointer, 716,721 
Inference, type, 259-270 
Infinity values, 147-148 
Inheritance, 22 

from base interfaces, 637-638 
in classes, 25-26,105, 494-496 
in classes vs. structs, 612 
hiding through, 102,125-127,495 
interface, 640, 657-659 
parameters, 689 
properties, 550 
Initializers 

array, 55, 630-632 
field, 515-516, 616-617 
in for stafements,422 
instance constructors, 580-581 
stack allocation, 736-738 
variables, 516-519,581 
Initially assigned variables, 169,177 
Initially unassigned variables, 169,177 
Inlining process, 552 
InnerException property,683 
Input production, 67 
Input-safe types, 636 
Input types in type inference,263 
Input-unsafe types, 636 


Instance constructors 
declarations, 579-580 
default, 584 
description, 42 
execution, 582-584 
initializers, 580-581 
invocation, 254 
optional parameters, 585-586 
private, 584-585 
Instance events, 565 
Instance fields 
class, 510-511 
example, 26-27 
initialization, 515-516,519 
read-only, 511^13 
Instance members 
class, 496^98 
description, 22 
protected access for, 113416 
Instance methods, 28, 33-34,531 
Instance properties, 546 
Instance types, 492 
Instance variables, 170-171, 510-511 
Instances, 21-22 
attribute, 698-699 
type, 153 
Instantiation 

delegates, 676-677 
local variables, 370-373 
int type, 9-10 

lnt64BitsToDouble method,334 
Integers 

addition, 338 

comparison operators, 346 
division, 334 
literals, 76-78 
logical operators, 356 
multiplication, 332 
negation, 327 
remainder, 336 
in struct example, 619-621 
subtraction, 340 
Integral types, 9-10,145-146 
interface keyword, 634 
Interface sets, 480 


828 


www.it-ebooks.info 



Interfaces ■ Just-In-Time GIT) compiler 


Interfaces, 4,633 
base, 637-638 
bodies, 638 
declarations, 633-638 
enumerable, 592 
enumerator, 592 
generic, 650-651 
implementations, 645-647 
abstract classes, 661 
base classes, 475 
explicit member, 647-650 
generic methods, 652-653 
inheritance, 657-659 
mapping, 653-656 
reimplementation, 659-660 
imiqueness, 650-652 
inheritance from, 637-638 
members, 106, 639-640 
access to, 642-644 
events, 642 

fully qualified names, 645 
indexers, 642 
methods, 640-641 
properties, 641-642 
modifiers, 634 
overview, 56-57 
partial types, 484^85 
struct, 609 

syntactic grammar, 805-806 
types, 8,11-13,155 
variant type parameter lists, 635-637 
Intermediate Language (IL) instructions,5 
Internal accessibility, 23,107 
Interning, 84 

Interoperation attributes, 707 
IntToString method, 737-738 
IntVector class,574 

InvalidCastException class, 159, 210, 355,685 
InvalidOperationException class, 152,600 
Invariant meaning in blocks, 281^83 
Invariant type parameters, 635 
Invocable members, 247-248 
Invocation 

delegates, 298, 677-680 
function members, 276-278 


instance constructors, 254 
methods, 251 
operators, 254 

Invocation expressions, 187, 288-298 
Invocation lists, 675,677 
Invoked members, 247-248 
IronPython, 236 
is operator, 352-353 
isFalse property,622 
IsNan method, 334 
isNull property 
DBBool, 622 
DBInt, 620 

ISO/IEC 23270 standard,! 

IStringList interface, 639 
isTrue properfyh22 
Iteration statements, 420 
do, 421 
for, 422-423 
foreach, 423^29 
while, 420^21 

Iteration variables in foreach, 423-424 
Iterafors, 592 
blocks, 403 

enumerable interfaces, 592 
enumerable objects for, 596^97 
enumerator interfaces, 592 
enumerator objects for, 593-596 
implementafion example, 597-603 
yield type, 592 
ITest interface, 119420 
ITextBox inferface, 56, 638, 645-647, 650656 

J 

Jagged arrays, 54 
JIT (Just-In-Time) compiler,5 
join clauses, 380-384 
Jump statements 
break, 431 
continue, 432 
goto, 433^34 
overview, 4294:31 
return, 435 
throw, 436437 
Just-In-Time (JIT) compiler,5 


829 


www.it-ebooks.info 



KeyValuePair struct ■ Local variables 


K 

KeyValuePair struct,613 
Keywords 

lexical grammar, 770 
list, 74-75 

L 

Label class, 551-552 
Label declaration space, 102-103 
Labeled statements 
for goto, 433^34 
overview, 406^07 
for switch, 181,415^19 
Left-associative operators, 239 
Left shift operator, 343-344 
Length of arrays, 53, 625, 631-632 
Less fhan signs (<) 

assignment operators, 389 
comparisons, 345 
pointers, 726 
shift operators, 343-344 
let clauses, 380-384 
Lexical grammar, 67,767 
comments, 69-70,768 
identifiers, 769-770 
keywords, 770 
line terminators, 68-69,767 
literals, 771-773 
operators and punctuators, 773 
preprocessing directives, 774-777 
tokens, 769 

Unicode character escape sequences, 769 
whitespace, 70-71,769 
Lexical structure, 65 
grammars, 65-67 

lexical. See Lexical grammar 
syntactic. See Syntactic grammar 
lexical analysis, 67-71 
preprocessing directives, 85-87 

conditional compilation, 87, 90-93 

declaration, 88-89 

diagnostic, 93-94 

line, 95-96 

pragma, 96-97 


preprocessing expressions, 87-88 
region, 94 
programs, 65 
tokens, 71 

identifiers, 72-74 
keywords, 74-75 
literals, 76-84 
operators, 84-85 

Unicode character escape sequence, 
71-72 

Libraries, 4,541 
Lifted conversions, 215 
Lifted operators, 246-247 
Mine directive, 94 
Mine default directive, 96 
Line directives, 95-96 
Line-feed characters, 69 
Mine hidden directive, 96 
Line-separator characters, 69 
Line terminators, 68-69,767 
List class, 40-50 
<list> tag, 746-747 
ListChanged method, 48 
Lists, statement, 403M:04 
Literals 

boolean, 76 
character, 80-81 
in constant expressions, 395 
conversions, 199 
defined, 76 
integer, 76-78 
lexical grammar, 771-773 
null, 84 

in primary expressions, 279 
real, 78-79 
simple values, 144 
string, 81-84 

Local constant declarations, 17,411M12 
Local variable declaration space, 103 
Local variables 

declarations, 17,407-411 
instantiation, 370-373 
in methods, 32-33 
scope, 124-125 
working with, 173-175 


830 


www.it-ebooks.info 



lock statement ■ Methods 


lock statement 

definite assignment rules, 186 
example, 21 
overview, 443^45 
Logical operators 
AND, 15 

for boolean values, 357 
conditional, 358-360 
for enumerations, 356-357 
for integers, 356 
negation, 327-328 
OR, 15 

overview, 356-357 
shift, 344 
XOR, 15 

LoginDialog class, 561 

long type, 9-10 

Lookup, member, 247^50 

Lower-boimd type inferences, 264-265 

lvalues, 193 

M 

Main method 

for startup, 99-100 
for static constructors, 587-588 
Mappings 

interface, 653-656 
pointers and integers, 719 
Math class, 334 
Members, 4, 22-23,105 
access to, 23,107,496 

accessibility domains, 110-113 
constraints, 116-117 
declared accessibility, 107-409 
interface, 642-644 
pointer, 721-722 
in primary expressions, 283-288 
protected, 113-116 
accessibility of, 23-24 
array, 106,628 
class, 106, 490M92 

access modifiers for,496 
constituent types, 496 
constructed types, 493M94 
inheritance of, 494M96 


instance types, 492 
nested types, 498-504 
new modifier for,496 
reserved names for, 504^06 
static and instance, 496M98 
delegate, 107 

enumeration, 106, 665-668 
function. See Function members 
inherited, 102,105,125-127,494M96 
interface, 106, 639-640 
access to, 642-644 
events, 642 

explicit implementations, 57, 647-650 
fully qualified names, 645 
indexers, 642 
methods, 640-641 
properties, 641-642 
lookup, 247-250 
namespaces, 105,463M64 
partial types, 485 
pointer, 721-722 
struct, 105-106,609 
Memory 

automatic management of, 132-137,176 
dynamic allocation of, 738-740 
Memory class, 738-740 
Memory leaks from events,561 
Message property,683 
Metadata, 5 

Method group conversions 
implicit, 204 
overview, 226-229 
type inference, 269 
Methods, 4,28 

abstract, 35, 539-540 
bodies, 32-33,544 
conditional, 701-703 
declarations, 520-522 
extension, 541-543 
external, 539-540 
in ID string format, 754, 757-758 
instance, 28, 33-34,531 
interface, 640-641 
invocations, 251, 288-298 
in List, 42 


831 


www.it-ebooks.info 



Methods ■ Nested members 


Methods (continued) 
overloading, 38M0 
overriding, 35, 535-537 
parameters, 29-32 
arrays, 528-531 
declarations, 522-525 
output, 526-527 
reference, 525-526 
value, 525 
partial, 486M90,541 
sealed, 537-538 
static, 28, 33-34,531 
virtual, 35-38, 532-534 
Minus (-) operator,327 
Minus signs (-) 

assignment operators, 389 
decrement operator, 303-305, 328-330 
pointers, 716, 721-722,725 
subtraction, 340-342 
Modifiers 

class, 467-471 
enums, 664-665 
interface, 634 
partial types, 483 
struct, 609 

Modulo operator, 336-337 
Most derived method implementation, 
532-533 

Most encompassing types,216 
Most specific operators, 215 
Move method, 760-761 
Moveable variables 
described, 716-717 
fixed addresses for, 728433 
MoveNext method, 426 

enumerator objects, 451, 593-595 
Stack, 599 
Tree, 603-604 

Multi-dimensional arrays, 11, 54,625, 
631-632 

Multi-use attribute classes, 688 
Multiple inheritance, 56-57,644 
Multiple statements, 402M03 
Multiplication operator, 15, 332-333 
Multiplicative operators, 15 
Multiplier class, 60-61 

832 


Multiply method, 60 
Mutual-exclusion locks, 4434:45 

N 

\n escape sequence, 81 
Named constants. See Enumerations and 
enum types 

Named parameters, 690-691 
Names 

anonymous types, 318-319 
binding, 490 
fully qualified, 131 

interface members, 645 
nested types, 499 
hiding, 124-127 
methods, 521 
reserved, 504-506 
simple 

in primary expressions, 279-283 
and type names, 286-287 
variables, 170 
namespace keyword, 454 
Namespaces, 3-4,453 

aliases, 456M61, 4644:66 
compilation units, 4534:54 
declarations, 103, 4544:56 
using directives in, 457463 
fully qualified names in,131 
in ID string format, 754 
members, 105, 4634:64 
overview, 127-130 
purpose, 104 

syntactic grammar, 793-794 
type declarations, 464 
NaN (Not-a-Number) value 
causes, 147,149 
exceptions, 682 

in floating point comparisons,347 
payload results, 333-334 
Negation 

logical, 327-328 
numeric, 327 

Nested array initializers, 631-632 
Nested blocks, 104 
Nested classes, 468 
Nested members, 110-111 


www.it-ebooks.info 



Nested scopes ■ Objects 


Nested scopes, 120 
Nested types, 498^99 
accessibility, 499-503 
description, 464 
fully qualified names for,499 
in generic classes, 503 
member access contained by, 502^03 
partial, 482 
this access to, 500-501 
Nesting 

aliases, 460 
with break, 431 
comments, 70 

hiding through, 124-125,500 
object initializers, 308 
New line escape sequence,81 
new modifier 

class members, 496 
classes, 468 
delegates, 672 
interface members, 640 
interfaces, 634 
new operator 

anonymous objects, 317-319 
arrays, 53, 55, 312-315 
collection initializers, 310-312 
constructors, 43 
delegates, 315-317 
hidden methods, 126 
object initializers, 307-310 
objects, 305 
structs, 52 

No fall through rule, 416^17 
No side effects convention,552 
Non-nested types, 498 
Non-nullable value type, 152 
Non-virtual methods, 35 
Nonterminal symbols, 65-66 
Normal form function members,272 
Normalization Form C, 73 
Not-a-Number (NaN) value 
causes, 147,149 
exceptions, 682 

in floating point comparisons,347 
payload results, 333-334 
Notation, grammar, 65-67 


NotSupportedException class, 593 
Null coalescing operator, 360-361 
Null field for events, 48 
Null literals, 84,152,199 
Null pointers, 714 
Null-termination of strings, 733 
Null values 

for array elements, 54 
in classes vs. structs, 613 
escape sequence for,81 
garbage collector for,134 
Nullable boolean logical operators,357 
Nullable types, 11-12 
contents, 13 
conversions 

explicit, 207-208 
implicit, 198-199 
operators, 353-355 
description, 8 

equality operators with, 352 
overview, 151-152 
NullReferenceException class 
array access, 300 
with as operator,355 
delegate creation, 316 
delegate invocation, 678 
description, 685 
foreach statement, 427 
throw statement, 436 
unboxing conversions, 159 
Numeric conversions 
explicit, 205-207 
implicit, 197 

Numeric promotions, 244-246 

0 

object class, 141,154 
Object variables, 12-13 
Objects 

creation expressions for 

definite assignment rules, 187 
new operator, 305-307 
deallocating, 22 
description, 139 
initializers, 307-310 
as instance types, 153 


833 


www.it-ebooks.info 



Obsolete attribute ■ Paragraph-separator characters 


Obsolete attribute, 705-706 
Octal literals, 77 
OnChanged method, 42,48 
One-dimensional arrays, 54 
Open types, 162 
Operands, 13,238 
Operation class, 35-36 
Operator notation, 241 
Operators, 13, 42, 49, 84-85 

arithmetic. See Arithmetic operators 
assignment operators, 16,389 
compoimd, 393-394 
event, 394-395 
simple, 390-393 
binary See Binary operators 
conditional, 361-363 
conversion, 575-578,759 
declaration, 571-573 
enums, 668-669 
in ID string format, 759 
invocation, 254 
lexical grammar, 773 
lifted, 246-247 
logical, 355-357 
null coalescing, 360-361 
numeric promotions, 244-246 
operator !=,49 
operator ==, 49-50 
overloading, 240-243 
overview, 238 

precedence and associativity, 238-240 
relational. See Relational operators 
shift, 343-344 
type-testing, 352-353 
unary. See Unary operators 
Optional parameters, 522, 585-586 
Optional symbols in grammar notation,66 
OR operators, 15 
Order 

declaration, 103 
execution, 137-138 
orderby clauses, 375, 380-384 
Out property, 553 
Outer variables, 369-373 


OutOfMemoryException class, 313,316, 
339,685 

Output parameters, 30,173, 526-527 
Output-safe types, 636 
Output types in type inference,263 
Output-unsafe types, 636 
Overflow checking context, 322-325,443 
OverflowException class 
addition, 338 
arrays, 313 

checked operator, 323-324 
decimal type, 150 
description, 686 
division, 335 

increment and decrement operators,329 
multiplication, 332-333 
remainder operator, 336 
Overload resolution 

anonymous functions, 368 
function members, 270-275 
Overloaded operators, 13 
purpose, 238 
shift, 343 
Overloading 
indexers, 47 
methods, 38^0 
operators, 240-243 
signatures in, 38,117-420 
Overridden base methods, 535 
Override events, 566 
Override indexers, 567 
Override methods, 535-537 
Overriding 

event declarations, 566 
methods, 35 

property accessors, 46,557 
property declarations, 557-558 

P 

Padding for pointers, 727 
Paint method, 56,539 
Pair class, 24 

Pair-wise declarations, 575 
<para> tag, 748 

Paragraph-separator characters, 69 


834 


www.it-ebooks.info 



<param>tag ■ Positional parameters 


<param> tag, 742,748 

Parameter lists, variant type, 635-637 

Parameters 

anonymous functions, 365 
arrays, 528-531 
attributes, 690-691 
entry points, 99 

function member invocations, 255-256 
indexers, 46-47, 567-568 
instance constructors, 581, 585-586 
methods, 29-32 

declaration, 522-525 
types, 524-531 
optional, 585-586 
output, 173, 526-527 
in overloading, 117-118 
reference, 172, 525-526 
type. See Type parameters 
value, 171,525 
<paramref> tag, 749 
params modifier, 31-32, 528^31 
Parentheses () 

anonymous functions, 365 
in grammar notation, 66 
in ID string format, 755 
for operator precedence, 240 
Parenthesized expressions, 283 
Partial methods, 541 
partial modifier,471 
interfaces, 634 
sfrucfs, 609 
types, 481^82 
Partial types, 471 
attributes, 482^83 
base classes, 484 
base interfaces, 484 
members, 485 
methods, 486^90 
modifiers, 483 
name binding, 490 
overview, 481^82 

type parameters and constraints, 483^84 
Patterns, query expression, 387-389 
Percent signs (%) 

assignment operators, 389 
remainder operator, 336-337 


Periods (.) 

base access, 302 
members, 105 
<permission> tag, 749 

Permitted user-defined conversions, 214-215 
Phases, type inference, 262 
Plus (+) operator,326 
Plus signs (+) 

addition, 337-340 
assignment operators, 389 
increment operator, 303-305, 328-330 
pointers, 725 
Point class 
base class, 25 
coordinates, 308 
declaration, 22 
instantiated objects, 51 
properties, 554 
source code, 760-762 
Point struct, 611-612 

assignment operators, 391-392 
default values, 613 
field initializers, 616-618 
instantiated objects, 51-52 
Point3D class, 25 
Pointers 

arithmetic, 725-726 
arrays, 719-720 
conversions, 717-720 
element access, 723 
in expressions, 720-727 
for fixed variables, 728-733 
function, 671 
indirection, 716,721 
member access, 721-722 
operators 

address-of, 724-725 
comparison, 726 
increment and decrement, 725 
sizeof, 727 
types, 713-716 
unsafe, 7,709 
variables with, 716-717 
Polymorphism, 22,26 
Pop method, 4-5 
Positional parameters, 690-691 

835 


www.it-ebooks.info 



Postfix increment and decrement operators ■ Quotes for characters 


Postfix increment and decrement operators, 
303-305 

#pragma directive, 96 
#pragma warning directive, 96-97 
Precedence of operators, 13,238^40 
Prefix increment and decrement operators, 
328-330 

Preprocessing directives 

conditional compilation, 87, 90-93 

declaration, 88-89 

diagnostic, 93-94 

lexical grammar, 774-777 

line, 95-96 

overview, 85-87 

pragma, 96-97 

preprocessing expressions, 87-88 
region, 94 

Preprocessing expressions, 87-88 
Primary expressions 

anonymous method, 326 
checked and unchecked operators, 
322-325 

default value, 325 
element access, 298-301 
forms of, 278-279 
invocation, 288-298 
literals in, 279 
member access, 283-288 
new operator m 

anonymous objects, 317-319 
arrays, 312-315 
collection initializers, 310-312 
delegates, 315-317 
object initializers, 307-310 
objects, 305-307 
parenthesized, 283 
postfix increment and decrement 
operators, 303-305 
simple names in, 279-283 
this access in, 301-302 
typeof operator, 319-322 
Primary operators, 14 
PrintColor method, 58 
Private accessibility, 23-24,107 
Private constructors, 584-585 
Productions, grammar, 65 
836 


Program class, 47, 602-603, 614-615 
Program structure, 4-6 
Programs, 4,65 
Projection initializers, 319 
Promotions, numeric, 244-246 
Propagation, exception, 437 
Properties, 4 
access to, 252 
accessibility, 555-556 
automatically implemented, 553-555 
declarations, 545-546 
example, 42 

in ID string format, 754,758 
indexers, 568 
interface, 641-642 

member names reserved for, 504^05 
overview, 43^6 
static and instance, 546 
Property accessors, 46 
declarations, 547 
overview, 547-553 
types of, 553 

Protected accessibility, 23-24 
declared, 107 

instance members, 113-116 
internal, 23-24,107 
Public accessibility, 23-24,107 
Punctuators 

lexical grammar, 773 
list of, 84-85 

PurchaseTransaction class,92 
Push method, 4 

Q 

Qualifiers, alias, 464^66 
Query expressions 
ambiguities in, 376 
overview, 373-375 
patterns, 387-389 
translations in, 376-387 
Question marks (?) 

null coalescing operator, 360-361 
ternary operators, 191, 361-362 
Quotes (',") for characters, 80-81 


www.it-ebooks.info 



\r escape sequence ■ Right shift operator 


R 

\r escape sequence,81 
Range variables, 375,379 
Rank of arrays, 54, 625-626 
Reachability 
blocks, 401 
do statements, 421 
for sfatements, 424 
labeled statements, 406^07 
overview, 400^02 
return statements, 435 
statement lists, 403 
throw statements, 437 
while statements, 420^21 
Read-only fields, 27-28, 511-513 
Read-only properties, 45, 549-550,554 
Read-write properties, 45, 549-550 
readonly modifier, 27,511 
ReadOnlyPoint class, 554 
Reads, volatile, 514 
Real literals, 78-79 
ReAlloc method, 739 

Recommended tags for comments, 743-753 
Rectangle class, 308-309 
Rectangle struct, 392 
ref modifier, 30 
Reference conversions 
explicit, 208-210 
implicit, 199-201 

Reference parameters, 29-30,172, 525-526 
Reference types, 6-8,152-153 
array, 53,155 
class, 153-154 
constraints, 476 
delegate, 155 
dynamic, 154 

equality operators, 349-351 
interface, 155 
object, 154 
string, 154 
References, 139 

paramefer passing by, 29^0 
variable, 192-193 

Referencing static class types, 470-471 
Referent types, pointer,713 


Region directives, 94 
Regular string literals, 81-82 
Reimplementation, interface, 659-660 
Relational operators 
booleans, 348 
decimal numbers, 348 
delegates, 351-352 
descriptions, 15 
enumerations, 348 
integers, 346 
lifted, 247 
overview, 344-345 
reference types, 349-351 
strings, 351 

Release semantics, 514 
Remainder operator, 336-337 
<remarks> tag, 750 
remove accessors 
attributes, 695 
events, 49,564 

RemoveEventHandler method, 565 
Removing delegates, 342 
Required parameters, 522 
Reserved attributes, 699-700 
AttributeUsage, 700 
Conditional, 701-705 
Obsolete, 705-706 

Reserved names for class members, 504^06 

Reset method, 604 

Resolution 

function members, 270-275 
operator overload, 38,243 
Resources, using statement for, 445449 
return statement 

definite assignment rules, 182-183 
example, 19 
methods, 33 
overview, 435 
with yield, 4494:52 
Return type 

entry points, 100 
inferred, 267-269 
methods, 28, 521-522 
<returns> tag, 750 
Right-associative operators, 239 
Right shift operator, 343-344 

837 


www.it-ebooks.info 



Rounding ■ Single-use attribute classes 


Rounding, 150 

Rules for definite assignment, 178-192 
running state for enumerator objects, 593-596 
Runtime processes 

argument list evaluation, 257-259 
array creation, 313 
attribute instance retrieval, 699 
binding, 235 
delegate creation, 316 
function member invocations, 276-277 
increment and decrement operators,304 
object creation, 306-307 
prefix increment and decrement 
operations, 329 
unboxing conversions, 160 
Runtime types, 35,532 
RuntimeWrappedException class,439 

s 

sbyte type, 9 
Scopes 

aliases, 459^60 
attributes, 694 
vs. declaration space, 101 
local variables, 410 
for name hiding, 124-127 
overview, 120-124 
Sealed accessors, 557 
Sealed classes, 469,474-475 
Sealed events, 566 
Sealed indexers, 567 
Sealed methods, 537-538 
sealed modifier, 469, 537-^38 
Sections for attributes, 692 
<see> tag, 751 
<seealso> tag, 751-752 
select clauses, 375, 378, 384-385 
Selection statements, 413 
if, 413^14 
switch, 414^19 
Semicolons (;) 
accessors, 548 
interface identifiers, 642 
method bodies, 544 
namespace declarations, 454 


Sequences in query expressions,375 
set accessors 

for aftribufes, 695 
defined, 45 
description, 557 
working with, 547-550 
Setltems method, 56 
SetNextSerialNo method, 34 
SetText method,56 
Shape class, 539 
Shift operators 
described, 15 
overview, 343-344 

Short-circuiting logical operators, 358 
short type, 9-10,144 
ShowHelp method, 62 
Side effects 

with accessors, 552 
and execution order, 137438 
Signatures 

anonymous functions, 365-366 
indexers, 568 
methods, 28,521 
operators 
binary, 575 
conversion, 578 
imary,573 

in overloading, 38,117420 
Signed integrals, 8-9 
Simple assignment 

definite assignment rules, 188 
operator, 389 
overview, 390-393 

Simple expression assignment rules,186 
Simple names 

in primary expressions, 279-283 
and type names, 286-287 
Simple types, 8,140-144 
Single-dimensional arrays 
defined, 625 
example, 54 
initializers, 631 

Single-line comments, 69-70, 741-742 
Single quotes (') for characfers, 80-81 
Single-use attribute classes, 688 


838 


www.it-ebooks.info 



SizeOf method ■ Strings 


SizeOf method, 739 
sizeof operator, 727 
Slashes (/) 

assignment operators, 389 
comments, 69-70, 741-742 
division, 334-335 
Slice method, 542-543 
Source files 

compilation, 6 
described, 65 
Point class, 760-762 
Source types in conversions,215 
SplitPath method, 527 
SqlBoolean struct, 621 
Sqltnt32 struct, 621 
Square brackets ([]) 
arrays, 11,54 
attributes, 692 
indexers, 46 
pointers, 716,723 
Square method, 60 
Squares class, 33 
Stack 

allocation, 736-738 
values on, 7 

Stack class, 4-5, 597-598 
stackalloc operator, 716, 736-738 
StackOverflowException class, 686,737 
Standard conversions, 213-214 
Startup, application, 99-100 
Statement lists, 403^04 
Statements, 399^00 
blocks in, 402^04 
checked and imchecked,443 
declaration, 407-^12 
definite assignment rules, 179 
empty, 404^06 

end points and reachability, 400402 
expression, 17,179, 4124:13 
in grammar notation, 66 
iteration, 420 
do, 421 
for, 422423 
foreach, 423429 
while, 420421 


jump, 429431 
break, 431 
continue, 432 
goto, 433434 
return, 435 
throw, 436437 
labeled, 406407 
lock, 443445 
overview, 16-21 
selection, 413 
if, 413414 
switch, 414419 
syntactic grammar, 788-793 
try, 438443 
using, 445449 
yield, 449452 

States, definite assignment, 178 
Static binding, 234-235 
Static classes, 470471 
Static constructors, 42 
in classes vs. structs, 619 
overview, 586-589 
Static events, 565 
Static fields, 26, 510-511 
for constants, 512-513 
initialization, 515-519 
read-only, 511-513 
Static members, 22, 496498 
Static methods, 28 

garbage collection, 133 
vs. instance, 33-34,531 
static modifier, 470471 
Static properties, 546 
Static variables, 170, 510-511 
Status codes, termination, 100 
String class, 3940,154 
string type, 9,154 
StringPromColor method, 667 
StringListEvent method, 639 
Strings 

concatenation, 339 
equality operators, 351 
literals, 81-84 
null-termination, 733 
switch governing type, 418 


839 


www.it-ebooks.info 



Structs ■ Tokens 


Structs 

assignment, 612 
boxing and unboxing, 613-616 
vs. classes, 610-619 
constructors, 617-618 
declarations, 608-609 
default values, 612-613 
destructors, 619 
examples 

database boolean type, 622-623 
database integer type, 619-621 
field initializers m, 616-617 
inheritance, 612 
instance variables, 171 
interface implementation by,57 
members, 105-106,609 
overview, 50-53,607 
syntactic grammar, 803-804 
this access in,616 
types, 6, 8,10-11,143 
value semantics, 610-612 
Subtraction operator, 340-342 
Suffixes, numeric, 76-79 
<summary> tag, 742,752 
SuppressFinalize method, 101 
suspended state, 593-596 
Swap method, 29 
switch statement 

definite assignment rules, 180 
example, 18 
overview, 414-419 
reachability, 402 
Syntactic grammar, 67 
arrays, 804-805 
attributes, 807-809 
basic concepts, 777 
classes, 794-803 
delegates, 807 
enums, 806-807 
expressions, 779-788 
interfaces, 805-806 
namespaces, 793-794 
statements, 788-793 
structs, 803-804 


types, 777-779 
variables, 779 

System-level exceptions, 682 
System namespace, 143 

T 

\t escape sequence, 81 
Tab escape sequence,81 
Tags for comments, 743-753 
Target types in conversions,215 
Targets 

goto, 433^34 
jump, 430 

Terminal symbols, 65-66 
Termination, application, 100-101 
Terminators, line, 68-69,767 
Ternary operators, 238, 361^63 
TextReader class,449 
TextWriter class,449 
this access 

classes vs. structs, 616 
indexers, 46 

instance constructors, 585-586 
nested types, 500-501 
overview, 301-302 
properties, 546 
static methods, 33 
Thread-safe delegates, 677 
Three-dimensional arrays, 54 
Throw points, 437 
throw statement 

definite assignment rules, 182 
example, 20 
for exceptions, 683 
overview, 436^37 
Tildes (~) 

bitwise complement, 328 
conversion, 759 
Time, binding, 235 
ToInt32 method,542 
Tokens, 71 

identifiers, 72-74 
keywords, 74-75 


840 


www.it-ebooks.info 



Tokens ■ Unbound types 


lexical grammar, 769 
literals, 76-84 
operators, 84-85 

Unicode character escape sequence, 71^2 
ToString method, 339 
and boxing, 614-615 
DBBool, 623 
DBInt, 621 
Point, 761-762 
Translate method, 761 
Translations in query expressions, 376-387 
Transparent identifiers in query expressions, 
377, 385-387 
Tree class, 602-603 
Tree types, expression, 165466 
Trig class,585 
True value,76 
try statement 

definite assignment rules, 183-185 
example, 20 
for exceptions, 684-685 
with goto, 434 
overview, 4384:43 
TryParse method, 527 
Two-dimensional arrays 
allocating, 54 
initializers, 631 
Type casts,59 
Type inference, 259-270 
Type names, 127-130 
fully qualified, 131 
identical, 286-287 
Type parameters, 139 

class declarations, 24-25, 471472 
constraints, 475481 
conversions, 211-212 
implicit conversions, 203-204 
overview, 164-165 
partial types, 483484 
Type-safe design,! 

Type testing operators 
as, 353-355 
described, 15 
is, 352-353 


TypelnitializationException class, 684,686 
typeof operator 

pointers with, 713 
primary expressions, 319-322 
<typeparam> tag, 753 
<typeparamref> tag, 753 
Types 

aliases for, 456461 
attribute parameter, 691 
boxing and unboxing, 156-158 
constructed, 160-164,493494 
declarations, 10,464 
dynamic, 166-167 
in ID string format, 754-756 
importing, 461463 
instance, 492 
nested, 464, 498-504 
nullable. See Nullable types 
overview, 6-13,139 
partial. See Partial types 
pointer. See Pointers 
reference. See Reference types 
syntactic grammar, 777-779 
underlying, 58-59,151 
value. See Value types 

u 

uint type, 10 
ulong type, 10 
Unary operators, 326 

cast expressions, 330-331 
described, 14,238 
in ID string format, 759 
lifted, 246 
minus, 327 

numeric promotions, 244 
overload resolution, 242-243 
overloadable, 240-241 
overview, 573-574 
plus, 326 

prefix increment and decrement, 328-330 
Unassigned variables, 177 
Unbound types, 160,162 


841 


www.it-ebooks.info 



Unboxing conversions ■ Value types 


Unboxing conversions 
described, 210 
overview, 158-160 
Unboxing operations 

in classes vs. structs, 613-616 
example, 12 
unchecked statement 

definite assignment rules, 179 
example, 20 
overview, 443 

in primary expressions, 322-325 
#undef directive, 87-89 
Undefined conditional compilation 
symbols, 87 
Underlying types 
enums, 58-59,664 
nullable, 151 

Underscore characters (_) for identifiers, 
72-74 

Unicode characters 

escape sequence, 71-72 
lexical grammar, 67,769 
for strings, 9 

Unicode Normalization Form C,73 
Unified type system,! 

Uniqueness 
aliases, 466 

interface implementations, 650-652 
Unmanaged types, 713 
Unreachable statements, 400 
Unsafe code, 709 

contexts in, 710-713 

dynamic memory allocation, 738-740 

fixed-size buffers, 733-736 

fixed statement, 728-733 

grammar extensions for, 809-812 

pointers 

arrays, 719-720 
conversions, 717-720 
in expressions, 720-727 
support for, 7 
types, 713-716 
stack allocation, 736-738 
unsafe modifier, 710-713 


Unsigned integrals, 8-10 
Unwrapping non-nullable value types, 152 
Upper-bound type inferences, 265-266 
User-defined conversions, 214 
evaluation, 215-216 
explicit, 213, 218-219 
implicit, 204,217 
lifted operators, 215 
overview, 575-578 
permitted, 214-215 
User-defined operators 
candidate, 243 
conditional logical, 359-360 
ushort type, 10 
Using directives 

for aliases, 458^61 

definite assignment rules, 185-186 

example, 21 

for importing types, 461^63 
overview, 445-449,457 
purpose, 3 

V 

\v escape sequence, 81 
Value method, 620 
Value parameters, 29,171,525 
Value property,152 
<value> tag, 752 
Value types 
bool, 150-151 
constraints, 476 
contents, 13 
decimal, 149-150 
default constructors, 141-142 
described, 8 
enumeration, 151 
floating point, 146-149 
integral, 145-146 
nullable, 151-152 
overview, 140-141 
simple, 143-144 
storing, 7 
struct, 143 


842 


www.it-ebooks.info 



Values ■ Write method 


Values 

array types, 626 
classes vs. structs, 610-612 
default, 141 

classes vs. structs, 612-613 
initialization, 175-176 
enums, 668-669 
expressions, 233 
fields, 510-511 
local constants, 412 
variables, 169,175-176,408^09 
ValueType class, 141,612 
VariableReference class, 35-36 
Variables, 169 

anonymous functions, 369-373 
array elements, 171 
declarations, 175, 407-411 
default values, 175-176 
definite assignment. See Definite 
assignment 

fixed addresses for, 728-733 
fixed and moveable, 716-717 
initializers, 516-519,581 
instance, 170-171, 510-511 
local, 173-175 
in methods, 32-33 
names, 170 

output parameters, 173 
overview, 12-13 
query expressions, 375,379 
reference parameters, 172 
references, 192-193 
scope, 124-125,410 
static, 170,510-511 
syntactic grammar, 779 
value parameters, 171 
Variant type parameter lists, 635-637 
Verbatim identifiers, 74 
Verbatim string literals, 81-83 
Versioning 

of constants, 512-513 
described, 1 
Vertical bars (I) 

assignment operators, 389 
definite assignment rules, 189-190 


logical operators, 355-359 
preprocessing expressions, 87 
Vertical tab escape sequence,81 
Vexing exceptions,686 
Viewers, documentation, 741 
Virtual accessors, 46, 557^59 
Virtual events, 566 
Virtual indexers, 567 
Virtual methods 
description, 236 
overview, 35-38 
working with, 532-534 
Visibility in scope, 120,124 
void type and values 

entry point method, 100 
events, 564 
pointers, 714 
return, 28,33 
with typeof, 320 
Volatile fields, 514^15 

w 

WaitForPendingFinalizers method, 136 
#warning directive, 94 
warnings, preprocessing directives, 
96-97 

where clauses 

query expressions, 380-384 
type parameter constraints, 163,476 
while statement 

definite assignment rules, 181 
example, 18 
overview, 4204:21 
Whitespace 

in comments, 742 
defined, 70-71 
in ID string format, 754 
lexical grammar, 769 
Win32 component interoperability,707 
workCompleted method, 47 
Worker class, 4748 

Wrapping non-nullable value types,152 
Write method, 31 


843 


www.it-ebooks.info 



Write-only properties ■ Zero values 


Write-only properties, 45, 549-550,554 
WriteLine method, 3, 31,136 
Writes, volatile,514 


X 

\x escape sequence, 80 
XAttribute class, 696-697 
XML (Extensible Markup Language), 
741-742, 762-765 
XOR operators, 15 


Y 

yield statement 

definite assignment rules, 186 
example, 20 
overview, 449M52 
yield break, 594-595 
yield return, 594-595 

Yield type iterators,592 

z 

Zero values, 146-148 


844 


www.it-ebooks.info 



