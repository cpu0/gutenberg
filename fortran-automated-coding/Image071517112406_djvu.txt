'i J Hi . J i i X 


188 


1957 WESTERN COMPUTER PROCEEDINGS 


I 


f 


1 


M 


Notes: 

1) The number of program steps executed in this routine is: 

a ^ t ^ le extra P°^ a tive check is used and no errors are made. 

b) 41 if the extrapolative check is used and the computed value 
is in error. 

c) 26 if the extrapolative check is used and one of the extrapola- 
tions is in error. 

d) 13 if the extrapolative check is disabled. 

2) Another possible method of disabling the check would be to 
store temporarily a transfer instruction after the third order in 
the routine. However, in real-time computers it is very desirable 
to have the instructions of the program permanently stored 
and theretore untouchable by the program itself. 

3) Steps 38)-43) must be executed whether the check is disabled 
or not so that when the check is reinstated the proper data will 
be available. 

4) It is reasonably clear that performing step 6) bv anv method 
more sophisticated than disabling the check would require 
quite a large number of extra program steps. 


5) The contents of has been made equal to 3 initially to inriJH 
the case in which no extrapolative check is made for 

three cycles. 

6) The author would like to thank J. G. Trvon for hi« u i 

streamlining this routine. ' 


Bibliography 


[1] Doe ream, C. H. Jr. “The Reasonableness Check in Aiiwl* 
non, 1956 IRE Convention' Record, Part 4, pp. 67-72. Utoma ^ 

[2] Hildebrand, F. B. Introduction to Numerical Analysis New v„-u‘ 
McGraw-Hill Book Companv, Inc., 1956. 

[31 Kopal^ Numerical Analysis, New York: John Wiley and sl S 

[ 4 1 Hamming, R.W. “Error Detecting and Error Correcting Code.’* 
Bell System Technical Journal, Vol. 29 (April, 1950) p D 

[5] Flores, I. “Reflected Number Systems,” IRE Transaction' 
on Electronic Computers, Vol. EC-5 (June, 1956) pp 79_g£ 


A 


The FORTRAN Automatic Coding System 


J. W. BACKUS;, R. J. BEEBERf, S. BESTt R. GOLDBERGf, L. M. HAIBTt § 

H. L. HERRICKt, R. A. NELSON! D. SAVRF.+ P R apt ft? tty a nt+ >W 


H. L. HERRICKt, R. A. NELSONf, D. SAYREf, P. B. SHERIDANt 
H. STERNf, I. ZILLERf, R. A. HUGHES §, and R. NUTT|| 


Introduction 

T HE FORTRAN project was begun in the sum- 
mer of 1954. Its purpose was to reduce by a large 
factor the task of preparing scientific problems for 
IBM’s next large computer, the 704. If it were possible 
for the 704 to code problems for itself and produce as 
good programs as human coders (but without the 
errors), it was clear that large benefits could be achieved. 
For it was known that about two-thirds of the cost of 
solving most scientific and engineering problems on 
large computers was that of problem preparation. 
Furthermore, more than 90 per cent of the elapsed time 
for a problem was usually devoted to planning, writing, 
and debugging the program. In many cases the de- 
velopment of a general plan for solving a problem was 
a small job in comparison to the task of devising and 
coding machine procedures to carry out the plan. The 
goal of the FORTRAN project was to enable the pro- 
grammer to specify a numerical procedure using a con- 
cise language like that of mathematics and obtain 
automatically from this specification an efficient 704 
program to carry out the procedure. It was expected 
that such a system would reduce the coding and de- 
bugging task to less than one-fifth of the job it had been. 

Two and one-half years and 18 man years have elapsed 
since the beginning of the project. The FORTRAN 


system is now complete. It has two components*, tt 
FORTRAN language, in which programs are writti|j 
and the translator or executive routine for the 
which effects the translation of FORTRAN langua* 
programs into 704 programs. Descriptions of the FQk 
TRAN language and the translator form the princjjpi 
sections of this paper. .M M 

The experience of the FORTRAN group in using itj3j 
system has confirmed the original expectations con 
cerning reduction of the task of problem preparatioi 
and the efficiency of output programs. A brief’ 
history of one job done with a system seldom givers 
good measure of its usefulness, particularly when’M 
selection is made by the authors of the system 
Nevertheless, here are the facts about a rather simM 
but sizable job. The programmer attended a orie jtgg 
course on FORTRAN and spent some more timetfra 
ferring to the manual. He then programmed the3|| 


in four hours, using 47 FORTRAN statements. TEi 
were compiled by the 704 in six minutes, produci 
about 1000 instructions. He ran the program and foil 


t InternatT Business Machines Corp., New York, N. Y. 
t Mass. Inst. Tech., Computation Lab., Cambridge. Mass. 
§ Radiation Lab., Univ. of California, Livermore, Calif. 

II United Aircraft Corp., East Hartford, Conn. 


the output incorrect. He studied the output (no trai|m 
or memory dumps were used) and was able to local® 
his error in a FORTRAN statement he had writ£j| 
He rewrote the offending statement, recompiled, an® 
found that the resulting program was correct. He esjj 
mated that it might have taken three days to code tfi« 
job by hand, plus an unknown time to debug it, and 
that no appreciable increase in speed of execution woulu 
have been achieved therebv. ASH 


1 




X 


Backus et al: The FORTRAN Automatic Coding System 


189 


initially to indicati 
made for the fir. 


his help ill 1 


!hec in Automa- I 
PP- -72. 
mtysis, New York: ; 

n Wi'ey and Sons. ; 

j 

Dorr ting Codes,” £ 
950,, pp. 147-160.' 
LE Transactions- 
1956), pp. 79-82. f 


The FORTRAN Language 

The FORTRAN language is most easily described 
hv reviewing some examples. 

1 ritii melic Statements 
Example 1: Compute: 


-(5/2) + v '(5/2) 2 - AC 


FORTRAN Program: 

ROOT 

= ! — (B 2.0i 4- SQRTF((B/2.0) - 


. 2 - A . C))/A. 


mpouents: the | 
ns are written® 
ie r the 704.| : 
RA language 
is of the F'OR-.| 
n t v, ‘» principal i’| 

up ... using the- 
lectations con->> 
m eparation 'A 
. i brief case-g 
selaom gives a | 
arly when the if 
: i ; system. 
i r; ter simple |«| 
ded a one-day 
mc-e time re- (| 
mr d the job | 
:en._Ats. These I 
tes, producing | 
rar and found £ 
pu no tracing | ; 
ible to localize | 
e had written!' • 
:co piled, and 
>rr< :. He esti- * 
ys to code thisp|' 
debug it, andg , 
tec don would K 


V. e that the desired program is a single FOR- 
TRAN statement, an arithmetic formula. Its meaning 
is: "Evaluate the expression on the right of the = sign 
and make this the value of the variable on the left.” 
The symbol « denotes multiplication and * * denotes 
exponentiation (i.e., A* *B means A B ). The program 
which is generated from this statement effects the 
computation in floating point arithmetic, avoids com- 
puting (13 2.0 twice and computes (B/2.0) * * 2 by a 
muhAncation rather than by an exponentiation routine. 
[Had (B/2.0; - -2.01 appeared instead, an exponentia- 
tion routine would necessarily be used, requiring more 
time than the multiplication.] 

The programmer can refer to quantities in both 
floating point and integer form. Integer quantities 
are somewhat restricted in their use and serve primarily 
as subscripts or exponents. Integer constants are written 
without a decimal point. Example: 2 (integer form) vs 
2.0 {floating point form). Integer variables begin with 
I, J. K. L. M. or N. Any meaningful arithmetic expres- 
sion may appear on the right-hand side of an arithmetic 
statement, provided the following restriction is ob- 
served: an integer quantity can appear in a floating- 
point expression only as a subscript or as an exponent 
or as the argument of certain functions. The functions 
which the programmer may refer to are limited only 
by those available on the library tape at the time, such 
as SQRTF. plus those simple functions which he has 
denned for the given problem by means of function 
statements. An example will serve to describe the latter. 

Function Statements 

Example 2: Define a function of three variables to be 
used throughout a given problem, as follows: 

ROOTF(A, B, C) 

= (-(B/2.0) 4- SQRTF((B/2.0) * .2 - A*C))/A. 

Function statements must precede the rest of the pro- 
gram. They are composed of the desired function name 
(ending in F) followed by any desired arguments which 
appear in the arithmetic expression on the right of the 
= sign. The definition of a function may employ any 


previously defined functions. Having defined ROOTF 
as above, the programmer may apply it to any set of 
arguments in any subsequent arithmetic statements. For 
example, a later arithmetic statement might be 

THETA = 1.0 4- GAMMA. ROOTF(PI, 3.2. Y 

4- 14.0, 7.63). 

DO Statements, DIMENSION Statements, and Sub- 
scripted Variables 

Example 3: Set Q max equal to the largest quantity 
P(a,+6,)/P(a< — bi) for some i between 1 and 1000 
where P(x) =c 0 +c 1 x-|-C 2 X 2 -rC 3 -t 3 . 

FOR T RA N Program : 

1) POLYF(X) =C04-X- (C14-X. (C2-|-X«C3)). 

2) DIMENSION A(1000), B(1000). 

3) QMAX= -1.0 E20. 

4) DO 5 1 = 1, 1000. 

5) QM AX = M AXF (QMAX, POLYF(A(I) 

+B(I))/POLYF(A(I)-B(I))). 

6) STOP. 

The program above is complete except for input and 
output statements which will be described later. The 
first statement is not executed; it defines the desired 
polynomial (in factored form for efficient output pro- 
gram). Similarly, the second statement merely informs 
the executive routine that the vectors A and B each have 
1000 elements. Statement 3 assigns a large negative 
initial value to QMAX, — 1.0X10 20 , using a special 
concise form for writing floating-point constants. State- 
ment 4 says “DO the following sequence of statements 
down to and including the statement numbered 5 for 
successive values of I from l to 1000.” In this case 
there is only one statement 5 to be repeated. It is exe- 
cuted 1000 times; the first time reference is made to 
A(l) and B(l), the second time to A(2) and B(2), etc. 
After the 1000th execution of statement 5, statement 
6 — STOP— is finally encountered. In statement 5, 
the function MAXF appears. MAXF may have two 
or more arguments and its value, by definition, is the 
value of its largest argument. Thus on each repetition 
of statement 5 the old value of QMAX is replaced by 
itself or by the value of POLYF(A(I)4-B(I))/POLYF 
(A(I) — B(I)), whichever is larger. The value of QMAX 
after the 1000th repetition is therefore the desired 
maximum. 

Example 4: Multiply the nXn matrix a«,(n< 20) by 
its transpose, obtaining the product elements on or be- 
low the main diagonal by the relation 

n 

Ci.i = X) ai.k-aj.k (for j < i) 

and the remaining elements by the relation 

o j,i ~ C \ , j • 



190 


1957 WESTERN COMPUTER PROCEEDINGS 


C 


i 


L.. 

K 



FORTRAN Program: 

DIMENSION A(20, 20), C(20, 20) 



DO 2 

I = 1, N 

P 


DO 2 

J = 1, I 

1 

Q 

1 

! 

i 

C(I. J 

DO 1 

! = 0.0 

K = 1, N 

R 


1 1 

| CT.J 

= C(I, J) + A(I, 

K) * A(J, K) 



2 

r j. i 

) = C(I, J; 








STOP 


As in the preceding example, the DIMENSION 
statement savs that there are two matrices of maximum 
size 20X20 named A and C. For explanatory purposes 
only, the three boxes around the program show the 
sequence of statements controlled by each DO state- 
ment. The first DO statement says that procedure P, 
i.e., the following statements down to statement 2 (outer 
box) is to be carried out for I = 1 then for I = 2 and so 
on up to I =N. The first statement of procedure 
P(DO 2 J = 1. I) directs that procedure Q be done for 
J = 1 to J = I. And of course each execution of pro- 
cedure Q involves N executions of procedure R for 
IC = 1, 2, • • ■ , N. 

Consider orocedure Q. Each time its last statement 
is completed the “index” J of its controlling DO state- 
ment is increased by 1 and control goes to the first 
statement of Q, until finally its last statement is reached 
and J = I. Since this is also the last statement of P and 
P has not been repeated until I =N, I will be increased 
and control will then pass to the first statement of P. 
This statement (DO 2 J=l. I) causes the repetition 
of Q to begin again. Finally, the last statement of Q and 
P (statement 2) will be reached with J = I and I = N, 
meaning that both Q and P have been repeated the 
required number of times. Control will then go to the 
next statement, STOP. Each time R is executed a new 
term is added to a product element. Each time Q is 
executed a new product element and its mate are ob- 
tained. Each time P is executed a product row (over to 
the diagonal) and the corresponding column (down to 
the diagonal! are obtained. 

The last example contains a “nest” of DO state- 
ments, meaning that the sequence of statements con- 
trolled by one DO statement contains other DO state- 
ments. Another example of such a nest is shown in the 
next column, on the left. Nests of the type shown on the 
right are not permitted, since they would usually be 
meaningless. 

Although not illustrated in the examples given, the 
programmer may also employ subscripted variables 
having three independent subscripts. 



Other . 

In t 
TRA> 


atten 


exam 

TRA 


ment 

analo 

vide 

auxil : 

pilin' 

of co 

arise 

vidin 

trans 

be t'o 

TRA 


READ, PRINT, FORMAT. IF and GO TO Stateme 

Example 5: For each case, read from cards two ■ __ 
tors, ALPHA and RHO, and the number ARG. ALPHi 
and RHO each have 25 elements and ALPHA(I| 
< ALPHA(I-f-l), 1 = 1 to 24. Find the SUM of alljtfl 
elements of ALPHA from the beginning to the la 
one which is less than or equal to ARG [assure 
ALPHA(l) <ARG<ALPHA(25)]. If this last eleme 
is the -Yth, set VALUE = 3. 14159 * RHO(iV). Print 
line for each case with ARG, SUM, and VALUE. Mj 

J 

FORTRAN Program: 

DIMENSION ALPHA(25), RHO(25) 

1) FORMAT(5F12.4). 


2 ) 


3) 

4) 


READ 1, ALPHA. RHO, ARG 
SUM =0.0 
DO 3 1 = 1, 25 

IF (ARG — ALPHAiI)) 4, 3, 3. 
SUM =SUM+ALPHA(I) 
VALUE = 3.14159 * RHO(I - 1) 
PRINT 1, ARG. SUM, VALUE 
GO TO 2. 


The FORMAT statement says that numbers an 
3 e found (or printed) J per card (or line), that|®8 
cumber is in fixed point form, that each number; Jj 
;upies a field 12 columns wide and that the decimi 
joint is located 4 digits from the right. The FORMA 
statement is not executed; it is referred to by the RE|| 
end PRINT statements to describe the desired arranff 
ment of data in the external medium. ; r '.wT 

The READ statement says “ READ cards ini 
card reader which are arranged according to FORM^ 
statement 1 and assign the successive numbers obtain 
as values of ALPHAS I) 1 = 1, 25 and RHO( I) I - 
and ARG.” Thus “ALPHA, RHO, ARG” is a deserp 
tion of a list of 51 quantities (the size of ALPHA, a| 
RHO being obtained from the DIMENSION star 
ment). Reading of cards proceeds until these 51 qua?P 
ties have been obtained, each card having five numb?| 
as per the FORMAT description, except the last whij 
has the value of ARG only. Since ARG terminated^ 
list, the remaining four fields on the last card are ,nc 
read. The PRINT statement is similar to READ excepfl 
that it specifies a list of only three quantities. Thii^ 


each ex' 
printed 

three of 
ment L 
The 

neg.Hiv 
5. T.id 
of i he 

norniall 
zero or 
the ne> 
creased 

ARG b 
Note i 
quell vc 
tion sp‘ 
the ind 
ALPH. 
(19) w. 

The 
statenn 
next c; 
more c. 
comple 
piled, 
progra 


Backus et ai: The FORTRAN Automatic Coding System 


191 



each execution 


TO Statements | 

cat i two vec- 
Al- ALPHA 
id ALPHA(I) 
>UM of all the 
ig ) the last 
AR _• [assume 
is last element; 
0(.' L Print a' 
V, ,UE. 


25' 


un ers are to 
ne] that each 
:h number oc- 
it the 

fhi 'ORMA 
b; he READ^ 
jsired arrange-?) 

isS-1 


c 

ds in the 

f to 

FORMAl 

fibers obtained* 

TC 

-) 1 = 1,23 

n ■ 

a descrip* 

f Alpha an(* 

NS I ON statel 

ies 

31 quanfal 

j ti 

numbers! 

the 

last whiclj 

errr 

mated th« 

t c 

d are nof 


AD except* 

anti ties. Thui 


of PRINT causes a single line to be 
printed with ARG. SUM, VALUE printed in the first 
ihree of the five fields described by FORMAT state- 
ineiit 1. 

The IF statement says “If ARG — ALPHA{T) is 

"i’-tive go to statement 4, if it is zero go to statement 
, and if it is positive go to 3.” Thus the repetition 
of the two statements controlled by the DO consists 
normally of computing ARG— ALPHA(I), finding it 
zero or positive, and going to statement 3 followed by 
the next repetition. However, when I has been in- 
creased to the extent that the first ALPHA exceeding 
\RG is encountered, control will pass to statement 4. 
\, ,:e i hat this statement does not belong to the se- 
controlled by the DO. In such cases, the repeti- 
tion specified by the DO is terminated and the value of 
the index (in this case I) is preserved. Thus if the first 
ALPHA exceeding ARG were ALPHA (20), then RHO 
(19) would be obtained in statement 4. 

The GO TO statement, of course, passes control to 
statement 2, which initiates reading the 11 cards for the 
next case. The process will continue until there are no 
more cards in the reader. The above program is entirely 
complete. When punched in cards as shown, and com- 
piled. the translator will produce a ready-to-run 704 
program which will perform the job specified. 

Other Types of FORTRAN Statements 

In the above examples the following types of FOR- 
TRAN statements have been exhibited. 

Arithmetic statements 
Function statements 
DO statements 
IF statements 
GO TO statements 
READ statements 
PRINT statements 
STOP statements 
DIMENSION statements 
FORMAT statements. 

The explanations accompanying each example have 
attempted to show some of the possible applications and 
variations of these statements. It is felt that these 
examples give a representative picture of the FOR- 
TRAN language: however, many of its features have 
had to be omitted. There are 23 other types of state- 
ments in the language, many of them completely 
analogous to some of those described here. They pro- 
vide facilities for referring to other input-output and 
auxiliary storage devices (tapes, drums, and card 
punch), for specifying preset and computed branching 
01 control, for detecting various conditions which may 
arise such as an attempt to divide by zero, and for pro- 
viding various information about a program to the 
translator. A complete description of the language is to 
he found in Programmer’ s Reference Manual, the FOR- 
TRAN Automatic Coding System for the IBM 704. 


Preparation of a Program for Translation 

The translator accepts statements punched one per 
card (continuation cards may be used for very long 
statements). There is a separate key on the keypunch- 
ing device for each character used in FORTRAN state- 
ments and each character is represented in the card by 
several holes in a single column of the card. Five 
columns are reserved for a statement number (if pres- 
ent) and 66 are available for the statement. Keypunch- 
ing a FORTRAN program is therefore a process similar 
to that of typing the program. 

Translation 

The deck of cards obtained by keypunching may- 
then be put in the card reader of a 704 equipped with 
the translator program. When the load button is pressed 
one gets either 1) a list of input statements which fail 
to conform to specifications of the FORTRAN language 
accompanied by remarks which indicate the type of 
error in each case; 2) a deck of binary cards representing 
the desired 704 program, 3) a binary tape of the program 
which can either be preserved or loaded and executed 
immediately after translation is complete, or 4) a tape 
containing the output program in symbolic form suitable 
for alteration and later assembly. (Some of these out- 
puts may be unavailable at the time of publication.) 

The FORTRAN Translator 
General Organization of the System 

The FORTRAN translator consists of six successive 
sections, as follows. 

Section 1: Reads in and classifies statements. For 
arithmetic formulas, compiles the object (output) in- 
structions. For nonarithmetic statements including 
input-output, does a partial compilation, and records 
the remaining information in tables. All instructions 
compiled in this section are in the COMPAIL file. 

Section 2: Compiles the instructions associated with 
indexing, which result from DO statements and the oc- 
currence of subscripted variables. These instructions 
are placed in the COMPDO file. 

Section 3: Merges the COMPAIL and COMPDO 
files into a single file, meanwhile completing the compila- 
tion of nonarithmetic statements begun in Section 1. 
The object program is now complete, but assumes an 
object machine with a large number of index registers. 

Section 4: Carries out an analysis of the flow of the 
object program, to be used by Section 5. 

Section 5: Converts the object program to one which 
involves only the three index registers of the 704. 

Section 6: Assembles the object program, producing 
a relocatable binary program ready for running. Also 
on demand produces the object program in SHARE 
symbolic language. 

{Note: Section 3 is of internal importance only; Sec- 
tion 6 is a fairly conventional assembly program. These 
sections will be treated only briefly in what follows.) 



Ill 

are ir 
whirl 
iinr !; 
ami 

+M 


tioni* 

rou*. 

variv. 

cntir 
ever 
is eir 
press 
one i 
been 
ing s- 
were 


T 
scan 
appi 
is cl 
ope. 
inci 
deh 
u 9 w 

Sim 
dele 
to ( 


T 

pro» 


i 1 -* - 






% 






1957 WESTERN COMPUTER PROCEEDINGS 


Within the translator, information is passed from 
section to section in two principal forms: as compiled 
instructions, and as tables. The compiled instructions 
(e.g., the COMPAIL and COMPDO files, and later their 
merged result) exist in a four-word format which con- 
tains all the elements of a symbolic 704 instruction; 
i.e., symbolic location, three-letter operation code, sym- 
bolic address with relative absolute part, symbolic tag, 
and absolute decrement. (Instructions which refer to 
quantities given symbolic names by the programmer 
have those same names in their addresses.) This sym- 
bolic format is retained until section 6. Throughout, the 
order of the compiled instructions is maintained by 
means of the symbolic locations (internal statement 
numbers . which are assigned in sequential fashion by 
section 1 as each new statement is encountered. 

The tables contain all information which cannot yet 
be embodied in compiled instructions. For this reason 
the translator requires only the single scan of the source 
program performed in section 1. 

A final observation should be made about the organ- 
ization of the system. Basically, it is simple, and most 
of the complexities which it does possess arise from the 
effort to cause it to produce object programs which 
can compete in efficiency with hand-written programs. 
Some of these complexities will be found within the 
individual sections; but also, in the system as a whole, 
the sometimes complicated interplay between compiled 
instructions and tables is a consequence of the desire to 
postpone compiling until the analysis necessary to 
produce high object-program efficiency has been per- 
formed. 

Section 1 Beeber, Herrick, Nutt, Sheridan, and Stern ) 

The over-all flow of section 1 is 

Read and classify next source statement No more 
*" and assign internal statement number statements 

Input-output Arithmetic Others 

Treat statement Treat statement Treat statement 

1 1 1 r 

i i i L 

| Section 2 [ 

For airinput-output statement, section 1 compiles the 
appropriate read or write select (RDS or WRS) in- 
struction. and the necessary copy (CPY) instructions 
(for binary operations) or transfer instructions to pre- 
written input-output routines which perform conver- 
sion between decimal and binary and govern format (for 
decimal operations). When the list of the input-output 
statement is repetitive, table entries are made which 
will cause section 2 to generate the indexing instructions 
necessary to make the appropriate loops. 

The treatment of statements which are neither input- 
output nor arithmetic is similar; i.e., those instructions 


which can be compiled are compiled, and the remaii 
information is extracted and placed in one or more 
the appropriate tables. 

In contrast, arithmetic formulas are complet< 
treated in section 1, except for open (built-in) 
routines, which are added in section 3; a complete 
of compiled instructions is produced in the COMPAQ 
file. This compilation involves two principal tasks:' 
the generation of an appropriate sequence of ari 
metic instructions to carry out the computation sp 
fied by the formula, and 2) the generation of (symbolic 
tags for those arithmetic instructions which refer 
subscripted variables (variables which denote arrays) 
which in combination with the indexing instructions 
be compiled in section 2 will refer correctly to the in 
vidual members of those arrays. Both these tasks, 
accomplished in the course of a single scan of the £ or 
mula. 

Task 2) can be quickly disposed of. When a s 
scripted variable is encountered in the scan, its su 
script(s) are examined to determine the symbols us 
in the subscripts, their multiplicative coefficients, 
the dimensions of the array. These items of informa 
are placed in tables where they will be availabl 
section 2 ; also from them is generated a subscript coi 
bination name which is used as the symbolic tag)) 
those instructions which refer to the subscripted va 
able. iyf - * 

The difficulty in carrying out task 1) is one of lent, 
there is implicit in every arithmetic formula an ord 
computation, which arises from the control over ordi 
ing assigned by convention to the various sym 
(parentheses, +, — , «, /, etc.) which can appear, 'afi 
this implicit ordering must be made explicit befc 
compilation of the instructions can be done. This , 
plicitness is achieved, during the formula scaria 
associating with each operation required by the form! 
a level number, such that if the operations are carri 
out in the order of increasing level number the cdi 
sequence of arithmetic instructions will be obtained. v 
sequence of level numbers is obtained by means jo 
set of rules, which specify for each possible pair fo: 
of operation type and symbol type the increment tod 
added to or subtracted from the level number offi 
preceding pair. 

In fact, the compilation is not carried out witfii| 
raw set of level numbers produced during the 
After the scan, but before the compilation, the le 
are examined for empty sections which can be dele 
for permutations of operations on the same level w 
will reduce the number of accesses to memory, and- 
redundant computation (arising from the existence; 
common subexpressions) which can be eliminated, if 

An example will serve to show (somewhat inaccura 
ly) some of the principles employed in the level-anal 
process. Consider the following arithmetic expression :ir 





Backus et al.: The FORTRAN Automatic Coding System 


193 


th< 


emainins 


ne or more of f 

l! i 

e >mpletel|ri 
bu -in) sub- 

i complete. Set? ■ 

le rOMPAlLft 

:ip£ tasks: 1)-* 
no. of arith-j | 
station sped-|l 
of ' ymbolic) || 
r hi( refer to 
enote arrays)/ 
nstructions to 
ly the indi-. 
ies. :asks are’,; 
an of the for-i 


W 1 n a sub- : 
sea , its sub-,: 
symbols used: 
:ffi<- : -:nts, and) 
if i Donation! 

available tog 
ibscript com- 
nbi c tag of 
scr :ed vari- g 

> one of level;; 
la , order of 
1 c :r order- 
ious symbols 
i a^ear, and _ 
cpl t before, I 
snt. This ex-; 
rla scan, by 
Y t! formula .§ 
s i \ carried 

w,~ 

:r tne correct 
ibtained. The. , 1 
’ n ms of a 
; p ■ form* 
rement to be 
imh“r of the! 

ou- with the 
ng the scanjl 
n, he level; 
n 1 deleted; 
i level whii 
lory, and for 
ex tence off 

•IP 


ir d. 
inaccurat 
vel-analysis: 
:p ssionrif 


,1 + B* *C*(E + F). 

In the level analysis of this expression parentheses 
ire in effect inserted which define the proper order in 
which the operations are to be performed. If only three 
implied levels are recognized (corresponding to +, * 
ami *) the expression obtains the following: 

-)-(*(« *d)) + ( * (’* * B* »C) » [+(»(* * £)) + (* (« »F)) J). 

The brackets represent the parentheses appearing in the 
original expression. (The level-analysis routine actually 
recognizes an additional level corresponding to func- 
tions.) Given the above expression the level-analysis 
routine proceeds to define a sequence of new dependent 
vu-ud'k". the first of which represents the value of the 
t .ni it - expression. Each new variable is generated when- 
ever a left parenthesis is encountered and its definition 
is entered on anocher line. In the single scan of the ex- 
pression it is often necessary to begin the definition of 
one new variable before the definition of another has 
been completed. The subscripts of the u’s in the follow- 
ing sets of definitions indicate the order in which they 
were defined. 

110 = “b U\ -f- Uz 

111 = * U 2 

7(2 = * * A 

Uz = * zl 4 . Uz 

Hi ~ * * B * * C 

Us = + u 6 -r 7<s 

«6 = *U 7 

u 7 = * * E 

U% = * 

u$ — * *F. 

This is the point reached at the end of the formula 
scan. What follows illustrates the further processing 
applied to the set of levels. Notice that « 9 , for example, 
is defined as * « F. Since there are not two or more 
operands to be combined the * * serves only as a level 
intimation and no further purpose is served by having 
defined iig. The procedure therefore substitutes F for 

wherever w 9 appears and the line « 9 = * * Fis deleted. 
Similarly, F is then substituted for « 8 and u s = * F is 
deleted. This elimination of “redundant” u’s is carried 
to completion and results in the following: 

«o = + A + :< 3 

M 3 = * 11 ^ 

U\ = * * B * * C 

»s = + E + F. 

These definitions, read up, describe a legitimate 
procedure for obtaining the value of the original ex- 


pression. The number of us remaining at this point 
(in this case four) determines the number of intermedi- 
ate quantities which may need to be stored. However, 
further examination of this case reveals that the result 
of u z is in the accumulator, ready for u 0 \ therefore the 
store and load instructions which would usually be 
compiled between u 3 and Ug are omitted. 

Section 2 ( Nelson and Ziller) 

Throughout the object program will appear in- 
structions which refer to subscripted variables. Each 
of these instructions will (until section 5) be tagged with 
a symbolic index register corresponding to the particu- 
lar subscript combination of the subscripts of the varia- 
ble [ e.g ., (/, K, J) and ( K , I. J) are two different sub- 
script combinations]. If the object program is to work 
correctly, every symbolic index register must be so 
governed that it will have the appropriate contents at 
every instant that it is being used. It is the source pro- 
gram, of course, which determines what these appro- 
priate contents must be, primarily through its DO 
statements, but also through arithmetic formulas (e.g. 
7 = iV+l) which may define the values of variables ap- 
pearing in subscripts, or input formulas which may 
read such values in at object time. Moreover, in the 
case of DO statements, which are designed to produce 
loops in the object program, it is necessary to provide 
tests for loop exit. It is these two tasks, the governing 
of symbolic index registers and the testing of their 
contents, which section 2 must carry out. 

Much of the complexity of what follows arises from 
the wish to carry out these tasks optimally; i.e., when 
a variable upon which many subscript combinations de- 
pend undergoes a change, to alter only those index 
registers which really require changing in the light of 
the problem flow, and to handle exits correctly with 
a minimum number of tests. 

If the following subscripted variable appears in a 
FORTRAN program 

A(2*I + 1, 4.7-3, 6 *K + 5), 

the index quantity which must be in its symbolic index 
register when this reference to A is made is 

(cii — 1) + (c 2 j — l)d; -r (czk — \)didj -f 1, 

where c u c 2 , and c 3 in this case have the values 2, 4, and 
6 ; i, j, and k are the values of I, 7, and K at the moment, 
and di and dj are the J and 7 dimensions of A. The 
effect of the addends 1, 3, and 5 is incorporated in the 
address of the instruction which makes the reference. 

In general, the index quantity associated with a sub- 
script combination as given above, once formed, is not 
recomputed. Rather, every time one of the variables in 
a subscript combination is incremented under control of 
a DO, the corresponding quantity is incremented by 
the appropriate amount. In the example given, if K 


194 


1957 WESTERN COMPUTER PROCEEDINGS 


I 


§> , 




is increased by n (under control of a DO), the index 
quantity is increased by c 3 did,n, giving the correct new 
value. The following paragraphs discuss in further detail 
the ways in which index quantities are computed and 
modified. 

Choosing the Indexing Instructions ; Case of Subscripts 
Controlled by DO's 

We distinguish between two classes of subscript; 
those which are in the range of a DO having that sub- 
script as its index symbol, and those subscripts which 
are not controlled by DO's. 

The fundamental idea for subscripts controlled by 
DO’s is that a sequence of indexing instruction groups 
can be selected to answer the requirements, and that 
the choice of a particular instruction group depends 
mainly on the arrangement of the subscripts within the 
subscript combination and the order of the DO’s con- 
trolling each subscript. 

DO's often exist in nests. A nest of DO’s consists of 
all the DO's contained by some one DO which is itself 
not contained by any other. Within a nest, DO’s are 
assigned level numbers. Wherever the index symbol of a 
DO appears as a subscript within the range of that DO, 
the level number of the DO is assigned to the subscript. 
The relative values of the level numbers in a subscript 
combination produce a group number which, along with 
other information, determines which indexing instruc- 
tion group is to be compiled. 

The source language, 

DO 10 I = 1, 5 
DO 10 / = 1, 5 
DO 5 K = 1,7 

5 At I. J, K) ■■ ■ (some statement referring to 

-m. j, k)) 

DO 10 K = J, 5 
10 • • • .4 (K. /,/)••■ 

produces the following DO structure and group combi- 
nations: 


level 2 
level 3 


I, J, K - 


K, J, I - 


(1,2, 3) 


(3, 2, 1) 


group no. 
>6 


1 3 

S 

% 




The decrement parts of the FORTRAN index! 
instructions are functions of the dimensions of arra 
and of the parameters of DO’s; that is, of the ini 
value »i, the upper bound n 2 , and the increment? 1 
appearing in the statement DO 1 i — n^ n 2 , n 3 . 
general form of the function is [(«. — ni+nf)/n 3 
where g represents necessary coefficients and dim 
sions, and [x] denotes the integral part of x. 

If all the parameters are constants, the decremei 
parts are computed during the execution of the FOR 
TRAN executive program. If the parameters are van 
able symbols, then instructions are compiled in th 
object program to compute the proper decrement val 
ues. For object program efficiency, it is desirable^ 
associate these computing instructions with the out 
most DO of a nest, where possible, and not with thl 
inner loops, even though these inner DO’s may havl 
variable parameters. Such a variable parameter («.gj 
N in “DO 7 1=1, N~) may be assigned values by thl 
programmer by any of a number of methods; it majtbj 
a value brought in by a READ statement, it may $ 
calculated by an arithmetic statement, it may take:$ 
value from a transfer exit from some other DO whdS 
index symbol is the pertinent variable symbol, or it mail 
be under the control of a DO in the nest. A searchfi: 
made to determine the smallest level number in ttii 
nest within which the variable parameter is not assigrel 
a new value. This level number determines the plac 
at which computing instructions can best be compile! 

Case of Subscripts not Controlled by DO's 

The second of the two classes of subscript symbols:! 
that of subscript symbols which are not under contro 
of DO's. Such a subscript can be given a value inlj 
number of ways similar to the defining of DO parain 
eters: a value may be read in by a READ statemejM 
it may be calculated by an arithmetic statement, . 0^1 
may be defined by an exit made from a DO with'th® 
index symbol. 

For subscript combinations with no subscript undl| 
the control of a DO, the basic technique used to introi 
duce the proper values into a symbolic index registe3jj 
that of determining where such definitions occur, (a||| 
at the point of definition, using a subroutine to compiitj 
the new index quantity. These subroutines are generate! 
at executive time, if it is determined that theyTaS 
necessary. 

If the index quantity exists in a DO nest at the tun 
of a transfer exit, then no subroutine calculation's® 
necessary since the exit values are precisely the desire* 
values. 


Producing the Decrement Parts of Indexing Instructions Mixed Cases 

The part of the 704 instruction used to change or test In cases in which some subscripts in a subscript coin 
the contents of an index register is called the decrement bination are controlled by DO’s, and some are noli 
part of the instruction. instructions are compiled to compute the initial valji' 


Backus el al.: The FORTRAN Automatic Coding System 


i indexing; 

3 of arrays? 

th initial! : 
:re int 
iii n 3 . The 

md limen-f 

decrement; 

; th FOR-' 
rs 5 vari- f 
ilea in the 
•ement val- 
les .ble to 
i tl outer- 1 
Dt with the 
i may have 
me r (e.g., 
lu< by the 
5 ; it may be 
, it may be 
lay ake its. 


d 1, or it may ; 
A arch is 
nb in the"! 
not assigned;- 
;s the placef 
ie mpiled.l 


-t s nbols is*' 
nd control!; 
i value inialj 
DO param- 1 
) s tement, 
:en it, or it 
'0 with that 

m 

sci t under- 
sea ;o intro-; 
ex register i? 

» o ur, andj 
j t :ompute 
ire generated 
lat they are 

t a the time 
culations are., 
v the desirecjl 


ibs ipt com 
>m are not 
initial valu< 


, the subscript combination at the beginning of the 
0 de loop. If the non-DO-controlled subscript sym- 
rTis then defined inside the loop (that is, after the 
• ° limiting of the load quantity) the procedure of using 
Subroutine at the point of subscript definition will 
"...r -he new value into the index register. 

'"\n exception to the use of a subroutine is made when 
, ‘ subscript is defined by a transfer exit from a DO, 

' K | = t hat DO is within the range of a DO controlling 
'ome other subscript in the subscript combination, 
in such instances, if the index quantity is used in the 
liner DO, no calculation is necessary; the exit values 
111 ase( j if the index quantity is not used, instructions 
'! r<1 ,-ompiled to simulate this use, so that in either case 
t'h'e '-r-u-sfer exit leaves the correct function value in 
the index register. 

Modification and Optimization 

Initializing and computing instructions correspond- 
ing to a given DO are placed in the object program at a 
point corresponding to the lowest possible (outermost) 


point luiiwpw — 'a 1 

DO level rather than at the point corresponding to the 
.-riven DO. This technique results in the desired removal 
ot certain instructions from the most frequent inner- 
most loops of the object program. However, it necessi- 
tates the consideration of some complex questions when 
the fiow r within--a nest of DO’s is complicated b\ the 
occurrence of transfer escapes from DO-type repetition 
and by other IF and GO TO flow paths. Consider a 
simple example, a nest having a DO on I containing a 
DO on /, where the subscript combination (I , J) appears 
onlv in the inner loop. If the object program corre- 
sponded precisely to the FORTRAN language pro- 
gram, there would be instructions at the entrance point 
of the inner loop to set the value of J in (7, J ) to the 
initial value specified by the inner DO. Usually, how- 
ever, it is more efficient to reset the value of J in (I, J ) 
at the end of the inner loop upon leaving it, and the ob- 
ject program is so constructed. In this case it becomes 
necessary to compile instructions which follow ever} 
transfer exit from the inner loop into the outer loop (if 
there are any such exits) which will also reset the value 
of J in (/, J) to the initial value it should have at the 
entrance of the inner loop. These instructions, plus the 
initialization of both I and J in (7, J) at the entrance 
of the outer loop (on I), insure that J always has its 
proper initial value at the entrance of the inner loop 
even though no instructions appear at that point which 
change J. The situation becomes considerably more 
complicated if the subscript combination (I, J) also ap- 
pears in the outer loop. In this case two independent 
index quantities are created, one corresponding to 
(7, J) in the inner loop, the other to (7, J) in the outer 
loop. 

Optimizing features play an important role in the 
modification of the procedures and techniques outlined 
above. It may be the case that the DO structure and 


subscript combinations of a nest describe the scanning 
of a two- or three-dimensional array which is the equiva- 
lent of a sequential scan of a vector; i.e., a reference 
to each of a set of memory locations in descending order. 
Such an equivalent procedure is discovered, and where 
the flow of a nest permits, is used in place of more com- 
plicated indexing. This substitution is not of an empiri- 
cal nature, but is instead the logical result of a general- 
ized analysis. 

Other optimizing techniques concern, for example, 
the computing instructions compiled to evaluate the 
functions (governing index values and decrements) men- 
tioned previously. When some of the parameters are 
constant, the functions are reduced at executive time, 
and a frequent result is the compilation of only one 
instruction, a reference to a variable, to obtain a proper 
initializing value. 

In choosing the symbolic index register in which to 
test the value of a subscript for exit purposes, those 
index registers are avoided which would require the 
compilation of instructions to modify the test instruc- 
tion decrement. 


Section 4 ( Haibt ) and Section 5 Best) 

The result of section 3 is a complete program, but one 
in which tagged instructions are tagged only sym- 
bolically, and which assumes that there will be a real 
index register available for ever}' symbolic one. It is the 
task of sections 4 and 5 to convert this program to one 
involving only the three real index registers of the 704. 
Generally, this requires the setting up, for each symbolic 
index register, of a storage cell which will act as an 
index cell , and the addition of instructions to load the 
real index registers from, and store them into, the index 
cells This is done in section 5 ijag analysis) on the basis 
of information about the pattern and frequency ot flow 
provided by section 4 (flow analysis) in such away 
that the time spent in loading and storing index registers 
will be nearly minimum. 

The fundamental unit of program is the basic block; a. 
basic block is a stretch of program which has a single 
entry point and a single exit point. The purpose ot sec- 
tion 4 is to prepare for section 5 a table of predecessors 
(PRED table) which enumerates the basic blocks and 
lists for every basic block each of the basic blocks which 
can be its immediate predecessor in flow, together with 
the absolute frequency of each such basic block tin . 
This table is obtained by an actual “execution ' ot the 
program in Monte-Carlo fashion, in which the outcome 
of conditional transfers arising out of IF- type state- 
ments and computed GO TO's is determined by a ran- 
dom number generator suitably weighted according 
to whatever FREQUENCY statements have been pro- 
vided. . ■ 

Section 5 is divided into four parts, of which part 1 is 

the most important. It makes all the major decisions 
concerning the handling of index registers, but records 


196 


1957 WESTERN COMPUTER PROCEEDINGS 


I 


I 

Is 




I 


I 


I 


I 

I 


m 


them simply as bits in the PRED table and a table of 
all tagged instructions, the STAG table. Part 2 merely 
reorganizes those tables; part 3 adds a slight further 
treatment to basic blocks which are terminated by an 
assigned GO TO; and finally part 4 compiles the finished 
program under the direction of the bits in the PRED and 
STAG tables. Since part 1 does the real work involved 
in handling the index registers, attention will be con- 
fined to this part in the sequel. 

The basic flow of part 1 of section S is, 



- 

r A ■ v. 

* $ . 


I 


r 

Ite - 


Consider a moment partway through the execution 
of part 1, when a new region has just been treated. The 
less frequent basic blocks have not yet been encoun- 
tered; each basic block that has been treated is a mem- 
ber of some region. The existing regions are of two 
types: transparent, in which there is at least one real 
index register which has not been used in any of the 
member basic blocks, and opaque. Bits have been en- 
tered in the STAG table, calling where necessary for 
an LXD (load index register from index cell) instruc- 
tion preceding, or an SXD (store index register in index 
cell) instruction following, the tagged instructions of the 
basic blocks that have been treated. For each basic 
block that has been treated is recorded the required 
contents of each of the three real index registers for 
entrance into the block, and the contents upon exit. 
In the PRED table, entries that have been considered 
may contain bits calling for interblock LXD’s and 
SXD’s, when the exit and entrance conditions across the 
link do not match. 

Now the PRED table is scanned for the highest- 
frequency link not yet considered. The new region is 
formed by working both forward over successors and 
backward over predecessors from this point, always 
choosing the most frequent remaining path of control. 
The marking out of a new region is terminated by en- 
countering 1) a basic block which belongs to an opaque 
region, 2) a basic block which has no remaining links 
into it (when working backward) or from it (when 
working forward), or which belongs to a transparent 
region with no such links remaining, or 3) a basic block 
which closes a loop. Thus the new region generally 
includes both basic blocks not hitherto encountered, and 
entire regions of basic blocks which have already been 
treated. 

The treatment of hitherto untreated basic blocks in 
the new region is carried out by simulating the action 
of the program. Three cells are set aside to represent the 
object machine index registers. As each new tagged in- 
struction is encountered these cells are examined to see 


I 


if one of them contains the required tag; if not, th^ 
program is searched ahead to determine which of thi 
three index registers is the least undesirable to replac 
and a bit is entered in the STAG table calling forts 
LXD instruction to that index register. WhenhtlS 
simulation of a new basic block is finished, the ~ 
trance and exit conditions are recorded, and the n a# 
item in the new region is considered. If it is a new basic! 
block, the simulation continues; if it is a region,. th. 
index register assignment throughout the region:"* 
examined to see if a permutation of the index regist 
would not make it match better, and any remaining mi 
match is taken care of by entries in PRED calling fo: 
interblock LXD’s. .«$jj 

A final concept is that of index register activit 
When a symbolic index register is initialized, or wh 
its contents are altered by an indexing instruction, tfi 
value of the corresponding index cell falls out of dat 
and a subsequent LXD will be incorrect without 
intervening SXD. This problem is handled by activi: 
bits, which indicate when the index cell is out of da 
when an LXD is required the activity bit is interroga 
and if it is on an SXD is called for immediately after 
initializing or indexing instruction responsible fora 
activity, or in the interblock link from the region o 
taining that instruction, depending upon whether 
basic block containing that instruction was a new b 
block or one in a region already treated. n 

When the new region has been treated, all of : 
old regions which belonged to it simply lose their idi 
tity; their basic blocks and the hitherto untreated b; 
blocks become the basic blocks of the new region. :T 
at the end of part 1 there is but one single regiortyS 
it is the entire program. The high-frequency parts oft 
program were treated early; the entrance and exit o 
ditions and indeed the whole handling of the iffi 
registers reflect primarily the efficiency needs of : 
high-frequency paths. The loading and unloading o 
index registers is therefore as much as possible pljS 
in the low-frequency paths, and the object pro 
time consumed in these operations is thus brought- 
to a minimum. ■ 


3?, 


_ Ml* 






m 


ij« 4 Ift 4 1 


Conclusion 


m 


The preceding sections of this paper have des 
the language and the translator program of the E' 
TRAN system. Following are some comments o: 
system and its application. : 




I 


Scope of Applicability 

The language of the system is intended to be cap 
of expressing virtually any numerical procedure. S< 
problems programmed in FORTRAN language to 
include: reactor shielding, matrix inversion, nurw 
integration, tray-to-tray distillation, microwave pr< 
gation, radome design, numerical weather predic 
plotting and root location of a quartic, a procedur 
playing the game “nimy helicopter design, and a num 




t 

l 






Backus et nl. : The FORTRAN Automatic Coding System 


ta if not, th| I 
ne hich of the 
rable to replace^ 
le --fling for an 
ste When the 
inibued, the en-; 
d, and the next ! 
it a new basic t 

is region, the '; 

t the region i s | 

2 index registers | 

V r< aining mi s - | 
RE calling for 

if 

igip*-er activity. ; 
ali d, or when, 
ins,., uction, the 
ills out of date, 
ec without an - 
He by activity- 
1 is out of dates ; 

: is interrogated,;'; 
ilia ly after the|i. 
>or ble for the'; 
the region con- 
on whether the| 
va: l new basic 

ited, all of the | 
lor their iden- 1 
un :ated basic 
:w icgion. Thus 
gle region, and ' 
re; >arts of the; 
e ; d exit con- < 

? ot the index 
needs of these i 
nli ding of the 
po ble placed 1 ' 
■bject program ’ 
s b ■•ought near* : 


ha described 
n i the FOR- 
iments on the 


1 to be capable |? ! 
need ure. Some j 
lg ge to dat< | 
ioi , numerica ;» 
rowave propa- j? 
ler prediction, 
p cedure foi 
, auu a number y. 


of others. The sizes of these first programs range from 
about 10 FORTRAN statements to well over 1000, or 
in terms of machine instructions, from about 100 to 
7500. 

Conciseness and Convenience 

The statement of a program in FORTRAN lan- 
guage rather than in machine language or assembly 
program language is intended to result in a considerable 
reduction in the amount of thinking, bookkeeping, 
writing, and time required. In the problems mentioned 
in the preceding paragraph, the ratio of the number of 
output machine instructions to the number of input 
FORTRAN statements for each problem varied be- 
tween about 4 and 20. (The number of machine instruc- 
ra-w- does not include any library subroutines and thus 
represents approximately the number which would need 
to be hand coded, since FORTRAN does not normally 
produce programs appreciably longer than correspond- 
ing hand-coded ones.) The ratio tends to be high, of 
course, for problems with many long arithmetic expres- 
sions or with complex loop structure and subscript ma- 
nipulation. The ratio is a rough measure of the concise- 
ness of the language. 

The convenience of using FORTRAN language is 
necessarily more difficult to measure than its concise- 
ness. However the ratio of coding times, assembly pro- 
gram language vs FORTRAN language, gives some in- 
dication of the reduction in thinking and bookkeeping 
as well as in writing. This time reduction ratio appears 
to range also from about 4 to 20 although it is difficult 
to estimate accurately. The largest ratios are usually 
obtained by those problems with complex loops and 
subscript manipulation as a result of the planning of 
indexing and bookkeeping procedures by the translator 
rather than by the programmer. 

Education 

It is considerably easier to teach people untrained in 
the use of computers how to write programs in 
FORTRAN language than it is to teach them machine 
language. A FORTRAN manual specifically designed 
as a teaching tool will be available soon. Despite the 
unavailability of this manual, a number of successful 
courses for nonprogrammers, ranging from one to three 
days, have been completed using only the present ref- 
erence manual. 

Debugging 

The structure of FORTRAN statements is such that 
the translator can detect and indicate many errors 
"hich may occur in a FORTRAN-language program, 
h urthermore. the nature of the language makes it possi- 
ble to write programs with far fewer errors than are to 
be expected in machine-language programs. 

Of course, it is only necessary to obtain a correct 
FORTRAN-language program for a problem, therefore 
all debugging efforts are directed toward this end. Any 


errors in the translator program or any machine mal- 
function during the process of translation will be de- 
tected and corrected by procedures distinct from the 
process of debugging a particular FORTRAN program. 

In order to produce a program with built-in debugging 
facilities, it is a simple matter for the programmer to 
write various PRINT statements, which cause “snap- 
shots” of pertinent information to be taken at appropri- 
ate points in his procedure, and insert these in the deck 
of cards comprising his original FORTRAN program. 
After compiling this program, running the resulting 
machine program, and comparing the resulting snap- 
shots with hand-calculated or known values, the pro- 
grammer can localize the specific area in his FORTRAN 
program which is causing the difficulty. After making 
the appropriate corrections in the FORTRAN program 
he may remove the snapshot cards and recompile the 
final program or leave them in and recompile if the pro- 
gram is not yet fully checked. 

Experience in debugging FORTRAN programs to 
date has been somewhat clouded by the simultaneous 
process of debugging the translator program. However, 
it becomes clear that most errors in FORTRAN pro- 
grams are detected in the process of translation. So far, 
those programs having errors undetected by the trans- 
lator have been corrected with ease by examining the 
FORTRAN program and the data output of the ma- 
chine program. 

Method of Translation 

In general the translation of a FORTRAN program 
to a machine-language program is characterized by the 
fact that each piece of the output program has been 
constructed, instruction by instruction, so as not only 
to produce an efficient piece locally but also to fit effi- 
ciently into its context as a result of many considerations 
of the structure of its neighboring pieces and of the 
entire program. With the exception of subroutines (cor- 
responding to various functions and input-output 
statements appearing in the FORTRAN program), the 
output program does not contain long precoded instruc- 
tion sequences with parameters inserted during trans- 
lation. Such instruction sequences must be designed to 
do a variety of related tasks and are often not efficient 
in particular cases to which they are applied. 
FORTRAN-written programs seldom contain sequences 
of even three instructions whose operation parts alone 
could be considered a precoded “skeleton.” 

There are a number of interesting observations con- 
cerning FORTRAN-written programs which may throw 
some light on the nature of the translation process. 
Many object programs, for example, contain a large 
number of instructions which are not attributable to 
any particular statement in the original FORTRAN 
program. Even transfers of control will appear which 
do not correspond to any control statement ( e.g ., DO, 
IF, GO TO) in the original program. The instructions 
arising from an arithmetic expression are"optimally 


I 


I 






SR 

; 5m**? 


1057 WESTERN COMPUTER PROCEEDINGS 


arranged, often in a surprisingly different sequence than 
the expression would lead one to expect. Depending 
on its context, the same DO statement may give rise to 
no instructions or to several complicated groups of in- 
structions located at different points in the program. 

While it is felt that the ability of the system to trans- 
late algebraic expressions provides an important and 
necessary convenience, its ability to treat subscripted 
variables, DO statements, and the various input-output 
and FORMAT statements often provides even more 
significant conveniences. 

In any case, the major part of the translator program 
is devoted to handling these last mentioned facilities 
rather than to translating arithmetic expressions. (The 
near-optimal treatment of arithmetic expressions is sim- 
ply not as complex a task as a similar treatment of 
“housekeeping" operations.; A list of the approximate 
number of instructions in each of the six sections of the 
translator will give a crude picture of the effort expend- 
ed in each area. (Recall that Section 1 completely treats 


arithmetic statements in addition to performing a a 
ber of other tasks.) 


Section Number 
1 
2 

3 

4 

5 

6 


Number of Instructions tfj 
5500 ..jg 

0000 
2500 
3000 
5000 
2000 


T 


1 

1 

' hi 
:1 




The generality and complexity of some of the teclv! 
niques employed to achieve efficient output program^ 
may often be superfluous in many common application! 
However the use of such techniques should enable th 
FORTRAN system to produce efficient programs! 
important problems which involve complex and unusu; 
procedures. In any case the intellectual satisfaction 
having formulated and solved some difficult problems 
of translation and the knowledge and experience a 
quired in the process are themselves almost a sufficien 
reward for the long effort expended on the FORTRj 
project. • jjj 


: 

F 

h- 


The Interpretation and Attainment of Reliability f 
in Industrial Data Systems 


BRUCE K. SMITH f 


Purpose of an Industrial Data System 

T HE FIRST self-sequenced digital computer was 
a relay device conceived for the purpose of reliev- 
ing man of the tedium of involved computation. 
It was a docile slave, content (for the most part) to work 
a 24-hour day doing arithmetic faster, cheaper, and 
with fewer errors, than had theretofore been possible. 
Even before the incorporation of electronics, these capa- 
bilities were being utilized on problems which were en- 
tirely unreasonable for manual solution. The modern 
digital computer represents a considerably faster, more 
versatile, and more reliable instrument than its prede- 
cessor, but the advances in capability have been hard 
pressed to keep pace with the advances in application. 
It may truly be said at this writing that there is no 
foreseeable limit to either the speed or the reliability 
which can be profitably utilized. 

Industrial data-handling systems have been con- 
ceived for the purpose of relieving man of the tedium of 
data gathering, data interpretation, and the use of in- 
terpreted data in factory control. We want, in essence, 
another docile slave who knows nothing of time clocks, 

t Beckman Instruments, Inc. Fullerton, Calif. 


Kf. 


and who will do our present tasks with greater accurac: 
speed, economy, and reliability than presently possib 
through manual methods. We must expect that the i 
troduction of such devices will permit manufacturin' 
techniques heretofore considered unreasonable becau 
of human limitations. We must, therefore, expect th 
considerably greater demands will be made of StB 
equipment than originally intended. There is no . sue 
thing as enough reliability, or enough capability in* 
data-handling system which is to be modern both .0 
the drawing board and on the day of installation. This 
does not imply any futility to construction with th 
means presently available, but rather the realizatio 
that these means can never be sufficient. 

«•; t $3 | 

The System as a Digital Computer 

•-*'**P 

Automatic process control requires the continuing 
development of suitable end instruments for measure- 
ment of physical and chemical process variables. The in- 
strumentation must, in many cases, be extremely accu- 
rate, and must in all cases produce outputs which may 
be scanned and monitored at a centralized facility. Com 
plete processing of this information for a closed-loop 
control system necessarily implies some computing 


§ 


ability, 
handle 
process 
compu 
ized ii 
much 
as sim 
growth 

The 
is usel 
requiri 
systen 
readil 
tolera 
higher 
com p< 
Fail 


