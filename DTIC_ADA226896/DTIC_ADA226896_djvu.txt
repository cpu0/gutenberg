0 F;, 


CORY 


TATION PAGE j 

gs AD-A226 896 


t w fcih t < w B.Dcao>oa. 

MTE 


«. REPORT TYPE AM) DATES COVERED 

Fina fe9 May 1990 to 09 May 1991 


*-TITLE AND SUBTITLE Ada Compiler Validation Summary Report: SYSTEAM KG 
SYSTEAM Ada Compiler VAX/VMS 1.82, VAX 8530 (Host & Target), 
90050911.11009 

S.FUKMNG NUMBERS 

i.AUTH0R(S) 

IABG-AVF 

Ottobrunn, FEDERAL REPUBLIC OF GERMANY 


7. PERFORMSNG ORGANIZATION NAMC(S) AfC AOORESS(ES) 

IABG-AVF, Industrieanlagen-Betrieb sge selschaf t 

Dept. SZT 

Einsteinstrasse 20 

D-8012 Ottobrunn 

FEDERAL REPUBLIC OF* GERMANY 

A PERFORMING ORGANIZATION 

REPORT NUMBER 

IABG-VSR-065 

A S'ONSORNGAAONITORNG AGENCY NAME(S) AND AOORESS(ES) 

i,d.i Joint Program Office 

United States Department of Defense 

Washington, D.C. 20301-3081 

10. SPONSORNG/MONTTORNG AGENCY 
REPORT NUMBER 

11. SUPPLEMENTARY NOTES 

12a. OSTRBUnONlAVAtABUTY STATEMENT 

Approved for public release; distribution unlimited. 

12b. DSTRBUnON COOE 


IS. ABSTRACT (Outrun200 won*; 

SYSTEAM KG, SYSTEAM Ada Compiler VAX/VMS 1.82, Ottobrunn, West Germany, VAX 8530 under 
VMS, Version 5.1 (Host & Target), ACVC 1.11. 


- OTIC 

C l LECTt: m 

L SEP 2 5 1990| 


i«. SUBJECT TEAMS Ada programming language, Ada Compiler Validation 
Summary Report, Ada Compiler Validation Capability^ Validation 
Testing, Ada Validation Office, Ada Validation Facility, ANSI/MIL- 
STD-1815A, Ada Joint Program Office 


It. NUMBER OF RAGES 


It. PRICE COOE 


1 


** jVWV: 


'REPORT 

CLASSIFIED 




r ' «rI, JVTT T1' j vr > 





imucT 

UNCLASSIFIED 




















CHAPTER 1 
INTRODUCTION 


A 


This Validation Summary Report ' (VSR^ describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results o f,- test ing this compiler using the Ada Compiler 
Validation Capability ^fACVU)^ An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that is 
not in the Standard. 




c 


Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between implementations. 
The Ada Standard permits some implementation dependencies—for example, the 
maximum length of identifiers or the maximum values of integer types. 
Other differences between compilers result from the characteristics of 
particular operating systems, hardware, or implementation strategies. All 
the dependencies observed during the process of testing this compiler are 
in rhjg report. s ) 


The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. '\The purpose of validating is to ensure conformity 
of the compiler to the A^a Standard by testing that the compiler properly 
implements legal language constructs and that it identifies and rejects 
illegal language constructs. The testing also identifies behavior that is 
implementation-dependent biit is permitted by the Ada Standard. Six classes 
of tests are used. These\tests are designed to perform checks at compile 
time, at link time, and during execution. 



e 


1-1 






AVF Control Number: IABG-VSR-065 

11 June 1990 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: #90050911.11009 
SYSTEAM KG 

SYSTEAM Ada Compiler VAX/VMS 1.82 
VAX 8530 Host and Target 


Prepared By: 
IABG mbH, Abt. ITE 
Einsteinstrasse 20 
D-8012 Ottobrunn 
West Germany 








Certificate Information 


> 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on 09 May 1990. 

Compiler Name and Version: SYSTEAM Ada Compiler VAX/VMS 


Host Computer System: 
Target Computer System: 


Version 1.82 

VAX 8530 under VMS, Version 5.1 
VAX 8530 under VMS, Version 5.1 


A more detailed description of this Ada implementation is found in section 
3.1 of thi3 report. 


As a result of this validation effort, Validation Certificate 

awarded to SYSTEAM KG. This certificate 
expires on 01 June 1992. 


This report has been reviewed and is approved. 


jLiU ^ o— J-Jl 

IABG mbH, Abt. ITE 
Michael Tonndorf 
Einsteinstrasse 20 
D-8012 Ottobrunn 
West Germany 


-:— fr -—- -----=- 

Ada Validation Organization 
Director, Computer & Software 
' ' Engineering Division 

Institute for Defense Analyses 
Alexandria VA 22311 


Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 



; Acce:iv: rcr 

i.. 

h 1 ’S 

u • -.v,l 

J, ; • •; 


By _ 

0 -!• t: ,;:c•'/ 


A'. 


D’st 


Av 






% 


Declaration of Conformance 


Customer: 

Ada Validation Facility: 
acvc Version: 


SYSTEAM KG 

IABG m. b. H., Abt. S2T 

1.11 


Ada Implementation 

Ada Compiler Name: 
Version: 

Host Computer System: 
Target Computer System: 


SYSTEAM Ada Compiler VAX/VMS 
1.82 


VAX 

8530 

under 

VMS, 

Version 

5.1 

VAX 

8530 

under 

VMS, 

Version 

5.1 


Customer's Declaration 

I, the undersigned, representing SYSTEAM KG, declare that SYSTEAM KG 
has no knowledge of deliberate deviations from the Ada Language 
Standard ANSI/MIL-STD-1815A in the implementation(s) listed in this 
declaration. 



20.03.1990 

Date 






CONTENTS 


CHAPTER 1 TEST INFORMATION . 1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT .... 1 

1.2 REFERENCES.2 

1.3 ACVC TEST CLASSES.2 

1.4 DEFINITION OF TERMS . 3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES . 5 

2.1 WITHDRAWN TESTS . 5 

2.2 INAPPLICABLE TESTS . 5 

2.3 TEST MODIFICATIONS.8 

CHAPTER 3 PROCESSING INFORMATION . 9 

3.1 TESTING ENVIRONMENT . 9 

3.2 TEST EXECUTION.10 


APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 


















INTRODUCTION 


CHAPTER 1 
INTRODUCTION 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro89] against the Ada Standard [Ada83] using the 
current Ada Compiler Validation Capability (ACVC). This Validation Summary 
Report (VSR) gives an account of the testing of this Ada implementation. For 
any technical terms used in this report, the reader i3 referred to [Pro89]. A 
detailed description of the ACVC may be found in the current ACVC User's Guide 
[UG89] . 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 

In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply only 
to the computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in thi3 report are accurate 
and complete, or that the subject implementation has no nonconformities to the 
Ada Standard other than those presented. Copies of this report are available 
to the public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 


Questions regarding this report or the validation test results should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1 






INTRODUCTION 


1.2 REFERENCES 

[Ada83] Reference Manual for the Ada Programming Language , 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro89] Ada Compiler Validation Procedures , Version 2.0, Ada Joint Program 
Office, May 1989. 

[UG89] Ada Compiler Validation Capability User's Guide , 24 October 1989. 

1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: A, B, 
C, D, E, and L. The first letter of a te3t name identifies the class to which 
it belongs. Class A, C, 0, and E tests are executable. Class B and class L 
tests are expected to produce errors at compile time and link time, 
respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they are 
executed. Three Ada library units, the packages REPORT and SPPRT13, and the 
procedure CHECK_FILE are used for this purpose. The package REPORT also 
provides a set of identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECKJTILE is used to check the contents of text 
files written by some of the Class C tests for Chapter 14 of the Ada Standard. 
The operation of REPORT and CHECK_FILE is checked by a set of executable 
tests. If these units are not operating correctly, validation testing i3 
discontinued. 

Class B tests check that a compiler detects illegal language usage. Class B 
tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of the 
Ada Standard are detected. Some of the class B tests contain legal Ada code 
which must not be flagged illegal by the compiler. This behavior is also 
verified. 

Class L tests check that an Ada implementation correctly detects violation of 
the Ada Standard involving multiple, separately compiled units. Errors are 
expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list of 
the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and implementation- 
dependent characteristics. The modifications required for this implementation 
are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by the AVF. 
This customization consists of making the modifications described in the 
preceding paragraph, removing withdrawn tests (see section 2.1) and, possibly 


2 








INTRODUCTION 


some inapplicable tests (see Section 3.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of the 
customized test suite according to the Ada Standard. 

1.4 DEFINITION OF TERMS 

Ada Compiler The software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compiler The means for testing compliance of Ada implementations. 
Validation consisting of the test suite, the support programs, the ACVC 

Capability user's guide and the template for the validation summary 

(ACVC) report. 

Ada An Ada compiler with its ho3t computer system and its 

Implementation target computer system. 

Ada The part of the certification body which carries out the 

Validation procedures required to establish the compliance of an Ada 
Facility (AVF) implementation. 

Ada The part of the certification body that provides technical 

Validation guidance for operations of the Ada certification system. 

Organization 
(AVO) 

Compliance of The ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer Functional unit, consisting of one or more computers and 

System associated software, that uses common storage for all or 

part of a program and also for all or part of the data 
necessary for the execution of the program; executes user- 
written or user-designated programs; performs user-designa¬ 
ted data manipulation, including arithmetic operations and 
logic operations; and that can execute programs that modify 
themselves during execution.A comuter system may be a stand¬ 
alone unit or may consist of several inter-connected units. 


Conformity 

Fulfillment by a product, process or 
requirements specified. 

service 

of 

all 

Customer 

An individual or corporate entity who 
agreement with an AVF which specifies 

enters 

the 

into 

terms 

an 

and 


conditions for AVF services (of any kind) to be performed. 

Declaration of A formal statement from a customer assuring that conformity 
Conformance is realized or attainable on the Ada implementation for 
which validation status is realized. 


3 











INTRODUCTION 


Host Computer 
System 

Inapplicable 

test 

Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


A computer system where Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation ^hat has been validated successfully 
either by AVF testing or by registration [Pro89]. 

The process of checking the conformity of an Ada compiler to 
the Ada programming language and of i33uing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


4 










IMPLEMENTATION DEPENDENCIES 


CHAPTER 2 

IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are withdrawn from the ACVC because they do not conform to the Ada 
Standard. The following 60 tests had been withdrawn by the Ada Validation 
Organization (AVO) at the time of validation testing. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 31 January 1990. 


E29005C 

B41308B 

C45114A 

C45612B 

C45651A 

C46022A 

B49008A 

A74006A 

B83022B 

B83022H 

B83025B 

BU3025D 

B83026B 

C83026A 

C83041A 

C97116A 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2119B 

CE3111C 

CE3118A 

CE3411B 

CE3412B 

CE3812A 

CE3902B 


Immediately before on-site testing the AVF was informed by the AVO that 
C98003B will be withdrawn, too. Therefore, this test was processed but its 
result was ignored. 


2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant for 
a given Ada implementation. The inapplicability criteria for some tests are 
explained in documents issued by ISO and the AJtO known as Ada Issues and 
commonly referenced in the format Al-dddd. For this implementation, the 
following tests were inapplicable for the reasons indicated; references to Ada 
Issues are included as appropriate. 


C24113W..Y (3 tests) contain lines of length greater than 255 characters 
which are no. --pported by this implementation. 

C34007P and C34007S are expected to raise CONSTRAINT_ERROR. This 


5 






The following 21 tests check for the predefined type LONG_INTEGER: 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45304F 

C45611C 

C45612C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001W 

C86006C 


CD7101F 

C41401A is expected to raise CONSTRAINT_ERROR for the evaluation of cer¬ 
tain attributes, however, this implementation derives the values from the 
subtypes of the prefix at compile time as allowed by 11.6 (7) LRM. There¬ 
fore, elaboration of the prefix is not involved and CONSTRAINT_ERROR is 
not raised. 

C45346A declares an array of length interre; 'last/2 +1. This implementation 
raises the proper exception when the array is declared. 

C45624A checks that the proper exception is raised if machine_overflows i3 
false for floating point types with digits 5. 

C45624B checks that the proper exception is raised if machine_overflows is 
false for floating point types with digits 6. 

C45531M..P (4 tests) and C45532 m..P (4 tests) check fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater. 

C86001F recompiles package SYSTEM, making package TEXT_IO, and her.ce 
package REPORT, obsolete. For this implementation, the package TEXT_IO is 
dependent upon package SYSTEM. 

B86001Y checks for a predefined fixed-point type other than DURATION. 

C96005B checks for values of type DURATION'BASE that are outside the range 
of DURATION. There are no such values for this implementation. 

CD1009C uses a representation clause specifying a non-default size for a 
floating-point type (see AI-00561). 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use representation 
clauses specifying non-default sizes for access types. 

BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code 
insertions. 

EE2401D contains instantiations of package DIRECT_IO with unconstrained 
array types. This implementation raises USE_ERROR upon creation of such a 
file. 

The 21 tests listed in the following table are not applicable because the 
given file operations are supported for the given combination of mode and 
file access method. 

Test File Operation Mode File Access Method 


CE2102D 

CREATE 

CE2102E 

CREATE 

CE2102F 

CREATE 

CE2102I 

CREATE 

CE2102J 

CREATE 


IN_FILE 
OUT_FILE 
INOUT_FILE 
IN_FILE 
OUT FILE 


SEQUENTIAL_IO 
SEQUENTIAL_IO 
DIRECT_IO 
DIRECT_IO 
DIRECT 10 


6 










CE2102N 

OPEN 

IN_FILE 

SEQUENTIAL_IO 

CE2102O 

RESET 

IN_FILE 

SEQUENTIAL_IO 

CE2102P 

OPEN 

OUT_FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT_FILE 

SEQUENTIAL_IO 

CE2102R 

OPEN 

INOUT_FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN_FILE 

DIRECT IO 

CE2102V 

OPEN 

OUT_FILE 

DIRECT 10 

CE2102W 

RESET 

OUT_FILE 

DIRECT 10 

CE3102E 

CREATE 

IN_FILE 

TEXT IO 

CE3102F 

RESET 

Any Mode 

TEXT 10 

CE3102G 

DELETE 


TEXT ro 

CE3102I 

CREATE 

OUT_FILE 

TEXT 10 

CE3102J 

OPEN 

IN_FILE 

TEXT_IO 

CE3102K 

OPEN 

0UT_FILE 

TEXT_I0 

CE2107E, 

CE2110B, and 

CE2111D attempt 

to associate multiple 


internal £iles with the same external file when one or more files is 
writing for sequential files. The proper exception is raised when 
multiple access is attempted. 

CE2107C, CE2107D, CE2107L, and CE2108B attempt to associate names with 
temporary sequential files. The proper exception is raised when such an 
association is attempted. 

CE2107G, CE2110D, and CE2111H attempt to associate multiple internal files 
with the same external file when one or more files is writing for direct 
files. The proper exception is raised when multiple access is attempted. 

CE2107H and CE2108D attempt to associate names with temporary direct 
files. The proper exception is raised when such an association is attemp¬ 
ted. 

CE2203A checks that WRITE raises USE_ERROR if the capacity of the external 
file is exceeded for SEQUENTIAL_IO. This implementation does not restrict 
file capacity. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of the external 
file is exceeded for DIRECT_IO. This implementation does not restrict file 
capacity. 

CE3111B, CE3111D..E (2 tests), CE3114B, and CE3115A attempt to associate 
multiple internal files with the same external file when one or more files 
is writing for text files. The proper exception is raised when multiple 
access is attempted. 

CE3112B attempts to associate names with temporary text files. The proper 
exception is raised when such an association is attempted. 

CE3304A checks that USE_ERROR is raised if a call to SET_LINE_LENGTH or 
SET_PAGE_LENGTH specifies a value that is inappropriate for external 
files. This implementation does not have inappropriate values for either 
line length or page length. 

CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the page 
number exceeds COUNT'LAST. For this implementation the value of COUNT'LAST 
is greater than 150000 making the checking of this objective impractical. 


7 











2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 17 tests. 

The following tests were split into two or more tests because this implementa¬ 
tion did not report the violations of the Ada Standard in the way expected by 
the original tests. 

B22003A B24009A B29001A B38003A B38009A B38009B 

B91001H BC2001D BC2001E BC3204B BC3205B BC3205D 

For the following tests a pragma ELABORATE for the package REPORT was added. 
C83030C C86007A 


The following tests compile without error, as allowed by AI-00256 — the units 
are illegal only with respect to units that they do not depend on. However, 
all errors are detected at link time. The AVO ruled that this is acceptable 
behavior. 

BC3204C BC3204D BC3205C BC3205D 


8 







PROCESSING INFORMATION 


CHAPTER 3 

PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 


The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact for technical information and sales information about 
this Ada implementation system, see: 

Syateam KG Dr. Winterstein 
Am Riippurrer SchloB 7 
0-7500 Karlsruhe 51 
West Germany 


Testing of this Ada implementation was conducted at the customer's site by a 
validation team from the AVF. 


9 





PROCESSING INFORMATION 


3.2 TEST EXECUTION 

Version 1.11 of the ACVC comprises 4140 tests. When this compiler was tested, 
the tests listed in section 2.1 had been withdrawn because of test errors. 

The AVF determined that 97 tests were inapplicable to this implementation. 

All inapplicable tests were processed during validation testing. In addition, 
the modified tests mentioned in section 2.3 were also processed. 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the validation team for processing. The contents of the 
magnetic tape were loaded directly onto the host computer. 

After the test files were loaded onto the host computer, the full set of tests 
was processed toy the Ada implementation. Tests were compiled, linked and 
executed (as appropriate) using a single computer. 

Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a complete listing of the 
processing options for this implementation. It also indicates the default 
options. 

Tests were compiled using the command 

SAS compile/LOG 'file name' 
and linked using the command 

SAS link/LOG/EXE*'test name' . 

The command qualifier /LOG enforces the compiler and the linker to write 
additional messages onto the specified file. 

Chapter B tests were compiled with the full listing option, /LIST. For several 
tests, completer listings were added using the option /LIST - 'test name'.LL. 

Test output, compiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by the 
validation team were also archived. 

During preparation of the VSR the AVF detected that the values of the macro 
parameters $FLOAT_NAME and SNAME did not correspond to the set of predefined 
types as stated in the APPENDIX F, package STANDARD, supplied by the customer. 
Therefore seven tests were rerun. The tests demonstrated acceptable behavior. 


10 









MACRO PARAMETERS 


APPENDIX A 
MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 

The meaning and purpose of these parameters are explained in [UG89]. The 
following macro parameters are defined in terms of the value V of $MAX_IN_LEN 
which is the maximum input line length permitted for the tested implementati¬ 
on. For these parameters, Ada string expressions are given rather than the 
macro values themselves. 

Macro Parameter Macro Value 


$BIG_ID1 

(1..V-1 -> 'A', 

V «> '1') 

$BIG_ID2 

(1..V-1 -> 'A', 

CM 

w 

A 

1 

> 

$BIG_ID3 

(1..V/2 -> 'A') 
<1..V-l-V/2 

& '3' £ 

-> 'A') 

$BIG_ID4 

(1..V/2 -> 'A') 
(1..V-l-V/2 

& '4' £ 

-> 'A') 

$BIG_INT_LIT 

(1..V-3 -> '0') 

£ "298" 

$BIG_REAL_LIT 

(1..V-5 -> '0') 

£ "690.0" 

$BIG_STRING1 

£ (1..V/2 

• 'A') £ ' 

$BIG_STRING2 

£ (1..V-l-V/2 -> 'A') 

SBLANKS 

(1..V-20 



$MAX_LEN_INT_BASED_LITERAL 

"2:" £ (1..V-5 -> '0') £ "11:" 

$MAX_LEN_REAL_BAS ED_LITERAL 

"16:" £ (1..V-7 -> '0') fi "F.E:" 

$MAX STRING LITERAL £ (1..V-2 -> 'A') & 











MACRO PARAMETERS 


The following table contains the values for the remaining macro parameters. 
Macro Parameter Macro Value 

$MAX_IN_L£N 255 

$ACC_SIZE 32 

$ALIGNMENT 4 

$COUNT_LAST 2147483647 

$DEFAULT_MEM_SIZE 2147483648 

$DEFAULT_STOR__UNIT 8 

$DEFAULT_SYS_NAME VAX_VMS 

$DELTA_DOC 2#1.0#E-31 

$ENTRY_ADDRESS SYSTEM.INTERRUPT_VECTOR(10) 

$ENTRY_ADDRESS1 SYSTEM.INTERRUPT__VECTOR(11) 

$ENTRY_ADDRESS2 SYSTEM. INTERRUPT__VECTOR (12) 

$FIELD_LAST 512 

$FILE_TERMINATOR • • 

$ FIXED_NAME NO_SUCH_FIXED_NAME 

$FLOAT_NAME LONG__LONG_F LO AT 

$FORM_STRING "" 

$FORM_STRING2 "CANNOT_RESTRICT_FILE_CAPACITY" 

$GREATER_THAN_DURATION 

0.0 

$GREATER_THAN_DURATION_BASE_LAST 

200 _ 000.0 

$GREATER_THAN_FLOAT_BASE_LAST 

l6#0.8#E+32 

$GREATER_THAN_FLOAT_SAFE_LARGE 

16#0 .7FFF_FFFF_1000_000#E+32 

$GR£ATER_THAN_SHORT_FLOAT_SAFE_LARGE 

16#0.7FFF FD0#E+32 






MACRO PARAMETERS 


$HIGH_PRIORITY 15 

$ILLEGAL_EXTERNAL_FILE_NAME1 

[NODIRECTORY]FILENAME 

$ILLEGAL_EXTERNAL_FILE_NAME2 

FILENAME.* 

$INAFPROPRIATE_LINE_LENGTH 

-1 

$INAPPROPRIATE_PAGE_LENGTH 

-1 

$INCLUDE_PRAGMA1 PRAGMA INCLUDE ("A28006D1.TST") 

$INCLUDE_PRAGMA2 PRAGMA INCLUDE ("B28006F1.TST") 

$INTEGER_FIRST -2147483648 

$INTEGER_LAST 2147483647 

$INTEGER_LAST_PLUS_1 2147483648 

$INTERFACE_LANGUAGE VMS 

$ LE S S_T HAN_DURATION -0.0 

$LES S_THAN_DURATION_BASE_FIRST 

-200J500.0 

$LINE_TERMINATOR ' • 

$LOW_PRIORITY 0 

$MACHINE_CODE_STATEMENT 

NULL; 

$MACHINE_CODE_TYPE NO_SUCH_TYPE 

$MANTISSA_DOC 31 

$MAX_DIGITS 33 

$MAX_INT 2147483647 

$MAX_INT_PLUS_1 2147483648 

$MIN_INT -2147483648 

SNAME SHORT SHORT INTEGER 


SNAME LIST 


VAX VMS 







MACRO PARAMETERS 


$NAME_SPECIFICATIONl 

$NAME_SPECIFICATION2 

$NAME_SPECIFICATION3 

$NEG_BASED_INT 

$NEW_MEM_SIZE 

$NEW_STOR_UNIT 

$NEW_SYS_NAME 

$PAGE_TERMINATOR 

$RECORD_DEFINITION 

$RECORD_NAME 

$TASK_SIZE 

$TASK_STORAGE_SIZE 

$TICK 

$VARIABLE_ADDRESS 
$VARIABLE_ADDRESS1 
$VARIABLE_ADDRESS2 
$YOUR PRAGMA 


BIGB:[V182.ACVC11.CHAPE]X212OA.;1 
BIGB:[V182.ACVC11.CHAPE]X2120B1 
BIGB:[V182.ACVC11.CHAPE]X3119A.;1 
16 #FFFFFFFE # 

2147483648 

8 

VAX_VMS 
/ / 

NEW INTEGER 

NO_SUCH_MACHINE_CODE_TYPE 

32 

10240 

0.01 

GET_VARIABLE__ADDRES S 
GET_VARIABLE_ADDRESS1 
GE T_VARIABLE_ADDRE S S2 
RESIDENT 






COMPILATION SYSTEM OPTIONS 


APPENDIX B 

COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted otherwise, 
references in this appendix are to compiler documentation and not to this 
report. 


LINKER OPTIONS 

The linker options of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, references 
in this appendix are to linker documentation and not to this report. 








Compiling 


Chapter 4 


4 Compiling 


After a program library has been created, one or more compilation units can be com¬ 
piled in the context of this library. The compilation units can be placed on different 
source files or they can all be on the same file. One unit, a parameterless procedure, 
acts as the main program. If all units needed by the main program and the main 
program itself have been compiled successfully, they can be linked. The resulting code 
can then be executed by giving a RUN command. 

§4.1 and Chapter 5 describe in detail how to call the Compiler and the Linker. In 
§4.2 the Completer, which is called to generate code for instances of generic units, is 
described. 

Chapter 6 explains the information which is given if the execution of a program is 
abandoned due to an unhandled exception. 

The information the Compiler produces and outputs in the Compiler listing is explained 
in §4.4. 

Finally, the log of a sample session is given in Chapter 7. 


4.1 Compiling Ada Units 


To start the SYSTEAM Ada Compiler, use the SAS COMPILE command. 


SAS COMPILE 

Command Description 

Format 

$ SAS COMPILE file-spec[,_] 


Command Qualifiers 

/[NO]ANALYZE-DEPENDENCY 
/LIBRARY-directory-spec 
/[NO]LOG[-file-spec] 

/[NO]RECOMPILE 

Defaults 

/NOANALYZE-DEPENDENCY 
/LIBRARY*[.ADALIB] 

/NOLOG 

/NORECOMPILE 

Positional Qualifiers 
/[NO]CHECK 
/[NO]COPY-SOURCE 
/[NO]INLINE 
/[NO]LIST[-file-spec] 

/[NO]MACHINE-CODE 
/[NO]OPTIMIZE 

Defaults 

/CHECK 

/COPY-SOURCE 

/INLINE 

/NOLIST 

/NOMACHINE-CODE 

/OPTIMIZE 


SYSTEAM Ada System - User Manual 


43 









Chapter 4 


Compiling 


Command Parameters 
file-spec 

Specifies the file(s) to be compiled. The default directory is []. The default 
file type is ADA. The maximum length of lines in file-spec is 255. The 
maximum number of source lines in file-spec is 65534. Wild cards are 
allowed. 

Note: If you specify a wild card the order of the compilation is alpha¬ 
betical, which is not always successful. Thus wild cards should be used 
together with /ANALYZE-DEPENDENCY. With this qualifier the sources can 
be processed in any order. 

Description 

The source file may contain a sequence of compilation units 
(cf. LRM(jjlO.l)). All compilation units in the source file are compiled 
individually. When a compilation unit is compiled successfully, the program 
library is updated and the Compiler continues with the compilation of the 
next unit on the source file. If the compilation unit contained errors, they 
are reported (see §4.4). In this case, no update operation is performed on 
the program library and all subsequent compilation units in the compilation 
are only analyzed without generating code. 

The Compiler delivers the status code WARNING on termination (cf. 
VAX/VMS, DCL Dictionary , command EXIT) if one of the compilation 
units contained errors. A message corresponding to this code has not been 
defined; hence %NONAME-W-NOMSG is printed upon notification of a 
batch job terminated with this status. 

Command Qualifiers 

/ANALYZE_DEPENDENCY 
/NOANALYZE-DEPENDENCY (D) 

Specifies that the Compiler only performs syntactical analysis and the anal¬ 
ysis of the dependencies on other units. The units in file-spec are entered 
into the library if they sure syntactically correct. The actual compilation is 
done later with the SAS AUTOCOMPILE command. 

Note: An already existing unit with the same name as the new one is 
replaced and all dependent units become obsolete, unless the source file 
of both are identical. In this case the library is not updated because the 
dependencies are already known. 

By default, the normal, full compilation is done. 


44 


SYSTEAM Ada System - User Manual 




Compiling 


Chapter 4 


/LIBRARY=dir-spec 

Specifies the program library the command works on. The SAS COMPILE 
command needs write access to the library. The default is [.ADALIB]. 

/LOG C*file-spec] 

/NOLOG (D) 

Controls whether the Compiler writes additional messages onto the speci¬ 
fied file. The default file name is SYSSOUTPUT. The default file type is 
LOG. 

By default, no additional messages are written. 

/RECOMPILE 
/NORECOMPILE (D) 

Indicates that a recompilation of a previously analyzed source is to be 
performed. This qualifier should not be used unless the command was 
produced by the SYSTEAM Ada Recompiler. See the SAS RECOMPILE 
command. 

Positional Qualifiers 


/CHECK (D) 

/NOCHECK 

Controls whether all run-time checks are suppressed. If you specify 
/NOCHECK this is equivalent to the use of PRAGMA suppress for all kinds 
of checks. 

By default, no run-time checks are suppressed, except in cases where 
PRAGMA suppress-all appears in the source. 

/COPY-SOURCE (D) 

/NOCOPY-SOURCE 

Controls whether a copy of the source file is kept in the library. The copy in 
the program library is used for later access by the Debugger or tools like the 
Recompiler. The name of the copy is generated by the Compiler and need 
normally not be known by the user. The Recompiler and the Debugger 
know thin nam e. You can use the SAS DIRECTORY/FULL command to 
see the file name of the copy. If a specified file contains several compilation 
units a copy containing only the source text of one compilation unit is 
stored in the library for each compilation unit. Thus the Recompiler can 
recompile a single unit. 

If /N0C0PY_S0URCE is specified, the Compiler only stores the name of the 
source file in the program library. In this case the Recompiler and the 
Debugger are able to use the original file if it still exists. 


SYSTEAM Ada System - User Manual 


45 



Chapter 4 


Compiling 


/COPY-SOURCE cannot be specified together with /ANALYZE-DEPENDENCY. 

/INLINE (D) 

/NOINLINE 

Controls whether inline expansion is performed as requested by PRAGMA 
inline. If you specify /NOINLINE these pragmas are ignored. 

By default, inline expansion is performed. 

/LIST[»file-spec] 

/NOLIST (D) 

Controls whether a listing file is created. One listing file is created for each 
source file compiled. If /LIST is placed as a co mman d qualifier a listing 
file is created for all sources. If /LIST is placed as a parameter qualifier a 
listing file is created only for the corresponding source file. 

The default directory for listing files is the current default directory. The 
default file name is the name of the source file being compiled unless /RE¬ 
COMPILE is specified. In this case the name of the original source file, which 
is stored in the library, is taken as default. The default file type is LIS. No 
wildcard characters are allowed in the file specification. 

By default, the COMPILE command does not create a listing file. 

/MACHINE_CODE 
/N0MACHINE_C0DE (D) 

Controls whether machine code is appended at the listing file. /MACHINE- 
CODE has no effect if /NOLIST or /ANALYZE-DEPENDENCY is specified. 

By default, no machine code is appended at the listing file. 

/OPTIMIZE (D) 

/NOOPTIMIZE 

Controls whether full optimization is applied in generating code. There is 
no way to specify that only certain optimizations are to be performed. 

By default, full optimization is done. 



46 SYSTEAM Ada System - User Manual 










Compiling 


Chapter 4 


4.2 Completing Generic Instances 


Since the Compiler does not generate code for instances of generic bodies, the Com¬ 
pleter must be used to complete such units before a program using the instances can 
be executed. The Completer must also be used to complete packages in the program 
which do not require a body. This is done implicitly when the Linker is called. 

It is also possible to call the Completer explicitly with the SAS COMPLETE command. 


SAS COMPLETE Command Description 

Format 

$ SAS COMPLETE unit[,...] 


Command Qualifiers 
/[NO]CHECK 
/[NO]INLINE 

/LIBRARY*directory-apec 
/[NO]LIST[=file-spec] 

/[NO]LOG[=file-apec] 
/[NO]MACHINE-CODE 
/[NO]OPTIMIZE 


Defaults 

/CHECK 

/INLINE 

/LIBRARY 3 ! ADALIB] 

/NOLIST 

/NOLOG 

/NOMACHINE-CODE 

/OPTIMIZE 


Command Parameters 
unit 

specifies the unit(s) whose execution closure is to be completed. 
Description 

The SAS COMPLETE command invokes the SYSTEAM Ada Completer. 
The Completer generates code for all instantiations of generic units in 
the execution closure of the specified unit(s). It also generates code for 
packages without bodies (if necessary). 

By default, the Completer is invoked implicitly by the SAS LINK command. 
In normal cases there is no need to invoke it explicitly. 

Command Qualifiers 

/CHECK (D) 

/NOCHECK 

Controls whether all run-time checks are suppressed. If you specify 
/ if n CHECK this is equivalent to the use of PRAGMA suppress for all kinds 
of checks. 


SYSTEAM Ada System - User Manual 










Chapter 4 


Compiling 


By default, no run-time checks are suppressed, except in cases where 
PRAGMA suppress_all appears in the source. 

/INLINE (D) 

/NOINLINE 

Controls whether inline expansion is performed as requested by PRAGMA 
inline. If /NOINLINE is specified these pragmas are ignored. By default, 
inline expansion is performed. 

/LIBRARY*dir-spec 

Specifies the program library the command works on. The SAS COM¬ 
PLETE command needs write access to the library. The default library is 
[.ADALIBj. 

/LIST Of ile-spec] 

/NOLIST (D) 

Controls whether a listing file is created. 

The default directory for listing files is the current default directory. The 
default file name is COMPLETE. The default file type is LIS. No wildcard 
characters are allowed in the file specification. By default, the COMPLETE 
command does not create a listing file. 

/LOG Of lie - spec ] 

/NOLOG (D) 

Controls whether the SAS COMPLETE command writes additional mes¬ 
sages onto the specified file. The default file name is SYSSOUTPUT. The 
default file type is LOG. 

By default, no additional messages are written. 

/MACHINE-CODE 
/NOMACHINE-CODE (D) 

Controls whether a machine code listing is appended to the listing file. 
/MACHINE-CODE has no effect if /NOLIST is specified. By default, no machine 
code listing is appended to the listing file. 

/OPTIMIZE (D) 

/NOOPTIMIZE 

Controls whether full optimization is applied in generating code. There is 
no way to specify that only certain optimizations are to be performed. 

By default, full optimization is done. 


48 


SYSTEAM Ada System - User Manual 





Compiling 


Chapter 4 


End of Command Description 


4.3 Automatic Compilation 

The SYSTEAM Ada System offers three different kinds of automatic compilation. It 
supports 

• automatic recompilation of obsolete units 

• automatic compilation of modified sources 


In the following the term recompilation stands for the recompilation of an obsolete 
unit using the identical source which was used the last time. (This kind of recom¬ 
pilation could alternatively be implemented by using some appropriate intermediate 
representation of the obsolete unit.) This definition is stronger than that of the LRM 
(10.3). If a new version of the source of a unit is compiled we call it compilation , not 
a recompilation. 

The set of units to be checked for recompilation or new compilation is described by 
specifying one or more units and the kind of a closure which is to be build on them. 
In many cases you will simply specify your main program. 

The automatic recompilation of obsolete units is supported by the SAS RECOMPILE 
command. It determines the set of obsolete units and generates a command file for 
calling the Compiler in an appropriate order. This command file is started by the user 
either in batch or in interactive mode. 

The recompilation is performed using the copy of the obsolete units which is (by 
default) stored in the library. (If the user does not want to hold a copy of the sources 
the SAS RECOMPILE command offers the facility to use the original source.) 

The automatic compilation of modified sources is supported by the SAS AUTOCOM- 
PILE command. It determines the set of modified sources and generates a command 
file for calling the Compiler in an appropriate order. This command file is started by 
the user either in batch or in interactive mode. The basis of both the SAS RECOM¬ 
PILE and the SAS AUTOCOMPILE command is the information in the library about 
the dependencies of the concerned units. Thus neither of these commands can handle 
the compilation of units which have not yet been entered in the library. 

The automatic compilation of new sources is supported by the SAS COMPILE com¬ 
mand together with the /ANALYZE-DEPENDENCY qualifier. This command is able 
to accept a set of sources in any order. It makes a syntactical analysis of the sources 


SYSTEAM Ada System - User Manual 


49 






Chapter 4 


Compiling 


and determines the dependencies. The units "compiled” with this command are en¬ 
tered into the library, but only their names, their dependencies on other units and the 
name of the source files are stored in the library. Units which are entered this way can 
be automatically compiled using the SAS AUTOCOMPILE command. They cannot 
be recompiled using the SAS RECOMPILE command because the SAS RECOMPILE 
command only recompiles units which were already compiled. 

The next sections explain the usage of the SAS RECOMPILE command, the SAS AU¬ 
TOCOMPILE command, and the SAS COMPILE/ANALYZE-DEPENDENCY com¬ 
mand. 


4.3.1 Recompiling Obsolete Units 


The SAS RECOMPILE command supports the automatic recompilation of units which 
became obsolete because of the (re)compilation of units they depend on. The command 
gets as a parameter a set of units which are to be used to form the closure of units 
to be recompiled. The kind of the closure can be specified. The SAS RECOMPILE 
command generates a command file with a sequence of SAS COMPILE commands to 
recompile the obsolete units which belong to the computed closure. This command 
file is started by the user either in batch or in interactive mode. The name of the 
command file can be specified using the /OUTPUT qualifier. 


SAS RECOMPILE 

Command Description 

Format 


$ SAS RECOMPILE unit[....] 


Command Qualifiers 

Defaults 

/[NO]BODIES.ONLY 

/NOBODIES-ONLY 

/[NO]CHECK 

see Text 

/[NO]CLOSURE-option 

/CLOSURE-EXECUTE 

/[NO]CONDITIONAL 

/CONDITIONAL 

/[NO]INLINE 

see Text 

/LIBRARY-directory-spec 

/LIBRARY-[.ADALIB] 

/[NO]LIST[-file-spec] 

/NOLIST 

/[NO]LOG[-file-spec] 

/NOLOG 

/[NO]MACHINE-CODE 

/NOMACHINE-CODE 

/[NO]OPTIMIZE 

see Text 

/OUTPUT-file-spec 

/OUTPUT*[]RECOMPILE.COM 

/[NO]SAME 

/SAME 

Positional Qualifiers 

Defaults 

/BODY 

see Text 


50 


SYSTEAM Ada System - User Manual 









Compiling 


Chapter 4 


Command Parameters 
unit 

Specifies the unit(s) whose closure is to be built. 

Description 


The SAS RECOMPILE command determines the specified closure based 
on the specified unit(s). Out of the units of the closure it determines the 
set of units which are obsolete. It generates a command file containing 
an SAS COMPILE/RECOMPILE command for every obsolete unit. They 
are compiled in an order consistent with the WITH dependencies and the 
”body-of” and "subunit-oP dependencies as required by the LRM(10.3). 

The SAS RECOMPILE commands uses the copy of the source which is 
stored in the library for the recompilation. By default, the SAS COMPILE 
command stores a copy of the source in the library. If there is no copy 
in the library - because the unit was compiled using the /N0C0PY_S0URC£ 
qualifier - the SAS RECOMPILE issues a warning and generates an SAS 
COMPILE command for the original source file name. This name does not 
include a version number. It is not checked whether such a file still exists. 
This command only performs a real recompilation if the current source is 
the same which was last compiled. 

In the command file each recompilation of a unit is executed under the 
condition that the recompilation of other units it depends on was successful. 
Thus useless recompilations axe avoided. The generated command file only 
works correctly if the library was not modified since the command file was 
generated. 

Note: If a unit from a parent library is obsolete it is compiled in the 
sublibrary in which the SAS RECOMPILE command is used. In this case 
a later recompilation in the parent library may be hidden afterwards. 

Command Qualifiers 

/BODIES-ONLY 
/NOBODIES-ONLY (D) 

Controls whether all units of the closure are recompiled (default) or only 
the secondary units. This qualifier is only effective if /NOCONDITIONAL is 
specified. 

/CHECK 

/HOCHECK 


SYSTEAM Ada System - User Manual 


51 













Chapter 4 


Compiling 


This qualifier is included in the generated command file and thus affects 
the generated SAS COMPILE command. See the same qualifier with the 
SAS COMPILE command. 

/CLOSURE*(EXECUTE I COMPILE) 

/NOCLOSURE 

Controls the kind of the closure which is built and which is the basis for 
the investigation for obsolete units. /NOCLOSURE means that only the spec¬ 
ified units are checked. /CLOSURE*COMPILE means that only those units 
on which the specified unit(s) transitively depend(s) are regarded. /CLQ- 
SURE=EXECUTE means that - in addition - all related secondary units and 
the units they depend on are regarded. 

By default, the execution closure is built. 

/CONDITIONAL (D) 

/NOCONDITIONAL 

Controls whether only obsolete units are recompiled (default). /NOCONDI¬ 
TIONAL means that all units in the closure are recompiled whether they are 
obsolete or not. This qualifier is useful for recompiling the complete closure 
with different qualifiers than the last time. 

/INLINE 

/NOINLINE 

This qualifier is included in the generated command file and thus affects 
the generated SAS COMPILE command. See the same qualifier with the 
SAS COMPILE command. 

/LIBRARY*directory-spec 

Specifies the program library the command works on. 

The default is [.ADALIBj. 

/LIST[*Yile-spec] 

/NOLIST (D) 

This qualifier is included in the generated command file and thus affects 
the generated SAS COMPILE command. See the same qualifier with the 
SAS COMPILE command. 

/LOG[*file-spec] 

/NOLOG (D) 

This qualifier is included in the generated command file and thus affects 
the generated SAS COMPILE command. See the same qualifier with the 
SAS COMPILE command. 

/MACHINE-CODE 
/NOMACHINE-CODE (D) 

This qualifier is included in the generated command file and thus affects 
the generated SAS COMPILE command. See the same qualifier with the 
SAS COMPILE command. 


52 


SYSTEAM Ada System - User Manual 


Compiling 


Chapter 4 


/OPTIMIZE 

/NOOPTIMIZE 

This qualifier is included in the generated command file and thus affects 
the generated SAS COMPILE command. See the same qualifier with the 
SAS COMPILE command. 

/OUTPUT-file-spec 

Specifies the name of the generated co mm and file. The default directory is 
[]. The default file name is RECOMPILE. The default file type is COM. 

/SAME (D) 

/NOSAME 

Controls whether the SAS RECOMPILE co mman d inserts certain addi¬ 
tional qualifiers in each SAS COMPILE co mman d which is generated. 
/SAME means that the same qualifiers for /CHECK, /INLINE and /OPTI¬ 
MIZE are included which were in effect at the last compilation, unless they 
are specified explicitly with the SAS RECOMPILE command. By default, 
additional qualifiers for /CHECK, /INLINE and /OPTIMIZE are inserted in 
order to do the compilation with the same effect as last time. 

Positional Qualifiers 


/BODY 

specifies that unit stands for the secondary unit with that name. By 
default, unit denotes the library unit. If unit specifies a subunit, the 
/BODY qualifier need not be specified. 


End of Command Description 


4.3.2 Compiling New Sources 

The SAS AUTOCOMPILE command supports the automatic compilation of units for 
which a new source exists. The command receives as parameters a set of units which 
are to be used to form the closure of units to be processed. The kind of closure can 
be specified. For every unit in the closure, the SAS AUTOCOMPILE checks whether 
there exists a newer source than that which was used for the last compilation. It 
generates a command file with a sequence of SAS COMPILE commands to compile 
the units for which a newer source exists. If a unit to be compiled depends on an¬ 
other unit which is obsolete or which will become obsolete and for which no newer 
source exists, the SAS AUTOCOMPILE command always adds an appropriate SAS 


SYSTEAM Ada System - User Manual 


53 









Chapter 4 


Compiling 


COMPILE/RECOMPILE command to make it current; the /RECOMPILE qualifier 
controls which other obsolete units are recompiled, and can indeed be used to spec¬ 
ify that the same recompilations are done as if the SAS RECOMPILE command was 
applied subsequently. The generated command file is started by the user either in 
batch or in interactive mode. The name of the command file can be specified using 

the /OUTPUT qualifier. 


SAS AUTOCOMPILE 

Command Description 

Format 


$ SAS AUTOCOMPILE unit[,...] 


Command Qualifiers 

Defaults 

/[NO]BODIES.ONLY 

/NOBODIES-ONLY 

/[NO]CHECK 

see Text 

/[NO]CLOSURE-option 

/CLOSURE-EXECUTE 

/[NO]CONDITIONAL 

/CONDITIONAL 

/[NO]COPY-SOURCE 

/COPY-SOURCE 

/[NO]INLINE 

see Text 

/LIBRARY-directory-spec 

/LIBRARY-[.ADALIB] 

/[NO]LIST[-file-spec] 

/NOLIST 

/[NO]LOG[-file-spec] 

/NOLOG 

/[NO]MACHINE-CODE 

. /NOMACHINE-CODE 

/[NO]OPTIMIZE 

see Text 

/OUTPUT-file-spec 

/OUTPUT-[]AUTOCOMPILE.COM 

/[NO]RECOMPILE-option 

/NORECOMPILE 

/[NO]SAME 

/SAME 

Positional Qualifiers 

Defaults 

/BODY 

see Text 

Command Parameters 


unit 

Specifies the unit(s) whose closure is 

to be built. 

Description 


The SAS AUTOCOMPILE command determines the specified closure 

based on the specified unit(s). It determines the set of units for which 
a new source exists. The decision is based on the full file name which is 

stored in the library together with the modification date. If the newest 
version of the file has a newer modification date than the modification date 

which is stored in the library then the unit is said to be ’’new*. Units 


54 SYSTEAM Ada System - User Manual 




Compiling 


Chapter 4 


which were entered with SAS COMPILE/ANALYZE-DEPENDENCY are 
always said to be new. 

The SAS AUTOCOMPILE command generates a command file containing 
an SAS COMPILE command for every "new” unit. They are compiled 
in an order according to the WITH dependencies and the ” body-of” and 
”subunit-oP relations. It is assumed that the dependencies do not change 
in the new sources. 

Inline dependencies are not fully considered by the SAS AUTOCOMPILE 
command. The SAS AUTOCOMPILE co mman d detects that a unit which 
is currently current will become obsolete because it depends on another 
unit (because of an inline call) which will be (re)compiled. The SAS AU¬ 
TOCOMPILE command does not detect that a unit u which is not current 
and will be (re)compiled will become dependent on another unit v (because 
of an inline call) which is currently current and will be (re) compiled too 
but after the compilation of u. In this case u will become obsolete again 
when v is (re)compiled. 

When determining the compilation order the SAS AUTOCOMPILE com¬ 
mand tries to choose the same order as last time by considering the com¬ 
pilation dates in the library, where possible. This strategy should solve the 
inline problem in most cases. 

In the generated command file each compilation of a unit is executed un¬ 
der the condition that the compilations of other units it depends on were 
successful. Thus useless compilations are avoided. The generated com¬ 
mand file only works correctly if the library has not been modified since 
the command file was generated. 

The SAS AUTOCOMPILE command does not fully handle the problem 
which arises when several compilation units are contained within one source 
file; it only avoids the multiple compilation of the same source file. If you 
want to use the SAS AUTOCOMPILE command it is reco mm ended not to 
keep several compilation units in one source. 

Command Qualifiers 

/BODIES-QNLY 
/N0B0DIES_0NLY (D) 

Controls whether all new units of the closure are compiled (default) or only 
the secondary units. This qualifier is only effective if /NOCONDITIONAL is 
specified. 

/CHECK 

/NOCHECK 


SYSTEAM Ada System - User Manual 


55 






Chapter 4 


Compiling 


This qualifier is included in the generated command file and thus affects 
the generated SAS COMPILE command. See the same qualifier with the 
SAS COMPILE command. 

/CLOSURE-(EXECUTE I COMPILE) 

/NQCLOSURE 

Controls the kind of the closure which is built and which is the basis for 
the investigation for new sources. /NOCLOSURE means that only the spec¬ 
ified units are checked. /CLOSURE-COMPILE means that only those units 
on which the specified unit(s) transitively depend(s) are regarded. /CLO¬ 
SURE-EXECUTE means that - in addition - all related secondary units and 
the units they depend on are regarded. 

By default, the execution closure is investigated for new sources. 

/CONDITIONAL (D) 

/NOCONDITIONAL 

Controls whether the check for new sources is performed (default). /NO¬ 
CONDITIONAL means that all units in the closure are compiled disregarding 
the modification date. This qualifier is useful for compiling the complete 
closure with different qualifiers than the last time. 

/COPY-SOURCE (D) 

/NOCOPY-SOURCE 

This qualifier is included in the generated command file and thus affects the 
generated SAS COMPILE command. See the same qualifier with the SAS 
COMPILE command. This qualifier has no effect for the recompilation of 
obsolete units in accordance with the SAS RECOMPILE command where 
/COPY-SOURCE cannot be specified. 

/INLINE 

/NOINLINE 

This qualifier is included in the generated command file and thus affects 
the generated SAS COMPILE command. See the same qualifier with the 
SAS COMPILE command. 

/LIBRARY-directory-spec 

Specifies the program library the command works on. The SAS AUTO¬ 
COMPILE command needs read access to the library. For executing the 
generated command file you need write access. The default is [.ADALIB]. 

/LIST[-file-spec] 

/NOLIST (D) 

This qualifier is included in the generated command file and thus affects 
the generated SAS COMPILE command. See the same qualifier with the 
SAS COMPILE command. 

/LOG[-file-spec] 


56 


SYSTEAM Ada System - User Manual 





Compiling 


Chapter 4 


/NOLOG (D) 

This qualifier is included in the generated command file and thus affects 
the generated SAS COMPILE command. See the same qualifier with the 
SAS COMPILE command. 

/MACHINE-CODE 
/NOMACHINE.CODE (D) 

This qualifier is included in the generated command file and thus affects 
the generated SAS COMPILE command. See the same qualifier with the 
SAS COMPILE command. 

/OPTIMIZE 

/NOOPTIMIZE 

This qualifier is included in the generated command file and thus affects 
the generated SAS COMPILE command. See the same qualifier with the 
SAS COMPILE co mman d. 

/OUTPUT-file-spec 

Specifies the name of the generated command file. The default directory 
is []. The default file name is AUTOCOMPILE. The default file type is 
COM. 

/RECOMPILE-(OBSOLETEI ALL) 

/NORECOMPILE <D) 

Controls whether the SAS AUTOCOMPILE co mman d additionally recom¬ 
piles obsolete units. With /NORECOMPILE only those units axe recompiled 
which are obsolete or become obsolete and are used by other units which are 
to be compiled because of new sources. /RECOMPILE-OBSOLETE additionally 
recompiles those units of the considered closure which will become obsolete 
during the compilation of new sources. This option specifies that there 
shall not be more obsolete units after the execution of the co mm and file 
than before. /RECOMPILE-ALL specifies that all obsolete units of the closure 
and all units which will become obsolete axe recompiled. This is equivalent 
to a subsequent call of the SAS RECOMPILE co mman d after the run of 
the command file generated by the SAS AUTOCOMPILE co mm and. 

/SAME (D) 

/NOSAME 

Controls whether the SAS AUTOCOMPILE co mm and inserts certain ad¬ 
ditional qualifiers in each SAS COMPILE command which is generated. 
/SAME means that the same qualifiers for /CHECK, /INLINE and /OPTIMIZE 
are included which were in effect at the last compilation, unless they are 
specified explicitly with the SAS AUTOCOMPILE command. By default, 
additional qualifiers for /CHECK, /INLINE and /OPTIMIZE are inserted in 
order to do the compilation with the same effect as last time. 

Positional Qualifiers 


SYSTEAM Ada System - User Manual 


57 






Chapter 4 


Compiling 


/BODY 

specifies that unit stands for the secondary unit with that name. By 
default, unit denotes the library unit. If unit specifies a subunit, the 
/BODY qualifier need not be specified. 


End of Command Description 


4.3.3 First compilation 

The SYSTEAM Ada System supports the first compilation of sources for which no 
compilation order is known by the SAS COMPILE/ANALYZE-DEPENDENCY com¬ 
mand in combination with the SAS AUTOCOMPILE command. 

With the /ANALYZE-DEPENDENCY qualifier the Compiler accepts sources in any 
order and performs the syntax analysis. If the sources are syntactically correct the 
units which are defined by the sources are entered into the library. Their names, 
their dependencies on other units and the name of the source files are stored in the 
library. Units which are entered this way can be automatically compiled using the 
SAS AUTOCOMPILE command, i.e. the Autocompiler computes the first compilation 
order for the new sources. The name of the main program, of course, must be known 
and specified with the SAS AUTOCOMPILE command. 

Note that the SAS COMPILE/ANALYZE-DEPENDENCY command replaces other 
units in the library with the same name as a new one. Thus the library may be modified 
even if the new units contain semantic errors; but the errors will not be detected until 
the command file generated by the SAS AUTOCOMPILE command is run. Hence it 
is recommended to use an empty sublibrary if you do not know anything about the set 
of new sources. 

Wild cards in the SAS COMPILE command are intended to be used together with the 
/ANALYZE-DEPENDENCY qualifier. 

If there are several sources containing units with the same name the last analyzed one 
will be kept in the library. 

The SAS AUTOCOMPILE command issues special warnings if the information about 
the new units is incomplete or inconsistent. 


58 


SYSTEAM Ada System - User Manual 







Compiling 


Chapter 4 


4.4 Compiler Listing 


By default, messages of the Compiler are listed on SYSSOUTPUT. A complete listing 
can be obtained on a file by using the /LIST qualifier with the SAS COMPILE, SAS 
COMPLETE or SAS LINK command. The generated listing file(s) will contain the 
whole source together with the messages of the Compiler/Completer. 

The listing for a compilation unit starts with the kind and the name of the current 
unit. 

Example: 


* PROCEDURE MAIN 


The format effectors ASCII.HT, ASCII.VT, ASCII.CR, ASCII.LF and ASCII.FF are 
represented by a character in the listing. In any case, those source lines which are 
included in the listing are numbered to make locating them in the source file easy. 

Errors are classified into SYMBOL ERROR, SYNTAX ERROR. SEMANTIC ERROR, 
RESTRICTION, COMPILER ERROR, WARNING and INFORMATION: 

SYMBOL ERROR 

pinpoints an inappropriate lexical element. ’’Inappropriate” can mean "inappro¬ 
priate in the given context”. For example, ’2’ is a lexical element of Ada, but it 
is not appropriate in the literal 2#012#. 

SYNTAX ERROR 

indicates a violation of the Ada syntax rules as given in the LRM(Appendix E). 
SEMANTIC ERROR 

indicates a violation of Ada language rules other than the syntax rules. 
RESTRICTION 

indicates a restriction of this implementation. Examples are representation clauses 
which are provided by the language but are not supported in this implementation; 
or situations in which the internal storage capacity of the Compiler for some sort 
of entity is exceeded. 

COMPILER ERROR 

We hope you will never see a message of this sort. 

WARNING 

messages tell the user facts which axe likely to cause errors (for example, the 
raising of exceptions) at runtime. 

INFORMATION 

messages tell the user facts which may be useful to know but probably do not 
endanger the correct r unn ing of the program. Examples are that a library unit 
named in a context clause is not used in the current compilation unit, or that 
another unit (which names the current compilation unit in a context clause) is 
made obsolete by the current compilation. 


SYSTEAM Ada System - User Manual 


59 






60 


SYSTEAM Ada System - User Manual 










APPENDIX C 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to implementation- 
dependent pragmas, to certain machine-dependent conventions as mentioned in 
Chapter 13 of the Ada Standard, and to certain allowed restrictions on repre¬ 
sentation clauses. The implementation-dependent characteristics of this Ada 
implementation, as described in this Appendix, are provided by the customer. 
Unless specifically noted otherwise, references in this Appendix are to compi¬ 
ler documentation and not to this report. The package STANDARD is included in 
the implementor's Chapter 13, Predefined Language Environment, on pages 275ff. 











Predefined Language Environment 


Chapter 13 


13 Predefined Language Environment 

The predefined language environment comprises the package standard, the language- 
defined library units and the implementation-defined library units. 


13.1 The Package STANDARD 

The specification of the package standard is outlined here; it contains all predefined 
identifiers of the implementation. 


PACKAGE standard IS 

TYPE boolean IS (false, true); 

— The predefined relational operators for this type are as follows: 

-- FUNCTION (left, right : boolean) RETURN boolean; 

— FUNCTION "/»" (left, right : boolean) RETURN boolean; 

— FUNCTION "<" (left, right : boolean) RETURN boolean; 

— FUNCTION "<»" (left, right : boolean) RETURN boolean; 

— FUNCTION ">" (left, right : boolean) RETURN boolean; 

— FUNCTION ">«" (left, right : boolean) RETURN boolean; 

— The predefined logical operators and the predefined logical 

— negation operator are as follows: 

— FUNCTION "AND" (left, right : boolean) RETURN boolean; 

— FUNCTION "OR" (left, right : boolean) RETURN boolean; 

— FUNCTION "XOR" (left, right : boolean) RETURN boolean; 

— FUNCTION "NOT" (right : boolean) RETURN boolean; 

-- The universal type universal-integer is predefined. 

TYPE integer IS RANGE - 2-147-483-648 .. 2_147_483_647; 

— The predefined operators for this type are as follows: 

— FUNCTION "»" (left, right : integer) RETURN boolean; 

— FUNCTION »/«• (left, right : integer) RETURN boolean; 


SYSTEAM Ada System - User Manual 


275 








Chapter 13 


Predefined Language Environment 


— FUNCTION "<" Cleft, right : integer) RETURN boolean; 

— FUNCTION "<■" (left, right : integer) RETURN boolean; 

— FUNCTION ">" (left, right : integer) RETURN boolean; 

— FUNCTION ">-" (left, right : integer) RETURN boolean; 

— FUNCTION "*" (right : integer) RETURN integer; 

— FUNCTION "-" (right : integer) RETURN integer; 

— FUNCTION "ABS" (right : integer) RETURN integer; 

— FUNCTION (left, right : integer) RETURN integer: 

— FUNCTION (left, right : integer) RETURN integer; 

— FUNCTION "*" (left, right : integer) RETURN integer: 

— FUNCTION "/" (left, right : integer) RETURN integer; 

— FUNCTION "REM" (left, right : integer) RETURN integer; 

— FUNCTION "MOD" (left, right : integer) RETURN integer; 

— FUNCTION "**" (left : integer; right : integer) RETURN integer; 

— An implementation may provide additional predefined integer types. 

— It is recommended that the names of such additional types end 

— with INTEGER as in SHORT-INTEGER or LONG-INTEGER. The 

— specification of each operator for the type universal-integer, or 

— for any additional predefined integer type, is obtained by 

-- replacing INTEGER by the name of the type in the specification 

— of the corresponding operator of the type INTEGER, except for the 

— right operand of the exponentiating operator. 

TYPE short-integer IS RANGE - 32-768 .. 32-767; 

TYPE short-short-integer IS RANGE - 128 .. 127; 

— The universal type universal-real is predefined. 

TYPE float IS DIGITS 9 RANGE 

- 16#0.7FFF_FFFF_FFFF_FF8#E+32 .. 

16#0.7FFF_FFFF_FFFF_FF8#E+32; 

— the corresponding machine type is D-FLOAT 

— The predefined operators for this type are as follows: 

— FUNCTION "«" (left, right : float) RETURN boolean; 

— FUNCTION "/»" (left, right : float) RETURN boolean; 

— FUNCTION "<" (left, right : float) RETURN boolean; 

— FUNCTION "<»" (left, right : float) RETURN boolean; 

— FUNCTION ">" (left, right : float) RETURN boolean; 

— FUNCTION ">«" (left, right : float) RETURN boolean; 


276 


SYSTEAM Ada System - User Manual 








Predefined Language Environment 


Chapter 13 


~ FUNCTION (right : float) RETURN float: 

— FUNCTION (right : float) RETURN float; 

— FUNCTION "ABS" (right : float) RETURN float; 

— FUNCTION (left, right : float) RETURN float; 

— FUNCTION (left, right : float) RETURN float; 

— FUNCTION (left, right : float) RETURN float; 

— FUNCTION "/" (left, right : float) RETURN float; 

— FUNCTION "**" (left : float; right : integer) RETURN float; 

— An implementation may provide additional predefined floating 

— point types. It is recommended that the names of such additional 

— types end with FLOAT as in SHORT-FLOAT or LQNG_FLQAT. 

— The specification of each operator for the type universal-real, 

— or for any additional predefined floating point type, is obtained 

— by replacing FLOAT by the name of the type in the specification of 

— the corresponding operator of the type FLOAT. 

TYPE short-float IS DIGITS 6 RANGE 

- 16#0.7FFF-FF8#E+32 .. 16#0.7FFF_FF8#E+32; 

— the corresponding machine type is F-FLOAT 

TYPE long-float IS DIGITS IS RANGE 

- 16#0.7FFF_FFFF_FFFF_FC#E+256 .. 

16#0.7FFF_FFFF_FFFF_FC#E+256; 

— the corresponding machine type is G-FLOAT 

TYPE long-long-float IS DIGITS 33 RANGE 

- 16#0.7FFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_C#E+4096 .. 

16#0.7FFF_FFFF_FFFF_FFFF_FFFF_FFFF_FFFF_C#E+4096; 

— the corresponding machine type is H-FLOAT 

— In addition, the following operators are predefined for universal 

— types: 

-- FUNCTION (left : UNIVERSAL-INTEGER; right : UNIVERSAL-REAL) 
RETURN UNIVERSAL-REAL; 

— FUNCTION »*• (left : UNIVERSAL-REAL; right : UNIVERSAL-INTEGER) 

RETURN UNIVERSAL-REAL; 

— FUNCTION "/" (left : UNIVERSAL-REAL; right : UNIVERSAL-INTEGER) 

RETURN UNIVERSAL-REAL; 

-- The type universal-fixed is predefined. 

— The only operators declared for this type are 

— FUNCTION •*■ (left : ANY-FIXED-POINT-TYPE; 


SYSTEAM Ada System - User Manual 


277 






Chapter 13 


Predefined Language Environment 


right : ANY-FIXED-POINT-TYPE) RETURN UNIVERSAL-FIXED; 

— FUNCTION ■/" (left : ANY-FIXED-POINT-TYPE; 

right : ANY-FIXED-POINT-TYPE) RETURN UNIVERSAL-FIXED; 

— The following characters form the standard ASCII character set. 

— Character literals corresponding to control characters are not 

— identifiers. 

TYPE character IS 


(nul. 

soh. 

stx. 

etx. 

eot, 

enq. 

ack. 

bel. 

bs. 

ht. 

If. 

vt. 

ff. 

cr. 

so. 

si. 

die. 

del. 

dc2. 

dc3. 

dc4. 

nak. 

syn. 

etb. 

can. 

em. 

sub. 

esc, 

fs. 

gs. 

rs. 

us. 

e • 

• 

• 1 • 

• s 

• It • 

• 


■$*. 


**\ 

• • • 

• 

•c\ 

*)•. 

•*\ 

*♦•. 

• I 

• » 

• — • 

• 

t • 

• • 

V. 

•O'. 

•1*. 

'2'. 

*3 ’, 

•4*. 

*5'. 

*6’. 

•7*. 

'8*. 

•9*. 

• • • 

• • 

• . • 

• e 

'<•. 

•»* 

• 

•>\ 

• • 


•A*. 

•B\ 

•C\ 

*D*. 

'E*, 

’F*. 

•c\ 

*H\ 

•I*. 

'J*. 

•K*. 

*L\ 


•N*. 

•0\ 

•P*. 

•Q\ 

*R\ 

•s*. 

•T*. 

•u\ 

•V*. 

•w*. 

*x*. 

•Y\ 

*2*. 


•v. 


• • 

• 

• • 

— • 

Ml 

• 

’a’. 

•b\ 

•c*. 

*d\ 

•e*. 

*f\ 

•s’. 

•h\ 

•i\ 

•j’. 

•k*. 

•1*. 

’m*. 

•n'. 

•o*. 

•P’. 

i.i 
<1 • 

•r\ 

's*. 

*t\ 

•u*. 

*v*. 

*w’, 

*x*. 

•*» 
j • 

*z\ 


•i\ 


• 1 

• 

del) 


FOR character USE — 128 ascii CHARACTER SET WITHOUT HOLES 

(0. 1. 2. 3, 4. 5. 125, 126. 127); 

— The predefined operators for the type CHARACTER are the same as 

— for any enumeration type. 

PACKAGE ascii IS 


Control characters: 


nul 


CONSTANT 

character 

• a 

nul; 

soh 

CONSTANT 

character 

• X 

soh; 

stx 


CONSTANT 

character 

; a 

stx; 

etx 

CONSTANT 

character 

• X 

etx; 

eot 


CONSTANT 

character 

l a 

eot; 

enq 

CONSTANT 

character 

J X 

enq; 

ack 


CONSTANT 

character 

j a 

ack; 

bel 

CONSTANT 

character 

• X 

bel; 

bs 


CONSTANT 

character 

• m 

bs; 

ht 

CONSTANT 

character 

; x 

ht; 

If 


CONSTANT 

character 

l * 

If: 

vt 

CONSTANT 

character 

* X 

vt; 

ff 


CONSTANT 

character 

• a 

ff; 

cr 

CONSTANT 

character 

• X 

cr; 

so 


CONSTANT 

character 

• a 

so; 

si 

CONSTANT 

character 

• X 

si; 

die 


CONSTANT 

character 

• a 

die; 

del 

CONSTANT 

character 

l 9 

del; 

dc2 


CONSTANT 

character 

• a 

dc2; 

dc3 

CONSTANT 

character 

• X 

dc3; 

dc4 


CONSTANT 

character 

; a 

dc4; 

nak 

CONSTANT 

character 

• X 

nak; 

syn 


CONSTANT 

character 

• a 

syn; 

etb 

CONSTANT 

character 

l X 

etb; 

can 


CONSTANT 

character 

; a 

can; 

em 

CONSTANT 

character 

; x 

em; 


278 


SYSTEAM Ada System - User Manual 





























Predefined Language Environment 


Chapter 13 


sub : CONSTANT character := sub; esc : CONSTANT character := esc; 

fs : CONSTANT character := fs; gs : CONSTANT character := gs; 

rs : CONSTANT character ;= rs; us : CONSTANT character := us; 

del : CONSTANT character ;= del; 

— Other characters: 


exclam 

CONSTANT character 

s • 1 • 

quotation 

CONSTANT character 

3 » It • 

sharp 

CONSTANT character 

■ ’#’ 

dollar 

CONSTANT character 

= '$• 

percent 

CONSTANT character 

= *r 

ampersand 

CONSTANT character 

= ’A’ 

colon 

CONSTANT character 

3 • . » 

semicolon 

CONSTANT character 

3 • . • 

t 

query 

CONSTANT character 

3 '?' 

at-sign 

CONSTANT character 

3 •$* 

1 -bracket 

CONSTANT character 

3 •[* 

back-slash 

CONSTANT character 

3 

r.bracket 

CONSTANT character 

3 •]' 

circumflex 

CONSTANT character 

S f 1 

underline 

CONSTANT character 

B I • 

grave 

CONSTANT character 

m • • • 

1 -brace 

CONSTANT character 

3 

bar 

CONSTANT character 

3 * | ’ 

r.brace 

CONSTANT character 

3 *}• 

tilde 

CONSTANT character 

3 »»; 


lc_a : CONSTANT character :■ ’a'; 


lc_z : CONSTANT character :■ ’z'l 
END ascii; 

— Predefined subtypes: 

SUBTYPE natural IS integer RANGE 0 .. integer*last; 
SUBTYPE positive IS integer RANGE 1 .. integer’last; 

— Predefined string type: 

TYPE string IS ARRAY(positive RANGE <>) OF character; 
PRAGMA pack(string); 

— The predefined operators for this type are as follows: 


SYSTEAM Ada System - User Manual 


279 









Chapter 13 


Predefined Language Environment 


— FUNCTION (left, right : string) RETURN boolean; 

— FUNCTION (left, right : string) RETURN boolean; 

— FUNCTION *<■ (left, right : string) RETURN boolean; 

— FUNCTION »<-■ (left, right : string) RETURN boolean; 

— FUNCTION ">" (left, right : string) RETURN boolean; 

— FUNCTION ">»" (left, right : string) RETURN boolean; 

— FUNCTION "4" (left : string; right : string) RETURN string; 

— FUNCTION "4" (left : character; right : string) RETURN string; 

— FUNCTION "4" (left : string: right : character) RETURN string; 

— FUNCTION "4" (left : character; right : character) RETURN string; 

TYPE duration IS DELTA 2#1.0#E-14 RANGE 

- 131-072.0 .. 131-071.999_938_964_843_75; 

— The predefined operators for the type DURATION are the same 

— as for any fixed point type. 

— the predefined exceptions: 

constraint-error : EXCEPTION; 

numeric-error : EXCEPTION; 

program-error : EXCEPTION; 

storage-error : EXCEPTION; 

tasking-error : EXCEPTION; 

END standard; 


13.2 Language-Defined Library Units 

The following language-defined library units are included in the master library: 

The package system 
The package calendar 

The generic procedure unchecked-deallocation 

The generic function unchecked-conversion 

The package io-exceptions 

The generic package sequential-io 

The generic package direct-io 

The package text_io 

The package low-level-io 


280 


SYSTEAM Ada System - User Manual 








Predefined Language Environment 


Chapter 13 


13.3 Implementation-Defined Library Units 

The master library also contains the implementation-defined library units collection 
manager and timing. 


13.3.1 The Package COLLECTION-MANAGER 

In addition to unchecked storage deallocation (cf. LRM(§13.10.1)), this implementa¬ 
tion provides the generic package collection-manager, which has advantages over 
unchecked deallocation in some applications; e.g. it makes it possible to clear a collec¬ 
tion with a single reset operation. See §15.10 for further information on the use of the 
collection manager and unchecked deallocation. 

The package specification is: 


GENERIC 

TYPE elem IS LIMITED PRIVATE; 

TYPE acc IS ACCESS elem; 

PACKAGE collection-manager IS 

TYPE status IS LIMITED PRIVATE; 

PROCEDURE mark (s : OUT status); 

— Marks the heap of type ACC and 

— delivers the actual status of this heap. 

PROCEDURE release (s : IN status); 

— Restore the status s on the collection of ACC. 

-- RELEASE without previous MARK raises CONSTRAINT-ERROR 

PROCEDURE reset; 

— Deallocate all objects on the heap of ACC 
PRIVATE 

— private declarations 


SYSTEAM Ada System - User Manual 


281 







Chapter 13 


Predefined Language Environment 


END collection-manager; 


A call of the procedure release with an actual parameter s causes the storage occupied 
by those objects of type acc which were allocated after the call of mark that delivered 
s as result, to be reclaimed. A call of reset causes the storage occupied by all objects 
of type acc which have been allocated so far to be reclaimed and cancels the effect of 
all previous calls of mark. 

See §15.2.1 for information on static and dynamic collections and the attribute STOR¬ 
AGE-SIZE. 


13.3.2 The Package TIMING 

The package timing provides a facility for CPU-time measurement. The package 
specification is: 


PACKAGE timing IS 

FUNCTION cpu-time RETURN natural; 
timing-error : EXCEPTION; 

END timing; 


A cadi of the function cpu-time returns the CPU-time consumed by the running process 
in milliseconds. The value natural’last will be reached after 24 days, 20 hours, 31 
minutes, 23 seconds and 647 milliseconds. 

The exception timing-error will be raised if a constraint-error or numeric-error 
occurs within cpu-time. 


282 


SYSTEAM Ada System - User Manual 




Appendix F 


Chapter 15 


15 Appendix F 

This chapter, together with the Chapters 16 and 17, is the Appendix F required in the 
LRM, in which all implementation-dependent characteristics of an Ada implementation 
are described. 


15.1 Implementation-Dependent Pragmas 

The form, allowed places, and effect of every implementation-dependent pragma is 
stated in this section. 


15.1.1 Predefined Language Pragmas 

The form and allowed places of the following pragmas are defined by the language; 
their effect is (at least partly) implementation-dependent and stated here. 

CONTROLLED 
has no effect. 


ELABORATE 

is fully implemented. The SYSTEAM Ada System assumes a PRAGMA elaborate, 
i.e. stores a unit in the library as if a PRAGMA elaborate for a unit u was given, 
if the compiled unit contains an instantiantion of u (or for a generic program unit 
in u) and if it is clear that u must have been elaborated before the compiled unit. 
In this case an appropriate information message is given. By this means it is 
avoided that an elaboration order is chosen which would lead to a PROGRAM- 
ERROR when elaborating the instantiation. 


INLINE 

Inline expansion of subprograms is supported with the following restrictions: 
the subprogram must not contain declarations of other subprograms, tasks, generic 
uni ts or body stubs. If the subprogram is called recursively only the outer call of 
this subprogram will be expanded. 


SYSTEAM Ada System - User Manual 


285 





Chapter 15 


Appendix F 


INTERFACE 

is supported for ASSEMBLER and VMS. PRAGMA interface (assembler....) 
provides an interface with the internal calling conventions of the SYSTEAM Ada 
System. See §15.1.3 for further description. 

PRAGMA interface (VMS,...) is provided to support the VAX procedure calling 
standard. §15.1.4 describes how to use this pragma. 

PRAGMA interface should always be used in connection with the PRAGMA exter¬ 
nal-name (see §15.1.2), otherwise the Compiler will generate an internal name 
that leads to an unsolved reference during linking. These generated names are 
prefixed with an underline; therefore the user should not use names beginning 
with an underline. 

LIST 

is fully implemented. Note that a listing is only generated when the /LIST 
qualifier is specified with the SAS COMPILE (or SAS COMPLETE or SAS LINK) 
command. 


MEMORY-SIZE 
has no effect. 


OPTIMIZE 

has no effect; but see also the /OPTIMIZER qualifier with the SAS COMPILE 
command, §4.1 


PACK 

see §16.1. 


PAGE 

is fully implemented. Note that form feed characters in the source do not cause 
a new page in the listing. They are - as well the other format effectors (horizontal 
tabulation, vertical tabulation, carriage return, and line feed) - replaced by a " 
character in the listing. 


PRIORITY 

There are two implementation-defined aspects of this pragma: First, the range of 


286 


SYSTEAM Ada System - User Manual 






Appendix F 


Chapter 15 


the subtype priority, and second, the effect on scheduling (Chapter 14) of not 
giving this pragma for a task or main program. The range of subtype priority is 
0 .. 15, as declared in the predefined library package system (see §15.3); and the 
effect on scheduling of leaving the priority of a task or main program undefined by 
not giving PRAGMA priority for it is the same as if the PRAGMA priority 0 
had been given (i.e. the task has the lowest priority). 


SHARED 

is fully supported. 


STORAGE-UNIT 
has no effect. 


SUPPRESS 

has no effect, but see §15.1.2 for the implementation-defined PRAGMA suppress, 
all. 


SYSTEMJfAME 
has no effect. 


15.1.2 Implementation-Defined Pragmas 

BYTE-PACK 
see §16.1. 


EXTERNAL-NAME (<string>, <ada_name>) 

<ada_name> specifies the nan -4 of a subprogram or of an object declared in a 
library package, <string> must be a string literal. It defines the external name 
of the specified item. The Compiler uses a symbol with this name in the call 
instruction for the subprogram. The subprogram declaration of <ad a ,. nam e> must 
precede this pragma. If several subprograms with the same name satisfy this 
requirement the pragma refers to that subprogram which is declared last. 

Upper and lower cases are distinguished within <string>, i.e. <string> must be 
given exactly as it is to be used by external routines. This pragma will be used in 


SYSTEAM Ada System - User Manual 


287 





Chapter 15 


Appendix F 


connection with the pragmas interface (vms) or interface (assembler) (see 
§15.1.1). 


RESIDENT (<ada_name>) 

this pragma causes the value of the object to be held in memory and prevents 
assignments of a value to the object <ada_name> from being e limin ated by the 
optimizer (see §4.1) of the SYSTEAM Ada Compiler. The following code sequence 
demonstrates the intended usage of the pragma: 


x : integer; 
a : SYSTEM.address; 


• • • 

BEGIN 
x ;« 5; 

a x’ADDRESS; 

do.something (a); 


x ;« 6; 


— let do_aomething be a non-local 

— procedure 

— a.ALL will be read in the body 
—of do_something 


If this code sequence is compiled by the SYSTEAM Ada Compiler with the /OP¬ 
TIMIZE qualifier the statement x : * 5; will be eliminated because from the point 
of view of the optimizer the value of x is not used before the next assi gnm ent to 
x. Therefore 

PRAGMA resident (x); 

should be inserted after the declaration of x. 

This pragma can be applied to all those kinds of objects for which the address 
clause is supported (cf. §16.5). 

It will often be used in connection with the PRAGMA interface (vms, ... ) 
(see §15.1.4). 


SUPPRESS_ALL 

causes all the runtime checks described in the LRM(§11.7) to be suppressed; this 
pragma is only allowed at the start of a compilation before the first compilation 
unit; it applies to the whole compilation. 


288 


SYSTEAM Ada System - User Manual 








Appendix F 


Chapter 15 


15.1.3 Pragma Interface (Assembler,...) 

This section describes the internal calling conventions of the SYSTEAM Ada System, 
which are the same ones which are used for subprograms for which a PRAGMA inter¬ 
face (ASSEMBLER....) is given. Thus the actual meaning of this pragma is simply 
that the body needs and must not be provided in Ada, but in object form using the 
/EXTERNAL qualifier with the SAS LINK command. 

In many cases it is more convenient to follow the VAX procedure calling 
standard. Therefore the SYSTEAM Ada System provides the PRAGMA in¬ 
terface (VMS, ...), which supports the standard return of the function result 
and the standard register saving. This pragma is described in the next sec¬ 
tion. 

The internal calling conventions are explained in four steps: 

- Parameter passing mechanism 

- Ordering of parameters 

- Type mapping 

- Saving registers 


Parameter passing mechanism: 

The parameters of a call to a subprogram are placed by the caller in an area called 
parameter block. This area is aligned on a longword boundary and contains parameter 
values (for parameter of scalar types), descriptors (for parameter of composite types) 
and alignment gaps. 

For a function subprogram an extra field is assigned at the beginning of the parameter 
block containing the function result upon return. Thus the return value of a function is 
treated like an anonymous parameter of mode OUT. No special treatment is required 
for a function result except for return values of an unconstrained array type (see below). 

A subprogram is called using the CALLG instruction. The address pointing to the 
be ginning of the parameter block and the code address of the subprogram are specified 
as operands. Within the called subprogram the parameter block is accessed via the 
argument pointer AP. 

In general, the ordering of the parameter values within the parameter block does not 
agree with the order specified in the Ada subprogram specification. When determining 
the position of a parameter within the parameter block the calling mechanism and the 
size and alignment requirements of the parameter type are considered. The size and 
aligment requirements and the passing mechanism are described in the following: 

Scalar parameters or parameters of access types are passed by value, i.e. the values 
of the actual parameters of modes IN or IN OUT are copied into the parameter block 


SYSTEAM Ada System - User Manual 


289 



Chapter 15 


Appendix F 


before the call. Then, aft ^r the subprogram has returned, values of the actual pa¬ 
rameters of modes IN OUT and OUT are copied out of the parameter block into the 
associated actual parameters. The parameters are aligned within the parameter block 
according to their size: A parameter with a size of 8, 16 or 32 bits (or a multiple of 
8 bits greater than 32) has an alignment of 1, 2 or 4 (which means that the object 
is aligned to a byte, word or longword boundary within the parameter block). If the 
size of the parameter is not a multiple of 8 bits (which may be achieved by attaching 
a size specification to the parameter’s type in case of an integer, enumeration or fixed 
point type) it will be byte aligned. Parameters of access types are always aligned to a 
longword boundary. 

For parameters of composite types, descriptors are placed in the parameter block in¬ 
stead of the complete object values. A descriptor contains the address of the actud 
parameter object and, possibly, further information dependent on the specific param¬ 
eter type. The following composite parameter types are distinguished: 

• A parameter of a constrained array type is passed by reference for all parameter 
modes. 

« For a parameter of an unconstrained array type, the descriptor consists of the 
address of the actud array parameter followed by the bounds for each index range 
in the array (i.e. FIRST(l), LAST(l), FIRST(2), LAST(2), ...). The space allo¬ 
cated for the bound elements in the descriptor depends on the type of the index 
constraint. 

• For functions whose return value is an unconstrained array type a descriptor for the 
array is passed in the parameter block as for parameters of mode OUT. The fields 
for its address and all array index bounds are filled up by the function before it 
returns. In contrast to the procedure for an OUT parameter, the function allocates 
the array in its own stack space. The function then returns without releasing its 
stack space. After the function has returned, the calling routine copies the array 
into its own memory space and then deallocates the stack memory of the function. 

• A constrained record parameter is passed by reference for all parameter modes. 

• For an unconstrained record parameter of mode IN, the parameter is passed by 
reference using the address pointing to the record. 

If the par am eter has mode OUT or IN OUT, the value of the CONSTRAINED at¬ 
tribute applied to the actual parameter is passed as an additional boolean IN 
parameter (which occupies one byte in the parameter block and is aligned to a 
byte boundary). The boolean IN parameter and the address are treated like two 
consecutive parameters in a subprogram specification, i.e. the positions of the 
two parameters wihtin the parameter block are determined independently of each 
other. 

For all kinds of composite parameter types the pointer pointing to the actual param¬ 
eter object is represented by a 32 bit address, which is always aligned to a longword 
boundary. 


290 


SYSTEAM Ada System - User Manual 





Appendix F 


Chapter 15 


Ordering of parameters: 

The ordering of the parameters in the parameter block is determined as follows: 

The parameters are processed in the order they are defined in the Ada subprogram 
specification. For a function the return value is treated as an anonymous parameter 
of mode OUT at the staxt of the parameter list. Because of the size and alignment 
requirements of a parameter it is not always possible to place parameters in such a way 
that two consecutive parameters axe densely located in the parameter block. In such a 
situation a gap, i.e. a piece of memory space which is not associated with a parameter, 
exists between two adjacent parameters. Consequently, the size of the parameter block 
will be larger than the sum of the sizes used for all parameters. In order to minimize 
the size of the gaps in a parameter block am attempt is made to fill each gap with a 
parameter that occurs later in the parameter list. If during the allocation of space 
within the parameter block a parameter is encountered whose size and alignment fit 
the characteristics of an available gap, then this gap is allocated for the parameter 
instead of appending it at the end of the parameter block. As each parameter will be 
aligned to a byte, word or longword boundary the size of any gap may be one, two 
or three bytes. Every gap of size three bytes cam be treated as two gaps, one of size 
one byte with an alignment of 1 and one of size two bytes with an alignment of 2. So, 
if a parameter of size two is to be adlocated, a two byte gap, if available, is filled up. 
A parameter of size one will fill a one byte gap. If none exists but a two byte gap is 
available, this is used as two one byte gaps. By this first fit algorithm ail parameters 
are processed in the order they occur in the Ada program. 

A called subprogram accesses each parameter for reading or writing using the argument 
pointer AP incremented by am offset from the start of the parameter block suitable for 
the parameter. So the value of a parameter of a scalar type or am access type is read 
(or written) directly from (into) the parameter block. For a parameter of a composite 
type the actual parameter value is accessed via the descriptor stored in the parameter 
block which contains a pointer to the actual object. 


Type mapping: 

To access individual components of array or record types, knowledge about the type 
mapping for array and record types is required. An array is stored as a sequential 
concatenation of all its components. Normally, pad bits are used to fill each component 
to a byte, word, longword or a multiple thereof in dependence on the size and alignment 
requirements of the components’ subtype. This padding may be influenced using one 
of the PRAGMAS pack or byte_pack (cf. §16.1). The offset of an individual array 
component is then obtained by multiplying the padded size of one array component 
by the number of components stored in the array before it. This number may be 
determined from the number of elements for each dimension using the fact that the 
array elements are stored column by column. (For unconstrained arrays the number 
of elements for each dimension can be found in the descriptor stored in the parameter 
block.) 


SYSTEAM Ada System - User Manual 


291 








Chapter 15 


Appendix F 


A record object is implemented as a concatenation of its components. Initially, loca¬ 
tions are reserved for those components that have a component clause applied to them. 
Then locations for all other components are reserved. Any gaps large enough to hold 
components without component clauses are filled, so in general the record components 
are rearranged. Components in record variants are overlaid. The ordering mechanism 
of the components within a record is in principle the same as that for ordering the 
parameters in the parameter block. 

A record may hold implementation-dependent components (cf. §16.4). For a record 
component whose size depends on discriminants, a generated component holds the 
offset of the record component within the record object. If a record type includes 
variant parts there may be a generated component (cf. §16.4) holding the size of the 
record object. This size component is allocated as the first component within the record 
object if this location is not reserved by a component clause. Since the mapping of 
record types is rather complex you should introduce record component clauses for each 
record component if you want to pass an object of that type to a non Ada subprogram 
to be sure to access the components correctly. 

Saving registers: 

The last aspect of the calling conventions discussed here is that of saving registers. The 
calling subprogram assumes that the values of the registers RO .. R5 will be destroyed 
by the called subprogram and saves them of its own accord. If the called subprogram 
wants to modify further register these must be specified in the procedure entry mask to 
ensure that they are pushed on the stack when entering the subprogram and restored 
when leaving it. This differs from the VAX procedure calling standard, which demands 
that all registers which are modified by the subprogram except RO and Rl must be 
specified in the mask. 


15.1.4 Pragma Interface(VMS,...) 

The SYSTEAM Ada System supports PRAGMA interface (VMS,...). 

With the help of this pragma and by obeying some rules (described below) subprograms 
can be called which follow the VAX procedure calling standard. As the user must 
know something about the internal calling conventions of the SYSTEAM Ada System 
we recommend reading §15.1.3 before reading this section and before using PRAGMA 
interface(VMS,...). 

In comparison to PRAGMA interface (assembler,...) PRAGMA interface (VMS,...) 
has two additional effects: 


292 


SYSTEAM Ada System - User Manual 




Appendix F 


Chapter 15 


• If the subprogram is a function it moves the function result in RO (or RQ and Rl 
for results of size 8 byte) into the allocated area at the beginning of the parameter 
block. 

• It controls register allocation in such a way that it is assumed (according to the 
standard) that the called subprogram only modifies the registers RO and Rl. 

The code for subprograms for which PRAGMA Interface (VMS....) is specified can 
reside in one of the VMS object libraries, which are searched by default, or can be 
provided using the /EXTERNAL qualifier with the SAS LINK command. 

In order to follow the VAX procedure calling standard in all aspects the user has to 
cover three other aspects: 

- The order of the parameters in the parameter block must be the same as in the 
Ada procedure specification. Because of the gap optimization - as described in the 
previous section - you can enforce this by using only parameters of 4 byte length (for 
example integer or access types). According to the VAX procedure calling standard 
shorter parameters are not used anyway. Note, that the Compiler will use a shorter 
representation where possible, even if there is no PRAGMA pack and no a repre¬ 
sentation clause. Thus a parameter of type boolean cannot be passed by value; you 
must specify integer instead, and pass the appropriate corresponding integer value (0 
or 1). Most of the parameters of the VMS system calls or of the run time library are 
passed by reference anyway; In this case the parameter can be declared to be of type 
SYSTEM.ADDRESS and the actual parameter is then <variable>’ADDRESS. For 
the function result the same rules apply as for the parameters, with one exception: 
You can also use the (predefined) types FLOAT and L0NG_FL0AT, which both have a 
size of 8 bytes (or equivalent floating point types which are mapped onto these two 
predefined types.) 

- It is an additional convention that the first parameter in the parameter block is of 
type integer and denotes the number of parameters which are passed. This is easily 
achieved by the user by adding a first parameter of type integer with a default value. 
By this means, the calls are not affected, provided parameter association is always 
named and not positional. 

Note: PRAGMA interface (vms,...) adds an additional parameter in front of this if 
the subprogram is a function. The Compiler then correctly passes the address in the 
parameter block where the first Ada parameter begins, i.e the first extra parameter 
for the function result, which exists only in the SYSTEAM Ada System internal 
calling conventions, is not present in the called function. 

- The last aspect which is not handled by the SYSTEAM Ada System is the support 
of complex types, such as string descriptors, etc. These types can be built in the Ada 
program by appropriate record declarations, with representation clauses if necessary. 


SYSTEAM Ada System - User Manual 


293 







Chapter 15 


Appendix F 


Summary: If you use only 4 byte parameters and specifiy PRAGMA interface (VMS,...) 

and add an additional first integer parameter which holds the number of pa¬ 
rameters, then the procedure call generated by the SYSTEAM Ada System 
conforms to the VAX procedure calling standard. 

Note: For parameters which are passed by reference by declaring the formal parameter 
of type SYSTEM.ADDRESS and passing the parameter by <object>’ADDRESS, the 
SYSTEAM Ada System typically needs PRAGMA resident to be specified for the actual 
parameter. This prevents the Optimizer of the SYSTEAM Ada System from holding 
the value of the parameter in a register or even eliminating it completely, because there 
is no further access to the parameter - from the Optimizers point of view. (cf. §15.1.2) 

The SYSTEAM Ada System does not check the observance of the VAX procedure 
calling standard. If it is violated the call of the non Ada routine will be erroneous. 

The following example shows the intended usage of PRAGMA interface (VMS,...) to 
call a VMS system routine. First some types with representation specifications and 
objects of those types are declared. Then the Ada specification of sys.qio appears and 
is related through appropriate pragmas to the system service SYS$QIO. It is assume d 
that the function is called in the body of the main program. This example further 
shows the use of interrupt entries with the SYSTEAM Ada System (cf. §16.5.1.2). 


WITH system, text-io; 

PROCEDURE vms-routine IS 

readprompt : CONSTANT :» 55; 

m_noecho : CONSTANT :« 64; 

null-address : CONSTANT system.address :* system.address-zero; 

TYPE iosb-type IS 
RECORD 

condition-value : short-integer; 
transfer-count : short-integer; 
dev-spec.info : integer; 

END RECORD; 

FOR iosb-type USE 
RECORD 

condition-value AT 0 RANGE 0 .. 15; 

transfer-count AT 0 RANGE 16 .. 31; 
dev-spec.info AT 4 RANGE 0 ..31; 

END RECORD; 


294 


SYSTEAM Ada System - User Manual 








Appendix F 


Chapter 15 


chan : integer; 

res : integer; 

io.buffer : string (1 .. 80); 

PRAGMA resident (io_buffer); 

prompt-buffer ; string (1 .. 2) := "* 

PRAGMA resident (prompt-buffer); 

iosb : iosb_type; 

PRAGMA resident (iosb); 

FUNCTION sys.qio (n : integer ;* 12; -- number of parameters 

efn : integer :* 0; — event flag number 

chan : integer; — channel 

func : integer; — function code 

iosb : system.address :* null-address; 

— 10 status block 

astadr : system.address :» null_address; 

— AST routine 

astprm : integer :» 0; 

pi : system.address; ~ 10 buffer 

p2 ; integer :» 0; — 10 buffer length 

p3 ; integer :■ 0; — timeout 

p4 : integer :■ 0; — read terminator 

p5 : system.address :» null-address; 

— prompt buffer 

p6 : integer :* 0) — prompt buffer length 

RETURN integer; 

PRAGMA interface (vms, sys.qio); 

— and additionally 

PRAGMA external-name ("SYS$QI0", sys.qio); 

vector-number : CONSTANT :■ 0; 
ast.parameter : CONSTANT 123_456_789; 

TASK buffer-handler IS 
PRAGMA priority (15); 

ENTRY buffer.read (param : integer); 

FOR buffer.read USE AT system.interrupt.vector (vector-number); 
END buffer-handler; 

TASK BODY buffer-handler IS 
BEGIN 

ACCEPT buffer-read (param : integer) DO 


— channel number 

— return code 


SYSTEAM Ada System - User Manual 


295 









Chapter 15 


Appendix F 


text_io.put_line (io_buffer); 

END buffer-read; 

END buffer-handler; 

BEGIN 

— after an appropriate ASSIGN channel call: 

res :» 

sys.qio (chan => chan, 

func *> readprompt ♦ m_noecho, 
iosb *> iosb*address, 

astadr *> system.ast_service (vector-number), 

astprm »> ast_parameter, 

pi *> io-buffer’address, 

p2 ■> io-buffer*length, 

p3 ■> 0, . 

p4 ■> 0. 

p5 «> prompt-buffer’address, 
p6 *> prompt-buffer•length); 

END vms-routine; 


15.2 Implementation-Dependent Attributes 

The name, type and implementation-dependent aspects of every implementation-de- 
pendent attribute is stated in this section. 


15.2.1 Language-Defined Attributes 

The name and type of all the language-defined attributes are as given in the LRM. We 
note here only the implementation-dependent aspects. 

ADDRESS 


If this attribute is applied to an object for which storage is allocated, it yields the 
address of the first storage unit that is occupied by the object. 

If it is applied to a subprogram or to a task, it yields the address of the entry 
point of the subprogram or task body. 


296 


SYSTEAM Ada System - User Manual 







Appendix F 


Chapter 15 


If it is applied to a task entry for which an address clause is given, it yields the 
address given in the address clause. 

For any other entity this attribute is not supported and will return the value 
system.address_zero. 


IMAGE 

The image of a character other than a graphic character (cf. LRM(§3.5.5(11))) 
is the string obtained by replacing each italic character in the indication of the 
character literal (given in the LRM(Annex C(13))) by the corresponding upper¬ 
case character. For example, character ’image(nuO » "NUL". 


MACHINE-OVERFLOWS 

Yields true for each real type or subtype. 


MACHINE-ROUNDS 

Yields true for each real type or subtype. 


STORAGE-SIZE 

The value delivered by this attribute applied to an access type is as follows: 

If a length specification (STORAGE-SIZE, see §16.2) has been given for that type 
(static collection), the attribute delivers that specified value. 

In case of a dynamic collection, i.e. no length specification by STORAGE-SIZE given 
for the access type, the attribute delivers the number of storage units currently 
allocated for the collection. Note that dynamic collections are extended if needed. 
If the collection manager (cf. §13.3.1) is used for a dynamic collection the attribute 
delivers the number of storage units currently allocated for the collection. Note 
that in this case the number of storage units currently allocated may be decreased 
by release operations. 

The value delivered by this attribute applied to a task type or task object is as 
follows: 

If a length specification (STORAGE-SIZE, see §16.2) has been given for the task 
type, the attribute delivers that specified value; otherwise, the default value is 
returned. 


15.2.2 Implementation-Defined Attributes 


There are no implementation-defined attributes. 


SYSTEAM Ada System - User Manual 


297 










Chapter 15 


Appendix F 


15.3 Specification of the Package SYSTEM 

The package system as required in the LRM(§13.7) is reprinted here with all imple¬ 
mentation-dependent characteristics and extensions filled in. 


PACKAGE system IS 

TYPE designated-by-address IS LIMITED PRIVATE; 

TYPE address IS ACCESS designated-by.address; 

FOR address‘storage-size USE 0; 

address_zero : CONSTANT address :• NULL; 

TYPE name IS (vax-vms); 

system-name : CONSTANT name :* vax-vms; 

storage-unit ; CONSTANT 8; 

memory-size : CONSTANT :■ 2 ** 31; 

min_int : CONSTANT :« - 2 ** 31; 

max_int : CONSTANT ;« 2 ** 31 - 1; 

max-digits : CONSTANT ;» 33; 

max-mantissa : CONSTANT :■ 31; 

fine-delta : CONSTANT ;= 2.0 ** (31); 
tick : CONSTANT :» 0.01; 

SUBTYPE priority IS integer RANGE 0 .. 15; 

FUNCTION "♦* (left : address; right ; integer) RETURN address; 

FUNCTION "♦" (left : integer; right : address) RETURN address; 

FUNCTION "-" (left : address; right : integer) RETURN address; 

FUNCTION "-" (left : address; right : address) RETURN integer; 

SUBTYPE external-address IS STRING; 

— External addresses use hexadecimal notation with characters 
— ‘O'..’9*. ‘a'.-’f and ’A’.-'F’. For instance: 

"7FFFFFFF" 

"80000000" 











Appendix F 


Chapter 15 


— "8" represents the same address as "00000008" 

FUNCTION convert .address (addr : external-address) RETURN address; 

— CONSTRAINT-ERROR is raised if the external address ADDR 

— is the empty string, contains characters other than 

— *0*..*9*. *a’..*f’. *A*..*F* or if the resulting address 

— value cannot be represented with 32 bits. 

FUNCTION convert-address (addr : address) RETURN external-address; 

— The resulting external address consists of exactly 8 

— characters , 0 , ..’9' 1 *A*..*F*. 

TYPE interrupt-number IS RANGE 0 .. 31; 

TYPE interrupt-addresses IS ARRAY (interrupt-number) OF address; 
ast-service, 

interrupt-vector : interrupt-addresses; 
non_ada.error : EXCEPTION; 

— non_ada_error is raised, if some event occurs which does not 

— correspond to any situation covered by Ada. e.g.: 

— illegal instruction encountered 

— error during address translation 

— illegal address 

TYPE exception-id IS NEW address; 

no-exception-id : CONSTANT exception-id :* address-zero; 

— Coding of the predefined exceptions; 

constraint-error-id : CONSTANT exception-id : a ... ; 

numeric-error-id r CONSTANT exception-id : a ... ; 

program-error-id : CONSTANT exception-id :* ... ; 

storage-error-id : CONSTANT exception-id :■ ... ; 

tasking_error_id : CONSTANT exception-id :■ ... ; 

non_ada_error-id : CONSTANT exception-id ... ; 

status-error-id : CONSTANT exception-id : a ... ; 

mode-error-id : CONSTANT exception-id : a ... ; 

name-error-id : CONSTANT exception-id : a ... ; 

use-error-id : CONSTANT exception-id :* ... ; 


SYSTEAM Ada System - User Manual 


299 













Chapter 15 


Appendix F 


device_error_id : CONSTANT exception-id :* ... ; 

end-error-id : CONSTANT exception-id :» ... ; 

data_error_id : CONSTANT exception-id := ... ; 

layout_error_id : CONSTANT exception-id :■ ... ; 

time-error-id : CONSTANT exception-id : s ... ; 

TYPE argument-array IS ARRAY (1 .. 4) OF integer; 

no-condition-name : CONSTANT :* 1; 

TYPE exception-information IS 
RECORD 

excp-id : exception-id; 

— Identification of the exception. The codings of 

— the predefined exceptions are given above. 

code_addr : address; 

— Code address where the exception occurred. Depending 

— on the kind of the exception it may be be address of 

— the instruction which caused the exception, or it 

— may be the address of the instruction which would 

— have been executed if the exception had not occurred. 

condition-name : integer; 

— If /* no-condition-name, the exception was caused 

— by a condition. In this case, the condition name 

— and other following information made available. 

nr.of-arguments : integer; -* in the range 1 .. 4. 

arguments : argument-array; 

— Only arguments (1 .. nr_of-arguments) are valid. 

-- It contains a copy of the optional information 

— supplied by VMS in the argument array when the 

— condition occurred. If there are more than 4 optional 

— entries in the argument array, only the first 4 

— are copied. 

psl : integer; 

— The processor status longword. 


300 


SYSTEAM Ada System - User Manual 









Appendix F 


Chapter 15 


END RECORD; 

PROCEDURE get-exception-information 

(excp_info : OUT exception-information); 

-- The subprogram get_exception_information must only be called 

— from within an exception handler BEFORE ANY OTHER EXCEPTION 

— IS RAISED. It then returns the information record about the 

— actually handled exception. 

— Otherwise, its result is undefined. 


TYPE exit-code IS NEW integer; 

— The exit codes WARNING, ERROR and SEVERE-ERROR set the bit 28, 

— which inhibits the display of the error message 0 by the DCL 


— interpreter 
warning 
success 
error 

information 
severe.error 


CONSTANT exit-code 
CONSTANT exit-code 
CONSTANT exit-code 
CONSTANT exit-code 
CONSTANT exit-code 


16#iOOOOOOO# 
16#00000001# 
16#10000002# 
16#00000003# 
16#10000004# 


PROCEDURE set-exit_code (val : exit-code); 


-- Specifies the exit code which is returned to the 

— operating system if the Ada program terminates normally. 

— The default exit code is ’success'. If the program is 

— abandoned because of an exception, the exit code is 

— ’error’. 


PRIVATE 

— private declarations 
END system; 

15.4 Restrictions on Representation Clauses 

See Chapter 16 of this manual. 


SYSTEAM Ada System - User Manual 


301 










Chapter 15 


Appendix F 


15.5 Conventions for Implementation-Generated Names 

There are implementation generated components but these have no names, (cf. §16.4 
of this manual). 


15.6 Expressions in Address Clauses 

See §16.5 of this manual. 


15.7 Restrictions on Unchecked Conversions 

The implementation supports unchecked type conversions for all kinds of source and 
target types with the restriction that the target type must not be an unconstrained 
array type. The result value of the unchecked conversion is unpredictable, if 

target-type‘SIZE > source-type‘SIZE 


15.8 Characteristics of the Input-Output Packages 


The implementation-dependent characteristics of the input-output packages as defined 
in the LRM(Chapter 14) are reported in Chapter 17 of this manual. 


15.9 Requirements for a Main Program 

A main program must be a parameterless library procedure. This procedure may be 
a generic instantiation; the generic procedure need not be a library unit. 


302 


SYSTEAM Ada System - User Manual 





Appendix F 


Chapter 15 


15.10 Unchecked Storage Deallocation 

The generic procedure unchecked-deallocation is provided; the effect of calling an 

instance of this procedure is as described in the LRM(§13.10.1). 

The implementation also provides an implementation-defined package collection- 

manager, which has advantages over unchecked deallocation in some applications (cf. 

513.3.1). 

Unchecked deallocation and operations of the collection-manager can be combined 

as follows: 

• collection-manager .reset can be applied to a collection on which unchecked 
deallocation has also been used. The effect is that storage of all objects of the 
collection is reclaimed. 

• After the first unchecked-deallocation (release) on a collection, all following 
calls of release (unchecked deallocation) until the next reset have no effect, 
i.e. storage is not reclaimed. 

• after a reset a collection can be managed by mark and release (resp. unchecked- 
deallocation) with the normal effect even if it was managed by unchecked- 
deallocation (resp. mark and release) before the reset. 


15.11 Machine Code Insertions 

A package machine-code is not provided and machine code insertions axe not sup¬ 
ported. 


15.12 Numeric Error 


The predefined exception numeric-error is never raised implicitly by any predefined 
operation; instead the predefined exception constraint-error is raised. 


SYSTEAM Ada System - User Manual 


303 
















Appendix F: Representation Clauses 


Chapter 16 


16 Appendix F: Representation Clauses 


In this chapter we follow the section numbering of Chapter 13 of the LRM and provide 
notes for the use of the features described in each section. 


16.1 Pragmas 

PACK 

As stipulated in the LRM(§13.1), this pragma may be given for a record or array 
type. It causes the Compiler to select a representation for this type such that gaps 
between the storage areas allocated to consecutive components are minimiz ed. 
For components whose type is an array or record type the PRAGMA PACK has no 
effect on the mapping of the component type. For all other component types the 
Compiler will choose a representation for the component type that needs minimal 
storage space (packing down to the bit level). Thus the components of a packed 
data structure will in general not start at storage unit boundaries. 


BYTE_PACK 

This is an implementation-defined pragma which takes the same argument as the 
predefined language PRAGMA PACK and is allowed at the same positions. For 
components whose type is an array or record type the PRAGMA BYTE_PACK has 
no effect on the mapping of the component type. For all other component types 
the Compiler will try to choose a more compact representation for the component 
type. But in contrast to PRAGMA PACK all components of a packed data structure 
will start at storage unit boundaries and the size of the components will be a 
multiple of system, storage -unit. Thus, the PRAGMA BYTE-PACK does not 
effect packing down to the bit level (for this see PRAGMA PACK). 


SYSTEAM Ada System - User Manual 


305 










Chapter 16 


Appendix F: Representation Clauses 


16.2 Length Clauses 

SIZE 

for all integer, fixed point and enumeration types the value must be <= 32; 
for short-float types the value must be = 32 (this is the amount of storage 
which is associated with these types anyway); 

for float and long-float types the value must be = 64 (this is the amount of 
storage which is associated with these types anyway). 

for long_long_float types the value must be = 128 (this is the amount of storage 
which is associated with these types anyway); 

for access types the value must be = 32 (this is the amount of storage which is 
associated with these types anyway). 

If any of the above restrictions are violated, the Compiler responds with a RE¬ 
STRICTION error message in the Compiler listing. 

STORAGE-SIZE 

Collection size: If no length clause is given, the storage space needed to contain 
objects designated by values of the access type and by values of other types derived 
from it is extended dynamically at runtime as needed. If, on the other hand, a 
length clause is given, the number of storage units stipulated in the length clause 
is reserved, and no dynamic extension at runtime occurs. 

Storage for tasks: The memory space reserved for a task is 10K bytes if no length 
clause is given (cf. Chapter 14). If the task is to be allotted either more or less 
space, a length clause must be given for its task type, and then all tasks of this 
type will be allotted the amount of space stipulated in the length clause (the 
activation of a small task requires about 1.4K bytes). Whether a length clause is 
given or not, the space allotted is not extended dynamically at runtime. 


SMALL 

there is no implementation-dependent restriction. Any specification for SMALL 
that is allowed by the LRM can be given. In particular those values for SMALL are 
also supported which are not a power of two. 


16.3 Enumeration Representation Clauses 

The integer codes specified for the enumeration type have to lie inside the range of the 
largest integer type which is supported; this is the type integer defined in package 
standard. 


306 


SYSTEAM Ada System - User Manual 







Appendix F: Representation Clauses 


Chapter 16 


16.4 Record Representation Clauses 


Record representation clauses are supported. The value of the expression given in an 
alignment clause must be 0, 1, 2 or 4. If this restriction is violated, the Compiler 
responds with a RESTRICTION error message in the Compiler listing. If the value is 
0 the objects of the corresponding record type will not be aligned, if it is 1, 2 or 4 the 
starting address of an object will be a multiple of the specified alignment. 

The number of bits specified by the range of a component clause must not be greater 
than the amount of storage occupied by this component. (Gaps between components 
can be forced by leaving some bits unused but not by specifying a bigger range than 
needed.) Violation of this restriction will produce a RESTRICTION error message. 

There are implementation-dependent components of record types generated in the 
following cases : 

• If the record type includes variant parts and if it has either more than one 
discriminant or else the only discriminant may hold more than 256 different values, 
the generated component holds the size of the record object. 

• If the record type includes array or record components whose sizes depend on dis¬ 
criminants, the generated components hold the offsets of these record components 
(relative to the corresponding generated component) in the record object. 

But there are no implementation-generated names (cf. LRM(§13.4(8))) denoting these 
components. So the mapping of these components cannot be influenced by a represen¬ 
tation clause. 


16.5 Address Clauses 

Address clauses are supported for objects declared by an object declaration and for 
single task entries. If an address clause is given for a subprogram, package or a task 
unit, the Compiler responds with a RESTRICTION error message in the Compiler 
listing. 

If an address clause is given for an object, the storage occupied by the object starts at 
the given address. Address clauses for single entries are described in §16.5.1. 


SYSTEAM Ada System - User Manual 


307 







Chapter 16 


Appendix F: Representation Clauses 


16.5.1 Interrupts 


On VAX/VMS, all hardware interrupts are handled by VMS. It is not possible to handle 
the hardware interrupts directly. However, some system services allow a process to be 
interrupted when a particular event occurs. Since the interrupt occurs asynchronously, 
the interrupt mechanism is called an asynchronous system trap (AST) (cf. VAX/VMS, 
System Services). The trap transfers control to a user-specified service routine that 
handles the event. 

VMS delivers an AST when requested to do so, for instance by calls of system services 
like IDCLAST, $ENQ, $GETDVI, $GETJPI, SGETSYI, SQIO, $SETIMR or by calls 
of RMS services. As parameters to a call of a system service the address of the AST 
service routine (usually the parameter astadr) and an AST parameter value (usually 
the parameter astprm) can be specified. The specified AST parameter value is passed 
to the AST service routine as argument when it is called. In this way one AST service 
routine can be used to handle several ASTs. 

For example, the $SETIMR service can be used to request an AST after 10 seconds or 
at 12:00:00. After calling the SSETIMR service the program continues in its normal 
control flow. If the time event occurs, VMS causes the normal control flow to be 
interrupted and executes the AST service routine. Upon completion of the AST service 
routine the execution of the program is continued where it was interrupted. 

An address clause for an entry associates the entry with an AST. When an AST occurs, 
the AST service routine initiates the entry call; the calling task and the called task 
continue their execution in parallel. 

By this mechanism, an interrupt acts as an entry call to that task; such an entry is 
called an interrupt entry. An interrupt causes the ACCEPT statement corresponding to 
the entry to be executed. 

The AST is mapped to an ordinary entry call. The entry may also be called by an 
Ada entry call statement. However, it is assumed that when an interrupt occurs there 
is no entry call waiting in the entry queue. Otherwise, the program is erroneous and 
behaves in the following way: 

• If an entry call stemming from an interrupt is already queued, this previous entry 
cadi is lost. 

• The entry call stemming from the interrupt is inserted into the front of the entry 
queue, so that it is handled before any entry call stemming from an Ada entry 
call statement. 


308 


SYSTEAM Ada System - User Manual 





Appendix F: Representation Clauses 


Chapter 16 


16.5.1.1 Association between Entry and Interrupt 


The association between an entry and an interrupt is achieved via an interrupt number 
(type system.interrupt_nximber) the range of interrupt numbers being 0 .. 31 (this 
means that 32 single entries can act as interrupt entries). A single entry of a task 
which has one IN parameter of type integer or system.address can be associated 
with an interrupt number by an address clause (the Compiler does not check these 
conventions). Since an address value must be given in the address clause, the interrupt 
number has to be converted into type system. address. The array system, interrupt _ 
vector is provided for this purpose; it is indexed by an interrupt number to get the 
corresponding address. 

The following example associates the entries timer-1, timer.2. io_f ailure and io_ 
success with the interrupt numbers 10, 11, 12 and 13, respectively. 


TASK handler IS 

ENTRY timer-1 (x : IN 
ENTRY timer_2 (x : IN 
ENTRY io-failure (x : 
ENTRY io-success (x : 

FOR timer-1 USE AT 
FOR timer_2 USE AT 
FOR io_failure USE AT 
FOR io-success USE AT 
END; 


integer); 
integer); 

IN system.address); 

IN system.address); 

system.interrupt-vector (10) 
system.interrupt-vector (11) 
system.interrupt-vector (12) 
system.interrupt-vector (13) 


The task body contains ordinary accept statements for the entries. 


16.5.1.2 Association between Interrupt and AST Service Routine 

When a system service is called and an entry is to be called via interrupt, the address 
value system.ast_service (nr) must be specified as AST service routine, where nr 
indicates the interrupt number. 

The effect of the execution of the AST service routine given by system.ast-service 
(nr) depends on Whether there is a task currently waiting at am ACCEPT or selective 
wait statement for am entry which is associated with the interrupt number nr. 


SYSTEAM Ada System - User Manual 


309 






Chapter 16 


Appendix F: Representation Clauses 


If there is a task waiting, a rendezvous with that task is performed immediately. 
If several tasks are waiting for the same interrupt, the program is erroneous (cf. 
LRM(§13.5(8))) and a rendezvous is performed with any of these tasks. 

Otherwise, the information that the interrupt nr occurred and the corresponding AST 
parameter value are stored by the Ada runtime system. If later on a task performs an 
ACCEPT or selective wait statement for the entry associated with the interrupt nr the 
rendezvous is performed. 

Therefore an interrupt is never treated as a conditional entry caill. If the interrupt nr 
occurs again before the previous one has been handled, the previous one is lost. 

A detailed example for an interrupt entry is given in §15.1.4, in the procedure vms. 
routine. 


16.5.1.3 Calling an Asynchronous VMS System Service 

The following example shows how to call an entry from an AST delivered by a VMS 
system service, here the SSETIMR service. 


• • • 

PROCEDURE vms.setimr ( ... ); 

PRAGMA external-name (vms-setimr. "SYS$SETIMR"); 

PRAGMA interface (vas, vms_aetimr); 

• • • 

vms_setimr — (1) 

(daytime ■> ... , — e.g. 12:00:00.00 

astadr ■> system.ast.service (10)); 

vms_setimr — (2) 

(daytime «> _ , — e.g. in 10 sec from now on 

astadr *> system.ast.service (11), 
reqidt -> 1234567); 


The effect of the call (1) of vms_setimr is that at the specified time an AST is delivered 
which is mapped to a call of the entry timer. 1 of the task specified above. No AST- 
parameter specified; VMS inserts the default 0, which is passed as argument x to the 
accept body of timer-1. 

The effect of the call (2) of vas_setiar is similar. Here the AST-parameter is specified. 
It is passed as argument x to the accept body of timer.2. 


310 


SYSTEAM Ada System - User Manual 




Appendix F: Representation Clauses 


Chapter 16 


16.5.1.4 Calling an Asynchronous RMS Service 

The RMS routines are a little bit different from the VMS system services. When 
calling an RMS service the addresses of two completion routines (one for success, 
one for failure) can be given as parameters. If this is done, the service is performed 
asynchronously and upon completion one of the two completion routines is called as 
AST routine. The address of the FAB (File Access Block) or RAB (Record Access 
Block) which was passed as operand to the RMS service is passed as AST parameter 
to the completion routine. 

Example: 


PROCEDURE rms-open ( ... ); 

PRAGMA external-name (rms_open, "SYS$0PEN"); 

PRAGMA interface (vms, rms-open); 

• • ■ 

my_fab : fab-type; 

• • • 

rms-open (fab ■> my_fab*address, 

err ■> system.aat.service (12), 
sue »> system.ast_service (13)); 

• • • 

Upon successful completion of the open operation an AST is delivered which results in 
calling the entry io-success with parameter x ® my_f ab* ADDRESS. If an error occurs, 
io-failure is called instead. 


16.6 Change of Representation 

The implementation places no additional restrictions on changes of representation. 


SYSTEAM Ada System - User Manual 


311 








Chapter 16 


Appendix F: Representation Clauses 











Appendix F: Input-Output 


Chapter 17 


17 Appendix F: Input-Output 


In this chapter we follow the section numbering of Chapter 14 of the LRM and provide 
notes for the use of the features described in each section. 


17.1 External Files and File Objects 

The only form of file sharing which is allowed is shared reading. If two or more files 
are associated with the same external file at one time (regardless of whether these files 
are declared in the same program or task), all of these (internal) files must be opened 
with the mode in_f ile. An attempt to open one of these files with a mode other than 
in_f ile will raise the exception use-error. 

Files associated with terminal devices (which is only legal for text files) are excepted 
from this restriction. Such files may be opened with an arbitrary mode at the same 
time and associated with the same terminal device. 

The following restrictions apply to the generic actual parameter for element-type: 

• input/output of access types is not defined. 

• input/output of unconstrained array types is only possible with a variable record 
format. 

• for RMS sequential [relative or indexed] files the size of an object to be input or 
output must not be greater than 32767 [16383] storage units. 

• input/output is not possible for an object whose (sub)type has a size which is not 
a multiple of system, storage-unit. Such objects can exist for types for which 
a representation clause or the PRAGMA pack is given. Use-error will be raised 
by any attempt to read or write such an object or to open or create a file for such 
a (sub) type. 


17.2 Sequential and Direct Files 

Sequential and direct files are represented by RMS sequential, relative or indexed files 
with fixed-length or variable-length records. Each element of the file is stored in one 
record. 


SYSTEAM Ada System - User Manual 


313 






Chapter 17 


Appendix F: Input-Output 


17.2.1 File Management 

Since there is a lot to say about this section, we shall introduce subsection numbers 
which do not exist in the LRM. 

17.2.1.1 The NAME and FORM Parameters 

The name parameter string must be a VMS file specification string and must not contain 
wild cards, even if that would specify a unique file. The function name will return a 
file specification string (including version number) which is the file name of the file 
opened or created. 

The syntax of the form parameter string is defined by: 

form-parameter [ form-specification { , form-specification } ] 
form-specification keyword [ »> value ] 

keyword identifier 

value identifier I string-literal I numeric-literal 

For identifier, numeric-literal, string-literal see the LRM (Appendix E). Only an integer 
literal is allowed as numeric-literal (cf. LRM(§2.4)). 

In the following, the form specifications which are allowed for all files are described. 


ALLOCATION ■> numeric-literal 


This value specifies the number of blocks which are allocated initially; it is only used 
in a create operation and ignored in an open operation. The value of ALLOCATION 
in the form string returned by the function form specifies the initial allocation size for 
existing files too. 


EXTENSION «> numeric-literal 


314 


SYSTEAM Ada System - User Manual 




Appendix F: Input-Output 


Chapter 17 


This value specifies the number of blocks by which a file is extended if necessary; the 
value 0 means that the RMS default value is taken. For existing files, this value only 
applies to extensions of the file between open and close operations in the Ada program. 

For details see the VAX/VMS, Record Management Services. 


MAX-RECORD-SIZE *> numeric-literal 


This value specifies the maximum record size in bytes. The value 0 indicates that 
there is no limit; for direct files, this valve is only allowed for indexed files, whereas 
for sequential files there is no such restriction. This form specification is only allowed 
for files with variable record format. If the value is specified for an existing file it must 
agree with the value of the external file. 


For files with fixed-length records, the maximum record size equals 
element-type'SIZE / system, storage-unit. If a fixed record format is used, all 
objects written to a file which are shorter than the maximum record size are filled up 
with zeros (ASCHNUL). 


RECORD-FORMAT -> VARIABLE I FIXED 


This form specification is used to specify the record format. If the format is specified 
for an existing file it must agree with the format of the external file. 


17.2.1.2 Sequential Files 

A sequential file is represented by an RMS sequential file with either fixed-length or 
variable-length records (this may be specified by the form parameter). 

If a fixed record format is used, all objects written to a file which are shorter than the 
maximum record size are filled up with zeros (ASCII.NUL). 


END-OF-FILE 


SYSTEAM Ada System - User Manual 


315 









Chapter 17 


Appendix F: Input-Output 


If the keyword END.OF.FILE is specified for an existing file in an open for an output 
file, then the file is opened at the end of the file; i.e. the existing file is extended and 
not rewritten. This keyword is only allowed for an output file; it only has an effect in 
an open operation and is ignored in a create. 

The default form string for a sequential file is : 


"ALLOCATION »> 0, EXTENSION => 0, " k 

"RECORD.FORMAT *> VARIABLE. MAX.RECORD.SIZE => 0 " 


The default form may be used for all types (except for those excluded in §17.1). 


17.2.1.3 Direct Files 


The implementation dependent type count defined in the package specification of 
direct-io has an upper bound of: 

COUNT’LAST - 2.147.483.647 (» INTEGER’LAST) 

Direct files are represented by RMS sequential files with fixed-length records or by 
relative or indexed files with either fixed-length or variable-length records. For indexed 
files, the record index is stored as unsigned four bytes binary value in the first four bytes 
of each record. If not explicitly specified, the maximum record size equals element- 
type’SIZE / system.storage.unit. 


BUCKET-SIZE ■> numeric-literal 


This value specifies the number of blocks (one block is 512 bytes) for one bucket; the 
value 0 means that the value is evaluated by RMS to the minimal number of blocks 
which is necessary to contain one record. The value must be in the range from 0 up 
to 32. This form specification is only allowed for relative or indexed files. If the value 
is specified for an existing file it must agree with the value of the external file. 


ORGANIZATION » INDEXED I RELATIVE I SEQUENTIAL 


316 


SYSTEAM Ada System - User Manual 






Appendix F: Input-Output Chapter 17 


This form specification is used to specify the file organization. If the organization is 
specified for an existing file it must agree with the organization of the external file. 


The default form string for a direct file is : 


"ALLOCATION -> 0, EXTENSION »> 0, " It 

"ORGANIZATION -> SEQUENTIAL. RECORD-FORMAT -> FIXED" 

Indexed files with variable-length records and a maximum record size of 0 may be used 
for all types (except for those excluded in §17.1). Relative files with variable-length 
records may also be used for all types, but in this case a maximum record size must be 
specified explicitly. Sequential, relative or indexed files with fixed-length records may 
not be used for unconstrained array types. 


17.3 Text Input-Output 


Text files are represented as sequential files with variable record format. One line is 
represented as a sequence of one or more records; all records except for the last one have 
a length of exactly MAX_RECORD_SIZE and a continuation marker (ASCII.LF) at 
the last position. A line of length MAX-RECORD-SIZE is represented by one record 
of this length. A line terminator is not represented explicitly in the external file; 
the end of a record which is shorter than MAX-RECORD-SIZE or which has length 
exactly MAX-RECORD-SIZE and does not have a continuation marker as its last 
character is taken as a line terminator. 

The value MAX-RECORD-SIZE may be specified by the form string for an output file 
and it is taken from the external file for an input file; for an input file, the value 0 stands 
for the default of 512. For all files which are created, the value MAX-RECORD-SIZE 
is used for the file attribute MRS (maximum record size). 

A page terminator is represented as a record consisting of a single ASCII.FF. A record 
of length zero is assumed to precede a page terminator if the record before the page 
terminator is another page terminator or a record of length MAX_RECORD_SIZE 
with a continuation marker at the last position; this implies that a page terminator is 
preceded by a line terminator in all cases. 

A file ter min ator is not represented explicitly in the external file; the end of the file is 
taken as a file terminator. A page terminator is assumed to precede the end of the file 
if there is not explicitly one as the last record of the file. For input from a terminal, a 
file terminator is represented as ASCII.SUB (= CTRL/Z). 


SYSTEAM Ada System - User Manual 


317 





Chapter 17 


Appendix F: Input-Output 


17.3.1 File Management 


In the following, the form specifications which are only allowed for text files or have a 
special meaning for text files are described. 


CHARACTER-10 


The predefined package text_io was designed for sequential text files; moreover, this 
implementation always uses sequential files with a record structure, even for terminal 
devices. It therefore offers no language-defined facilities for modifying data previously 
written to the terminal (e.g. changing characters in a text which is already on the ter¬ 
minal screen) or for outputting characters to the terminal without following them by a 
line terminator. It also has no language-defined provision for input of single characters 
from the terminal (as opposed to lines, which must end with a line terminator, so that 
in order to input one character the user must type in that character and then a line 
terminator) or for suppressing the echo on the terminal of characters typed in at the 
keyboard. 

For these reasons, in addition to the input/output facilities with record structured 
external files, another form of input/output is provided for text files: It is possible 
to transfer single characters from/to a terminal device. This form of input/output is 
specified by the keyword CHARACTER_IO in the form string. If CHARACTER-IO 
is specified, no other form specification is allowed and the file name must denote a 
terminal device. 

For an infile, the external file (associated with a terminal) is considered to contain 
a single line. An ASCII.SUB (= CTRL/Z) character represents an line terminator 
followed by a page terminator followed by a file terminator. Arbitrary characters 
(including all control characters except for ASCII.SUB) may be read; a character read 
is not echoed to the terminal. 

For an outfile, arbitrary characters (including all control characters and escape se¬ 
quences) may be written on the external file (terminal). A line terminator is rep¬ 
resented as ASCII.CR followed by ASCII.LF, a page terminator is represented as 
ASCII.FF and a file terminator is not represented on the external file. 


318 


SYSTEAM Ada System - User Manual 




Appendix F: Input-Output 


Chapter 17 


Only for input files : 

PROMPTING *> string-literal 

This string is output on the terminal before an input record is read if the input file is 
associated with a terminal; otherwise this form specification is ignored. 


Only for output files : 


MAX-RECORD-SIZE *> numeric-literal 


This value specifies the maximum length of a record in the external file. Each record 
which is not the last record of a line has exactly this maximum record size, with a 
continuation marker (ASCU.LF) at the last position. The value must be in the range 
2 .. 512. If a file is created, the specified value (or the default of 512) is used for the 
file attribute MRS (maximum record size) of the external file. If the value is specified 
for an existing file it must be identical to the value of the external file. 


END-OF-FILE 


If the keyword END_OF_FILE is specified for an existing file in an open for an output 
file, then the file is opened at the end of the file; i.e. the existing file is extended and 
not rewritten. This keyword only has an effect in an open operation and is ignored in 
a create. 


The default form string for an input text file is : 


"ALLOCATION «> 0. EXTENSION »> 0, PROMPTING -> """" 


The default form string for an output text file is : 


SYSTEAM Ada System - User Manual 


319 






Chapter 17 


Appendix F: Input-Output 


"ALLOCATION => 0, EXTENSION => 0, MAX_RECORD_SIZE => 512" 


17.3.2 Default Input and Output Files 

The standard input (resp. output) file is associated with the system default logical 
names SYS$INPUT (resp. SYSSOUTPUT) of VMS. If a program reads from the 
standard input file, the logical name SYS $ INPUT must denote an existing file. If a 
program writes to the standard output file, a file with the logical name SYSSOUTPUT 
is created if no such file exists; otherwise the existing file is extended. 

The qualifiers /INPUT and /OUTPUT may be used for the VMS RUN command to 
associate VMS files with the standard files of text.io. 

The name and form strings for the standard files are : 


standard-input : NAME «> "SYS3INPUT:" 

FORM -> "PROMPTING •>■■*■« " 

standard-output : NAME -> "SYSSOUTPUT:" 

FORM -> "MAX_RECORD_SIZE *> 512" 


17.3.3 Implementation-Defined Types 

The implementation-dependent types count and field defined in the package specif! 
cation of text.io have the following upper bounds : 


COUNT'LAST - 2_147-483.647 (- INTEGER'LAST) 
FIELD'LAST - 512 


320 


SYSTEAM Ada System - User Manual 






Appendix F: Input-Output 


Chapter 17 


17.4 Exceptions in Input-Output 


For each of name_error, use_error, device-error and data_error we list the condi¬ 
tions under which that exception can be raised. The conditions under which the other 
exceptions declared in the package io_ except ions can be raised are as described in 
the LRM(§14.4). 

NAME-ERROR 

• in an open operation, if the specified file does not exist; 

• in a create operation, if the name string contains an explicit version number and 
the specified file already exists; 

• if the name parameter in a call of the create or open procedure is not a legal 
VMS file specification string; for example, if it contains illegal characters, is too 
long or is syntactically incorrect; and also if it contains wild cards, even if that 
would specify a unique file. 


USE-ERROR 

• if an attempt is made to increase the total number of open files (including the two 
standard files) to more than 18; 

• whenever an error occurred during an operation of the underlying RMS system. 
This may happen if an internal error was detected, an operation is not possible for 
reasons depending on the file or device characteristics, a size restriction is violated, 
a capacity limit is exceeded or for similar reasons; 

• if the function name is applied to a temporary file; 

• if the characteristics of the external file are not appropriate for the file type; for 
example, if the record size of a file with fixed-length records does not correspond to 
the size of the element type of a direct-io or sequential_io file. In general it is 
only guaranteed that a file which is created by an Ada program may be reopened 
by another program if the file types and the form strings are the same; 

• if two or more (internal) files are associated with the same external file at one 
time (regardless of whether these files are declared in the same program or task), 
and an attempt is made to open one of these files with mode other than in-file. 
However, files associated with terminal devices (which is only legal for text files) 
are excepted from this restriction. Such files may be opened with an arbitrary 
mode at the same time and associated with the same terminal device; 

• if a given form parameter string does not have the correct syntax or if a condition 
on an individual form specification described in §17.2-3 is not fulfilled; 

• if an attempt is made to open or create a sequential or direct file for an element 
type whose size is not a multiple of system, storage -unit; or if an attempt 
is made to read or write an object whose (sub)type has a size which is not a 
multiple of system.storage-unit (such situations can arise for types for which 
a representation clause or the PRAGMA pack is given); 


SYSTEAM Ada System - User Manual 


321 




Chapter 17 


Appendix F: Input-Output 


DEVICE_ERROR 

is never raised. Instead of this exception the exception use_error is raised when¬ 
ever an error occurred during an operation of the underlying RMS system. 

DATAJERROR 

• the conditions under which data_error is raised by text.io are laid down in the 
LRM; the following notes apply to the packages sequential_io and direct_io: 

• by the procedure read if the size of a variable-length record in the external file to 
be read exceeds the storage size of the given variable or else the size of a fixed- 
length record in the external file to be read exceeds the storage size of the given 
variable which has exactly the size element-type*SIZE. 

• In general, the exception data.error is not raised by the procedure read if the 
element read is not a legal value of the element type. 

• by the procedure read if an element with the specified position in a direct file 
does not exist; this is only possible if the file is associated with a relative or an 
indexed file. 


17.5 Low Level Input-Output 

We give here the specification of the package low-level-io: 


PACKAGE low_level_io IS 

TYPE device-type IS (null-device); 

TYPE data_type IS 
RECORD 
HULL; 

END RECORD; 

PROCEDURE send_control (device : device-type; 

data : IN OUT data_type); 

PROCEDURE receive.control (device : device-type; 

data : IN OUT data-type); 

END low-level-io; 


322 


SYSTEAM Ada System - User Manual 





Appendix F: Input-Output 


Chapter 17 


Note that the enumeration type device-type has only one enumeration value, null- 
device; thus the procedures send-control and receive.control can be called, but 
send_control will have no effect on any physical device and the value of the actual 
parameter data after a call of receive.control will have no physical significance. 


SYSTEAM Ada System - User Manual 


323 




