
AVF Control Nunber: AVF-VSR-569.0893 
^ Date VSR Coopleted: 16 Septenber 1993 

If) 93-07-12-INT 



Q 

< 


Ada CGMPXLER 
VALIDATIGN SUMMARY REPORT:. 

Certificate Number: 930901N1.11322 
Intermetrics Inc. 

RISCAE Honeywell RH32-targeted Ada Con^iler, 1.0 
DEC VAXstation 4000 under VMS, 5.5 -> 

RISCAE Honeywell RH32 Simulator running on the host tnder VMS, 5.5 


(Final) 


Prepared By: 

Ada Validation Facility 
645 C-CSG/SCSL 

Wright-Patterson AFB OH 45433-6503 



DTIC 

ELECTE 
dec 141993 

E 





93 12 13 056 


93-30206 

illllllll 





Best 

Available 

Copy 




REPORT DOCUMENTATION PAGE 


OH4NO. 


^uMc w pa mn gbm ^ tomiacDlwllBWfltln tBnw I iin bw I ii i iMa d lBiw w Qil ‘—| -r-- V -r-’r-'-p ‘- r-T‘—-*~^~ 0'*iiTi iniinw i ■a rn iiiiii 

id w l nt t W ntll>»Jite m td rt .iiidii^fi>Hth»col«cllotiollnl—i rt on. tinrt tw m n urn i np i nl i ng ihli tuinltn Uniai m «n( Mtiw mmH n' Hit ftrminn irt I n iMiiiaiiMi rnti i ift iii 

■u w il tin til lot frtMtlwg O* Wtati ln gloii lli rtn iiirti w Iwvix. Dwaai — lot Wnrn iMi n w 0 | H « H bhi and n ipQrt i . .t». ,r. frtmmn .Y* 

tiaa»4aOtandt»H»0»io»o<l n l nmi rto n «ndmg u lMDHi«li>i.O<»G»ot M itiilgiiiii nt <n< a M^i t .W—h i»m o»i . DC MMS. 





ISCAE Honeywell RH32-targeted Ada Compiler, 1.0, Host: DEC 
VAXstation 4000, Target: RISCAI Honeywell RH32 Simulator rum ing on the 
host, 930901W1.11322 


Authors: 


Wright-Patterson AFB 






Ada Validating Facility, Language Control Facility ASD/SCEL 

Bldg. 676, Room 135 

Wright Patterson AFB, Dayton OH 45433 





Ada Joint Program Office 
The Pentagon. Rm 3E118 
Washington, 0020301*3080 


10 . 
AGENCY 





lON^AVAILABIL 

Approved for public release; distribution unlimited 


(Maximum 

RISCAE Honeywell RH32-targeted Ada Compiler, 1.0, Host: DEC VAXstation 4000 , Target: 
TISCAE Honeywell RH32 Simulator running on the host, ACVC 1.11 



Ada programming language, Ada Compiler Val. Summary Report, Ada Comp 

• Testing, Ada Val. Office. Ada Val. Faclll 




CLASSFICATION 

UNCLASSIFED 



19. SECU 
CLASSIFICATION 

UNCLASSIFED 



UNCLASSIFED 


.( 

Pi — c ribtd by ANSI SM. 


UNCLASSIFED 


















Certificate InforMtion 


Itie folloidng Ma iapleaentation was tested and detereined to pass ACVC 
1.11. Testing was coa|>leted on 1 Septeober 1993. 

Oosfpiler Nane and Version: RISCME Honeywell RH32-tar9eted Ada Coopiler, 1.0 

Host OcMputer Systeai: OBC VHXstation 4000 

isidter VMS, 5.5 

Target Cosiuter System: RISCAE Honeywell RH32 Simulator running csi the host 

under VKS, 5.5 

Customer Agreement Number: 93-07-12-INT 


See section 3.1 for any additional information about the testing 
environment. • 

As a result of this validation effort. Validation Certificate 
930901W1.11322 is awarded to Intermetrics Inc. This certificate expires 
two years after I1I1,>STD-1615B is approved by ANSI. 







DBCLMtKTlGN OF OCXIFORWICE 


The folloiiring declaration of confonnnce %iias supplied by the custcner. 


Declaration of Conforaance 
Custoner: Intemetrics Inc. 


Ada Validation Facility: 645 C-CSG/SCSL 

Hri^t-Patterson AFB OH 45433-6503 

ACVC Version: 1.11 
Ada InplMentation: 

Ada Conpiler Naae and Version: RISCAE Boneyviell BH32-targeted Ada Conpiler, 1. 

Host Cooputer System: DGC VMCstati<» 4000 

under VMS, 5.5 

Target Cooputer System: RISCAE Honeywell BH32 Siimilator nmning on the host 

under VMS, 5.5 


Declaration: 

I, the undersigned, declare that I have no 
knowledge of deliberate deviations from the Ada Language 
Standard ANSI/11IL-STD-1815A ISO 6652-1987 in the implementation 
listed above. 




Date 


Customer Si^iature 


TABLE OF CXMIENIS 


C W TER 1 ZNIROOUCTZCN 

1.1 USE OF THIS VALIDATIGN SUMIARY REPORT ... c ... 1-1 

1.2 REFERENCES .1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDEXaES 

2.1 WITHDBAMN TESTS .2-1 

2.2 INAPPLICABLE TESTS .2-1 

2.3 TEST MODIFICATIONS .2-4 

C HAP TER 3 PROCESSING INFORMATION 

3.1 TESTING EZOVIROraiENT .3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION .3-2 

APPEIE)IX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 


APPENDIX C 


APPENDIX F OF THE Ada STANDARD 












C HAP TER 1 


INIBCOUCTXGN 


Th« Ada iaplementation described above %«as tested according to the Ada 
validation Procedures [Pro90] against the Ada Standard [Ada83] using the 
current Ada Coo^iler validation Capability (ACVC). This validation Sunnary 
Report (VSR) gives an account of the testing of this Ada inplenentation. 

For any tecl^cal terns \ised in this report, the reader is referred to 
[Pro901. A detailed description of the ACVC nay be found in the current 
ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SOMHARY REPORT 

consistent with the national laws of the originating country, the Ada 
Certification Body nay nake full and free public disclosure of this report. 
In the united States, this is provided in accordance with the "Freedoei of 
Infomation Act" (5 U.S.C. #552). The results of this validation apply 
only to the coofuters, operating systens, and ccnpiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statonents set forth in this report are 
accurate and conplete, or that the subject inplenentation has no 
nonconformities to the Ada Standard ot^r than those presented, copies of 
this report are available to the public from the AVF which performed this 
validaticxi or from: 

Naticxial Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questicais regarding this report or the validation test results should be 
directed to the AVF vdiich performed this validation or to: 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense An^yses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1-1 








mmsucTiGN 


1.2 REFERENCES 

[Ada83] Reference Manual for the Ada Prograaeinq Lanquage, 

#^iuary 190’and lid S5R4987. 

[Pro90] Ada Coagiler Validation Procedures , Version 2.1, Ada Joint 
Program office, August IS^IT 

[UG89] Ada Coepiler Validation Capability Oser*s Guide , 21 Jme 1989. 


1.3 ACVC TEST CLASSES 

Coafillance of Ada ieplementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: A, 
B, C, D, E, and L. The first letter of a test name identifies the class to 
\ddch it belongs. Class A, C, D, and E tests are executable. Class B and 
class L tests are expected to produce errors at cosipile time and link time, 
respectively. 

The executable tests are written in a self-<diecking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result %«hen tlwy 
are executed. Three Ada library units, the packages REPORT and SPPBT13, 
and the procedure CHECK FILE are tmed for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK FILE is used to check the contents of 
text files written by some of the ^lass C tests for Chiqpter 14 of the Ada 
Standard. The <^rati<m of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not curating correctly, validation 
testing is dlsccxitinued. 

Class B tests check that a compiler detects illegal language iisage. Class 
B tests are not executable. Each test in this class is cxmpiled and the 
resulting compilaticm listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code vhich must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada iaplementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and executicxi is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
iiqplementation-specific vidues — for example, the largest integer. A list 
of the valijes us^ for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove \inforeseen conflicts between the tests and 
implmnmntation-dependent characteristics. The modifications required for 
this implmnentation are described in section 2.3. 


1-2 







zNHiQaicnGN 


For ead) Ada iaplowntation, a custoodsed test suite is produced by the 
AVP. This custcadsation consists of aaking the aodifications described in 
the preceding paragri^, resoving withdrawn tests (see section 2.1), and 
possibly resioving some inapplicable tests (see section 2.2 and [UG89]). 

In order to pass an ACVC an Ada iaplementation oust process each test of 
the custoodsed test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 

Ada Ccsnpiler The software and any needed hardware that have to be added 
to a given host and target coaster system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada compiler The means for testing coopliance of Ada implementations, 
validation consisting of the test suite, the svpport programs, the ACVC 
Capability user's guide and the template for the validaticxi summary 

(ACVC) report. 

Ada An Ada compiler with its host computer system and its 

Implementation target computer system. 

Ada Joint The part of the certification body which provides policy and 
Program guidance for the Ada certification system. 

Office (AJFO) 

Ada The part of the certification body vdiich carries out the 

Validaticxi procedures required to establish the compliance of an Ada 
Fr ility (AVF) implementaticm. 

Ada The part of the certification body that provides technical 

Validation guidance for operations of the Ada certification syston. 

Organization 
(AVO) 

Compliance of The ability of the inplementation to pass an ACVC version, 
an Ada 

Implementation 

Computer A functional unit, consisting of one or more computers and 

System associated software, that uses common storage for all or 

part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
xiser-written or user-designated programs; performs 
user-designated data manipulation, induing arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone vnit or may ccxisist of 
several inter-connected xmits. 


1-3 




ZNnaxJcnoN 


Oonfonity PulflllMnt by a product, pcocass, or sarvica of all 
raquiroamts spacified. 

Custoner An individual or corporate entity who enters into an 

agraeoent with an AVF %«hich specifies the terns and 
conditions for AVF services (of any kind) to be perfomed. 

Declaration of A formal statement from a custoemr assuring that conformity 
Conformance is realized or attainable on the Ada implementation for 
whidi validation status is realized. 

Host Computer A cooputer system where Ada source programs are transformed 
Systm into executable form. 

Inapplicable A test that contains one or more test d!>jectives found to be 
test irrelevant for the given Ada inplementatim. 

ISO International Organization for Standardization. 

LRH The Ada standard, or Language Reference Manual, published as 

ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRN take the form "<secti(»i>.<s\jbsection>:<paragraph>." 

Operating Software that controls the execution of programs and that 
System provides services such as resource allocation, schedulir^, 

iiput/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
complete hardware implementations are possible. 

Target A conputer system where the executable form of Ada programs 

Computer are executed. 

System 

Validated Ada The conpiler of a validated Ada implementation. 

Compiler 

Validated Ada An Ada inplementation that has been validated successfully 
Implenentati<m either by AVF testing or by registration [Pro90]. 

Validation The process of checking the ccxiformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

Withdrawn A test found to be incorrect and not used in conformity 
test testing. A test may be incorrect because it has an invalid 

test objective, fails to meet its test objective, or 
cmtains erroneous or illegal use of the Ada programming 
language. 


1-4 




CHAPTER 2 

IMPLEMENTATION I»7EN[»«:iES 


2.1 HITHDRM4N TESTS 

Ttw following tests have been withdiawn by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 2 August 1991. 


E28005C 

B28006C 

C32203A 

C34006D 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45348A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

C83026A 

B83026B 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

Ba226A 

Ca226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21B 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022O 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CIA201E 

CE21071 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 



2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant 
for a given Aite inplementation. Reasons for a test's inapplicability say 
be si 9 ported by documents Issued by the ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be ini^licable for 
the reasons invested; references to Ada Commentaries are included as 
appropriate. 


2-1 



IHPLENDlXKnGN DBPEMDQICIES 


The following 201 tests have floating-point type declarations 
requiring nore digits than SYSTEI1.MI0C_DIGZTS: 


C24113L..y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


C35713B, C45423B, B86001T, and C86006H check for the predefined type 
SHCRT_FLQA.T; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type %id.th a 
name other than FLOAT, LQNS_FLCAT, or SH0RT_FLCAT; for this 
implementation, there is no such type. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations for 
types that require a SYSTEH.MAX_MANTZSSA of 47 or greater; for this 
implementation, HAX_MANnsSA is less than 47. 

C45624A. .B (2 tests) check that the proper exception is raised if 
MACHINEjOVEEtFLONS is FALSE for floating point types and the results of 
various floating-point operations lie outside the range of the base 
type; for this implementation, MACHINEjOVERFLCMS is TRUE. 

D5SA03E..H (4 tests) use 31 levels of loop nesting; this level of loop 
nesting exceeds the capacity of the conpiler. 

D64005G iises 17 levels of recursive procedure calls nesting; this 
level of nesting for procedure cedis exceeds the capacity of the 
coopiler. 

B86001Y uses the name of a predefined fixed-point type other than type 
DURATION; for this inplementation, there is no such type. 

CA2009C and CA2009F check \d\ether a generic unit can be instantiated 
before its body (and any of its subunits) is compiled; this 
ioplementation creates a dependence on generic mits as allowed by 
AI-00408 and AI-00506 such that the coapilation of the generic imit 
bodies makes the instantiating units obsolete. (See section 2.3.) 

CD1009C checks vAiether a length clause can specify a nm-defaidt size 
for a floating-point type; this isplementation does not support such 
sizes. 


a>2A84A, CD2A84E, CD2A84Z..J (2 tests), and a)2A840 use length claiises 
to specify non-default sizes for access types; this Implanentation 
does not support such sizes. 


2-2 





IMPLEHEMTATIGN IXPBNDEMCIES 


AE2101C and EE2201D..E (2 tests) use instantiations of package 
SEQUENTIAL_IO with unconstrained array types and record types with 
discriminants without defaults; these instantiations are rejected by 
this compiler. 

AE2101H, EE2401O, and EE2401G use instantiations of ^ckage DIRECT_iO 
with unccmstrained array types and record types with discriminants 
without defaults; these instantiations are rejected by this compiler. 

Ihe following 260 tests check operations on sequential, text, and 
direct access files; this isplementation does not support external 
files: 


CE2102A. .C 

(3) 

CE2102G..H 

(2) 

CE2102K 


CE2102N..Y 

(12) 

CE2103C..D 

(2) 

CE2104A..D 

(4) 

CE2105A. .B 

(2) 

CE2106A..B 

(2) 

CE2107A. .H 

(8) 

CE2107L 


CE2108A. .H 

(8) 

CE2109A. .C 

(3) 

CE2110A..O 

(4) 

CE2111A..1 

(9) 

CE211SA..B 

(2) 

CE212QA..B 

(2) 

CE2201A. .C 

(3) 

CE2201F..N 

(9) 

CE2203A 


CE2204A..D 

(4) 

CE2205A 


CE2206A 


CE2208B 


CE240IA..C 

(3) 

CE2401E..F 

(2) 

CE2401H..L 

(5) 

CE2403A 


CE2404A..B 

(2) 

CE2405B 


CE2406A 


CE2407A..B 

(2) 

CE2408A. .B 

(2) 

CE2409A. .B 

(2) 

CE241QA..B 

(2) 

CE2411A 


CE3102A. .C 

(3) 

CE3102F..H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A..C 

(3) 

CE3106A. .B 

(2) 

CE3107B 


CE3108A..B 

(2) 

CE3109A 


CE311QA 


CE3111A. .B 

(2) 

CE3111D..E 

(2) 

CE3112A..D 

(4) 

CE3114A. .B 

(2) 

CE3115A 


CE3119A 


EE3203A 


EE3204A 


CE3207A 


CE3208A 


CE3301A 


EE3301B 


CE3302A 


CE3304A 


CE3305A 


CE3401A 


CE3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A. .C 

(3) 

CE3403E..F 

(2) 

CE3404B..D 

(3) 

CE3405A 


EE3405B 


CE3405C..D 

(2) 

CE3406A..D 

(4) 

CE3407A..C 

(3) 

CE3408A. .C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE3410C..E 

(3) 

EE3410F 


CE341IA 


CE3411C 


CE3412A 


EE3412C 


CE3413A. .C 

(3) 

CE3414A 


CE3602A..D 

(4) 

CE3603A 


CE3604A..B 

(2) 

CE3605A..E 

(5) 

CE3606A..B 

(2) 

CE3704A..F 

(6) 

CE3704M..0 

(3) 

CE3705A..E 

(5) 

CE3706D 


CE3706F..G 

(2) 

CE3804A..P 

(16) 

CE3805A. .B 

(2) 

CE3806A. .B 

(2) 

CE3806D..E 

(2) 

C:E3806G. .H 

(2) 

CE3904A. .B 

(2) 

CE3905A. .C 

(3) 

CE3905L 


CE3906A..C 

(3) 

CE3906E..F 

(2) 








CE2103A, CE2103B, and CE3107A use an illegal file name in an attmopt 
to create a file and expect NAHE_ERROR to be raised; this 
implementation does not siq^rt external files and so raises 
USE EBROR. (See section 2.3.) 


2-3 





IMPLEMEHEKnCN DEPENDENCIES 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) viere required for 10 tests. 

The following tests were split into two or more tests becaxise this 
implementation did not report the violations of the Ada Standard in the way 
eiqpected the original tests. 

B22003A B83033B B85013D 

Ch2009C and CA2009F were graded inapplicable by Evaluatim Modification as 
directed by the AVO. These tests contain instwtiations of a generic \jnit 
prior to the separate ccopilation of that unit's body; as allowed by 
AI~257, this implementation requires that the bodies of a generic unit be 
in the same compilation if instantiatiois of that unit precede the bodies. 
The ioplementation issues error messages at link time that the main program 
"has unresolved generic instantiations" and the tests cannot be executed. 

BC3204C and BC3205D were graded passed Processing Modification as 
directed by the AVO. These tests check ttot instantiatims of generic 
units with imconstrained types as generic actxial parameters are illegal if 
the generic bodies contain uses of the types that require a constraint. 
However, the generic bodies are ccopiled after the units that contain the 
instantiations, and this implementation creates a dependence of the 
instantiating imits on the generic units as allowed Al-00408 and 
AI> ‘r'S06 such that the compilation of the generic bodies makes the 
instantiating units obsolete—no errors are detected. The processing of 
these tests was modified by re-conpiling the obsolete units; all intended 
errors were then detected by the coapiler. 

CE2103A, CE2103B, and CE3107A were graded inaqjplicable by Evaluation 

Modification as directed by the AVO. The tests abort with an uidiandled 
exception vhen USE_ERBOR is raised on the attempt to create an external 
file. This is acceptable behavior because this implementatim does not 
support external files (cf. Al-00332). 


2-4 






CHAPTER 3 

PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

Hie Ada iaplanentation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For technical and sales information about this Ada inplementation, contact: 

Mike l^r 
Intermetrics Inc. 

733 Concord Avenue 
Cambridge MA 02138-1002 
(617) 661-1840 


Testing of this Ada implementation was conducted at the customer's site by 
a vedidation team from the AVF. 


3.2 SUHHARy OF TEST RESULTS 

An Ada Inplementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada Inplementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that c^forms to the Ada Progranming Language Standard. 

The list of items below gives the nunber of ACVC tests in various 
categories. All tests were processed, except those that were withdrawn 
because of test errors (item b; see section 2.1), those that require a 
floating-point precision that exceeds the implementation's 
precision (item e; see section 2.2), and those that depend on the svpport 
of a file system — if none is st^ported (item d). All tests passed, 
except those that are listed in sections 2.1 and 2.2 (counted in itons b 


3-1 







PROCESSING INTORmnON 


and f, below). 


a) Total Number of Applicable Tests 3575 

b) Total Number of Withdrawn Tests 95 

c) Processed Ini^licable Tests 39 

d) Non-Processed I/O Tests 260 

e) Ncxi-Processed Floating-Point 

Precision Tests 201 

f) Total Number of in^splicable Tests 500 (c-Kl+e) 


g) Total Number of Tests for ACVC 1.11 4170 (a-t-bff) 


3.3 TEST EXECUnCN 

A TK-50 cartridge t^^ containing the customized test suite (see section 
1.3) was ta]cen on-site the validation team for processing. The contents 
of the TK-50 cartridge tape were loaded directly onto the host computer. 

After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada implementaticai. 

The tests were coa()iled and lin)ced on the computer system, as appropriate, 
and run. The results were captured on the confiuter system. 

Testing was performed using command scripts provided the customer and 
reviewed by the validation team. See i^jpendix B for a complete listing of 
the processing options for this implementation. It edso indicates the 
default options. The options invoked explicitly for validaticm testing 
during this test were: 

Opticxi/Switch 

Conpiler Options 
AIST 


-Ic 


Program Builder optiois 
/PASS-llink_options 

Linker/Locator options 
/LLi-adabase: [ lib Ihnwn^. Ibl 

Name of library index file to be used for 
unresolved references. 

/C-adabase:[lib]hnwnpk.11c 

Name of file containing locator commands. 


Effect 

Generate a coa{>ilation listing with default 
listing format. Used for E tests. 

Generate a compilation listing with continuous 
listing format. Used for all other tests. 

Pass options to the linker locator. 


3-2 





PRCXZSSINS INFatHATION 


/SE Ellainate unraferenced sagnents. 

"atatOOl","rtl_stack",”addres6_spaca_descriptor") 

Mark indicated synbols as raferencad bafora 
detarmining unrafaranced sagaents. 


Test output, coBf>iler and linker listings, and j(^ logs were captured on 
TK-50 cartridge tape and archived at the AVF. The listings examined 
on-site by the validation team were also archived. 




APPENDIX A 


MACRO PARAHEIEltS 


appendix contains the macro parameters used for custoadzino the ACVC. 
The meaning and purpose of these parameters are eiqplained in [UQ89]. Die 
parameter values are presented in two tables. The first table lists the 
v^ues that are defined in terms of the maximum ii^t-line length, whidi is 
the val\ie for $MAX_IN_UM—also listed here. These values are e^mressed 
Mre as Ada string aggregates, v*ere "v" represents the input-line 

length. ^ 


Macro Parameter 


Macro Value 


$MAX_IN_LEN 

$B1G__ID1 

$BIG_1D2 

$BIG_ID3 

$BIG_I04 

$BIG_INT__LIT 

$BlGJfflAL_LIT 

$BIG__STRING1 

$BIG_STRING2 

$BLANRS 


200 — Value of V 

(1..V-1 -> »A», V -> »1») 

(1..V-1 -> V -> '2') 

(1..V/2 -> 'A') & '3' & 
(1..V-1-V/2 -> 'AM 

(1..V/2 -> 'A') & '4' & 
(1..V-1-V/2 -> 'A') 


(1. 

.V-3 -> '0') & 

"298" 

(1. 

.V-5 -> '0') & 

"690.0" 

r fi r 

& (1. 

..V/2 -> 

'A') & 

r 

& (1. 

, .v-l-V/2 

-> 'A') & '1' & 

(1. 

.V-20 




$MAX_LEN_INr_BASED_LITERAL 

"2:- 4 (1..V-5 -> '0') s "11:" 

$NAX_LENJtEAL_BASED_LZTERAL 

"16:" & (1..V-7 -> '0') 6 "F.E:" 




$NMC SBONG LITERAL 


9 N R 


t (1..V-2 -> »A») & 


9 M 9 


IfM following table lists all of the other ancro paraaeters and their 
reflective values. 

Macro Parameter Macro value 


$ACX:_S1ZE 
$ALIGNHEMT 
$OCXtir_LAST 
$I»najLTJlEM_SZZE 
$ISFAULT_STQRJUNIT 
$DEFAULT_SYS_NAME 
$DEL'1AJD0C 
$ENI1ty_ADI»ESS 
$ENTBY_ADI»ESS1 
$iaiIRy_ADORESS2 
$field_last 

$FILEjrEBMINATOR 
$FIXED_NAHE 
$FLQAT_NAHE 
$FQBH_STTaNG 
$FQRM_STRING2 
$GREAlEr THAN DURATION 


32 

4 

2_147_483_647 

2_147_483_648 

8 

»W_RH32 

2.0**(-31) 

16 « 1 * 

16*21 

16*3* 

2_147_483_647 

9 9 

llO__SOCH_FIXEDjrePE 

NOjSUCH_rLQAT_TYPE 

nh 

"CAMIOT RESraiCT FILE CAPAdTT” 


90_000.0 

$GREATERJIBAN_DURATION BASE LAST 

T0_00T)[_000.0 

$greaxer_thanjflgm: base last 

“ 3.I1B+38 

$GREATERJIHAN_FLQAT SAFE LARK 

l.TrE38 







mCBO PMtMBTBRS 


$GISAIER_THAN_SHORT FLOAT SAFE LARGE 

1.0138 ~ 

$HlGH_PRICRIT!f 31 

$ZLLEGAL_EXTE!tNAL_FILE NAHEl 

ifo_FILES_AT_ALL_l 

$ILLEGALJSCIEBNAL_FILE_NAME2 

NO_FILES_AT_ALL_2 

$IMAPPROPRIATE_LIME LEXIGfIB 

-1 

$INAPPRQPRIAIE_PAGE_LE>IGIR 



-1 

$INCLUIX:_PRAGKA1 

PRAGMA INCLUDE ("A28006D1 .ADT") 

$INCLUDe_PBAGHA2 

PRAGMA INCLUDE ("BlEOOSFl .ADT*) 

$INIBGER_FIRST 

-2147483648 

$INTBGER_LAST 

2147483647 

$INTBGER_LAST_PLUS__1 

2147483648 

$IIfrERFACB_LANGUAGE 

ASSEMBLY 

$LESS_TBAN_DUBATIGN 

-90^000.0 

$LESS TBAN DURATION BASE FIRST 

-ITTOOOOOO.O 

$LIMEjrERMINATQR 

ASCII.LP 

$LOW_PRIGRITT 

1 

$HACHINE_OOItt;_STATEHBIT 

Format R Offset Base'CH LD,R1,0, 
Format R'^{H JMP,R1); ” 
Format'K R R'(H AEO,RO,RO,RO); 

$MACHlNE_pQrejr3fPE 

Format__RJR 

$nANnSSA_DOC 

31 

$nAXJDIGITS 

15 

$MAX_INT 

2147483647 

$HAX__INT_PLUS_1 

2_147_483_648 

$MIN_INT 

-2147483648 


A-3 





$Nltf1E 

$AME_UST 

^AMEJSPECIFIGATIGNl 

$NMIE_SPBClFICmGN2 

$NM(E_SPBCinaVTZGN3 

$NB6_BASED_INT 

$NEN_MEM_SIZE 

$NEW_S!rORJUNZT 

$NEW_SyS_NM1E 

$SAGEJXEBMINKEOR 

$REOORD_DEFINITIGM 


BYTE_INTBGER 

»WJ«32, TRW_RH32 

N0_FILES_1 

N0_FILES_2 

N0_FILES_3 

16iF000000E« 

2147483648 

8 

T!IW_RH32 
ASCII.FF 

RECORD »lEMGNIC:NNEIfONIC ENUI; 
REG:RBGZSTER OWN; £20) RSOORD; 


$REOOftD_NMlE FGRMATJt 

$TASK_SIZE 32 

$TASK_STORAGE_SIZE 2048 

$TICK 2.0**(-14) 

$VARIABLE_ADORESS 16«3FFD0i 

$VMaABLE_AII»ESSl l6f3FFF4i 

$VARIABLE_A00RESS2 16t3FFF8i 

$YC»R PRAGMA 


APART 




APPQOIX B 


OQKPIIATIGN SYSTEM OPTICNS 


lh« conpiler options of this Ada ioplenentation, as described in this 
appendix, are provided by the custOMer. unless specifically noted 
otherwise, references in this appendix are to conpiler docunentation and 
not to this report. 


B-1 







Inputs 


Invocation 


adilnp CiptfM. • • IjfKtada 


Options 

/dabug Generate debugging output The /dabug option causes the compiler to generate the ap- 
pn^ate code and dau for operation with the RISCAE Debugger. 

/arxor.leg Generate error log file. The/arror_log option causes the comfnte’to 

generate a log file containing all the error messages and warning messages produced during com¬ 
pilation. The error log file has the same name as the source file, with the extension .arr. For 
example, the error log file for aiaipla.ada isaiagpla.arr. The error log file is placed in the 
current working directory. In the absence of the /Hat option, the error log infonnation is sent to 
the standard output stream. 

/snm.ehaeks.auppraaa Suppress numeric diecking. The /Bnm.ehaeks.auppraas option 
suppresses two kinds of numeric checks for the entire compilation: 

1. division.clieck 

2. ovcrflow.check 

These checks are described in section 11.7 of theLRM. Using /araa.chaeka.auppraaa re¬ 
duces the size of the code. Note that there is a related adahmr option. /all_chacks_aup- 
praas to suppress all checks for a compilation. 

/all_ehaeka_8uppraaa Suppress all checks. The /all.chaeka.auppraaa option suppresses 
all automatic checking, including numeric checking. This option is equivalent to using pragma 
mvppxmmm onall checks. This option reduces the size of the code, and is good for prothicing‘‘pro¬ 
duction quality” code or for benchmarking the compiler. Note that there is a related adatanw op¬ 
tion. /iiinB_e]iae]ea_avpprass to suppress only certain kinds of numeric checks. 

/wazniag.suppraaa 

Suppress warning messages. With this option, the compiler does not print warning messages about 
igiK^ pragmas, exceptions that are certain to be raised at Tun-^ime. or other potential problems that 
the compUer is otherwise forbidden to deem as errors by the LRM. 

/no_dal«t« 

Keep internal form file. This option is forusebycomf^ermaintainers. Without this option, the 
compiler deldes internal form files foliowii^ code generation. 

/list 

Generate listing file. The /list option causes the compiler to create a listing. The formats of and 
options for listings are discussed in section 3.2.1.7. The default listing file generated has the same 
name as the source file, with the extension . l«t. For example, the default listing file produced for 
■iavln.ada has the name siflpln.lst. The listing file is placed in the current working direc¬ 
tory. Inorder to generate a listing in the continuous listing format, use the -le switch rather than the 








/list option. Note: /list also causes an mot log file to be produced, as with the/sr- 
ror.leg option. 

/library 

Defuilt: ads.lib 

Use alteniate library. The /library option specifies an alternative name for the program library. 






OCMPIlAnCM SYSnH OPTZGNS 


LINKER OPnCNS 

Ttw linker options of this Ada ispleamtation, as described in this 
^jpendix, are provided by the custoeer. Unless specifically noted 
ottorwise, references in this appendix are to linker dociawitation and not 
to this report. 





Inputs 


Invocation 


BMit C«|Nte« ...1 Cinriii ffCiikm tumtj 


Options 

/ compilBr=compUer_name 

Default: ada. lib 

Use alternate compiler. The / compiler option specifies the complete (non 
relative) directory path to the RlSCAEAda compiler. This option overrides 
the compiler program name stored in the program library. The / coirpiler 
option is intended for use by system maintainers. 


/main.suppress 

Suppress main program generation step. The /main.suppress option sup¬ 
presses the creation and additional code generation steps for the temporary 
main program file. The /main^suppress option can be used when a sim¬ 
ple change has been made to the body of a compilation unit If unit elabora¬ 
tion order is changed, or if the specification of a unit is changed, or if new 
units are added, then this option should not be used. The /main.sup- 
press option saves a few seconds, but places an additional bookkeeping 
burden on you. The option should be avoided under most circumstances. 
Note that invoking banp with the / load_suppress option followed by 
another invocation of basqp with tte /inain_suppress option has the 
same effect as an invocation of banp with neither option (/load.sup- 
press and /inain_suppress neutralize each other). 

/ lihx SLxy^library-nanu 

Default: ada. lib 

Use alternate library. The / library option speciffes the name of the pro¬ 
gram library to be consulted by the bamp program. This option overrides the 
default library name. 


/load^suppress 

No link. The option suppresses actual object file linkage, but creates and per¬ 
forms code generation on the main program file. Note that invoking bauip 
with the option followed by another invocation of bai^ with the / 
main.suppress option has the same effect as an invocation of banp with 
neither option. That is, and /main.suppress neutralize each other. 


RISCAE Software 


Users Manud 









/ display^comnands 

No operations. The / display_cotninands option causes the bainp com¬ 
mand to do a '‘dry run’*; it prints out the actions it takes to generate the execut¬ 
able program, but does not actually perform those actions. The same kind of 
information is printed by the /print_operations option. 

/ o\xtpMt=output-file'name 

Use alternate executable file output name. The /output option specifies 
the name of the executable program file written by the beunp command. This 
option overrides the default output file name which is the main procedure 
name concatenated to 8 characters with Hie extension . ab. 


/ peiss^^llink-options 

Pass options to the Linking Locator. The/pass option specifies the Linnking 
Locator options which are passed directly to the Linking Locator. 

/print_operations 

Print operations. The /print.operations option causes the bainp command to 
print out the actions it takes to generate the executable program as the actions 
ate performed. 

/verbose Link verbosely. The /verbose option causes the banp command to print 

out information about what actions it takes in building the main program such 
as; 

• The name of the program library consulted. 

• The library search order (listed as “saves” of the library units used by 
the program). 

• The name of the main program file created (as opposed to the main 
procedure name). 

• The elaboration order. 

• The name of the executable lead module created. 


RISCAE Software 


Users Manual 



Inputs 


Invocation 


x&xvK {faiiGi40b iM I loptiotui 


Linker Options 


1) 

Name library index files to be searched for unresolved externals. If the index 
file indicates that a given external can be resolved by reading a particular 
module, that module is included in the link. The Librarian section explains 
how library files are built and managed. If a module name in the library index 
file is not a full pathname. 11 ink searches for the module in the directory 
containing the index file. 


Read library index to be searched from file ifii. Index file ifii lists all libraries 
that would be specified on the command line if the /LIB switch were used. 


Note: The linker portiari of the linking locator may not always search 
the libraries in the order given. See the Library Searches subsection 
for more details. 

/SE 

Eliminate unreferenced segments in object modules during linking. This op¬ 
tion has no effect unless the /US option is used. 

/US=(”sym”,”syra 

r...) 

Mark the specified symbols as referenced before determining unreferenced 
segments. The symbols may be global symbols or segment names. This op¬ 
tion has no effect unless the /SE option is used. 

Locator Options 


Locate processing is done by default If the / LO switch is present, locate pro¬ 
cessing is not performed. When locate processing is performed, output is 
written to PROG.AB unless the /O switch is specified. 

IC=cfti 

Read locator commands from file cfh. 

/LO 

Suppress locate processing (link only). If no ROM processing option is speci¬ 
fied, write output to PROC.LN. 

/P=n 

Pad the size of all segments by n bytes. 

/W=n% 

Pad the size of all segments to n percent of their original size (n must be > 


100 ). 


RISCAE Software 


Users Manual 










ROM Processing Options 

ROM processing is performed if and only if some ROM processing option 
is present. If locate processing is also performed, output is written to 
PROG.AB. If only ROM processing is performed, the output is written to 
PROG. RMP by default. 

/B=‘segname Specify the name of the segment to be created. The default name is rom- 

pOutSeg. 

/ RC =classl [, class2,... ] 

Specifies that all segments of the named classfes) will be processed. 


/RS=5egy[,seg2....] 

Specifies that the named segment(s) will be processed. 


Symbol Options 

/K(K“sym,sym2,...”l 

Keep only the named global symbols in the ouput module: suppress all oth¬ 
ers. If no symbols are named, suppress all global symbols. 

/SP(=“syra,sym2,...”] 

Suppress the named global symbols in the output module; keep all others. 

Global symbols are generated by the compiler and assembler for global vari¬ 
ables and procedures. The compiler’s rules for forming global symbol names 
ate described in the RISCAE Software Programmer's Manual. Note that the 
names specified in /SP and /K must be formed via these conventions. 

Generally all global symbols must be retained in the output module to permit 
any further references to be resolved during later links. Specific global sym¬ 
bols may be suppressed to mask name conflicts. The switches which apply 
to global symbols are mutually exclusive. 

If no debugging is intended and the link is complete, all symbols may be 
suipped. Stripping symbols reduces the amount of disk space required to 
hold the output module and speeds up the execution of llink and the formatter. 
It does not a^ect the size of the user program or the download hex file gener¬ 
ated by the formatter. 

Miscellaneous Options 

/ 0 (Zero) Displays the version number of the executable (for technical support 

purposes). 

/ This switch specifies that the names of input object modules are to be taken 

from the file ifn. The input module names should be listed in the file, one per 


RISCAE Software 


Users Manual 








line. The name of the Hrst module listed will be used as a default for 
constructing the name of the linked output file. If ifii is omitted, the names of 
the files are read from the terminal. 

/ 0[ ^ofii] This switch specifies the name of the output file. If the switch is omitted, out¬ 

put will be written to PROG.UJ or PROG.RliP, depending on the switches spe¬ 
cified. 

Verbose mode. Reports the following linking actions as performed: 

• - The names of the object modules being read 

• - The names of the library index files being searched. 

• - The name of the output module. 

/W This switch inhibits warning messages. If llink is not performing the lo¬ 

cate function, the “unresolved externals” warning is the only warning mes¬ 
sage that llink can emit This can safely be suppressed if unresolved exter¬ 
nal references are expected. Other warning messages represent error 
conditions and should not in general be ignored or suppressed. 


RISCAE Software 


Users Manual 






APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed inplementatian dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventiois 
as menticmed in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics of this Ada inplementaticm, as described in this i^ipendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this ^jpendix are to coopiler documentation and not to this 
report. Implementation-specific porticns of the package STANDARD, which 
are not a part of ^jpendix F, are: 


package STANDARD is 


type INTEGER is range -2147483648 .. 2147483647; 
type LGNG_INTBGER is range -2147483648 .. 2147483647; 
type saORT_I N lE G E R is range -2147483648 .. 2147483647; 
type ByTE_INTEGER is range -2147483648 .. 2147483647; 

type FLOAT is digits 6 range -3.40282&i>38 .. 3.40282E4-38; 
type LGNG_FLQAT is digits 15 range -1.79769B+308 .. 1.79769B+308; 

type DURATIGN is delta 2**-14 range -86400.0 .. 86400.0; 


end STANDARD; 









Appendix F 

This section constitutes Appendix F of the Ada LRM for this implementation. Appendix F from the LRM 
states: 

The Ada language allows for certain machine-dependencies in a controlled manner. No machine- 
dependent syntax or semantic extensions or restrictions are allowed The only allowed implementa¬ 
tion-dependencies correspond to implementation-dependent pragmas and attributes, certain ma¬ 
chine-dependent conventions as mentioned in Chapter 13, and certain allowed restrictions on 
representation clauses. 

The reference manual of each Ada implementation must include an appendix (called Appendix F) 
that describes ail implemetaeaiort-deperuUnt characteristics. The Appendix F for a given imple¬ 
mentation must list in particular: 

1. The form, allowed places, and effect of every implementation-dependent pragma. 

2. The name and the type of every implementation-dependent attribute. 

3. The specification of the package SYSTEM. 

4. The list of all restrictions on representatic louses. 

5. The conventions used for any implementation-generated name denoting implementation- 
dependent components. 

6. The interpretation of expressions that appear in address clauses, including those for inter¬ 
rupts. 

7. Any restriction on unchecked conversions. 

8. Any implementation-dependeru characteristics of the input-output packages 
In addition, the present section will describe the following topics: 

9. Any implementation-dependant characteristics of tasking. 

10. Other implementation dependencies. 

F.l: Pragmas 

F.l.l: Predefined Language Pragmas 

This section describes the form, allowed places, and implementation-dependent effect of every predefined 
language pragma. 

F.1.1.1: Pragmas ELABORATE, LIST, OPTIMIZE, PAGE, AND PRIORITY 

Pragmas ELABORATE, LIST, OPTIMIZE, PAGE, and PRIORITY are supported exactly in the form, in the 
allowed places, and with the effect as described in the LRM. 

F.1.1.2: Pragm.f» SUPPRESS 

Form: pragma SUPPRESS (identifier (,(ON s>) name]); 

where the ittentifier and name, if present, are as specified in LRM B( 14). Suf^ession of the follow¬ 
ing run-time checks are supported: 

ACCESS.CHECK 

DISCRIMINANT.CHECK 

INDEX_CHECK 





LENGTH.CHECK 

RANGE.CHECK 

DIVISION.CHECK 

OVERFLOW.CHECK 

ELABORATION^CHECK 

STORAGE.CHECK 

Allowed Places: as specifled in LRM B(14): SUPPRESS. 

Permits the compiler not to emit code in the unit being compiled to perform various checking opera¬ 
tions during program execution. The suf^xirted checks have the effect of suppressing the specified 
check as des^bed in die LRM except as follows. 

• The suppression of DISCRIMINANT.CHECK has no effect if the pragma is not 
in the same declarative pan as the type to which it applies. 

• The suppression of ELABORATION.CHECK has no effect on a task body. 

• The suppression of STORAGE_ERROR does not suppress the check that an al¬ 
locator does not require more space than is available. 

F.1.1.3: Pragma INLINE 

Form: Pragma INLINE isubprogram_namej:(mmaJist) 

Allowed Places: As specified in LRM B(4): INLINE 

Effect: If the subprogram body has already been compiled, or is in the same compilation unit as the call, and 
if the subprogram does not contain nested subprograms, the code is expanded in-liae at every call 
site and is subject to all optimizations. If the subprogram to be inlined is recursive, only the first call 
is inlined and the recursive call is a normal call. 

Exception handlers for the INLINE subprogram are handled as for block statements. 

Use: This pragma is used either when it is believed that the time required for a call to the specified routine 

will in general be excessive (this for frequently called subprograms) or when the average expected 
size of expanded code is thought to be comparable to that of a call. 

F.1.1.4: Pragma INTERFACE 

Form: Przgjnz INTERFACE (.language_name^subprogram_name[, ”link_name"]) 

where the language jname must be assembly, builtin, or internal, and the subprogram juune is as 
specified in the LRM B(S). The optional Unk juune parameter is a string literal specifying the entry 
point label of the non-Ada subprogram named in the second parameter. If link juune is omitted, 
then link juune defaults to the value of subjnogrwnjume. 

Allowed Place: As specified in LRM B(S): INTERFACE 

Effect: Specifies that a subprogram will be provided outside the Ada program library and will be callable 
with a specified calling interface. Neither an Ada body nor an Ada body.stub may be provided for 
a subprogram for which INTERFACE has been specified. Unk juune is used as the entry point label 
of the subprogram. The language juune buiUui and internal are reserved for use by RISC AE com¬ 
piler maintainers in run time suppon packages. 

Use: Use with a subprogram being provided via another program language and for which no body will 
be given in any Ada program. 





The calling conventions for an Ada program calling a pragma INTERFACE (assembly) subprogram 
are according to the RISCAE Run Time Model described in Appendix C of the RISCAE Software 
Programmer’s Manual. 

F.1.1.5: PrafniaPACK 

Form: Pragma PACK (,type_simplejtame) 

Allowed Places: As specified in LRM 13.1(12) 

Effect: The efiea of pragma PACK is to minimizestorageconsumptionbydisaetecomponmt types whose 
ranges permit packing. Refer to the RISCAE Software Programmer’s Manual for more information 
about the effect of pragma PACK. 

Use: Pragma PACK is used to reduce storage size. Size reduction usually implies an increased cost of 
accessing components. The decrease in storage size may be offset by increase in size of accessing 
code and by slowing of accessing operations. 

F.1.1.6: Pmgmns SYS’TEM, NAME, STORAGE.UNTT, MEMORY.SIZE, CON’TROLLED 
These pragmas are not supported and are ignored 

F.1.1.7: Pragma SHARED 

Form: pragma SHARED (variable_simplejiame) 

where variable jiMplejeame is of any scalar type except longjloat. 

Allowed Places: As specified in LRM B(2): SHARED 

Effect Direct reading and direa updating of the specified variable must be implemented as an indivisible 
operation. In addition, the implementation must ensure that each reference of the variable is made 
directly from/to memory (i.e. not fiom a temporary copy of the variable). 

Use: ’This is used to cause every read or update of a variable to be a “synchronization” point for that vari> 

able. 

F.U: RISCAE-Deflned Pragmas 

F.1J.1: F.1,12: Pragma APART 

Form: pragma APART (variable segname\) 

where variabkjume must refer to a static object, (i.e. a variable declared in a library unit package 
specification or body, or in a package specification or body contained in a library unit package) and 
segiuuae, if provided, must be a string literal which specifies the name of the segment containing 
the object 

Allowed Places: Pragma APART Is allowed in the declarative region of a library unit package specification 
or body, or in a package specification or body contained in a library unit package. The declaration 
of the variable must be in the same declarative region as the pragma and must proceed the occurrence 
of the pragma. 

Effect: The object will be placed in a segment that is not included in group “data” and consetpiently, is ad¬ 
dressed directly using prefixed memory direct addressing mode. If segname is provided, it is used 
as the name of the segment for the obj^ Otherwise, the objea is located in segment “aidau” for 
inidailzed objects or “audau” for uninitialized objects. 

Use: 'The RISCAE ran time model specifies that static objects and constants be addressed using base offset . 

addressing mode with the global base register (GBR) and that there is a limit of 64K bytes of total 
size of such data. Pragma APART can be used to specify objects which are not to be addressed using 
the global base register (GBR). Pragma APART may be used if specific data items need to be located 








ftirther APART than 64K bytes or in a large program for which the total size of static objects and 
constants is latga than 64K bytes. Refer to the RISCAE Programmer’s Reference Manual tor mtne 
infmmttion about location and adthessing of static objects. 

F.l^: Pragma INDIRECT 

Form: pragma INDIRECT (,sybprogram_name) 

where iMbfrognmjum* is the name of a subprogram which is declared in the same declarative 
region. A body is not aUowed for a subprogram to which pragma INDIRECT applies. 

Allowed Places: Pragma INDIRECT must appear within the same declarative part as the subprogram to 
which it applies, following the subprogram, and prior to the first use of the subprogram. 

Effect: A call to a subprogram to which pragma INDIRECT applies will cause foe compiler to generate a 
call to the address provided by the first parameter of the subprogram with parameters 2 through N 
of the subprogram being treated as parameters 1 through N-1. This provides the ability to save the 
address of a subprogram in a variable or dtfa structure so that it may be called later. 

Use: This is used in run time system code. It foould not nramally be used in application programs. 

¥.1X4: Pragma CONTIGUOUS 

Form: pragma CONTIGUOUS (jrecord_typejiame) 

Allowed Places: Pragma CONTIGUOUS must appear within the same declarative part as the type to which 
it applies, following the type declaration but prior to any forcing occurrence of the type. 

Effect: Pragma CONTIGUOUS alters the layout of an Ada discriminant record type. Normally an array 
whose bound depends on a discriminant is mapped on to a pointer to a dynamically allocated suing. 
This pragma forces the comjHier to lay out the record and array in a single object 

Use: This is used in nm time system code and should only be used as it is used in the run time. Itshould 

not normally be used in triplication programs. 

F.2: Standard I^pes and Implementation-Dependant Attributes 

Dieie are no imf^mentation-dependent attributes provided by the RISCAE Ada compiler. The fol¬ 
lowing sections define the standard types supported by the RISCAE Ada com{riler and the implementation- 
dependent values of their attributes. 

F.2.1: Standard Types 

The following standard types ate defined for foe RISCAE RH32-targeted compiler, 
type bytejnteger is range -2147483648.. 2147483647; 
type shortjnteger is range -2147483648.. 2147483647; 
type integer is range -2147483648.. 2147483647; 
type Iong_int^er is range -2147483648.. 2147483647; 
type float is digits 6 range -3.40282E'»-38.. 3.40282E4-38; 
type long_float is digits 15 rai^e -1.79769E+308.. 1.79769B+308; 
type duration is delta 2**-14 range -86400.0.. 86400.0; 

¥2J2: Implementation-Dependent Attributes 

This section describes the implementation-dependent values of the attributes of the standard types. 

Type INTEGER 

INTEGER’SIZE 


32 — bits 







INTEGER’FIRST 

WTEGERLAST 

Type longjntcger 

INTEGER’SCZE 

INTEGER’FIRST 

INTEGERLAST 

Type SHORT.INTEGER. 
INTEGER’SIZE 

intcgerfirst 

INTEGERLAST 

Type BYTE.INTEGER. 
INTEGER’SIZE 
INTEGER’FIRST 
INTEGER’LAST 


» -(2**31) -2.147.483.648 

= (2**31- I) — 2,147.483.648 


» 32 - bits 

»-<2**3l) -2.147.483.648 

= (2**31- 1) -- 2,147.483.648 


= 32 - bits 

.-{2**31)-2.147,483.648 

» (2**31 - 1) — 2,147.483.648 


■ 32-bits 

*-(2**31)-2.147.483.648 

■ (2**31 - 1) — 2.147.483.648 


Type FLOAT 

FLOATSIZE 

FLOATDIGITS 

FLOATMANTISSA 

FLOATEMAX 

FLOATEPSILON 

FLOArSMALL 

FLOATLARGE 

FLOATMACHINE.ROUNDS 

FLOATMACHINE.OVERFLOWS 

FLOATMACHINE.RADIX 

FLOArMACHINE_MANTTSSA 

FLOATMACHINE_EMAX 

FLOArMACHINE_EMIN 

FLOATSAFE_EMAX 

FLOArSAFE.SMALL 

FLOArSAFE_LARGE 


= 32 - - bits. 

= 6 
= 21 

■ 84 

■ 2 . 0 **(- 20 ) 

»2.0**(-85) 

■ (1.0-2.0**(-21))*2.0**84 

■ tnie 
= tnie 
= 2 

= 24 
= 128 
= -125 
» 125 

» 2.0**{-l26) 

= (1.0-2.0**-21)*2.0**'125 


Type LONG.FLOAT. 

LONG_FLOArSIZE 

long_floatdigits 

LONG FLOATMANTISSA 

LONG_fLOATEMAX 

LONG_fLOArEPSILON 

long_floatsmall 

LONGJT-OATLARGE 

LONG FLOATMACHINE_ROUNDS 

LONG_FLOATMACHINE_OVERFLOWS 

LONG FLOATMACHINE_RADIX 

longIfloatmachine_mantissa 

LONG_FLOArMACHINE_EMAX 
LONG FLOArMACHINE_EMIN 
LONG_FLOATSAFE_EMAX 
LONGljFLOATSAFE_SMALL 


■ 64 — bits. 

« 15 

= 51 
= 204 

= 2.0**(-50) 

*2.0**(-205) 

»(1.0 - 2.0**-51)*2.0**204 

■ tnie 

■ true 
*2 

» 53 
» 1024 
*-1021 
X 1021 

« 2 . 0 **(- 1022 ) 



LONG_FLOATSAFE_LARGE 


(l.(>-2.0**-5I)*2.0**l021 


Type DURATION. 

DURATION-DELTA 
DURATION-FIRST 
DURATION-LAST 
DURATION-SMALL 

Type PRIORITY. 

PRIORTTY-nRST 
PRIORITY-LAST 

R3: Package SYSTEM 

package SYSTEM is 

type ADDRESS is new integer; 

NULL.ADDRESS : constant ADDRESS 0: 

type NAME is (hnw_rh32. trw_rh32); 

SYSTEM.NAME: constant NAMEhnw.rh32; 

S-TORAGE.UNIT: constant ;* 8; 

MEMORY.SIZE: constant;» 2**31; — In storage units 

- System-Dependent Named Numbers: 

MIN.INT. constant;« -2147483648; 

MAX.INT: constant:» 2147483647; 

MAX_DIGITS : constant;« IS; 

MAX.MANTISSA: constant31; 

FINE.DELTA: constant:» 2.0**(-3I); 

TICK: constam ;* 2.0**(-14); 

- Other System-Dependem Declarations 

- Legal values for pragma nUORTTY. 

- - There are 31 user priority levels. 

- - The default prtotity. if not assigned by pragma, is 0. 
subtype PRIORITY is INTEGER range i.. 31; 

- - NO-TE: -The RISCAE kernel supports higher priorities 

- - under which hardwue interrupts are disabled. 

end SYSTEM; 


F.4: Restrictions on Representation Clauses 

This section describes the list of all restrictions on representation clauses. 


= 2.0**(-l4)--seconds 
= -86_400.0 
« 86_400.0 
= 2.0**(-l4) 


s 1 

= 31 






“NOTE: An implementatUm may limit its acceptance of -epresentation clauses to those that can be 
handled simply by the underlying hardware.... If a program cont tins a representation clause that is not ac¬ 
cepted (by the compiler I, then the program is illegal." (LRM 13.1 (10)). 

F.4.1: Length Clauses 

Size specification: TSIZE. 

The size specification may be applied to a type T or first-named subtype T which is an access type, 
a scalar type, an array type or a record type. 

AI-00S36/07 has altered the meaning of a size specification. In particular, the statement from the 
LRM 13.2.a that the expression in the length clause specifies an upper bound for the number of bits 
to be allocated to objects of the type is incotrect. Inst^. the expression specifies the exaa size for 
the type. Objects of the type may be larger than the specified size for padding. Note that the specified 
size is not used when the type is used as a component of a record type and a component clause specify¬ 
ing a different size is given. 

If the length clause can not be satisfied by the type, an error message will be generated. In addition, 
the following restrictions apply: 

access type: the only size supported is 32. 

integer, fixed point, or enumeration type: minimum size supported is 1. the maximum size 

that is supported is 32. the size of the largest prede¬ 
fined integer type. Biased representation is not 
supported. 

floating point type: the sizes supported are 32 and 64. Note that the 

size must satisfy the DIGITS requirement No 
support is provided for shortened mantissa and/or 
exponent lengths. 

Specification of collection size: TSTORAGE_SIZE. 

The effect of the specification of collection size is that a contiguous area of the required size will be 
allocated for the collection. If an attempt to allocate an objea within the collection requires more 
space than currently exists in the collection. STORAGE.ERROR will be raised. Note that this space 
includes the header information. 

Specification of storage for a task activation: TSTORAGE.SIZE. 

The value specified by the length clause will be the total size of the stacks (primary and secondary) 
allocated for the task. 

Specification of small for a fixed point type: TSMALL. 

The value of TSMALL is subject only to the restrictions defined in the LRM(13.2). 

F.4.2: Enumeration Representation Clauses 

Enumeration representation clauses are supported with the restriction that the values of the internal 
codes must be in the range of MIN.INT.. MAX.H^. 

F.43: Record Representation Clauses 

Record representation clauses are supported with the following restrictions: 

• Allowed values in the alignment clause are 1 (byte-aligned), 2 (half-word 
aligned). 4 (fiiU-word aligned) and 8 (double-word aligned). 






• In the component clause, the storage unit offf't (the smric_simple_expression 
pan) must be a word offset (i.e. 0 or a positive multiple of 4). The range of bits 
specified has the following restrictions: if the starting bit is 0, there is no limit 
on the value for the ending bit: if the starting bit is greater than 0, then the end¬ 
ing bit must be less than or equal to 31. 

The actual size of the record objea (including its use as a component of a record or array type) will 
always be a multiple of words (32 bits) with padding added to the end of the record, if necessary. User-speci¬ 
fied ranges must contain at least the minimal number of bits required to represent a (bit-packed) objea of 
the corresponding type; e.g. to represent an integer type with a range of 0.. IS. at least 4 bits must be specified 
in the r<^cord representation specification range. For more information about record layout, refer to the RIS- 
CAE Software Programmer’s Reference Manual. 


F.4.4: Address Clauses 

An address clause may be supplied for an object (whether constant or variable), a subprogram, or 
a task entry, but not for a package or task unit. If an address clause is supplied for a subprogram, a body is 
not allowed for that subprogram. 

An interrupt entry (address clause for an entry) may not have parameters. 

F.5: Implementation Dependent Components 

There are no implementation-generated names denoting implementation-dependent (record) com¬ 
ponents. 

R6: Interpretation of Expression in Address Clauses 

This section describes the interpretation of expressions that appear in address clauses, including 
those for interrupts. System.Address is declared to be new INTEGER, hence, takes values from -2**31 to 
2**31 - 1. For address clauses on objects or subprograms, these values will be interpreted as (virtual) ad¬ 
dresses in target memory as follows: 

address >= 0 implies (virtual) address » address 
address < 0 imfHies (virtual) address «(2**32) address 

For an object: 

The meaning of the value given by an address clause for an objea is the (virtual) address in the target 
memory assigned to that object 

For a subprogram: 

The meaning of the value given by an address clause for a subprogram is the (virtual) address in target 
memory to which the program will branch when the user program makes a call to the sub(vogram. 
The user must supply the code to be executed and ensure that it is located at the indicated address. 

Fcr an entry: 

The Honeywell RH32 provides 8 external interrupt levels, 0 to 7 with level 7 the highest priority. 
If the value given by an address clause for a task entry is in the range 0.. 7. the entry will be called 
when the interrupt corresponding to that interrupt level is signaled. Interrupt level 0 is the Timer A 
interrupt and is reserved for use by the RISCAE kernel in the implementation of package CAL¬ 
ENDAR and to support Ada delay statements. If an interrupt entry attempts to use this interrupt level, 
PROGRAM.ERROR will be raised during activation of the task containing the interrupt entry. 

The RISCAE kernel also provides an INTERFACE which allows an application to cause a software 
interrupt to occur. Values in the range 8 .. IS are provided for software interrupt;. 




Any value outside the range of 0.. IS will cause PROGRAM.ERROR to be raised during activation 

of the task containing the interrupt entry. 

F.7: UNCHECKED CONVERSION 

There are no restrictions on the use of UNCHECKED_CONVERSION. Conversions between ob¬ 
jects whose sizes do not confirm may result in storage areas with undefined values. 

F.8: Input-Output 

This section describes implementation-dependent characteristics of the language predefined input- 
output packages. 

• The RISCAE Ada run time provides no support for external files nor for STAN- 
DARD_INPUT. The predefined exception USE_ERROR will be raised if an 
attempt is made to create or open any external file. The predefined exception 
END_ERROR will be raised if an attempt is made to read STAND ARD_INPUT. 

Support for STAND ARD.OUTPUT is implemented assuming the presence of a 
console I/O device which accepts output characters. The RISCAE simulator pro¬ 
vides the effect of a console I/O device which is used to implement STAN- 
DARD.OUTPUT. (Implementation of STANDARD_OUTTUT for the RH32 
ADM is TBD). 

• Line terminator is ASCII.LF (line feed): page terminator is ASCII.FF (form 
feed). 

• The packages SEQUENTI/VLJO and DIRECT JO cannot be instantiated with 
unconstrained composite types or record types with discriminants without de¬ 
faults. 

• Package LOW_LEVEL_IO is not provided. 

F.9: Tasking 

This section describes other implementation-dependent characteristics of the tasking run-time pack¬ 
ages. 

F.9.1: Scheduling of Ada tasks 

The scheduler of the Ada run-time tasking system runs tasks of equal priority in the order that they 
became eligible to run and allows them to run until blocked or until interrupt^ by the eligibility of a task 
of higher priority. A task whose priority is higher than the task currently tunning may be made eligible to 
run by an interrupt or by the expiration of a delay statement Such an event will cause the currently tunning 
task to be immediately blocked so that the higher priority task may run. 

F.9.2: Implementation-Dependent Termination of Library Unit Tasks 

Even though a main program completes aiul terminates (its dependent tasks, if any. having termi¬ 
nated). the elaboration of the program as a whole continues until each task dependent upon a library unit pack¬ 
age has either terminated or reached an open terminate alternative. See LRM 9.4( 13). 

F.93: Implementation of Calendar 

Support for implementation of Ada delay statements and for the function CLOCK in package CAL¬ 
ENDAR are ptovitted by the RISCAE kernel. The kernel implementation uses Timer A on the cache chip 
of the Honeywell RH32 processor and external interrupt level 0. 




RIO: Other Matters 

This section describes other implemenution-dependent characteristics of the system. 

Restrictions on main program: 

Any paramet^ess procedure which is a library unit may be a main program (LRM 10.1 ;8). 

Order of compilation of generic bodies and subunits (LRM 10.3:9): 

Body and subunits of generic must be in the same compilation as the specification if instantiations 
prec^ them (see AI-00237/02). 





