AD-A223 




FILE COW ■ , 


REPORT DOCUMENTATION PAGE 


Form Apptwd 
OPM No.0704-0188 




aai es 1 z e za 


2. REPORT DATE 

1 Dec 89 to 1 Dec 90 


2. REPORT TYPE AND OATES COVERED 

Final 


<• TITLE AND StBTf^I - ^^3""comp"iler" 1 ^alidat ion Summar^ — ReportTuSNavy^^| A. REONQ AA*®£8$ 

Ada/L, Version 2.0 (/N0_0PTIMIZE Option), VAX 8550 and VAX 11/78 
(Hosts) to AN/UYK-43 (Target), 891201 Si.10211 


«.AUTHOR(S) 

National Institute of Standards and Technology 

Gaithersburg, MD 

USA 


7. PERFORMNG ORGANIZATION NAVE(S) AND ADORESS(ES) 

National Institute of Standards and Technology 
National Computer Systems Laboratory 
Bldg. 255, Rm. A266 
Gaithersburg, MD 20899 

Usa_1_ 

9. SPONSORMG/MONITDRMG AGENCY NAME(S) ANDAOORESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Washington, D.C. 20301-3081 


11. SUP VENTARY NOTES 


12*. DtSTRBUTIONrAVAtABSJTY STATE LENT 

Approved for public release; distribution unlimited. 


[i. PERFORMMG ORGANIZATION 
REPORT NUMBER 


10. SPONSOR NGA/IONtTORING AGENCY 
REPORTNUMBER 


12b. DSTRBUTION COOE 


1S U^^/*A^L?° Version 2.0 (/N0_0PTIMIZE Option), VAX 8550 and VAX 11/785 (Hosts) to 
AN/UYK-43 (Target), ACVC 1.10 


DT1C 

lELECTEj 
JUN 2 619801 

%B 1 


114. SUBJECT TERMS Ada programming language, Ada Compiler Validation 
Summary Report, Ada Compiler Validation Capability, Validation 
Testing, Ada Validation Office, Ada Validation Facility, ANSI/MIL- 
STD-1815A, Ada Joint Prog ra m Office _ 

SECURITY CLASSIFICATION 1s“tfduffff7dLAiS#£AteN H. SEOJRnlV d^55HiUT W 

Classified I unSD^ed UNCLASSIFIED 


40 - 01*2804800 


SO 06 .25 133 


IS. MUVBER OF RAGES 


IS. PRICE 0006 


20. UMfTATCN OF ABSTRACT 


296, (HIV. M8) 

NwMif 


















T 


7 



AVF Control Number: NIST89USN555_3_1.10 
DATE VSR CCMPLETED BEFORE QN-STTE: 08-11-89 
DATE VSR COMPLETED AFTER ON-SITE: 12-04-89 
DATE VSR MODIFIED PER AVO COMMENTS: 12-29-89 
DATE VSR MODIFIED PER AVO COMMENTS: 04-27-90 


Ada COMPILER 
VAIZDATION SUMMARY REPORT: 

Certificate Number: 891201S1.10211 
U.S. NAVY 

Ada/L, Version 2.0 (/NOjOPTIMIZE Option) 

VAX 8550 an! VAX 11/785 Hosts and AN/UYK-43 Target 


Completion of On-Site Testing: 
12-01-89 


Prepared By: 

Software Standards Validation Group 
National Computer Systems laboratory 
National Institute of Standards and Technology 
Building 225, Rocm A266 
Gaithersburg, Maryland 20899 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 



Accession For 

NTIS GRAJfci 
DTIC TAB 
Unannounced 
Just If 5 calion_ 


7 ^ 


By--- 

.Distribution/ 
Availability Codes 
[Avfiil und/or 
| Spoolal 


□ □ 




AVF Control Number: NIST89USN555_3_1.10 
DATE COMPLETED BEFORE ON-SITE: 08-11-89 
DATE COMPLETED AFTER ON-SITE: 12-04-89 

Ada Compiler Validation Summary Report: 

Compiler Name: Ada/L, Version 2.0 (/NO_OPTIMIZE Option) 

Certificate Number: 891201S1.10211 


Hosts: VAX 8550 and VAX 11/785 under VMS, Version 5.1 

Target: AN/UYK-43 Bare machine 


Testing Completed 12-01-89 Using ACVC 1.10 


This report has been reviewed and 



Dn/ David K. Jefferson 
Chief, Information Systems 
Engineering Division (ISED) 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


t*- \ t«r ■***•' I —■ — 

Ada Validation Organization 

1 Dr. John F< garner 

Institute for Defense Analyses 
Alexandria VA 22311 



Ada Joint Program Office 
Dr. John Soloraond 
Director 

Department of Defense 
Washington DC 20301 


is approved. 



Ada Validation Facility 
Mr. L. Arnold John&rh 
Manager, Software Standards 
Validation Group 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 






TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1-2 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.1-2 

1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-3 

1.5 AC VC TEST CLASSES.1-4 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED.2-1 

2.2 IMPLEMENTATION CHARACTERISTICS . 2-2 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.3-1 

3.2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 WITHDRAWN TESTS.3-2 

3.5 INAPPLICABLE TESTS . 3-2 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . .3-6 

3.7 ADDITIONAL TESTING INFORMATION . 3-7 

3.7.1 Prevalidation.3-7 

3.7.2 Test Method.3-7 

3.7.3 Test Site.3-8 

APPENDIX A CONFORMANCE STATEMENT 

APPENDIX B APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 

APPENDIX E COMPILER OPTIONS AS SUPPLIED BY 

U.S. NAVY 




















CHAPTER 1 


INTRODUCTION 


This Validation Summary Report (VSR) describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results of ^testing this compiler using the Ada Compiler 
Validation Capability (ACVC). An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that 
is not in the Standard. 

Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between 
implementations. The Ada Standard permits some implementation 
dependencies--for example, the maximum length of identifiers or the 
maximum values of integer types. Other differences between compilers 
result from the characteristics of particular operating systems, 
hardware, or implementation strategies. All the dependencies observed 
during the process of testing this compiler are given in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. ^ The purpose of validating is to ensure 
conformity of the compiler to the Ada Standard by testing that the 
compiler properly implements legal language constructs and that it 
identifies and rejects illegal language constructs. The testing also 
identifies behavior that is implementation dependent, but is permitted 
by the Ada Standard. Six classes of tests are used. These tests are 
designed to perform checks at compile time, at link time, and during 
execution. 





1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 


This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 

. To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

. To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

. To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


On-site testing was completed 12-01-89 at Syscon Corporation, 
Washington, D.C. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO 
may make full and free public disclosure of this report. In the United 
States, this is provided in accordance with the "Freedom of Information 
Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do 
not represent or warrant that all statements set forth in this report 
are accurate and complete, or that the subject compiler has no 
nonconformities to the Ada Standard other than those presented. Copies 
of this report are available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 

Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 

Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 


1-2 






r 


Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.3 REFERENCES 


1. Reference Manual for the Ada Programming Language, 
ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide, December 1986. 

1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to 
the Ada programming language. 

Ada Commentary An Ada Commentary contains all information relevant to 
the Commentary point addressed by a comment on the Ada 
Standard. These comments are given a unique 
identification number having the form Al-ddddd. 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

The agency requesting validation. 

The Ada Validation Facility. The AVF is responsible for 
conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 

Gui<telinsa- 


The Ada Validation Organization. The AVO has oversight 
authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and 
technical support for Ada validations to ensure 
consistent practices. 

A processor for the Ada language. In the context of 
this report, a compiler is any language processor, 


Ada Standard 

Applicant 

AVF 

AVO 


Compiler 


1-3 





including cross-compilers, translators, and 
interpreters. 

Failed test An ACVC test for which the compiler generates a result 
that demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 


Inapplicable An ACVC test that uses features of the language that a 
test compiler is not required to support or may legitimately 

support in a way other than the one expected by the 
test. 

Passed test An ACVC test for which a compiler generates the expected 
result. 


Target 


Test 


Withdrawn 


The computer which executes the code generated by the 
compiler. 

A program that checks a compiler's conformity regarding 
a particular feature or a combination of features to the 
Ada Standard. In the context of this report, the term 
is used to designate a single test, which may comprise 
one or more files. 

An ACVC test found to be incorrect and not used to check 
test conformity to the Ada Standard. A test may be 
incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains illegal or 
erroneous use of the language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name 
identifies the class to which it belongs. Class A, C, D, and E tests 
are executable, and special program units are used to report their 
results during execution. Class B tests are expected to produce 
compilation errors. Class L tests are expected to produce errors 
because of the way in which a program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal 
Ada programs with certain language constructs which cannot be verified 
at run time. There are no explicit program components in a Class A test 
to check semantics. For example, a Class A test checks that reserved 
words of another language (other than those already reserved in the Ada 
language) are not treated as reserved words by an Ada compiler. A Class 
A test is passed if no errors are detected at compile time and the 
program executes to produce a PASSED message. 


1-4 









Class B tests check that a compiler detects Illegal language usage. 

Class B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that every 
syntax or semantic error in the test is detected. A Class B test is 
passed if every illegal construct that it contains is detected by the 
compiler. 

Class C tests check the run time system to ensure that legal Ada 
programs can be correctly compiled and executed. Each Class C test is 
self-checking and produces a PASSED, FAILED, or NOT APPLICABLE message 
indicating the result when it is executed. 

Class D tests check the compilation and execution capacities of a 
compiler. Since there are no capacity requirements placed on a compiler 
by the Ada Standard for some parameters--for example, the number of 
identifiers permitted in a compilation or the number of units in a 
library--a compiler may refuse to compile a Class D test and still be a 
conforming compiler. Therefore, if a Class D test fails to compile 
because the capacity of the compiler is exceeded, the test is classified 
as inapplicable. If a Class D test compiles successfully, it is 
self-checking and produces a PASSED or FAILED message during execution. 


Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the 
Ada Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is 
rejected by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is 
attempted. A Class L test passes if it is rejected at link time--that 
is, an attempt to execute the main program must generate an error 
message before any declarations in the main program or any units 
referenced by the main program are elaborated. In some cases, an 
implementation may legitimately detect errors during compilation of the 
test. 

Two library units, the package REPORT and the procedure CHECK_FILE, 
support the self-checking features of the executable tests. The package 
REPORT provides the mechanism by which executable tests report PASSED, 
FAILED, or NOT APPLICABLE results. It also provides a set of identity 
functions used to defeat some compiler optimizations allowed by the Ada 
Standard that would circumvent a test objective. The procedure 
CHECK_FILE is used to check the contents of text files written by some 
of the Class C tests for Chapter 14 of the Ada Standard. The operation 


1-5 





of REPORT and CHECK_FI T JS is checked by a set of executable tests. These 
tests produce messages that are examined to verify that the. units are 
operating correctly. If these units are not operating correctly, then 
the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended 
to ensure that the tests are reasonably portable without modification. 
For example, the tests make use of only the basic set of 55 characters, 
contain lines with a maximum length of 72 characters, use small numeric 
values, and place features that may not be supported by all 
implementations in separate tests. However, some tests contain values 
that require the test to be customized according to 
implementation-specific values--for example, an illegal file name. A 
list of the values used for this validation is provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable 
to the implementation. The applicability of a test to an 
implementation is considered each time the implementation is validated. 

A test that is inapplicable for one validation is not necessarily 
inapplicable for a subsequent validation. Any test that was determined 
to contain an illegal language construct or an erroneous language 
construct is withdrawn from the ACVC and, therefore, is not used in 
testing a compiler. The tests withdrawn at the time of this validation 
are given in Appendix D. 


1-6 







CHAPTER 2 


CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation wts tested under 
the following configuration: 

Compiler: Ada/L, Version 2.0 (/NO_OPTIMIZE Opticn) 

ACVC Version: 1 10 

Certificate Number: 891201S1.10211 

Host Computers: 

Machine: VAX 8550 and VAX 11/785 

Operating System: VMS, Version 5.1 
Memory Size: 48MBytes / 16MBytes 

Target Computer: 

Machine: AN/UYK-43 

Operating System: Bare machine 
Memory Size: ISMBytes 

Communications network: PORTAL/43 


2-1 






2.2 IMPLEMENTATION CHARACTERISTICS 


One of the purposes of validating compilers is to determine the behavior 
of a compiler in those areas of the Ada S tandar d that permit 
implementations to differ. Class D and E tests specifically check for 
such implementation differences. However, tests in other classes also 
characterize an implementation. The tests demonstrate the following 
characteristics: 


a. Capacities. 

(1) The compiler correctly processes a compilation containing 
723 variables in the same declarative part. (See test 
D29002K.) 

(2) The compiler correctly processes tests containing loop 
statements nested to 65 levels. (See tests D55A03A. .H (8 
tests).) 

(3) The compiler correctly processes tests containing block 
statements nested to 65 levels. (See test D56001B.) 

(4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tests D64005E. .G (3 tests).) 


b. Predefined types. 

(1) This implementation supports the additional predefined 
types IDNG_INTEGER and LONG_FLQAT in the package STANDARD. 
(See tests B86001T..Z (7 tests).) 


c. Expression evaluation. 

The order in which expressions are evaluated and the time at 
which constraints are checked are not defined by the language. 
While the ACVC tests do not specifically attempt to determine 
the order of evaluation of expressions, test results indicate 
the following: 

(1) All of the default initialization expressions for record 
components are evaluated before any value is checked for 
membership in a component's subtype. (See test C32117A.) 

(2) Assignments for subtypes are performed with the same 
precision as the base type. (See test C35712B.) 


2-2 









(3) This implementation uses no extra bits for extra precision 
and uses all extra bits for extra range. (See test 
C35903A.) 

(4) NUMERIC_ERROR is raised for pre-defined integer comparison 
and for pre-defined integer membership. NO EXCEPTION is 
raised for large_int comparison or for large_int 
membership. NUMERIC_ERROR is raised for small_int 
comparison and for small_int membership when an integer 
literal operand in a comparison or membership test is 
outside the range of the base type. (See test C45232A.) 

(5) NUMERIC_ERROR is raised when a literal operand in a 
fixed-point comparison or membership test is outside the 
range of the base type. (See test C45252A.) 

(6) Underflow is gradual. (See tests C45524A. .K (11 
tests).) 


d. Rounding. 

The method by which values are rounded in type conversions is 
not defined by the language. While the ACVC tests do not 
specifically attempt to determine the method of rounding, the 
test results indicate the following: 

(1) The method used for rounding to integer is round away from 
zero. (See tests C46012A..K (11 tests).) 

(2) The method used for rounding to longest integer is round 
away from zero. (See tests C46012A. .K (11 tests).) 

(3) The method used for rounding to integer in static universal 
real expressions is round toward zero. (See test C4A014A.) 


e. Array types. 

An implementation is allowed to raise NUMERIC_ERRDR or 
CENSTRAIOT_ERRGR for an array having a 'LENGTH that exceeds 
STANDARD. INTEGER'LAST and/or SYSTEM. MAXJtNT. For this 

implementation: 

(1) Declaration of an array type or subtype declaration with 
more than SYSTEM.MAX_INT components raises NUMERIC_ERRDR. 
(See test C36003A.) 

(2) NUMERIC_ERRDR is raised when 'LENGTH is applied to an array 
type with INTEGER'LAST + 2 components. (See test C36202A.) 


2-3 





(3) NUMERIC_ERROR is raised when 'LENGTH is applied to an array 

type with SYSTEM.MAX_INT + 2 components. (See test 

C36202B.) 

(4) A packed BOOLEAN array having a 'LENGTH exceeding 
INTEGER'LAST raises NUMERICJSRRQR. (See test C52103X.) 

(5) A packed two-dimensional BOOLEAN array with more than 
INTEGER'LAST components raises NUMERIC_ERRQR when the array 
type is declared. (See test C52104Y.) 

(6) A null array with one dimension of length greater than 
INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAINT_ERROR 
either when declared or assigned. Alternatively, an 
implementation may accept the declaration. However, 
lengths must match in array slice assignments. This 
implementation raises no exception. (See test E52103Y.) 

(7) In assigning one-dimensional array types, the expression is 
evaluated in its entirety before OONSTRAINr_ERROR is raised 
when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

(8) In assigning two-dimensional array types, the expression is 
not evaluated in its entirety before OQNSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

f. Discriminated types. 

(1) In assigning record types with discriminants, the 
expression is evaluated in its entirety before 
CENSTRAINr_ERROR is raised when checking whether the 
expression's subtype is compatible with the target's 
subtype. (See test C52013A.) 


g. Aggregates. 

(1) In the evaluation of a multi-dimensional aggregate, the 
test results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 

(2) In the evaluation of an aggregate containing subaggregates, 
all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 

(3) All choices were not evaluated before OONSTRAINT_ERROR is 
raised when a bound in a non-null range of a non-null 
a gg re g ate does not belong to an index subtype. (See test 
E43211B.) 


2-4 




h. Pragmas. 


(1) Hie pragma INLINE is supported for functions or procedures. 
(See tests IA3004A. .B (2 tests), EA3004C..D (2 tests), and 
CA3004E..F (2 tests).) 

i. Generics. 

(1) Generic specifications and bodies can be compiled in 

separate compilations. (See tests CA1012A, CA2009C, 

CA2009F, BC3204C, and BC3205D.) 

(2) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 

(3) Generic subprogram declarations and bodies can be compiled 
in separate compilations. (See tests CA1012A and CA2009F.) 

(4) Generic library subprogram specifications and bodies can be 
compiled in separate compilations. (See test CA1012A.) 

(5) Generic non-library subprogram bodies can be compiled in 
separate compilations from their stubs. (See test 
CA2009F.) 

(6) Generic package declarations and bodies can be compiled in 
separate compilations. (See tests CA2009C, BC3204C, and 
BC3205D.) 

(7) Generic library package specifications and bodies can be 
compiled in separate compilations. (See tests BC3204C and 
BC3205D.) 

(8) Generic non-library package bodies as subunits can be 
compiled in separate compilations. (See test CA2009C.) 

(9) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA301IA.) 


j. Input and output. 

(1) The package SEQCJENTIAL_IO cannot be instantiated with 

unconstrained array types and record types with 

discriminants without defaults. (See tests AE2101C, 

EE2201D, and EE2201E.) 

(2) The package DIRECr_IO cannot be instantiated with 

unconstrained array types or record types with 

discriminants without defaults. (See tests AE2101H, 


2-5 








EE2401D, and EE2401G.) 

(3) USEJERROR is raised when Mode IN_FHE is not supported for 
the operation of CREATE for SEQUEOTIAL_IO. (See test 
CE2102D.) 

(4) USE_ERRQR is raised when Mode IN_FH£ is not supported for 
the operation of CREATE for DIRECT_IO. (See test CE2102I.) 

(5) Modes INJFTIE, COT_FHE, and INC3OT_FIIE are supported for 
DIRECr_IO. (See tests CE2102F, CE2102J, CE2102R, CE2102T, 
and CE2102V.) 

(6) Modes IN_FH£ and CXJT_FHE are supported for text files. 
(See tests CE3102I..K (3 tests).) 

(7) RESET and DELETE operations are supported for 
SEQUENTIAL_IO. (See tests CE2102G and CE2102X.) 

(8) RESET and DELETE operations are supported for DIRECr_IO. 
(See tests CE2102K and CE2102Y.) 

(9) RESET and DELETE operations are supported for text files. 

(See tests CE3102F. .G (2 tests), CE3104C, CE3110A, and 

CE3114A.) 

(10) Overwriting to a sequential file does not truncate the 
file. (See test CE2208B.) 

(11) Temporary sequential files are given names and deleted when 
closed. (See test CE2108A.) 

(12) Temporary direct files are given names and deleted when 
closed. (See test CE2108C.) 

(13) Temporary text files are given names and deleted when 
closed. (See test CE3112A.) 

(14) Only one internal file can be associated with each external 
file for sequential files when reading only. (See test 
GE2107A.) 

(15) Only one internal file can be associated with each external 
file for sequential files when writing. (See tests 
CE2107B..E (4 tests), CE2110B, and CE2111D.) 

(16) Only one internal file can be associated with each external 
file for direct files when reading. (See test CE2107F.) 

(17) Only one internal file can be associated with each external 
file for direct files when writing. (See tests CE2107G. .H 
(2 tests), CE2110D and CE2111H.) 


2-6 







(18) Only one internal file can be associated with each external 
file for text files when reading only. (See CE3111A.) 

(19) Only one interned, file can be associated with each external 
file for text files when reading or writing. (See tests 
CE3111B, CE3111D..E (2 tests), CE3114B, and CE3115A.) 


2-7 




CHAPTER 3 


TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 471 tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing except for 
201 executable tests that use floating-point precision exceeding that 
supported by the implementation. Modifications to the code, processing, 
or grading for 41 tests were required to successfully demonstrate the 
test objective. (See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT TEST CLASS TOTAL 

_A_ B .... C D E L _ 


Passed 

127 

1132 

1858 

17 

22 

46 

3202 

Inapplicable 

2 

6 

457 

0 

6 

0 

471 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


3-1 





3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 

_ z 

3 

4 


6 

7 

CHAPTER 
8 9 

10 11 


_13 

TOTAL 

Passed 

194 

573 

544 

245 

172 

99 

161 

332 

137 

36 

252 

182 275 

3202 

Inapplicable 

18 

76 

136 

3 

0 

0 

5 

0 

0 

0 

0 

187 46 

471 

Wdrn 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 325 

3717 


3.4 WITHDRAWN TESTS 

The following 44 tests were withdrawn from ACVC Version 1.10 at the time 
of this validation: 


A39005G 

B97102E 

C97116A 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A84M 

CD2A84N 

CD2B15C 

CD2D11B 

CD5007B 

CD5011O 

CD7105A 

CD7203B 

CD7204B 

CD7205C 

CD7205D 

CE2107I 

CE3111C 

CE3301A 

CE3411B 

E28005C 

ED7004B 

ED7005C 

ED7005D 

ED7006C 

ED7006D 






See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of 
features that a compiler is not required by the Ada Standard to support. 
Others may depend on the result of another test that is either 
inapplicable or withdrawn. The applicability of a test to an 
implementation is considered each time a validation is attempted. A 
test that is inapplicable for one validation attempt is not necessarily 
inapplicable for a subsequent attempt. For this validation attempt, 471 
tests were inapplicable for the reasons indicated: 

a. The following 201 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAX_DIGITS: 

C24113L..Y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 

C35708L..Y (14 tests) C35802L..Z (15 tests) 


3-2 






C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


b. C24113H, C24113I, C24113J, C24113K (4 tests) are not applicable 
because this implementation supports a line length of 120 
characters. 


c. C35508I, C35508J, C35508M, and C35508N are not applicable because 
they include enumeration representation clauses for BOOLEAN types 
in which the representation values are other than (FALSE -> 0, TRUE 
-> 1). Under the terms of AI-00325, this implementation is not 
required to support such representation clauses. 

d. C35702A and B86001T are not applicable because this implementation 
supports no predefined type SHORT^FLOAT. 


e. The following 16 tests are not applicable because this 
implementation does not support a predefined type SHORT_INTEGER: 



C45231B 

C45304B 

C45502B 

C45503B 

C45504B 


C45504E 

C45611B 

C45613B 

C45614B 

C45631B 


C45632B 

CD7101E 

B52004E 

C55B07B 

B55B09D 

B86001V 

f. 

C45531M..P (4 

tests), C45532M..P 

(4 tests) 

are not applicable 


because this implementation does not support a 48 bit integer 
machine size. 

g. B86001X, C45231D, and CD7101G (3 tests) are not applicable because 
this implementation does not support any predefined integer type 
with a name other than INTEGER or LONG_INTEGER. 

h. B86001Z is not applicable because this implementation supports no 

predefined floating-point type with a name other than FLOAT, or 

LONG_FLOAT. 

i. C86001F is not applicable because, for this implementation, the 
package TEXT_I0 is dependent upon package SYSTEM. This test 
recompiles package SYSTEM, making package TEXT_I0, and hence 
package REPORT, obsolete. Because of the recompilation, the test 
compiles but fails to link. 

j. CD1009C, CD2A41A, CD2A41B, CD2A41E, CD2A42A, CD2A42B, CD2A42C, 

CD2A42D, CD2A42E, CD2A42F, CD2A42G, CD2A42H, CD2A42I, CD2A42J (14 
tests) are not applicable because this implementation does not 
support 'SIZE representations for floating-point types. 

k. CD1009N, CD1009X, CD1009Y, CD1009Z, CD1C03H, CD1C04E, CD4031A, 

CD4041A, CD4051A, CD4051B, CD4051C, CD4051D, CD7204C, ED1D04A (14 
tests)are not applicable because record representation clauses are 


3-3 





not supported. 


1. CD1C04C is not applicable because this implementation does not 
support 'SMALL specification clause for a derived fixed point type 
when it is inherited from the parent. 


m. CD2A51A, CD2A51B, CD2A51D, CD2A51E, CD2A52A, CD2A52B, CD2A52C, 

CD2A52D, CD2A52G, CD2A52H, CD2A52I, CD2A52J, CD2A53A, CD2A53B, 

CD2A53C, CD2A53D, CD2A53E, CD2A54A, CD2A54B, CD2A54C, CD2A54D, 

CD2A54G, CD2A54H, CD2A54I, CD2A54J, ED2A56A (26 tests) are not 
applicable because this implementation does not support 'SIZE 
representations for fixed-point types. 

n. CD2A61A, CD2A61B, CD2A61C, CD2A61D, CD2A61E, CD2A61F, CD2A61G, 

CD2A61H, CD2A61I, CD2A61J, CD2A61K, CD2A61L, CD2A62A, CD2A62B, 

CD2A62C, CD2A64A, CD2A64B, CD2A64C, CD2A64D, CD2A65A, CD2A65B, 

CD2A65C, CD2A65D (23 tests) are not applicable because this 
implementation does not support size specifications for array types 
that imply compression of component storage. 


o. CD2A71A, CD2A71B, CD2A71C, CD2A71D, CD2A72A, CD2A72B, CD2A72C, 

CD2A72D, CD2A74A, CD2A74B, CD2A74C, CD2A74D, CD2A75A, CD2A75B, 

CD2A75C, CD2A75D (16 tests) are not applicable because this 

implementation does not support the 'SIZE specification for record 
types implying compression of component storage. 

p. CD2A84B, CD2A84C, CD2A84D, CD2A84E, CD2A84F, CD2A84G, CD2A84H, 

CD2A84I, CD2A84K, CD2A84L (10 tests) are not applicable because 
'SIZE representation clauses for access types are not supported. 


q. CD2A91A, CD2A91B, CD2A91C, CD2A91D, CD2A91E (5 tests) are not 
applicable because this implementation does not support the 'SIZE 
representation clauses for task types. 


r. 


CD5003B, 
CD5003I, 
CD5011M, 
CD5012J, 
CD5013K, 
CD5014G, 
CD5014V, 


CD5003C, 
CD5011A, 
CD5011Q, 
CD5012M, 
CD5013M, 
CD5014I, 


CD5003D, 
CD5011C, 
CD5012A, 
CD5013A, 
CD50130, 
CD5014K, 


CD5003E, 
CD5011E, 
CD5012B, 
CD5013C, 
CD5013S, 
CD5014M, 


CD5003F, 
CD5011G, 
CD5012E, 
CD5013E, 
CD5014A, 
CD50140, 


CD5003G, 
CD5011I, 
CD5012F, 
CD5013G, 
CD5014C, 
CD5014S, 


CD5003H, 
CD5011K, 
CD5012I, 
CD5013I, 
CD5014E, 
CD5014T, 


CD5014X, CD5014Y, CD5014Z (46 tests) are not applicable 
because this implementation does not support 'ADDRESS clauses for 
variables. 


s. 


CD5011B, CD5011D, 
CD5011S, CD5012C, 
CD5013D, CD5013F, 
CD5014D, CD5014F, 
CD5014U, CD5014W 
implementation does 


CD5011F, CD5011H, CD5011L, CD5011N, CD5011R, 
CD5012D, CD5012G, CD5012H, CD5012L, CD5013B, 
CD5013H, CD5013L, CD5013N, CD5013R, CD5014B, 
CD5014H, CD5014J, CD5014L, CD5014N, CD5014R, 
(30 tests) are not applicable because this 
not support 'ADDRESS clauses for constants. 


t. AE2101C, EE2201D, and EE2201E use instantiations of package 


3-4 





SEQUENTIAL_IO with unconstrained array types and record types with 
discriminants without defaults. These instantiations are rejected 
by this compiler. 

u. AE2101H, EE2401D, and EE2401G use instantiations of package 

DIRECT_IO with unconstrained array types and record types with 
discriminants without defaults. These instantiations are rejected 
by this compiler. 

v. CE2102E is inapplicable because this implementation supports CREATE 
with OUT_FILE mode for SEQUENTIAL_IO. 

w. CE2102F is inapplicable because this implementation supports CREATE 
with INOUT_FILE mode for DIRECT_IO. 

x. CE2102J is inapplicable because this implementation supports CREATE 
with OUT_FILE mode for DIRECT_IO. 

y. CE2102N is inapplicable because this implementation supports OPEN 
with IN_FILE mode for SEQUENTIAL_IO. 

z. CE2102O is inapplicable because this implementation supports RESET 
with IN_FILE mode for SEQUENTIAL_IO. 

aa. CE2102P is inapplicable because this implementation supports OPEN 
with OUT_FILE mode for SEQUENTIAL_IO. 

ab. CE2102Q is inapplicable because this implementation supports RESET 
with OUT_FILE mode for SEQUENTIAL_IO. 

ac. CE2102R is inapplicable because this implementation supports OPEN 
with INOUT_FILE mode for DIRECT_IO. 

ad. CE2102S is inapplicable because this implementation supports RESET 
with INOUT_FILE mode for DIRECT_IO. 

ae. CE2102T is inapplicable because this implementation supports OPEN 
with IN_FILE mode for DIRECT_IO. 

af. CE2102U is inapplicable because this implementation supports RESET 
with IN_FILE mode for DIRECT_IO. 

ag. CE2102V is inapplicable because this implementation supports OPEN 
with OUT_FILE mode for DIRECT_IO. 

ah. CE2102W is inapplicable because this implementation supports RESET 
with OUT_FILE mode for DIRECT.IO. 

ai. CE2105A is inapplicable because CREATE with IN_FILE mode is not 
supported by this implementation for SEQUENTIAL_IO. 

aj. CE210SB is inapplicable because CREATE with IN_FILE mode is not 


3-5 







supported by this implementation for DIRECT_IO. 

ak. CE2107A..E (5 tests), CE2107L, CE2110B CE2111D are not applicable 
because multiple internal files cannot be associated with the same 
external file when one or more files is reading or writing for 
sequential files. The proper exception is raised when multiple 
access is attempted. 

al. CE2107F is not applicable because multiple internal files cannot be 
associated with the same external file when one or more files is 
reading for direct files. 

am. CE2107G..H (2 tests), CE2110D, and CE2111H are not applicable 

because multiple internal files cannot be associated with the same 
external file when one or more files is writing for direct files. 
The proper exception is raised when multiple access is attempted. 

an. CE3102F is inapplicable because text file RESET is supported by 
this implementation. 

ao. CE3102G is inapplicable because text file deletion of an external 
file is supported by this implementation. 

ap. CE3102I is inapplicable because text file CREATE with OUT_FILE mode 
is supported by this implementation. 

aq. CE3102J is inapplicable because text file OPEN with IN_FILE mode is 
supported by this implementation. 

ar. CE3102K is inapplicable because text file OPEN with OUT FILE mode 
is not supported by this implementation. 

as. CE3109A is inapplicable because text file CREATE with IN_FILE mode 
is not supported by this implementation. 

at. CE3111A..B (two tests), CE3111D..E (2 tests), CE3114B, and CE3115A 
are not applicable because multiple internal files cannot be 
associated with the same external file when one or more files is 
reading or writing for text files. The proper exception is raised 
when multiple access is attempted. 


3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases 
where legitimate implementation behavior prevents the successful 
completion of an (otherwise) applicable test. Examples of such 
modifications include: adding a length clause to alter the default size 
of a collection; splitting a Class B test into subtests so that all 
errors are detected; and confirming that messages produced by an 


3-6 







executable test demonstrate conforming behavior that was not anticipated 
by the test (such as raising one exception instead of another). 

Modifications were required for 41 tests. 

The following tests contain no pragma elaboarate. Therefore, it is 
possible that the package body may be elaborated before the package bod^ 
of REPORT. Each of the following tests were modified with the addition 
of a pragma elaborate statement and with the modification report PASS: 

C39005A CD7004C CD7005E CD7006E 

CC3126A was modified by inserting the initializing expression 
(others -> 'H')" into line numbered 117. With this modification, this 
test reports PASS. 

For this implementation CD2C11A and CD2C11B were modified by inserting 
the initialization 5.0" into variable W's declaration (note that W 

is declared along with one or two other variables in a single object 
declaration; the initialization is not needed for them, but does not 
affect their use). With this modification, these tests report PASS. 

The following 34 tests were split because syntax errors at one point 
resulted in the compiler not detecting other errors in the test: 


B28003A 

B28003C 

B2A003A 

B33201C 

B33202C 

B33203C 

B33301B 

B37106A 

B37201A 

B37301I 

B38003A 

B38003B 

B38009A 

B38009B 

B44001A 

B44004A 

B51001A 

B54A01L 

B91001H 

B95063A 

BB1006B 

BC1002A 

BC1102A 

BC1109A 

BC1109B 

BC1109C 

BC1109D 

BC1201F 

BC1201G 

BC1201H 

BC1201I 

BC1201J 

BC1201L 

BC3013A 



3.7 ADDITIONAL TESTING INFORMATION 
3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 
produced by the Ada/L, Version 2.0 (/N0_0PTIMIZE Option) compiler was 
submitted to the AVF by the applicant for review. Analysis of these 
results demonstrated that the compiler successfully passed all 
applicable tests, and the compiler exhibited the expected behavior on 
all inapplicable tests. 


3.7.2 Test Method 

Testing of the Ada/L, Version 2.0 (/N0_0PTIMIZE Option) compiler using 
ACVC Version 1.10 was conducted on-site by a validation team from the 
AVF. The configuration in which the testing was performed is described 
by the following designations of hardware and software components: 

Host computers: VAX 8550 and VAX 11/785 


3-7 







Host operating system: 
Target computer: 

Target operating system: 
Compiler: 

Linker: 

Importer: 

Exporter: 

Loader/Dovmloader: 
Runtime System: 


VMS , Version 5.1 
AN/UYK-43 
Bare machine 

Ada/L, Version 2.0 (/N0_0PTIMIZE 

Option) 

LNK_L 

IMP_L 

EXP_L 

PORTAL/43 

RTEXEC Version 2.0/RTLIB Version 2.0 


The host and target computers were linked via PORTAL/43 


A magnetic tape containing all tests except for withdrawn tests was 
taken on-site by the validation team for processing. Tests that make 
use of implementation-specific values were customized before being 
written to the magnetic tape. Tests requiring modifications during the 
prevalidation testing were modified on-site. 


TEST INFORMATION 

The contents of the magnetic tape were loaded directly onto the host 
computers. 

The ACVC Version 1.10 was compiled and linked on the host VAX 8550. All 
executable tests were transferred to the AN/UYK-43 using PORTAL/43 and 
were run on the AN/UYK-43. Results were uploaded from the target system 
to the VAX 8550 stored on disk and printed. 

The ACVC Version 1.10 was compiled and linked on the host VAX 11/785. 
All executable tests were transferred to the AN/UYK-43 using PORTAL/43 
and were run on the AN/UYK-43. Results were uploaded from the target 
system to the VAX 11/785 stored on disk and printed. 

The compiler was tested using command scripts provided by U.S. NAVY and 
reviewed by the validation team. See Appendix E for a complete listing 
of the compiler options for this implementation. The compiler options 
invoked during this test were: 

For A, C, D, L Tests: 

/SUMMARY /N0_0PTIMIZE /SOURCE 

For B, E Tests: 

/SUMMARY /NO_OPTIMIZE /SOURCE 

Unless explicitly stated the following are the default options: 

N0_S0URCE , NO_MACHINE , N0_ATTRIBUTE , NO_CROSS_REFERENCE , 
NO_DIAGNOSTICS, NO_SUMMARY, N0_N0TES, PRIVATE, CONTAINER_GENERATION, 


3-8 








CODE_ON_WARNING, LIST, NO_MEASURE, DEBUG, NO_OPTIMIZE, CHECKS, 
NO_EXECUTIVE, NO_RTE_ONLY 

Tests were compiled, linked, and executed as appropriate using a single 
computer. Test output, compilation listings, and job logs were captured 
on magnetic tape and archived at the AVF. The listings were examined 
on-site by the validation team. 


3.7.3 Test Site 

Testing was conducted at Syscon Corporation, Washington, D.C. and was 
completed on 12-01-89. 


3-9 







APPENDIX A 


DECLARATION OF CONFORMANCE 


U.S. NAVY has submitted the following Declaration of Conformance 
concerning the Ada/L, Version 2.0 (/NO_OPTIMIZE Option). 


A-l 









DECLARATION OF CONFORMANCE 


Customer: U.S. NAVY 

Ada Validation Facility: 


Ada Validation Facility 
National Computer Systems Laboratory (NCSL) 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


Ada Compiler Validation Capability (ACVC) Version: 1.10 


Ada Implementation: 

Host Computer Systems: 
Host OS and Version: 
Target Computer System: 
Target OS and Version: 


Ada/L, Version 2.0 (/N0_0PTIMIZE Option) 

VAX 8550 and VAX 11/785 

VMS, Version 5.1 

AN/UYK-43 

Bare machine 


Customer’s Declaration 


I, the undersigned, representing U.S. NAVY, declare that the U.S. NAVY 
has no knowledge of deliberate deviations from the Ada Language Standard 
ANSI/MI^L-STD-ISISA in the implementation (s) listed in this declarations. 

Date 

Signature of: 




William L. Wilder, 
U.S. NAVY 







APPENDIX B 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of the Ada/L, Version 2.0 
(/NO_OPTIMIZE Option) compiler, as described in this Appendix, are 
provided by U.S. NAVY. Unless specifically noted otherwise, references 
in this appendix are to compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are not 
a part of Appendix F, are: 


package STANDARD is 


type INTEGER is range -2_147_483_647 .. 2_147_483_647; 
type LONG_INTEGER is range 

- 9_223_372_036_854_775_807 .. 9_223_372_036_854_775_807; 

type FLOAT is digits 6 range 

- (16#0.FF_FFF8#E63) .. (16#0.FF_FFF8#E6 3); 
type LONG_FLOAT is digits 1.5 range 

- (16#0.FF_FFFF_FFFF_FFE0#E63) .. (16#0.FF_FFFF_FFFF_FFE0#E6 3); 

type DURATION is delta 2.0 ** (-14) range 
-131 071.0 .. 131 071.0; 


end STANDARD; 


B-l 





Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


Section 6 

The Ada Language for the AN/UYK-43 


The source language accepted by the compiler is Ada, as 
described in the Military Standard, Ada Programming Language, 
ANSI/MIL-STD-1815A-1983, 17 February 1983 ("Ada Language 
Reference Manual"). 

The Ada definition permits certain implementation 
dependencies. Each Ada implementation is required to supply a 
complete description of its dependencies, to be thought of as 
Appendix F to the Ada Language Reference Manual. This section is 
that description for the AN/UYK-43 target. 


6.1 Options 

There are several compiler options provided by all ALS/N 
Compilers that directly affect the pragmas defined in the Ada 
Language Reference Manual. These compiler options currently 
include the CHECKS and OPTIMIZE options which affect the SUPPRESS 
and OPTIMIZE pragmas, respectively. A complete list of ALS/N 
Compiler options can be found in Section 10.2. 

The CHECKS option enables all run-time error checking for 
the source file being compiled, which can contain one or more 
compilation units. This allows the SUPPRESS pragma to be used in 
suppressing the run-time checks discussed in the Ada Language 
Reference Manual, but note that the SUPPRESS pragma(s) must be 
applied to each compilation unit. The NO CHECKS option disables 
all run-time error checking for all compiTation units within the 
source file and is equivalent to SUPPRESSing all run-time checks 
within every compilation unit. 

The OPTIMIZE option enables all compile-time optimizations 
for the source file being compiled, which can contain one or more 
compilation units. This allows the OPTIMIZE pragma to request 
either TIME-oriented or SPACE-oriented optimizations be 
performed, but note that the OPTIMIZE pragma must be applied to 
each compilation unit. If the OPTIMIZE pragma is not present, 
the ALS/N Compiler's Global Optimizer tends to optimize for TIME 
over SPACE. The NO_OPTIMIZE option disables all compile-time 
optimizations for all compilation units within the source file 
regardless of whether or not the OPTIMIZE pragma is present. 

In addition to those compiler options normally provided by 
the ALS/N Common Ada Baseline compilers, the Ada/L compiler also 
implements the EXECUTIVE, DEBUG, and MEASURE options. 

The EXECUTIVE compiler option shall enable processing of the 


6.1 Options 


6-01 





Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


EXECUTIVE pragma. The EXECUTIVE compiler option also allows WITH 
of units compiled with the RTE_ONLY option. If NONEXECUTIVE is 
specified on the command line, the pragma will be Ignored and 
will have no effect on the generated code. 

The DEBUG compiler option shall enable processing of the 
pragma DEBUG to provide debugging support. If NO_DEBUG is 
specified, the DEBUG pragmas shall have no effect. Program units 
containing DEBUG pragmas and compiled with the DEBUG compiler 
option may be linked with program units containing DEBUG pragmas 
and compiled with the NO_DEBUG option; only those program units 
compiled with the DEBUG option shall have additional DEBUG 
support. 

The MEASURE compiler option shall enable processing of the 
pragma MEASURE to provide debugging support. If NO_MEASURE is 
specified, the MEASURE pragmas shall have no effect. Program 
units containing MEASURE pragmas and compiled with the MEASURE 
compiler option may be linked with program units containing 
MEASURE pragmas and compiled with the NO_MEASURE option; only 
those program units compiled with the MEASURE option shall have 
additional MEASURE support. 


6-02 


6.1 Options 






Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.2 P ragmas 

These paragraphs describe the pragmas recognized and 
processed by the Ada/L compiler. The syntax defined in Section 
2.8 of the Ada Language Reference Manual allows a pragma as the 
only element in a compilation unit, before a compilation unit, at 
defined places within a compilation unit, or following a 
compilation unit. Ada/L associates pragmas with compilation 
units as follows: 

a. If a pragma appears before any compilation unit in a 
compilation, it will affect all following compilation 
units, as specified below and in section 2.8 of the 
Ada Language Reference Manual. 

b. If a pragma appears inside a compilation unit, it 
will be associated with that compilation unit, and 
with the listings associated with that compilation 
unit, as described in the Ada Language Reference 
Manual, or below. 

c. If a pragma follows a compilation unit, it will be 
associated with the preceding compilation unit, and 
effects of the pragma will be found in the container 
of that compilation unit and in the listings 
associated with that container. 


6.2.1 Language-Defined Pragmas 

This paragraph specifies implementation-specific changes to 
those pragmas described in Appendix B of the Ada Language 
Reference Manual. Unmentioned pragmas are implemented as defined 
in the Ada Language Reference Manual. 

The pragmas MEMORY_SIZE (arg), STORAGE_UNlT (arg), and 
SYSTEM_NAME (arg) must appear at the start of the first 
compilation when creating a program library, as opposed to the 
start of any compilation unit. If they appear elsewhere, a 
diagnostic of severity WARNING is generated and the pragma has no 
effect. 

pragma INLINE (arg {,arg,...}); 

The arguments designate subprograms. There are three I 
instances in which the INLINE pragma is ignored. Each 
of these cases produces a warning message which states 
that the INLINE did not occur. 

a. If a call to an INLINEd subprogram is 
compiled before the actual body of the 
subprogram has been compiled (a routine 
call is made instead). 


6.2.1 Language-Defined Pragmas 


6-03 









Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


b. If the INLINEd subprograms compilation unit 
depends on the compilation unit of its 
caller (a routine call is made instead). 

c. If an immediately recursive subprogram call 
is made within the body of the INLINEd 
subprogram (the pragma INLINE is ignored 
entirely). 

pragma INTERFACE (arg, arg); 

The first argument specifies the language and type of 
interface to be used in calls used to the externally 
supplied subprogram, specified by the second argument. 
The allowed values for the first argument (language 
name) are MACRO_NORMAL and MACRO_QUICK. MACRO_NORMAL 
indicates that parameters will be passed on the stack 
and the calling conventions used for normal Ada 
subprogram calls (see Section 3.4.14.2 of 
Ada/L_Intf^Spec]) will apply. MACRO_QUICK is used in 
RTLIB routines to indicate that parameters are passed 
in registers. See Section 7.7 for details on the space 
required to pass various types of parameters. 

The user must ensure that an assembly-language body 
container will exist in the library before linking. 

pragma OPTIMIZE (arg); 

The argument is either TIME or SPACE. The default is 
SPACE. This pragma will be effective only when the 
OPTIMIZE option has been given to the compiler, as 
described in Appendix 20 of [ ALS/N_Spec]. 

pragma PRIORITY (arg); 

The argument is an integer static expression in the 
range 0..15, where 0 is the lowest use-specifiable task 
priority and IS is the highest. If the value of the 
argument is out of range, the pragma will have no 
effect other than to generate a WARNING diagnostic. A 
value of zero will be used if priority is not defined. 
The pragma will have no effect when not specified in a 
task (type) specification or the outermost declarative 
I part of a subprogram. If the pragma appears in the 
I declarative part of a subprogram, it will have no 

effect unless that subprogram is designated as the main 
subprogram at link time. 

pragma SUPPRESS (arg {,arg}); 

This pragma is unchanged with the following exceptions: 


6-04 


6.2.1 Language-Defined Pragmas 







Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


Suppression of OVERFLOW_CHECK applies only to integer 
operations; and a SUPPRESS pragma has effect only 
within the compilation unit in which it appears, except 
that suppression of ELABORATION_CHECK applied at the 
declaration of a subprogram or task unit applies to all 
calls or activations. 


6.2.2 Implementation-Defined Pragmas 

This paragraph describes the use and meaning of those 
pragmas recognized by Ada/L which are not specified in Appendix B 
of the Ada Language Reference Manual. 

pragma DEBUG; 

To be supplied. 

pragma EXECUTIVE [(arg)]; 

This pragma allows the user to specify that a I 

compilation unit is to run in the executive state of i 
the machine and/or utilize privileged instructions. I 

The pragma has no effect if the Compiler option j 

NO EXECUTIVE is enabled, either explicitly or by | 

default. I 

If PRAGMA EXECUTIVE is specified without an argument, | 

executive state is in effect for the compilation unit ! 

and the code generator does not generate privileged ! 

instructions for the compilation unit. If PRAGMA ! 

EXECUTIVE (INHERIT) is specified, a subprogram in the | 

compilation unit inherits the state of its caller and j 

the code generator does not generate privileged j 

instructions for the compilation unit. If PRAGMA ! 

EXECUTIVE (PRIVILEGED) is specified, the executive I 

state is in effect and the code generator may generate I 
privileged instructions for the compilation unit. I 

Currently, the Ada/L compiler does not generate such ! 
instructions. In the absence of PRAGMA EXECUTIVE, the I 
compilation unit executes in task state and the code ! 
generator does not generate privileged instructions. I 

If PRAGMA EXECUTIVE (INTERRUPT_CMR) is specified, the j 
Ada/L compiler generates code which uses executive I 

state registers instead of task state registers (i.e. I 
SCI instead of SCT). I 

PRAGMA EXECUTIVE is applied once per compilation unit, I 
so its scope is the entire compilation unit. PRAGMA I 
EXECUTIVE may appear between the context clause and the I 
outermost unit. If there is no context clause, the I 
pragma EXECUTIVE must appear within that unit before I 
the first declaration or statement. The placement of | 


6.2.2 Implementation-Defined Pragmas 


6-05 





Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


! the pragma before the context clause has no effect on 
i any or all following compilation units. If PRAGMA 
I EXECUTIVE appears in the specification of a compilation 
! unit, it must also appear in the body of that unit, and 
I vice versa. If the pragma appears in a specification 
I but is absent from the body, the user is warned and the 
I pragma is effective. If the pragma appears in the body 
I of a compilation unit, but is absent from the 
I corresponding specification, the user is warned and the 
I pragma has no effect. PRAGMA EXECUTIVE does not 
I propagate to subunits. If a subunit is compiled 
j without PRAGMA EXECUTIVE and the parent of the subunit 
j is compiled with PRAGMA EXECUTIVE, the user is warned 
j and PRAGMA EXECUTIVE has no effect on the subunit. 

pragma FAST_INTERRUPT_ENTRY (argl, arg2); 

I To be supplied. 

pragma MEASURE (extraction_set, [arg,...]); 

To be supplied. 

pragma STATIC; 

To be supplied. 

pragma TITLE (arg); 

This is a listing control pragma. It takes a single 
argument of type string. The string specified will 
appear on the second line of each page of every listing 
produced for the compilation unit. At most one such 
pragma may appear for any compilation unit, and it must 
be the first lexical unit in the compilation unit 
(excluding comments). 

pragma TRIVIAL_ENTRY (NAME: entry_simple_name); 

To be supplied 

pragma UNMAPPED (arg [arg,...]); 

The effect of this pragma is for unmapped (i.e., not 
consistently mapped within the virtual space) 
allocation of data in a compilation unit. The 
arguments of this pragma are access types to be 
unmapped. If a program tries to allocate more UNMAPPED 
space than is available in the physical configuration, 
then STORAGE_ERROR will be raised at run-time. Pragma 
UNMAPPED must appear in the same declarative region as 
the type and after the type declaration. 


6-06 


6.2.2 Implementation-Defined Pragmas 








Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.2.3 Scope of Pragmas 

The scope for each pragma previously described as differing 
from the Ada Language Reference Manual is given below: 


DEBUG 


EXECUTIVE 


body, 


To be supplied. 

Applies to the compilation unit in which the pragma 
appears, i.e., to all subprograms and tasks within 
the unit. Elaboration code is not affected. 

The pragma is not propagated from specifications 
to bodies, or from bodies to subunits. The pragma 
must appear consistently in the specification, 

and subunits associated with a library unit. 


FAST_INTERRUPTJENTRY 

To be supplied. 


INLINE 


INTERFACE 


MEASURE 


MEMORY SIZE 


OPTIMIZE 


PRIORITY 


STATIC 


Applies only to subprogram names in its 
arguments. If the argument is an overloaded 
subprogram name, the INLINE pragma applies to 
all definitions of that subprogram name which 
appear in the same declarative part as the 
INLINE pragma. 

Applies to all invocations of the named 
imported subprogram. 

To be supplied. 

Applies to the entire Program Library in 
which the pragma appears. 

Applies to the entire compilation unit in 
which the pragma appears. 

Applies to the task specification in which it 
appears, or to the environment task if it 
appears in the main subprogram. 

To be supplied. 


STORAGE_UNIT Applies to the entire Program Library in 
which the pragma appears. 


SYSTEM NAME 


SUPPRESS 


Applies to the entire Program Library in 
which the pragma appears. 

Applies to the block or body that contains 
the declarative part in which the pragma 
appears. 


6.2.3 Scope of Pragmas 


6-07 











Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


TITLE 

TRIVIAL_ENTRY 

UNMAPPED 


Applies to the compilation unit in 
which the pragma appears. 

To be supplied. 

Applies to all objects of the access type 
named as arguments. 


6-08 


6.2.3 Scope of Pragmas 









Ada/L PSE Handbook Version 2.0C 

30 September 1989 


6.3 Attributes 

There is an implementation-defined attribute in addition to 
the predefined attributes found in Appendix A of the Ada Language 
Reference Manual. 

p'PHYSICAL_ADDRESS for a prefix p that denotes a data 
object: 

Yields a value of type system.physical_address, which corresponds 
to the absolute address in physical memory of the object named by 
p. This attribute is used to support operations associated with 
the pragma UNMAPPED. 

The following notes augment the language-required 
definitions of the predefined attributes found in Appendix A of 
the Ada Language Reference Manual. 


T’MACHINE_EMAX is 63. 

T*MACHINE_EMIN is -64. 

T’MACHINE_MANTISSA is 6. 

T'MACEINE_OVERFLOWS is TRUE. 

T'MACHINE_RADIX is 16. 

T*MACHINE ROUNDS is FALSE. 


6.3 Attributes 


6-09 



Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


6.4 Predefined Language Environment 

I The predefined Ada language environment consists of the 

I packages STANDARD and SYSTEM, which are described below. 


6.4.1 Package STANDARD 

The package STANDARD contains the following definitions in 
addition to those specified in Appendix C of the Ada Language 
Reference Manual. 

PACKAGE STANDARD IS 

TYPE boolean IS (false, true); 

— The type universal_integer is predefined. 

TYPE integer IS RANGE -2_147_483 647 .. 2_147_483_647; 

-(2**31 - 1) .. (2**31 - 1) 

TYPE long_integer IS RANGE 

-9_223_372_036_854_775_807 .. 9_223_372_036_854_775_807; 

TYPE float IS DIGITS 6 RANGE 

-(16#0.FF_FFF8#E63) .. (16 # 0.FF_FFF8#E63); 

TYPE long_float IS DIGITS 15 RANGE 

-(16#0.FF_FFFF FFFF_FFE0#E63) .. 
(16#0.FF_FFFF”FFFF_FFE0#E63); 

— Predefined subtypes; 

SUBTYPE natural IS integer RANGE 0 .. integer'LAST; 

SUBTYPE positive IS integer RANGE 1 .. integer'LAST; 

— Predefined string type; 

TYPE string IS ARRAY (positive RANGE <>) OF character; 

PRAGMA PACK(string); 

TYPE duration IS DELTA 2.0 ** (-14)’ 

RANGE -131 071.0 .. 131 071.0; 

— (2**17 - 1) 


- The predefined exceptions; 


constraint_error 

numeric__error 

program~error 

storage~error 

;asking“error 


exception; 

exception; 

exception; 

exception; 

exception; 


6-10 


6.4.1 Package STANDARD 










Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


END STANDARD; 


6.4.2 Package SYSTEM 

The package SYSTEM for Ada/L is as follows: 

PACKAGE SYSTEM IS 

memory_size : CONSTANT := 1_048_576; 

-- 2**20 

— virtual memory size (not configurable). 

TYPE address IS RANGE 0..system.memory_size - 1; 

— virtual address. 

TYPE name IS (anuyk43); 

— only one compatible system name. 

system_name : CONSTANT system.name := system.anuyk43; 

— name of current system. 

storage_unit : CONSTANT := 32; 

— word-oriented system (not configurable) 

— System Dependent Named Numbers 

min_int : CONSTANT := -((2**63)-l); 

— most negative integer. 

max_int : CONSTANT := (2**63)-l; 

— most positive integer. 

max_digits ; CONSTANT := 15; — 15 with long_float 

— most decimal digits in floating point constraint. 

max_mantissa : CONSTANT := 31; 

— most binary digits for fixed point subtype. 

fine_delta : CONSTANT 

2#0.0000_0000 0000J3000_0000J)000J)000_001#; 

— 2**(-31)“is minimum fixed point constraint. 

tick : CONSTANT := 4.8828125e-05; 

— 1/20480 seconds is the basic clock period. 

— FOR address'SIZE USE 32; 

— virtual address is a 32-bit quantity. 

null_addr : CONSTANT address := 0; 

~ Indicates a NULL address. 


6.4.2 Package SYSTEM 


6-11 







Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


— Address clause (interrupt) addresses 

Class I CJnhandled address : CONSTANT 

address : = 1610800#; 

Class II Unhandled address : CONSTANT 

~ _ address := 16#1800#; 

CP Operand Memory_Resume address ; CONSTANT 

address := 1611000#; 

CP IOC Command Resume address : CONSTANT 

address := 16#1100#; 

CP Instruction Memory_Resume_address : CONSTANT 

address := 16#1200#; 

CP IOC Interrupt Code Resume address : CONSTANT 

“ ~ ~ address := 16#1300#; 

CP Operand Memory Error address : CONSTANT 

* address ;= 16#1400#; 

CP Instruction Memory Error address : CONSTANT 

~ address := 16#1500#; 

CP IOC Command Operand Error address : CONSTANT 

~ ~ “ ” address :* 16#1600#; 

IOC Memory Error address : CONSTANT 

~ address := 16#1700#; 

IPI Fault address : CONSTANT 

address := 16#1900#; 

IOC_Memory_Resume_address : CONSTANT 

address := 16#1A00#; 

Intercomputer Timeout address : CONSTANT 

address : s 16#1B00#; 

Confidence Test Fault address : CONSTANT 

address : s 16#1C00#; 

CPU IOC Microprocessor Stop address ; CONSTANT 

address ;= 16#1D00#; 

Module Interrupt_address : CONSTANT 

address ;® 16#1E00#; 

Power Tolerance Interrupt address : CONSTANT 

~ address ;* 16#1F00#; 


6-12 


6.4.2 Package SYSTEM 






Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


Class III Unhandled_address : CONSTANT 

address := 16#2800#; 

CP Illegal Instruction_Error_address : CONSTANT 

address := 16#22Q0#; 

Privileged Instruction Error_address : CONSTANT 

address := 1612300#; 

Data Pattern Breakpoint address : CONSTANT 

~ address := 16#2400#; 

Operand Breakpoint Match address ; CONSTANT 

~ address := 16#2500#; 

Operand Read address : CONSTANT 

address := 16#2600#; 

DCU Status Interrupt address : CONSTANT 

" ~ address := 16#2700#; 

Operand Write Protection address : CONSTANT 

address := 1612900#; 

Operand Limit Protection address : CONSTANT 

~ address ;= 16#2A00#; 

Instruction Breakpoint Match address : CONSTANT 

address := 16#2B00#; 

RPD Underflow address : CONSTANT 

address := 16#2C00#; 

Instruction Execute Protection address : CONSTANT 

~ ” address := 16#2D00#; 

Instruction Limit Protection address : CONSTANT 

address : s 16I2E00#; 

Precisly Timed Interrupts address : CONSTANT 

address 16#2F00#; 


I/O Interrupts 

User should program 

FOR entry-name USE AT system.address_of( 
interrupt=>interrupt_name, 
£or_channel=>channel“number); 

e. g. 

USE system; 

• • 

FOR el USE AT address_of(ioc_cp_interrupt, 

for”channel=>5); 


6.4.2 Package SYSTEM 


6-13 






Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


Note that if the user wants to register for the 
IOC_Illegal_CAR_Instruction interrupt, where only the 
IOC~is to be specified, for_channel should be either 0 
or 32. 


(Declaration of FUNCTION address of is found below) 


IOC_Illegal_CAR_Instruction 
IOC_Memory_Protection 
IOC_ChanneT_Function_Error 
IOC_Illegal_Chain_Instruction 
IOC_Confidence_Test_Fault 
IOC_Breakpoint_Match 
IOC_CP_Inte r rupt 
IOC_External_Interrupt_Monitor 
10C_External_Function_Monitor 
10C_0utput_Data_Monitor 
IOC~Input_Data_Monitor 


CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 
CONSTANT address 


16#3000# 

1613100# 

16#3300# 

16#3400# 

16#3800# 

16#3900# 

16I3B00# 

16#3C00# 

16I3D00# 

16#3E00# 

16#3F00# 


SUBTYPE IO_interrupts IS address RANGE 

IOC_Illegal CAR_Instruction..IOC_Input_Data_Monitor; 
SUBTYPE channel numbers IS INTEGER RANGE 0..63; 


physical_memory_size : CONSTANT := 2**31; 

— maximum physical memory size (not configurable) 

TYPE physical_address IS 

RANGE 0..system.physical_memory_size - 1 ; 

— absolute address. 


null_phys addr j CONSTANT physical address := 0; 

— Indicates a NULL physical address. 

TYPE word IS NEW INTEGER; 

— objects of this type occupy one target_computer 

— word *32 bits on the AN/UYK-43). 

— UNCHECKEDJZONVERSION must be used to interpret 

— the value for an object of this type from Ada. 

SUBTYPE priority IS integer RANGE 0..15; 

— task priority, lowest = default = 0. 

TYPE entry_kind is (normal, immediate); 

— enumeration type for use with 
— PRAGMA INTERRUPT HANDLER TASK. 


— The following exceptions are provided as a "convention" 

— whereby the Ada program can be compiled with all implicit 

— checks suppressed (i.e. pragma SUPPRESS or equivalent), 

— explicit checks included as necessary, the appropriate 

— exception raised when required, and then the exception is 


6-14 


6.4.2 Package SYSTEM 







Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


— either handled or the Ada program terminates. 

ACCESS_CHECK : EXCEPTION; 

DISCRIMINANT_CHECK : EXCEPTION; 

INDEX_CHECK : EXCEPTION; 

LENGTH CHECK : EXCEPTION; 

RANGE CHECK : EXCEPTION; 

DIVISION CHECK : EXCEPTION; 

OVERFLOW~CHECK : EXCEPTION; 

ELABORATION_CHECK : EXCEPTION; 

STORAGE_CHECK : EXCEPTION; 

— implementation-defined exceptions. 

UNRESOLVED_REFERENCE : EXCEPTION; 

SYSTEM_ERROR : EXCEPTION; 

CAPACITY_ERROR : EXCEPTION; 

— The exception CAPACITY_ERROR is raised by the RTExec when 

— Pre-RunTime specified 7esource limits are exceeded. 


FUNCTION ADDRESS_OF 

— returns the system.address of the given Class III 

— interrupt for the specified channel 
(interrupt : IN IO_interrupts; 

— The name of the interrupt 
for_channel : IN channel__numbers 

— The channel number. 

) RETURN address; 

— The address to be used in the 
— representation (address) clause. 

PRAGMA INTERFACE (MACRO NORMAL,ADDRESS_OF); 


FUNCTION "AND" 

— returns the logical 32 bit 'AND' between two integers. 

(operand_a : IN integer; — The first operand. 

operand_b ; IN integer — The second operand 

) RETURN~integer; — The results. 

PRAGMA INTERFACE {MACRO_NORMAL, "AND"); 

FUNCTION "NOT" 

— returns the logical 32 bit 'NOT' of an integer. 
(operand_a : IN integer — The first operand. 

) RETURN~integer; — The results. 

PRAGMA INTERFACE (MACRO_NORMAL , "NOT"); 

FUNCTION "OR" 

— returns the logical 32 bit 'OR' between two integers. 

(operand_a : IN integer; — The first operand. 

operand”b : IN integer — The second operand 


6.4.2 Package SYSTEM 


6-15 








Version 2.0C Ada/L PSE Handbook 

30 September 1989 

I ) RETURN integer; — The results. 

| PRAGMA INTERFACE (MACRO_NORMAL , "OR"); 

I END SYSTEM; 


6-16 


6.4.2 Package SYSTEM 







Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.5 Character Set 

Ada compilations may be expressed using the following 
characters'in addition to the basic character set: 

lower case letters: 

abcdefghijklmnopqrstuvwxyz 
special characters: 

!$?@[/j~{}~ (accent grave) % 


6.5 Character Set 


6-17 





Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


6.6 Representation apd Declaration Restrictions 

Representation specifications are described in Section 13 of 
the Ada Language Reference Manual. Declarations are described in 
Section 3 of the Ada Language Reference Manual. 

In the following specifications, the capitalized word SIZE 
indicates the number of bits used to represent an object of the 
type under discussion. The upper case symbols D, L, R, 
correspond to those discussed in Section 3.5.9 of the Ada 
Language Reference Manual. 


6.6.1 Integer Types 

Integer types are specified with constraints of the form 
RANGE L..R 

where 

R <= system.max_int & L >= system.min_int 

For a prefix "t" denoting an integer type, length specifications 
of the form 

FOR t 1 SIZE USE n ; 

may specify integer values n such that 
n in 2..64, 
and such that 

R <= 2**(n-l)-l & L >* -(2**(n-l)-l) 
or else such that 

R <= (2**n)-l & L >= 0 

and 

1 < n <* 15 

For a stand-alone object of integer type, a default SIZE of 32 is 
I used when: 

| r <= 2**31 - 1 & L >* -(2**31 - 1) 

I Otherwise, a SIZE of 64 is used. 

For components of integer types within packed composite 


6-18 


6.6.1 Integer Types 





Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


objects, the smaller of the default stand-alone SIZE and the SIZE 
from a length specification is used. 


6.6.2 Floating Types 

Floating types are specified with constraints of the form: 
DIGITS D 

where D is an integer in the range 1 through 15. 

For a prefix "t" denoting a floating point type, length 

specifications 

of the form: 

FOR t 1 SIZE USE n; 

are permitted only when the integer value n = 32 for D <= 6 or 
N = 64 for 7 <= D <= 15. 


6.6.3 Fixed Types 

Fixed types are specified with constraints of the form 
DELTA D RANGE L..R 


where 


MAX (ABS(R), ABS(L)) 

- <= 2**31 - 1. 

actual delta 

The actual delta defaults to the largest integral power of 2 less 
than or equal to the specified delta D. (This implies that fixed 
values are stored right-aligned.) For specifications of the form 

FOR t'SMALL USE n; 

n must be specified as an integral power of 2 such that n <= D. 

For a prefix "t" denoting a fixed point type, length 
specifications of the form 

FOR t'SIZE USE n; 

are permitted only when n = 32. All fixed values have SIZE = 32. 


6.6.4 Enumeration Types 

In the absence of a representation specification for an 


6.6.4 Enumeration Types 


6-19 





Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


enumeration type "t", the internal representation of t'FIRST is 
0. The default size for a stand-alone object of enumeration type 
"t" is 32, so the internal representations of t'FIRST and t 1 LAST 
I both fall within the range: 

| -(2**31 - 1) .. 2**31 - 1. 

I For enumeration types, length specifications of the form 
| FOR t 1 SIZE USE n; 

I and/or enumeration representations of the form 
| FOR t USE <aggregate>; 

I are permitted for n in 2..32, provided the representations and 
| the SIZE 

I conform to the relationship specified above, or else for n in 
I 1..32, 

j is supported for enumeration types and provides an internal 
I representation of: 

| t'FIRST >= 0 .. t'LAST <= 2**(t'SIZE) - 1. 


For components of enumeration types within packed composite 
objects, the smaller of the default stand-alone SIZE or the SIZE 
from a length specification is used. 

Enumeration representations for types derived from the 
predefined type standard.boolean will not be accepted, but length 
specifications will be accepted. 


6.6.5 Access Types 

For access type, ”t H , length specifications of the form: 

FOR t'SIZE USE n; 

will not affect the runtime implementation of "t M , therefore n - 
32 is the only value permitted for SIZE, which is the value 
returned by the attribute. 

For collection size specifications of the form: 

FOR t’STORAGE_SIZE USE n; 

for any value of ”n" is permitted for STORAGE_SIZE (and that 
value will be returned by the attribute call)7 The collection 
size specification will affect the implementation of "t M and its 
collection at runtime by limiting the number of objects for type 
"t" that can be allocated. 


6-20 


6.6.5 Access Types 





Ada/L PSE Handbook 


Version 2.QC 
30 September 1989 


The value of t' STORAGE__SIZE for an access type "t" specifies 
the maximum number of storage_units used for all objects in the 
collection for type *• t*'. This includes all space used by the 
allocated objects, plus any additional storage required to 
maintain the collection. 


6.6.6 Arrays and Records 

For arrays and records, a length specification of the form 
FOR t'size USE n; 

is not allowed unless it is the default size. 

The PACK pragma may be used to minimize wasted space between 
components of arrays and records. The pragma causes the type 
representation to be chosen such that the storage space 
requirements are minimized at the possible expense of data access 
time and code space. 

A record type representation specification is not allowed. 
For records, an alignment clause/of the form: 

AT MOD n 

specify alignments of 1 word (word alignment) or 2 words 
(doubleword alignment). 

If it is determinable at compile time that the SIZE of a 
record or array type or subtype is outside the range of 
standard.integer, a diagnostic of severity WARNING is generated. 
Declaration of such a type or subtype would raise NUMERIC_ERROR 
when elaborated. 


6.6.7 Other Length Specifications 

Length Specifications are discribed in Section 13.2 of the I 
Ada Language Reference Manual. I 

A length specification for a task type "t", of the form: I 

FOR t'STORAGE _SIZE use N; I 

specifies the number of system.storage_units that are allocated 
for the execution of each task object of type "t”. This includes 
the runtime stack for the task object but does not include 
objects allocated at runtime by the task object. 


6.6.7 Other Length Specifications 


6-21 






Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


6.7 System Generated Names 

I Refer to Section 13.7 of the Ada Language Reference Manual 

| and th-? section above on the Predefined Language Environment for 
j a discussion of package SYSTEM. 

I The system name is chosen based on the target(s) supported, 

j but it cannot be changed. In the case of Ada/L, the system name 
| is ANUYK43. 


6-22 


6.7 System Generated Names 






Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.8 Address Clauses 

Refer to Section 13.5 of the Ada Language Reference Manual 
for a description of address clauses. All rules and restrictions 
described there apply. In addition, the following restrictions 
apply. 

An address clause designates a single task entry only. The 
appearance of a data object, subprogram, package, or task unit 
name in an address clause is not allowed, and will result in the 
generation of a diagnostic of severity ERROR. 

An address clause may designate a single task entry. Such 
an address clause is allowed only within a task specification 
compiled with the EXECUTIVE compiler option. The meaningful 
values of the simple_expression are the allowable interrupt entry 
addresses as defined”in Table 6-1. The use of other values will | 
result in the raising of a PROGRAM__ERROR exception upon creation 
of the task. ~ 

If more than one task entry is equated to the same interrupt 
entry address, the most recently executed interrupt entry 
registration permanently overrides any previous registrations. 

At most one address clause is allowed for a single task 
entry. Specification of more than one interrupt address for a 
task entry is erroneous. 


6.8 Address Clauses 


6-23 







Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 



I --- --- I 


| Class I Unhandled Interrupt None 16*0800# 



Class II Unhandled Interrupt 
CP-Operand Memory Resume 
CP-IOC Command Resume 
CP-Instruction Memory Resume 
CP-IOC Interrupt Code Resume 
CP-Operand Memory Error 
CP-Instruction Memory Error 
CP-IOC Command/Operand Error 
IOC Memory Error 
IPI Fault 
IOC Memory Resume 
Intercomputer Timeout 
CP Confidence Test Fault 
CPU/IOC Microprocessor Stop 
Module Interrupt 
Power Tolerance 


None 16#1800# 
16#0# 16*1000* 
16*1# 16*1100# 
16*2# 16*1200# 
16*3# 16*1300# 
16*4# 16*1400# 
16*5# 16*1500# 
16*6# 16*1600# 
16*7# 16*1700# 
16*9# 16*1900# 
16#A# 16#1A00# 
16#B# 16#1B00# 
16#C# 16#1C00# 
16*0# 16#1D00# 
16#E# 16#1E00# 
16#F# 16#1F00# 


Table 6-la - Interrupt Entry Addresses 


6-24 


6.8 Address Clauses 















Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


j AN/UYK-43(V) Interrupt 

Summary 



1 Class 

II 




1 

ISC 

Interrupt 



1 Target-Computer Interrupt 

CODE 

Entry Address 

Registration 


| - *—-----—--- - 

1 

I Class III (Jnhandled Interrupt 

None 

16#2800# 


1 

1 

1 

1 Interprocessor Interrupt 

16#0# 

16#2000# 

UNDEFINABLE 

i 

I Floating Point Error 

16#1# 

16#2100# 

UNDEFINABLE 

1 

j Illegal Instruction 

16#2# 

16#2200# 


1 

j Privileged Instruction Error 

16#3# 

16#2300# 


1 

j Data Pattern Breakpoint 

1.6#4# 

1612400# 


1 

j Operand Address Breakpoint 

16#5# 

1612500# 


1 

I Operand Read or 




1 

j Indirect Addressing 

16#6* 

16#26GG# 

* 

1 

j DCU Status Interrupt 

16#7# 

16#2700# 


1 

j Operand Write 

16#9# 

16#2900# 


1 

j Operand Limit 

16#A# 

16#2A00# 


1 

j Instruction Address Breakpoint 

16#B# 

16#2B00# 


1 

j RPD Underflow 

16#C# 

16#2C00# 


1 

| Instruction Execute 

16#D# 

16#2D00# 


1 

j Instruction Limit 

16*E# 

16#2E00# 


1 

j Monitor Clock 

16#F# 

16#2F00# 

UNDEFINABLE 

1 

- + 


Table 6-lb - Interrupt Entry Addresses (Continued) 


6.8 Address Clauses 


6-25 













Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


AN/UYK-43(V) Interrupt Summary 


Class III 




ISC 

Interrupt 

Target-Computer 

Interrupt 

CODE 

Entry Address Registration 

IOC Illegal CAR 

Instruction 

16#0# 

1613010# 

IOC Memory Protection 

16#1# 

16#31IC# 


If the above interrupt is generated during CAR execution, no 
channel number is available. The interrupt will be 
translated to Class II Unhandled. 


UNDEFINED 16#2# 16#3200# UNDEFINABLE 

Channel Function Error 16#3# 16#33IC# 

IOC Illegal Chain Instruction 16#4#.. 16#34IC# 

16#7# 

IOC Confidence Test Fault 16#8# 16#38IC# 

If the above interrupt is generated during CAR execution, no 
channel number is available. The interrupt will be 
translated to Class II Unhandled. 

IOC Breakpoint Match 16#9# 16#39IC# 

If the above interrupt is generated during CAR execution, no 
channel number is available. The interrupt will be 
translated to Class II Unhandled. 

IOC Monitor Clock 16#A# 16#3AI0# UNDEFINABLE 

IOC Processor Interrupt 16#B# 16I3BIC# 

External Interrupt Monitor 16#C# 16#3CIC# 

External Function Monitor 16#D# 16#3DIC# 

output Data Monitor 16#E# 16I3EIC# 

Input Data Monitor 16#F# 16#3FIC# 

For class III interrupts, the following interpretations apply: 

IC *> IOC, channel number where 

16#00#..16I1F# indicates IOC 0, channel 16#00..16#1F#, 
16120#..16#3F# indicates IOC 1, channel 16#00..16#1F# 


Table 6-lc - Interrupt Entry Addresses (Continued) 


6-26 


6.8 Address Clauses 












Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.9 Unchecked Conversions 

Refer to Section 13.10.2 of the Ada Language Reference 
Manual for a description of UNCHECKED_CONVERSION. It is 
erroneous if the user written ada program performs 
CJNCHECKED_CONVERSION when the source and target objects have 
different sizes. 


6.9 Unchecked Conversions 


6-27 







Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


6.10 Restrictions on the Main Subprogram 

Refer to Section 10.1 (8) of the Ada Language Reference 
Manual for a description of the main subprogram. The subprogram 
designated as the main subprogram cannot have parameters. The 
designation as the main subprogram of a subprogram whose 
specification contains a formal_part results in a diagnostic of 
severity ERROR at link time. 

The main subprogram can be a function, but the return value 
will not be available upon completion of the main subprogram's 
execution. The main subprogram may not be an import unit. 


6-28 


6.10 Restrictions on the Main Subprogram 





Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.11 Input/Output 

Refer to Section 14 of the Ada Language Reference Manual for 
a discussion of Ada Input/Output and to Section 12 of the Ada/L 
Run Time Environment Handbook for more specifics on the Ada/L 
Input/Output subsystem. 

The Ada/L Input/Output subsystem provides the following 
packages to the user: TEXT_IO, SEQUENTIAL_IO, DIRECT_IO, and 
LOW_LEVEL_IO. These packages execute in the context of the 
user-written Ada program task making the I/O request. 
Consequently, all of the code that processes an I/O request on 
behalf of the user-written Ada program executes sequentially. 

The package IO_EXCEPTIONS defines all of the exceptions needed by 
the packages SEQUENTIAL_IO, DIRECT^IO, and TEXT_IO. The 
specification of this package is given in Section 14.5 of the Ada 
Language Reference Manual. This package is visible to all of the 
constituent packages of the Ada/L I/O subsystem so that 
appropriate exception handlers can be inserted. 

I/O in Ada/L is performed solely on external files. No 
allowance is provided in the I/O subsystem for memory resident 
files (i.e., files which do not reside on a peripheral device). 
This is true even in the case of temporary files. With the 
external files residing on the peripheral devices, Ada/L makes 
the further restriction on the number of files that may be open 
on an individual peripheral device. 

Section 14.1 of the Ada Language Reference Manual states 
that all I/O operations are expressed as operations on objects of 
some file type, rather than in terms of an external file. File 
objects are implemented in Ada/L as access objects which point to 
a data structure called the File Control Block (see Section 

3.1.2.11 of the (Ada/L_RTLIB PDS]). This File Control Block is 
defined internally to each of the high-level I/O packages; its 
purpose is to represent an external file. The File Control Block 
contains all of the I/O-specific information about an external 
file that is needed by the high-level I/O packages to accomplish 
requested I/O operations. 


6.11.1 Naming External Files 

The naming conventions for external files in Ada/L are of 
particular importance to the user. All of the system-dependent 
information needed by the I/O subsystem about an external file is 
contained in the file name. External files may be named using 
one of three file naming conventions: standard, temporary, and 
user-derived. 

a. Standard File Names: 

The standard external file naming convention used in 


6 . 11.1 


Naming External Files 


6-29 







Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


Ada/L identifies the specific location of the external 
file in terms of the physical device on which it is 
stored. For this reason, the user should be aware of the 
configuration of the peripheral devices on the AN/UYK-43 
at a particular user site. 

Standard file names consist of a six character 
prefix and a file name of up to twenty characters. The 
six character prefix has a predefined format. The first 
and second characters must be either "DK," "MT," or "TT," 
designating an AN/UYH-3(V) Recorder/Reproducer Set 
Magnetic Disk, the RD-358 Magnetic Tape Subsystem, or the 
AN/USQ-69 Data Terminal Set, respectively. 

The third and fourth characters specify the channel 
on which the peripheral device is connected. Since there 
are sixty-four channels on the AN/UYK-43, the values for 
the third and fourth positions must lie in the range "00" 
to "63." 

The range of values for the fifth position in the 
prefix (the unit number) depends upon the device 
specified by the characters in the first and second 
positions of the external file name. If the specified 
peripheral device is the AN/UYH-3 magnetic disk drive, 
then the character in the fifth position must be one of 
the characters "0," "1," "2," or "3." This value 
determines which of the four disk units available on the 
AN/OYH-3 is to be accessed. If the specified peripheral 
device is the RD-358 magnetic tape drive, the character 
in the fifth position must be one of the characters "0," 
"1," "2," or "3." This value determines which of the four 
tape units available on the RD-358 is to be accessed. If 
the specified peripheral device is the AN/USQ-69 
militarized display terminal, the character in the fifth 
position depends on the channel type. If the channel 
type is parallel then this character must be a ”0". This 
is the only allowable value for the unit number when the 
AN/USQ-69 is connected to a parallel I/O channel. This 
is because the AN/USQ-69 may have only one unit on a 
parallel channel. If the channel type is serial then the 
character in the fifth position must be one of the 
characters "0", "1", "2", "3", "4", "5", "6", "7", or "8" 
(the character "8" will be used to specify a broadcast 
mode transmission). The AN/USQ-69 allows up to eight 
terminals to be daisy chained together when running on a 
serial channel. 

The colon, is the only character allowed in the 

sixth position. If any character other than the colon is 
in this position, the file name will be considered 
non-standard and the file will reside on the default 
device defined during the elaboration of CONFIGURE_IO. 


6-30 


6.11.1 Naming External Files 









Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


Positions seven through twenty-six are optional to 
the user written Ada program and may be used as desired. 
These positions may contain any printable character the 
user chooses in order to make the file name more 
intelligible. Embedded blanks, however, are not allowed. 

The location of an external file on a peripheral 
device is thus a function of the first six characters of 
the file name regardless of the characters that might 
follow. For example, if the external file 
"MT000:01d_Data" has been created and not subsequently 
closed, an attempt to create the external file 
"MT000:New_Data" will cause the exception DEVICE_ERROR 
(rather than NAME_ERROR or USE_ERROR) to be raised 
because the peripheral device on channel "00" and 
cartridge "0" is already in use. 

The user is advised that any file name beginning 
with "xxxxx:" (where x denotes any printable character) 
is assumed to be a standard external file name. If this 
external file name does not conform to the Ada/L standard 
file naming conventions, the exception NAME_ERROR will be 
raised. 

b. Temporary File Names: 

Section 14.2.1 of the Ada Language Reference Manual 
defines a temporary file to be an external file that is 
not accessible after completion of the main subprogram. 

If the null string is supplied for the external file 
name, the external file is considered temporary. In this 
case, the high level I/O packages internally create an 
external file name to be used by the lower level I/O 
packages. The internal naming scheme used by the I/O 
subsystem is a function of the type of file to be created 
(text, direct or sequential) and the current date and 
time. This scheme is consistent with the requirement 
specified in the Ada Language Reference Manual that all 
external file names be unique. 

The first two characters of the file name are "TX," 
"D_," or "S_." The next eight characters are the date 
(four characters for the year, two characters for the 
month, and two characters for the day). The remaining 
ten characters are the time (five for seconds and five 
for the fraction part of a second). For instance, the 
temporary external file name "D_198803311234598765" would 
be a DIRECT^IO file created March 31, 1988 at 
12,345.9876? seconds. 

c. User-Derived File Names: 

A random string containing a sequence of characters 


6 . 11.1 


Naming External Files 


6-31 







Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


of length one to twenty may also be used to name an 
external file. External files with names of this nature 
are considered to be permanent external files. The user 
is cautioned to refrain from using names which conform to 
the scheme used by the I/O subsystem to name temporary 
external files (see list item "b."). 

It is not possible to associate two or more internal 
files with the same external file. The exception 
CJSE ERROR will be raised if this restriction is violated. 


6.11.2 The FORM Specification for External Files 

Section 14.2.1 of the Ada Language Reference Manual defines 
a string argument called the FORM, which supplies 
system-dependent information that is sometimes required to 
correctly process a request to create or open a file. In Ada/L, 
the string argument supplied to the FORM parameter on calls to 
CREATE and OPEN is retained while the file is open, so that calls 
to the function FORM can return the string to the user written 
Ada program. FORM options specified on calls to CREATE have the 
effects stated below. FORM options specified on calls to OPEN 
have no effect. 

Ada/L only allows a FORM parameter when a file is open or 
created on the RD-358 tape drive. A USE_ERROR will be raised 
when a FORM parameter is associated with“any other Ada/L system 
device. The FORM parameter specifically controls the positioning 
and formatting of the tape prior to tape I/O operations. This 
section identifies the arguments of the FORM parameter. Refer to 
Section 14.2.1 of the Ada Language Reference Manual and to 
Section 12.2.2 of the Ada/L Run Time Environment Handbook for 
more detail on the use of the FORM parameter. 

The FORM parameter is a string literal of which a maximum of 
twenty characters is processed. If the supplied FORM string is 
longer than the maximum allowed (20 characters), the exception 
USE_ERROR will be raised. The string literal is interpreted as a 
sequence of arguments. If the user wishes to utilize the default 
arguments, a FORM parameter need not be supplied. 

Only the first two arguments within the string are 
processed. All following characters or arguments will cause the 
USE_ERROR to be raised. The arguments are not case sensitive. 

The arguments must be separated by at least one delimiter. A 
legal delimiter consists of a comma or blank. Extra delimiters 
are ignored. Of the recognized arguments, at most one formatting 
and one positioning argument are allowed. If conflicting 
arguments are used, the exception USE_ERROR will be raised. 

Positioning arguments allow control of tape before its use. 
The following positioning arguments are available to the user: 


6-32 


6 . 11.2 





Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


a. REWIND - specifies that a rewind will be performed 
prior to the requested operation. 

b. NOREWIND - specifies that the tape remains positioned 
as is. 

c. APPEND - specifies that the tape be positioned at the 
logical end of tape (LEOT) prior to the requested 
operation. The LEOT is denoted by two consecutive 
tape_marks. 

The formatting argument specifies information about tape 
format. If a formatting argument is not supplied, the file is 
assumed to contain a format header record determined by the ALS/N 
I/O system. The following formatting argument is available to 
the user: 

a. NOHEAD - specifies that the designated file has no 
header record. This argument allows the reading and 
writing of tapes used on computer systems using 
different header formats. 


6.11.3 File Processing 

Processing allowed on Ada/L files is influenced by the 
characteristics of the underlying device. The following 
restrictions apply: 

a. . Only one file may be open on an individual RD-358 

tape drive at a time. 

b. The attempt to CREATE a file with the mode IN_FILE is 
not supported since there will be no data in the file 
to read. 


6.11.4 Text Input/Output 

TEXT_IO is invoked by the user-written Ada program to 
perform sequential access I/O operations on text files (i.e., 
files whose content is in human-readable form). TEXT_IO is not a 
generic package and, thus, its subprograms may be invoked 
directly from the user-written Ada program, using objects with 
base type or parent type in the language-defined type character. 
TEXT_IO also provides the generic packages INTEGER_IO, FLOAT_IO, 
FIXED^_IO, and ENUMERATION_IO for the reading and writing of 
numeric values and enumeration values. The generic packages 
within TEXT_IO require an instantiation for a given element type 
before any of their subprograms are invoked. The specification 
of this package is given in Section 14.3.10 of the Ada Language 
Reference Manual. 


6.11.4 Text Input/Output 


6-33 







Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


The implementation-defined type COUNT that appears in 
Section 14.3.10 of the Ada Language Reference Manual is defined 
as follows: 

type COUNT is range 0... INTEGER'LAST; 

The implementation-defined subtype FIELD that appears in Section 
14.3.10 of the Ada Language Reference Manual is defined as 
follows: 


subtype FIELD is INTEGER range 0...INTEGER*LAST; 

At the beginning of program execution, the STANDARD_INPUT 
file and the STANDARD_OUTPUT file are open, and associated with 
the files specified by the user at export time. Additionally, if 
a program terminates before an open file is closed (except for 
STANDARD_INPUT and STANDARD OUTPUT), then the last line which the 
user added to the file may Ee lost; if the file is on magnetic 
tape, the file structure on the tape may be inconsistent. 

A program is erroneous if concurrently executing tasks 
attempt to perform overlapping GET and/or PUT operations on the 
same terminal. The semantics of text layout as specified in the 
Ada Language Reference Manual, Section 14.3.2, (especially the 
concepts of current column number and current line) cannot be 
guaranteed when GET operations are interweaved with PUT 
operations. A program which relies on the semantics of text 
layout under those circumstances is erroneous. 

For TEXT_IO processing, the line length can be no longer 
than 1022 characters. An attempt to set the line length through 
SET_LINE_LENGTH to a length greater than 1022 will result in 
USE~ERROR. 


6.11.5 Sequential Input/Output 

SEQUENTIAL_IO is invoked by the user-written Ada program to 
perform I/O on the records of a file in sequential order. The 
SEQUENTIAL_IO package also requires a generic instantiation for a 
given element type before any of its subprograms may be invoked. 
Once the package SEQUENTIAL_IO is made visible, it will perform 
any service defined by the subprograms declared in its 
specification. The specification of this package is given in 
Section 14.2.3 of the Ada Language Reference Manual. 

The following restrictions are imposed on the use of the 
package SEQUENTIAL_IO: 

a. SEQUENTIAL IO must be instantiated for a constrained 
type. 

b. Ada/L does not raise DATA ERROR on a read operation 


6-34 


6.11.5 Sequential Input/Output 







Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


if the data input 
the instantiating 
Reference Manual, 


from the external file is not of 
type (see the Ada Language 
Section 14.2.2). 


6.11.6 Direct Input/Output 

DIRECT_IO is invoked by the user-written Ada program to 
perform I/O of the records of a file in an arbitrary order. The 
package DIRECT_IO requires a generic instantiation for a given 
element type before any of its subprograms may be invoked. Once 
the package DIRECT_IO is made visible, it will perform any 
service defined by the subprograms declared in its specification. 
The specification of this package is given in Section 14.2.5 of 
the Ada Language Reference Manual. 

The following restrictions are imposed on the use of the 
package DIRECT_IO: 

a. DIRECT_IO must be instantiated for a constrained 
type. 

b. Ada/L does not raise DATA_ERROR on a read operation 
if the data input from the external file is not of 
the instantiating type (see the Ada Language 
Reference Manual, Section 14.2.4). 


6.11.7 Low Level Input/Output 

LOW_LEVEL_IO is invoked by the user-written Ada program to 
initiate physical operations on peripheral devices, and thus 
executes as part of the user-written Ada program task. Requests 
made to LOW_LEVEL_IO from the user-written Ada program are passed 
through the RTEXEC_GATEWAY to the channel programs in CHANNEL_IO. 
Any status check or result information is the responsibility of 
the invoking subprogram and can be obtained from the subprogram 
RECEIVE_CONTROL within LOW_LEVEL_IO. 

The package LOW_LEVEL_IO allows the user written Ada program 
to send I/O commands to the I/O devices (using SEND_CONTROL) and 
to receive status information from the I/O devices (using 
RECEIVE_CONTROL). A program is erroneous if it uses LOW LEVEL_IO 
to access a device that is also accessed by high-level l7o 
packages such as SEQUENTIAL_IO and TEXT_IO. The following is 
excerpted from the package LOW_LEVEL__IO. 

PACKAGE LOW_LEVEL_IO IS 

SUBTYPE channel_range IS INTEGER RANGE 0..63; 

— Range of values allowed for channel number. 

SUBTYPE device str IS STRING; 


6.11.7 Low Level Input/Output 


6-35 





Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


— To be passed to CHANNEL_IO for future implementations 

— of logical path name. The string will be ignored until 

— logical path name support is added. 

SUBTYPE btc_int IS INTEGER RANGE 0..16383; 

— Passes transfer counts to/frora lO_MANAGEMENT/RTEXEC. 

SUBTYPE io functions IS INTEGER RANGE 0..20; 

— Specifies the I/O function to be performed by LOW^_LEVEL_IO. 

— The following table shows the values associated with device 

and 

— device functions available. 


—— 

VALUE 

— DEVICE 

— FUNCTION 

—— 

0 

RD-358 

Normal Read 

— 

1 

RD-358 

Read with Search data 

— 

2 

RD-358 

Normal Write 

— 

3 

RD-358 

Send EF Command 

—— 

4 

RD-358 

Initialize Channel 

—— 

0 

UYH-3 

Read with 2 word EF 

— 

1 

UYH-3 

Read with 1 word EF 

-- 

2 

UYH-3 

Write 

— 

3 

UYH-3 

Send 1 word EF Command 

— 

4 

UYH-3 

Send 2 word EF Command 

3) 

5 

UYH-3 

Send 1 word EF Command (Same as function 

6 

UYH-3 

Initialize Channel 


USQ-69 Read 

USQ-69 Write 

USQ-69 Write (Same as function 1) 

USQ-69 Send Command 

USQ-69 Initialize Channel 


I TYPE cap block IS 

I — Information that can be found in IOC control memory on 

I — a per channel/ per function basis. 

I RECORD 

I cap ; INTEGER; — CAP register. 

I instruct base ; INTEGER; — CAP instruction base. 

I index : INTEGER; — CAP index register. 

I accumulator : INTEGER; — CAP accumulator register. 

I status : INTEGER; — CAP status register. 

I buffer_base ; INTEGER; — CAP buffer base. 

I bcw ~ : INTEGER; — CAP buffer control word. 

I operand base : INTEGER; — CAP operand base. 

I END RECORD?. 

I TYPE short rec control block IS 



6-36 


6.11.7 Low Level Input/Output 











Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


— I/O control block sent to LOW_LEVEL_IO as a parameter 

— when calling subprogram RECEIVE_REQUEST. 

RECORD 

channel : low_level_io.channel_range; 

— Specifies channel of interest. 
ei_word : INTEGER; 

— External interrupt returned by the peripheral device. 
END RECORD; 

TYPE receive_control_block IS 

— I/O control block sent to LOW_LEVEL_IO as a parameter 

— when calling subprogram RECEIVE_REQUEST. 

RECORD 

data : low_level_io.short_rec_control_block; 

— Channel and eijword. — 
ef : low_level_io.cap_block; 

— External Function CAP information, 
output : low_level_io.cap block; 

— Output CAP information, 
ei ; low_level_io.cap_block; 

— External Interrupt CAP information, 
input : low_level io.cap_block; 

— Input CAP information. 

END RECORD; 

TYPE send_control_block IS 

~ I/O control block sent to LOW_LEVEL_IO as a parameter 

— when calling subprogram SEND REQUEST. 

RECORD 

functionjpos : low_level io.io_functions; 

— Indicates which I/O function is to be requested 

— of LOW_LEVEL_IO. 

channel ; low_level_io.channel_range; 

— Specifies channel number, 
transfer count ; low_level_io.btc int; 

— Buffer transfer count for l7o operation. 
buffer_addr : system.address; 

— Address of data buffer. 

command_l : INTEGER; 

— Holds the first word of the external 

— function for the device. 

command_2 : INTEGER; 

— Holds the second word of the external 

— function for the device. 

filler_l : INTEGER; 

— Passes additional information to 
— CHANNEL_IO (such as the terrainal_address 

— for the”USQ-69 device). 

END RECORD; 


PROCEDURE SENDJZONTROL 

— Passes I/O control information to a procedure in 


6.11.7 Low Level Input/Output 


6-37 







Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


— IO_MANAGEMENT/RTEXEC in order to send data to the 

— specified device. 

(device : IN low_level__io.device_str := ; 

— This string will be ignored until 
— logical path names are implemented, 
data : IN low_level_io.send_control block 

— I/O control block“for senU request. 

); 


PROCEDURE RECEIVE_CONTROL 

— Passes I/O control information to a procedure in 

— IO_MANAGEMENT/RTEXEC in order to obtain the status of 

— the I/O operation. 

(device : IN low_level io.device_str := 

— This stFing will be ignored until 
— logical path names are implemented, 
data : IN OUT low_level_io.receive_control_block 
— I/O control block for receive request. 

); 


PROCEDURE RECEIVE_CONTROL 

— Passes I/O control information to a procedure in 
— I0_MANAGEMENT/RTEXEC in order to obtain the status of 
— the I/O operation. 

(device : IN low_level io.device_str := M "; 

— This string wTll be ignored until 
— logical path names are implemented, 
data ; IN OUT low_level_io.short_rec control_block 
— I/O control block for receive request. 

); 

END LOW LEVEL 10; 


6-38 


6.11.7 


Low Level Input/Output 








Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.12 System Defined Exceptions 

In addition to the exceptions defined in the Ada Language 
Reference Manual, this implementation pre-defines the exceptions 
shown in Table 6-2. 


Name 

Significance 

UNRESOLVED_REFERENCE 

Attempted call to a routine not 
linked into the executable image. 

SYST£M_ERROR 

Serious error detected in underlying 
AN/UYK-43 operating system. 

CAPACITY_ERROR 

Raised by the RTEXEC when Pre-Runtime 
specified resource limits are 
exceeded. 

UNREGISTERED_PTI 

Raised by the PTI support package if 
the PTI's state is returned as 
"unregistered". 

PAST_PTI_TIME 

Raised by the PTI support package if 
the PTI start time is greater than the 
current calendar.CLOCK. 


Table 6-2a - System Defined Exceptions 


6.12 


System Defined Exceptions 


6-39 







Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


Name 

Significance 

ACCESS_CHECK 

The ACCESS_CHECK exception has been 
raised explicitly within the program. 

DISCRIMINANT_CHECK 

DISCRIMINANT_CHECK exception has been 
raised explicitly within the program. 

INDEX _CHECK 

The INDEX_CHECK exception has been 
raised explicitly within the program. 

LENGTH_CHECK 

The LENGTH_CHECK exception has been 
raised explicitly within the program. 

RANGE_CHECK 

The RANGE_CHECK exception has been 
raised explicitly within the program. 

DIVISION_CHECK 

The DIVISION_CHECK exception has been 
raised explicitly within the program. 

OVERFLOW_CHECK 

The OVERFLOW_CHECK exception has been 
raised explicitly within the program. 

ELABORATION_CHECK 

ELABORATION CHECK exception has been 
raised explicitly within the program. 

STORAGE_CHECK 

The STORAGE CHECK exception has been 
raised explicitly within the program. 


Table 6-2b - System Defined Exceptions (Continued) 


6-40 


6.12 System Defined Exceptions 









Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


6.13 Machine Code Insertions 


The Ada language permits machine code insertions as defined 
in Section 13.8 of the Ada Language Reference Manual. This 
section describes the specific details for writing machine code 
insertions as provided by the predefined package MACHINE_CODE. 

The Ada/L user may, if desired, include AN/UYK-43 
instructions within an Ada program. This is done by including a 
procedure in the program which contains only record aggregates 
defining machine instructions. The package MACHINE_CODE, 
included in the system program library, contains type, record, 
and constant declarations which are used to form the 
instructions. Each field of the aggregate contains a field of 
the resulting machine instruction. These fields are specified in 
the order in which they appear in the actual instruction. Since 
the AN/UYK-43 has several different formats for instructions, 
package MACHINE_CODE defines different types for each of these 
formats. For each of the fields which must have a certain value 
for a given instruction (i.e.,- part of the opcode), package 
MACHINE_CODE defines a constant to use for that field. 

The following procedure implements a floating point 
exponential. Note that this actual procedure would not be used, 
because package MATH_PACK implements the same operation in a more 
efficient manner. 

with machine_code; use machine_code; 

procedure floating_point_exponential 
(x : FLOAT; 
ex : OUT FLOAT) is 


BEGIN 

formatl'(f_LA,l,3,6,0,0,0); 

— LA A1,B6+0 

formatv'(f_FEX,l,f2_FEX,2,0,0,0,f6_FEX); 
— FEX A1,A2 


formatl'(f=>f_SA,a=>2,k=>3,b=>6,i=>0,s=>0,y=>l); 

— SA A2,B6+1 

END; 

Note that either positional or names aggregates may be used. 
Whenever a field does not appear in the MACRO/L instruction, it 
must be filled in with 0, since no missing fields are allowed. 

For formatl instructions, when k=0, the s and y field are 
collapsed and used together. For user convenience, an additional 
record type, formatli, for immediate, can be used to define the s 
and y fields as a single 16-bit quantity. This quantity is 
defined as an unsigned integer, so if a negative number x is 
desired, one should instead put the number x + 65535; 


6.13 Machine Code Insertions 


6-41 







Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


Table 6-3 contains a list of MACRO/L instructions and their 
Ada/L machine code equivalents, sorted by MACRO/L mnemonic. 


6-42 


6.13 Machine Code Insertions 







Ada/L PSC Handbook 


Version 2.0C 
30 September 1989 


+ 

I 

+ 


MACRO/L 

AA 

a,y,k,b,s 

AB 

a,y,k,b,s 

AEI 

a,sy,b 

ALP 

a,y,b,s 

ANA 

a,y,k,b,s 

ANB 

a,y,k,b,s 

ATSF 

a,b 

BC 

ak,y,b,s 

BS 

ak,y,b,s 

BZ 

ak,y,b,s 

C 

CB 

a,y,k,b,s 

CBN 

a,n 

CBR 

a,b 

CCT 

a,b 

CE 


CG 

a,y,k,b,s 

CHCL 

a,y,b,s 

CL 

a,y,k,b,s 

CM 

a,y,k,b,s 

CMPS 

a,b 

CNT 

a,y ,b,s 

CRB 

a,b 

CXI 

a,y,k,b,s 

D 

a,y,k,b,s 

DA 

a,y,b,s 

DAN 

a,y,b,s 

DC 

a,y ,b,s 

DJNZ 

a,y,k,b,s 

DJZ 

a,y,k,b,s 

DL 

a,y,b,s 

DS 

a,y ,b,s 

DSP 

EECM 

ESCM 

ETCM 

3 1 b f m 

FA 

a,y,b,s 

FAC 

a,b 

FAN 

a,y,b,s 

FANR 

a,y ,b,s 

FAR 

a,y,b,s 

FAS 

a,b 

FAT 

a,b 

FD 

a ,y, b, s 

FDR 

a,y,b,s 


Ada/L 


formatI'(f_AA,a,k,b,i,s,y); 

formatl'jf AB,a,k,b,i,s,y); 

formatli'(?_AEI,a,k_AEI,b,i,sy); 

formatl*(f_ALP,a,k_ALP,b,i,s,y); 

formatI'(f_ANA,a,k,b,i,s,y); 

formatI*(f_ANB,a,k,b,i,s,y); 

formatv'(f ATSF,a,f2_ATSF,b,0,0,0,f6_ATSF); 

formatla'(F_BC,a,k,b,i, s,y); 

formatla'(f_BS,a,k,b,i,s,y); 

formatla 1 {f_BZ,a,k,b,i,s,y); 

formatl’{f_C,a,k,b,i,s,y); 

formatIVA’(f_CB,a_CB,0,i_CB ); 

formative(f_CBN,a,f4_CBN,n); 

formatV’(f_CBR,a,f2_CBR,b,0,0,0,f6_CBR ); 

formatlVA’(f_CCT,a,b,i_CCT); 

formatIVA'(f_CE,a_CE,0,i_CE ); 

formatl’(f_CG,a,k,b,i,s,y); 

formatl’(f_CHCL,a,k_CHCL,b,i_CHCL,s,y); 

formatI'(f_CL,a,k,b,i,s,y); 

formatI'{f_CM,a,k,b,i,s,y); 

formatv *(f_CMPS,a,f2_CMPS,b,0,0,0,f6_CMPS ); 

formatl’(f“CNT,a,k_CNT r b,i,s,y); 

formatv’(f_CRB,a,f2_CRB,b,0,0,0,f6_CRB ); 

formatI’(f”CXI,a,k,b,i,s,y); 

formatI*(f“D,a,k,b,i,s,y); 

forraatl'(f~DA,a,k_DA,b,i,s,y); 

formatI'(f~DAN,a,k_DAN,b,i,s,y); 

forraatl'(f_DC,a,k DC,b,i,s,y); 

formatlll'(f_DJNZ7a,f3_DJNZ,k,b,i,s,y); 

format 111 1 (f_DJZ, a, f 3__DJZ ,k,b,i,s,y); 

formatI'(f_DL,a,k_DL,H,i,s,y); 
formatl’(f7DS,a,k~DS,b,i,s,y); 
formatv'{f DSP,a,F2 DSP,b,0,0,m,f6_DSP ); 
fo rraa tIVA'7f_EECM,a”EECM,0,i_EECM ); 
formatlVA'(f ESCM,a~ESCM,0,i_ESCM ); 
formatlVA'(f_ETCM,a“ETCM,0,i^ETCM ); 
forraatl’(f FA,a,k FA,b,i,s,y); 
formatv'(f7FAC,a,F2_FAC,b,0,0,0,f6_FAC ); 
formatI'(f7FAN,a,k_FAN,b,i,s,y); 
formatI’(f_FANR,a,k_FANR,b,i,s,y); 
forraatl'( f^FAR,a,k FAP.,b,i,s,y); 
formatv*(f FAS,a,fI FAS,b,0,0,0,f6_FAS ); 
formatv'{flFAT,a,f2"FAT,b,0,0,0,f6_FAT ); 
formatI'(f7FD,a,k_FD,b,i,s,y); 
format I'(f_FDR,a,k_FDR,b,i,s,y); 


Table 6-3a - Machine Code Instructions 


6.13 Machine Code Insertions 


6-43 












Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


MACRO/L 

Ada/L 

FEX 

a,b 

formatV'(f FEX,a,f2 FEX,b,0,0,0,f6 FEX ); 

FLN 

a,b 

formatV'(f“FLN,a,f2"FLN,b,0,0,0,f6~FLN ); 

FLTF 

a,n 

formatV'(f“FLTF,a,f2 FLTF,n,0,0,0,l6 FLTF); 

FM 

a,y,b,s 

formatl'(f“FM,a,k FM7b,i,s,y); 

FMR 

a,y,b,s 

formatl'(f“FMR,a,k FMR,b,i,s,y); 

FPA 

a,b 

formatV'(f“FPA,a,fI FPA,b,0,0,0,f6 FPA); 

FPD 

a,b 

formatV'(f“FPD,a,f2“FPD,b,0,0,0,f6 FPD); 

FPM 

a,b 

formatV'(f FPM,a,f2 FPM,b,0,0,0,f6 FPM ); 

FPS 

a,b 

formatV'(f“FPS,a,f2 FPS,b,0,0,0,f6 FPS ); 

FSA 

a,b 

formatV'(f FSA,a,f2 FSA,b,0,0,0,f6 FSA); 

FSC 

a,b 

formatV'(f FSC,a,f2 FSC,b,0,0,0,f6 FSC ); 

FSD 

a,b 

formatV'(f“FSD,a,f2 FSD,b,0,0,0,f6 FSD); 

FSM 

a,b 

formatV'(f“FSM,a,f2 FSM,b,0,0,0,f6 FSM); 
formatV'(f"FSS,a,f2 FSS,b,0,0,0,f6 FSS); 

FSS 

a, b 

FTSL 

a,b 

formatV'(f"FTSL,a,f2 FTSL,b,0,0,0,^6 FTSL); 

HA 

a,b 

formatIVA'(f HA,a,b,0); 

HAEI 
HA I 
HALT 

a,b 

formatIVA'(f“HAEI,a,b,i HAEI ); 
formatlVA'(f“HAI,0,0,0)7 
formatIVA'(f“HALT,0,0,i HALT ); 

HAN 

a,b 

formatIVA*(f“HAN,a,b,0)“ 

HAND 

a,b 

formatIVA'(f“HAND,a,b,i HAND ); 

HC 

a,b 

formatIVA'(f“HC,a,b,0)j“ 
formatIVA'(f“HCB,a,b,0); 

HCB 

a,b 

HCL 

a,b 

formatIVA'(f“HCL,a,b,0); 

HCM 

a,b 

formatIVA'(f“HCM,a,b,0); 
formatIVA'(f“HCP,a,0,0); 

HCP 

a 

HCRC 

a,b 

formatIVA•(f“HCRC,a,b,i HCRC ); 

HD 

a,b 

formatIVA'(f“HD,a,b,0); 

HDCP 

a 

formatIVA'(f“HDCP,a,0,0); 

HDLC 

a,m 

formatlVB’(f“HDLC,a,m); 

HDRS 

a,m 

formatIVB'(f“HDRS,a,m); 

HDRZ 

a,ra 

formatlVB'(f“HDRZ,a,m); 

HDSF 

a,b 

formatIVA'(f“HDSF,a,b,0); 

HLB 

a,b 

formatIVA'(f“HLB,a,b,0); 

HLC 

a,m 

formatlVB'{f~HLC,a,m); 

HLCA 

a,b 

formatIVA'(f“HLCA,a,b,i HLCA ); 

HLC I 

af 4,b 

formatIVA l'Tf HLCI,af4',b,i HLCI); 

HLCT 

af 4,b 

formatIVA“l'(f“HLCT,af4,b,i"HLCT); 

HLTC 

a,b 

formatIVA t (f HLTC,a,b,i HLTC ); 

HM 

a,b 

formatIVA'(f“HM,a,b,0); 

HOR 

a,b 

formatIVA'(f"HOR,a,b,0); 

HPEI 
HP I 

a,b 

formatIVA'(f"HPEI,a,b,i HPEI ); 
formatIVA'(f"HPI,0,0,0)7 

HR 

a,b 

formatV'(f HR,a,f2 HR,b,0,0,0,f6 HR); 

HRS 

a,m 

formatIVB'“f_HRS,a7m); 


Table 6-3b - Machine Code Instructions (Continued) 


6-44 


6.13 Machine Code Insertions 











Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


MACRO/L 


Ada/L 

HRT 

a,b 


formatlVA'(f HRT,a,b,0); 

HRZ 

a,m 


formatIVB'(f HRZ,a,m); 

HSCA 

a,b 


formatlVA'(f-HSCA,a,b,i HSCA ); 

HSCI 

af4,b 


formatlVA l'Tf HSCI,af4,b,i HSCI); 

HSCT 

af 4,b 


formatlVA 1*(f~HSCT,af4 r b,i HSCT); 

HSF 

a,b 


formatIVA T (f HSF,a,b,0); 

HSIM 

a,b 


formatlVA'(f“HSIM,a,b,i HSIM ); 

HSTC 

HST1 

HST2 

HST3 

HST4 

a, b 


formatlVA'(f HSTC,a,b,i~HSTC ); 
formatlVA'(f HSTl,a HSTl,b HSTl,i HST1); 
formatlVA'(f HST2,a HST2,b HST2,i HST2); 
formatlVA'(f HST3,a HST3,b HST3,i HST3); 
formatlVA’(f HST4,a HST4,b HST4,i HST4); 

HSTD 

a,b 


formatlVA’(f"HSTD,a,b,i HSTD ); 

HSTV 

a,b 


formatlVA'(f HSTV,a,b,i HSTV ); 

HV 

HWFI 

a,b 


formatV*(f HV,a,f2 HV,b7o,0,0,f6 HV); 
formatIVA'Tf HWFI,0,0,i HWFI ); 

HXOR 

a,b 


formatlVA’(f“HXOR,a,b,0); 

I BSC 

a 


formatlVA'(f~IBSC,a,0,i IBSC ); 

IILM 

a 


formatlVA'(f IILM,a,0,i IILM ); 

10 

a,y ,b,s 


formatI'(f 10,a,k IO,b,I,s,y); 

ICCL 

a 


formatlVA'(f IOCL,a,0,i IOCL ); 

I OCR 

a 


formatlVA'(f“lOCR,a,0,i IOCR ); 

IOCS 

a 


formatlVA*(f IOCS,a,0,i IOCS ); 

IOT 

a,b,m 


formatV'(f I0T,a,f2 IOT,b,0,0,m,f6 IOT ); 

IPI 

IR 

y,b,s 


formatl'(f_IPI,a_IPI,k_IPI,b,i,s,y); 
formatI'(f IR,0,i« IR,0,0,0,0); 

IRMMS 

a,b 


formatlVA'(f IRMMS,a,b,i IRMMS); 

IRMSR 

a,b 


formatlVA'(f IRMSR,a,b,i IRMSR ); 

ISMSR 

a,b 


formatlVA’(f ISMSR,a,b,i ISMSR ); 

ISP 

3l f b / m 


formatV'(f ISP,a,f2 ISP,b,0,0,m,f6 ISP ); 

J 

y»k,b,s 


formatlll'Tf J,l3 J,k,b,i,s,y); 

JBNZ 

a,y,k,b. 

s 

formatin’ (f JBNZ, a. Cl JBNZ, k, b, i, s ,y); 

JC 

a, y, k, b, 

s 

formatlll'lf JC,a,f3 JC,k,b,i,s,y); 

JE 

y,k,b,s 


formatIII'(f JE,a JE,f3 JE,k,b,i,s,y); 

JEP 

a,y,k,b. 

s 

formatlll'if JEP,a,f3 JEP,k,b,i,s,y); 

JG 

y»k,b,s 


formatlll'(f~JG,a JG,T3 JG,k,b,i,s,y); 

JGE 

y»k,b,s 


formatlll'if JGE,a JGE,?3 JGE,k,b,i,s,y); 

JL 

y#k,b,s 


formatlll'(f”JL,a,F3 JL,k7b,i,s,y); 

JLE 

y*k,b,s 


formatlll'if JLE,a JLE,f3 JLE,k,b,i,s,y); 

JLT 

y,k,b,s 


formatlll'(f~JLT,a JLT,f3 JLT,k,b,i,s,y); 

JN 

a,y,k,b, 

3 

formatin' (f"JN,a,?3 JN,k7b,i,s,y); 

JNE 

y»k,b,s 


formatin'(f JNE,a JNE,f3 JNE,k,b, i,s,y); 

JNF 

y,k,b,s 


formatin' (f"JNF,a”JNF,f3“JNF,k,b,i,s,y); 

JNW 

yrk,b,s 


formatin' (f“JNW,a~JNW,f3~JNW,k,b,i,s,y); 

JNZ 

a,y,k,b. 

3 

formatlll' i f__JNZ,a7f3_JNZ,k,b, i,s,y); 


Table 6-3c - Machine Code Instructions (Continued) 


6.13 Machine Code Insertions 


6-45 









Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


+ — —— — — — — — — — — — — — — — — — — — — — — — — — —— — — — - — — — —— — — • — ^ 

I MACRO/L Ada/L | 


+- 

1 

JOF 

y,k,b,s 

formatin' (f JOF,a JOF,f3 JOF, k, b, i, s, y); 

-+ 

1 

1 

JOP 

a,y,k,b,s 

formatill'(f~JOP,a7f3 JOP,k,b,i,s,y); 

1 


JP 

a,y,k,b,s 

formatin' (f~JP,a,f3 JP,k,b,i,s,y); 

1 


JS 

sy,k,b 

forraatlll’<f JS,0,f3 JS,k,b,i,s,y); 


1 

JSC 

a,y,k,b,s 

formatin' (f”jSC,a,fJ JSC,k,b, i,s,y) ; 

1 

1 

JW 

y,k,b,s 

formatlll'{f~JW,a JW,?3 JW,k,b,i,s,y); 

1 

1 

JZ 

a,y,k,b,s 

formatin'(f JZ,a,f3 JZ,k,b,i,s,y); 

1 

! 

LA 

a,y,k,b,s 

formatI'(f LA,a,k,b,r,s,y); 

1 

1 

LB 

a,y,k,b,s 

formatI'(f LB,a,k,b,i,s,y); 

1 

1 

LBJ 

a, y, k, b, s 

formatin'(f LBJ,a,f3 LBJ,k,b,i,s,y); 

1 

1 

LBMP 

a,y,b,s 

formatI'(f LBMP,a,k LBMP,b,i,s,y); 

1 

1 

LCI 

ak,y,b,s 

formatla'd LCI,ak,b,i,s,y); 

1 

1 

LCM1 

y,b,s 

formatl'(f LCMl,a LCMl,k LCMl,b,i LCMl,s,y); 

1 

1 

LCM2 

y,b,s 

formatl'(f LCM2,a LCM2,k LCM2,b,i~LCM2,s,y); 

1 

1 

LCM3 

y,b,s 

formatl'(f LCM3, a~LCM3, k LCM3,b, i““LCM3,s,y) ; 

1 

1 

LCM4 

y*b,s 

formatl'(f LCM4,a LCM4,k LCM4,b,i“LCM4,s,y) ; 

1 

1 

LCMA 

y,b,s 

formatl'(f LCMA,a LCMA, k LCMA,b, i~"LCMA,s,y) ; 

1 

1 

LCMP 

y,b,s 

formatl' (f-LCMP^^LCMP^ LCMP,b, i7s,y); 

1 

1 

LCMT 

y,b,s 

formatl'(f LCMT,a LCMT,k LCMT,b,i LCMT,s,y); 

1 

1 

LCPA 

a,y,b,s 

formatl '( f~LCPA,a7k LCPA,b,i,s,y)7 

1 

1 

LCRA 

a,y,b,s 

formatl'(f LCRA,a,k LCRA,b,i, s ,y ); 

1 

1 

LCT 

ak,y,b,s 

formatIa'(r LCT,ak,5,i,s,y )? 

1 

1 

LDIF 

a,y,k,b,s 

formatl'(f LDIF,a,k,b,i,s,y) ; 

1 

1 

LECM 


formatIVA’Tf LECM,a LECM,0,i LECM ); 

1 

1 

LIBP 

a,y,b,s 

formatl’ (f LIBP,a,k LIBP,b,i,s,y) ; 

1 

1 

LIM 

a,sy ,b 

formatIi'(? LIM,a,k LIM,b,i,sy) ; 

1 

1 

LIMP 

a,y ,b,s 

formatl'(f LIMP,a,k LIMP,b,i,s,y) ; 

1 

1 

LISR 

a,b 

formatIVA'Tf LISR,a,b,i LISR ); 

1 

1 

LLP 

a,y,b,s 

formatl '( f LLP,a,k LLP ,H, i,s,y ); 

1 

1 

LLPN 

a,y,b,s 

formatl' (f”LLPN,a,I« LLPN,b,i,s,y) ; 

1 


LM 

a,y,k,b,s 

formatl'(f LM,a,k,b7i,Sry) ; 


1 

LNA 

a,y,k,b,s 

formatl '( f~LNA,a,k,b,i,s,y) ; 

1 

1 

LRR 

a,m 

formatV' ( f LRR,a,f2 LRR,0,0,0,m,f6 LRR); 

1 

1 

LRRA 

a,b,i 

formatIVA’Tf LRRA,a,b,i ); 

1 


LSCM 


formatIVA' ( f"LSCM,a LSCM,0,i LSCM); 

1 

1 

LSUM 

a,y,k,b,s 

formatl'(f LSUM,a,k7b,i,s,y) ; 


1 

LTCM 


formatIVA'Tf LTCM,a LTCM,0,i LTCM ); 

1 

1 

LXB 

a,y,k,b,s 

formatI'(f LXB,a,k,B,i,s,y) ; 

1 

1 

M 

a,y,k,b,s 

formatl '( f~M,a,k,b,i,s,y) ; 

1 


MS 

a,y,b,s 

formatl '( f~MS,a,k MS,b,i,s,y); 


1 

NLP 

a,y,b,s 

formatl '( f NLP,a,k NLP,b,i,s,y ); 

1 

1 

OR 

a,y ,b,s 

formatl'(f~OR,a,k OR,b,i,s,y); 

1 

1 

PEI 

a,sy,b 

formatli’(? PEI,a7k PEI,b,i,sy); 

1 


PFCD 


formatIVA'(T PFCD,070,i PFCD ); 

1 

1 

+■— 

PFCE 


formatIVA’(f~PFCE,0,0,i~PFCE ); 

I 

■+ 


Table 6-3d - Machine Code Instructions (Continued) 


6-46 


6.13 Machine Code Insertions 













Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


+- 

I MACRO/L Ada/L 


+- 

1 

1 

PFR 

PIE 

a. 

y,b,s 

formatl'(f PFR,a,k PFR,b,i PFR,s,y); 
formatIVA'Tf PIE,0,0,i PIE); 

1 

PMM 

y> 

b,s 

formatl*(£_PMM,a_PMM,k_PMM,b,i,s,y); 
formatl' (f PMR,a“PMR,k“PMR,b,i,s,y); 

1 

PMR 

y> 

b, s 

1 

POP 

a, 

b 

formatV(f“POP,a,f2 POP,b,0,0,0,f6 POP); 

1 

PUSH 

a. 

b 

formatV’ (f_PUSH,a,fI^_PUSH,b,0,0,0,F6_PUSH ) ; 
formatI'(f RA,a,k,b,I,s,y); 

1 

RA 

a. 

y,k,b,s 

1 

RALP 

a. 

y,b,s 

formatl'jf RALP,a,k RALP,b,i,s,y); 

1 

RAN 

a. 

y,k,b,s 

formatl'(f RAN,a,k,E,i,s,y); 


RCCR 

y> 

b,s 

formatl'(f RCCR,a RCCR,k RCCR,b,i,s,y); 

1 

RD 

a. 

y,k,b,s 

formatl'(£ RD,a,k,b,i,s,y); 

1 

RI 

a. 

y,k,b,s 

formatI'(f RI,a,k,b,i,s,y); 

1 

RIOAS 

a. 

b 

formatIVA*“f RIOAS,a,b,i RIOAS); 


RISR 

a. 

b 

formatIVA*(f“RISR,a,b,i RISR ); 

1 

RJ 

y* 

k,b,s 

formatin' (£ RJ,a RJ,f3 RJ,k,b, i,s,y); 

1 

RJC 

a. 

y,k,b,s 

formatin' (f~RJC,a,£3 RJC,k,b, i,s,y); 

1 

RJSC 

a. 

y,k,b,s 

formatin' (f“RJSC,a,f! RJSC,k,b, i ,s,y); 

1 

RLP 

a. 

y,b,s 

formatI'(f RLP,a,k RLP,b,i,s,y); 


RMMS 

a, 

bi 

formatIVA'(f RMMS,a,b,i); 

1 

RMS 

a. 

y,b,s 

formatl'(f RMS,a,k RMS,b,i,s,y); 

1 

RMSR 

y- 

b,s 

formatl'(f~RMSR,a RMSR,k RMSR,b,i,a,y); 

I 

RNLP 

a. 

y,b,s 

formatl'(f“RNLP,a7k RNLP,b,i,s,y); 


ROR 

a, 

y,b,s 

formatl'(f~ROR,a,k ROR,b,i,s,y); 

1 

RP 

a. 

sy,b 

formatIi'(F RP,a,k~RP,b,i,sy); 

1 

RPD 

Y> 

k,b,s 

formatl'(f RPD,a RPD,k,b,i,s,y); 

1 

RRR 

a, 

m 

formatV'(f“RRR,a,f2 RRR,0,0,0,m,f6 RRR ); 

1 

RSC 

a, 

cr 

u 

formatl'(f”RSC,a,k RSC,b,i,s,y); 

1 

RSO 

a 


formatIVA'Tf RSD,a,0,i RSD); 


RXOR 

a, 

y,b,s 

formatl'(f RXOR,a,k RXOR,b,i,s,y); 


SA 

a, 

y#k,b,s 

formatl*(f~SA,a,k,b,i,s,y); 

1 

SB 

a, 

y,k,b,s 

formatl'(f“SB,a,k,b,i,s,y); 

1 

SBN 

a, 

n 

formative(f SBN,a,f4 SBN,n); 

1 

SBPC 

a. 

y#k,b,s 

formatI'(f SBPC,a,k,b,i,s,y); 

1 

SC 

a, 

y,b,s 

formatl'(f“SC,a,k SC,b,i,s,y); 

1 

SCI 

ak 

»y,b,s 

formatIa'(7 SCI,aiT,b,i,s,y); 

1 

SCMA 

y» 

b, s 

formatl' (f SCMA,a SCMA,k SCMA,b,i SCMA,s,y); 

1 

SCMP 

Y' 

b,s 

formatl'(f SCMP,a SCMP,k SCMP,b,i,s,y); 

1 

SCMT 

Y' 

b,s 

formatl'(ff“SCMT,a"SCMT,k SCMT,b,i SCMT,s,y); 

1 

SCM1 

Y> 

b,s 

formatl’(f“SCMl,a SCMl,k SCMl,b,i SCMl,s,y); 

1 

SCM2 

y» 

b,s 

formatl'(f SCM2,a“SCM2,k SCM2,b,i SCM2,s,y); 

1 

SCM3 

y» 

b,s 

formatl’(f“SCM3,a“SCM3,k SCM3,b,i SCM3,s,y); 

i 

SCM4 

Y> 

b, s 

formatl’(f SCM4,a SCM4,k SCM4,b,i SCM4,s,y); 

i 

SCPA 

a, 

y,b,s 

formatl'(f”SCPA,a7k SCPA,b,i,s,y); 

i 

SCRA 

a, 

y,b,s 

formatl'(f“SCRA,a,k SCRA,b,i,s,y); 

i 

SCSR 

Y> 

b,s 

formatl'(f“SCSR,a_S?SR,k_SCSR,b,i,s,y); 


Table 6-3e - Machine Code Instructions (Continued) 


6.13 Machine Code Insertions 


6-47 









Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


MACRO/L 

SCT 

ak,y,b,s 

SDIF 

a,y,b,s 

SDMC 

a 

SIBP 

a,y,b,s 

SIMC 

a, b 

SIMP 

a,y,b,s 

SIRC 

a,b 

SITC 

a,b 

SLP 

a,y,b,s 

SM 

a,y,k,b,s 

SMCC 

a 

SMSR 

y,b,s 

SNA 

a,y,k,b,s 

SRRA 

a, b, i 

SSUM 

a,y,b,s 

STAF 

a,b 

STSB 

ak,y,b,s 

SXB 

a,y,k,b,s 

TBN 

a,n 

TR 

a,b 

TSBN 

a, n 

TSF 

y»b,s 

TSM 

bi 

TV 

a,b 

WFBP 

a,y ,b,s 

WFM 

a,y,b,s 

XOR 

a,y,b,s 

XR 

y/b,s 

XRL 

y,b,s 

XS 

sy,b 


Ada/L 


formatla'(f_SCT,ak,b,i,s,y); 

formatl'(f_SDIF,a,k_SDIF,b,i,s,y); 

formatIVA'(f_SDMC,a,0,i_SDMC ); 

formatI’(f SIBP,a,k SIBP,b,i,s,y) ; 

formatIVA'7f_SIMC,a7b,i_SIMC ); 

formatl’(f_SIMP,a,k SIMP,b,i,s,y); 

formatIVA'(f SIRC,a7b,i SIRC ); 

formatlVA*(f~SITC,a,b,i^SITC ); 

formatl'(f_SLP,a,k_SLP,b,i,s,y); 

formatl'(f_SM,a,k,b,i,s,y); 

formatIVA'(f_SMCC,a,0,i_SMCC ); 

formatl'(f_SMSR,a_SMSR,k_SMSR,b,i,s,y); 

formatl’(f~SNA,a,k,b,i,s,y); 

formatIVA'7f_SRRA,a,b,i); 

formatl'(f SSUM,a,k SSUM,b,i,s,y); 

formatV'(f~STAF,a,f! STAF,b,0,0,0,f6_STAF); 

formatla'(?_STSB,ak,E,i,s,y); 

formatl'(f_SXB,a,k,b,i,s,y); 

formative*(f_TBN,a,f4_TBN,n); 

formatV'(f_TR,a,f2_TR,b,0,0,0,f6_TR); 

formatIVC'(f_TSBN,a,f4_TSBN,n); 

formatl'(f_TSF,0,k_TSF,b,i,s,y); 

formatIVA'(f_TSM ,a_TSM,b,i); 

formatV'(f_TV,a,f2_TV,b,0,0,0,f6_TV); 

formatl'(f~WFBP,a,k WFBP,b,i_WFBP,s,y); 

formatl'(f~WFM,a,k_WFM,b,i_WFM,s,y)? 

formatl'(f~XOR,a,k_XOR,b,i,s,y); 

formatl'(f_XR,0,k_XR,b,i,s,y); 

formatl'(f_XRL,0,k_XRL,b,i,s,y); 

formatl'(f XS,a XS,k_XS,b,i,sy); 


-t 


Table 6-3f - Machine Code Instructions (Continued) 


6-48 


6.13 Machine Code Insertions 















APPENDIX C 


TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, 
such as the maximum length of an input line and invalid file names. A 
test that makes use of such values is identified by the extension .TST 
in its file name. Actual values to be substituted are represented by 
names that begin with a dollar sign. A value must be substituted for 
each of these names before the test is run. The values used for this 
validation are given below. 


C-l 











(BLANKS 

A SKJUKNCB OP ((MAX IN LBN - 20) BLANKS. 

USBD INi B22001A B22001B B22001C B22001D B22001B B22001F 

B22001C B22001I B22001J B22001K B22001L B22001H 











*.”»X 1NT PLUS 1 

AN INTEGER LITERAL WHOSE ' aLUB IS SYSTEM .MAX I NT 
USED IN: C46232A 
: I NT PLUS 1 0223372036864776808 



















APPENDIX D 


WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to 
the Ada Standard. The following 44 tests had been withdrawn at the time 
of validation testing for the reasons indicated. A reference of the 
form Al-ddddd is to an Ada Commentary. 

A39005G 

This test unreasonably expects a component clause to pack an array 
component into a minimum size (line 30). 

B97102E 

This test contains an unintended illegality: a select statement 
contains a null statement at the place of a selective wait alternative 
(line 31). 

C97116A 

This test contains race conditions, and it assumes that guards are 
evaluated indivisibly. A conforming implementation may use interleaved 
execution in such a way that the evaluation of the guards at lines 50 & 
54 and the execution of task CHANGING_OF_THE_GUARD results in a call to 
REPORT.FAILED at one of lines 52 or 56. 

BC3009B 

This test wrongly expects that circular instantiations will be detected 
in several compilation units even though none of the units is illegal 
with respect to the units it depends on; by AI-00256, the illegality 
need not be detected until execution is attempted (line 95). 

CD2A62D 

This test wrongly requires that an array object's size be no greater 
than 10 although its subtype's size was specified to be 40 (line 137). 

CD2A63A..D, CD2A66A..D, CD2A73A.,D, CD2A76A..D [16 tests] 

These tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them to a 
derived subprogram (which implicitly converts them to the parent type 
(Ada standard 3.4:14)). Additionally, they use the 'SIZE length clause 
and attribute, whose interpretation is considered problematic by the WG9 
ARG. 

CD2A81G, CD2A83G, CD2A84M & N, & CD50110 

These tests assume that dependent tasks will terminate while the main 
program executes a loop that simply tests for cask termination; this is 
not the case, and the main program may loop indefinitely (lines 74, 85, 
86 & 96, 86 & 96, and 58, resp.). 


D-l 







CD2B15C & CD7205C 

These tests expect that a 'STORAGE_SIZE length clause provides precise 
control over the number of designated objects in a collection; the Ada 
standard 13.2:15 allows that such control must not be expected. 

CD2D11B 

This test gives a SMALL representation clause for a derived fixed-point 
type (at line 30) that defines a set of model numbers that are not 
necessarily represented in the parent type; by Commentary AI-00099, all 
model numbers of a derived fixed-point type must be representable values 
of the parent type. 

CD5007B 

This test wrongly expects an implicitly declared subprogram to be at the 
address that is specified for an unrelated subprogram (line 303). 

ED7004B, ED7005C & D, ED7006C & D [5 tests] 

These tests check various aspects of the use of the three SYSTEM 
pragmas; the AVO withdraws these tests as being inappropriate for 
validation. 

CD7105A 

This test requires that successive calls to CALENDAR.CLOCK change by at 
least SYSTEM.TICK; however, by Commentary AI-00201, it is only the 
expected frequency of change that must be at least SYSTEM.TICK -- 
particular instances of change may be less (line 29). 

CD7203B, & CD7204B 

These tests use the 'SIZE length clause and attribute, whose 
interpretation is considered problematic by the WG9 ARG. 

CD7205D 

This test checks an invalid test objective: it treats the specification 
of storage to be reserved for a task's activation as though it were like 
the specification of storage for a collection. 

CE2107I 

This test requires that objects of two similar scalar types be 
distinguished when read from a file--DATA_ERROR is expected to be raised 
by an attempt to read one object as of the other type. However, it is 
not clear exactly how the Ada standard 14.2.4:4 is to be interpreted; 
thus, this test objective is not considered valid. (line 90) 

CE3111C 

This test requires certain behavior, when two files are associated with 
the same external file, that is not required by the Ada standard. 

CE3301A 

This test contains several calls to END_0F_LINE & END_0F_PAGE that have 
no parameter: these calls were intended to specify a file, not to refer 
to STANDARD_INPUT (lines 103, 107, 118, 132, & 136). 


D-2 







CE3411B 

This test requires that a text file's column number be set to COUNT'LAST 
in order to check that LAYOUT_ERROR is raised by a subsequent PUT 
operation. But the former operation vill generally raise an exception 
due to a lack of available disk space, and the test would thus encumber 
validation testing. 

E28005C 

This test expects that the string TOP OF PAGE. --63" of line 204 
will appear at the top of the listing page due to a pragma PAGE in line 
203; but line 203 contains text that follows the pragma, and it is this 
that must appear at the top of the page. 


D-3 










APPENDIX E 


Compiler: 

ACVC Version: 


COMPILER OPTIONS AS SUPPLIED BY 
U.S. NAVY 

Ada/L, Version 2.0 (/NO_OPTIMIZE 

Option) 

1.10 


E-l 




Ada/L PSE Handbook 


Version 2. QC 
30 September 1989 


10.2 Options 

Options control the type of processing the compiler 
performs. They enable the selection of listings produced as pare 
of the compilation process, make special processing requests, and 
indicate when special compilation units are being compiled. The 
compiler options, their functions and defaults are summarized in 
Table 10-1. Each option may be specified as shown or preceded by 
the three characters "NO^ 1 to specify the opposite option. For 
example, SOURCE turns the source listing on; NO_SOURCE turns the 
source listing off. 

The following error conditions are detected by the compiler 
during option processing. In each case, the compiler issues a 
WARNING diagnostic and takes the action indicated. 

a. The complement of an already-specified option is 
specified; the last option is honored. For example, 
if NO_SOURCE is specified, followed by SOURCE later 
in the option list, SOURCE is the option that will be 
in effect. 

b. An option is specified more than once. The last 
occurrence of the option is honored; all others are 
ignored. 

c. An undefined option is specified. The option is 
ignored. 

The compiler does not check options for redundant 
directions. For example, no error is reported when both 
NO_SOURCE and NO_PRIVATE are specified in the same compiler 
invocation. 

Some options impact the speed with which the compilation 
process is completed and the efficiency of the object code 
produced by the compiler. The remainder of this section 
discusses the implications of options for the compilation 
process, how options affect the quality of object code generated 
by the compiler, and guidelines for using them. 


10.2 Options 


10-03 






Version 2.0C Ada/L PSE Handbook 

30 September 1989 


Option Function 


Listing Control Options: 

ATTRIBUTE Produce a Symbol Attribute Listing. (Produces an 

attribute cross-reference listing when both 
ATTRIBUTE and CROSS REFERENCE are specified.) 
Default: NO_ATTRIBUTE 

CROSS_REFERENCE Produce a Cross-Reference Listing. (Produces an 
attribute cross-reference listing when both 
ATTRIBUTE and CROSS_REFERENCE are specified.) 
Default: NO_CROSS_REFERNCE 

DIAGNOSTICS Produce a Diagnostic Summary Listing. 

Default: NO_DIAGNOSTICS 

MACHINE Produce a Machine Code Listing if code is 

generated. Code is generated when 
CONTAINERJ3ENERATION option is in effect and (1) 
there are""no diagnostics of severity ERROR, SYSTEM 
or FATAL (2) NO_CODE_ON_WARNING option is in effect 
and there are no diagnostics of severity higher 
than NOTE. A diagnostic of severity NOTE is 
reported when a Machine Code Listing is requested 
and no code is generated. OCTAL is an additional 
option that may be used with MACHINE to output 
octal values on the listing instead of hex values. 
Default: NO_MACHINE 

NOTES Include diagnostics of NOTE severity level in the 

Source Listing and Diagnostic Summary Listing. 
Default: NO_NOTES 

PRIVATE If there is a Source Listing, text in the private 

part of a package specification is listed in 
accordance with the selected SOURCE option, subject 
to requirements of LIST pragmas. Default: PRIVATE. 

SOURCE Produce listing of Ada source statements. 

Default: NO_SOURCE 

SUMMARY Produce a Summary Listing; always produced when 

there are errors in the compilation. 

Default: NO SUMMARY 


Table 10-la - Ada Compiler Options 


10-04 


10.2 Options 














Ada/L PSE Handbook 


Version 2.0C 
30 September 1989 


Option Function 


Special Processing Options: 

CHECKS Provide run-time error checking. 

NO_CHECKS suppresses all run-time error 
checking. Please refer to the Pragma 
SUPPRESS description for further information 
on run-time error checking. 

Default: CHECKS 

CODE_ON_WARNING Generate code (and Machine Code Listing, if 

requested) only when there are no diagnostics 
of a severity higher than WARNING. 

NO_CODE_ON_WARNING means no code is generated 
when there"~is a diagnostic of severity WARNING 
or higher (i.e., ERROR, SYSTEM, or FATAL). 
Default: CODE_ON_WARNING 

CONTAINER_GENERATION 

Produce a container if diagnostic severity 
permits. NO_CONTAINER_GENERATION means that no 
container is~produced even if there are no 
diagnostics. No code (or Machine Code Listing, 
if requested) is generated if a container is not 
produced because the NO_CONTAlNER_GENERATION 
option is in effect. 

Default: CONTAINER_GENERATION 

DEBUG Include in compiler output only that information 

needed to link, export, and execute the current 
unit. This option is ignored for a unit that: 

o is a package or subprogram specification, 
o is a subprogram body for which there is 
no previous declaration, or 
o contains a body stub, pragma INLINE, 
generic declaration, or a generic body. 

If DEBUG is used, internal representations are 
stored in the container as well as additional 
symbolic information. 

A diagnostic of severity NOTE is issued when 
the option is ignored. 

Default: NO DEBUG 


Table 10-lb - Ada Compiler Options (Continued) 


10.2 Options 


10-05 














Version 2.0C 
30 September 1989 


Ada/L PSE Handbook 


Option Function 


Special Processing Options (continued): 

EXECUTIVE Enable pragma EXECUTIVE and allow visibility 

to units which have been compiled with the 
/RTE ONLY option. 

Default: NO_EXECUTIVE. 

MEASURE Deferred. 

OPTIMIZE Enable global optimizations in accordance with 

the optimization pragmas specified in the source 
program. When NO_OPTIMIZE is in effect, no 
global optimizations are performed, regardless 
of the pragmas specified. The optimize option 
enables global optimization. The goals of global 
optimization may be influenced by the user 
through the Ada defined optimize pragma. 

If time is specified, the optimizer concentrates 
on optimizing code execution time. If space is 
specified, the optimizer concentrates on 
optimizing code size. If the user does not 
include pragma optimize, the global optimizer 
tends to optimize time over space. 

Default: NOJ3PTIMIZE 

RTE_ONLY Restrict visibility of this unit only to those 

units compiled with the /EXECUTIVE option. 
Default: NOT RTE ONLY. 


Table 10-lc - Ada Compiler Options (Continued) 


10-06 


10.2 Options 









